unint64_t CMYKf16_mark_pixelmask(unint64_t result, uint64_t a2, __n128 _Q0, double a4, __n128 _Q2, __n128 a6, float32x4_t _Q4, float32x4_t _Q5, float16x4_t a9, double _D7, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  __int16 *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  float16x4_t *v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  int v35;
  float16x4_t *v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  float16x4_t *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unsigned int v47;
  float v49;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __int16 *v61;
  uint64_t v62;
  int v63;
  int v64;
  unsigned int v65;
  float v67;
  float16x4_t *v73;
  __int16 *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __int16 *v84;
  int v85;
  int v86;
  unsigned int v87;
  float v93;
  float16x4_t *v100;
  __int16 *v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  __int16 *v112;
  int v113;
  int v114;
  unsigned int v115;
  float v132;
  float v135;
  float v137;
  float16x4_t *v143;
  __int16 *v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  __int16 *v155;
  int v156;
  int v157;
  unsigned int v158;
  float v178;
  float v182;
  float v183;
  float16x4_t *v186;
  __int16 *v187;
  unint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  __int16 *v198;
  int v199;
  int v200;
  float v203;
  float16x4_t *v209;
  __int16 *v210;
  unint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  __int16 *v221;
  int v222;
  int v223;
  unsigned int v224;
  float v227;
  float v228;
  float v231;
  float16x4_t *v236;
  __int16 *v237;
  unint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  __int16 *v247;
  int v248;
  int v249;
  unsigned int v250;
  float v268;
  float16x4_t *v287;
  __int16 *v288;
  unint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  __int16 *v298;
  int v299;
  int v300;
  unsigned int v301;
  float v320;
  float16x4_t *v335;
  __int16 *v336;
  unint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  __int16 *v347;
  int v348;
  int v349;
  float v352;
  float v357;
  float16x4_t *v359;
  __int16 *v360;
  unint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  __int16 *v371;
  int v372;
  int v373;
  float v376;
  float16x4_t *v382;
  __int16 *v383;
  unint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  __int16 *v393;
  int v394;
  int v395;
  float v421;
  float v425;
  float v429;
  float v431;
  float v435;
  float16x4_t *v439;
  __int16 *v440;
  unint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  __int16 *v450;
  int v451;
  int v452;
  float32x4_t v456;
  float16x4_t v462;
  float16x4_t *v463;
  __int16 *v464;
  unint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  __int16 *v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  int v475;
  float v478;
  __n128 v479;
  __n128 v480;
  int32x2_t v481;
  unsigned __int32 v484;
  unint64_t v485;
  unint64_t v486;
  float16x4_t *v487;
  uint64_t v488;
  unint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  __int16 *v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  int v498;
  float v501;
  __n128 v502;
  __n128 v503;
  int32x2_t v504;
  unsigned __int32 v507;
  unint64_t v508;
  unint64_t v509;
  float16x4_t *v510;
  uint64_t v511;
  unint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  __int16 *v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  int v521;
  float v524;
  __n128 v525;
  __n128 v526;
  int32x2_t v527;
  unsigned __int32 v530;
  unint64_t v531;
  unint64_t v532;
  float16x4_t *v533;
  uint64_t v534;
  unint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  __int16 *v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  int v544;
  float v547;
  __n128 v548;
  __n128 v549;
  __int32 v551;
  unint64_t v552;
  unint64_t v553;
  float16x4_t *v554;
  uint64_t v555;
  unint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  __int16 *v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  int v565;
  float v568;
  __n128 v569;
  __n128 v570;
  __int32 v572;
  unint64_t v573;
  unint64_t v574;
  float16x4_t *v575;
  uint64_t v576;
  unint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  uint64_t v581;
  __int16 *v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  int v586;
  float v589;
  __n128 v590;
  __n128 v591;
  int32x2_t v592;
  unsigned __int32 v595;
  unint64_t v596;
  unint64_t v597;
  float16x4_t *v598;
  uint64_t v599;
  unint64_t v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  __int16 *v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  int v609;
  float v612;
  __n128 v613;
  __n128 v614;
  int32x2_t v615;
  unsigned __int32 v618;
  unint64_t v619;
  unint64_t v620;
  float16x4_t *v621;
  uint64_t v622;
  unint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  __int16 *v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  int v632;
  float v635;
  __n128 v636;
  __n128 v637;
  int32x2_t v638;
  unsigned __int32 v640;
  unint64_t v641;
  unint64_t v642;
  float16x4_t *v643;
  uint64_t v644;
  unint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  __int16 *v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  int v654;
  float v657;
  __n128 v658;
  __n128 v659;
  int32x2_t v660;
  unsigned __int32 v663;
  unint64_t v664;
  unint64_t v665;
  float16x4_t *v666;
  uint64_t v667;
  unint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  __int16 *v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  int v677;
  float v680;
  __n128 v681;
  __n128 v682;
  int32x2_t v683;
  unsigned __int32 v685;
  unint64_t v686;
  unint64_t v687;
  float16x4_t *v688;
  uint64_t v689;
  unint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  __int16 *v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  int v699;
  float v702;
  __n128 v703;
  __n128 v704;
  int32x2_t v705;
  unsigned __int32 v707;
  unint64_t v708;
  unint64_t v709;
  float16x4_t *v710;
  uint64_t v711;
  unint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  __int16 *v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  int v721;
  float v724;
  __n128 v725;
  __n128 v726;
  int32x2_t v727;
  unsigned __int32 v730;
  unint64_t v731;
  unint64_t v732;
  float16x4_t *v733;
  uint64_t v734;
  unint64_t v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  __int16 *v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  int v744;
  float v747;
  __n128 v748;
  __n128 v749;
  int32x2_t v750;
  unsigned __int32 v753;
  unint64_t v754;
  unint64_t v755;
  float16x4_t *v756;
  uint64_t v757;
  unint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  __int16 *v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  int v767;
  float v770;
  __n128 v774;
  __n128 v775;
  unint64_t v777;
  unint64_t v778;
  float16x4_t *v779;
  uint64_t v780;
  unint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  __int16 *v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  int v790;
  float v793;
  __n128 v794;
  __n128 v795;
  int32x2_t v796;
  unsigned __int32 v799;
  unint64_t v800;
  unint64_t v801;
  float16x4_t *v802;
  uint64_t v803;
  unint64_t v804;
  uint64_t v805;
  uint64_t v806;
  int v807;
  int v808;
  unsigned int v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  uint64_t v813;
  int v814;
  int v815;
  unsigned int v816;
  float16x4_t v817;
  float16x4_t *v818;
  uint64_t v819;
  unint64_t v820;
  uint64_t v821;
  float16x4_t *v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  __int16 *v826;
  int v827;
  unsigned int v828;
  float16x4_t v831;
  float v832;
  float16x4_t *v837;
  __int16 *v838;
  uint64_t v839;
  unint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  __int16 *v848;
  int v849;
  unsigned int v850;
  float v865;
  float16x4_t *v880;
  __int16 *v881;
  uint64_t v882;
  unint64_t v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  __int16 *v889;
  int v890;
  unsigned int v891;
  float v907;
  float16x4_t *v919;
  __int16 *v920;
  uint64_t v921;
  unint64_t v922;
  uint64_t v923;
  uint64_t v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  uint64_t v928;
  uint64_t v929;
  __int16 *v931;
  int v932;
  float v934;
  float16x4_t *v935;
  __int16 *v936;
  uint64_t v937;
  unint64_t v938;
  uint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  uint64_t v943;
  int v944;
  int v945;
  float16x4_t *v946;
  uint64_t v947;
  unint64_t v948;
  uint64_t v949;
  float16x4_t *v950;
  uint64_t v951;
  uint64_t v952;
  uint64_t v953;
  int v954;
  int v955;
  unsigned int v956;
  float v958;
  float16x4_t *v962;
  uint64_t v963;
  unint64_t v964;
  unint64_t v965;
  uint64_t v966;
  float16x4_t *v967;
  uint64_t v968;
  float16x4_t v969;
  float16x4_t v970;
  __int32 v971;
  uint64_t v972;
  uint64_t v973;
  uint64_t v974;
  uint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  uint64_t v979;
  uint64_t v980;
  uint64_t v981;
  uint64_t v982;
  uint64_t v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  uint64_t v987;
  uint64_t v988;
  uint64_t v989;
  uint64_t v990;
  uint64_t v991;
  uint64_t v992;
  uint64_t v993;
  uint64_t v994;
  uint64_t v995;
  uint64_t v996;
  uint64_t v997;
  uint64_t v998;
  uint64_t v999;
  uint64_t v1000;
  uint64_t v1001;
  uint64_t v1002;
  uint64_t v1003;
  uint64_t v1004;
  uint64_t v1005;
  uint64_t v1006;
  uint64_t v1007;
  uint64_t v1008;
  uint64_t v1009;
  uint64_t v1010;
  uint64_t v1011;
  uint64_t v1012;
  uint64_t v1013;
  uint64_t v1014;
  uint64_t v1015;
  uint64_t v1016;
  uint64_t v1017;
  uint64_t v1018;
  uint64_t v1019;
  uint64_t v1020;
  uint64_t v1021;
  uint64_t v1022;
  uint64_t v1023;
  uint64_t v1024;
  uint64_t v1025;
  uint64_t v1026;
  uint64_t v1027;
  uint64_t v1028;
  uint64_t v1029;
  uint64_t v1030;
  uint64_t v1031;
  unint64_t v1032;
  unint64_t v1033;
  unint64_t v1034;
  uint64_t v1035;
  unint64_t v1036;
  int v1037;
  unint64_t v1038;
  __int16 *v1039;
  unint64_t v1040;
  int v1041;
  uint64_t v1042;
  uint64_t v1043;

  v16 = *(_QWORD *)(result + 48);
  v17 = *(_QWORD *)(result + 136);
  v19 = *(int *)(result + 12);
  v18 = *(int *)(result + 16);
  if (v16)
  {
    v20 = (unint64_t)*(int *)(result + 32) >> 1;
    v21 = (__int16 *)(v16 + 2 * (v19 + v20 * v18));
    v22 = 0xFFFFFFFFLL;
    if (!v17)
      return result;
  }
  else
  {
    v21 = 0;
    v20 = 0;
    v22 = 0;
    if (!v17)
      return result;
  }
  v23 = *(unsigned int *)(result + 4);
  v24 = *(_DWORD *)(result + 8);
  v26 = *(_QWORD *)(result + 88);
  v25 = *(_QWORD *)(result + 96);
  v27 = (unint64_t)*(int *)(result + 28) >> 3;
  v28 = (float16x4_t *)(*(_QWORD *)(result + 40) + 8 * (v19 + v27 * v18));
  v29 = *(int *)(result + 124);
  v30 = (_BYTE *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v29);
  v31 = *(int *)(result + 56);
  v32 = *(int *)(result + 60);
  v33 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    v34 = *(_DWORD *)(result + 64);
    v35 = *(_DWORD *)(result + 68);
    v1038 = v33 >> 3;
    v1039 = *(__int16 **)(result + 96);
    if (v25)
    {
      v1036 = (unint64_t)*(int *)(result + 80) >> 1;
      v25 = 1;
    }
    else
    {
      v1036 = 0;
    }
    result = v26 + 8 * v1038 * v35;
    v22 &= 1u;
    v38 = 1;
    v1040 = v26;
    v36 = (float16x4_t *)v26;
    goto LABEL_19;
  }
  v1038 = v33 >> 3;
  if (v25)
  {
    v1036 = (unint64_t)*(int *)(result + 80) >> 1;
    v1039 = (__int16 *)(v25 + 2 * (v31 + v1036 * v32));
    v25 = 0xFFFFFFFFLL;
  }
  else
  {
    v1039 = 0;
    v1036 = 0;
  }
  v36 = (float16x4_t *)(v26 + 8 * (v31 + v1038 * v32));
  if (v1038 == v27 && (char *)v28 - (char *)v36 >= 1)
  {
    if ((int)v23 >= (uint64_t)((unint64_t)((char *)v28 - (char *)v36) >> 3))
    {
      v28 += (int)v23 - 1;
      v36 += (int)v23 - 1;
      v30 += (int)v23 - 1;
      v21 += (int)(v22 & (v23 - 1));
      v38 = -1;
      v1038 = (unint64_t)*(int *)(result + 28) >> 3;
      v1039 += (int)(v25 & (v23 - 1));
      goto LABEL_16;
    }
    v37 = v24 - 1;
    if (v28 <= &v36[v27 * v37 - 1 + (int)v23])
    {
      v28 += v27 * v37;
      v30 += v29 * v37;
      v29 = -v29;
      v21 += v20 * v37;
      v20 = -(uint64_t)v20;
      v22 &= 1u;
      v1038 = -(uint64_t)v27;
      v1039 += v1036 * v37;
      v1036 = -(uint64_t)v1036;
      v25 &= 1u;
      v38 = 1;
      v36 += v27 * v37;
      v27 = -(uint64_t)v27;
      goto LABEL_16;
    }
  }
  v22 &= 1u;
  v25 &= 1u;
  v38 = 1;
LABEL_16:
  result = 0;
  v1040 = 0;
  v26 = -1;
  v35 = v1036;
  v34 = v1038;
LABEL_19:
  v39 = v38 * v23;
  v1037 = v23;
  v1033 = result;
  v1041 = v24;
  if (result)
  {
    v40 = (int)v32 % v35;
    v41 = &v36[v1038 * v40];
    result = (int)v31 % v34;
    v36 = &v41[result];
    v26 = (unint64_t)&v41[v34];
    v42 = v1036 * v40;
    v43 = (uint64_t)v1039;
    v44 = (uint64_t)&v1039[v42 + result];
    if ((v25 & 1) != 0)
      v43 = v44;
    v1039 = (__int16 *)v43;
    v1040 = (unint64_t)&v41[result];
  }
  else
  {
    v1038 -= v39;
    v1036 -= (int)v25 * (int)v23;
  }
  v1035 = v29 - v39;
  v1034 = v27 - v39;
  v1032 = v20 - (int)v22 * (int)v23;
  v1042 = v25;
  v1043 = v22;
  switch((int)a2)
  {
    case 0:
      if ((_DWORD)v22)
      {
        do
        {
          v45 = v23;
          v46 = v1041;
          do
          {
            v47 = *v30;
            if (*v30)
            {
              if (v47 == 255)
              {
                *v28 = 0;
                _H2 = 0;
              }
              else
              {
                v49 = (float)((float)v47 * -0.0039216) + 1.0;
                *v28 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), v49));
                _H3 = *v21;
                __asm { FCVT            S3, H3 }
                _S2 = v49 * _S3;
                __asm { FCVT            H2, S2 }
              }
              *v21 = _H2;
            }
            v30 += v38;
            v21 += (int)v22;
            v28 += v38;
            --v45;
          }
          while (v45);
          v30 += v1035;
          v28 += v1034;
          v21 += v1032;
          --v1041;
        }
        while (v46 != 1);
      }
      else
      {
        do
        {
          v807 = v23;
          v808 = v1041;
          do
          {
            v809 = *v30;
            if (*v30)
            {
              if (v809 == 255)
                *v28 = 0;
              else
                *v28 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), (float)((float)v809 * -0.0039216) + 1.0));
            }
            v30 += v38;
            v28 += v38;
            --v807;
          }
          while (v807);
          v30 += v1035;
          v28 += v1034;
          --v1041;
        }
        while (v808 != 1);
      }
      return result;
    case 1:
      if ((_DWORD)v22)
      {
        v57 = v38;
        if ((_DWORD)v25)
        {
          v58 = v35;
          v59 = -(uint64_t)(v1038 * v35);
          v60 = -(uint64_t)(v1036 * v58);
          v61 = v1039;
          v62 = -(uint64_t)v34;
          do
          {
            v63 = v1037;
            v64 = v1041;
            do
            {
              v65 = *v30;
              if (*v30)
              {
                if (v65 == 255)
                {
                  *v28 = *v36;
                  _H2 = *v61;
                }
                else
                {
                  v67 = (float)v65 * 0.0039216;
                  *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), 1.0 - v67), vcvtq_f32_f16(*v36), v67));
                  _H4 = *v61;
                  __asm { FCVT            S4, H4 }
                  _H5 = *v21;
                  __asm { FCVT            S5, H5 }
                  _S2 = (float)((float)(1.0 - v67) * _S5) + (float)(_S4 * v67);
                  __asm { FCVT            H2, S2 }
                }
                *v21 = _H2;
              }
              v30 += v57;
              v73 = &v36[v57];
              v74 = &v61[(int)v25];
              if ((unint64_t)v73 >= v26)
                result = v62;
              else
                result = 0;
              v61 = &v74[result];
              v36 = &v73[result];
              v21 += (int)v22;
              v28 += v57;
              --v63;
            }
            while (v63);
            if (v1033)
            {
              result = v1038;
              v75 = v1040 + 8 * v1038;
              if (v75 >= v1033)
                v76 = v60;
              else
                v76 = 0;
              v77 = (uint64_t)&v1039[v1036 + v76];
              if (v75 >= v1033)
                v78 = v59;
              else
                v78 = 0;
              v36 = (float16x4_t *)(v75 + 8 * v78);
              v26 += 8 * v78 + 8 * v1038;
              v1039 += v1036 + v76;
              v1040 = (unint64_t)v36;
              v61 = (__int16 *)v77;
            }
            else
            {
              v36 += v1038;
              v61 += v1036;
            }
            v30 += v1035;
            v28 += v1034;
            v21 += v1032;
            --v1041;
          }
          while (v64 != 1);
        }
        else
        {
          v952 = -(uint64_t)v34;
          v953 = -(uint64_t)(v1038 * v35);
          result = v1033;
          do
          {
            v954 = v23;
            v955 = v1041;
            do
            {
              v956 = *v30;
              if (*v30)
              {
                if (v956 == 255)
                {
                  *v28 = *v36;
                  _H3 = 15360;
                }
                else
                {
                  v958 = (float)v956 * 0.0039216;
                  *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), 1.0 - v958), vcvtq_f32_f16(*v36), v958));
                  _H5 = *v21;
                  __asm { FCVT            S5, H5 }
                  _S3 = v958 + (float)((float)(1.0 - v958) * _S5);
                  __asm { FCVT            H3, S3 }
                }
                *v21 = _H3;
              }
              v30 += v57;
              v962 = &v36[v57];
              if ((unint64_t)v962 >= v26)
                v963 = v952;
              else
                v963 = 0;
              v36 = &v962[v963];
              v21 += (int)v22;
              v28 += v57;
              --v954;
            }
            while (v954);
            v30 += v1035;
            v28 += v1034;
            v21 += v1032;
            v964 = v1040;
            v965 = v1040 + 8 * v1038;
            if (v965 >= v1033)
              v966 = v953;
            else
              v966 = 0;
            v967 = (float16x4_t *)(v965 + 8 * v966);
            v968 = v26 + 8 * v966 + 8 * v1038;
            if (v1033)
            {
              v26 = v968;
              v964 = (unint64_t)v967;
              v36 = v967;
            }
            else
            {
              v36 += v1038;
            }
            v1040 = v964;
            --v1041;
          }
          while (v955 != 1);
        }
      }
      else
      {
        v810 = v38;
        v811 = -(uint64_t)v34;
        v812 = -(uint64_t)(v1038 * v35);
        v813 = 8 * v38;
        do
        {
          v814 = v23;
          v815 = v1041;
          do
          {
            v816 = *v30;
            if (*v30)
            {
              if (v816 == 255)
                v817 = *v36;
              else
                v817 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), 1.0 - (float)((float)v816 * 0.0039216)), vcvtq_f32_f16(*v36), (float)v816 * 0.0039216));
              *v28 = v817;
            }
            v30 += v810;
            v818 = &v36[v810];
            if ((unint64_t)v818 >= v26)
              v819 = v811;
            else
              v819 = 0;
            v36 = &v818[v819];
            v28 = (float16x4_t *)((char *)v28 + v813);
            --v814;
          }
          while (v814);
          v30 += v1035;
          v28 += v1034;
          result = v1040;
          v820 = v1040 + 8 * v1038;
          if (v820 >= v1033)
            v821 = v812;
          else
            v821 = 0;
          v822 = (float16x4_t *)(v820 + 8 * v821);
          v823 = v26 + 8 * v821 + 8 * v1038;
          if (v1033)
          {
            v26 = v823;
            result = (unint64_t)v822;
            v36 = v822;
          }
          else
          {
            v36 += v1038;
          }
          v1040 = result;
          --v1041;
        }
        while (v815 != 1);
      }
      return result;
    case 2:
      v79 = v38;
      v80 = -(uint64_t)v34;
      v81 = v35;
      if ((_DWORD)v22)
      {
        v82 = -(uint64_t)(v1038 * v35);
        v83 = -(uint64_t)(v1036 * v81);
        v84 = v1039;
        while (1)
        {
          v85 = v1037;
          v86 = v1041;
          do
          {
            v87 = *v30;
            if (!*v30)
              goto LABEL_74;
            if (v87 == 255)
            {
              _H3 = *v84;
              __asm { FCVT            S2, H3 }
              if (_S2 >= 1.0)
              {
                *v28 = *v36;
                goto LABEL_73;
              }
              if (_S2 <= 0.0)
                goto LABEL_74;
              *v28 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v36), vcvtq_f32_f16(*v28), 1.0 - _S2));
              _H4 = *v21;
              __asm { FCVT            S4, H4 }
              _S2 = _S2 + (float)(_S4 * (float)(1.0 - _S2));
            }
            else
            {
              v93 = (float)v87 * 0.0039216;
              _H2 = *v84;
              __asm { FCVT            S2, H2 }
              _S2 = v93 * _S2;
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
              }
              if (_S2 <= 0.0)
                goto LABEL_74;
              *v28 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v93))), vcvtq_f32_f16(*v28), 1.0 - _S2));
              _H3 = *v21;
              __asm { FCVT            S3, H3 }
              _S2 = _S2 + (float)(_S3 * (float)(1.0 - _S2));
            }
            __asm { FCVT            H3, S2 }
LABEL_73:
            *v21 = _H3;
LABEL_74:
            v30 += v79;
            v100 = &v36[v79];
            v101 = &v84[(int)v25];
            if ((unint64_t)v100 >= v26)
              result = v80;
            else
              result = 0;
            v84 = &v101[result];
            v36 = &v100[result];
            v21 += (int)v22;
            v28 += v79;
            --v85;
          }
          while (v85);
          if (v1033)
          {
            result = v1038;
            v102 = v1040 + 8 * v1038;
            if (v102 >= v1033)
              v103 = v83;
            else
              v103 = 0;
            v104 = (uint64_t)&v1039[v1036 + v103];
            if (v102 >= v1033)
              v105 = v82;
            else
              v105 = 0;
            v36 = (float16x4_t *)(v102 + 8 * v105);
            v26 += 8 * v105 + 8 * v1038;
            v1039 += v1036 + v103;
            v1040 = (unint64_t)v36;
            v84 = (__int16 *)v104;
          }
          else
          {
            v36 += v1038;
            v84 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          v21 += v1032;
          --v1041;
          if (v86 == 1)
            return result;
        }
      }
      v824 = -(uint64_t)(v1038 * v35);
      v825 = -(uint64_t)(v1036 * v81);
      v826 = v1039;
LABEL_787:
      v827 = v23;
      while (1)
      {
        v828 = *v30;
        if (*v30)
        {
          if (v828 == 255)
          {
            _H2 = *v826;
            __asm { FCVT            S2, H2 }
            if (_S2 >= 1.0)
            {
              v831 = *v36;
              goto LABEL_796;
            }
            if (_S2 > 0.0)
            {
              v831 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v36), vcvtq_f32_f16(*v28), 1.0 - _S2));
LABEL_796:
              *v28 = v831;
            }
          }
          else
          {
            v832 = (float)v828 * 0.0039216;
            _H3 = *v826;
            __asm { FCVT            S3, H3 }
            _S3 = v832 * _S3;
            __asm
            {
              FCVT            H3, S3
              FCVT            S3, H3
            }
            if (_S3 > 0.0)
            {
              v831 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v832))), vcvtq_f32_f16(*v28), 1.0 - _S3));
              goto LABEL_796;
            }
          }
        }
        v30 += v79;
        v837 = &v36[v79];
        v838 = &v826[(int)v25];
        if ((unint64_t)v837 >= v26)
          v839 = v80;
        else
          v839 = 0;
        v826 = &v838[v839];
        v36 = &v837[v839];
        v28 += v79;
        if (!--v827)
        {
          if (v1033)
          {
            v840 = v1040 + 8 * v1038;
            if (v840 >= v1033)
              v841 = v825;
            else
              v841 = 0;
            v842 = (uint64_t)&v1039[v1036 + v841];
            if (v840 >= v1033)
              v843 = v824;
            else
              v843 = 0;
            v36 = (float16x4_t *)(v840 + 8 * v843);
            v26 += 8 * v843 + 8 * v1038;
            v1039 += v1036 + v841;
            v1040 = (unint64_t)v36;
            v826 = (__int16 *)v842;
          }
          else
          {
            v36 += v1038;
            v826 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          result = (v1041 - 1);
          v1041 = result;
          if (!(_DWORD)result)
            return result;
          goto LABEL_787;
        }
      }
    case 3:
      v106 = v38;
      v107 = v35;
      v108 = -(uint64_t)(v1038 * v35);
      v109 = -(uint64_t)(v1036 * v107);
      v110 = 8 * v38;
      v111 = -(uint64_t)v34;
      v112 = v1039;
      do
      {
        v113 = v1037;
        v114 = v1041;
        do
        {
          v115 = *v30;
          if (*v30)
          {
            if (v115 == 255)
            {
              _H1 = v36->i16[0];
              _H2 = *v21;
              __asm
              {
                FCVT            S2, H2
                FCVT            S1, H1
              }
              _S1 = _S1 * _S2;
              __asm { FCVT            H1, S1 }
              v28->i16[0] = LOWORD(_S1);
              LOWORD(_S1) = v36->i16[1];
              LOWORD(_S2) = *v21;
              __asm
              {
                FCVT            S1, H1
                FCVT            S2, H2
              }
              _S1 = _S1 * _S2;
              __asm { FCVT            H1, S1 }
              v28->i16[1] = LOWORD(_S1);
              LOWORD(_S1) = v36->i16[2];
              LOWORD(_S2) = *v21;
              __asm
              {
                FCVT            S1, H1
                FCVT            S2, H2
              }
              _S1 = _S1 * _S2;
              __asm { FCVT            H1, S1 }
              v28->i16[2] = LOWORD(_S1);
              LOWORD(_S1) = v36->i16[3];
              LOWORD(_S2) = *v21;
              __asm
              {
                FCVT            S1, H1
                FCVT            S2, H2
              }
              _S1 = _S1 * _S2;
              __asm { FCVT            H1, S1 }
              v28->i16[3] = LOWORD(_S1);
              if ((_DWORD)v25)
              {
                _H1 = *v112;
                __asm { FCVT            S1, H1 }
              }
              else
              {
                _S1 = 1.0;
              }
              _H2 = *v21;
              __asm { FCVT            S2, H2 }
              _S1 = _S1 * _S2;
            }
            else
            {
              v132 = (float)v115 * 0.0039216;
              _H1 = *v21;
              __asm { FCVT            S1, H1 }
              v135 = v132 * _S1;
              _S4 = 1.0;
              v137 = 1.0 - v132;
              *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), v137), vcvtq_f32_f16(*v36), v135));
              if ((_DWORD)v25)
              {
                _H4 = *v112;
                __asm { FCVT            S4, H4 }
              }
              _S1 = (float)(v137 * _S1) + (float)(_S4 * v135);
            }
            __asm { FCVT            H1, S1 }
            *v21 = _H1;
          }
          v30 += v106;
          v143 = &v36[v106];
          v144 = &v112[(int)v25];
          if ((unint64_t)v143 >= v26)
            result = v111;
          else
            result = 0;
          v112 = &v144[result];
          v36 = &v143[result];
          v21 += (int)v22;
          v28 = (float16x4_t *)((char *)v28 + v110);
          --v113;
        }
        while (v113);
        if (v1033)
        {
          result = v1038;
          v145 = v1040 + 8 * v1038;
          if (v145 >= v1033)
            v146 = v109;
          else
            v146 = 0;
          v147 = (uint64_t)&v1039[v1036 + v146];
          if (v145 >= v1033)
            v148 = v108;
          else
            v148 = 0;
          v36 = (float16x4_t *)(v145 + 8 * v148);
          v26 += 8 * v148 + 8 * v1038;
          v1039 += v1036 + v146;
          v1040 = (unint64_t)v36;
          v112 = (__int16 *)v147;
        }
        else
        {
          v36 += v1038;
          v112 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        --v1041;
      }
      while (v114 != 1);
      return result;
    case 4:
      v149 = v38;
      v150 = v35;
      v151 = -(uint64_t)(v1038 * v35);
      v152 = -(uint64_t)(v1036 * v150);
      v153 = 8 * v38;
      v154 = -(uint64_t)v34;
      v155 = v1039;
      do
      {
        v156 = v1037;
        v157 = v1041;
        do
        {
          v158 = *v30;
          if (*v30)
          {
            if (v158 == 255)
            {
              _H2 = v36->i16[0];
              __asm { FCVT            S3, H2 }
              _H2 = *v21;
              __asm { FCVT            S4, H2 }
              _S2 = 1.0;
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              v28->i16[0] = LOWORD(_S3);
              LOWORD(_S3) = v36->i16[1];
              __asm { FCVT            S3, H3 }
              LOWORD(_S4) = *v21;
              __asm { FCVT            S4, H4 }
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              v28->i16[1] = LOWORD(_S3);
              LOWORD(_S3) = v36->i16[2];
              __asm { FCVT            S3, H3 }
              LOWORD(_S4) = *v21;
              __asm { FCVT            S4, H4 }
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              v28->i16[2] = LOWORD(_S3);
              LOWORD(_S3) = v36->i16[3];
              __asm { FCVT            S3, H3 }
              LOWORD(_S4) = *v21;
              __asm { FCVT            S4, H4 }
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              v28->i16[3] = LOWORD(_S3);
              if ((_DWORD)v25)
              {
                _H2 = *v155;
                __asm { FCVT            S2, H2 }
              }
              _H3 = *v21;
              __asm { FCVT            S3, H3 }
              _S2 = _S2 * (float)(1.0 - _S3);
            }
            else
            {
              v178 = (float)v158 * 0.0039216;
              _H2 = *v21;
              __asm { FCVT            S2, H2 }
              _S4 = 1.0;
              v182 = v178 * (float)(1.0 - _S2);
              v183 = 1.0 - v178;
              *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), v183), vcvtq_f32_f16(*v36), v182));
              if ((_DWORD)v25)
              {
                _H4 = *v155;
                __asm { FCVT            S4, H4 }
              }
              _S2 = (float)(v183 * _S2) + (float)(_S4 * v182);
            }
            __asm { FCVT            H2, S2 }
            *v21 = _H2;
          }
          v30 += v149;
          v186 = &v36[v149];
          v187 = &v155[(int)v25];
          if ((unint64_t)v186 >= v26)
            result = v154;
          else
            result = 0;
          v155 = &v187[result];
          v36 = &v186[result];
          v21 += (int)v22;
          v28 = (float16x4_t *)((char *)v28 + v153);
          --v156;
        }
        while (v156);
        if (v1033)
        {
          result = v1038;
          v188 = v1040 + 8 * v1038;
          if (v188 >= v1033)
            v189 = v152;
          else
            v189 = 0;
          v190 = (uint64_t)&v1039[v1036 + v189];
          if (v188 >= v1033)
            v191 = v151;
          else
            v191 = 0;
          v36 = (float16x4_t *)(v188 + 8 * v191);
          v26 += 8 * v191 + 8 * v1038;
          v1039 += v1036 + v189;
          v1040 = (unint64_t)v36;
          v155 = (__int16 *)v190;
        }
        else
        {
          v36 += v1038;
          v155 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        --v1041;
      }
      while (v157 != 1);
      return result;
    case 5:
      v192 = v38;
      v193 = v35;
      v194 = -(uint64_t)(v1038 * v35);
      v195 = -(uint64_t)(v1036 * v193);
      v196 = 8 * v38;
      v197 = -(uint64_t)v34;
      v198 = v1039;
      do
      {
        v199 = v1037;
        v200 = v1041;
        do
        {
          if (*v30)
          {
            _H2 = *v21;
            __asm { FCVT            S2, H2 }
            v203 = (float)*v30 * 0.0039216;
            _H4 = *v198;
            __asm { FCVT            S4, H4 }
            _S4 = v203 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
            }
            *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), 1.0 - _S4), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v203))), _S2));
            _S2 = (float)((float)(1.0 - _S4) * _S2) + (float)(_S4 * _S2);
            __asm { FCVT            H2, S2 }
            *v21 = LOWORD(_S2);
          }
          v30 += v192;
          v209 = &v36[v192];
          v210 = &v198[(int)v25];
          if ((unint64_t)v209 >= v26)
            result = v197;
          else
            result = 0;
          v198 = &v210[result];
          v36 = &v209[result];
          v21 += (int)v22;
          v28 = (float16x4_t *)((char *)v28 + v196);
          --v199;
        }
        while (v199);
        if (v1033)
        {
          result = v1038;
          v211 = v1040 + 8 * v1038;
          if (v211 >= v1033)
            v212 = v195;
          else
            v212 = 0;
          v213 = (uint64_t)&v1039[v1036 + v212];
          if (v211 >= v1033)
            v214 = v194;
          else
            v214 = 0;
          v36 = (float16x4_t *)(v211 + 8 * v214);
          v26 += 8 * v214 + 8 * v1038;
          v1039 += v1036 + v212;
          v1040 = (unint64_t)v36;
          v198 = (__int16 *)v213;
        }
        else
        {
          v36 += v1038;
          v198 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        --v1041;
      }
      while (v200 != 1);
      return result;
    case 6:
      v215 = v38;
      v216 = v35;
      v217 = -(uint64_t)(v1038 * v35);
      v218 = -(uint64_t)(v1036 * v216);
      v219 = 8 * v38;
      v220 = -(uint64_t)v34;
      v221 = v1039;
      while (1)
      {
        v222 = v1037;
        v223 = v1041;
        do
        {
          v224 = *v30;
          if (!*v30)
            goto LABEL_175;
          _H2 = *v21;
          __asm { FCVT            S2, H2 }
          v227 = 1.0 - _S2;
          if ((float)(1.0 - _S2) >= 1.0)
          {
            v231 = (float)v224 * 0.0039216;
            *v28 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v231));
            if ((_DWORD)v25)
            {
              _H3 = *v221;
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            _S2 = v231 * _S3;
          }
          else
          {
            if (v227 <= 0.0)
              goto LABEL_175;
            v228 = (float)((float)v224 * 0.0039216) * v227;
            *v28 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v28), vcvtq_f32_f16(*v36), v228));
            if ((_DWORD)v25)
            {
              _H4 = *v221;
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            _S2 = _S2 + (float)(_S4 * v228);
          }
          __asm { FCVT            H2, S2 }
          *v21 = _H2;
LABEL_175:
          v30 += v215;
          v236 = &v36[v215];
          v237 = &v221[(int)v25];
          if ((unint64_t)v236 >= v26)
            result = v220;
          else
            result = 0;
          v221 = &v237[result];
          v36 = &v236[result];
          v21 += (int)v22;
          v28 = (float16x4_t *)((char *)v28 + v219);
          --v222;
        }
        while (v222);
        if (v1033)
        {
          result = v1038;
          v238 = v1040 + 8 * v1038;
          if (v238 >= v1033)
            v239 = v218;
          else
            v239 = 0;
          v240 = (uint64_t)&v1039[v1036 + v239];
          if (v238 >= v1033)
            v241 = v217;
          else
            v241 = 0;
          v36 = (float16x4_t *)(v238 + 8 * v241);
          v26 += 8 * v241 + 8 * v1038;
          v1039 += v1036 + v239;
          v1040 = (unint64_t)v36;
          v221 = (__int16 *)v240;
        }
        else
        {
          v36 += v1038;
          v221 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        --v1041;
        if (v223 == 1)
          return result;
      }
    case 7:
      v242 = v38;
      if ((_DWORD)v22)
      {
        v243 = v35;
        v244 = -(uint64_t)(v1038 * v35);
        v245 = -(uint64_t)(v1036 * v243);
        v246 = -(uint64_t)v34;
        v247 = v1039;
        do
        {
          v248 = v1037;
          v249 = v1041;
          do
          {
            v250 = *v30;
            if (*v30)
            {
              if (v250 == 255)
              {
                _H2 = v28->i16[0];
                _H3 = *v247;
                __asm
                {
                  FCVT            S3, H3
                  FCVT            S2, H2
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[0] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[1];
                LOWORD(_S3) = *v247;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[1] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[2];
                LOWORD(_S3) = *v247;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[2] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[3];
                LOWORD(_S3) = *v247;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[3] = LOWORD(_S2);
                LOWORD(_S2) = *v21;
                LOWORD(_S3) = *v247;
                __asm
                {
                  FCVT            S3, H3
                  FCVT            S2, H2
                }
                _S2 = _S2 * _S3;
              }
              else
              {
                v268 = (float)v250 * 0.0039216;
                _H3 = *v21;
                __asm { FCVT            S3, H3 }
                _H4 = v28->i16[0];
                __asm { FCVT            S4, H4 }
                _H5 = *v247;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v268) * _S4) + (float)(_S4 * (float)(v268 * _S5));
                __asm { FCVT            H4, S4 }
                v28->i16[0] = LOWORD(_S4);
                LOWORD(_S4) = v28->i16[1];
                __asm { FCVT            S4, H4 }
                LOWORD(_S5) = *v247;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v268) * _S4) + (float)(_S4 * (float)(v268 * _S5));
                __asm { FCVT            H4, S4 }
                v28->i16[1] = LOWORD(_S4);
                LOWORD(_S4) = v28->i16[2];
                __asm { FCVT            S4, H4 }
                LOWORD(_S5) = *v247;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v268) * _S4) + (float)(_S4 * (float)(v268 * _S5));
                __asm { FCVT            H4, S4 }
                v28->i16[2] = LOWORD(_S4);
                LOWORD(_S4) = v28->i16[3];
                __asm { FCVT            S4, H4 }
                LOWORD(_S5) = *v247;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v268) * _S4) + (float)(_S4 * (float)(v268 * _S5));
                __asm { FCVT            H4, S4 }
                v28->i16[3] = LOWORD(_S4);
                LOWORD(_S4) = *v247;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - v268) * _S3) + (float)(_S3 * (float)(v268 * _S4));
              }
              __asm { FCVT            H2, S2 }
              *v21 = _H2;
            }
            v30 += v242;
            v287 = &v36[v242];
            v288 = &v247[(int)v25];
            if ((unint64_t)v287 >= v26)
              result = v246;
            else
              result = 0;
            v247 = &v288[result];
            v36 = &v287[result];
            v21 += (int)v22;
            v28 += v242;
            --v248;
          }
          while (v248);
          if (v1033)
          {
            result = v1038;
            v289 = v1040 + 8 * v1038;
            if (v289 >= v1033)
              v290 = v245;
            else
              v290 = 0;
            v291 = (uint64_t)&v1039[v1036 + v290];
            if (v289 >= v1033)
              v292 = v244;
            else
              v292 = 0;
            v36 = (float16x4_t *)(v289 + 8 * v292);
            v26 += 8 * v292 + 8 * v1038;
            v1039 += v1036 + v290;
            v1040 = (unint64_t)v36;
            v247 = (__int16 *)v291;
          }
          else
          {
            v36 += v1038;
            v247 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          v21 += v1032;
          --v1041;
        }
        while (v249 != 1);
      }
      else
      {
        v844 = -(uint64_t)v34;
        v845 = v35;
        v846 = -(uint64_t)(v1038 * v35);
        v847 = -(uint64_t)(v1036 * v845);
        v848 = v1039;
        do
        {
          v849 = v23;
          do
          {
            v850 = *v30;
            if (*v30)
            {
              if (v850 == 255)
              {
                _H2 = v28->i16[0];
                _H3 = *v848;
                __asm
                {
                  FCVT            S3, H3
                  FCVT            S2, H2
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[0] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[1];
                LOWORD(_S3) = *v848;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[1] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[2];
                LOWORD(_S3) = *v848;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _S2 = _S2 * _S3;
                __asm { FCVT            H2, S2 }
                v28->i16[2] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[3];
                LOWORD(_S3) = *v848;
                __asm
                {
                  FCVT            S2, H2
                  FCVT            S3, H3
                }
                _S2 = _S2 * _S3;
              }
              else
              {
                v865 = (float)v850 * 0.0039216;
                _H3 = v28->i16[0];
                __asm { FCVT            S3, H3 }
                _H4 = *v848;
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)(1.0 - v865) * _S3) + (float)(_S3 * (float)(v865 * _S4));
                __asm { FCVT            H3, S3 }
                v28->i16[0] = LOWORD(_S3);
                LOWORD(_S3) = v28->i16[1];
                __asm { FCVT            S3, H3 }
                LOWORD(_S4) = *v848;
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)(1.0 - v865) * _S3) + (float)(_S3 * (float)(v865 * _S4));
                __asm { FCVT            H3, S3 }
                v28->i16[1] = LOWORD(_S3);
                LOWORD(_S3) = v28->i16[2];
                __asm { FCVT            S3, H3 }
                LOWORD(_S4) = *v848;
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)(1.0 - v865) * _S3) + (float)(_S3 * (float)(v865 * _S4));
                __asm { FCVT            H3, S3 }
                v28->i16[2] = LOWORD(_S3);
                LOWORD(_S3) = v28->i16[3];
                __asm { FCVT            S3, H3 }
                LOWORD(_S4) = *v848;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - v865) * _S3) + (float)(_S3 * (float)(v865 * _S4));
              }
              __asm { FCVT            H2, S2 }
              v28->i16[3] = _H2;
            }
            v30 += v242;
            v880 = &v36[v242];
            v881 = &v848[(int)v25];
            if ((unint64_t)v880 >= v26)
              v882 = v844;
            else
              v882 = 0;
            v848 = &v881[v882];
            v36 = &v880[v882];
            v28 += v242;
            --v849;
          }
          while (v849);
          if (v1033)
          {
            v883 = v1040 + 8 * v1038;
            if (v883 >= v1033)
              v884 = v847;
            else
              v884 = 0;
            v885 = (uint64_t)&v1039[v1036 + v884];
            if (v883 >= v1033)
              v886 = v846;
            else
              v886 = 0;
            v36 = (float16x4_t *)(v883 + 8 * v886);
            v26 += 8 * v886 + 8 * v1038;
            v1039 += v1036 + v884;
            v1040 = (unint64_t)v36;
            v848 = (__int16 *)v885;
          }
          else
          {
            v36 += v1038;
            v848 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          result = (v1041 - 1);
          v1041 = result;
        }
        while ((_DWORD)result);
      }
      return result;
    case 8:
      v293 = v38;
      v294 = -(uint64_t)v34;
      v295 = v35;
      if ((_DWORD)v22)
      {
        v296 = -(uint64_t)(v1038 * v35);
        v297 = -(uint64_t)(v1036 * v295);
        v298 = v1039;
        do
        {
          v299 = v1037;
          v300 = v1041;
          do
          {
            v301 = *v30;
            if (*v30)
            {
              _H2 = v28->i16[0];
              if (v301 == 255)
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[0] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[1];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[1] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[2];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[2] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[3];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[3] = LOWORD(_S2);
                LOWORD(_S2) = *v298;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v298;
                __asm { FCVT            S3, H3 }
                v320 = (float)v301 * 0.0039216;
                _S2 = (float)(1.0 - (float)(v320 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[0] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[1];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v320 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[1] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[2];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v320 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[2] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[3];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v298;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v320 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[3] = LOWORD(_S2);
                LOWORD(_S2) = *v298;
                __asm { FCVT            S2, H2 }
                _S2 = v320 * _S2;
              }
              _H3 = *v21;
              __asm { FCVT            S3, H3 }
              _S2 = (float)(1.0 - _S2) * _S3;
              __asm { FCVT            H2, S2 }
              *v21 = LOWORD(_S2);
            }
            v30 += v293;
            v335 = &v36[v293];
            v336 = &v298[(int)v25];
            if ((unint64_t)v335 >= v26)
              result = v294;
            else
              result = 0;
            v298 = &v336[result];
            v36 = &v335[result];
            v21 += (int)v22;
            v28 += v293;
            --v299;
          }
          while (v299);
          if (v1033)
          {
            result = v1038;
            v337 = v1040 + 8 * v1038;
            if (v337 >= v1033)
              v338 = v297;
            else
              v338 = 0;
            v339 = (uint64_t)&v1039[v1036 + v338];
            if (v337 >= v1033)
              v340 = v296;
            else
              v340 = 0;
            v36 = (float16x4_t *)(v337 + 8 * v340);
            v26 += 8 * v340 + 8 * v1038;
            v1039 += v1036 + v338;
            v1040 = (unint64_t)v36;
            v298 = (__int16 *)v339;
          }
          else
          {
            v36 += v1038;
            v298 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          v21 += v1032;
          --v1041;
        }
        while (v300 != 1);
      }
      else
      {
        v887 = -(uint64_t)(v1038 * v35);
        v888 = -(uint64_t)(v1036 * v295);
        v889 = v1039;
        do
        {
          v890 = v23;
          do
          {
            v891 = *v30;
            if (*v30)
            {
              _H2 = v28->i16[0];
              if (v891 == 255)
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v889;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[0] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[1];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v889;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[1] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[2];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v889;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[2] = LOWORD(_S2);
                LOWORD(_S2) = *v889;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v889;
                __asm { FCVT            S3, H3 }
                v907 = (float)v891 * 0.0039216;
                _S2 = (float)(1.0 - (float)(v907 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[0] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[1];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v889;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v907 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[1] = LOWORD(_S2);
                LOWORD(_S2) = v28->i16[2];
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v889;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v907 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                v28->i16[2] = LOWORD(_S2);
                LOWORD(_S2) = *v889;
                __asm { FCVT            S2, H2 }
                _S2 = v907 * _S2;
              }
              _H3 = v28->i16[3];
              __asm { FCVT            S3, H3 }
              _S2 = (float)(1.0 - _S2) * _S3;
              __asm { FCVT            H2, S2 }
              v28->i16[3] = LOWORD(_S2);
            }
            v30 += v293;
            v919 = &v36[v293];
            v920 = &v889[(int)v25];
            if ((unint64_t)v919 >= v26)
              v921 = v294;
            else
              v921 = 0;
            v889 = &v920[v921];
            v36 = &v919[v921];
            v28 += v293;
            --v890;
          }
          while (v890);
          if (v1033)
          {
            v922 = v1040 + 8 * v1038;
            if (v922 >= v1033)
              v923 = v888;
            else
              v923 = 0;
            v924 = (uint64_t)&v1039[v1036 + v923];
            if (v922 >= v1033)
              v925 = v887;
            else
              v925 = 0;
            v36 = (float16x4_t *)(v922 + 8 * v925);
            v26 += 8 * v925 + 8 * v1038;
            v1039 += v1036 + v923;
            v1040 = (unint64_t)v36;
            v889 = (__int16 *)v924;
          }
          else
          {
            v36 += v1038;
            v889 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          result = (v1041 - 1);
          v1041 = result;
        }
        while ((_DWORD)result);
      }
      return result;
    case 9:
      v341 = v38;
      v342 = v35;
      v343 = -(uint64_t)(v1038 * v35);
      v344 = -(uint64_t)(v1036 * v342);
      v345 = 8 * v38;
      v346 = -(uint64_t)v34;
      v347 = v1039;
      do
      {
        v348 = v1037;
        v349 = v1041;
        do
        {
          if (*v30)
          {
            _H2 = *v21;
            __asm { FCVT            S2, H2 }
            v352 = (float)*v30 * 0.0039216;
            _H4 = *v347;
            __asm { FCVT            S4, H4 }
            _S4 = v352 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
            }
            v357 = (float)(1.0 - v352) + _S4;
            *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), v357), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v352))), 1.0 - _S2));
            _S2 = (float)(v357 * _S2) + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *v21 = LOWORD(_S2);
          }
          v30 += v341;
          v359 = &v36[v341];
          v360 = &v347[(int)v25];
          if ((unint64_t)v359 >= v26)
            result = v346;
          else
            result = 0;
          v347 = &v360[result];
          v36 = &v359[result];
          v21 += (int)v22;
          v28 = (float16x4_t *)((char *)v28 + v345);
          --v348;
        }
        while (v348);
        if (v1033)
        {
          result = v1038;
          v361 = v1040 + 8 * v1038;
          if (v361 >= v1033)
            v362 = v344;
          else
            v362 = 0;
          v363 = (uint64_t)&v1039[v1036 + v362];
          if (v361 >= v1033)
            v364 = v343;
          else
            v364 = 0;
          v36 = (float16x4_t *)(v361 + 8 * v364);
          v26 += 8 * v364 + 8 * v1038;
          v1039 += v1036 + v362;
          v1040 = (unint64_t)v36;
          v347 = (__int16 *)v363;
        }
        else
        {
          v36 += v1038;
          v347 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        --v1041;
      }
      while (v349 != 1);
      return result;
    case 10:
      v365 = v38;
      v366 = v35;
      v367 = -(uint64_t)(v1038 * v35);
      v368 = -(uint64_t)(v1036 * v366);
      v369 = 8 * v38;
      v370 = -(uint64_t)v34;
      v371 = v1039;
      do
      {
        v372 = v1037;
        v373 = v1041;
        do
        {
          if (*v30)
          {
            _H2 = *v21;
            __asm { FCVT            S2, H2 }
            v376 = (float)*v30 * 0.0039216;
            _H4 = *v371;
            __asm { FCVT            S4, H4 }
            _S4 = v376 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
            }
            *v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v28), 1.0 - _S4), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v376))), 1.0 - _S2));
            _S2 = (float)((float)(1.0 - _S4) * _S2) + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *v21 = LOWORD(_S2);
          }
          v30 += v365;
          v382 = &v36[v365];
          v383 = &v371[(int)v25];
          if ((unint64_t)v382 >= v26)
            result = v370;
          else
            result = 0;
          v371 = &v383[result];
          v36 = &v382[result];
          v21 += (int)v22;
          v28 = (float16x4_t *)((char *)v28 + v369);
          --v372;
        }
        while (v372);
        if (v1033)
        {
          result = v1038;
          v384 = v1040 + 8 * v1038;
          if (v384 >= v1033)
            v385 = v368;
          else
            v385 = 0;
          v386 = (uint64_t)&v1039[v1036 + v385];
          if (v384 >= v1033)
            v387 = v367;
          else
            v387 = 0;
          v36 = (float16x4_t *)(v384 + 8 * v387);
          v26 += 8 * v387 + 8 * v1038;
          v1039 += v1036 + v385;
          v1040 = (unint64_t)v36;
          v371 = (__int16 *)v386;
        }
        else
        {
          v36 += v1038;
          v371 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        --v1041;
      }
      while (v373 != 1);
      return result;
    case 11:
      v388 = v38;
      if ((_DWORD)v22)
      {
        v389 = v35;
        v390 = -(uint64_t)(v1038 * v35);
        v391 = -(uint64_t)(v1036 * v389);
        v392 = -(uint64_t)v34;
        v393 = v1039;
        do
        {
          v394 = v1037;
          v395 = v1041;
          do
          {
            if (*v30)
            {
              if ((_DWORD)v25)
              {
                _H2 = *v393;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _H3 = v36->i16[0];
              __asm { FCVT            S3, H3 }
              _S4 = (float)*v30 * 0.0039216;
              _S3 = _S4 * _S3;
              __asm { FCVT            H3, S3 }
              _H5 = v36->i16[1];
              __asm { FCVT            S5, H5 }
              _S5 = _S4 * _S5;
              __asm { FCVT            H5, S5 }
              _H6 = v36->i16[2];
              __asm { FCVT            S6, H6 }
              _S6 = _S4 * _S6;
              __asm { FCVT            H6, S6 }
              _H7 = v36->i16[3];
              __asm { FCVT            S7, H7 }
              _S7 = _S4 * _S7;
              __asm { FCVT            H7, S7 }
              _S2 = _S4 * _S2;
              __asm { FCVT            H2, S2 }
              LOWORD(_S4) = *v21;
              __asm
              {
                FCVT            S4, H4
                FCVT            S2, H2
              }
              _S16 = _S4 + _S2;
              _H17 = v28->i16[0];
              __asm
              {
                FCVT            S17, H17
                FCVT            S3, H3
              }
              v421 = (float)(_S4 - _S17) + (float)(_S2 - _S3);
              if ((float)(_S4 + _S2) > 1.0)
                _S16 = 1.0;
              _H17 = v28->i16[1];
              __asm
              {
                FCVT            S17, H17
                FCVT            S5, H5
              }
              v425 = (float)(_S2 - _S5) + (float)(_S4 - _S17);
              _S3 = _S16 - v421;
              __asm { FCVT            H3, S3 }
              v28->i16[0] = LOWORD(_S3);
              LOWORD(_S3) = *v21;
              __asm { FCVT            S3, H3 }
              LOWORD(_S5) = v28->i16[2];
              __asm { FCVT            S5, H5 }
              v429 = _S3 - _S5;
              __asm { FCVT            S5, H6 }
              v431 = (float)(_S2 - _S5) + v429;
              _S4 = _S16 - v425;
              __asm { FCVT            H4, S4 }
              v28->i16[1] = LOWORD(_S4);
              LOWORD(_S4) = *v21;
              __asm { FCVT            S4, H4 }
              LOWORD(_S5) = v28->i16[3];
              __asm { FCVT            S5, H5 }
              v435 = _S4 - _S5;
              __asm { FCVT            S5, H7 }
              _S3 = _S16 - v431;
              __asm { FCVT            H3, S3 }
              v28->i16[2] = LOWORD(_S3);
              __asm { FCVT            H3, S16 }
              *v21 = LOWORD(_S3);
              _S2 = _S16 - (float)((float)(_S2 - _S5) + v435);
              __asm { FCVT            H2, S2 }
              v28->i16[3] = LOWORD(_S2);
            }
            v30 += v388;
            v439 = &v36[v388];
            v440 = &v393[(int)v25];
            if ((unint64_t)v439 >= v26)
              result = v392;
            else
              result = 0;
            v393 = &v440[result];
            v36 = &v439[result];
            v21 += (int)v22;
            v28 += v388;
            --v394;
          }
          while (v394);
          if (v1033)
          {
            result = v1038;
            v441 = v1040 + 8 * v1038;
            if (v441 >= v1033)
              v442 = v391;
            else
              v442 = 0;
            v443 = (uint64_t)&v1039[v1036 + v442];
            if (v441 >= v1033)
              v444 = v390;
            else
              v444 = 0;
            v36 = (float16x4_t *)(v441 + 8 * v444);
            v26 += 8 * v444 + 8 * v1038;
            v1039 += v1036 + v442;
            v1040 = (unint64_t)v36;
            v393 = (__int16 *)v443;
          }
          else
          {
            v36 += v1038;
            v393 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          v21 += v1032;
          --v1041;
        }
        while (v395 != 1);
      }
      else
      {
        v926 = -(uint64_t)v34;
        v927 = v35;
        v928 = -(uint64_t)(v1038 * v35);
        v929 = -(uint64_t)(v1036 * v927);
        __asm { FMOV            V1.4S, #1.0 }
        v931 = v1039;
        do
        {
          v932 = v23;
          do
          {
            if (*v30)
            {
              if ((_DWORD)v25)
              {
                _H2 = *v931;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _Q2.n128_u32[0] = 1.0;
              }
              v934 = (float)*v30 * 0.0039216;
              _Q2.n128_f32[0] = v934 * _Q2.n128_f32[0];
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
              }
              _Q2.n128_u64[0] = (unint64_t)vcvt_f16_f32(vsubq_f32(_Q1, vaddq_f32(vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)_Q2.n128_u64[0], 0), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v934)))), vsubq_f32(_Q1, vcvtq_f32_f16(*v28)))));
              *v28 = (float16x4_t)_Q2.n128_u64[0];
            }
            v30 += v388;
            v935 = &v36[v388];
            v936 = &v931[(int)v25];
            if ((unint64_t)v935 >= v26)
              v937 = v926;
            else
              v937 = 0;
            v931 = &v936[v937];
            v36 = &v935[v937];
            v28 += v388;
            --v932;
          }
          while (v932);
          if (v1033)
          {
            v938 = v1040 + 8 * v1038;
            if (v938 >= v1033)
              v939 = v929;
            else
              v939 = 0;
            v940 = (uint64_t)&v1039[v1036 + v939];
            if (v938 >= v1033)
              v941 = v928;
            else
              v941 = 0;
            v36 = (float16x4_t *)(v938 + 8 * v941);
            v26 += 8 * v941 + 8 * v1038;
            v1039 += v1036 + v939;
            v1040 = (unint64_t)v36;
            v931 = (__int16 *)v940;
          }
          else
          {
            v36 += v1038;
            v931 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          result = (v1041 - 1);
          v1041 = result;
        }
        while ((_DWORD)result);
      }
      return result;
    case 12:
      v445 = v38;
      if ((_DWORD)v22)
      {
        v446 = v35;
        v447 = -(uint64_t)(v1038 * v35);
        v448 = -(uint64_t)(v1036 * v446);
        v449 = -(uint64_t)v34;
        v450 = v1039;
        do
        {
          v451 = v1037;
          v452 = v1041;
          do
          {
            if (*v30)
            {
              if ((_DWORD)v25)
              {
                _H2 = *v450;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _S3 = (float)*v30 * 0.0039216;
              v456 = vmulq_n_f32(vcvtq_f32_f16(*v36), _S3);
              _S2 = _S3 * _S2;
              __asm { FCVT            H2, S2 }
              LOWORD(_S3) = *v21;
              __asm
              {
                FCVT            S3, H3
                FCVT            S2, H2
              }
              _S2 = _S3 + _S2;
              if (_S2 > 1.0)
                _S2 = 1.0;
              __asm { FCVT            H2, S2 }
              v462.i32[0] = v28->i32[0];
              *v21 = _H2;
              v462.i32[1] = v28->i32[1];
              *v28 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(v462), vcvtq_f32_f16(vcvt_f16_f32(v456))));
            }
            v30 += v445;
            v463 = &v36[v445];
            v464 = &v450[(int)v25];
            if ((unint64_t)v463 >= v26)
              result = v449;
            else
              result = 0;
            v450 = &v464[result];
            v36 = &v463[result];
            v21 += (int)v22;
            v28 += v445;
            --v451;
          }
          while (v451);
          if (v1033)
          {
            result = v1038;
            v465 = v1040 + 8 * v1038;
            if (v465 >= v1033)
              v466 = v448;
            else
              v466 = 0;
            v467 = (uint64_t)&v1039[v1036 + v466];
            if (v465 >= v1033)
              v468 = v447;
            else
              v468 = 0;
            v36 = (float16x4_t *)(v465 + 8 * v468);
            v26 += 8 * v468 + 8 * v1038;
            v1039 += v1036 + v466;
            v1040 = (unint64_t)v36;
            v450 = (__int16 *)v467;
          }
          else
          {
            v36 += v1038;
            v450 += v1036;
          }
          v30 += v1035;
          v28 += v1034;
          v21 += v1032;
          --v1041;
        }
        while (v452 != 1);
      }
      else
      {
        v942 = -(uint64_t)v34;
        v943 = -(uint64_t)(v1038 * v35);
        do
        {
          v944 = v23;
          v945 = v1041;
          do
          {
            if (*v30)
              *v28 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(*v28), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), (float)*v30 * 0.0039216)))));
            v30 += v445;
            v946 = &v36[v445];
            if ((unint64_t)v946 >= v26)
              v947 = v942;
            else
              v947 = 0;
            v36 = &v946[v947];
            v28 += v445;
            --v944;
          }
          while (v944);
          v30 += v1035;
          v28 += v1034;
          result = v1040;
          v948 = v1040 + 8 * v1038;
          if (v948 >= v1033)
            v949 = v943;
          else
            v949 = 0;
          v950 = (float16x4_t *)(v948 + 8 * v949);
          v951 = v26 + 8 * v949 + 8 * v1038;
          if (v1033)
          {
            v26 = v951;
            result = (unint64_t)v950;
            v36 = v950;
          }
          else
          {
            v36 += v1038;
          }
          v1040 = result;
          --v1041;
        }
        while (v945 != 1);
      }
      return result;
    case 13:
      v469 = v38;
      v470 = (int)v25;
      v471 = v1039;
      v987 = -(uint64_t)(v1038 * v35);
      v972 = -(uint64_t)(v1036 * v35);
      v472 = 2 * (int)v22;
      v473 = 8 * v38;
      v474 = -(uint64_t)v34;
      v1002 = v472;
      v1017 = (int)v25;
      while (1)
      {
        v475 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v471;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v478 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v478 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v479 = (__n128)vcvtq_f32_f16(*v36);
              v480 = (__n128)vmulq_n_f32((float32x4_t)v479, v478);
              v481 = (int32x2_t)vcvt_f16_f32((float32x4_t)v480);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v481.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v485) = v481.i16[2];
                  LOWORD(v486) = v481.i16[3];
                  goto LABEL_338;
                }
                v484 = vdup_lane_s32(v481, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v481.i16[1];
                v484 = vdup_lane_s32(v481, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v480.n128_u16[0] = v28->u16[1];
              v479.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAmultiplyPDA(_Q0, v480, v479, a6, _S4, *(double *)&v481, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v481.i16[0], a9.i16[0], v484,
                         SHIWORD(v484),
                         *(float *)&_D7);
              v485 = HIDWORD(result);
              v486 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v481.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v472 = v1002;
                v470 = v1017;
LABEL_338:
                v28->i16[0] = v481.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v485;
                v28->i16[3] = v486;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_340;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v472 = v1002;
              v470 = v1017;
            }
          }
LABEL_340:
          v30 += v469;
          v487 = &v36[v469];
          if ((unint64_t)v487 >= v26)
            v488 = v474;
          else
            v488 = 0;
          v471 += v470 + v488;
          v36 = &v487[v488];
          v21 = (__int16 *)((char *)v21 + v472);
          v28 = (float16x4_t *)((char *)v28 + v473);
          --v475;
        }
        while (v475);
        if (v1033)
        {
          v489 = v1040 + 8 * v1038;
          v490 = v972;
          if (v489 < v1033)
            v490 = 0;
          v471 = &v1039[v1036 + v490];
          v491 = v987;
          if (v489 < v1033)
            v491 = 0;
          v36 = (float16x4_t *)(v489 + 8 * v491);
          v26 += 8 * v491 + 8 * v1038;
          v1039 += v1036 + v490;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v471 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 14:
      v492 = v38;
      v493 = (int)v25;
      v494 = v1039;
      v988 = -(uint64_t)(v1038 * v35);
      v973 = -(uint64_t)(v1036 * v35);
      v495 = 2 * (int)v22;
      v496 = 8 * v38;
      v497 = -(uint64_t)v34;
      v1003 = v495;
      v1018 = (int)v25;
      while (1)
      {
        v498 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v494;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v501 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v501 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v502 = (__n128)vcvtq_f32_f16(*v36);
              v503 = (__n128)vmulq_n_f32((float32x4_t)v502, v501);
              v504 = (int32x2_t)vcvt_f16_f32((float32x4_t)v503);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v504.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v508) = v504.i16[2];
                  LOWORD(v509) = v504.i16[3];
                  goto LABEL_367;
                }
                v507 = vdup_lane_s32(v504, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v504.i16[1];
                v507 = vdup_lane_s32(v504, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v503.n128_u16[0] = v28->u16[1];
              v502.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAscreenPDA(_Q0, v503, v502, a6, _S4, *(double *)&v504, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v504.i16[0], a9.i16[0], v507,
                         SHIWORD(v507),
                         *(float *)&_D7);
              v508 = HIDWORD(result);
              v509 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v504.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v495 = v1003;
                v493 = v1018;
LABEL_367:
                v28->i16[0] = v504.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v508;
                v28->i16[3] = v509;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_369;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v495 = v1003;
              v493 = v1018;
            }
          }
LABEL_369:
          v30 += v492;
          v510 = &v36[v492];
          if ((unint64_t)v510 >= v26)
            v511 = v497;
          else
            v511 = 0;
          v494 += v493 + v511;
          v36 = &v510[v511];
          v21 = (__int16 *)((char *)v21 + v495);
          v28 = (float16x4_t *)((char *)v28 + v496);
          --v498;
        }
        while (v498);
        if (v1033)
        {
          v512 = v1040 + 8 * v1038;
          v513 = v973;
          if (v512 < v1033)
            v513 = 0;
          v494 = &v1039[v1036 + v513];
          v514 = v988;
          if (v512 < v1033)
            v514 = 0;
          v36 = (float16x4_t *)(v512 + 8 * v514);
          v26 += 8 * v514 + 8 * v1038;
          v1039 += v1036 + v513;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v494 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 15:
      v515 = v38;
      v516 = (int)v25;
      v517 = v1039;
      v989 = -(uint64_t)(v1038 * v35);
      v974 = -(uint64_t)(v1036 * v35);
      v518 = 2 * (int)v22;
      v519 = 8 * v38;
      v520 = -(uint64_t)v34;
      v1004 = v518;
      v1019 = (int)v25;
      while (1)
      {
        v521 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v517;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v524 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v524 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v525 = (__n128)vcvtq_f32_f16(*v36);
              v526 = (__n128)vmulq_n_f32((float32x4_t)v525, v524);
              v527 = (int32x2_t)vcvt_f16_f32((float32x4_t)v526);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v527.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v531) = v527.i16[2];
                  LOWORD(v532) = v527.i16[3];
                  goto LABEL_396;
                }
                v530 = vdup_lane_s32(v527, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v527.i16[1];
                v530 = vdup_lane_s32(v527, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v526.n128_u16[0] = v28->u16[1];
              v525.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAoverlayPDA(_Q0, v526, v525, a6, _S4, *(double *)&v527, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v527.i16[0], a9.i16[0], v530,
                         SHIWORD(v530),
                         *(float *)&_D7);
              v531 = HIDWORD(result);
              v532 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v527.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v518 = v1004;
                v516 = v1019;
LABEL_396:
                v28->i16[0] = v527.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v531;
                v28->i16[3] = v532;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_398;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v518 = v1004;
              v516 = v1019;
            }
          }
LABEL_398:
          v30 += v515;
          v533 = &v36[v515];
          if ((unint64_t)v533 >= v26)
            v534 = v520;
          else
            v534 = 0;
          v517 += v516 + v534;
          v36 = &v533[v534];
          v21 = (__int16 *)((char *)v21 + v518);
          v28 = (float16x4_t *)((char *)v28 + v519);
          --v521;
        }
        while (v521);
        if (v1033)
        {
          v535 = v1040 + 8 * v1038;
          v536 = v974;
          if (v535 < v1033)
            v536 = 0;
          v517 = &v1039[v1036 + v536];
          v537 = v989;
          if (v535 < v1033)
            v537 = 0;
          v36 = (float16x4_t *)(v535 + 8 * v537);
          v26 += 8 * v537 + 8 * v1038;
          v1039 += v1036 + v536;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v517 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 16:
      v538 = v38;
      v539 = (int)v25;
      v540 = v1039;
      v990 = -(uint64_t)(v1038 * v35);
      v975 = -(uint64_t)(v1036 * v35);
      v541 = 2 * (int)v22;
      v542 = 8 * v38;
      v543 = -(uint64_t)v34;
      v1005 = v541;
      v1020 = (int)v25;
      while (1)
      {
        v544 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v540;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v547 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v547 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v548 = (__n128)vcvtq_f32_f16(*v36);
              v549 = (__n128)vmulq_n_f32((float32x4_t)v548, v547);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v549);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = _Q5.i16[1];
                if (_Q4.f32[0] <= 0.0)
                {
                  LOWORD(v552) = _Q5.i16[2];
                  LOWORD(v553) = _Q5.i16[3];
                  goto LABEL_425;
                }
                v551 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
              }
              else
              {
                a9.i16[0] = _Q5.i16[1];
                v551 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v549.n128_u16[0] = v28->u16[1];
              v548.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              v969.i32[1] = v551;
              v969.i16[1] = a9.i16[0];
              v969.i16[0] = _Q5.i16[0];
              result = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], v549, v548, a6, _Q4, _Q5, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v969, *(float *)&_D7);
              v552 = HIDWORD(result);
              v553 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                _Q5.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v541 = v1005;
                v539 = v1020;
LABEL_425:
                v28->i16[0] = _Q5.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v552;
                v28->i16[3] = v553;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_427;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v541 = v1005;
              v539 = v1020;
            }
          }
LABEL_427:
          v30 += v538;
          v554 = &v36[v538];
          if ((unint64_t)v554 >= v26)
            v555 = v543;
          else
            v555 = 0;
          v540 += v539 + v555;
          v36 = &v554[v555];
          v21 = (__int16 *)((char *)v21 + v541);
          v28 = (float16x4_t *)((char *)v28 + v542);
          --v544;
        }
        while (v544);
        if (v1033)
        {
          v556 = v1040 + 8 * v1038;
          v557 = v975;
          if (v556 < v1033)
            v557 = 0;
          v540 = &v1039[v1036 + v557];
          v558 = v990;
          if (v556 < v1033)
            v558 = 0;
          v36 = (float16x4_t *)(v556 + 8 * v558);
          v26 += 8 * v558 + 8 * v1038;
          v1039 += v1036 + v557;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v540 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 17:
      v559 = v38;
      v560 = (int)v25;
      v561 = v1039;
      v991 = -(uint64_t)(v1038 * v35);
      v976 = -(uint64_t)(v1036 * v35);
      v562 = 2 * (int)v22;
      v563 = 8 * v38;
      v564 = -(uint64_t)v34;
      v1006 = v562;
      v1021 = (int)v25;
      while (1)
      {
        v565 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v561;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v568 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v568 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v569 = (__n128)vcvtq_f32_f16(*v36);
              v570 = (__n128)vmulq_n_f32((float32x4_t)v569, v568);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v570);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = _Q5.i16[1];
                if (_Q4.f32[0] <= 0.0)
                {
                  LOWORD(v573) = _Q5.i16[2];
                  LOWORD(v574) = _Q5.i16[3];
                  goto LABEL_454;
                }
                v572 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
              }
              else
              {
                a9.i16[0] = _Q5.i16[1];
                v572 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v570.n128_u16[0] = v28->u16[1];
              v569.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              v970.i32[1] = v572;
              v970.i16[1] = a9.i16[0];
              v970.i16[0] = _Q5.i16[0];
              result = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], v570, v569, a6, _Q4, _Q5, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v970, *(float *)&_D7);
              v573 = HIDWORD(result);
              v574 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                _Q5.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v562 = v1006;
                v560 = v1021;
LABEL_454:
                v28->i16[0] = _Q5.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v573;
                v28->i16[3] = v574;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_456;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v562 = v1006;
              v560 = v1021;
            }
          }
LABEL_456:
          v30 += v559;
          v575 = &v36[v559];
          if ((unint64_t)v575 >= v26)
            v576 = v564;
          else
            v576 = 0;
          v561 += v560 + v576;
          v36 = &v575[v576];
          v21 = (__int16 *)((char *)v21 + v562);
          v28 = (float16x4_t *)((char *)v28 + v563);
          --v565;
        }
        while (v565);
        if (v1033)
        {
          v577 = v1040 + 8 * v1038;
          v578 = v976;
          if (v577 < v1033)
            v578 = 0;
          v561 = &v1039[v1036 + v578];
          v579 = v991;
          if (v577 < v1033)
            v579 = 0;
          v36 = (float16x4_t *)(v577 + 8 * v579);
          v26 += 8 * v579 + 8 * v1038;
          v1039 += v1036 + v578;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v561 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 18:
      v580 = v38;
      v581 = (int)v25;
      v582 = v1039;
      v992 = -(uint64_t)(v1038 * v35);
      v977 = -(uint64_t)(v1036 * v35);
      v583 = 2 * (int)v22;
      v584 = 8 * v38;
      v585 = -(uint64_t)v34;
      v1007 = v583;
      v1022 = (int)v25;
      while (1)
      {
        v586 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v582;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v589 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v589 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v590 = (__n128)vcvtq_f32_f16(*v36);
              v591 = (__n128)vmulq_n_f32((float32x4_t)v590, v589);
              v592 = (int32x2_t)vcvt_f16_f32((float32x4_t)v591);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v592.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v596) = v592.i16[2];
                  LOWORD(v597) = v592.i16[3];
                  goto LABEL_483;
                }
                v595 = vdup_lane_s32(v592, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v592.i16[1];
                v595 = vdup_lane_s32(v592, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v591.n128_u16[0] = v28->u16[1];
              v590.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAcolordodgePDA(_Q0, v591, v590, a6, _S4, *(double *)&v592, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v592.i16[0], a9.i16[0], v595,
                         SHIWORD(v595),
                         *(float *)&_D7);
              v596 = HIDWORD(result);
              v597 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v592.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v583 = v1007;
                v581 = v1022;
LABEL_483:
                v28->i16[0] = v592.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v596;
                v28->i16[3] = v597;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_485;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v583 = v1007;
              v581 = v1022;
            }
          }
LABEL_485:
          v30 += v580;
          v598 = &v36[v580];
          if ((unint64_t)v598 >= v26)
            v599 = v585;
          else
            v599 = 0;
          v582 += v581 + v599;
          v36 = &v598[v599];
          v21 = (__int16 *)((char *)v21 + v583);
          v28 = (float16x4_t *)((char *)v28 + v584);
          --v586;
        }
        while (v586);
        if (v1033)
        {
          v600 = v1040 + 8 * v1038;
          v601 = v977;
          if (v600 < v1033)
            v601 = 0;
          v582 = &v1039[v1036 + v601];
          v602 = v992;
          if (v600 < v1033)
            v602 = 0;
          v36 = (float16x4_t *)(v600 + 8 * v602);
          v26 += 8 * v602 + 8 * v1038;
          v1039 += v1036 + v601;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v582 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 19:
      v603 = v38;
      v604 = (int)v25;
      v605 = v1039;
      v993 = -(uint64_t)(v1038 * v35);
      v978 = -(uint64_t)(v1036 * v35);
      v606 = 2 * (int)v22;
      v607 = 8 * v38;
      v608 = -(uint64_t)v34;
      v1008 = v606;
      v1023 = (int)v25;
      while (1)
      {
        v609 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v605;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v612 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v612 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v613 = (__n128)vcvtq_f32_f16(*v36);
              v614 = (__n128)vmulq_n_f32((float32x4_t)v613, v612);
              v615 = (int32x2_t)vcvt_f16_f32((float32x4_t)v614);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v615.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v619) = v615.i16[2];
                  LOWORD(v620) = v615.i16[3];
                  goto LABEL_512;
                }
                v618 = vdup_lane_s32(v615, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v615.i16[1];
                v618 = vdup_lane_s32(v615, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v614.n128_u16[0] = v28->u16[1];
              v613.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAcolorburnPDA(_Q0, v614, v613, a6, _S4, *(double *)&v615, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v615.i16[0], a9.i16[0], v618,
                         SHIWORD(v618),
                         *(float *)&_D7);
              v619 = HIDWORD(result);
              v620 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v615.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v606 = v1008;
                v604 = v1023;
LABEL_512:
                v28->i16[0] = v615.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v619;
                v28->i16[3] = v620;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_514;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v606 = v1008;
              v604 = v1023;
            }
          }
LABEL_514:
          v30 += v603;
          v621 = &v36[v603];
          if ((unint64_t)v621 >= v26)
            v622 = v608;
          else
            v622 = 0;
          v605 += v604 + v622;
          v36 = &v621[v622];
          v21 = (__int16 *)((char *)v21 + v606);
          v28 = (float16x4_t *)((char *)v28 + v607);
          --v609;
        }
        while (v609);
        if (v1033)
        {
          v623 = v1040 + 8 * v1038;
          v624 = v978;
          if (v623 < v1033)
            v624 = 0;
          v605 = &v1039[v1036 + v624];
          v625 = v993;
          if (v623 < v1033)
            v625 = 0;
          v36 = (float16x4_t *)(v623 + 8 * v625);
          v26 += 8 * v625 + 8 * v1038;
          v1039 += v1036 + v624;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v605 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 20:
      v626 = v38;
      v627 = (int)v25;
      v628 = v1039;
      v994 = -(uint64_t)(v1038 * v35);
      v979 = -(uint64_t)(v1036 * v35);
      v629 = 2 * (int)v22;
      v630 = 8 * v38;
      v631 = -(uint64_t)v34;
      v1009 = v629;
      v1024 = (int)v25;
      while (1)
      {
        v632 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v628;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v635 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v635 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v636 = (__n128)vcvtq_f32_f16(*v36);
              v637 = (__n128)vmulq_n_f32((float32x4_t)v636, v635);
              v638 = (int32x2_t)vcvt_f16_f32((float32x4_t)v637);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v638.i16[1];
                if (_Q4.f32[0] <= 0.0)
                {
                  LOWORD(v641) = v638.i16[2];
                  LOWORD(v642) = v638.i16[3];
                  goto LABEL_541;
                }
                v640 = vdup_lane_s32(v638, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v638.i16[1];
                v640 = vdup_lane_s32(v638, 1).u32[0];
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v637.n128_u16[0] = v28->u16[1];
              v636.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              HIWORD(v971) = a9.i16[0];
              LOWORD(v971) = v638.i16[0];
              result = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], v637, v636, a6, *(double *)_Q4.i64, v638, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v971, v640, SHIWORD(v640),
                         *(float *)&_D7);
              v641 = HIDWORD(result);
              v642 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v638.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v629 = v1009;
                v627 = v1024;
LABEL_541:
                v28->i16[0] = v638.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v641;
                v28->i16[3] = v642;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_543;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v629 = v1009;
              v627 = v1024;
            }
          }
LABEL_543:
          v30 += v626;
          v643 = &v36[v626];
          if ((unint64_t)v643 >= v26)
            v644 = v631;
          else
            v644 = 0;
          v628 += v627 + v644;
          v36 = &v643[v644];
          v21 = (__int16 *)((char *)v21 + v629);
          v28 = (float16x4_t *)((char *)v28 + v630);
          --v632;
        }
        while (v632);
        if (v1033)
        {
          v645 = v1040 + 8 * v1038;
          v646 = v979;
          if (v645 < v1033)
            v646 = 0;
          v628 = &v1039[v1036 + v646];
          v647 = v994;
          if (v645 < v1033)
            v647 = 0;
          v36 = (float16x4_t *)(v645 + 8 * v647);
          v26 += 8 * v647 + 8 * v1038;
          v1039 += v1036 + v646;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v628 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 21:
      v648 = v38;
      v649 = (int)v25;
      v650 = v1039;
      v995 = -(uint64_t)(v1038 * v35);
      v980 = -(uint64_t)(v1036 * v35);
      v651 = 2 * (int)v22;
      v652 = 8 * v38;
      v653 = -(uint64_t)v34;
      v1010 = v651;
      v1025 = (int)v25;
      while (1)
      {
        v654 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v650;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v657 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v657 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v658 = (__n128)vcvtq_f32_f16(*v36);
              v659 = (__n128)vmulq_n_f32((float32x4_t)v658, v657);
              v660 = (int32x2_t)vcvt_f16_f32((float32x4_t)v659);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v660.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v664) = v660.i16[2];
                  LOWORD(v665) = v660.i16[3];
                  goto LABEL_570;
                }
                v663 = vdup_lane_s32(v660, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v660.i16[1];
                v663 = vdup_lane_s32(v660, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v659.n128_u16[0] = v28->u16[1];
              v658.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAhardlightPDA(_Q0, v659, v658, a6, _S4, *(double *)&v660, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v660.i16[0], a9.i16[0], v663,
                         SHIWORD(v663),
                         *(float *)&_D7);
              v664 = HIDWORD(result);
              v665 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v660.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v651 = v1010;
                v649 = v1025;
LABEL_570:
                v28->i16[0] = v660.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v664;
                v28->i16[3] = v665;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_572;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v651 = v1010;
              v649 = v1025;
            }
          }
LABEL_572:
          v30 += v648;
          v666 = &v36[v648];
          if ((unint64_t)v666 >= v26)
            v667 = v653;
          else
            v667 = 0;
          v650 += v649 + v667;
          v36 = &v666[v667];
          v21 = (__int16 *)((char *)v21 + v651);
          v28 = (float16x4_t *)((char *)v28 + v652);
          --v654;
        }
        while (v654);
        if (v1033)
        {
          v668 = v1040 + 8 * v1038;
          v669 = v980;
          if (v668 < v1033)
            v669 = 0;
          v650 = &v1039[v1036 + v669];
          v670 = v995;
          if (v668 < v1033)
            v670 = 0;
          v36 = (float16x4_t *)(v668 + 8 * v670);
          v26 += 8 * v670 + 8 * v1038;
          v1039 += v1036 + v669;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v650 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 22:
      v671 = v38;
      v672 = (int)v25;
      v673 = v1039;
      v996 = -(uint64_t)(v1038 * v35);
      v981 = -(uint64_t)(v1036 * v35);
      v674 = 2 * (int)v22;
      v675 = 8 * v38;
      v676 = -(uint64_t)v34;
      v1011 = v674;
      v1026 = (int)v25;
      while (1)
      {
        v677 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v673;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v680 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v680 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v681 = (__n128)vcvtq_f32_f16(*v36);
              v682 = (__n128)vmulq_n_f32((float32x4_t)v681, v680);
              v683 = (int32x2_t)vcvt_f16_f32((float32x4_t)v682);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v683.i16[1];
                if (_Q4.f32[0] <= 0.0)
                {
                  LOWORD(v686) = v683.i16[2];
                  LOWORD(v687) = v683.i16[3];
                  goto LABEL_599;
                }
                v685 = vdup_lane_s32(v683, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v683.i16[1];
                v685 = vdup_lane_s32(v683, 1).u32[0];
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v682.n128_u16[0] = v28->u16[1];
              v681.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAdifferencePDA(_Q0, v682, v681, (float16x4_t)a6.n128_u64[0], *(double *)_Q4.i64, v683, a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v683.i16[0], a9.i16[0], v685,
                         SHIWORD(v685),
                         *(float *)&_D7);
              v686 = HIDWORD(result);
              v687 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v683.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v674 = v1011;
                v672 = v1026;
LABEL_599:
                v28->i16[0] = v683.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v686;
                v28->i16[3] = v687;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_601;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v674 = v1011;
              v672 = v1026;
            }
          }
LABEL_601:
          v30 += v671;
          v688 = &v36[v671];
          if ((unint64_t)v688 >= v26)
            v689 = v676;
          else
            v689 = 0;
          v673 += v672 + v689;
          v36 = &v688[v689];
          v21 = (__int16 *)((char *)v21 + v674);
          v28 = (float16x4_t *)((char *)v28 + v675);
          --v677;
        }
        while (v677);
        if (v1033)
        {
          v690 = v1040 + 8 * v1038;
          v691 = v981;
          if (v690 < v1033)
            v691 = 0;
          v673 = &v1039[v1036 + v691];
          v692 = v996;
          if (v690 < v1033)
            v692 = 0;
          v36 = (float16x4_t *)(v690 + 8 * v692);
          v26 += 8 * v692 + 8 * v1038;
          v1039 += v1036 + v691;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v673 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 23:
      v693 = v38;
      v694 = (int)v25;
      v695 = v1039;
      v997 = -(uint64_t)(v1038 * v35);
      v982 = -(uint64_t)(v1036 * v35);
      v696 = 2 * (int)v22;
      v697 = 8 * v38;
      v698 = -(uint64_t)v34;
      v1012 = v696;
      v1027 = (int)v25;
      while (1)
      {
        v699 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v695;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v702 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v702 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v703 = (__n128)vcvtq_f32_f16(*v36);
              v704 = (__n128)vmulq_n_f32((float32x4_t)v703, v702);
              v705 = (int32x2_t)vcvt_f16_f32((float32x4_t)v704);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v705.i16[1];
                if (_Q4.f32[0] <= 0.0)
                {
                  LOWORD(v708) = v705.i16[2];
                  LOWORD(v709) = v705.i16[3];
                  goto LABEL_628;
                }
                v707 = vdup_lane_s32(v705, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v705.i16[1];
                v707 = vdup_lane_s32(v705, 1).u32[0];
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v704.n128_u16[0] = v28->u16[1];
              v703.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAexclusionPDA(_Q0, v704, v703, (float16x4_t)a6.n128_u64[0], *(double *)_Q4.i64, (float16x4_t)v705, *(double *)&a9, *(int32x2_t *)&_D7, result, a2, v23, v25, v22, a14, a15, a16, v705.i16[0], a9.i16[0], v707,
                         SHIWORD(v707),
                         *(float *)&_D7);
              v708 = HIDWORD(result);
              v709 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v705.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v696 = v1012;
                v694 = v1027;
LABEL_628:
                v28->i16[0] = v705.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v708;
                v28->i16[3] = v709;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_630;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v696 = v1012;
              v694 = v1027;
            }
          }
LABEL_630:
          v30 += v693;
          v710 = &v36[v693];
          if ((unint64_t)v710 >= v26)
            v711 = v698;
          else
            v711 = 0;
          v695 += v694 + v711;
          v36 = &v710[v711];
          v21 = (__int16 *)((char *)v21 + v696);
          v28 = (float16x4_t *)((char *)v28 + v697);
          --v699;
        }
        while (v699);
        if (v1033)
        {
          v712 = v1040 + 8 * v1038;
          v713 = v982;
          if (v712 < v1033)
            v713 = 0;
          v695 = &v1039[v1036 + v713];
          v714 = v997;
          if (v712 < v1033)
            v714 = 0;
          v36 = (float16x4_t *)(v712 + 8 * v714);
          v26 += 8 * v714 + 8 * v1038;
          v1039 += v1036 + v713;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v695 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 24:
      v715 = v38;
      v716 = (int)v25;
      v717 = v1039;
      v998 = -(uint64_t)(v1038 * v35);
      v983 = -(uint64_t)(v1036 * v35);
      v718 = 2 * (int)v22;
      v719 = 8 * v38;
      v720 = -(uint64_t)v34;
      v1013 = v718;
      v1028 = (int)v25;
      while (1)
      {
        v721 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v717;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v724 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v724 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v725 = (__n128)vcvtq_f32_f16(*v36);
              v726 = (__n128)vmulq_n_f32((float32x4_t)v725, v724);
              v727 = (int32x2_t)vcvt_f16_f32((float32x4_t)v726);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v727.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v731) = v727.i16[2];
                  LOWORD(v732) = v727.i16[3];
                  goto LABEL_657;
                }
                v730 = vdup_lane_s32(v727, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v727.i16[1];
                v730 = vdup_lane_s32(v727, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v726.n128_u16[0] = v28->u16[1];
              v725.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAhuePDA(_Q0, v726, v725, a6, _S4, *(double *)&v727, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v727.i16[0], a9.i16[0], v730,
                         SHIWORD(v730),
                         *(float *)&_D7);
              v731 = HIDWORD(result);
              v732 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v727.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v718 = v1013;
                v716 = v1028;
LABEL_657:
                v28->i16[0] = v727.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v731;
                v28->i16[3] = v732;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_659;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v718 = v1013;
              v716 = v1028;
            }
          }
LABEL_659:
          v30 += v715;
          v733 = &v36[v715];
          if ((unint64_t)v733 >= v26)
            v734 = v720;
          else
            v734 = 0;
          v717 += v716 + v734;
          v36 = &v733[v734];
          v21 = (__int16 *)((char *)v21 + v718);
          v28 = (float16x4_t *)((char *)v28 + v719);
          --v721;
        }
        while (v721);
        if (v1033)
        {
          v735 = v1040 + 8 * v1038;
          v736 = v983;
          if (v735 < v1033)
            v736 = 0;
          v717 = &v1039[v1036 + v736];
          v737 = v998;
          if (v735 < v1033)
            v737 = 0;
          v36 = (float16x4_t *)(v735 + 8 * v737);
          v26 += 8 * v737 + 8 * v1038;
          v1039 += v1036 + v736;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v717 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 25:
      v738 = v38;
      v739 = (int)v25;
      v740 = v1039;
      v999 = -(uint64_t)(v1038 * v35);
      v984 = -(uint64_t)(v1036 * v35);
      v741 = 2 * (int)v22;
      v742 = 8 * v38;
      v743 = -(uint64_t)v34;
      v1014 = v741;
      v1029 = (int)v25;
      while (1)
      {
        v744 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v740;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            v747 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v747 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v748 = (__n128)vcvtq_f32_f16(*v36);
              v749 = (__n128)vmulq_n_f32((float32x4_t)v748, v747);
              v750 = (int32x2_t)vcvt_f16_f32((float32x4_t)v749);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S4, H1 }
                a9.i16[0] = v750.i16[1];
                if (_S4 <= 0.0)
                {
                  LOWORD(v754) = v750.i16[2];
                  LOWORD(v755) = v750.i16[3];
                  goto LABEL_686;
                }
                v753 = vdup_lane_s32(v750, 1).u32[0];
              }
              else
              {
                a9.i16[0] = v750.i16[1];
                v753 = vdup_lane_s32(v750, 1).u32[0];
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v28->i16[0];
              v749.n128_u16[0] = v28->u16[1];
              v748.n128_u16[0] = v28->u16[2];
              a6.n128_u16[0] = v28->u16[3];
              result = PDAsaturationPDA(_Q0, v749, v748, a6, _S4, *(double *)&v750, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v750.i16[0], a9.i16[0], v753,
                         SHIWORD(v753),
                         *(float *)&_D7);
              v754 = HIDWORD(result);
              v755 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v750.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                v25 = v1042;
                v741 = v1014;
                v739 = v1029;
LABEL_686:
                v28->i16[0] = v750.i16[0];
                v28->i16[1] = a9.i16[0];
                v28->i16[2] = v754;
                v28->i16[3] = v755;
                *v21 = _Q0.n128_u16[0];
                goto LABEL_688;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v741 = v1014;
              v739 = v1029;
            }
          }
LABEL_688:
          v30 += v738;
          v756 = &v36[v738];
          if ((unint64_t)v756 >= v26)
            v757 = v743;
          else
            v757 = 0;
          v740 += v739 + v757;
          v36 = &v756[v757];
          v21 = (__int16 *)((char *)v21 + v741);
          v28 = (float16x4_t *)((char *)v28 + v742);
          --v744;
        }
        while (v744);
        if (v1033)
        {
          v758 = v1040 + 8 * v1038;
          v759 = v984;
          if (v758 < v1033)
            v759 = 0;
          v740 = &v1039[v1036 + v759];
          v760 = v999;
          if (v758 < v1033)
            v760 = 0;
          v36 = (float16x4_t *)(v758 + 8 * v760);
          v26 += 8 * v760 + 8 * v1038;
          v1039 += v1036 + v759;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v740 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 26:
      v761 = v38;
      v762 = (int)v25;
      v763 = v1039;
      v1000 = -(uint64_t)(v1038 * v35);
      v985 = -(uint64_t)(v1036 * v35);
      v764 = 2 * (int)v22;
      v765 = 8 * v38;
      v766 = -(uint64_t)v34;
      v1015 = v764;
      v1030 = (int)v25;
      while (1)
      {
        v767 = v1037;
        do
        {
          if (*v30)
          {
            if ((_DWORD)v25)
            {
              _H0 = *v763;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            v770 = (float)*v30 * 0.0039216;
            _S1 = v770 * _S1;
            __asm
            {
              FCVT            H2, S1
              FCVT            S4, H2
            }
            if (_S4 > 0.0)
            {
              v774 = (__n128)vcvtq_f32_f16(*v36);
              v775 = (__n128)vmulq_n_f32((float32x4_t)v774, v770);
              v775.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v775);
              if ((_DWORD)v22)
              {
                _H1 = *v21;
                __asm { FCVT            S5, H1 }
                v774.n128_u16[0] = v775.n128_u16[1];
                if (_Q5.f32[0] <= 0.0)
                {
                  LOWORD(v777) = v775.n128_u16[2];
                  LOWORD(v778) = v775.n128_u16[3];
                  goto LABEL_715;
                }
                _Q2.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v775.n128_u64[0], 1);
              }
              else
              {
                v774.n128_u16[0] = v775.n128_u16[1];
                _Q2.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v775.n128_u64[0], 1);
                _Q5.i32[0] = 1.0;
              }
              a6.n128_u16[0] = _Q2.n128_u16[1];
              result = PDAluminosityPDA(v775, v774, _Q2, a6, _S4, *(double *)_Q5.i64, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v28->i32[0], HIWORD(v28->i32[0]), v28->i32[1],
                         HIWORD(v28->i32[1]),
                         _Q5.f32[0]);
              v777 = HIDWORD(result);
              v778 = HIWORD(result);
              v22 = v1043;
              if ((_DWORD)v1043)
              {
                v774.n128_u16[0] = WORD1(result);
                v775.n128_u16[0] = result;
                _H2 = a2;
                v25 = v1042;
                v764 = v1015;
                v762 = v1030;
LABEL_715:
                v28->i16[0] = v775.n128_u16[0];
                v28->i16[1] = v774.n128_u16[0];
                v28->i16[2] = v777;
                v28->i16[3] = v778;
                *v21 = _H2;
                goto LABEL_717;
              }
              *v28 = (float16x4_t)result;
              v25 = v1042;
              v764 = v1015;
              v762 = v1030;
            }
          }
LABEL_717:
          v30 += v761;
          v779 = &v36[v761];
          if ((unint64_t)v779 >= v26)
            v780 = v766;
          else
            v780 = 0;
          v763 += v762 + v780;
          v36 = &v779[v780];
          v21 = (__int16 *)((char *)v21 + v764);
          v28 = (float16x4_t *)((char *)v28 + v765);
          --v767;
        }
        while (v767);
        if (v1033)
        {
          v781 = v1040 + 8 * v1038;
          v782 = v985;
          if (v781 < v1033)
            v782 = 0;
          v763 = &v1039[v1036 + v782];
          v783 = v1000;
          if (v781 < v1033)
            v783 = 0;
          v36 = (float16x4_t *)(v781 + 8 * v783);
          v26 += 8 * v783 + 8 * v1038;
          v1039 += v1036 + v782;
          v1040 = (unint64_t)v36;
        }
        else
        {
          v36 += v1038;
          v763 += v1036;
        }
        v30 += v1035;
        v28 += v1034;
        v21 += v1032;
        if (!--v1041)
          return result;
      }
    case 27:
      v784 = v38;
      v785 = (int)v25;
      v786 = v1039;
      v1001 = -(uint64_t)(v1038 * v35);
      v986 = -(uint64_t)(v1036 * v35);
      v787 = 2 * (int)v22;
      v788 = 8 * v38;
      v789 = -(uint64_t)v34;
      v1016 = v787;
      v1031 = (int)v25;
      break;
    default:
      return result;
  }
  do
  {
    v790 = v1037;
    do
    {
      if (*v30)
      {
        if ((_DWORD)v25)
        {
          _H0 = *v786;
          __asm { FCVT            S0, H0 }
        }
        else
        {
          _S0 = 1.0;
        }
        v793 = (float)*v30 * 0.0039216;
        _Q0.n128_f32[0] = v793 * _S0;
        __asm
        {
          FCVT            H0, S0
          FCVT            S7, H0
        }
        if (*(float *)&_D7 > 0.0)
        {
          v794 = (__n128)vcvtq_f32_f16(*v36);
          v795 = (__n128)vmulq_n_f32((float32x4_t)v794, v793);
          v796 = (int32x2_t)vcvt_f16_f32((float32x4_t)v795);
          if ((_DWORD)v22)
          {
            _H1 = *v21;
            __asm { FCVT            S4, H1 }
            a9.i16[0] = v796.i16[1];
            if (_S4 <= 0.0)
            {
              LOWORD(v800) = v796.i16[2];
              LOWORD(v801) = v796.i16[3];
              goto LABEL_744;
            }
            v799 = vdup_lane_s32(v796, 1).u32[0];
          }
          else
          {
            a9.i16[0] = v796.i16[1];
            v799 = vdup_lane_s32(v796, 1).u32[0];
            _S4 = 1.0;
          }
          _Q0.n128_u16[0] = v28->i16[0];
          v795.n128_u16[0] = v28->u16[1];
          v794.n128_u16[0] = v28->u16[2];
          a6.n128_u16[0] = v28->u16[3];
          result = PDAluminosityPDA(_Q0, v795, v794, a6, _S4, *(double *)&v796, *(double *)&a9, _D7, result, a2, v23, v25, v22, a14, a15, a16, v796.i16[0], a9.i16[0], v799,
                     SHIWORD(v799),
                     *(float *)&_D7);
          v800 = HIDWORD(result);
          v801 = HIWORD(result);
          v22 = v1043;
          if ((_DWORD)v1043)
          {
            v796.i16[0] = result;
            a9.i32[0] = result >> 16;
            _Q0.n128_u16[0] = a2;
            v25 = v1042;
            v787 = v1016;
            v785 = v1031;
LABEL_744:
            v28->i16[0] = v796.i16[0];
            v28->i16[1] = a9.i16[0];
            v28->i16[2] = v800;
            v28->i16[3] = v801;
            *v21 = _Q0.n128_u16[0];
            goto LABEL_746;
          }
          *v28 = (float16x4_t)result;
          v25 = v1042;
          v787 = v1016;
          v785 = v1031;
        }
      }
LABEL_746:
      v30 += v784;
      v802 = &v36[v784];
      if ((unint64_t)v802 >= v26)
        v803 = v789;
      else
        v803 = 0;
      v786 += v785 + v803;
      v36 = &v802[v803];
      v21 = (__int16 *)((char *)v21 + v787);
      v28 = (float16x4_t *)((char *)v28 + v788);
      --v790;
    }
    while (v790);
    if (v1033)
    {
      v804 = v1040 + 8 * v1038;
      v805 = v986;
      if (v804 < v1033)
        v805 = 0;
      v786 = &v1039[v1036 + v805];
      v806 = v1001;
      if (v804 < v1033)
        v806 = 0;
      v36 = (float16x4_t *)(v804 + 8 * v806);
      v26 += 8 * v806 + 8 * v1038;
      v1039 += v1036 + v805;
      v1040 = (unint64_t)v36;
    }
    else
    {
      v36 += v1038;
      v786 += v1036;
    }
    v30 += v1035;
    v28 += v1034;
    v21 += v1032;
    --v1041;
  }
  while (v1041);
  return result;
}

uint64_t CMYKf16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  int *v6;
  _BOOL8 v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t (*v26)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double, float32x4_t);
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  _OWORD v32[64];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v6 = (int *)*a1;
  memset(v32, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*((_QWORD *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v26, (uint64_t)v32) < 1)
    return 0xFFFFFFFFLL;
  v18 = *v6;
  v19 = *(_DWORD *)a3;
  v27 = v19;
  v28 = v18;
  if (v19 != 269501477)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 <= 0x1B)
        _CGHandleAssert("CMYKf16_image_inner", 15096, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "index > SAMPLEF", "index = %d", v21, v22, v23, v20);
      v26 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double, float32x4_t))CMYKF16_image_sample[v20 + 1];
      if (v26)
      {
        v27 = 269501477;
        goto LABEL_27;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v26 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double, float32x4_t))&CMYK8_image_sample[2 * v20 + 2];
        if (v26)
        {
          v24 = 8;
          v25 = 134759444;
LABEL_26:
          v29 = v24;
          v27 = v25;
          goto LABEL_27;
        }
      }
      v26 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double, float32x4_t))&CMYK16_image_sample[2 * v20 + 2];
      if (v26)
      {
        v24 = 16;
        v25 = 269501476;
        goto LABEL_26;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v31 && (~v30 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((v30 & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      CMYKf16_mark_inner(*(_QWORD *)(*a1 + 56), v17);
      return 1;
    }
  }
  v26 = CMYKf16_sample_CMYKf_inner;
LABEL_27:
  CMYKf16_image_mark((uint64_t)a2, (uint64_t)&v26, v8, v17);
  return 1;
}

uint64_t CMYKf16_sample_CMYKf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, float32x4_t _Q7)
{
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  float16x4_t *v59;
  float16x4_t *v60;
  unint64_t v61;
  __int16 *v62;
  __int16 *v63;
  float16x4_t v65;
  unsigned int v66;
  int v67;
  uint64_t v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  float16x4_t *v81;
  unint64_t v82;
  float16x4_t *v83;
  float16x4_t *v84;
  float16x4_t v85;
  float16x4_t v86;
  float16x4_t v87;
  __int16 *v91;
  unint64_t v92;
  unint64_t v93;
  __int16 *v94;
  __int16 *v95;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float v106;
  float v107;
  float v110;
  float v111;
  float32x4_t v112;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  float16x4_t *v119;
  float16x4_t v120;
  __int16 *v122;
  float32x4_t v123;
  float v125;
  uint64_t v127;
  int64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  float16x4_t *v132;
  float16x4_t v133;
  __int16 *v135;
  float32x4_t v136;
  float16x4_t *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  float16x4_t *v150;
  __int16 *v151;
  __int16 *v152;
  unsigned int v153;
  unsigned int *v154;
  unsigned int v155;
  unsigned int v157;
  int v158;
  int v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  int v167;

  v14 = *(_DWORD *)(result + 24);
  v167 = *(_DWORD *)(result + 28);
  v15 = *(_QWORD *)(result + 112);
  v16 = *(_QWORD *)(result + 48);
  v17 = *(_QWORD *)(result + 56);
  if (v16)
  {
    v166 = *(_QWORD *)(result + 112);
    if (v15 > v16)
      v166 = v15 % v16;
  }
  else
  {
    v166 = 0;
  }
  v18 = *(_QWORD *)(result + 176);
  v20 = *(_QWORD *)(result + 32);
  v19 = *(_QWORD *)(result + 40);
  v21 = *(_QWORD *)(result + 120);
  if (v17)
  {
    v22 = v21 % v17;
    if (v21 <= v17)
      v22 = *(_QWORD *)(result + 120);
    v165 = v22;
  }
  else
  {
    v165 = 0;
  }
  v161 = *(_QWORD *)(result + 80);
  v163 = *(_QWORD *)(result + 88);
  v160 = *(_DWORD *)(result + 188);
  v23 = *(_QWORD *)(result + 152) - 10;
  v24 = *(_QWORD *)(result + 144) - 1;
  v25 = *(_DWORD *)(result + 260) - 1;
  v26 = *(_DWORD *)(result + 256);
  v27 = v19 + (v25 * v167) + 2 * (v26 - 1);
  v158 = *(_DWORD *)(result + 240);
  v28 = v20 + (v25 * v14) + 2 * (4 * v26) - 8;
  v162 = *(_QWORD *)(result + 64);
  v164 = *(_QWORD *)(result + 72);
  v159 = a4;
  while (1)
  {
    if (a3 >= v164)
    {
      if (a3 <= v163)
      {
        v37 = 0;
        v38 = ((unint64_t)a3 >> 22) & 0x3C0;
        v39 = 0x3FFFFFFF;
        v40 = a3;
        v41 = v162;
      }
      else
      {
        v33 = *(_QWORD *)(result + 216);
        v34 = *(_QWORD *)(result + 224) + v163;
        v35 = v34 - a3 + (v33 >> 1);
        if (v35 < 1)
          goto LABEL_56;
        if (v35 >= v33)
          LODWORD(v36) = 0x3FFFFFFF;
        else
          v36 = (unint64_t)(*(_QWORD *)(result + 232) * v35) >> 32;
        v41 = v162;
        v39 = v160 | v36;
        v40 = v34 - 0x1000000;
        v37 = a3 - (v34 - 0x1000000);
        v38 = 448;
      }
    }
    else
    {
      v29 = *(_QWORD *)(result + 216);
      v30 = v164 - *(_QWORD *)(result + 224);
      v31 = a3 - v30 + (v29 >> 1);
      if (v31 < 1)
        goto LABEL_56;
      if (v31 >= v29)
        LODWORD(v32) = 0x3FFFFFFF;
      else
        v32 = (unint64_t)(*(_QWORD *)(result + 232) * v31) >> 32;
      v41 = v162;
      v39 = v160 | v32;
      v40 = v30 + 0x1000000;
      v37 = a3 - (v30 + 0x1000000);
      v38 = 512;
    }
    if (a2 >= v41)
      break;
    v42 = *(_QWORD *)(result + 192);
    v43 = v41 - *(_QWORD *)(result + 200);
    v44 = a2 - v43 + (v42 >> 1);
    if (v44 >= 1)
    {
      if (v44 < v42)
        v39 = ((v39 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v44) >> 32) >> 15)) | v160;
      v45 = v43 + 0x1000000;
      v46 = a2 - (v43 + 0x1000000);
      v47 = 32;
      goto LABEL_35;
    }
LABEL_56:
    --a4;
    a2 += v15;
    a3 += v21;
    v23 += 10;
    *(_BYTE *)++v24 = 0;
LABEL_57:
    if (!a4)
      return result;
  }
  if (a2 <= v161)
  {
    v46 = 0;
    v47 = ((unint64_t)a2 >> 26) & 0x3C;
    v45 = a2;
    goto LABEL_35;
  }
  v48 = *(_QWORD *)(result + 192);
  v49 = *(_QWORD *)(result + 200) + v161;
  v50 = v49 - a2 + (v48 >> 1);
  if (v50 < 1)
    goto LABEL_56;
  if (v50 < v48)
    v39 = ((v39 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v50) >> 32) >> 15)) | v160;
  v45 = v49 - 0x1000000;
  v46 = a2 - (v49 - 0x1000000);
  v47 = 28;
LABEL_35:
  if (v39 < 0x400000)
    goto LABEL_56;
  if (v16)
  {
    v51 = (v17 & ((v40 % v17) >> 63)) + v40 % v17;
    v52 = (v16 & ((v45 % v16) >> 63)) + v45 % v16;
    if (v51 >= v17)
      v53 = v17;
    else
      v53 = 0;
    v40 = v51 - v53;
    if (v52 >= v16)
      v54 = v16;
    else
      v54 = 0;
    v45 = v52 - v54;
    v37 += v40;
    v46 += v52 - v54;
  }
  v55 = v40 >> 32;
  v56 = v45 >> 32;
  v57 = v20 + SHIDWORD(v40) * (uint64_t)v14;
  v58 = v57 + 8 * v56;
  v59 = *(float16x4_t **)(result + 32);
  if (v28 >= v58)
    v60 = (float16x4_t *)(v57 + 8 * v56);
  else
    v60 = (float16x4_t *)v28;
  if (v60 < v59)
    v60 = *(float16x4_t **)(result + 32);
  if (v19)
  {
    v61 = v19 + (int)v55 * (uint64_t)v167 + 2 * v56;
    v62 = *(__int16 **)(result + 40);
    if (v27 >= v61)
      v63 = (__int16 *)v61;
    else
      v63 = (__int16 *)v27;
    if (v63 >= v62)
      v62 = v63;
    _H3 = *v62;
  }
  else
  {
    v61 = 0;
    _H3 = 15360;
  }
  v65 = *v60;
  if (!v18)
    goto LABEL_154;
  v66 = *(_DWORD *)(v18 + (v47 | v38));
LABEL_62:
  v67 = v66 & 0xF;
  v68 = v66 >> 8;
  v69 = HIBYTE(v66) & 3;
  switch(v67)
  {
    case 1:
      LODWORD(v114) = SBYTE1(v66);
      if (v16)
      {
        v115 = v68 << 56;
        v116 = v37 + ((uint64_t)(char)v68 << 32);
        v117 = v17 & (v116 >> 63);
        if (v117 + v116 >= v17)
          v118 = v17;
        else
          v118 = 0;
        v114 = (v117 + (v115 >> 24) - v118) >> 32;
      }
      v119 = (float16x4_t *)(v58 + (int)v114 * (uint64_t)v14);
      if (v28 < (unint64_t)v119)
        v119 = (float16x4_t *)v28;
      if (v119 < v59)
        v119 = v59;
      v120 = *v119;
      _H6 = 15360;
      if (v19)
      {
        v122 = (__int16 *)(v61 + (int)v114 * (uint64_t)v167);
        if (v27 < (unint64_t)v122)
          v122 = (__int16 *)v27;
        if ((unint64_t)v122 < *(_QWORD *)(result + 40))
          v122 = *(__int16 **)(result + 40);
        _H6 = *v122;
      }
      _Q7.i16[0] = interpolate_cmykaf[5 * v69 + 4];
      __asm { FCVT            S7, H7 }
      v123 = vcvtq_f32_f16(v65);
      v65 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v123, v123, *(float32x2_t *)_Q7.f32, 0), vcvtq_f32_f16(v120), _Q7.f32[0]));
      __asm { FCVT            S3, H3 }
      v125 = _S3 - (float)(_S3 * _Q7.f32[0]);
      __asm { FCVT            S5, H6 }
      goto LABEL_152;
    case 2:
      v127 = SBYTE2(v66);
      if (v16)
      {
        v128 = (unint64_t)HIWORD(v66) << 56;
        v129 = v46 + (v128 >> 24);
        v130 = v16 & (v129 >> 63);
        if (v130 + v129 >= v16)
          v131 = v16;
        else
          v131 = 0;
        v127 = (v130 + (v128 >> 24) - v131) >> 32;
      }
      v132 = (float16x4_t *)(v58 + 8 * v127);
      if (v28 < (unint64_t)v132)
        v132 = (float16x4_t *)v28;
      if (v132 < v59)
        v132 = v59;
      v133 = *v132;
      _H5 = 15360;
      if (v19)
      {
        v135 = (__int16 *)(v61 + 2 * v127);
        if (v27 < (unint64_t)v135)
          v135 = (__int16 *)v27;
        if ((unint64_t)v135 < *(_QWORD *)(result + 40))
          v135 = *(__int16 **)(result + 40);
        _H5 = *v135;
      }
      _Q7.i16[0] = interpolate_cmykaf[5 * ((v66 >> 28) & 3) + 4];
      __asm { FCVT            S7, H7 }
      v136 = vcvtq_f32_f16(v65);
      v65 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v136, v136, *(float32x2_t *)_Q7.f32, 0), vcvtq_f32_f16(v133), _Q7.f32[0]));
      __asm { FCVT            S3, H3 }
      v125 = _S3 - (float)(_S3 * _Q7.f32[0]);
      __asm { FCVT            S5, H5 }
LABEL_152:
      _S3 = v125 + (float)(_S5 * _Q7.f32[0]);
      goto LABEL_153;
    case 3:
      LODWORD(v70) = SBYTE1(v66);
      v71 = SBYTE2(v66);
      if (v16)
      {
        v72 = v68 << 56;
        v73 = v37 + (v72 >> 24);
        v74 = v46 + ((uint64_t)SBYTE2(v66) << 32);
        v157 = v39;
        v75 = v17 & (v73 >> 63);
        v76 = v16 & (v74 >> 63);
        v77 = v76 + v74;
        if (v75 + v73 >= v17)
          v78 = v17;
        else
          v78 = 0;
        if (v77 >= v16)
          v79 = v16;
        else
          v79 = 0;
        v80 = v75 + (v72 >> 24);
        v39 = v157;
        v70 = (v80 - v78) >> 32;
        v71 = (v76 + ((uint64_t)((unint64_t)HIWORD(v66) << 56) >> 24) - v79) >> 32;
      }
      v81 = (float16x4_t *)(v58 + 8 * v71);
      if (v28 < (unint64_t)v81)
        v81 = (float16x4_t *)v28;
      if (v81 < v59)
        v81 = v59;
      v82 = v58 + (int)v70 * (uint64_t)v14;
      if (v28 >= v82)
        v83 = (float16x4_t *)(v58 + (int)v70 * (uint64_t)v14);
      else
        v83 = (float16x4_t *)v28;
      if (v83 < v59)
        v83 = v59;
      v84 = (float16x4_t *)(v82 + 8 * v71);
      if (v28 < (unint64_t)v84)
        v84 = (float16x4_t *)v28;
      if (v84 < v59)
        v84 = v59;
      v85 = *v81;
      v86 = *v83;
      v87 = *v84;
      _H16 = 15360;
      _H17 = 15360;
      _H18 = 15360;
      if (v19)
      {
        v91 = (__int16 *)(v61 + 2 * v71);
        v92 = *(_QWORD *)(result + 40);
        if (v27 < (unint64_t)v91)
          v91 = (__int16 *)v27;
        if ((unint64_t)v91 < v92)
          v91 = *(__int16 **)(result + 40);
        _H16 = *v91;
        v93 = v61 + (int)v70 * (uint64_t)v167;
        if (v27 >= v93)
          v94 = (__int16 *)(v61 + (int)v70 * (uint64_t)v167);
        else
          v94 = (__int16 *)v27;
        if ((unint64_t)v94 < v92)
          v94 = *(__int16 **)(result + 40);
        _H17 = *v94;
        v95 = (__int16 *)(v93 + 2 * v71);
        if (v27 < (unint64_t)v95)
          v95 = (__int16 *)v27;
        if ((unint64_t)v95 < v92)
          v95 = *(__int16 **)(result + 40);
        _H18 = *v95;
      }
      _H19 = interpolate_cmykaf[5 * (HIBYTE(v66) & 3) + 4];
      __asm { FCVT            S19, H19 }
      _H20 = interpolate_cmykaf[5 * ((v66 >> 28) & 3) + 4];
      __asm { FCVT            S20, H20 }
      v101 = vcvtq_f32_f16(v65);
      v102 = vcvtq_f32_f16(v85);
      v103 = vcvtq_f32_f16(v86);
      _Q7 = vcvtq_f32_f16(v87);
      __asm
      {
        FCVT            S3, H3
        FCVT            S16, H16
      }
      v106 = (float)(_S3 - (float)(_S3 * _D20.f32[0])) + (float)(_S16 * _D20.f32[0]);
      if (v106 < 1.0)
        v107 = v106;
      else
        v107 = 1.0;
      if (v106 > 1.0)
        v106 = 1.0;
      if (v107 < 0.0)
        v106 = 0.0;
      __asm
      {
        FCVT            S16, H17
        FCVT            S17, H18
      }
      v110 = (float)(_S16 - (float)(_S16 * _D20.f32[0])) + (float)(_S17 * _D20.f32[0]);
      if (v110 < 1.0)
        v111 = v110;
      else
        v111 = 1.0;
      if (v110 > 1.0)
        v110 = 1.0;
      if (v111 < 0.0)
        v110 = 0.0;
      v112 = vmlaq_n_f32(vmlsq_lane_f32(v101, v101, _D20, 0), v102, _D20.f32[0]);
      v65 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v112, v112, _D19, 0), vmlaq_n_f32(vmlsq_lane_f32(v103, v103, _D20, 0), _Q7, _D20.f32[0]), _D19.f32[0]));
      _S3 = (float)(v106 - (float)(v106 * _D19.f32[0])) + (float)(v110 * _D19.f32[0]);
      if (_S3 >= 1.0)
        _S3 = 1.0;
      if (_S3 <= 0.0)
        _S3 = 0.0;
LABEL_153:
      __asm { FCVT            H3, S3 }
      break;
  }
LABEL_154:
  *(float16x4_t *)(v23 + 10) = v65;
  *(_WORD *)(v23 + 18) = _H3;
  *(_BYTE *)++v24 = v39 >> 22;
  if (--a4)
  {
    v138 = (float16x4_t *)(v23 + 28);
    a2 += v15;
    v139 = v161 - a2;
    a3 += v21;
    v140 = v163 - a3;
    while (1)
    {
      v23 = (uint64_t)&v138[-3] + 6;
      if ((v140 | v139 | (a3 - v164) | (a2 - v162)) < 0)
        goto LABEL_57;
      if (v16)
      {
        v141 = (v17 & ((v37 + v165) >> 63)) + v37 + v165;
        v142 = (v16 & ((v46 + v166) >> 63)) + v46 + v166;
        if (v141 >= v17)
          v143 = v17;
        else
          v143 = 0;
        v37 = v141 - v143;
        if (v142 >= v16)
          v144 = v16;
        else
          v144 = 0;
        v46 = v142 - v144;
        v145 = v37;
        v146 = v46;
      }
      else
      {
        v145 = a3;
        v146 = a2;
      }
      v147 = v146 >> 32;
      v148 = v145 >> 32;
      v149 = v20 + (int)v148 * (uint64_t)v14;
      v58 = v149 + 8 * v147;
      v59 = *(float16x4_t **)(result + 32);
      if (v28 >= v58)
        v150 = (float16x4_t *)(v149 + 8 * v147);
      else
        v150 = (float16x4_t *)v28;
      if (v150 < v59)
        v150 = *(float16x4_t **)(result + 32);
      _H3 = 15360;
      if (v19)
      {
        v61 = v19 + (int)v148 * (uint64_t)v167 + 2 * v147;
        v151 = *(__int16 **)(result + 40);
        if (v27 >= v61)
          v152 = (__int16 *)v61;
        else
          v152 = (__int16 *)v27;
        if (v152 >= v151)
          v151 = v152;
        _H3 = *v151;
      }
      v65 = *v150;
      if (v18)
      {
        v66 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        v153 = v66 & 0xF;
        if ((v66 & 0xF) != 0)
        {
          v154 = *(unsigned int **)(result + 264);
          v155 = *v154;
          if (a4 + 1 != v159 && a4 != 1 && v158 != 1 && v155 == 3 && v153 < 3)
            v66 |= 3u;
          v39 = -1;
          if (v155 < v153)
            *v154 = v153;
          goto LABEL_62;
        }
      }
      v138[-1] = v65;
      v138->i16[0] = _H3;
      v138 = (float16x4_t *)((char *)v138 + 10);
      a2 += v15;
      v139 -= v15;
      a3 += v21;
      *(_BYTE *)++v24 = -1;
      v140 -= v21;
      if (!--a4)
        return result;
    }
  }
  return result;
}

void CMYKf16_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  __int16 *v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  float16x4_t *v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  _QWORD *v36;
  uint64_t v37;
  void *v38;
  unsigned __int8 *v39;
  void *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  int v45;
  uint64_t v46;
  uint64_t (*v47)(_QWORD *, unint64_t);
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __n128 v58;
  __n128 v59;
  double v62;
  float16x4_t *v64;
  unsigned __int8 *v65;
  unsigned int v66;
  int v67;
  _BYTE *v68;
  uint64_t v73;
  int v74;
  uint64_t v75;
  _WORD *v76;
  float16x4_t *v77;
  uint64_t v78;
  unsigned __int16 *v79;
  _WORD *v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v87;
  unint64_t v88;
  uint64_t v93;
  float16x4_t *v94;
  uint64_t v95;
  float32x4_t v96;
  _WORD *v97;
  uint64_t v98;
  __int128 *v103;
  uint64_t v104;
  int v105;
  unsigned __int8 *v106;
  unsigned int v107;
  float v109;
  unsigned __int8 v113;
  uint64_t v114;
  float16x4_t *v115;
  _BYTE *v116;
  __int16 *v117;
  float16x4_t *v118;
  unint64_t v119;
  unsigned int v120;
  float v122;
  unsigned __int8 v128;
  uint64_t v129;
  _BYTE *v130;
  __int16 *v131;
  float16x4_t *v132;
  unsigned int v133;
  float v139;
  float16x4_t *v146;
  int v147;
  unsigned int v148;
  float v166;
  float v169;
  float v170;
  float16x4_t *v174;
  int v175;
  unsigned int v176;
  float v194;
  float v197;
  float v198;
  float16x4_t *v202;
  int v203;
  unsigned int v204;
  unsigned int v205;
  float v208;
  float16x4_t *v214;
  int v215;
  unsigned int v216;
  unsigned int v217;
  float v220;
  float v221;
  float v225;
  uint64_t v229;
  float16x4_t *v230;
  int v231;
  unsigned int v232;
  float v236;
  float v241;
  float v242;
  float32x4_t v243;
  uint64_t v245;
  float16x4_t *v246;
  int v247;
  unsigned int v248;
  float v251;
  float v255;
  float v260;
  float v261;
  float32x4_t v262;
  float16x4_t *v264;
  int v265;
  unsigned int v266;
  unsigned int v267;
  float v270;
  float v275;
  float16x4_t *v277;
  int v278;
  unsigned int v279;
  unsigned int v280;
  float v283;
  uint64_t v289;
  __int16 *v290;
  int v291;
  unsigned int v292;
  unsigned int v293;
  float v296;
  float v319;
  float v323;
  float v329;
  float v333;
  uint64_t v337;
  float16x4_t *v338;
  int v339;
  unsigned int v340;
  unsigned int v341;
  float v342;
  float32x4_t v351;
  float16x4_t v352;
  int v353;
  float16x4_t *v354;
  int v355;
  unsigned __int8 *v356;
  unsigned int v357;
  unsigned int v358;
  float v359;
  __n128 v362;
  __n128 v363;
  int32x2_t v364;
  unsigned __int32 v367;
  unint64_t v368;
  unint64_t v369;
  int v370;
  float16x4_t *v371;
  int v372;
  unsigned int v373;
  unsigned int v374;
  float v375;
  __n128 v378;
  __n128 v379;
  int32x2_t v380;
  unsigned __int32 v383;
  unint64_t v384;
  unint64_t v385;
  int v386;
  float16x4_t *v387;
  int v388;
  unsigned int v389;
  unsigned int v390;
  float v391;
  __n128 v394;
  __n128 v395;
  int32x2_t v396;
  unsigned __int32 v399;
  unint64_t v400;
  unint64_t v401;
  int v402;
  float16x4_t *v403;
  int v404;
  unsigned int v405;
  unsigned int v406;
  float v407;
  __n128 v410;
  __n128 v411;
  __int32 v413;
  unint64_t v414;
  unint64_t v415;
  int v416;
  float16x4_t *v417;
  int v418;
  unsigned int v419;
  unsigned int v420;
  float v421;
  __n128 v424;
  __n128 v425;
  __int32 v427;
  unint64_t v428;
  unint64_t v429;
  int v430;
  float16x4_t *v431;
  int v432;
  unsigned int v433;
  unsigned int v434;
  float v435;
  __n128 v438;
  __n128 v439;
  int32x2_t v440;
  unsigned __int32 v443;
  unint64_t v444;
  unint64_t v445;
  int v446;
  float16x4_t *v447;
  int v448;
  unsigned int v449;
  unsigned int v450;
  float v451;
  __n128 v454;
  __n128 v455;
  int32x2_t v456;
  unsigned __int32 v459;
  unint64_t v460;
  unint64_t v461;
  int v462;
  float16x4_t *v463;
  int v464;
  unsigned int v465;
  unsigned int v466;
  float v467;
  __n128 v470;
  __n128 v471;
  int32x2_t v472;
  unsigned __int32 v474;
  unint64_t v475;
  unint64_t v476;
  int v477;
  float16x4_t *v478;
  int v479;
  unsigned int v480;
  unsigned int v481;
  float v482;
  __n128 v485;
  __n128 v486;
  int32x2_t v487;
  unsigned __int32 v490;
  unint64_t v491;
  unint64_t v492;
  int v493;
  float16x4_t *v494;
  int v495;
  unsigned int v496;
  unsigned int v497;
  float v498;
  __n128 v501;
  __n128 v502;
  int32x2_t v503;
  unsigned __int32 v505;
  unint64_t v506;
  unint64_t v507;
  int v508;
  float16x4_t *v509;
  int v510;
  unsigned int v511;
  unsigned int v512;
  float v513;
  __n128 v516;
  __n128 v517;
  int32x2_t v518;
  unsigned __int32 v520;
  unint64_t v521;
  unint64_t v522;
  int v523;
  float16x4_t *v524;
  int v525;
  unsigned int v526;
  unsigned int v527;
  float v528;
  __n128 v531;
  __n128 v532;
  int32x2_t v533;
  unsigned __int32 v536;
  unint64_t v537;
  unint64_t v538;
  int v539;
  float16x4_t *v540;
  int v541;
  unsigned int v542;
  unsigned int v543;
  float v544;
  __n128 v547;
  __n128 v548;
  int32x2_t v549;
  unsigned __int32 v552;
  unint64_t v553;
  unint64_t v554;
  float16x4_t *v555;
  unsigned int v556;
  unsigned int v557;
  float v558;
  __n128 v564;
  __n128 v565;
  unint64_t v567;
  unint64_t v568;
  int v569;
  float16x4_t *v570;
  int v571;
  unsigned int v572;
  unsigned int v573;
  float v574;
  __n128 v577;
  __n128 v578;
  int32x2_t v579;
  unsigned __int32 v582;
  unint64_t v583;
  unint64_t v584;
  int v585;
  unsigned int v586;
  unsigned __int8 *v587;
  float16x4_t *v588;
  int v589;
  unsigned int v590;
  float16x4_t v591;
  unsigned __int8 v592;
  unsigned __int8 *v593;
  float16x4_t *v594;
  int v595;
  unsigned int v596;
  float16x4_t v599;
  float v600;
  unsigned __int8 v605;
  const __int16 *v606;
  int v607;
  unsigned int v608;
  float16x4_t v609;
  float32x4_t v610;
  float32x4_t v613;
  float16x4_t *v614;
  int v615;
  unsigned int v616;
  float v621;
  _WORD *v627;
  float v630;
  float v635;
  float v636;
  float16x4_t *v644;
  int v645;
  unsigned int v646;
  unsigned int v647;
  float v648;
  int v650;
  unsigned __int8 *v651;
  unsigned int v652;
  unsigned int v653;
  float16x4_t *v654;
  unsigned __int8 *v655;
  int v656;
  float v658;
  unsigned __int8 v664;
  unsigned __int8 *v665;
  int v666;
  float v672;
  unsigned __int8 v679;
  float16x4_t v680;
  unsigned __int8 v681;
  float16x4_t *v682;
  float16x4_t v685;
  float v686;
  unsigned __int8 v691;
  uint64_t v692;
  int v693;
  int v694;
  int v695;
  int v696;
  int v697;
  uint64_t v698;
  float16x4_t v699;
  float16x4_t v700;
  __int32 v701;
  unint64_t v702;
  void *v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  _QWORD *v708;
  int v709;
  uint64_t v710;
  uint64_t v711;
  __n128 v712;
  uint64_t v713;
  int v714;
  unint64_t v715;
  void *v716;
  uint64_t v717;
  int v718;
  uint64_t v719;
  int v720;
  uint64_t v721;

  v709 = a3;
  v721 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 4);
  v714 = *(_DWORD *)(a1 + 8);
  v707 = v4;
  v5 = *(int *)(a1 + 28);
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  v8 = *(int **)(a1 + 136);
  v9 = *(_QWORD *)(a2 + 96);
  v717 = *(_QWORD *)(a2 + 104);
  v720 = 0;
  *(_QWORD *)(a2 + 264) = &v720;
  v706 = (int)v4;
  v10 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v10 > 0x1FFFFFF)
    return;
  v712 = a4;
  v13 = *(int *)(a1 + 12);
  v12 = *(int *)(a1 + 16);
  v708 = (_QWORD *)a2;
  v716 = (void *)*(int *)(a2 + 16);
  v14 = ((_QWORD)v716 + 12) * v10;
  if (v14 > 65439)
  {
    v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x768749E2uLL);
    v16 = v17;
    v19 = v17;
    v20 = v708;
    if (!v17)
      return;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1, a4);
    v16 = (char *)&v702 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    v19 = 0;
    v20 = v708;
  }
  v703 = v19;
  v21 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  v22 = v21 + ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((_DWORD)v716)
    v23 = (10 * v10 + 15) & 0xFFFFFFFFFFFFFFF0;
  else
    v23 = 0;
  v24 = v22 + v23;
  v25 = v5 >> 3;
  v20[18] = v21;
  v20[19] = v24;
  v20[20] = v22;
  if (v7)
  {
    v26 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v27 = (__int16 *)(v7 + 2 * (v13 + v26 * v12));
    v28 = v706;
    v29 = v707;
    v713 = v26 - v706;
    v719 = 1;
  }
  else
  {
    v27 = 0;
    v713 = 0;
    v719 = 0;
    v28 = v706;
    v29 = v707;
  }
  v30 = v9;
  v31 = (float16x4_t *)(v6 + 8 * (v13 + v25 * v12));
  v711 = v25 - v28;
  v32 = *(int *)(a1 + 104);
  v33 = *(_DWORD *)(a1 + 108);
  v34 = *(unsigned __int8 *)(a1 + 2);
  if (v34 == 6 || v34 == 1)
  {
    v35 = v709;
    v36 = v708;
    if (v8)
    {
      v702 = v25;
      v718 = 0;
      v37 = *(int *)(a1 + 124);
      v38 = 0;
      v39 = (unsigned __int8 *)v8 + v32 + (int)v37 * (uint64_t)v33;
      v28 = v706;
      v710 = v37 - v706;
      goto LABEL_21;
    }
    goto LABEL_584;
  }
  v702 = v25;
  v35 = v709;
  v36 = v708;
  if (v8)
  {
    v715 = v24;
    shape_enum_clip_alloc((uint64_t)v17, v18, v8, 1, 1, 1, v32, v33, v29, v714);
    if (!v40)
      goto LABEL_584;
    v38 = v40;
    v718 = 0;
    v41 = (int)(((_DWORD)v716 * v10 + 15) & 0xFFFFFFF0);
    if (!(_DWORD)v716)
      v41 = (10 * v10 + 15) & 0xFFFFFFFFFFFFFFF0;
    v42 = v706;
    v710 = -v706;
    v39 = (unsigned __int8 *)(v715 + v41 + 16);
LABEL_587:
    v692 = v713 + v42;
    v693 = v718;
LABEL_588:
    v718 = v693;
    while (1)
    {
      v694 = *((_DWORD *)v39 - 4);
      v695 = v693;
      _VF = __OFSUB__(v694, v693);
      v696 = v694 - v693;
      if (!((v696 < 0) ^ _VF | (v696 == 0)))
      {
        v714 -= v696;
        if (v714 < 1)
          goto LABEL_582;
        v30 += v36[16] * v696;
        v717 += v36[17] * v696;
        v31 += v702 * v696;
        v698 = v692 * v696;
        if (!(_DWORD)v719)
          v698 = 0;
        v27 += v698;
        v693 = v694;
        goto LABEL_588;
      }
      if (v695 < *((_DWORD *)v39 - 3) + v694)
        break;
      v697 = shape_enum_clip_scan((uint64_t)v38, (_DWORD *)v39 - 4);
      v693 = v718;
      if (!v697)
        goto LABEL_582;
    }
    v28 = v706;
  }
  else
  {
    v710 = 0;
    v38 = 0;
    v39 = 0;
    v718 = 0;
  }
LABEL_21:
  v704 = -v28;
  v705 = (v29 - 1) + 1;
  v43 = 2 * v719;
  v44 = v38;
  v45 = v714;
  v46 = v717;
  while (2)
  {
    v715 = v30;
    v716 = v44;
    *((_DWORD *)v36 + 60) = v45;
    v47 = (uint64_t (*)(_QWORD *, unint64_t))*v36;
    v717 = v46;
    v48 = v47(v36, v30);
    v64 = (float16x4_t *)v36[20];
    v65 = (unsigned __int8 *)v36[18];
    v66 = *((_DWORD *)v36 + 2);
    if (v66 == *((_DWORD *)v36 + 3))
    {
      _Q1.i64[0] = v712.n128_u64[0];
      if (v712.n128_f32[0] < 1.0)
      {
        v67 = v29;
        v68 = (_BYTE *)v36[18];
        do
        {
          if (*v68)
          {
            _Q0 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*v64), _Q1.f32[0]);
            _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
            *v64 = (float16x4_t)_Q0.n128_u64[0];
            _Q0.n128_u16[0] = v64[1].u16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = _Q1.f32[0] * _Q0.n128_f32[0];
            __asm { FCVT            H0, S0 }
            v64[1].i16[0] = _Q0.n128_u16[0];
          }
          ++v68;
          v64 = (float16x4_t *)((char *)v64 + 10);
          --v67;
        }
        while (v67);
        v64 = (float16x4_t *)((char *)v64 + 10 * v704);
        v65 += v705 + v704;
      }
    }
    else
    {
      v73 = v36[19];
      v74 = HIWORD(v66) & 0x3F;
      v58 = v712;
      if (v74 == 16)
      {
        v78 = 0;
        v79 = (unsigned __int16 *)(v73 + 8);
        v80 = (_WORD *)v64 + 2;
        if (v712.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v65[v78])
            {
              v87 = *v79;
              v88 = *((_QWORD *)v79 - 1);
              _S0 = *(float *)&_blt_float[v88 + 256] + *(float *)&_blt_float[BYTE1(v88) + 512];
              __asm { FCVT            H0, S0 }
              *(v80 - 2) = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[BYTE2(v88) + 256] + *(float *)&_blt_float[BYTE3(v88) | 0x200];
              __asm { FCVT            H0, S0 }
              *(v80 - 1) = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[BYTE4(v88) + 256] + *(float *)&_blt_float[BYTE5(v88) + 512];
              __asm { FCVT            H0, S0 }
              *v80 = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[BYTE6(v88) + 256] + *(float *)&_blt_float[HIBYTE(v88) + 512];
              __asm { FCVT            H0, S0 }
              v80[1] = LOWORD(_S0);
              _Q0.n128_f32[0] = *(float *)&_blt_float[v87 + 256]
                              + *(float *)((char *)&_blt_float[512] + ((v87 >> 6) & 0x3FC));
              __asm { FCVT            H0, S0 }
              v80[2] = _Q0.n128_u16[0];
            }
            v79 += 8;
            ++v78;
            v80 += 5;
          }
          while (v29 != (_DWORD)v78);
        }
        else
        {
          do
          {
            if (v65[v78])
            {
              v81 = *v79;
              v82 = *((_QWORD *)v79 - 1);
              _S0 = v58.n128_f32[0]
                  * (float)(*(float *)&_blt_float[v82 + 256] + *(float *)&_blt_float[BYTE1(v82) + 512]);
              __asm { FCVT            H0, S0 }
              *(v80 - 2) = LOWORD(_S0);
              _S0 = v58.n128_f32[0]
                  * (float)(*(float *)&_blt_float[BYTE2(v82) + 256] + *(float *)&_blt_float[BYTE3(v82) | 0x200]);
              __asm { FCVT            H0, S0 }
              *(v80 - 1) = LOWORD(_S0);
              _S0 = v58.n128_f32[0]
                  * (float)(*(float *)&_blt_float[BYTE4(v82) + 256] + *(float *)&_blt_float[BYTE5(v82) + 512]);
              __asm { FCVT            H0, S0 }
              *v80 = LOWORD(_S0);
              _S0 = v58.n128_f32[0]
                  * (float)(*(float *)&_blt_float[BYTE6(v82) + 256] + *(float *)&_blt_float[HIBYTE(v82) + 512]);
              __asm { FCVT            H0, S0 }
              v80[1] = LOWORD(_S0);
              _Q0.n128_f32[0] = v58.n128_f32[0]
                              * (float)(*(float *)&_blt_float[v81 + 256]
                                      + *(float *)((char *)&_blt_float[512] + ((v81 >> 6) & 0x3FC)));
              __asm { FCVT            H0, S0 }
              v80[2] = _Q0.n128_u16[0];
            }
            v79 += 8;
            ++v78;
            v80 += 5;
          }
          while (v29 != (_DWORD)v78);
        }
      }
      else if (v74 == 32)
      {
        v75 = 0;
        v76 = (_WORD *)(v73 + 8);
        v77 = v64 + 1;
        if (v712.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v65[v75])
            {
              _Q0.n128_u64[0] = *((_QWORD *)v76 - 1);
              v77[-1] = (float16x4_t)_Q0.n128_u64[0];
              v77->i16[0] = *v76;
            }
            v76 += 5;
            ++v75;
            v77 = (float16x4_t *)((char *)v77 + 10);
          }
          while (v29 != (_DWORD)v75);
        }
        else
        {
          do
          {
            if (v65[v75])
            {
              _Q0 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)(v76 - 4)), v58.n128_f32[0]);
              _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
              v77[-1] = (float16x4_t)_Q0.n128_u64[0];
              _Q0.n128_u16[0] = *v76;
              __asm { FCVT            S0, H0 }
              _Q0.n128_f32[0] = v58.n128_f32[0] * _Q0.n128_f32[0];
              __asm { FCVT            H0, S0 }
              v77->i16[0] = _Q0.n128_u16[0];
            }
            v76 += 5;
            ++v75;
            v77 = (float16x4_t *)((char *)v77 + 10);
          }
          while (v29 != (_DWORD)v75);
        }
      }
      else
      {
        v93 = 0;
        if (v712.n128_f32[0] >= 1.0)
        {
          v97 = (_WORD *)v64 + 2;
          do
          {
            if (v65[v93])
            {
              v98 = *(_QWORD *)(v73 + 8 * v93);
              _S0 = _blt_float[BYTE3(v98)];
              __asm { FCVT            H0, S0 }
              *(v97 - 2) = _S0;
              _S0 = _blt_float[BYTE2(v98)];
              __asm { FCVT            H0, S0 }
              *(v97 - 1) = _S0;
              _S0 = _blt_float[BYTE1(v98)];
              __asm { FCVT            H0, S0 }
              *v97 = _S0;
              _S0 = _blt_float[v98];
              __asm { FCVT            H0, S0 }
              v97[1] = _S0;
              _Q0.n128_u32[0] = _blt_float[BYTE4(v98)];
              __asm { FCVT            H0, S0 }
              v97[2] = _Q0.n128_u16[0];
            }
            ++v93;
            v97 += 5;
          }
          while (v29 != (_DWORD)v93);
        }
        else
        {
          v94 = v64 + 1;
          do
          {
            if (v65[v93])
            {
              v95 = *(_QWORD *)(v73 + 8 * v93);
              v96.i32[0] = _blt_float[BYTE3(v95)];
              v96.i32[1] = _blt_float[BYTE2(v95)];
              v96.i32[2] = _blt_float[BYTE1(v95)];
              v96.i32[3] = _blt_float[v95];
              _Q0 = (__n128)vmulq_n_f32(v96, v58.n128_f32[0]);
              _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
              v94[-1] = (float16x4_t)_Q0.n128_u64[0];
              _Q0.n128_f32[0] = v58.n128_f32[0] * *(float *)&_blt_float[BYTE4(v95)];
              __asm { FCVT            H0, S0 }
              v94->i16[0] = _Q0.n128_u16[0];
            }
            ++v93;
            v94 = (float16x4_t *)((char *)v94 + 10);
          }
          while (v29 != (_DWORD)v93);
        }
      }
    }
    v103 = &xmmword_185005000;
    switch(v35)
    {
      case 0:
        v104 = v39 != 0;
        if ((_DWORD)v719)
        {
          v105 = v29;
          v106 = v39;
          do
          {
            v107 = *v65;
            if (*v65)
            {
              if (v39)
                v107 = (*v106 * v107 + ((*v106 * v107) >> 8) + 1) >> 8;
              if ((_BYTE)v107)
              {
                if (v107 == 255)
                {
                  *v31 = 0;
                  _H0 = 0;
                }
                else
                {
                  v109 = (float)((float)v107 * -0.0039216) + 1.0;
                  *v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), v109));
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _S0 = v109 * _S1;
                  __asm { FCVT            H0, S0 }
                }
                *v27 = _H0;
              }
            }
            ++v65;
            v106 += v104;
            ++v31;
            ++v27;
            --v105;
          }
          while (v105);
        }
        else
        {
          v585 = v29;
          v106 = v39;
          do
          {
            v586 = *v65;
            if (*v65)
            {
              if (v39)
                v586 = (*v106 * v586 + ((*v106 * v586) >> 8) + 1) >> 8;
              if ((_BYTE)v586)
              {
                if (v586 == 255)
                  *v31 = 0;
                else
                  *v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), (float)((float)v586 * -0.0039216) + 1.0));
              }
            }
            ++v65;
            v106 += v104;
            ++v31;
            --v585;
          }
          while (v585);
        }
        goto LABEL_521;
      case 1:
        v113 = *v65;
        if ((_DWORD)v719)
        {
          if (v39)
          {
            v114 = 0;
            v115 = v64 + 1;
            v116 = v65 + 1;
            v117 = v27 - 1;
            v118 = v31 - 1;
            v119 = v715;
            do
            {
              if (v113)
              {
                v120 = ((unsigned __int16)(v39[v114] * v113
                                                          + ((v39[v114] * v113) >> 8)
                                                          + 1) >> 8);
                if (v120)
                {
                  if (v120 == 255)
                  {
                    v31[v114] = v115[-1];
                    _H0 = v115->i16[0];
                  }
                  else
                  {
                    v122 = (float)v120 * 0.0039216;
                    v31[v114] = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v31[v114]), 1.0 - v122), vcvtq_f32_f16(v115[-1]), v122));
                    _H2 = v115->i16[0];
                    __asm { FCVT            S2, H2 }
                    _H3 = v27[v114];
                    __asm { FCVT            S3, H3 }
                    _S0 = (float)((float)(1.0 - v122) * _S3) + (float)(_S2 * v122);
                    __asm { FCVT            H0, S0 }
                  }
                  v27[v114] = _H0;
                }
              }
              v113 = v116[v114++];
              v115 = (float16x4_t *)((char *)v115 + 10);
              ++v117;
              ++v118;
            }
            while (v29 != (_DWORD)v114);
            v39 += v114 + v710;
          }
          else
          {
            v654 = v64 + 1;
            v655 = v65 + 1;
            v117 = v27 - 1;
            v118 = v31 - 1;
            v656 = v29;
            v119 = v715;
            do
            {
              if (v113)
              {
                if (v113 == 255)
                {
                  v118[1] = v654[-1];
                  _H0 = v654->i16[0];
                }
                else
                {
                  v658 = (float)v113 * 0.0039216;
                  v118[1] = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v118[1]), 1.0 - v658), vcvtq_f32_f16(v654[-1]), v658));
                  _H2 = v654->i16[0];
                  __asm { FCVT            S2, H2 }
                  _H3 = v117[1];
                  __asm { FCVT            S3, H3 }
                  _S0 = (float)((float)(1.0 - v658) * _S3) + (float)(_S2 * v658);
                  __asm { FCVT            H0, S0 }
                }
                v117[1] = _H0;
              }
              v664 = *v655++;
              v113 = v664;
              v654 = (float16x4_t *)((char *)v654 + 10);
              ++v117;
              ++v118;
              --v656;
            }
            while (v656);
            v39 = 0;
          }
          v31 = &v118[v711 + 1];
          v27 = &v117[v713 + 1];
          goto LABEL_524;
        }
        v587 = v65 + 1;
        v588 = v31 - 1;
        v589 = v29;
        if (v39)
        {
          v119 = v715;
          do
          {
            if (v113)
            {
              v590 = ((unsigned __int16)(*v39 * v113 + ((*v39 * v113) >> 8) + 1) >> 8);
              if (v590)
              {
                if (v590 == 255)
                  v591 = *v64;
                else
                  v591 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v588[1]), 1.0 - (float)((float)v590 * 0.0039216)), vcvtq_f32_f16(*v64), (float)v590 * 0.0039216));
                v588[1] = v591;
              }
            }
            v592 = *v587++;
            v113 = v592;
            v64 = (float16x4_t *)((char *)v64 + 10);
            ++v39;
            ++v588;
            --v589;
          }
          while (v589);
          v39 += v710;
        }
        else
        {
          v119 = v715;
          do
          {
            if (v113)
            {
              if (v113 == 255)
                v680 = *v64;
              else
                v680 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v588[1]), 1.0 - (float)((float)v113 * 0.0039216)), vcvtq_f32_f16(*v64), (float)v113 * 0.0039216));
              v588[1] = v680;
            }
            v681 = *v587++;
            v113 = v681;
            v64 = (float16x4_t *)((char *)v64 + 10);
            ++v588;
            --v589;
          }
          while (v589);
          v39 = 0;
        }
        v682 = &v588[v711];
        goto LABEL_580;
      case 2:
        v128 = *v65;
        if ((_DWORD)v719)
        {
          if (v39)
          {
            v129 = 0;
            v130 = v65 + 1;
            v131 = v27 - 1;
            v132 = v31 - 1;
            v119 = v715;
            while (1)
            {
              if (!v128)
                goto LABEL_97;
              v133 = ((unsigned __int16)(v39[v129] * v128 + ((v39[v129] * v128) >> 8) + 1) >> 8);
              if (!v133)
                goto LABEL_97;
              if (v133 == 255)
              {
                _H1 = v64[1].i16[0];
                __asm { FCVT            S0, H1 }
                if (_S0 >= 1.0)
                {
                  v31[v129] = *v64;
                  goto LABEL_96;
                }
                if (_S0 > 0.0)
                {
                  v31[v129] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v64), vcvtq_f32_f16(v31[v129]), 1.0 - _S0));
                  _H2 = v27[v129];
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S0));
                  goto LABEL_94;
                }
              }
              else
              {
                v139 = (float)v133 * 0.0039216;
                _H0 = v64[1].i16[0];
                __asm { FCVT            S0, H0 }
                _S0 = v139 * _S0;
                __asm
                {
                  FCVT            H0, S0
                  FCVT            S0, H0
                }
                if (_S0 > 0.0)
                {
                  v31[v129] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), v139))), vcvtq_f32_f16(v31[v129]), 1.0 - _S0));
                  _H1 = v27[v129];
                  __asm { FCVT            S1, H1 }
                  _S0 = _S0 + (float)(_S1 * (float)(1.0 - _S0));
LABEL_94:
                  __asm { FCVT            H1, S0 }
LABEL_96:
                  v27[v129] = _H1;
                }
              }
LABEL_97:
              v128 = v130[v129];
              v64 = (float16x4_t *)((char *)v64 + 10);
              ++v129;
              ++v131;
              ++v132;
              if (v29 == (_DWORD)v129)
              {
                v39 += v129 + v710;
LABEL_557:
                v31 = &v132[v711 + 1];
                v27 = &v131[v713 + 1];
                goto LABEL_524;
              }
            }
          }
          v665 = v65 + 1;
          v131 = v27 - 1;
          v132 = v31 - 1;
          v666 = v29;
          v119 = v715;
          while (1)
          {
            if (v128)
            {
              if (v128 == 255)
              {
                _H1 = v64[1].i16[0];
                __asm { FCVT            S0, H1 }
                if (_S0 >= 1.0)
                {
                  v132[1] = *v64;
                  goto LABEL_554;
                }
                if (_S0 > 0.0)
                {
                  v132[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v64), vcvtq_f32_f16(v132[1]), 1.0 - _S0));
                  _H2 = v131[1];
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S0));
                  goto LABEL_552;
                }
              }
              else
              {
                v672 = (float)v128 * 0.0039216;
                _H0 = v64[1].i16[0];
                __asm { FCVT            S0, H0 }
                _S0 = v672 * _S0;
                __asm
                {
                  FCVT            H0, S0
                  FCVT            S0, H0
                }
                if (_S0 > 0.0)
                {
                  v132[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), v672))), vcvtq_f32_f16(v132[1]), 1.0 - _S0));
                  _H1 = v131[1];
                  __asm { FCVT            S1, H1 }
                  _S0 = _S0 + (float)(_S1 * (float)(1.0 - _S0));
LABEL_552:
                  __asm { FCVT            H1, S0 }
LABEL_554:
                  v131[1] = _H1;
                }
              }
            }
            v679 = *v665++;
            v128 = v679;
            v64 = (float16x4_t *)((char *)v64 + 10);
            ++v131;
            ++v132;
            if (!--v666)
            {
              v39 = 0;
              goto LABEL_557;
            }
          }
        }
        v593 = v65 + 1;
        v594 = v31 - 1;
        v595 = v29;
        if (!v39)
        {
          v119 = v715;
          while (1)
          {
            if (v128)
            {
              if (v128 == 255)
              {
                _H0 = v64[1].i16[0];
                __asm { FCVT            S0, H0 }
                if (_S0 >= 1.0)
                {
                  v685 = *v64;
                  goto LABEL_576;
                }
                if (_S0 > 0.0)
                {
                  v685 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v64), vcvtq_f32_f16(v594[1]), 1.0 - _S0));
LABEL_576:
                  v594[1] = v685;
                }
              }
              else
              {
                v686 = (float)v128 * 0.0039216;
                _H1 = v64[1].i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = v686 * _S1;
                __asm
                {
                  FCVT            H1, S1
                  FCVT            S1, H1
                }
                if (_S1 > 0.0)
                {
                  v685 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), v686))), vcvtq_f32_f16(v594[1]), 1.0 - _S1));
                  goto LABEL_576;
                }
              }
            }
            v691 = *v593++;
            v128 = v691;
            v64 = (float16x4_t *)((char *)v64 + 10);
            ++v594;
            if (!--v595)
            {
              v39 = 0;
              goto LABEL_579;
            }
          }
        }
        v119 = v715;
        do
        {
          if (v128)
          {
            v596 = ((unsigned __int16)(*v39 * v128 + ((*v39 * v128) >> 8) + 1) >> 8);
            if (v596)
            {
              if (v596 == 255)
              {
                _H0 = v64[1].i16[0];
                __asm { FCVT            S0, H0 }
                if (_S0 >= 1.0)
                {
                  v599 = *v64;
                }
                else
                {
                  if (_S0 <= 0.0)
                    goto LABEL_490;
                  v599 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v64), vcvtq_f32_f16(v594[1]), 1.0 - _S0));
                }
              }
              else
              {
                v600 = (float)v596 * 0.0039216;
                _H1 = v64[1].i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = v600 * _S1;
                __asm
                {
                  FCVT            H1, S1
                  FCVT            S1, H1
                }
                if (_S1 <= 0.0)
                  goto LABEL_490;
                v599 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), v600))), vcvtq_f32_f16(v594[1]), 1.0 - _S1));
              }
              v594[1] = v599;
            }
          }
LABEL_490:
          v605 = *v593++;
          v128 = v605;
          v64 = (float16x4_t *)((char *)v64 + 10);
          ++v39;
          ++v594;
          --v595;
        }
        while (v595);
        v39 += v710;
LABEL_579:
        v682 = &v594[v711];
LABEL_580:
        v31 = v682 + 1;
        v27 += v713;
LABEL_524:
        if (--v45)
        {
          v44 = 0;
          ++v718;
          v30 = v36[16] + v119;
          v46 = v36[17] + v717;
          if (v716)
          {
            v717 += v36[17];
            v714 = v45;
            v42 = v706;
            v38 = v716;
            goto LABEL_587;
          }
          continue;
        }
        v38 = v716;
LABEL_582:
        if (v38)
          free(v38);
LABEL_584:
        if (v703)
          free(v703);
        return;
      case 3:
        v146 = v64 + 1;
        v147 = v29;
        v106 = v39;
        do
        {
          v148 = *v65;
          if (*v65)
          {
            if (v39)
              v148 = (*v106 * v148 + ((*v106 * v148) >> 8) + 1) >> 8;
            if ((_BYTE)v148)
            {
              if (v148 == 255)
              {
                _H0 = v146[-1].i16[0];
                _H1 = *v27;
                __asm
                {
                  FCVT            S1, H1
                  FCVT            S0, H0
                }
                _S0 = _S0 * _S1;
                __asm { FCVT            H0, S0 }
                v31->i16[0] = LOWORD(_S0);
                LOWORD(_S0) = v146[-1].i16[1];
                LOWORD(_S1) = *v27;
                __asm
                {
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                _S0 = _S0 * _S1;
                __asm { FCVT            H0, S0 }
                v31->i16[1] = LOWORD(_S0);
                LOWORD(_S0) = v146[-1].i16[2];
                LOWORD(_S1) = *v27;
                __asm
                {
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                _S0 = _S0 * _S1;
                __asm { FCVT            H0, S0 }
                v31->i16[2] = LOWORD(_S0);
                LOWORD(_S0) = v146[-1].i16[3];
                LOWORD(_S1) = *v27;
                __asm
                {
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                _S0 = _S0 * _S1;
                __asm { FCVT            H0, S0 }
                v31->i16[3] = LOWORD(_S0);
                LOWORD(_S0) = v146->i16[0];
                LOWORD(_S1) = *v27;
                __asm
                {
                  FCVT            S0, H0
                  FCVT            S1, H1
                }
                _S0 = _S0 * _S1;
              }
              else
              {
                v166 = (float)v148 * 0.0039216;
                _H1 = *v27;
                __asm { FCVT            S1, H1 }
                v169 = v166 * _S1;
                v170 = 1.0 - v166;
                *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), v170), vcvtq_f32_f16(v146[-1]), v169));
                _H3 = v146->i16[0];
                __asm { FCVT            S3, H3 }
                _S0 = (float)(v170 * _S1) + (float)(_S3 * v169);
              }
              __asm { FCVT            H0, S0 }
              *v27 = _H0;
            }
          }
          ++v65;
          v106 += v39 != 0;
          ++v31;
          v146 = (float16x4_t *)((char *)v146 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          --v147;
        }
        while (v147);
        goto LABEL_521;
      case 4:
        v174 = v64 + 1;
        v175 = v29;
        v106 = v39;
        do
        {
          v176 = *v65;
          if (*v65)
          {
            if (v39)
              v176 = (*v106 * v176 + ((*v106 * v176) >> 8) + 1) >> 8;
            if ((_BYTE)v176)
            {
              if (v176 == 255)
              {
                _H0 = v174[-1].i16[0];
                __asm { FCVT            S0, H0 }
                _H1 = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                v31->i16[0] = LOWORD(_S0);
                LOWORD(_S0) = v174[-1].i16[1];
                __asm { FCVT            S0, H0 }
                LOWORD(_S1) = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                v31->i16[1] = LOWORD(_S0);
                LOWORD(_S0) = v174[-1].i16[2];
                __asm { FCVT            S0, H0 }
                LOWORD(_S1) = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                v31->i16[2] = LOWORD(_S0);
                LOWORD(_S0) = v174[-1].i16[3];
                __asm { FCVT            S0, H0 }
                LOWORD(_S1) = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                v31->i16[3] = LOWORD(_S0);
                LOWORD(_S0) = v174->i16[0];
                __asm { FCVT            S0, H0 }
                LOWORD(_S1) = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
              }
              else
              {
                v194 = (float)v176 * 0.0039216;
                _H1 = *v27;
                __asm { FCVT            S1, H1 }
                v197 = v194 * (float)(1.0 - _S1);
                v198 = 1.0 - v194;
                *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), v198), vcvtq_f32_f16(v174[-1]), v197));
                _H2 = v174->i16[0];
                __asm { FCVT            S2, H2 }
                _S0 = (float)(v198 * _S1) + (float)(_S2 * v197);
              }
              __asm { FCVT            H0, S0 }
              *v27 = _H0;
            }
          }
          ++v65;
          v106 += v39 != 0;
          ++v31;
          v174 = (float16x4_t *)((char *)v174 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          --v175;
        }
        while (v175);
        goto LABEL_521;
      case 5:
        v202 = v64 + 1;
        v203 = v29;
        v106 = v39;
        while (1)
        {
          v204 = *v65;
          if (*v65)
          {
            if (!v39)
              goto LABEL_126;
            v205 = *v106 * v204 + ((*v106 * v204) >> 8) + 1;
            if (BYTE1(v205))
              break;
          }
LABEL_127:
          ++v65;
          v106 += v39 != 0;
          ++v31;
          v202 = (float16x4_t *)((char *)v202 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v203)
            goto LABEL_521;
        }
        v204 = v205 >> 8;
LABEL_126:
        _H0 = *v27;
        __asm { FCVT            S0, H0 }
        v208 = (float)v204 * 0.0039216;
        _H2 = v202->i16[0];
        __asm { FCVT            S2, H2 }
        _S2 = v208 * _S2;
        __asm
        {
          FCVT            H2, S2
          FCVT            S2, H2
        }
        *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), 1.0 - _S2), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v202[-1]), v208))), _S0));
        _S0 = (float)((float)(1.0 - _S2) * _S0) + (float)(_S2 * _S0);
        __asm { FCVT            H0, S0 }
        *v27 = LOWORD(_S0);
        goto LABEL_127;
      case 6:
        v214 = v64 + 1;
        v215 = v29;
        v106 = v39;
        while (1)
        {
          v216 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v217 = *v106 * v216 + ((*v106 * v216) >> 8) + 1;
              if (!BYTE1(v217))
                goto LABEL_139;
              v216 = v217 >> 8;
            }
            _H0 = *v27;
            __asm { FCVT            S0, H0 }
            v220 = 1.0 - _S0;
            if ((float)(1.0 - _S0) >= 1.0)
            {
              v225 = (float)v216 * 0.0039216;
              *v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v214[-1]), v225));
              _H1 = v214->i16[0];
              __asm { FCVT            S1, H1 }
              _S0 = v225 * _S1;
              goto LABEL_138;
            }
            if (v220 > 0.0)
            {
              v221 = (float)((float)v216 * 0.0039216) * v220;
              *v31 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v31), vcvtq_f32_f16(v214[-1]), v221));
              _H2 = v214->i16[0];
              __asm { FCVT            S2, H2 }
              _S0 = _S0 + (float)(_S2 * v221);
LABEL_138:
              __asm { FCVT            H0, S0 }
              *v27 = _H0;
            }
          }
LABEL_139:
          ++v65;
          v106 += v39 != 0;
          ++v31;
          v214 = (float16x4_t *)((char *)v214 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v215)
            goto LABEL_521;
        }
      case 7:
        v229 = v39 != 0;
        if ((_DWORD)v719)
        {
          v230 = v64 + 1;
          v231 = v29;
          v106 = v39;
          do
          {
            v232 = *v65;
            if (*v65)
            {
              if (v39)
                v232 = (*v106 * v232 + ((*v106 * v232) >> 8) + 1) >> 8;
              if ((_BYTE)v232)
              {
                if (v232 == 255)
                {
                  _Q0.n128_u16[0] = v230->i16[0];
                  *v31 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16((int16x4_t)_Q0.n128_u64[0], 0)), vcvtq_f32_f16(*v31)));
                  _H1 = *v27;
                  __asm
                  {
                    FCVT            S0, H0
                    FCVT            S1, H1
                  }
                  _Q0.n128_f32[0] = _S0 * _S1;
                }
                else
                {
                  v236 = (float)v232 * 0.0039216;
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _H2 = v230->i16[0];
                  __asm { FCVT            S2, H2 }
                  v241 = v236 * _S2;
                  v242 = 1.0 - v236;
                  v243 = vcvtq_f32_f16(*v31);
                  *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v243, v242), v243, v241));
                  _Q0.n128_f32[0] = (float)(v242 * _S1) + (float)(_S1 * v241);
                }
                __asm { FCVT            H0, S0 }
                *v27 = _H0;
              }
            }
            ++v65;
            v106 += v229;
            ++v31;
            ++v27;
            v230 = (float16x4_t *)((char *)v230 + 10);
            --v231;
          }
          while (v231);
        }
        else
        {
          v606 = (const __int16 *)&v64[1];
          v607 = v29;
          v106 = v39;
          do
          {
            v608 = *v65;
            if (*v65)
            {
              if (v39)
                v608 = (*v106 * v608 + ((*v106 * v608) >> 8) + 1) >> 8;
              if ((_BYTE)v608)
              {
                if (v608 == 255)
                {
                  v609 = (float16x4_t)vld1_dup_s16(v606);
                  v610 = vmulq_f32(vcvtq_f32_f16(v609), vcvtq_f32_f16(*v31));
                }
                else
                {
                  _H1 = *v606;
                  __asm { FCVT            S1, H1 }
                  v613 = vcvtq_f32_f16(*v31);
                  v610 = vmlaq_n_f32(vmulq_n_f32(v613, 1.0 - (float)((float)v608 * 0.0039216)), v613, (float)((float)v608 * 0.0039216) * _S1);
                }
                *v31 = vcvt_f16_f32(v610);
              }
            }
            ++v65;
            v106 += v229;
            ++v31;
            v606 += 5;
            --v607;
          }
          while (v607);
        }
        goto LABEL_521;
      case 8:
        v245 = v39 != 0;
        if ((_DWORD)v719)
        {
          v246 = v64 + 1;
          v247 = v29;
          v106 = v39;
          do
          {
            v248 = *v65;
            if (*v65)
            {
              if (v39)
                v248 = (*v106 * v248 + ((*v106 * v248) >> 8) + 1) >> 8;
              if ((_BYTE)v248)
              {
                if (v248 == 255)
                {
                  _H0 = v246->i16[0];
                  __asm { FCVT            S0, H0 }
                  v251 = 1.0 - _S0;
                  *v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), v251));
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _S0 = v251 * _S1;
                }
                else
                {
                  v255 = (float)v248 * 0.0039216;
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _H2 = v246->i16[0];
                  __asm { FCVT            S2, H2 }
                  v260 = v255 * (float)(1.0 - _S2);
                  v261 = 1.0 - v255;
                  v262 = vcvtq_f32_f16(*v31);
                  *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v262, v261), v262, v260));
                  _S0 = (float)(v261 * _S1) + (float)(_S1 * v260);
                }
                __asm { FCVT            H0, S0 }
                *v27 = _H0;
              }
            }
            ++v65;
            v106 += v245;
            ++v31;
            ++v27;
            v246 = (float16x4_t *)((char *)v246 + 10);
            --v247;
          }
          while (v247);
        }
        else
        {
          v614 = v64 + 1;
          v615 = v29;
          v106 = v39;
          do
          {
            v616 = *v65;
            if (*v65)
            {
              if (v39)
                v616 = (*v106 * v616 + ((*v106 * v616) >> 8) + 1) >> 8;
              if ((_BYTE)v616)
              {
                if (v616 == 255)
                {
                  _H0 = v31->i16[0];
                  __asm { FCVT            S0, H0 }
                  _H1 = v614->i16[0];
                  __asm { FCVT            S1, H1 }
                  v621 = 1.0 - _S1;
                  _S0 = v621 * _S0;
                  __asm { FCVT            H0, S0 }
                  v31->i16[0] = LOWORD(_S0);
                  LOWORD(_S0) = v31->i16[1];
                  __asm { FCVT            S0, H0 }
                  _S0 = v621 * _S0;
                  __asm { FCVT            H0, S0 }
                  v31->i16[1] = LOWORD(_S0);
                  LOWORD(_S0) = v31->i16[2];
                  __asm { FCVT            S0, H0 }
                  _S0 = v621 * _S0;
                  __asm { FCVT            H0, S0 }
                  v31->i16[2] = LOWORD(_S0);
                  v627 = (_WORD *)v31 + 3;
                  LOWORD(_S0) = v31->i16[3];
                  __asm { FCVT            S0, H0 }
                  _S0 = v621 * _S0;
                }
                else
                {
                  v630 = (float)v616 * 0.0039216;
                  _H1 = v31->i16[0];
                  __asm { FCVT            S1, H1 }
                  _H2 = v614->i16[0];
                  __asm { FCVT            S2, H2 }
                  v635 = v630 * (float)(1.0 - _S2);
                  v636 = 1.0 - v630;
                  _S1 = (float)(v636 * _S1) + (float)(_S1 * v635);
                  __asm { FCVT            H1, S1 }
                  v31->i16[0] = LOWORD(_S1);
                  LOWORD(_S1) = v31->i16[1];
                  __asm { FCVT            S1, H1 }
                  _S1 = (float)(v636 * _S1) + (float)(_S1 * v635);
                  __asm { FCVT            H1, S1 }
                  v31->i16[1] = LOWORD(_S1);
                  LOWORD(_S1) = v31->i16[2];
                  __asm { FCVT            S1, H1 }
                  _S1 = (float)(v636 * _S1) + (float)(_S1 * v635);
                  __asm { FCVT            H1, S1 }
                  v31->i16[2] = LOWORD(_S1);
                  v627 = (_WORD *)v31 + 3;
                  LOWORD(_S1) = v31->i16[3];
                  __asm { FCVT            S1, H1 }
                  _S0 = (float)(v636 * _S1) + (float)(_S1 * v635);
                }
                __asm { FCVT            H0, S0 }
                *v627 = _H0;
              }
            }
            ++v65;
            v106 += v245;
            ++v31;
            v614 = (float16x4_t *)((char *)v614 + 10);
            --v615;
          }
          while (v615);
        }
        goto LABEL_521;
      case 9:
        v264 = v64 + 1;
        v265 = v29;
        v106 = v39;
        while (1)
        {
          v266 = *v65;
          if (*v65)
          {
            if (!v39)
              goto LABEL_170;
            v267 = *v106 * v266 + ((*v106 * v266) >> 8) + 1;
            if (BYTE1(v267))
              break;
          }
LABEL_171:
          ++v65;
          v106 += v39 != 0;
          ++v31;
          v264 = (float16x4_t *)((char *)v264 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v265)
            goto LABEL_521;
        }
        v266 = v267 >> 8;
LABEL_170:
        _H0 = *v27;
        __asm { FCVT            S0, H0 }
        v270 = (float)v266 * 0.0039216;
        _H2 = v264->i16[0];
        __asm { FCVT            S2, H2 }
        _S2 = v270 * _S2;
        __asm
        {
          FCVT            H2, S2
          FCVT            S2, H2
        }
        v275 = (float)(1.0 - v270) + _S2;
        *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), v275), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v264[-1]), v270))), 1.0 - _S0));
        _S0 = (float)(v275 * _S0) + (float)(_S2 * (float)(1.0 - _S0));
        __asm { FCVT            H0, S0 }
        *v27 = LOWORD(_S0);
        goto LABEL_171;
      case 10:
        v277 = v64 + 1;
        v278 = v29;
        v106 = v39;
        while (1)
        {
          v279 = *v65;
          if (*v65)
          {
            if (!v39)
              goto LABEL_178;
            v280 = *v106 * v279 + ((*v106 * v279) >> 8) + 1;
            if (BYTE1(v280))
              break;
          }
LABEL_179:
          ++v65;
          v106 += v39 != 0;
          ++v31;
          v277 = (float16x4_t *)((char *)v277 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v278)
            goto LABEL_521;
        }
        v279 = v280 >> 8;
LABEL_178:
        _H0 = *v27;
        __asm { FCVT            S0, H0 }
        v283 = (float)v279 * 0.0039216;
        _H2 = v277->i16[0];
        __asm { FCVT            S2, H2 }
        _S2 = v283 * _S2;
        __asm
        {
          FCVT            H2, S2
          FCVT            S2, H2
        }
        *v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v31), 1.0 - _S2), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v277[-1]), v283))), 1.0 - _S0));
        _S0 = (float)((float)(1.0 - _S2) * _S0) + (float)(_S2 * (float)(1.0 - _S0));
        __asm { FCVT            H0, S0 }
        *v27 = LOWORD(_S0);
        goto LABEL_179;
      case 11:
        v289 = v39 != 0;
        if ((_DWORD)v719)
        {
          v290 = (__int16 *)v64 + 2;
          v291 = v29;
          v106 = v39;
          while (1)
          {
            v292 = *v65;
            if (*v65)
            {
              if (!v39)
                goto LABEL_187;
              v293 = *v106 * v292 + ((*v106 * v292) >> 8) + 1;
              if (BYTE1(v293))
                break;
            }
LABEL_190:
            ++v65;
            v106 += v289;
            ++v31;
            ++v27;
            v290 += 5;
            if (!--v291)
              goto LABEL_521;
          }
          v292 = v293 >> 8;
LABEL_187:
          _H0 = *(v290 - 2);
          __asm { FCVT            S0, H0 }
          v296 = (float)v292 * 0.0039216;
          _S0 = v296 * _S0;
          __asm { FCVT            H0, S0 }
          _H2 = *(v290 - 1);
          __asm { FCVT            S2, H2 }
          _S2 = v296 * _S2;
          __asm { FCVT            H2, S2 }
          _H3 = *v290;
          __asm { FCVT            S3, H3 }
          _S3 = v296 * _S3;
          __asm { FCVT            H3, S3 }
          _H4 = v290[1];
          __asm { FCVT            S4, H4 }
          _S4 = v296 * _S4;
          __asm { FCVT            H4, S4 }
          _H5 = v290[2];
          __asm { FCVT            S5, H5 }
          _S1 = v296 * _S5;
          __asm { FCVT            H1, S1 }
          LOWORD(_S5) = *v27;
          __asm
          {
            FCVT            S5, H5
            FCVT            S1, H1
          }
          _S6 = _S5 + _S1;
          _H7 = v31->i16[0];
          __asm
          {
            FCVT            S7, H7
            FCVT            S0, H0
          }
          v319 = (float)(_S5 - _S7) + (float)(_S1 - _S0);
          if ((float)(_S5 + _S1) > 1.0)
            _S6 = 1.0;
          _H7 = v31->i16[1];
          __asm
          {
            FCVT            S7, H7
            FCVT            S2, H2
          }
          v323 = (float)(_S5 - _S7) + (float)(_S1 - _S2);
          _S0 = _S6 - v319;
          __asm { FCVT            H0, S0 }
          v31->i16[0] = LOWORD(_S0);
          LOWORD(_S0) = *v27;
          __asm { FCVT            S0, H0 }
          _H5 = v31->i16[2];
          __asm
          {
            FCVT            S5, H5
            FCVT            S3, H3
          }
          v329 = (float)(_S1 - _S3) + (float)(_S0 - _S5);
          _S2 = _S6 - v323;
          __asm { FCVT            H2, S2 }
          v31->i16[1] = LOWORD(_S2);
          LOWORD(_S2) = *v27;
          __asm { FCVT            S2, H2 }
          LOWORD(_S3) = v31->i16[3];
          __asm { FCVT            S3, H3 }
          v333 = _S2 - _S3;
          __asm { FCVT            S3, H4 }
          _S0 = _S6 - v329;
          __asm { FCVT            H0, S0 }
          v31->i16[2] = LOWORD(_S0);
          __asm { FCVT            H0, S6 }
          *v27 = LOWORD(_S0);
          _S0 = _S6 - (float)((float)(_S1 - _S3) + v333);
          __asm { FCVT            H0, S0 }
          v31->i16[3] = LOWORD(_S0);
          goto LABEL_190;
        }
        v644 = v64 + 1;
        v645 = v29;
        v106 = v39;
        while (1)
        {
          v646 = *v65;
          if (*v65)
          {
            if (!v39)
              goto LABEL_519;
            v647 = *v106 * v646 + ((*v106 * v646) >> 8) + 1;
            if (BYTE1(v647))
              break;
          }
LABEL_520:
          ++v65;
          v106 += v289;
          ++v31;
          v644 = (float16x4_t *)((char *)v644 + 10);
          if (!--v645)
          {
LABEL_521:
            v39 = &v106[v710];
            goto LABEL_522;
          }
        }
        v646 = v647 >> 8;
LABEL_519:
        v648 = (float)v646 * 0.0039216;
        _Q1.i16[0] = v644->i16[0];
        __asm { FCVT            S1, H1 }
        _Q1.f32[0] = v648 * _Q1.f32[0];
        __asm
        {
          FCVT            H1, S1
          FCVT            S1, H1
          FMOV            V3.4S, #1.0
        }
        _Q1 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 0);
        *v31 = vcvt_f16_f32(vsubq_f32(_Q3, vaddq_f32(vsubq_f32(_Q1, vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v644[-1]), v648)))), vsubq_f32(_Q3, vcvtq_f32_f16(*v31)))));
        goto LABEL_520;
      case 12:
        v337 = v39 != 0;
        if ((_DWORD)v719)
        {
          v338 = v64 + 1;
          v339 = v29;
          v106 = v39;
          while (1)
          {
            v340 = *v65;
            if (*v65)
            {
              if (!v39)
                goto LABEL_198;
              v341 = *v106 * v340 + ((*v106 * v340) >> 8) + 1;
              if (BYTE1(v341))
                break;
            }
LABEL_201:
            ++v65;
            v106 += v337;
            ++v31;
            ++v27;
            v338 = (float16x4_t *)((char *)v338 + 10);
            if (!--v339)
              goto LABEL_521;
          }
          v340 = v341 >> 8;
LABEL_198:
          v342 = (float)v340 * 0.0039216;
          _H1 = v338->i16[0];
          __asm { FCVT            S1, H1 }
          _S1 = v342 * _S1;
          __asm { FCVT            H1, S1 }
          _H2 = *v27;
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S2 + _S1;
          if (_S1 > 1.0)
            _S1 = 1.0;
          __asm { FCVT            H1, S1 }
          v351 = vmulq_n_f32(vcvtq_f32_f16(v338[-1]), v342);
          v352.i32[0] = v31->i32[0];
          *v27 = _H1;
          v352.i32[1] = v31->i32[1];
          *v31 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(v352), vcvtq_f32_f16(vcvt_f16_f32(v351))));
          goto LABEL_201;
        }
        v650 = v29;
        v651 = v39;
        while (1)
        {
          v652 = *v65;
          if (*v65)
          {
            if (!v39)
              goto LABEL_532;
            v653 = *v651 * v652 + ((*v651 * v652) >> 8) + 1;
            if (BYTE1(v653))
              break;
          }
LABEL_533:
          ++v65;
          v64 = (float16x4_t *)((char *)v64 + 10);
          v651 += v337;
          ++v31;
          if (!--v650)
          {
            v39 = &v651[v710];
LABEL_522:
            v31 += v711;
            v27 += v713;
LABEL_523:
            v119 = v715;
            goto LABEL_524;
          }
        }
        v652 = v653 >> 8;
LABEL_532:
        *v31 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(*v31), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), (float)v652 * 0.0039216)))));
        goto LABEL_533;
      case 13:
        v714 = v45;
        v353 = v29;
        v354 = v64 + 1;
        v355 = v353;
        v356 = v39;
        while (1)
        {
          v357 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v358 = *v356 * v357 + ((*v356 * v357) >> 8) + 1;
              if (!BYTE1(v358))
                goto LABEL_218;
              v357 = v358 >> 8;
            }
            v359 = (float)v357 * *((float *)v103 + 159);
            _H0 = v354->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v359 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v362 = (__n128)vcvtq_f32_f16(v354[-1]);
              v363 = (__n128)vmulq_n_f32((float32x4_t)v362, v359);
              v364 = (int32x2_t)vcvt_f16_f32((float32x4_t)v363);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v364.i16[1];
                if (_S4 > 0.0)
                {
                  v367 = vdup_lane_s32(v364, 1).u32[0];
                  goto LABEL_213;
                }
                LOWORD(v368) = v364.i16[2];
                LOWORD(v369) = v364.i16[3];
              }
              else
              {
                LOWORD(v62) = v364.i16[1];
                v367 = vdup_lane_s32(v364, 1).u32[0];
                _S4 = 1.0;
LABEL_213:
                _Q0.n128_u16[0] = v31->i16[0];
                v363.n128_u16[0] = v31->u16[1];
                v362.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAmultiplyPDA(_Q0, v363, v362, v59, _S4, *(double *)&v364, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v364.i16[0], SLOWORD(v62), v367,
                        SHIWORD(v367),
                        *(float *)&_D7);
                v368 = HIDWORD(v48);
                v369 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_218;
                }
                v364.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v364.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v368;
              v31->i16[3] = v369;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_218:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v354 = (float16x4_t *)((char *)v354 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v355)
            goto LABEL_457;
        }
      case 14:
        v714 = v45;
        v370 = v29;
        v371 = v64 + 1;
        v372 = v370;
        v356 = v39;
        while (1)
        {
          v373 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v374 = *v356 * v373 + ((*v356 * v373) >> 8) + 1;
              if (!BYTE1(v374))
                goto LABEL_235;
              v373 = v374 >> 8;
            }
            v375 = (float)v373 * *((float *)v103 + 159);
            _H0 = v371->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v375 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v378 = (__n128)vcvtq_f32_f16(v371[-1]);
              v379 = (__n128)vmulq_n_f32((float32x4_t)v378, v375);
              v380 = (int32x2_t)vcvt_f16_f32((float32x4_t)v379);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v380.i16[1];
                if (_S4 > 0.0)
                {
                  v383 = vdup_lane_s32(v380, 1).u32[0];
                  goto LABEL_230;
                }
                LOWORD(v384) = v380.i16[2];
                LOWORD(v385) = v380.i16[3];
              }
              else
              {
                LOWORD(v62) = v380.i16[1];
                v383 = vdup_lane_s32(v380, 1).u32[0];
                _S4 = 1.0;
LABEL_230:
                _Q0.n128_u16[0] = v31->i16[0];
                v379.n128_u16[0] = v31->u16[1];
                v378.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAscreenPDA(_Q0, v379, v378, v59, _S4, *(double *)&v380, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v380.i16[0], SLOWORD(v62), v383,
                        SHIWORD(v383),
                        *(float *)&_D7);
                v384 = HIDWORD(v48);
                v385 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_235;
                }
                v380.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v380.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v384;
              v31->i16[3] = v385;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_235:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v371 = (float16x4_t *)((char *)v371 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v372)
            goto LABEL_457;
        }
      case 15:
        v714 = v45;
        v386 = v29;
        v387 = v64 + 1;
        v388 = v386;
        v356 = v39;
        while (1)
        {
          v389 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v390 = *v356 * v389 + ((*v356 * v389) >> 8) + 1;
              if (!BYTE1(v390))
                goto LABEL_252;
              v389 = v390 >> 8;
            }
            v391 = (float)v389 * *((float *)v103 + 159);
            _H0 = v387->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v391 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v394 = (__n128)vcvtq_f32_f16(v387[-1]);
              v395 = (__n128)vmulq_n_f32((float32x4_t)v394, v391);
              v396 = (int32x2_t)vcvt_f16_f32((float32x4_t)v395);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v396.i16[1];
                if (_S4 > 0.0)
                {
                  v399 = vdup_lane_s32(v396, 1).u32[0];
                  goto LABEL_247;
                }
                LOWORD(v400) = v396.i16[2];
                LOWORD(v401) = v396.i16[3];
              }
              else
              {
                LOWORD(v62) = v396.i16[1];
                v399 = vdup_lane_s32(v396, 1).u32[0];
                _S4 = 1.0;
LABEL_247:
                _Q0.n128_u16[0] = v31->i16[0];
                v395.n128_u16[0] = v31->u16[1];
                v394.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAoverlayPDA(_Q0, v395, v394, v59, _S4, *(double *)&v396, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v396.i16[0], SLOWORD(v62), v399,
                        SHIWORD(v399),
                        *(float *)&_D7);
                v400 = HIDWORD(v48);
                v401 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_252;
                }
                v396.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v396.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v400;
              v31->i16[3] = v401;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_252:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v387 = (float16x4_t *)((char *)v387 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v388)
            goto LABEL_457;
        }
      case 16:
        v714 = v45;
        v402 = v29;
        v403 = v64 + 1;
        v404 = v402;
        v356 = v39;
        while (1)
        {
          v405 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v406 = *v356 * v405 + ((*v356 * v405) >> 8) + 1;
              if (!BYTE1(v406))
                goto LABEL_269;
              v405 = v406 >> 8;
            }
            v407 = (float)v405 * *((float *)v103 + 159);
            _H0 = v403->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v407 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v410 = (__n128)vcvtq_f32_f16(v403[-1]);
              v411 = (__n128)vmulq_n_f32((float32x4_t)v410, v407);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v411);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = _Q5.i16[1];
                if (_Q4.f32[0] > 0.0)
                {
                  v413 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
                  goto LABEL_264;
                }
                LOWORD(v414) = _Q5.i16[2];
                LOWORD(v415) = _Q5.i16[3];
              }
              else
              {
                LOWORD(v62) = _Q5.i16[1];
                v413 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
                _Q4.i32[0] = 1.0;
LABEL_264:
                _Q0.n128_u16[0] = v31->i16[0];
                v411.n128_u16[0] = v31->u16[1];
                v410.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v699.i32[1] = v413;
                v699.i16[1] = LOWORD(v62);
                v699.i16[0] = _Q5.i16[0];
                v48 = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], v411, v410, v59, _Q4, _Q5, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v699, *(float *)&_D7);
                v414 = HIDWORD(v48);
                v415 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_269;
                }
                _Q5.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = _Q5.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v414;
              v31->i16[3] = v415;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_269:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v403 = (float16x4_t *)((char *)v403 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v404)
            goto LABEL_457;
        }
      case 17:
        v714 = v45;
        v416 = v29;
        v417 = v64 + 1;
        v418 = v416;
        v356 = v39;
        while (1)
        {
          v419 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v420 = *v356 * v419 + ((*v356 * v419) >> 8) + 1;
              if (!BYTE1(v420))
                goto LABEL_286;
              v419 = v420 >> 8;
            }
            v421 = (float)v419 * *((float *)v103 + 159);
            _H0 = v417->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v421 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v424 = (__n128)vcvtq_f32_f16(v417[-1]);
              v425 = (__n128)vmulq_n_f32((float32x4_t)v424, v421);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v425);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = _Q5.i16[1];
                if (_Q4.f32[0] > 0.0)
                {
                  v427 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
                  goto LABEL_281;
                }
                LOWORD(v428) = _Q5.i16[2];
                LOWORD(v429) = _Q5.i16[3];
              }
              else
              {
                LOWORD(v62) = _Q5.i16[1];
                v427 = vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1).u32[0];
                _Q4.i32[0] = 1.0;
LABEL_281:
                _Q0.n128_u16[0] = v31->i16[0];
                v425.n128_u16[0] = v31->u16[1];
                v424.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v700.i32[1] = v427;
                v700.i16[1] = LOWORD(v62);
                v700.i16[0] = _Q5.i16[0];
                v48 = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], v425, v424, v59, _Q4, _Q5, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v700, *(float *)&_D7);
                v428 = HIDWORD(v48);
                v429 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_286;
                }
                _Q5.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = _Q5.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v428;
              v31->i16[3] = v429;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_286:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v417 = (float16x4_t *)((char *)v417 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v418)
            goto LABEL_457;
        }
      case 18:
        v714 = v45;
        v430 = v29;
        v431 = v64 + 1;
        v432 = v430;
        v356 = v39;
        while (1)
        {
          v433 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v434 = *v356 * v433 + ((*v356 * v433) >> 8) + 1;
              if (!BYTE1(v434))
                goto LABEL_303;
              v433 = v434 >> 8;
            }
            v435 = (float)v433 * *((float *)v103 + 159);
            _H0 = v431->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v435 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v438 = (__n128)vcvtq_f32_f16(v431[-1]);
              v439 = (__n128)vmulq_n_f32((float32x4_t)v438, v435);
              v440 = (int32x2_t)vcvt_f16_f32((float32x4_t)v439);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v440.i16[1];
                if (_S4 > 0.0)
                {
                  v443 = vdup_lane_s32(v440, 1).u32[0];
                  goto LABEL_298;
                }
                LOWORD(v444) = v440.i16[2];
                LOWORD(v445) = v440.i16[3];
              }
              else
              {
                LOWORD(v62) = v440.i16[1];
                v443 = vdup_lane_s32(v440, 1).u32[0];
                _S4 = 1.0;
LABEL_298:
                _Q0.n128_u16[0] = v31->i16[0];
                v439.n128_u16[0] = v31->u16[1];
                v438.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAcolordodgePDA(_Q0, v439, v438, v59, _S4, *(double *)&v440, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v440.i16[0], SLOWORD(v62), v443,
                        SHIWORD(v443),
                        *(float *)&_D7);
                v444 = HIDWORD(v48);
                v445 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_303;
                }
                v440.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v440.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v444;
              v31->i16[3] = v445;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_303:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v431 = (float16x4_t *)((char *)v431 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v432)
            goto LABEL_457;
        }
      case 19:
        v714 = v45;
        v446 = v29;
        v447 = v64 + 1;
        v448 = v446;
        v356 = v39;
        while (1)
        {
          v449 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v450 = *v356 * v449 + ((*v356 * v449) >> 8) + 1;
              if (!BYTE1(v450))
                goto LABEL_320;
              v449 = v450 >> 8;
            }
            v451 = (float)v449 * *((float *)v103 + 159);
            _H0 = v447->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v451 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v454 = (__n128)vcvtq_f32_f16(v447[-1]);
              v455 = (__n128)vmulq_n_f32((float32x4_t)v454, v451);
              v456 = (int32x2_t)vcvt_f16_f32((float32x4_t)v455);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v456.i16[1];
                if (_S4 > 0.0)
                {
                  v459 = vdup_lane_s32(v456, 1).u32[0];
                  goto LABEL_315;
                }
                LOWORD(v460) = v456.i16[2];
                LOWORD(v461) = v456.i16[3];
              }
              else
              {
                LOWORD(v62) = v456.i16[1];
                v459 = vdup_lane_s32(v456, 1).u32[0];
                _S4 = 1.0;
LABEL_315:
                _Q0.n128_u16[0] = v31->i16[0];
                v455.n128_u16[0] = v31->u16[1];
                v454.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAcolorburnPDA(_Q0, v455, v454, v59, _S4, *(double *)&v456, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v456.i16[0], SLOWORD(v62), v459,
                        SHIWORD(v459),
                        *(float *)&_D7);
                v460 = HIDWORD(v48);
                v461 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_320;
                }
                v456.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v456.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v460;
              v31->i16[3] = v461;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_320:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v447 = (float16x4_t *)((char *)v447 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v448)
            goto LABEL_457;
        }
      case 20:
        v714 = v45;
        v462 = v29;
        v463 = v64 + 1;
        v464 = v462;
        v356 = v39;
        while (1)
        {
          v465 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v466 = *v356 * v465 + ((*v356 * v465) >> 8) + 1;
              if (!BYTE1(v466))
                goto LABEL_337;
              v465 = v466 >> 8;
            }
            v467 = (float)v465 * *((float *)v103 + 159);
            _H0 = v463->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v467 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v470 = (__n128)vcvtq_f32_f16(v463[-1]);
              v471 = (__n128)vmulq_n_f32((float32x4_t)v470, v467);
              v472 = (int32x2_t)vcvt_f16_f32((float32x4_t)v471);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v472.i16[1];
                if (_Q4.f32[0] > 0.0)
                {
                  v474 = vdup_lane_s32(v472, 1).u32[0];
                  goto LABEL_332;
                }
                LOWORD(v475) = v472.i16[2];
                LOWORD(v476) = v472.i16[3];
              }
              else
              {
                LOWORD(v62) = v472.i16[1];
                v474 = vdup_lane_s32(v472, 1).u32[0];
                _Q4.i32[0] = 1.0;
LABEL_332:
                _Q0.n128_u16[0] = v31->i16[0];
                v471.n128_u16[0] = v31->u16[1];
                v470.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                HIWORD(v701) = LOWORD(v62);
                LOWORD(v701) = v472.i16[0];
                v48 = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], v471, v470, v59, *(double *)_Q4.i64, v472, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v701, v474, SHIWORD(v474),
                        *(float *)&_D7);
                v475 = HIDWORD(v48);
                v476 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_337;
                }
                v472.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v472.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v475;
              v31->i16[3] = v476;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_337:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v463 = (float16x4_t *)((char *)v463 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v464)
            goto LABEL_457;
        }
      case 21:
        v714 = v45;
        v477 = v29;
        v478 = v64 + 1;
        v479 = v477;
        v356 = v39;
        while (1)
        {
          v480 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v481 = *v356 * v480 + ((*v356 * v480) >> 8) + 1;
              if (!BYTE1(v481))
                goto LABEL_354;
              v480 = v481 >> 8;
            }
            v482 = (float)v480 * *((float *)v103 + 159);
            _H0 = v478->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v482 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v485 = (__n128)vcvtq_f32_f16(v478[-1]);
              v486 = (__n128)vmulq_n_f32((float32x4_t)v485, v482);
              v487 = (int32x2_t)vcvt_f16_f32((float32x4_t)v486);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v487.i16[1];
                if (_S4 > 0.0)
                {
                  v490 = vdup_lane_s32(v487, 1).u32[0];
                  goto LABEL_349;
                }
                LOWORD(v491) = v487.i16[2];
                LOWORD(v492) = v487.i16[3];
              }
              else
              {
                LOWORD(v62) = v487.i16[1];
                v490 = vdup_lane_s32(v487, 1).u32[0];
                _S4 = 1.0;
LABEL_349:
                _Q0.n128_u16[0] = v31->i16[0];
                v486.n128_u16[0] = v31->u16[1];
                v485.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAhardlightPDA(_Q0, v486, v485, v59, _S4, *(double *)&v487, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v487.i16[0], SLOWORD(v62), v490,
                        SHIWORD(v490),
                        *(float *)&_D7);
                v491 = HIDWORD(v48);
                v492 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_354;
                }
                v487.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v487.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v491;
              v31->i16[3] = v492;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_354:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v478 = (float16x4_t *)((char *)v478 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v479)
            goto LABEL_457;
        }
      case 22:
        v714 = v45;
        v493 = v29;
        v494 = v64 + 1;
        v495 = v493;
        v356 = v39;
        while (1)
        {
          v496 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v497 = *v356 * v496 + ((*v356 * v496) >> 8) + 1;
              if (!BYTE1(v497))
                goto LABEL_371;
              v496 = v497 >> 8;
            }
            v498 = (float)v496 * *((float *)v103 + 159);
            _H0 = v494->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v498 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v501 = (__n128)vcvtq_f32_f16(v494[-1]);
              v502 = (__n128)vmulq_n_f32((float32x4_t)v501, v498);
              v503 = (int32x2_t)vcvt_f16_f32((float32x4_t)v502);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v503.i16[1];
                if (_Q4.f32[0] > 0.0)
                {
                  v505 = vdup_lane_s32(v503, 1).u32[0];
                  goto LABEL_366;
                }
                LOWORD(v506) = v503.i16[2];
                LOWORD(v507) = v503.i16[3];
              }
              else
              {
                LOWORD(v62) = v503.i16[1];
                v505 = vdup_lane_s32(v503, 1).u32[0];
                _Q4.i32[0] = 1.0;
LABEL_366:
                _Q0.n128_u16[0] = v31->i16[0];
                v502.n128_u16[0] = v31->u16[1];
                v501.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAdifferencePDA(_Q0, v502, v501, (float16x4_t)v59.n128_u64[0], *(double *)_Q4.i64, v503, *(float16x4_t *)&v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v503.i16[0], SLOWORD(v62), v505,
                        SHIWORD(v505),
                        *(float *)&_D7);
                v506 = HIDWORD(v48);
                v507 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_371;
                }
                v503.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v503.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v506;
              v31->i16[3] = v507;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_371:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v494 = (float16x4_t *)((char *)v494 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v495)
            goto LABEL_457;
        }
      case 23:
        v714 = v45;
        v508 = v29;
        v509 = v64 + 1;
        v510 = v508;
        v356 = v39;
        while (1)
        {
          v511 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v512 = *v356 * v511 + ((*v356 * v511) >> 8) + 1;
              if (!BYTE1(v512))
                goto LABEL_388;
              v511 = v512 >> 8;
            }
            v513 = (float)v511 * *((float *)v103 + 159);
            _H0 = v509->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v513 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v516 = (__n128)vcvtq_f32_f16(v509[-1]);
              v517 = (__n128)vmulq_n_f32((float32x4_t)v516, v513);
              v518 = (int32x2_t)vcvt_f16_f32((float32x4_t)v517);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v518.i16[1];
                if (_Q4.f32[0] > 0.0)
                {
                  v520 = vdup_lane_s32(v518, 1).u32[0];
                  goto LABEL_383;
                }
                LOWORD(v521) = v518.i16[2];
                LOWORD(v522) = v518.i16[3];
              }
              else
              {
                LOWORD(v62) = v518.i16[1];
                v520 = vdup_lane_s32(v518, 1).u32[0];
                _Q4.i32[0] = 1.0;
LABEL_383:
                _Q0.n128_u16[0] = v31->i16[0];
                v517.n128_u16[0] = v31->u16[1];
                v516.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAexclusionPDA(_Q0, v517, v516, (float16x4_t)v59.n128_u64[0], *(double *)_Q4.i64, (float16x4_t)v518, v62, *(int32x2_t *)&_D7, v48, v49, v50, v51, v52, v53, v54, v55, v518.i16[0], SLOWORD(v62), v520,
                        SHIWORD(v520),
                        *(float *)&_D7);
                v521 = HIDWORD(v48);
                v522 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_388;
                }
                v518.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v518.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v521;
              v31->i16[3] = v522;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_388:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v509 = (float16x4_t *)((char *)v509 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v510)
            goto LABEL_457;
        }
      case 24:
        v714 = v45;
        v523 = v29;
        v524 = v64 + 1;
        v525 = v523;
        v356 = v39;
        while (1)
        {
          v526 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v527 = *v356 * v526 + ((*v356 * v526) >> 8) + 1;
              if (!BYTE1(v527))
                goto LABEL_405;
              v526 = v527 >> 8;
            }
            v528 = (float)v526 * *((float *)v103 + 159);
            _H0 = v524->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v528 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v531 = (__n128)vcvtq_f32_f16(v524[-1]);
              v532 = (__n128)vmulq_n_f32((float32x4_t)v531, v528);
              v533 = (int32x2_t)vcvt_f16_f32((float32x4_t)v532);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v533.i16[1];
                if (_S4 > 0.0)
                {
                  v536 = vdup_lane_s32(v533, 1).u32[0];
                  goto LABEL_400;
                }
                LOWORD(v537) = v533.i16[2];
                LOWORD(v538) = v533.i16[3];
              }
              else
              {
                LOWORD(v62) = v533.i16[1];
                v536 = vdup_lane_s32(v533, 1).u32[0];
                _S4 = 1.0;
LABEL_400:
                _Q0.n128_u16[0] = v31->i16[0];
                v532.n128_u16[0] = v31->u16[1];
                v531.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAhuePDA(_Q0, v532, v531, v59, _S4, *(double *)&v533, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v533.i16[0], SLOWORD(v62), v536,
                        SHIWORD(v536),
                        *(float *)&_D7);
                v537 = HIDWORD(v48);
                v538 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_405;
                }
                v533.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v533.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v537;
              v31->i16[3] = v538;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_405:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v524 = (float16x4_t *)((char *)v524 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v525)
            goto LABEL_457;
        }
      case 25:
        v714 = v45;
        v539 = v29;
        v540 = v64 + 1;
        v541 = v539;
        v356 = v39;
        while (1)
        {
          v542 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v543 = *v356 * v542 + ((*v356 * v542) >> 8) + 1;
              if (!BYTE1(v543))
                goto LABEL_422;
              v542 = v543 >> 8;
            }
            v544 = (float)v542 * *((float *)v103 + 159);
            _H0 = v540->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v544 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCVT            S7, H0
            }
            if (*(float *)&_D7 > 0.0)
            {
              v547 = (__n128)vcvtq_f32_f16(v540[-1]);
              v548 = (__n128)vmulq_n_f32((float32x4_t)v547, v544);
              v549 = (int32x2_t)vcvt_f16_f32((float32x4_t)v548);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S4, H1 }
                LOWORD(v62) = v549.i16[1];
                if (_S4 > 0.0)
                {
                  v552 = vdup_lane_s32(v549, 1).u32[0];
                  goto LABEL_417;
                }
                LOWORD(v553) = v549.i16[2];
                LOWORD(v554) = v549.i16[3];
              }
              else
              {
                LOWORD(v62) = v549.i16[1];
                v552 = vdup_lane_s32(v549, 1).u32[0];
                _S4 = 1.0;
LABEL_417:
                _Q0.n128_u16[0] = v31->i16[0];
                v548.n128_u16[0] = v31->u16[1];
                v547.n128_u16[0] = v31->u16[2];
                v59.n128_u16[0] = v31->u16[3];
                v48 = PDAsaturationPDA(_Q0, v548, v547, v59, _S4, *(double *)&v549, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v549.i16[0], SLOWORD(v62), v552,
                        SHIWORD(v552),
                        *(float *)&_D7);
                v553 = HIDWORD(v48);
                v554 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_422;
                }
                v549.i16[0] = v48;
                LODWORD(v62) = v48 >> 16;
                _Q0.n128_u16[0] = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v549.i16[0];
              v31->i16[1] = LOWORD(v62);
              v31->i16[2] = v553;
              v31->i16[3] = v554;
              *v27 = _Q0.n128_u16[0];
            }
          }
LABEL_422:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v540 = (float16x4_t *)((char *)v540 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v541)
            goto LABEL_457;
        }
      case 26:
        v714 = v45;
        v555 = v64 + 1;
        v356 = v39;
        while (1)
        {
          v556 = *v65;
          if (*v65)
          {
            if (v39)
            {
              v557 = *v356 * v556 + ((*v356 * v556) >> 8) + 1;
              if (!BYTE1(v557))
                goto LABEL_439;
              v556 = v557 >> 8;
            }
            v558 = (float)v556 * *((float *)v103 + 159);
            _H1 = v555->i16[0];
            __asm { FCVT            S1, H1 }
            _S1 = v558 * _S1;
            __asm
            {
              FCVT            H2, S1
              FCVT            S4, H2
            }
            if (_S4 > 0.0)
            {
              v564 = (__n128)vcvtq_f32_f16(v555[-1]);
              v565 = (__n128)vmulq_n_f32((float32x4_t)v564, v558);
              v565.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v565);
              if ((_DWORD)v719)
              {
                _H1 = *v27;
                __asm { FCVT            S5, H1 }
                v564.n128_u16[0] = v565.n128_u16[1];
                if (_Q5.f32[0] > 0.0)
                {
                  v58.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v565.n128_u64[0], 1);
                  goto LABEL_434;
                }
                LOWORD(v567) = v565.n128_u16[2];
                LOWORD(v568) = v565.n128_u16[3];
              }
              else
              {
                v564.n128_u16[0] = v565.n128_u16[1];
                v58.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v565.n128_u64[0], 1);
                _Q5.i32[0] = 1.0;
LABEL_434:
                v59.n128_u16[0] = v58.n128_u16[1];
                v48 = PDAluminosityPDA(v565, v564, v58, v59, _S4, *(double *)_Q5.i64, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v31->i32[0], HIWORD(v31->i32[0]), v31->i32[1],
                        HIWORD(v31->i32[1]),
                        _Q5.f32[0]);
                v567 = HIDWORD(v48);
                v568 = HIWORD(v48);
                if (!(_DWORD)v719)
                {
                  *v31 = (float16x4_t)v48;
                  v103 = &xmmword_185005000;
                  goto LABEL_439;
                }
                v564.n128_u16[0] = WORD1(v48);
                v565.n128_u16[0] = v48;
                _H2 = v49;
                v103 = &xmmword_185005000;
              }
              v31->i16[0] = v565.n128_u16[0];
              v31->i16[1] = v564.n128_u16[0];
              v31->i16[2] = v567;
              v31->i16[3] = v568;
              *v27 = _H2;
            }
          }
LABEL_439:
          ++v65;
          v356 += v39 != 0;
          ++v31;
          v555 = (float16x4_t *)((char *)v555 + 10);
          v27 = (__int16 *)((char *)v27 + v43);
          if (!--v29)
            goto LABEL_457;
        }
      case 27:
        v714 = v45;
        v569 = v29;
        v570 = v64 + 1;
        v571 = v569;
        v356 = v39;
        break;
      default:
        goto LABEL_523;
    }
    break;
  }
  while (1)
  {
    v572 = *v65;
    if (*v65)
    {
      if (v39)
      {
        v573 = *v356 * v572 + ((*v356 * v572) >> 8) + 1;
        if (!BYTE1(v573))
          goto LABEL_456;
        v572 = v573 >> 8;
      }
      v574 = (float)v572 * *((float *)v103 + 159);
      _H0 = v570->i16[0];
      __asm { FCVT            S0, H0 }
      _Q0.n128_f32[0] = v574 * _S0;
      __asm
      {
        FCVT            H0, S0
        FCVT            S7, H0
      }
      if (*(float *)&_D7 > 0.0)
      {
        v577 = (__n128)vcvtq_f32_f16(v570[-1]);
        v578 = (__n128)vmulq_n_f32((float32x4_t)v577, v574);
        v579 = (int32x2_t)vcvt_f16_f32((float32x4_t)v578);
        if ((_DWORD)v719)
        {
          _H1 = *v27;
          __asm { FCVT            S4, H1 }
          LOWORD(v62) = v579.i16[1];
          if (_S4 > 0.0)
          {
            v582 = vdup_lane_s32(v579, 1).u32[0];
            goto LABEL_451;
          }
          LOWORD(v583) = v579.i16[2];
          LOWORD(v584) = v579.i16[3];
        }
        else
        {
          LOWORD(v62) = v579.i16[1];
          v582 = vdup_lane_s32(v579, 1).u32[0];
          _S4 = 1.0;
LABEL_451:
          _Q0.n128_u16[0] = v31->i16[0];
          v578.n128_u16[0] = v31->u16[1];
          v577.n128_u16[0] = v31->u16[2];
          v59.n128_u16[0] = v31->u16[3];
          v48 = PDAluminosityPDA(_Q0, v578, v577, v59, _S4, *(double *)&v579, v62, _D7, v48, v49, v50, v51, v52, v53, v54, v55, v579.i16[0], SLOWORD(v62), v582,
                  SHIWORD(v582),
                  *(float *)&_D7);
          v583 = HIDWORD(v48);
          v584 = HIWORD(v48);
          if (!(_DWORD)v719)
          {
            *v31 = (float16x4_t)v48;
            v103 = &xmmword_185005000;
            goto LABEL_456;
          }
          v579.i16[0] = v48;
          LODWORD(v62) = v48 >> 16;
          _Q0.n128_u16[0] = v49;
          v103 = &xmmword_185005000;
        }
        v31->i16[0] = v579.i16[0];
        v31->i16[1] = LOWORD(v62);
        v31->i16[2] = v583;
        v31->i16[3] = v584;
        *v27 = _Q0.n128_u16[0];
      }
    }
LABEL_456:
    ++v65;
    v356 += v39 != 0;
    ++v31;
    v570 = (float16x4_t *)((char *)v570 + 10);
    v27 = (__int16 *)((char *)v27 + v43);
    if (!--v571)
    {
LABEL_457:
      v39 = &v356[v710];
      v31 += v711;
      v27 += v713;
      v35 = v709;
      v29 = v707;
      v36 = v708;
      v45 = v714;
      goto LABEL_523;
    }
  }
}

uint64_t CMYKf16_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  _BOOL8 v8;
  int v9;
  __n128 v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  _BYTE v18[36];
  char v19;
  _QWORD v20[483];

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E0C80C00];
  v7 = *(int **)v2;
  v8 = !*((_QWORD *)v3 + 12) && !*(_QWORD *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v9 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) != 0x4000000)
  {
    if (v13)
      goto LABEL_22;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(v5 + 16))
  {
    v12 = CMYKf16_shade_radial_CMYK;
  }
  else if (*(_QWORD *)(v5 + 24))
  {
    v12 = CMYKf16_shade_conic_CMYK;
  }
  else if (v16 < 2)
  {
    v12 = CMYKf16_shade_axial_CMYK;
  }
  else
  {
    v12 = CMYKf16_shade_custom_CMYK;
  }
  v13 = v12;
LABEL_22:
  v14 = *v7;
  v15 = v14;
  CMYKf16_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17))
    free(v17);
  return 1;
}

void CMYKf16_shade_radial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int64x2_t v4;
  int64x2_t v5;
  float *v9;
  float v10;
  float v11;
  float *v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  float32x4_t *v30;
  float *v31;
  uint64_t v32;
  uint64_t v33;
  float *v34;
  float v35;
  float v36;
  int v37;
  int v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float16x4_t *i;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  BOOL v51;
  float v52;
  uint64_t v54;
  float v55;
  uint64_t v56;
  float32x4_t v58;
  char v63;
  float v64;
  float v65;
  float v66;
  uint64_t v67;
  int32x2_t *v68;
  int v69;
  float v71;
  float v72;
  float v73;
  float v75;
  float v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  float16x4_t v82;
  uint64_t v83;
  float32x4_t v84;
  float32x4_t v86;
  float32x4_t v88;
  char v90;
  uint64_t v91;
  char v93;
  uint64_t v94;
  float32x4_t v96;
  float16x4_t v97;
  int v99;

  v9 = *(float **)(a1 + 400);
  v10 = *(float *)(a1 + 280);
  v11 = *(float *)(a1 + 284);
  v12 = *(float **)(a1 + 272);
  v13 = v12[1];
  v14 = v13 * (float)a2;
  v15 = v13 * (float)a3;
  v16 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v15) + (float)(v10 * v14));
  v17 = *(float *)(a1 + 300) + (float)((float)(v15 * *(float *)(a1 + 292)) + (float)(v11 * v14));
  v18 = *(float *)(a1 + 336);
  v19 = *(float *)(a1 + 344);
  v20 = *(float *)(a1 + 304);
  v21 = *(float *)(a1 + 308);
  v22 = *(unsigned int *)(a1 + 324);
  v23 = v9[2];
  v24 = v9[4];
  v25 = v9[5];
  v26 = v9[7];
  v29 = a1 + 144;
  v27 = *(char **)(a1 + 144);
  v28 = *(_QWORD *)(v29 + 8);
  v30 = *(float32x4_t **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v31 = *(float **)(a1 + 392);
  else
    v31 = v12;
  v32 = *(_QWORD *)(a1 + 32);
  v33 = *(_QWORD *)(a1 + 40);
  if (v33)
    v34 = *(float **)(a1 + 40);
  else
    v34 = v12;
  if (v23 != 0.0 || v26 != 0.0 || v11 != 0.0)
  {
    v38 = *(_DWORD *)(a1 + 320);
    v39 = v9[3];
    v40 = v9[8];
    v41 = -v9[6];
    v42 = v21 - v20;
    for (i = (float16x4_t *)(v28 + 8); ; i = (float16x4_t *)((char *)i + 10))
    {
      v44 = v41 + (float)((float)(v16 + v16) * v23);
      v45 = (float)((float)(v17 * v17) + (float)(v16 * v16)) - v26;
      if (v25 == 0.0)
      {
        v52 = v45 / v44;
      }
      else
      {
        v46 = (float)((float)(v25 * -4.0) * v45) + (float)(v44 * v44);
        if (v46 < 0.0)
          goto LABEL_48;
        v47 = sqrtf(v46);
        v48 = v40 * (float)(v44 - v47);
        v49 = v44 + v47;
        v50 = v40 * v49;
        v51 = (float)(v40 * v49) <= v48;
        if ((float)(v40 * v49) <= v48)
          v52 = v40 * v49;
        else
          v52 = v48;
        if (v51)
          v50 = v48;
        if (v50 < 0.0)
        {
          _NF = v50 < v39;
LABEL_31:
          LODWORD(v54) = v38;
          if (_NF)
            goto LABEL_48;
LABEL_32:
          if ((v54 & 0x80000000) == 0)
            goto LABEL_44;
          goto LABEL_48;
        }
        if (v50 <= 1.0)
        {
          v55 = v20 + (float)(v50 * v42);
          goto LABEL_43;
        }
        if ((v22 & 0x80000000) == 0)
        {
          LODWORD(v54) = v22;
          if (v50 <= v24)
          {
LABEL_44:
            v56 = 16 * (_DWORD)v54;
            v54 = v54;
            if (!v33)
              v54 = 0;
            _S25 = v34[v54];
            v58 = *(float32x4_t *)(v32 + v56);
            if (!v33)
              goto LABEL_51;
            goto LABEL_50;
          }
        }
      }
      if (v52 < 0.0)
      {
        _NF = v52 < v39;
        goto LABEL_31;
      }
      if (v52 > 1.0)
      {
        LODWORD(v54) = v22;
        if (v52 > v24)
          goto LABEL_48;
        goto LABEL_32;
      }
      v55 = v20 + (float)(v52 * v42);
LABEL_43:
      LODWORD(v54) = (int)(float)(v19 * (float)(v55 - v18));
      if ((v54 & 0x80000000) == 0)
        goto LABEL_44;
LABEL_48:
      if (!v30)
      {
        v63 = 0;
        goto LABEL_53;
      }
      _S25 = *v31;
      v58 = *v30;
LABEL_50:
      v58 = vmulq_n_f32(v58, _S25);
LABEL_51:
      i[-1] = vcvt_f16_f32(v58);
      __asm { FCVT            H25, S25 }
      i->i16[0] = _H25;
      v63 = -1;
LABEL_53:
      v16 = v10 + v16;
      v17 = v11 + v17;
      *v27++ = v63;
      if (!--a4)
        return;
    }
  }
  v35 = v17 * v17;
  v36 = -v25;
  if (v35 <= (float)-v25)
  {
    v64 = fabsf(v9[8]);
    v65 = v25 * -4.0;
    v66 = v21 - v20;
    if (v33)
      v67 = v22;
    else
      v67 = 0;
    v68 = (int32x2_t *)(v28 + 10);
    v69 = a4 + 2;
    v4.i64[0] = *(_QWORD *)(a1 + 40);
    __asm { FMOV            V20.4S, #1.0 }
    v5.i64[0] = v4.i64[0];
    while (1)
    {
      v71 = v35 + (float)(v16 * v16);
      v72 = v10 + v16;
      v73 = v35 + (float)(v72 * v72);
      if (v71 > v36 && v73 > v36)
      {
        if ((v22 & 0x80000000) != 0)
        {
          if (!v30)
          {
            v93 = 0;
            v90 = 0;
            goto LABEL_103;
          }
          _Q23.i32[0] = *(__int32 *)v31;
          _D24 = (int32x2_t)vcvt_f16_f32(vmulq_n_f32(*v30, *v31));
          *(int32x2_t *)((char *)v68 - 10) = _D24;
          __asm { FCVT            H23, S23 }
          v68[-1].i16[3] = _Q23.i16[0];
          *v68 = _D24;
        }
        else
        {
          _Q23.i64[0] = 0;
          *(float *)_D24.i32 = v34[v67];
          _Q23 = (int64x2_t)vmulq_f32(*(float32x4_t *)(v32 + 16 * (int)v22), (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_s64(v5, _Q23).i64[0], 0), _Q20, (int8x16_t)vdupq_lane_s32(_D24, 0)));
          v82 = vcvt_f16_f32((float32x4_t)_Q23);
          *(float16x4_t *)((char *)v68 - 10) = v82;
          __asm { FCVT            H23, S24 }
          v68[-1].i16[3] = _Q23.i16[0];
          *v68 = (int32x2_t)v82;
        }
        goto LABEL_101;
      }
      v75 = sqrtf(v65 * v73);
      v76 = v64 * sqrtf(v65 * v71);
      v77 = v64 * v75;
      v78 = (int)(float)(v19 * (float)((float)(v20 + (float)(v76 * v66)) - v18));
      v79 = (int)(float)(v19 * (float)((float)(v20 + (float)((float)(v64 * v75) * v66)) - v18));
      if (v76 <= 1.0 && v77 <= 1.0)
      {
        v83 = 16 * (_DWORD)v78;
        v78 = (int)v78;
        if (!v33)
          v78 = 0;
        *(float *)_Q23.i32 = v34[v78];
        v84 = *(float32x4_t *)(v32 + v83);
        if (v33)
        {
          v84 = vmulq_n_f32(v84, *(float *)_Q23.i32);
          _S25 = *(float *)(v33 + 4 * (int)v79);
          v86 = vmulq_n_f32(*(float32x4_t *)(v32 + 16 * (int)v79), _S25);
        }
        else
        {
          _S25 = *v12;
          v86 = *(float32x4_t *)(v32 + 16 * (int)v79);
        }
        _D24 = (int32x2_t)vcvt_f16_f32(v84);
        *(int32x2_t *)((char *)v68 - 10) = _D24;
        __asm { FCVT            H23, S23 }
        v68[-1].i16[3] = _H23;
        *v68 = (int32x2_t)vcvt_f16_f32(v86);
        __asm { FCVT            H23, S25 }
LABEL_101:
        v90 = -1;
        goto LABEL_102;
      }
      if (v76 <= 1.0)
      {
        if ((v78 & 0x80000000) == 0)
        {
          v81 = 4 * (int)v78;
          if (!v33)
            v78 = 0;
LABEL_83:
          _S24 = v34[v78];
          v88 = *(float32x4_t *)(v32 + 4 * v81);
          if (!v33)
            goto LABEL_88;
          goto LABEL_87;
        }
      }
      else if (v76 <= v24)
      {
        v78 = v67;
        v81 = 4 * (int)v22;
        if ((v22 & 0x80000000) == 0)
          goto LABEL_83;
      }
      if (!v30)
      {
        v90 = 0;
        goto LABEL_89;
      }
      _S24 = *v31;
      v88 = *v30;
LABEL_87:
      v88 = vmulq_n_f32(v88, _S24);
LABEL_88:
      *(float16x4_t *)((char *)&v68[-2] + 6) = vcvt_f16_f32(v88);
      __asm { FCVT            H24, S24 }
      v68[-1].i16[3] = _H24;
      v90 = -1;
LABEL_89:
      if (v77 <= 1.0)
      {
        if ((v79 & 0x80000000) != 0)
          goto LABEL_97;
        v91 = 4 * (int)v79;
        if (!v33)
          v79 = 0;
      }
      else if (v77 > v24 || (v79 = v67, v91 = 4 * (int)v22, (v22 & 0x80000000) != 0))
      {
LABEL_97:
        if (!v30)
        {
          v93 = 0;
          goto LABEL_103;
        }
        _Q23.i32[0] = *(__int32 *)v31;
        _D24 = (int32x2_t)vcvt_f16_f32(vmulq_n_f32(*v30, *v31));
        *v68 = _D24;
        __asm { FCVT            H23, S23 }
        goto LABEL_102;
      }
      _Q23.i64[0] = 0;
      *(float *)_D24.i32 = v34[v79];
      _Q23 = (int64x2_t)vmulq_f32(*(float32x4_t *)(v32 + 4 * v91), (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_s64(v4, _Q23).i64[0], 0), _Q20, (int8x16_t)vdupq_lane_s32(_D24, 0)));
      *v68 = (int32x2_t)vcvt_f16_f32((float32x4_t)_Q23);
      __asm { FCVT            H23, S24 }
LABEL_102:
      v68[1].i16[0] = _Q23.i16[0];
      v93 = -1;
LABEL_103:
      v16 = v10 + v72;
      *v27 = v90;
      v27[1] = v93;
      v27 += 2;
      v68 = (int32x2_t *)((char *)v68 + 20);
      v69 -= 2;
      if (v69 <= 2)
        return;
    }
  }
  if (v30 || (v22 & 0x80000000) == 0)
  {
    if ((v22 & 0x80000000) != 0)
    {
      _S1 = *v31;
      v96 = *v30;
    }
    else
    {
      if (v33)
        v94 = v22;
      else
        v94 = 0;
      _S1 = v34[v94];
      v96 = *(float32x4_t *)(v32 + 16 * (int)v22);
      if (!v33)
        goto LABEL_116;
    }
    v96 = vmulq_n_f32(v96, _S1);
LABEL_116:
    v97 = vcvt_f16_f32(v96);
    __asm { FCVT            H1, S1 }
    v99 = a4 + 4;
    do
    {
      *(float16x4_t *)v28 = v97;
      *(_WORD *)(v28 + 8) = _H1;
      *(float16x4_t *)(v28 + 10) = v97;
      *(_WORD *)(v28 + 18) = _H1;
      *(float16x4_t *)(v28 + 20) = v97;
      *(_WORD *)(v28 + 28) = _H1;
      *(float16x4_t *)(v28 + 30) = v97;
      v99 -= 4;
      *(_WORD *)(v28 + 38) = _H1;
      v28 += 40;
      *(_DWORD *)v27 = -1;
      v27 += 4;
    }
    while (v99 > 4);
    return;
  }
  if (a4 >= 4)
    v37 = 4;
  else
    v37 = a4;
  bzero(v27, ((a4 - v37 + 3) & 0xFFFFFFFC) + 4);
}

void CMYKf16_shade_conic_CMYK(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, int64x2_t a5, __n128 a6)
{
  float32x2_t v7;
  float v8;
  float v9;
  float v10;
  float16x4_t *v11;
  _BYTE *v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  int32x2_t v22;
  int32x2_t v23;
  float v24;
  signed int v25;
  unsigned int v26;
  float v27;
  uint64_t v28;
  int v29;
  int8x16_t v30;
  uint64_t v31;
  float v32;
  float16x4_t v35;
  int8x16_t v36;
  int64x2_t v37;
  int8x16_t v38;
  __n128 v39;

  v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a2));
  v8 = a1[42].f32[0];
  v9 = a1[43].f32[0];
  v10 = a1[38].f32[0];
  v12 = (_BYTE *)a1[18];
  v11 = (float16x4_t *)a1[19];
  v13 = a1[4];
  v14 = a1[5];
  if (v14)
    v15 = a1[5];
  else
    v15 = a1[34];
  v16 = a1[38].f32[1] - v10;
  *(float32x2_t *)a5.i8 = a1[5];
  v37 = a5;
  __asm { FMOV            V0.4S, #1.0 }
  v36 = (int8x16_t)_Q0;
  do
  {
    _Q0.i64[0] = 0;
    v38 = (int8x16_t)vdupq_lane_s64(vceqq_s64(v37, _Q0).i64[0], 0);
    v39 = a6;
    *(float *)_Q0.i32 = v9
                      * (float)((float)(v10
                                      + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5)
                                              * v16))
                              - v8);
    v24 = ceilf(*(float *)_Q0.i32);
    v25 = vcvtms_s32_f32(*(float *)_Q0.i32);
    v26 = vcvtms_s32_f32(v9 + *(float *)_Q0.i32);
    if (*(float *)_Q0.i32 < 0.0)
      v25 = v26;
    v27 = ceilf(*(float *)_Q0.i32 - v9);
    if (*(float *)_Q0.i32 > v9)
      v24 = v27;
    v28 = v25;
    if (!*(_QWORD *)&v14)
      v28 = 0;
    v22.i32[0] = *(_DWORD *)(*(_QWORD *)&v15 + 4 * v28);
    v29 = (int)v24;
    v30 = (int8x16_t)vdupq_lane_s32(v22, 0);
    v31 = v29;
    if (!*(_QWORD *)&v14)
      v31 = 0;
    v23.i32[0] = *(_DWORD *)(*(_QWORD *)&v15 + 4 * v31);
    v32 = *(float *)_Q0.i32 - (float)(int)floorf(*(float *)_Q0.i32);
    _Q1 = vmulq_f32(*(float32x4_t *)(*(_QWORD *)&v13 + 16 * v25), (float32x4_t)vbslq_s8(v38, v36, v30));
    _S2 = *(float *)v22.i32 + (float)(v32 * (float)(*(float *)v23.i32 - *(float *)v22.i32));
    v35 = vcvt_f16_f32(vmlaq_n_f32(_Q1, vsubq_f32(vmulq_f32(*(float32x4_t *)(*(_QWORD *)&v13 + 16 * v29), (float32x4_t)vbslq_s8(v38, v36, (int8x16_t)vdupq_lane_s32(v23, 0))), _Q1), v32));
    __asm { FCVT            H1, S2 }
    *v11 = v35;
    v11[1].i16[0] = _Q1.i16[0];
    a6.n128_u64[1] = v39.n128_u64[1];
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v39.n128_u64[0]);
    *v12++ = -1;
    v11 = (float16x4_t *)((char *)v11 + 10);
    --a4;
  }
  while (a4);
}

uint64_t CMYKf16_shade_custom_CMYK(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6;
  float32x2_t v7;
  float32x4_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  char *v13;
  float32x4_t *v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  float16x4_t *v20;
  float32x4_t v21;
  float32x4_t v23;
  int v24;
  float v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v34;

  v6 = *(_QWORD *)(result + 272);
  v7 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), *(float *)(v6 + 4) * (float)a3), v7, *(float *)(v6 + 4) * (float)a2));
  v8 = *(float32x4_t *)(result + 304);
  v9 = *(float *)(result + 336);
  v10 = *(float *)(result + 348);
  v11 = *(float *)(result + 344);
  v12 = *(float *)(result + 356);
  v13 = *(char **)(result + 144);
  v14 = *(float32x4_t **)(result + 384);
  v15 = *(float **)(result + 392);
  if (!v15)
    v15 = *(float **)(result + 272);
  v16 = *(_QWORD *)(result + 32);
  v17 = *(_QWORD *)(result + 40);
  if (v17)
    v18 = *(_DWORD *)(result + 48);
  else
    v18 = 0;
  if (v17)
    v6 = *(_QWORD *)(result + 40);
  v19 = 4 * *(_DWORD *)(result + 48);
  v20 = (float16x4_t *)(*(_QWORD *)(result + 152) + 8);
  do
  {
    v21 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v8, v21))), vmovn_s32(vcgtq_f32(v21, v8))), 0xFuLL))) & 1) == 0)
    {
      v24 = (int)(float)(v12 * (float)(*(float *)&a6.i32[1] - v10));
      v25 = v11 * (float)(*(float *)a6.i32 - v9);
      v26 = v16 + 4 * v19 * v24;
      v27 = 16 * (int)v25;
      v28 = v6 + 4 * v18 * v24;
      result = (int)v25;
      if (!v17)
        result = 0;
      _S7 = *(float *)(v28 + 4 * result);
      v23 = *(float32x4_t *)(v26 + v27);
      if (!v17)
        goto LABEL_16;
      goto LABEL_15;
    }
    if (v14)
    {
      _S7 = *v15;
      v23 = *v14;
LABEL_15:
      v23 = vmulq_n_f32(v23, _S7);
LABEL_16:
      v20[-1] = vcvt_f16_f32(v23);
      __asm { FCVT            H7, S7 }
      v20->i16[0] = _H7;
      v34 = -1;
      goto LABEL_18;
    }
    v34 = 0;
LABEL_18:
    *(float32x2_t *)a6.i8 = vadd_f32(v7, *(float32x2_t *)a6.i8);
    *v13++ = v34;
    v20 = (float16x4_t *)((char *)v20 + 10);
    --a4;
  }
  while (a4);
  return result;
}

void CMYKf16_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  int v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  float32x4_t *v17;
  float *v18;
  float *v19;
  uint64_t v20;
  int v21;
  float16x4_t *i;
  uint64_t v23;
  uint64_t v24;
  float32x4_t v26;
  char v32;
  uint64_t v33;
  float32x4_t v35;
  float16x4_t v36;
  int v38;

  v5 = *(float *)(a1 + 280);
  v6 = *(float **)(a1 + 272);
  v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  v8 = *(float *)(a1 + 336);
  v9 = *(float *)(a1 + 344);
  v10 = *(float *)(a1 + 304);
  v11 = *(float *)(a1 + 308);
  LODWORD(v12) = *(_DWORD *)(a1 + 320);
  v13 = *(_DWORD *)(a1 + 324);
  v16 = a1 + 144;
  v14 = *(_DWORD **)(a1 + 144);
  v15 = *(_QWORD *)(v16 + 8);
  v17 = *(float32x4_t **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v18 = *(float **)(a1 + 392);
  else
    v18 = v6;
  v20 = *(_QWORD *)(a1 + 32);
  v19 = *(float **)(a1 + 40);
  if (v19)
    v6 = v19;
  if (v5 != 0.0)
  {
    for (i = (float16x4_t *)(v15 + 8); ; i = (float16x4_t *)((char *)i + 10))
    {
      LODWORD(v23) = v12;
      if (v7 >= v10)
      {
        LODWORD(v23) = v13;
        if (v7 <= v11)
          LODWORD(v23) = (int)(float)(v9 * (float)(v7 - v8));
      }
      if ((v23 & 0x80000000) != 0)
      {
        if (!v17)
        {
          v32 = 0;
          goto LABEL_29;
        }
        _S6 = *v18;
        v26 = *v17;
      }
      else
      {
        v24 = 16 * (_DWORD)v23;
        v23 = v23;
        if (!v19)
          v23 = 0;
        _S6 = v6[v23];
        v26 = *(float32x4_t *)(v20 + v24);
        if (!v19)
          goto LABEL_28;
      }
      v26 = vmulq_n_f32(v26, _S6);
LABEL_28:
      i[-1] = vcvt_f16_f32(v26);
      __asm { FCVT            H6, S6 }
      i->i16[0] = _H6;
      v32 = -1;
LABEL_29:
      v7 = v5 + v7;
      *(_BYTE *)v14 = v32;
      v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4)
        return;
    }
  }
  if (v7 >= v10)
  {
    LODWORD(v12) = v13;
    if (v7 <= v11)
      LODWORD(v12) = (int)(float)(v9 * (float)(v7 - v8));
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      _S1 = *v18;
      v35 = *v17;
    }
    else
    {
      v33 = 16 * (_DWORD)v12;
      v12 = v12;
      if (!v19)
        v12 = 0;
      _S1 = v6[v12];
      v35 = *(float32x4_t *)(v20 + v33);
      if (!v19)
        goto LABEL_39;
    }
    v35 = vmulq_n_f32(v35, _S1);
LABEL_39:
    v36 = vcvt_f16_f32(v35);
    __asm { FCVT            H1, S1 }
    v38 = a4 + 4;
    do
    {
      *(float16x4_t *)v15 = v36;
      *(_WORD *)(v15 + 8) = _H1;
      *(float16x4_t *)(v15 + 10) = v36;
      *(_WORD *)(v15 + 18) = _H1;
      *(float16x4_t *)(v15 + 20) = v36;
      *(_WORD *)(v15 + 28) = _H1;
      *(float16x4_t *)(v15 + 30) = v36;
      v38 -= 4;
      *(_WORD *)(v15 + 38) = _H1;
      v15 += 40;
      *v14++ = -1;
    }
    while (v38 > 4);
    return;
  }
  if (a4 >= 4)
    v21 = 4;
  else
    v21 = a4;
  bzero(v14, ((a4 - v21 + 3) & 0xFFFFFFFC) + 4);
}

uint64_t CMYKf16_sample_Wf16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  __int16 *v43;
  __int16 *v44;
  unint64_t v45;
  __int16 *v46;
  __int16 *v47;
  unsigned int v50;
  int v51;
  unsigned int v52;
  __int16 *v53;
  unint64_t v55;
  __int16 *v56;
  __int16 *v58;
  uint64_t v63;
  __int16 *v64;
  unint64_t v65;
  unint64_t v66;
  __int16 *v67;
  __int16 *v68;
  float v78;
  float v81;
  float v84;
  float v85;
  float v88;
  float v89;
  __int16 *v92;
  __int16 *v95;
  char *v96;
  __int16 *v97;
  __int16 *v98;
  __int16 *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  __int16 *v113;
  __int16 *v114;
  __int16 *v115;
  __int16 *v116;
  unsigned int v117;
  unsigned int *v120;
  unsigned int v121;
  int v123;
  int v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;

  v5 = *(_QWORD *)(result + 32);
  v6 = *(_QWORD *)(result + 40);
  v7 = *(_DWORD *)(result + 24);
  v8 = *(_DWORD *)(result + 28);
  v9 = *(_QWORD *)(result + 176);
  v10 = *(_QWORD *)(result + 72);
  v126 = *(_QWORD *)(result + 80);
  v127 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 112);
  v11 = *(_QWORD *)(result + 120);
  v125 = *(_DWORD *)(result + 188);
  v13 = *(_QWORD *)(result + 152) - 10;
  v14 = *(_QWORD *)(result + 144) - 1;
  v15 = *(_DWORD *)(result + 260) - 1;
  v16 = *(unsigned int *)(result + 256);
  v17 = v6 + (v15 * v8) + 2 * (v16 - 1);
  v123 = *(_DWORD *)(result + 240);
  v18 = v5 + (v15 * v7) + 2 * v16 - 2;
  v128 = *(_QWORD *)(result + 64);
  v124 = a4;
  while (1)
  {
    if (a3 >= v10)
    {
      if (a3 <= v127)
      {
        v28 = ((unint64_t)a3 >> 22) & 0x3C0;
        v29 = 0x3FFFFFFF;
        v30 = a3;
        v22 = v128;
      }
      else
      {
        v24 = *(_QWORD *)(result + 216);
        v25 = *(_QWORD *)(result + 224) + v127;
        v26 = v25 - a3 + (v24 >> 1);
        v22 = v128;
        if (v26 < 1)
          goto LABEL_39;
        if (v26 >= v24)
          LODWORD(v27) = 0x3FFFFFFF;
        else
          v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
        v29 = v27 | v125;
        v30 = v25 - 0x1000000;
        v28 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v10 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = v128;
      if (v21 < 1)
        goto LABEL_39;
      if (v21 >= v19)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v29 = v23 | v125;
      v30 = v20 + 0x1000000;
      v28 = 512;
    }
    if (a2 >= v22)
      break;
    v31 = *(_QWORD *)(result + 192);
    v32 = v22 - *(_QWORD *)(result + 200);
    v33 = a2 - v32 + (v31 >> 1);
    if (v33 >= 1)
    {
      if (v33 < v31)
        v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v125;
      v34 = v32 + 0x1000000;
      v35 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v12;
    a3 += v11;
    v13 += 10;
    *(_BYTE *)++v14 = 0;
LABEL_40:
    if (!a4)
      return result;
  }
  if (a2 <= v126)
  {
    v35 = ((unint64_t)a2 >> 26) & 0x3C;
    v34 = a2;
    goto LABEL_26;
  }
  v36 = *(_QWORD *)(result + 192);
  v37 = *(_QWORD *)(result + 200) + v126;
  v38 = v37 - a2 + (v36 >> 1);
  if (v38 < 1)
    goto LABEL_39;
  if (v38 < v36)
    v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v38) >> 32) >> 15)) | v125;
  v34 = v37 - 0x1000000;
  v35 = 28;
LABEL_26:
  if (v29 < 0x400000)
    goto LABEL_39;
  v39 = v30 >> 32;
  v40 = v34 >> 31;
  v41 = v40 & 0xFFFFFFFFFFFFFFFELL;
  v42 = v5 + (int)v39 * (uint64_t)v7 + (v40 & 0xFFFFFFFFFFFFFFFELL);
  v43 = *(__int16 **)(result + 32);
  if (v18 >= v42)
    v44 = (__int16 *)(v5 + (int)v39 * (uint64_t)v7 + (v40 & 0xFFFFFFFFFFFFFFFELL));
  else
    v44 = (__int16 *)v18;
  if (v44 < v43)
    v44 = *(__int16 **)(result + 32);
  if (v6)
  {
    v45 = v6 + (int)v39 * (uint64_t)v8 + v41;
    v46 = *(__int16 **)(result + 40);
    if (v17 >= v45)
      v47 = (__int16 *)v45;
    else
      v47 = (__int16 *)v17;
    if (v47 >= v46)
      v46 = v47;
    _H4 = *v46;
  }
  else
  {
    v45 = 0;
    _H4 = 15360;
  }
  _H5 = *v44;
  if (!v9)
    goto LABEL_119;
  v50 = *(_DWORD *)(v9 + (v35 | v28));
LABEL_45:
  v51 = v50 & 0xF;
  v52 = HIBYTE(v50) & 3;
  switch(v51)
  {
    case 1:
      v92 = (__int16 *)(v42 + SBYTE1(v50) * (uint64_t)v7);
      if (v18 < (unint64_t)v92)
        v92 = (__int16 *)v18;
      if (v92 < v43)
        v92 = v43;
      _H6 = *v92;
      _H7 = 15360;
      if (v6)
      {
        v95 = (__int16 *)(v45 + SBYTE1(v50) * (uint64_t)v8);
        if (v17 < (unint64_t)v95)
          v95 = (__int16 *)v17;
        if ((unint64_t)v95 < *(_QWORD *)(result + 40))
          v95 = *(__int16 **)(result + 40);
        _H7 = *v95;
      }
      v96 = (char *)&interpolate_waf[2 * v52];
      goto LABEL_117;
    case 2:
      v97 = (__int16 *)(v42 + 2 * SBYTE2(v50));
      if (v18 < (unint64_t)v97)
        v97 = (__int16 *)v18;
      if (v97 < v43)
        v97 = v43;
      _H6 = *v97;
      _H7 = 15360;
      if (v6)
      {
        v98 = (__int16 *)(v45 + 2 * SBYTE2(v50));
        if (v17 < (unint64_t)v98)
          v98 = (__int16 *)v17;
        if ((unint64_t)v98 < *(_QWORD *)(result + 40))
          v98 = *(__int16 **)(result + 40);
        _H7 = *v98;
      }
      v96 = (char *)&interpolate_waf[2 * ((v50 >> 28) & 3)];
LABEL_117:
      _H16 = *((_WORD *)v96 + 1);
      __asm
      {
        FCVT            S16, H16
        FCVT            S5, H5
        FCVT            S6, H6
      }
      _S5 = (float)(_S5 - (float)(_S5 * _S16)) + (float)(_S6 * _S16);
      __asm
      {
        FCVT            H5, S5
        FCVT            S4, H4
        FCVT            S6, H7
      }
      _S4 = (float)(_S4 - (float)(_S4 * _S16)) + (float)(_S6 * _S16);
      goto LABEL_118;
    case 3:
      v53 = (__int16 *)(v42 + 2 * SBYTE2(v50));
      if (v18 < (unint64_t)v53)
        v53 = (__int16 *)v18;
      if (v53 < v43)
        v53 = v43;
      _H6 = *v53;
      v55 = v42 + SBYTE1(v50) * (uint64_t)v7;
      if (v18 >= v55)
        v56 = (__int16 *)(v42 + SBYTE1(v50) * (uint64_t)v7);
      else
        v56 = (__int16 *)v18;
      if (v56 < v43)
        v56 = v43;
      _H7 = *v56;
      v58 = (__int16 *)(v55 + 2 * SBYTE2(v50));
      if (v18 < (unint64_t)v58)
        v58 = (__int16 *)v18;
      if (v58 < v43)
        v58 = v43;
      _H16 = *v58;
      _H17 = 15360;
      _H18 = 15360;
      _H19 = 15360;
      if (v6)
      {
        v63 = 2 * SBYTE2(v50);
        v64 = (__int16 *)(v45 + v63);
        v65 = *(_QWORD *)(result + 40);
        if (v17 < v45 + v63)
          v64 = (__int16 *)v17;
        if ((unint64_t)v64 < v65)
          v64 = *(__int16 **)(result + 40);
        _H17 = *v64;
        v66 = v45 + SBYTE1(v50) * (uint64_t)v8;
        if (v17 >= v66)
          v67 = (__int16 *)(v45 + SBYTE1(v50) * (uint64_t)v8);
        else
          v67 = (__int16 *)v17;
        if ((unint64_t)v67 < v65)
          v67 = *(__int16 **)(result + 40);
        _H18 = *v67;
        v68 = (__int16 *)(v66 + v63);
        if (v17 < (unint64_t)v68)
          v68 = (__int16 *)v17;
        if ((unint64_t)v68 < v65)
          v68 = *(__int16 **)(result + 40);
        _H19 = *v68;
      }
      _H20 = interpolate_waf[2 * v52 + 1];
      __asm { FCVT            S20, H20 }
      _H21 = interpolate_waf[2 * ((v50 >> 28) & 3) + 1];
      __asm
      {
        FCVT            S21, H21
        FCVT            S5, H5
        FCVT            S6, H6
      }
      v78 = (float)(_S5 - (float)(_S5 * _S21)) + (float)(_S6 * _S21);
      __asm
      {
        FCVT            S6, H7
        FCVT            S7, H16
      }
      v81 = (float)(_S6 - (float)(_S6 * _S21)) + (float)(_S7 * _S21);
      __asm
      {
        FCVT            S4, H4
        FCVT            S7, H17
      }
      v84 = (float)(_S4 - (float)(_S4 * _S21)) + (float)(_S7 * _S21);
      if (v84 < 1.0)
        v85 = v84;
      else
        v85 = 1.0;
      if (v84 > 1.0)
        v84 = 1.0;
      if (v85 < 0.0)
        v84 = 0.0;
      __asm
      {
        FCVT            S7, H18
        FCVT            S16, H19
      }
      v88 = (float)(_S7 - (float)(_S7 * _S21)) + (float)(_S16 * _S21);
      if (v88 < 1.0)
        v89 = v88;
      else
        v89 = 1.0;
      if (v88 > 1.0)
        v88 = 1.0;
      if (v89 < 0.0)
        v88 = 0.0;
      _S5 = (float)(v78 - (float)(v78 * _S20)) + (float)(v81 * _S20);
      __asm { FCVT            H5, S5 }
      _S4 = (float)(v84 - (float)(v84 * _S20)) + (float)(v88 * _S20);
      if (_S4 >= 1.0)
        _S4 = 1.0;
      if (_S4 <= 0.0)
        _S4 = 0.0;
LABEL_118:
      __asm { FCVT            H4, S4 }
      break;
  }
LABEL_119:
  *(_WORD *)(v13 + 14) = 0;
  *(_DWORD *)(v13 + 10) = 0;
  __asm { FCVT            S5, H5 }
  _S5 = 1.0 - _S5;
  __asm { FCVT            H5, S5 }
  *(_WORD *)(v13 + 16) = LOWORD(_S5);
  *(_WORD *)(v13 + 18) = _H4;
  *(_BYTE *)++v14 = v29 >> 22;
  if (--a4)
  {
    v108 = (__int16 *)(v13 + 28);
    a3 += v11;
    v109 = v127 - a3;
    a2 += v12;
    v110 = v126 - a2;
    while (1)
    {
      v13 = (uint64_t)(v108 - 9);
      if (((a2 - v128) | v110 | (a3 - v10) | v109) < 0)
        goto LABEL_40;
      v111 = v5 + SHIDWORD(a3) * (uint64_t)v7;
      v112 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      v42 = v111 + v112;
      v43 = *(__int16 **)(result + 32);
      if (v18 >= v111 + v112)
        v113 = (__int16 *)(v111 + v112);
      else
        v113 = (__int16 *)v18;
      if (v113 >= v43)
        v114 = v113;
      else
        v114 = *(__int16 **)(result + 32);
      _H4 = 15360;
      if (v6)
      {
        v45 = v6 + SHIDWORD(a3) * (uint64_t)v8 + v112;
        v115 = *(__int16 **)(result + 40);
        if (v17 >= v45)
          v116 = (__int16 *)(v6 + SHIDWORD(a3) * (uint64_t)v8 + v112);
        else
          v116 = (__int16 *)v17;
        if (v116 >= v115)
          v115 = v116;
        _H4 = *v115;
      }
      _H5 = *v114;
      if (v9)
      {
        v50 = *(_DWORD *)(v9 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        v117 = v50 & 0xF;
        if ((v50 & 0xF) != 0)
        {
          v120 = *(unsigned int **)(result + 264);
          v121 = *v120;
          if (a4 != 1 && a4 + 1 != v124 && v123 != 1 && v121 == 3 && v117 < 3)
            v50 |= 3u;
          v29 = -1;
          if (v121 < v117)
            *v120 = v117;
          goto LABEL_45;
        }
      }
      *(v108 - 2) = 0;
      *((_DWORD *)v108 - 2) = 0;
      __asm { FCVT            S5, H5 }
      _S5 = 1.0 - _S5;
      __asm { FCVT            H5, S5 }
      *(v108 - 1) = LOWORD(_S5);
      *v108 = _H4;
      *(_BYTE *)++v14 = -1;
      v108 += 5;
      v109 -= v11;
      a2 += v12;
      v110 -= v12;
      a3 += v11;
      if (!--a4)
        return result;
    }
  }
  return result;
}

uint64_t CMYKf16_sample_RGBf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  double v30;
  double v35;
  double v48;
  double v53;
  float v62;
  double v66;
  unsigned int v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  float v126;
  __int16 v127;
  float v128;
  __int16 v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  const unsigned __int8 *v140;
  const unsigned __int8 *v141;
  uint64_t v142;
  __int16 v143;
  __int16 v144;
  __int16 v145;
  __int16 v146;
  __int16 v147;
  __int16 v148;
  __int16 v149;
  __int16 v150;
  __int16 v151;
  __int16 v152;
  __int16 v153;
  __int16 v154;
  __int16 v155;
  const unsigned __int8 *v156;
  unsigned int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  unsigned int v176;
  uint64_t v177;
  uint64_t v178;
  int v179;
  int v180;
  const unsigned __int8 *v181;
  uint64_t v182;
  _WORD *v183;
  unsigned int v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  uint64_t v194;
  int v195;
  uint64_t v198;

  v198 = result;
  v195 = a4;
  v194 = *(_QWORD *)(result + 32);
  v193 = *(_DWORD *)(result + 24);
  v192 = *(_QWORD *)(result + 176);
  v191 = *(_QWORD *)(result + 64);
  v190 = *(_QWORD *)(result + 72);
  v189 = *(_QWORD *)(result + 112);
  v188 = *(_QWORD *)(result + 80);
  v187 = *(_QWORD *)(result + 88);
  v186 = *(_QWORD *)(result + 120);
  v185 = *(_DWORD *)(result + 188);
  v184 = 0;
  v183 = (_WORD *)(*(_QWORD *)(result + 152) - 10);
  v182 = *(_QWORD *)(result + 144) - 1;
  v181 = (const unsigned __int8 *)(*(_QWORD *)(v198 + 32)
                                 + (*(_DWORD *)(v198 + 24) * (*(_DWORD *)(result + 260) - 1))
                                 + 2 * (3 * *(_DWORD *)(result + 256)));
  v180 = a4 - 1;
  v179 = *(_DWORD *)(result + 240);
  do
  {
    v178 = 0;
    v177 = 0;
    v176 = 0;
    if (a3 >= v190)
    {
      if (a3 <= v187)
      {
        v176 = ((a3 >> 28) & 0xF) << 6;
        v184 = 0x3FFFFFFF;
        v177 = a3;
      }
      else
      {
        v166 = *(_QWORD *)(v198 + 224);
        v165 = *(_QWORD *)(v198 + 216);
        v164 = v187 + v166 - (a3 - (v165 >> 1));
        if (v164 > 0)
        {
          if (v164 < v165)
          {
            result = IMAGECOVERAGE_YEDGE(v164, *(_QWORD *)(v198 + 232));
            v184 = v185 | result;
          }
          else
          {
            v184 = v185 | 0x3FFFFFFF;
          }
          v176 = 448;
          v177 = v187 + v166 - 0x1000000;
          v168 = 0;
        }
        else
        {
          v168 = 4;
        }
        if (v168)
          goto LABEL_102;
      }
    }
    else
    {
      v175 = *(_QWORD *)(v198 + 224);
      v174 = *(_QWORD *)(v198 + 216);
      v173 = a3 + (v174 >> 1) - (v190 - v175);
      if (v173 > 0)
      {
        if (v173 < v174)
        {
          result = IMAGECOVERAGE_YEDGE(v173, *(_QWORD *)(v198 + 232));
          v184 = v185 | result;
        }
        else
        {
          v184 = v185 | 0x3FFFFFFF;
        }
        v176 = 512;
        v177 = v190 - v175 + 0x1000000;
        v167 = 0;
      }
      else
      {
        v167 = 4;
      }
      if (v167)
        goto LABEL_102;
    }
    if (a2 >= v191)
    {
      if (a2 <= v188)
      {
        v176 |= 4 * ((a2 >> 28) & 0xF);
        v178 = a2;
      }
      else
      {
        v160 = *(_QWORD *)(v198 + 200);
        v159 = *(_QWORD *)(v198 + 192);
        v158 = v188 + v160 - (a2 - (v159 >> 1));
        if (v158 > 0)
        {
          if (v158 < v159)
          {
            result = IMAGECOVERAGE_XEDGE(v158, *(_QWORD *)(v198 + 208), v184);
            v184 = v185 | result;
          }
          v176 |= 0x1Cu;
          v178 = v188 + v160 - 0x1000000;
          v170 = 0;
        }
        else
        {
          v170 = 4;
        }
        if (v170)
        {
LABEL_102:
          --v195;
          a2 += v189;
          a3 += v186;
          v183 += 5;
          *(_BYTE *)++v182 = 0;
          v171 = 0;
          continue;
        }
      }
    }
    else
    {
      v163 = *(_QWORD *)(v198 + 200);
      v162 = *(_QWORD *)(v198 + 192);
      v161 = a2 + (v162 >> 1) - (v191 - v163);
      if (v161 > 0)
      {
        if (v161 < v162)
        {
          result = IMAGECOVERAGE_XEDGE(v161, *(_QWORD *)(v198 + 208), v184);
          v184 = v185 | result;
        }
        v176 |= 0x20u;
        v178 = v191 - v163 + 0x1000000;
        v169 = 0;
      }
      else
      {
        v169 = 4;
      }
      if (v169)
        goto LABEL_102;
    }
    if (v184 <= 0x3FFFFF)
      goto LABEL_102;
    v156 = (const unsigned __int8 *)(v194 + v193 * (v177 >> 32) + 6 * (v178 >> 32));
    result = (uint64_t)CLAMP_PTR(v156, *(const unsigned __int8 **)(v198 + 32), v181, 6);
    v152 = *(_WORD *)result;
    v153 = *(_WORD *)(result + 2);
    v154 = *(_WORD *)(result + 4);
    _S0 = 1.0;
    __asm { FCVT            H0, S0 }
    v155 = LOWORD(_S0);
    if (!v192)
      goto LABEL_79;
    v157 = *(_DWORD *)(v192 + v176);
LABEL_41:
    switch(v157 & 0xF)
    {
      case 3u:
        v142 = v193 * (uint64_t)SBYTE1(v157);
        v141 = CLAMP_PTR(&v156[6 * SBYTE2(v157)], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        v148 = *(_WORD *)v141;
        v149 = *((_WORD *)v141 + 1);
        v150 = *((_WORD *)v141 + 2);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        v151 = LOWORD(_S0);
        v140 = CLAMP_PTR(&v156[v142], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        v144 = *(_WORD *)v140;
        v145 = *((_WORD *)v140 + 1);
        v146 = *((_WORD *)v140 + 2);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        v147 = LOWORD(_S0);
        result = (uint64_t)CLAMP_PTR(&v156[6 * SBYTE2(v157) + v142], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        v143 = LOWORD(_S0);
        LOWORD(_S0) = interpolate_rgbaf16[4 * (HIBYTE(v157) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v139 = _S0;
        LOWORD(_S0) = interpolate_rgbaf16[4 * ((v157 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v138 = _S0;
        LOWORD(_S0) = v152;
        __asm { FCVT            S0, H0 }
        _H2 = v148;
        __asm { FCVT            S2, H2 }
        v137 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v144;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        v136 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v153;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v149;
        __asm { FCVT            S2, H2 }
        v133 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v145;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        v132 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v154;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v150;
        __asm { FCVT            S2, H2 }
        v135 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v146;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        v134 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v155;
        __asm { FCVT            S0, H0 }
        _H1 = v151;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
        {
          _H0 = v155;
          __asm { FCVT            S0, H0 }
          _H1 = v151;
          __asm { FCVT            S1, H1 }
          v30 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
        }
        else
        {
          v30 = 1.0;
        }
        if (v30 >= 0.0)
        {
          _H0 = v155;
          __asm { FCVT            S0, H0 }
          _H1 = v151;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
          {
            _H0 = v155;
            __asm { FCVT            S0, H0 }
            _H1 = v151;
            __asm { FCVT            S1, H1 }
            v35 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
          }
          else
          {
            v35 = 1.0;
          }
        }
        else
        {
          v35 = 0.0;
        }
        _S0 = v35;
        v131 = _S0;
        LOWORD(_S0) = v147;
        __asm { FCVT            S0, H0 }
        _H1 = v143;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
        {
          _H0 = v147;
          __asm { FCVT            S0, H0 }
          _H1 = v143;
          __asm { FCVT            S1, H1 }
          v48 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
        }
        else
        {
          v48 = 1.0;
        }
        if (v48 >= 0.0)
        {
          _H0 = v147;
          __asm { FCVT            S0, H0 }
          _H1 = v143;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
          {
            _H0 = v147;
            __asm { FCVT            S0, H0 }
            _H1 = v143;
            __asm { FCVT            S1, H1 }
            v53 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
          }
          else
          {
            v53 = 1.0;
          }
        }
        else
        {
          v53 = 0.0;
        }
        v62 = v53;
        v130 = v62;
        _S0 = (float)(v137 - (float)(v137 * v139)) + (float)(v136 * v139);
        __asm { FCVT            H0, S0 }
        v152 = LOWORD(_S0);
        _S0 = (float)(v133 - (float)(v133 * v139)) + (float)(v132 * v139);
        __asm { FCVT            H0, S0 }
        v153 = LOWORD(_S0);
        _S0 = (float)(v135 - (float)(v135 * v139)) + (float)(v134 * v139);
        __asm { FCVT            H0, S0 }
        v154 = LOWORD(_S0);
        if ((float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139)) <= 1.0)
          v66 = (float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139));
        else
          v66 = 1.0;
        if (v66 >= 0.0)
        {
          if ((float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139)) <= 1.0)
            _D0 = (float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139));
          else
            _D0 = 1.0;
        }
        else
        {
          _D0 = 0.0;
        }
        __asm { FCVT            H0, D0 }
        v155 = _H0;
        break;
      case 2u:
        result = (uint64_t)CLAMP_PTR(&v156[6 * SBYTE2(v157)], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        v129 = LOWORD(_S0);
        LOWORD(_S0) = interpolate_rgbaf16[4 * ((v157 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v128 = _S0;
        LOWORD(_S0) = v152;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        v152 = LOWORD(_S0);
        LOWORD(_S0) = v153;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        v153 = LOWORD(_S0);
        LOWORD(_S0) = v154;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        v154 = LOWORD(_S0);
        LOWORD(_S0) = v155;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v129;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        v155 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        break;
      case 1u:
        result = (uint64_t)CLAMP_PTR(&v156[v193 * (uint64_t)SBYTE1(v157)], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        v127 = LOWORD(_S0);
        LOWORD(_S0) = interpolate_rgbaf16[4 * (HIBYTE(v157) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v126 = _S0;
        LOWORD(_S0) = v152;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        v152 = LOWORD(_S0);
        LOWORD(_S0) = v153;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        v153 = LOWORD(_S0);
        LOWORD(_S0) = v154;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        v154 = LOWORD(_S0);
        LOWORD(_S0) = v155;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v127;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        v155 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        break;
    }
    while (1)
    {
LABEL_79:
      --v195;
      a3 += v186;
      a2 += v189;
      v183 += 5;
      _H0 = v155;
      __asm { FCVT            S0, H0 }
      v125 = _S0;
      LOWORD(_S0) = v152;
      __asm { FCVT            S0, H0 }
      v123 = _S0;
      LOWORD(_S0) = v153;
      __asm { FCVT            S0, H0 }
      v122 = _S0;
      LOWORD(_S0) = v154;
      __asm { FCVT            S0, H0 }
      v121 = _S0;
      if (v123 <= v122)
        v124 = v122;
      else
        v124 = v123;
      if (_S0 > v124)
        v124 = _S0;
      _S0 = v124 - v123;
      __asm { FCVT            H0, S0 }
      *v183 = LOWORD(_S0);
      _S0 = v124 - v122;
      __asm { FCVT            H0, S0 }
      v183[1] = LOWORD(_S0);
      _S0 = v124 - v121;
      __asm { FCVT            H0, S0 }
      v183[2] = LOWORD(_S0);
      _S0 = v125 - v124;
      __asm { FCVT            H0, S0 }
      v183[3] = LOWORD(_S0);
      _S0 = v125;
      __asm { FCVT            H0, S0 }
      v183[4] = LOWORD(_S0);
      *(_BYTE *)++v182 = v184 >> 22;
      if (!v195)
      {
        v171 = 2;
        goto LABEL_103;
      }
      if (((v187 - a3) | (a3 - v190) | (v188 - a2) | (a2 - v191)) < 0)
        break;
      v184 = -1;
      v156 = (const unsigned __int8 *)(v194 + v193 * (a3 >> 32) + 6 * (a2 >> 32));
      result = (uint64_t)CLAMP_PTR(v156, *(const unsigned __int8 **)(v198 + 32), v181, 6);
      v152 = *(_WORD *)result;
      v153 = *(_WORD *)(result + 2);
      v154 = *(_WORD *)(result + 4);
      _S0 = 1.0;
      __asm { FCVT            H0, S0 }
      v155 = LOWORD(_S0);
      if (v192)
      {
        v157 = *(_DWORD *)(v192 + ((((a3 >> 28) & 0xF) << 6) | (4 * ((a2 >> 28) & 0xF))));
        v120 = v157 & 0xF;
        if ((v157 & 0xF) != 0)
        {
          if (v195 != v180 && v195 != 1 && v179 != 1 && **(_DWORD **)(v198 + 264) == 3 && v120 < 3)
            v157 |= 3u;
          if (**(_DWORD **)(v198 + 264) < v120)
            **(_DWORD **)(v198 + 264) = v120;
          v172 = 7;
        }
        else
        {
          v172 = 0;
        }
        if (v172)
          goto LABEL_41;
      }
    }
    v171 = 3;
LABEL_103:
    ;
  }
  while (v171 != 2 && v195);
  return result;
}

unint64_t IMAGECOVERAGE_YEDGE(uint64_t a1, uint64_t a2)
{
  return (unint64_t)(a2 * a1) >> 32;
}

uint64_t IMAGECOVERAGE_XEDGE(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (a3 >> 15) * (((unint64_t)(a2 * a1) >> 32) >> 15);
}

const unsigned __int8 *CLAMP_PTR(const unsigned __int8 *a1, const unsigned __int8 *a2, const unsigned __int8 *a3, uint64_t a4)
{
  const unsigned __int8 *v4;

  v4 = &a3[-a4];
  if (&a3[-a4] >= a1)
    v4 = a1;
  if (v4 >= a2)
    return v4;
  else
    return a2;
}

uint64_t CMYKf16_sample_RGBAf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  double v64;
  double v69;
  double v82;
  double v87;
  float v96;
  double v100;
  unsigned int v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float v185;
  float v186;
  __int16 v187;
  float v188;
  __int16 v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  const unsigned __int8 *v200;
  const unsigned __int8 *v201;
  uint64_t v202;
  __int16 v203;
  __int16 v204;
  __int16 v205;
  __int16 v206;
  __int16 v207;
  __int16 v208;
  __int16 v209;
  __int16 v210;
  __int16 v211;
  __int16 v212;
  __int16 v213;
  __int16 v214;
  __int16 v215;
  const unsigned __int8 *v216;
  unsigned int v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  int v227;
  int v228;
  int v229;
  int v230;
  int v231;
  int v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  unsigned int v236;
  uint64_t v237;
  uint64_t v238;
  int v239;
  int v240;
  const unsigned __int8 *v241;
  float v242;
  uint64_t v243;
  _WORD *v244;
  unsigned int v245;
  int v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  int v254;
  uint64_t v255;
  int v256;
  uint64_t v259;

  v259 = result;
  v256 = a4;
  v255 = *(_QWORD *)(result + 32);
  v254 = *(_DWORD *)(result + 24);
  v253 = *(_QWORD *)(result + 176);
  v252 = *(_QWORD *)(result + 64);
  v251 = *(_QWORD *)(result + 72);
  v250 = *(_QWORD *)(result + 112);
  v249 = *(_QWORD *)(result + 80);
  v248 = *(_QWORD *)(result + 88);
  v247 = *(_QWORD *)(result + 120);
  v246 = *(_DWORD *)(result + 188);
  v245 = 0;
  v244 = (_WORD *)(*(_QWORD *)(result + 152) - 10);
  v243 = *(_QWORD *)(result + 144) - 1;
  v4 = 1.0;
  if (*(_QWORD *)(result + 40))
    v4 = 0.0;
  v242 = v4;
  v241 = (const unsigned __int8 *)(*(_QWORD *)(result + 32)
                                 + (*(_DWORD *)(result + 24) * (*(_DWORD *)(result + 260) - 1))
                                 + 2 * (4 * *(_DWORD *)(result + 256)));
  v240 = a4 - 1;
  v239 = *(_DWORD *)(result + 240);
  do
  {
    v238 = 0;
    v237 = 0;
    v236 = 0;
    if (a3 >= v251)
    {
      if (a3 <= v248)
      {
        v236 = ((a3 >> 28) & 0xF) << 6;
        v245 = 0x3FFFFFFF;
        v237 = a3;
      }
      else
      {
        v226 = *(_QWORD *)(v259 + 224);
        v225 = *(_QWORD *)(v259 + 216);
        v224 = v248 + v226 - (a3 - (v225 >> 1));
        if (v224 > 0)
        {
          if (v224 < v225)
          {
            result = IMAGECOVERAGE_YEDGE(v224, *(_QWORD *)(v259 + 232));
            v245 = v246 | result;
          }
          else
          {
            v245 = v246 | 0x3FFFFFFF;
          }
          v236 = 448;
          v237 = v248 + v226 - 0x1000000;
          v228 = 0;
        }
        else
        {
          v228 = 4;
        }
        if (v228)
          goto LABEL_174;
      }
    }
    else
    {
      v235 = *(_QWORD *)(v259 + 224);
      v234 = *(_QWORD *)(v259 + 216);
      v233 = a3 + (v234 >> 1) - (v251 - v235);
      if (v233 > 0)
      {
        if (v233 < v234)
        {
          result = IMAGECOVERAGE_YEDGE(v233, *(_QWORD *)(v259 + 232));
          v245 = v246 | result;
        }
        else
        {
          v245 = v246 | 0x3FFFFFFF;
        }
        v236 = 512;
        v237 = v251 - v235 + 0x1000000;
        v227 = 0;
      }
      else
      {
        v227 = 4;
      }
      if (v227)
        goto LABEL_174;
    }
    if (a2 >= v252)
    {
      if (a2 <= v249)
      {
        v236 |= 4 * ((a2 >> 28) & 0xF);
        v238 = a2;
      }
      else
      {
        v220 = *(_QWORD *)(v259 + 200);
        v219 = *(_QWORD *)(v259 + 192);
        v218 = v249 + v220 - (a2 - (v219 >> 1));
        if (v218 > 0)
        {
          if (v218 < v219)
          {
            result = IMAGECOVERAGE_XEDGE(v218, *(_QWORD *)(v259 + 208), v245);
            v245 = v246 | result;
          }
          v236 |= 0x1Cu;
          v238 = v249 + v220 - 0x1000000;
          v230 = 0;
        }
        else
        {
          v230 = 4;
        }
        if (v230)
        {
LABEL_174:
          --v256;
          a2 += v250;
          a3 += v247;
          v244 += 5;
          *(_BYTE *)++v243 = 0;
          v231 = 0;
          continue;
        }
      }
    }
    else
    {
      v223 = *(_QWORD *)(v259 + 200);
      v222 = *(_QWORD *)(v259 + 192);
      v221 = a2 + (v222 >> 1) - (v252 - v223);
      if (v221 > 0)
      {
        if (v221 < v222)
        {
          result = IMAGECOVERAGE_XEDGE(v221, *(_QWORD *)(v259 + 208), v245);
          v245 = v246 | result;
        }
        v236 |= 0x20u;
        v238 = v252 - v223 + 0x1000000;
        v229 = 0;
      }
      else
      {
        v229 = 4;
      }
      if (v229)
        goto LABEL_174;
    }
    if (v245 <= 0x3FFFFF)
      goto LABEL_174;
    v216 = (const unsigned __int8 *)(v255 + v254 * (v237 >> 32) + 8 * (v238 >> 32));
    result = (uint64_t)CLAMP_PTR(v216, *(const unsigned __int8 **)(v259 + 32), v241, 8);
    v212 = *(_WORD *)result;
    v213 = *(_WORD *)(result + 2);
    v214 = *(_WORD *)(result + 4);
    if (v242 == 0.0)
    {
      _H0 = *(_WORD *)(result + 6);
      __asm { FCVT            D0, H0 }
      if (_D0 <= 1.0)
      {
        _H0 = *(_WORD *)(result + 6);
        __asm { FCVT            D0, H0 }
      }
      else
      {
        _D0 = 1.0;
      }
      if (_D0 >= 0.0)
      {
        _H0 = *(_WORD *)(result + 6);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
      }
      else
      {
        _D0 = 0.0;
      }
    }
    else
    {
      _D0 = v242;
    }
    __asm { FCVT            H0, D0 }
    v215 = _H0;
    if (!v253)
      goto LABEL_141;
    v217 = *(_DWORD *)(v253 + v236);
LABEL_53:
    switch(v217 & 0xF)
    {
      case 3u:
        v202 = v254 * (uint64_t)SBYTE1(v217);
        v201 = CLAMP_PTR(&v216[8 * SBYTE2(v217)], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        v208 = *(_WORD *)v201;
        v209 = *((_WORD *)v201 + 1);
        v210 = *((_WORD *)v201 + 2);
        if (v242 == 0.0)
        {
          _H0 = *((_WORD *)v201 + 3);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *((_WORD *)v201 + 3);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *((_WORD *)v201 + 3);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *((_WORD *)v201 + 3);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        v211 = _H0;
        v200 = CLAMP_PTR(&v216[v202], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        v204 = *(_WORD *)v200;
        v205 = *((_WORD *)v200 + 1);
        v206 = *((_WORD *)v200 + 2);
        if (v242 == 0.0)
        {
          _H0 = *((_WORD *)v200 + 3);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *((_WORD *)v200 + 3);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *((_WORD *)v200 + 3);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *((_WORD *)v200 + 3);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        v207 = _H0;
        result = (uint64_t)CLAMP_PTR(&v216[8 * SBYTE2(v217) + v202], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        if (v242 == 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *(_WORD *)(result + 6);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        v203 = _H0;
        _H0 = interpolate_rgbaf16[4 * (HIBYTE(v217) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v199 = _S0;
        LOWORD(_S0) = interpolate_rgbaf16[4 * ((v217 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v198 = _S0;
        LOWORD(_S0) = v212;
        __asm { FCVT            S0, H0 }
        _H2 = v208;
        __asm { FCVT            S2, H2 }
        v197 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v204;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        v196 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v213;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v209;
        __asm { FCVT            S2, H2 }
        v193 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v205;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        v192 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v214;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v210;
        __asm { FCVT            S2, H2 }
        v195 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v206;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        v194 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v215;
        __asm { FCVT            S0, H0 }
        _H1 = v211;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
        {
          _H0 = v215;
          __asm { FCVT            S0, H0 }
          _H1 = v211;
          __asm { FCVT            S1, H1 }
          v64 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
        }
        else
        {
          v64 = 1.0;
        }
        if (v64 >= 0.0)
        {
          _H0 = v215;
          __asm { FCVT            S0, H0 }
          _H1 = v211;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
          {
            _H0 = v215;
            __asm { FCVT            S0, H0 }
            _H1 = v211;
            __asm { FCVT            S1, H1 }
            v69 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
          }
          else
          {
            v69 = 1.0;
          }
        }
        else
        {
          v69 = 0.0;
        }
        _S0 = v69;
        v191 = _S0;
        LOWORD(_S0) = v207;
        __asm { FCVT            S0, H0 }
        _H1 = v203;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
        {
          _H0 = v207;
          __asm { FCVT            S0, H0 }
          _H1 = v203;
          __asm { FCVT            S1, H1 }
          v82 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
        }
        else
        {
          v82 = 1.0;
        }
        if (v82 >= 0.0)
        {
          _H0 = v207;
          __asm { FCVT            S0, H0 }
          _H1 = v203;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
          {
            _H0 = v207;
            __asm { FCVT            S0, H0 }
            _H1 = v203;
            __asm { FCVT            S1, H1 }
            v87 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
          }
          else
          {
            v87 = 1.0;
          }
        }
        else
        {
          v87 = 0.0;
        }
        v96 = v87;
        v190 = v96;
        _S0 = (float)(v197 - (float)(v197 * v199)) + (float)(v196 * v199);
        __asm { FCVT            H0, S0 }
        v212 = LOWORD(_S0);
        _S0 = (float)(v193 - (float)(v193 * v199)) + (float)(v192 * v199);
        __asm { FCVT            H0, S0 }
        v213 = LOWORD(_S0);
        _S0 = (float)(v195 - (float)(v195 * v199)) + (float)(v194 * v199);
        __asm { FCVT            H0, S0 }
        v214 = LOWORD(_S0);
        if ((float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199)) <= 1.0)
          v100 = (float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199));
        else
          v100 = 1.0;
        if (v100 >= 0.0)
        {
          if ((float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199)) <= 1.0)
            _D0 = (float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199));
          else
            _D0 = 1.0;
        }
        else
        {
          _D0 = 0.0;
        }
        __asm { FCVT            H0, D0 }
        v215 = _H0;
        break;
      case 2u:
        result = (uint64_t)CLAMP_PTR(&v216[8 * SBYTE2(v217)], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        if (v242 == 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *(_WORD *)(result + 6);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        v189 = _H0;
        _H0 = interpolate_rgbaf16[4 * ((v217 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v188 = _S0;
        LOWORD(_S0) = v212;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        v212 = LOWORD(_S0);
        LOWORD(_S0) = v213;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        v213 = LOWORD(_S0);
        LOWORD(_S0) = v214;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        v214 = LOWORD(_S0);
        LOWORD(_S0) = v215;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v189;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        v215 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        break;
      case 1u:
        result = (uint64_t)CLAMP_PTR(&v216[v254 * (uint64_t)SBYTE1(v217)], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        if (v242 == 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *(_WORD *)(result + 6);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        v187 = _H0;
        _H0 = interpolate_rgbaf16[4 * (HIBYTE(v217) & 3) + 3];
        __asm { FCVT            S0, H0 }
        v186 = _S0;
        LOWORD(_S0) = v212;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        v212 = LOWORD(_S0);
        LOWORD(_S0) = v213;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        v213 = LOWORD(_S0);
        LOWORD(_S0) = v214;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        v214 = LOWORD(_S0);
        LOWORD(_S0) = v215;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v187;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        v215 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        break;
    }
    while (1)
    {
LABEL_141:
      --v256;
      a3 += v247;
      a2 += v250;
      v244 += 5;
      _H0 = v215;
      __asm { FCVT            S0, H0 }
      v185 = _S0;
      LOWORD(_S0) = v212;
      __asm { FCVT            S0, H0 }
      v183 = _S0;
      LOWORD(_S0) = v213;
      __asm { FCVT            S0, H0 }
      v182 = _S0;
      LOWORD(_S0) = v214;
      __asm { FCVT            S0, H0 }
      v181 = _S0;
      if (v183 <= v182)
        v184 = v182;
      else
        v184 = v183;
      if (_S0 > v184)
        v184 = _S0;
      _S0 = v184 - v183;
      __asm { FCVT            H0, S0 }
      *v244 = LOWORD(_S0);
      _S0 = v184 - v182;
      __asm { FCVT            H0, S0 }
      v244[1] = LOWORD(_S0);
      _S0 = v184 - v181;
      __asm { FCVT            H0, S0 }
      v244[2] = LOWORD(_S0);
      _S0 = v185 - v184;
      __asm { FCVT            H0, S0 }
      v244[3] = LOWORD(_S0);
      _S0 = v185;
      __asm { FCVT            H0, S0 }
      v244[4] = LOWORD(_S0);
      *(_BYTE *)++v243 = v245 >> 22;
      if (!v256)
      {
        v231 = 2;
        goto LABEL_175;
      }
      if (((v248 - a3) | (a3 - v251) | (v249 - a2) | (a2 - v252)) < 0)
        break;
      v245 = -1;
      v216 = (const unsigned __int8 *)(v255 + v254 * (a3 >> 32) + 8 * (a2 >> 32));
      result = (uint64_t)CLAMP_PTR(v216, *(const unsigned __int8 **)(v259 + 32), v241, 8);
      v212 = *(_WORD *)result;
      v213 = *(_WORD *)(result + 2);
      v214 = *(_WORD *)(result + 4);
      if (v242 == 0.0)
      {
        _H0 = *(_WORD *)(result + 6);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
        }
        else
        {
          _D0 = 0.0;
        }
      }
      else
      {
        _D0 = v242;
      }
      __asm { FCVT            H0, D0 }
      v215 = _H0;
      if (v253)
      {
        v217 = *(_DWORD *)(v253 + ((((a3 >> 28) & 0xF) << 6) | (4 * ((a2 >> 28) & 0xF))));
        v180 = v217 & 0xF;
        if ((v217 & 0xF) != 0)
        {
          if (v256 != v240 && v256 != 1 && v239 != 1 && **(_DWORD **)(v259 + 264) == 3 && v180 < 3)
            v217 |= 3u;
          if (**(_DWORD **)(v259 + 264) < v180)
            **(_DWORD **)(v259 + 264) = v180;
          v232 = 7;
        }
        else
        {
          v232 = 0;
        }
        if (v232)
          goto LABEL_53;
      }
    }
    v231 = 3;
LABEL_175:
    ;
  }
  while (v231 != 2 && v256);
  return result;
}

_QWORD *CGPDFTextExtractorCreateWithPage(uint64_t a1, char a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t cftype;

  v4 = CGPDFTextExtractorCreate(0);
  if (v4)
  {
    v5 = CGPDFContentStreamCreate(a1);
    v4[5] = v5;
    if (v5)
    {
      if (CGPDFTextStringGetTypeID_onceToken != -1)
        dispatch_once(&CGPDFTextStringGetTypeID_onceToken, &__block_literal_global_10353);
      cftype = pdf_create_cftype();
      if (cftype)
      {
        *(_BYTE *)(cftype + 16) = a2;
        *(_OWORD *)(cftype + 24) = 0u;
        *(_OWORD *)(cftype + 40) = 0u;
        v4[6] = cftype;
        return v4;
      }
      v4[6] = 0;
    }
    CGPDFTextExtractorRelease(v4);
    return 0;
  }
  return v4;
}

_QWORD *CGPDFTextExtractorCreate(__int128 ***a1)
{
  _QWORD *v2;
  _QWORD *Copy;
  CGPDFOperatorTableRef v4;
  CGPDFOperatorTable *v5;
  uint64_t i;
  CFMutableDictionaryRef Mutable;

  v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (a1)
    Copy = CGPDFRStateCreateCopy(*a1);
  else
    Copy = CGPDFRStateCreate();
  *v2 = Copy;
  if (!Copy)
    goto LABEL_11;
  v2[1] = *Copy;
  v4 = CGPDFOperatorTableCreate();
  if (!v4)
  {
    v2[3] = 0;
LABEL_11:
    CGPDFTextExtractorRelease(v2);
    return 0;
  }
  v5 = v4;
  for (i = 0; i != 44; i += 2)
    CGPDFOperatorTableSetCallback(v5, (&operators_7574)[i], (CGPDFOperatorCallback)(&operators_7574)[i + 1]);
  v2[3] = v5;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  v2[4] = Mutable;
  if (!Mutable)
    goto LABEL_11;
  return v2;
}

void CGPDFTextExtractorRelease(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  if (a1)
  {
    v2 = (const void *)a1[4];
    if (v2)
      CFRelease(v2);
    CGPDFRStateRelease((_QWORD *)*a1);
    v3 = (const void *)a1[3];
    if (v3)
      CFRelease(v3);
    v4 = (const void *)a1[6];
    if (v4)
      CFRelease(v4);
    v5 = (const void *)a1[5];
    if (v5)
      CFRelease(v5);
    free(a1);
  }
}

void op_q_7576(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  if (*(_BYTE *)(a2 + 16))
  {
  }
  else
  {
    CGPDFRStateGSave(*(_QWORD *)a2);
    v3 = *(_QWORD **)a2;
    if (*(_QWORD *)a2)
      v3 = (_QWORD *)*v3;
    *(_QWORD *)(a2 + 8) = v3;
  }
}

void op_Q_7578(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  if (*(_BYTE *)(a2 + 16))
  {
  }
  else
  {
    CGPDFRStateGRestore(*(_QWORD *)a2);
    v3 = *(_QWORD **)a2;
    if (*(_QWORD *)a2)
      v3 = (_QWORD *)*v3;
    *(_QWORD *)(a2 + 8) = v3;
  }
}

double op_cm_7580(CGPDFScanner *a1, uint64_t a2)
{
  double result;
  double *v5;
  double v6[6];
  CGPDFReal value;
  CGPDFReal v8;
  CGPDFReal v9;
  CGPDFReal v10;
  CGPDFReal v11;
  CGPDFReal v12;

  v11 = 0.0;
  v12 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  value = 0.0;
  v8 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v8)
    && CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &v10)
    && CGPDFScannerPopNumber(a1, &v11)
    && CGPDFScannerPopNumber(a1, &v12))
  {
    v5 = *(double **)(a2 + 8);
    v6[0] = v12;
    v6[1] = v11;
    v6[2] = v10;
    v6[3] = v9;
    v6[4] = v8;
    v6[5] = value;
    return CGPDFGStateConcatCTM(v5, v6);
  }
  return result;
}

BOOL op_Tc_7582(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  CGPDFReal *v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 72) = value;
      v6 = *(CGPDFReal **)(v4 + 272);
      if (v6)
        *v6 = v5;
    }
  }
  return result;
}

BOOL op_Tw_7584(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 80) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 8) = v5;
    }
  }
  return result;
}

BOOL op_Tz_7586(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 88) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 16) = v5;
    }
  }
  return result;
}

BOOL op_TL_7588(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 96) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 24) = v5;
    }
  }
  return result;
}

void op_Tf_7590(uint64_t *a1, uint64_t a2)
{
  const void *Font;
  uint64_t v5;
  CGPDFReal v6;
  uint64_t v7;
  char *v8;
  CGPDFReal value;

  v8 = 0;
  value = 0.0;
  if (CGPDFScannerPopNumber((CGPDFScannerRef)a1, &value)
    && CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&v8))
  {
    Font = CGPDFContentStreamGetFont(a1[7], v8);
    if (Font)
    {
      CGPDFGStateSetFont(*(_QWORD *)(a2 + 8), Font);
      v5 = *(_QWORD *)(a2 + 8);
      if (v5)
      {
        v6 = value;
        *(CGPDFReal *)(v5 + 128) = value;
        v7 = *(_QWORD *)(v5 + 272);
        if (v7)
          *(CGPDFReal *)(v7 + 56) = v6;
      }
    }
    else
    {
    }
  }
}

void op_Tr_7592(CGPDFScanner *a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  CGPDFInteger value;

  value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    v3 = value;
    if ((unint64_t)value >= 8)
    {
      pdf_error("invalid text drawing mode: %ld.", value);
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 8);
      if (v4)
      {
        *(_DWORD *)(v4 + 112) = value;
        v5 = *(_QWORD *)(v4 + 272);
        if (v5)
          CGPDFTextObjectSetTextDrawingMode(v5, v3);
      }
    }
  }
}

BOOL op_Ts_7594(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 104) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 32) = v5;
    }
  }
  return result;
}

CGFloat op_BT_7596(uint64_t a1, uint64_t a2)
{
  CGFloat result;
  char *TextObject;

  if (*(_BYTE *)(a2 + 16))
  {
    pdf_error("warning: already in a text object.");
  }
  else
  {
    *(_BYTE *)(a2 + 16) = 1;
    TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
    result = CGAffineTransformIdentity.a;
    *(CGAffineTransform *)(TextObject + 72) = CGAffineTransformIdentity;
    *(CGAffineTransform *)(TextObject + 120) = CGAffineTransformIdentity;
  }
  return result;
}

void op_ET_7598(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 16))
    *(_BYTE *)(a2 + 16) = 0;
  else
}

void op_Td_7600(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  double v5;
  CGPDFReal value;

  v5 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v5);
    }
    else
    {
    }
  }
}

void op_TD_7602(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  double v5;
  uint64_t v6;
  char *TextObject;
  double v8;
  CGPDFReal value;

  v8 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v8) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      v4 = *(_QWORD *)(a2 + 8);
      if (v4)
      {
        v5 = -v8;
        *(double *)(v4 + 96) = -v8;
        v6 = *(_QWORD *)(v4 + 272);
        if (v6)
          *(double *)(v6 + 24) = v5;
      }
      TextObject = CGPDFGStateGetTextObject(v4);
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v8);
    }
    else
    {
    }
  }
}

void op_Tm_7604(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  CGPDFReal v5;
  CGPDFReal v6;
  CGPDFReal v7;
  CGPDFReal v8;
  CGPDFReal v9;
  char *TextObject;
  uint64_t v11;
  CGPDFReal value;
  CGPDFReal v13;
  CGPDFReal v14;
  CGPDFReal v15;
  CGPDFReal v16;

  v15 = 0.0;
  v16 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v11 = 0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v11)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v13)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      v4 = v11;
      v5 = value;
      v6 = v13;
      v7 = v14;
      v8 = v15;
      v9 = v16;
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
      *((CGPDFReal *)TextObject + 9) = v9;
      *((CGPDFReal *)TextObject + 10) = v8;
      *((CGPDFReal *)TextObject + 11) = v7;
      *((CGPDFReal *)TextObject + 12) = v6;
      *((CGPDFReal *)TextObject + 13) = v5;
      *((_QWORD *)TextObject + 14) = v4;
      *((CGPDFReal *)TextObject + 15) = v9;
      *((CGPDFReal *)TextObject + 16) = v8;
      *((CGPDFReal *)TextObject + 17) = v7;
      *((CGPDFReal *)TextObject + 18) = v6;
      *((CGPDFReal *)TextObject + 19) = v5;
      *((_QWORD *)TextObject + 20) = v4;
    }
    else
    {
    }
  }
}

double op_Tstar_7606(uint64_t a1, uint64_t a2)
{
  char *TextObject;
  uint64_t v4;
  double v5;
  double result;

  if (*(_BYTE *)(a2 + 16))
  {
    TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
      v5 = *(double *)(v4 + 96);
    else
      v5 = 0.0;
    *(_QWORD *)&result = CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v5).n128_u64[0];
  }
  else
  {
  }
  return result;
}

void op_Tj_7608(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  __n128 v4;
  CGPDFStringRef value;

  value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
      v4.n128_f64[0] = CGPDFTextObjectAppendString((uint64_t)TextObject, (uint64_t)value);
      CGPDFTextStringAppendTextLayout(*(_QWORD **)(a2 + 48), *(_QWORD *)a2, *((_QWORD **)TextObject + 21), v4);
    }
    else
    {
    }
  }
}

void op_singlequote_7610(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  uint64_t v4;
  uint64_t v5;
  double v6;
  __n128 v7;
  CGPDFStringRef value;

  value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
      v4 = (uint64_t)TextObject;
      v5 = *(_QWORD *)(a2 + 8);
      if (v5)
        v6 = *(double *)(v5 + 96);
      else
        v6 = 0.0;
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v6);
      v7.n128_f64[0] = CGPDFTextObjectAppendString(v4, (uint64_t)value);
      CGPDFTextStringAppendTextLayout(*(_QWORD **)(a2 + 48), *(_QWORD *)a2, *(_QWORD **)(v4 + 168), v7);
    }
    else
    {
    }
  }
}

void op_doublequote_7612(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  CGPDFReal v5;
  CGPDFReal *v6;
  CGPDFReal v7;
  char *TextObject;
  uint64_t v9;
  uint64_t v10;
  double v11;
  __n128 v12;
  CGPDFReal v13;
  CGPDFReal v14;
  CGPDFStringRef value;

  v14 = 0.0;
  value = 0;
  v13 = 0.0;
  if (CGPDFScannerPopString(a1, &value) && CGPDFScannerPopNumber(a1, &v14) && CGPDFScannerPopNumber(a1, &v13))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      v4 = *(_QWORD *)(a2 + 8);
      if (v4)
      {
        v5 = v14;
        *(CGPDFReal *)(v4 + 72) = v14;
        v6 = *(CGPDFReal **)(v4 + 272);
        if (v6)
        {
          *v6 = v5;
          v7 = v13;
          *(CGPDFReal *)(v4 + 80) = v13;
          v6[1] = v7;
        }
        else
        {
          *(CGPDFReal *)(v4 + 80) = v13;
        }
      }
      TextObject = CGPDFGStateGetTextObject(v4);
      v9 = (uint64_t)TextObject;
      v10 = *(_QWORD *)(a2 + 8);
      if (v10)
        v11 = *(double *)(v10 + 96);
      else
        v11 = 0.0;
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v11);
      v12.n128_f64[0] = CGPDFTextObjectAppendString(v9, (uint64_t)value);
      CGPDFTextStringAppendTextLayout(*(_QWORD **)(a2 + 48), *(_QWORD *)a2, *(_QWORD **)(v9 + 168), v12);
    }
    else
    {
    }
  }
}

void op_TJ_7614(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  __n128 v4;
  CGPDFArrayRef value;

  value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (*(_BYTE *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 8));
      v4.n128_f64[0] = CGPDFTextObjectAppendStrings((uint64_t)TextObject, value);
      CGPDFTextStringAppendTextLayout(*(_QWORD **)(a2 + 48), *(_QWORD *)a2, *((_QWORD **)TextObject + 21), v4);
    }
    else
    {
    }
  }
}

void op_Do_7616(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  CGPDFStream *v10;
  CGPDFDictionary *v11;
  uint64_t v12;
  uint64_t v13;
  CGPDFStream *v14;
  CGPDFDictionary *v15;
  uint64_t *Child;
  uint64_t *v17;
  const CGAffineTransform *v18;
  __int128 v19;
  _OWORD *v20;
  const CGAffineTransform *v21;
  __int128 v22;
  _OWORD v23[3];
  _OWORD v24[3];
  char *value;

  value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    v4 = *((_QWORD *)a1 + 7);
    if (v4)
    {
      v5 = value;
      while (1)
      {
        v6 = CGPDFResourcesCopyXObject(*(_QWORD *)(v4 + 32), v5);
        if (v6)
          break;
        v4 = *(_QWORD *)(v4 + 40);
        if (!v4)
          return;
      }
      v7 = v6[4];
      if (v7)
      {
        if (v7 == 2)
        {
          v12 = CGPDFXObjectGetValue((uint64_t)v6);
          v13 = v12;
          if (v12)
          {
            v14 = *(CGPDFStream **)v12;
            v15 = *(CGPDFDictionary **)(v12 + 88);
          }
          else
          {
            v14 = 0;
            v15 = 0;
          }
          Child = CGPDFTextExtractorCreateChild(a2, v14, v15);
          v17 = Child;
          v21 = (const CGAffineTransform *)(v13 + 40);
          if (!v13)
            v21 = &CGAffineTransformIdentity;
          v22 = *(_OWORD *)&v21->c;
          v23[0] = *(_OWORD *)&v21->a;
          v23[1] = v22;
          v23[2] = *(_OWORD *)&v21->tx;
          v20 = v23;
        }
        else
        {
          if (v7 != 1)
          {
            pdf_error("unrecognized or unsupported XObject subtype.");
            return;
          }
          v8 = CGPDFXObjectGetValue((uint64_t)v6);
          v9 = v8;
          if (v8)
          {
            v10 = *(CGPDFStream **)(v8 + 16);
            v11 = *(CGPDFDictionary **)(v8 + 104);
          }
          else
          {
            v10 = 0;
            v11 = 0;
          }
          Child = CGPDFTextExtractorCreateChild(a2, v10, v11);
          v17 = Child;
          v18 = (const CGAffineTransform *)(v9 + 56);
          if (!v9)
            v18 = &CGAffineTransformIdentity;
          v19 = *(_OWORD *)&v18->c;
          v24[0] = *(_OWORD *)&v18->a;
          v24[1] = v19;
          v24[2] = *(_OWORD *)&v18->tx;
          v20 = v24;
        }
        draw_child_xobject(Child, v20);
        CGPDFTextExtractorRelease(v17);
      }
    }
  }
}

void op_gs_7618(uint64_t *a1, uint64_t a2)
{
  CGPDFDictionary *ExtGState;
  const void *v5;
  uint64_t v6;
  CGPDFReal v7;
  uint64_t v8;
  CGPDFDictionaryRef v9;
  CGPDFArrayRef array;
  char *value;
  CGPDFReal v12;

  value = 0;
  v12 = 0.0;
  v9 = 0;
  array = 0;
  if (CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value))
  {
    ExtGState = (CGPDFDictionary *)CGPDFContentStreamGetExtGState(a1[7], value);
    if (ExtGState)
    {
      if (CGPDFDictionaryGetArray(ExtGState, "Font", &array)
        && CGPDFArrayGetDictionary(array, 0, &v9)
        && CGPDFArrayGetNumber(array, 1uLL, &v12))
      {
        v5 = (const void *)CGPDFFontCreate(v9);
        if (v5)
        {
          CGPDFGStateSetFont(*(_QWORD *)(a2 + 8), v5);
          v6 = *(_QWORD *)(a2 + 8);
          if (v6)
          {
            v7 = v12;
            *(CGPDFReal *)(v6 + 128) = v12;
            v8 = *(_QWORD *)(v6 + 272);
            if (v8)
              *(CGPDFReal *)(v8 + 56) = v7;
          }
        }
      }
    }
  }
}

_QWORD *CGPDFTextExtractorCreateChild(uint64_t a1, CGPDFStream *a2, CGPDFDictionary *a3)
{
  _QWORD *v6;
  CGPDFContentStreamRef v7;
  const void *v8;

  v6 = CGPDFTextExtractorCreate((__int128 ***)a1);
  if (v6)
  {
    v7 = CGPDFContentStreamCreateWithStream(a2, a3, *(CGPDFContentStreamRef *)(a1 + 40));
    v6[5] = v7;
    if (v7)
    {
      v8 = *(const void **)(a1 + 48);
      if (v8)
      {
        CFRetain(v8);
        v6[6] = v8;
        return v6;
      }
      v6[6] = 0;
    }
    CGPDFTextExtractorRelease(v6);
    return 0;
  }
  return v6;
}

void draw_child_xobject(uint64_t *a1, _OWORD *a2)
{
  double *v4;
  __int128 v5;
  CGPDFContentStreamRef *v6;
  _OWORD v7[3];

  if (a1)
  {
    CGPDFRStateGSave(*a1);
    if (*a1)
      v4 = *(double **)*a1;
    else
      v4 = 0;
    v5 = a2[1];
    v7[0] = *a2;
    v7[1] = v5;
    v7[2] = a2[2];
    CGPDFGStateConcatCTM(v4, (double *)v7);
    v6 = CGPDFTextExtractorCopyTextString((CGPDFContentStreamRef *)a1);
    if (v6)
      CFRelease(v6);
    CGPDFRStateGRestore(*a1);
  }
}

CGPDFContentStreamRef *CGPDFTextExtractorCopyTextString(CGPDFContentStreamRef *info)
{
  CGPDFContentStreamRef *v1;
  CGPDFScanner *v2;

  v1 = info;
  if (info)
  {
    if (!*((_BYTE *)info + 56))
    {
      v2 = CGPDFScannerCreate(info[5], info[3], info);
      CGPDFScannerScan(v2);
      if (v2)
        CFRelease(v2);
      *((_BYTE *)v1 + 56) = 1;
    }
    v1 = (CGPDFContentStreamRef *)v1[6];
    if (v1)
      CFRetain(v1);
  }
  return v1;
}

_QWORD *pdf_aes_create(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  if (a2 == 16 || a2 == 32)
  {
    v3 = malloc_type_calloc(1uLL, 0x40uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    *v3 = a2;
    __memcpy_chk();
    pdf_aes_reset(v3);
  }
  else
  {
    pdf_error("invalid AES password length.");
    return 0;
  }
  return v3;
}

uint64_t pdf_aes_reset(_QWORD *key)
{
  char *v2;
  _CCCryptor *v3;
  CCCryptorRef *v4;

  key[5] = 0;
  key[6] = 0;
  v2 = (char *)(key + 5);
  v4 = (CCCryptorRef *)(key + 7);
  v3 = (_CCCryptor *)key[7];
  if (v3)
    CCCryptorRelease(v3);
  return CCCryptorCreate(1u, 0, 0, key + 1, *key, v2, v4);
}

void pdf_aes_free(_QWORD *a1)
{
  _CCCryptor *v2;

  if (a1)
  {
    v2 = (_CCCryptor *)a1[7];
    if (v2)
      CCCryptorRelease(v2);
    free(a1);
  }
}

uint64_t pdf_aes_process_buffer(uint64_t a1, const void *a2, void *dataOut, size_t dataOutAvailable)
{
  BOOL v4;
  uint64_t v5;
  size_t dataOutMoved;

  v4 = (dataOutAvailable & 0xF) == 0 && dataOutAvailable > 0xF;
  v5 = v4;
  if (v4)
  {
    dataOutMoved = 0;
    CCCryptorUpdate(*(CCCryptorRef *)(a1 + 56), a2, dataOutAvailable, dataOut, dataOutAvailable, &dataOutMoved);
  }
  else
  {
    pdf_error("invalid AES block size.", a2, dataOut);
  }
  return v5;
}

uint64_t FontSubset::FontSubset(uint64_t a1, uint64_t a2, __int128 *a3, int a4)
{
  __int128 v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t i;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  uint64_t *v16;
  unsigned __int16 v18;
  _WORD v19[256];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = off_1E1627D68;
  *(_QWORD *)(a1 + 8) = a2;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 16), *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v7 = *a3;
    *(_QWORD *)(a1 + 32) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(a1 + 16) = v7;
  }
  *(_DWORD *)(a1 + 40) = a4;
  *(_QWORD *)(a1 + 48) = PDFXRefTableAddObject(*(_QWORD **)(**(_QWORD **)(a2 + 8) + 464));
  *(_DWORD *)(a1 + 56) = 33;
  PDFFont::get_embedded_font_name((std::string *)(a1 + 64), a2);
  *(_QWORD *)(a1 + 120) = 0;
  v8 = (uint64_t *)(a1 + 120);
  *(_QWORD *)(a1 + 112) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 96;
  *(_QWORD *)(a1 + 128) = 0;
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
    if (v9)
      (*(void (**)(_QWORD, char **, _WORD *, uint64_t))(*(_QWORD *)(v9 + 16) + 280))(*(_QWORD *)(v9 + 112), CGPDFEncodingVectorMacRoman, v19, 256);
    for (i = 0; i != 256; ++i)
    {
      v11 = (unsigned __int16)v19[i];
      v18 = v19[i];
      v12 = *v8;
      if (!*v8)
        goto LABEL_19;
      v13 = a1 + 120;
      do
      {
        v14 = *(unsigned __int16 *)(v12 + 26);
        v15 = v14 >= v11;
        if (v14 >= v11)
          v16 = (uint64_t *)v12;
        else
          v16 = (uint64_t *)(v12 + 8);
        if (v15)
          v13 = v12;
        v12 = *v16;
      }
      while (*v16);
      if ((uint64_t *)v13 == v8 || v11 < *(unsigned __int16 *)(v13 + 26))
LABEL_19:
        *((_WORD *)std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((uint64_t **)(a1 + 112), v11, &v18)+ 14) = i;
    }
  }
  return a1;
}

void sub_184C45948(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t FontSubset::add_glyph(FontSubset *this, unsigned int a2)
{
  uint64_t **v2;
  char **v3;
  uint64_t **v4;
  unsigned int v5;
  BOOL v6;
  char **v7;
  char *v8;
  char **v9;
  char *v10;
  char *v11;
  unsigned int v12;
  BOOL v13;
  char **v14;
  int v15;
  unsigned __int16 v17;

  v17 = a2;
  v2 = (uint64_t **)((char *)this + 96);
  v3 = (char **)*((_QWORD *)this + 12);
  if (v3)
  {
    v4 = (uint64_t **)((char *)this + 96);
    do
    {
      v5 = *((unsigned __int16 *)v3 + 13);
      v6 = v5 >= a2;
      if (v5 >= a2)
        v7 = v3;
      else
        v7 = v3 + 1;
      if (v6)
        v4 = (uint64_t **)v3;
      v3 = (char **)*v7;
    }
    while (*v7);
    if (v4 != v2 && *((unsigned __int16 *)v4 + 13) <= a2)
      return 1;
  }
  if (*((_DWORD *)this + 10) == 1)
  {
    v10 = (char *)*((_QWORD *)this + 15);
    v8 = (char *)this + 120;
    v9 = (char **)v10;
    if (v10)
    {
      v11 = v8;
      do
      {
        v12 = *((unsigned __int16 *)v9 + 13);
        v13 = v12 >= a2;
        if (v12 >= a2)
          v14 = v9;
        else
          v14 = v9 + 1;
        if (v13)
          v11 = (char *)v9;
        v9 = (char **)*v14;
      }
      while (*v14);
      if (v11 != v8 && *((unsigned __int16 *)v11 + 13) <= a2)
      {
        LOWORD(v15) = *((_WORD *)v11 + 14);
LABEL_27:
        *((_WORD *)std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(v2 - 1, a2, &v17)+ 14) = v15;
        return 1;
      }
    }
  }
  else
  {
    v15 = *((_DWORD *)this + 14);
    if (v15 <= 255)
    {
      *((_DWORD *)this + 14) = v15 + 1;
      goto LABEL_27;
    }
  }
  return 0;
}

char *FontSubset::create_glyph_index_set(FontSubset *this)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  BOOL v7;

  v2 = (char *)malloc_type_calloc(1uLL, 0x50uLL, 0x1010040C7309667uLL);
  *(_DWORD *)v2 = 1;
  v3 = (char *)*((_QWORD *)this + 11);
  v4 = (char *)this + 96;
  if (v3 != v4)
  {
    do
    {
      CGFontIndexSetAddIndex(v2, *((unsigned __int16 *)v3 + 13));
      v5 = (char *)*((_QWORD *)v3 + 1);
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (char *)*((_QWORD *)v3 + 2);
          v7 = *(_QWORD *)v6 == (_QWORD)v3;
          v3 = v6;
        }
        while (!v7);
      }
      v3 = v6;
    }
    while (v6 != v4);
  }
  return v2;
}

_WORD *FontSubset::get_encoding_vector(FontSubset *this, uint64_t a2)
{
  _WORD *result;
  uint64_t v5;
  __int128 v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  result = operator new(0x200uLL);
  v5 = 0;
  *(_QWORD *)this = result;
  *((_QWORD *)this + 1) = result;
  *((_QWORD *)this + 2) = result + 256;
  *(_QWORD *)&v6 = -1;
  *((_QWORD *)&v6 + 1) = -1;
  do
  {
    *(_OWORD *)&result[v5] = v6;
    v5 += 8;
  }
  while (v5 != 256);
  *((_QWORD *)this + 1) = result + 256;
  v7 = *(_QWORD **)(a2 + 88);
  if (v7 != (_QWORD *)(a2 + 96))
  {
    while (1)
    {
      v8 = *((unsigned __int16 *)v7 + 14);
      if (v8 >= 0x100)
        break;
      result[v8] = *((_WORD *)v7 + 13);
      v9 = (_QWORD *)v7[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v7[2];
          v11 = *v10 == (_QWORD)v7;
          v7 = v10;
        }
        while (!v11);
      }
      v7 = v10;
      if (v10 == (_QWORD *)(a2 + 96))
        return result;
    }
    __break(1u);
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,std::less<int>,true>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void FontSubset::emit_widths(FontSubset *this)
{
  uint64_t v2;
  CGGlyph *v3;
  uint64_t v4;
  int *font_info;
  float v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  _QWORD *v18;
  _QWORD **v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD **v41;
  _QWORD *v42;
  _QWORD **v43;
  int v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  _QWORD *v50[2];
  int v51;
  CGGlyph *v52;
  const CGGlyph *v53;
  int advances[256];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v2 = **(_QWORD **)(*((_QWORD *)this + 1) + 8);
  FontSubset::get_encoding_vector((FontSubset *)&v52, (uint64_t)this);
  v3 = v52;
  v4 = (char *)v53 - (char *)v52;
  if (v53 == v52)
LABEL_35:
    __break(1u);
  CGFontGetGlyphAdvances(*(CGFontRef *)(*((_QWORD *)this + 1) + 16), v52, 0x100uLL, advances);
  v50[0] = 0;
  v50[1] = 0;
  v49 = (uint64_t *)v50;
  font_info = (int *)get_font_info(*(_QWORD **)(*((_QWORD *)this + 1) + 16));
  if (font_info)
    v6 = (float)font_info[2];
  else
    v6 = 0.0;
  v7 = 0;
  v51 = 0;
  v8 = v4 >> 1;
  do
  {
    if (v8 == v7)
      goto LABEL_35;
    if ((__int16)v3[v7] != -1)
    {
      v9 = advances[v7];
      *((_DWORD *)std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,std::less<int>,true>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v49, v7, &v51)+ 8) = (int)(float)((float)((float)(1000 * v9) / v6) + 0.5);
    }
    v51 = ++v7;
  }
  while (v7 != 256);
  operator delete(v3);
  v16 = v50[0];
  v17 = *((_DWORD *)v49 + 7);
  if (v50[0])
  {
    do
    {
      v18 = v16;
      v16 = (_QWORD *)v16[1];
    }
    while (v16);
  }
  else
  {
    v19 = v50;
    do
    {
      v18 = v19[2];
      v20 = *v18 == (_QWORD)v19;
      v19 = (_QWORD **)v18;
    }
    while (v20);
  }
  v21 = *((unsigned int *)v18 + 7);
  PDFDocumentPrintf(v2, (uint64_t)"/FirstChar %d", v10, v11, v12, v13, v14, v15, *((unsigned int *)v49 + 7));
  PDFDocumentPrintf(v2, (uint64_t)"/LastChar %d", v22, v23, v24, v25, v26, v27, v21);
  PDFDocumentPrintf(v2, (uint64_t)"/Widths [", v28, v29, v30, v31, v32, v33, v47);
  if (v17 <= (int)v21)
  {
    do
    {
      v40 = v50[0];
      if (!v50[0])
        goto LABEL_28;
      v41 = v50;
      do
      {
        v42 = v40;
        v43 = v41;
        v44 = *((_DWORD *)v40 + 7);
        if (v44 >= v17)
          v41 = (_QWORD **)v40;
        else
          ++v40;
        v40 = (_QWORD *)*v40;
      }
      while (v40);
      if (v41 != v50 && (v44 >= v17 ? (v45 = v42) : (v45 = v43), v17 >= *((_DWORD *)v45 + 7)))
      {
        if (v44 < v17)
          v42 = v43;
        v46 = *((unsigned int *)v42 + 8);
      }
      else
      {
LABEL_28:
        v46 = 0;
      }
      PDFDocumentPrintf(v2, (uint64_t)"%d", v34, v35, v36, v37, v38, v39, v46);
      v20 = v17++ == (_DWORD)v21;
    }
    while (!v20);
  }
  PDFDocumentPrintf(v2, (uint64_t)"]", v34, v35, v36, v37, v38, v39, v48);
  std::__tree<unsigned long>::destroy(v50[0]);
}

void sub_184C45F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

unint64_t get_font_stream_7680(uint64_t a1, int *a2)
{
  unint64_t result;
  CGPDFStreamRef v4;
  _BOOL4 Name;
  const char *v6;
  int v7;
  CGPDFStreamRef value;

  result = CGPDFFontGetFontDescriptor(a1);
  if (result)
  {
    value = 0;
    if (CGPDFDictionaryGetStream(*(CGPDFDictionaryRef *)(result + 32), "FontFile3", &value))
      v4 = value;
    else
      v4 = 0;
    if (!v4)
      return 0;
    value = 0;
    Name = CGPDFDictionaryGetName(*((CGPDFDictionaryRef *)v4 + 6), "Subtype", (const char **)&value);
    result = 0;
    if (!Name)
      return result;
    v6 = (const char *)value;
    if (!strcmp((const char *)value, "CIDFontType0C"))
    {
      v7 = 4;
    }
    else
    {
      if (strcmp(v6, "OpenType"))
      {
        return 0;
      }
      v7 = 6;
    }
    *a2 = v7;
    return (unint64_t)v4;
  }
  return result;
}

uint64_t CGPDFFontHasMatchingROS(uint64_t a1, _QWORD *a2)
{
  const char **CIDSystemInfo;
  const char *v4;
  const char *v5;
  _BOOL4 RegistryOrderingSupplement;
  uint64_t v7;
  CFStringRef v8;
  CFStringRef v9;
  CFTypeRef v11;
  CFTypeRef cf2;
  int v13;

  CIDSystemInfo = (const char **)CGPDFFontGetCIDSystemInfo(a1);
  if (!CIDSystemInfo)
    return 1;
  v5 = *CIDSystemInfo;
  v4 = CIDSystemInfo[1];
  if (!strcmp(*CIDSystemInfo, "Adobe") && !strcmp(v4, "Identity"))
    return 1;
  v13 = 0;
  v11 = 0;
  cf2 = 0;
  RegistryOrderingSupplement = CGFontGetRegistryOrderingSupplement(a2, &cf2, &v11, &v13);
  v7 = 0;
  if (RegistryOrderingSupplement)
  {
    v8 = CFStringCreateWithCString(0, v5, 0x600u);
    v7 = CFEqual(v8, cf2);
    CFRelease(v8);
    if ((_DWORD)v7)
    {
      v9 = CFStringCreateWithCString(0, v4, 0x600u);
      v7 = CFEqual(v9, v11) != 0;
      CFRelease(v9);
    }
  }
  return v7;
}

_QWORD *CGPDFFontMatchCID(uint64_t a1)
{
  uint64_t v1;
  unint64_t FontDescriptor;
  unint64_t Style;
  double v4;
  _BOOL4 v5;
  _QWORD *CIDSystemInfo;
  const char *v7;
  const char *v8;
  int v9;
  _QWORD *MatchingFont;
  _QWORD *v11;
  const char *v12;
  const char *v13;

  v1 = a1;
  FontDescriptor = CGPDFFontGetFontDescriptor(a1);
  Style = CGPDFFontDescriptorGetStyle(FontDescriptor);
  if (Style)
  {
    v4 = *(double *)Style;
    v5 = *(_BYTE *)(Style + 18) != 0;
  }
  else
  {
    v5 = 0;
    v4 = 0.0;
  }
  CIDSystemInfo = CGPDFFontGetCIDSystemInfo(v1);
  if (CIDSystemInfo)
  {
    v7 = (const char *)*CIDSystemInfo;
    v8 = (const char *)CIDSystemInfo[1];
    v9 = *((_DWORD *)CIDSystemInfo + 4);
    MatchingFont = CGFontCreateMatchingFont((const char *)*CIDSystemInfo, v8, v9, v5, v4);
    v11 = MatchingFont;
    if (MatchingFont)
    {
      v12 = "CIDFontType2";
      if (v1)
      {
        if (*(_DWORD *)(v1 + 200) == 6)
          v12 = "CIDFontType0";
        v1 = *(_QWORD *)(v1 + 32);
      }
      v13 = (const char *)(*(uint64_t (**)(_QWORD))(MatchingFont[2] + 144))(MatchingFont[14]);
    }
  }
  else
  {
    return 0;
  }
  return v11;
}

uint64_t zombie_GetColorTransform()
{
  return 0;
}

CGFloat zombie_GetTransform@<D0>(CGAffineTransform *a1@<X8>)
{
  *a1 = CGAffineTransformIdentity;
  return CGAffineTransformIdentity.tx;
}

double zombie_GetBounds()
{
  return INFINITY;
}

uint64_t zombie_DrawRects()
{
  return 0;
}

uint64_t zombie_DrawPath()
{
  return 0;
}

uint64_t zombie_DrawImage()
{
  return 0;
}

uint64_t zombie_DrawGlyphs()
{
  return 0;
}

uint64_t zombie_DrawShading()
{
  return 0;
}

uint64_t zombie_DrawLinearGradient()
{
  return 0;
}

uint64_t zombie_DrawRadialGradient()
{
  return 0;
}

uint64_t zombie_DrawConicGradient()
{
  return 0;
}

uint64_t zombie_DrawDisplayList()
{
  return 0;
}

uint64_t zombie_DrawImages()
{
  return 0;
}

uint64_t zombie_DrawImageFromRect()
{
  return 0;
}

uint64_t zombie_BeginPage()
{
  return 0;
}

uint64_t zombie_EndPage()
{
  return 0;
}

uint64_t zombie_Operation()
{
  return 0;
}

uint64_t zombie_DrawWindowContents()
{
  return 0;
}

double zombie_GetLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  double result;

  v8 = CGContextDelegateCreate(0, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
  {
    *(_OWORD *)(v8 + 216) = xmmword_1E162C2C8;
    *(_OWORD *)(v8 + 232) = unk_1E162C2D8;
    *(_OWORD *)(v8 + 248) = xmmword_1E162C2E8;
    *(_OWORD *)(v8 + 264) = unk_1E162C2F8;
    *(_OWORD *)(v8 + 152) = xmmword_1E162C288;
    *(_OWORD *)(v8 + 168) = *(_OWORD *)&off_1E162C298;
    *(_OWORD *)(v8 + 184) = xmmword_1E162C2A8;
    *(_OWORD *)(v8 + 200) = *(_OWORD *)&off_1E162C2B8;
    *(_OWORD *)(v8 + 88) = xmmword_1E162C248;
    *(_OWORD *)(v8 + 104) = *(_OWORD *)&off_1E162C258;
    *(_OWORD *)(v8 + 120) = xmmword_1E162C268;
    *(_OWORD *)(v8 + 136) = *(_OWORD *)&off_1E162C278;
    *(_OWORD *)(v8 + 24) = gZombieVTable;
    *(_OWORD *)(v8 + 40) = *(_OWORD *)&off_1E162C218;
    *(_QWORD *)&result = 6522430000;
    *(_OWORD *)(v8 + 56) = xmmword_1E162C228;
    *(_OWORD *)(v8 + 72) = *(_OWORD *)&off_1E162C238;
  }
  return result;
}

uint64_t zombie_DrawLayer()
{
  return 0;
}

uint64_t CGContextDelegateGetTypeID()
{
  if (_block_invoke_once_7714 != -1)
    dispatch_once(&_block_invoke_once_7714, &__block_literal_global_4_7715);
  return CGContextDelegateGetTypeID_context_delegate_id;
}

uint64_t CGContextDelegateCreateWithCallbacks(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (!a2)
    return 0;
  if (_block_invoke_once_7714 != -1)
    dispatch_once(&_block_invoke_once_7714, &__block_literal_global_4_7715);
  result = CGTypeCreateInstance(CGContextDelegateGetTypeID_context_delegate_id, 280, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *(_QWORD *)(result + 288) = a1;
    v11 = *a2;
    v12 = a2[1];
    v13 = a2[2];
    *(_OWORD *)(result + 72) = a2[3];
    *(_OWORD *)(result + 56) = v13;
    *(_OWORD *)(result + 40) = v12;
    *(_OWORD *)(result + 24) = v11;
    v14 = a2[4];
    v15 = a2[5];
    v16 = a2[6];
    *(_OWORD *)(result + 136) = a2[7];
    *(_OWORD *)(result + 120) = v16;
    *(_OWORD *)(result + 104) = v15;
    *(_OWORD *)(result + 88) = v14;
    v17 = a2[8];
    v18 = a2[9];
    v19 = a2[10];
    *(_OWORD *)(result + 200) = a2[11];
    *(_OWORD *)(result + 184) = v19;
    *(_OWORD *)(result + 168) = v18;
    *(_OWORD *)(result + 152) = v17;
    v20 = a2[12];
    v21 = a2[13];
    v22 = a2[14];
    *(_OWORD *)(result + 264) = a2[15];
    *(_OWORD *)(result + 248) = v22;
    *(_OWORD *)(result + 232) = v21;
    *(_OWORD *)(result + 216) = v20;
  }
  return result;
}

CFTypeRef CGContextDelegateRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

uint64_t CGContextDelegateImplementsCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (!a1)
    return 1;
  result = get_callback_address(a1, a2, (uint64_t)"CGContextDelegateImplementsCallback", a4, a5, a6, a7, a8);
  if (result)
    return *(_QWORD *)result != 0;
  return result;
}

uint64_t CGContextDelegateGetDelegate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  _QWORD *callback_address;

  for (i = a1; i; i = *(_QWORD *)(i + 16))
  {
    callback_address = (_QWORD *)get_callback_address(i, a2, (uint64_t)"CGContextDelegateGetDelegate", a4, a5, a6, a7, a8);
    if (callback_address && *callback_address == a3)
      break;
  }
  return i;
}

uint64_t CGContextDelegateGetNext(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

void CGContextDelegateSetNext(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v4;

  if (a1)
  {
    v4 = *(CFTypeRef *)(a1 + 16);
    if (v4 != cf)
    {
      if (cf)
      {
        CFRetain(cf);
        v4 = *(CFTypeRef *)(a1 + 16);
      }
      if (v4)
        CFRelease(v4);
      *(_QWORD *)(a1 + 16) = cf;
    }
  }
}

uint64_t CGContextDelegateGetColorTransform(uint64_t a1)
{
  uint64_t (*v1)(void);

  if (a1 && (v1 = *(uint64_t (**)(void))(a1 + 32)) != 0)
    return v1();
  else
    return 0;
}

uint64_t CGContextDelegateGetColorSpace(uint64_t a1)
{
  uint64_t (*v1)(void);

  if (a1 && (v1 = *(uint64_t (**)(void))(a1 + 264)) != 0)
    return v1();
  else
    return 0;
}

CGFloat CGContextDelegateGetTransform@<D0>(uint64_t a1@<X0>, CGAffineTransform *a2@<X8>)
{
  void (*v2)(void);
  CGFloat result;

  if (a1 && (v2 = *(void (**)(void))(a1 + 40)) != 0)
  {
    v2();
  }
  else
  {
    *a2 = CGAffineTransformIdentity;
    return CGAffineTransformIdentity.tx;
  }
  return result;
}

uint64_t CGContextDelegateDrawShading(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 96);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateDrawRadialGradient(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 112);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateDrawConicGradient(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 120);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateDrawDisplayList(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 128);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateDrawImages(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 136);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateDrawImageFromRect(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 144);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateBeginPage(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 152);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateEndPage(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 160);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateOperation(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 168);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateDrawWindowContents(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 176);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateGetLayer(uint64_t a1)
{
  uint64_t (*v1)(void);

  if (a1 && (v1 = *(uint64_t (**)(void))(a1 + 208)) != 0)
    return v1();
  else
    return 0;
}

uint64_t CGContextDelegateDrawLayer(uint64_t result)
{
  uint64_t (*v1)(void);

  if (result)
  {
    v1 = *(uint64_t (**)(void))(result + 216);
    if (v1)
      return v1();
    else
      return 1006;
  }
  return result;
}

uint64_t CGContextDelegateGetBitmapContextInfo(uint64_t a1)
{
  uint64_t (*v1)(void);

  if (a1 && (v1 = *(uint64_t (**)(void))(a1 + 248)) != 0)
    return v1();
  else
    return 0;
}

uint64_t CGContextDelegateDrawImageApplyingToneMapping(uint64_t a1)
{
  uint64_t (*v1)(void);

  if (!a1)
    return 1000;
  v1 = *(uint64_t (**)(void))(a1 + 272);
  if (v1)
    return v1();
  else
    return 1006;
}

uint64_t CGContextDelegateSetOwnerIdentity(uint64_t result, int a2)
{
  *(_DWORD *)(result + 280) = a2;
  return result;
}

_QWORD *CGCryptorCreateRC4(const void *a1, size_t a2)
{
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (a2 - 513 < 0xFFFFFFFFFFFFFE00)
    return 0;
  v4 = malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
  *(_BYTE *)v4 = 0;
  v5 = malloc_type_malloc(a2, 0x2062DE7BuLL);
  v4[2] = v5;
  memmove(v5, a1, a2);
  v4[1] = a2;
  v4[3] = 0;
  *((_DWORD *)v4 + 8) = 4;
  v4[5] = 0;
  if ((CGCryptorReset((CCCryptorRef *)v4, v6, v7, v8, v9, v10, v11, v12) & 1) == 0)
  {
    CGCryptorRelease((uint64_t)v4);
    return 0;
  }
  return v4;
}

uint64_t CGCryptorReset(CCCryptorRef *cryptorRef, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CCCryptor *v9;
  CCCryptorRef *v10;
  int v11;
  CCCryptorRef v12;
  CCCryptorRef v13;
  CCAlgorithm v14;
  CCOptions v15;
  CCCryptorRef v16;
  CCCryptorStatus v17;

  v10 = cryptorRef + 3;
  v9 = cryptorRef[3];
  if (v9)
  {
    CCCryptorRelease(v9);
    *v10 = 0;
  }
  v11 = *((_DWORD *)cryptorRef + 8);
  if (v11)
  {
    if (v11 != 4)
    {
      LOBYTE(v17) = 44;
      goto LABEL_10;
    }
    v13 = cryptorRef[1];
    v12 = cryptorRef[2];
    v14 = 4;
    v15 = 0;
    v16 = 0;
  }
  else
  {
    v15 = *(unsigned __int8 *)cryptorRef != 0;
    v13 = cryptorRef[1];
    v12 = cryptorRef[2];
    v16 = cryptorRef[5];
    v14 = 0;
  }
  v17 = CCCryptorCreate(*(_BYTE *)cryptorRef == 0, v14, v15, v12, (size_t)v13, v16, v10);
  if (!v17)
    return 1;
LABEL_10:
  CGPostError((uint64_t)"CGCryptorReset: CCCryptorCreate failed: error %d.", a2, a3, a4, a5, a6, a7, a8, v17);
  return 0;
}

void CGCryptorRelease(uint64_t a1)
{
  _CCCryptor *v2;
  void *v3;

  if (a1)
  {
    v2 = *(_CCCryptor **)(a1 + 24);
    if (v2)
      CCCryptorRelease(v2);
    v3 = *(void **)(a1 + 40);
    if (v3)
      free(v3);
    free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

_QWORD *CGCryptorCreateAES(const void *a1, size_t a2, _OWORD *a3, char a4)
{
  _QWORD *v8;
  void *v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (a2 != 32 && a2 != 16)
    return 0;
  v8 = malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
  *(_BYTE *)v8 = a4;
  v9 = malloc_type_malloc(a2, 0x2062DE7BuLL);
  v8[2] = v9;
  memmove(v9, a1, a2);
  v8[1] = a2;
  v8[3] = 0;
  *((_DWORD *)v8 + 8) = 0;
  v10 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
  v8[5] = v10;
  *v10 = *a3;
  if ((CGCryptorReset((CCCryptorRef *)v8, v11, v12, v13, v14, v15, v16, v17) & 1) == 0)
  {
    CGCryptorRelease((uint64_t)v8);
    return 0;
  }
  return v8;
}

void CGCryptorProcessBytes(uint64_t a1, const void *a2, size_t a3, void *a4, size_t a5, size_t *a6)
{
  CCCryptorStatus v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t dataOutMoved;

  dataOutMoved = 0;
  v7 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 24), a2, a3, a4, a5, &dataOutMoved);
  if (v7)
  {
    CGPostError((uint64_t)"CGCryptorProcessBytes: CCCryptorUpdate failed: error %d.", v8, v9, v10, v11, v12, v13, v14, v7);
  }
  else if (a6)
  {
    *a6 = dataOutMoved;
  }
}

void CGCryptorDrain(uint64_t a1, void *a2, size_t a3, size_t *a4)
{
  CCCryptorStatus v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t dataOutMoved;

  dataOutMoved = 0;
  v5 = CCCryptorFinal(*(CCCryptorRef *)(a1 + 24), a2, a3, &dataOutMoved);
  if (v5)
  {
    CGPostError((uint64_t)"CGCryptorProcessBytes: CCCryptorFinal failed: error %d.", v6, v7, v8, v9, v10, v11, v12, v5);
  }
  else if (a4)
  {
    *a4 = dataOutMoved;
  }
}

uint64_t CGCryptorGetInitializationVector(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t CGCryptorGetCipher(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t compareUnsigned(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

uint64_t compareDoubleIndirect(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  double v3;
  double v4;

  v3 = *(double *)(a1 + 8 * *a2);
  v4 = *(double *)(a1 + 8 * *a3);
  if (v3 < v4)
    return 0xFFFFFFFFLL;
  else
    return v3 > v4;
}

_QWORD *CGClipGlyphsCreate(const void *a1, int a2, const CGAffineTransform *a3, const void *a4, const void *a5, uint64_t a6)
{
  _QWORD *v6;
  char *v13;
  const CGAffineTransform *v14;
  __int128 v15;
  __int128 v16;
  void *v17;
  size_t v18;
  void *v19;

  v6 = 0;
  if (a5 && a4 && a1 && a6)
  {
    v13 = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
    v6 = v13;
    *(_DWORD *)v13 = 1;
    v14 = &CGAffineTransformIdentity;
    if (a3)
      v14 = a3;
    v16 = *(_OWORD *)&v14->c;
    v15 = *(_OWORD *)&v14->tx;
    *(_OWORD *)(v13 + 8) = *(_OWORD *)&v14->a;
    *(_OWORD *)(v13 + 24) = v16;
    *(_OWORD *)(v13 + 40) = v15;
    *((_DWORD *)v13 + 14) = a2;
    CFRetain(a1);
    v6[8] = a1;
    v6[11] = a6;
    v17 = malloc_type_malloc(16 * a6, 0x705560E0uLL);
    v6[10] = v17;
    if (v17
      && (memcpy(v17, a5, 16 * a6), v18 = 2 * a6, v19 = malloc_type_malloc(v18, 0x705560E0uLL), (v6[9] = v19) != 0))
    {
      memcpy(v19, a4, v18);
    }
    else
    {
      CGClipGlyphsRelease((uint64_t)v6);
      return 0;
    }
  }
  return v6;
}

void CGClipGlyphsRelease(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  const void *v4;

  if (a1)
  {
    do
    {
      v2 = __ldxr((unsigned int *)a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, (unsigned int *)a1));
    if (!v3)
    {
      v4 = *(const void **)(a1 + 64);
      if (v4)
        CFRelease(v4);
      free(*(void **)(a1 + 80));
      free(*(void **)(a1 + 72));
      free((void *)a1);
    }
  }
}

unsigned int *CGClipGlyphsCreateCopy(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

unsigned int *CGClipGlyphsRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

_QWORD *CGClipGlyphsCreateCopyByApplyingTransform(_QWORD *a1, float64x2_t *a2)
{
  _QWORD *v2;
  float64x2_t *v4;
  float64x2_t *v5;
  uint64_t v6;
  double *v7;
  float64x2_t *v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  unsigned int v22;
  CGAffineTransform v24;

  v2 = a1;
  if (a1)
  {
    if (a2)
    {
      v4 = (float64x2_t *)malloc_type_malloc(16 * a1[11], 0x2062DE7BuLL);
      v5 = v4;
      v6 = v2[11];
      if (v6)
      {
        v7 = (double *)(v2[10] + 8);
        v8 = v4;
        v9 = v2[11];
        do
        {
          *v8++ = vmlaq_n_f64(vmulq_n_f64(a2[1], *v7), *a2, *(v7 - 1));
          v7 += 2;
          --v9;
        }
        while (v9);
      }
      v10 = *((double *)v2 + 1);
      v11 = *((double *)v2 + 2);
      v12 = *((double *)v2 + 3);
      v13 = *((double *)v2 + 4);
      v14 = *((double *)v2 + 5);
      v15 = *((double *)v2 + 6);
      v16 = a2->f64[0];
      v17 = a2->f64[1];
      v18 = a2[1].f64[0];
      v19 = a2[1].f64[1];
      v20 = a2[2].f64[0];
      v21 = a2[2].f64[1];
      v24.a = v11 * v18 + v10 * a2->f64[0];
      v24.b = v11 * v19 + v10 * v17;
      v24.c = v13 * v18 + v12 * v16;
      v24.d = v13 * v19 + v12 * v17;
      v24.tx = v20 + v18 * v15 + v14 * v16;
      v24.ty = v19 * v15 + v14 * v17 + v21;
      v2 = CGClipGlyphsCreate((const void *)v2[8], *((_DWORD *)v2 + 14), &v24, (const void *)v2[9], v4, v6);
      free(v5);
    }
    else
    {
      do
        v22 = __ldxr((unsigned int *)a1);
      while (__stxr(v22 + 1, (unsigned int *)a1));
    }
  }
  return v2;
}

BOOL CGClipGlyphsEqualToClipGlyphs(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t CGClipGlyphsGetLength(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 88);
  return result;
}

uint64_t CGClipGlyphsGetGlyphAtIndex(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(_QWORD *)(result + 88) <= a2)
      return 0;
    else
      return *(unsigned __int16 *)(*(_QWORD *)(result + 72) + 2 * a2);
  }
  return result;
}

CGFloat CGClipGlyphsGetAdvanceAtIndex(uint64_t a1, unint64_t a2)
{
  const CGSize *v2;

  if (a1 && *(_QWORD *)(a1 + 88) > a2)
    v2 = (const CGSize *)(*(_QWORD *)(a1 + 80) + 16 * a2);
  else
    v2 = &CGSizeZero;
  return v2->width;
}

uint64_t CGClipGlyphsGetFontAtIndex(uint64_t result, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;

  if (result)
  {
    v3 = *(_QWORD *)(result + 88);
    if (v3 <= a2)
    {
      return 0;
    }
    else
    {
      if (a3)
      {
        *a3 = 0;
        a3[1] = v3;
      }
      return *(_QWORD *)(result + 64);
    }
  }
  return result;
}

uint64_t CGClipGlyphsGetFontRenderingStyleAtIndex(uint64_t result, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  if (result)
  {
    if (a3)
    {
      v3 = *(_QWORD *)(result + 88);
      *a3 = 0;
      a3[1] = v3;
    }
    return *(unsigned int *)(result + 56);
  }
  return result;
}

__n128 CGClipGlyphsGetMatrixAtIndex@<Q0>(uint64_t a1@<X0>, _QWORD *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v3;
  const CGAffineTransform *v4;
  __int128 v5;
  __n128 result;

  if (a1)
  {
    if (a2)
    {
      v3 = *(_QWORD *)(a1 + 88);
      *a2 = 0;
      a2[1] = v3;
    }
    v4 = (const CGAffineTransform *)(a1 + 8);
  }
  else
  {
    v4 = &CGAffineTransformIdentity;
  }
  v5 = *(_OWORD *)&v4->c;
  *(_OWORD *)a3 = *(_OWORD *)&v4->a;
  *(_OWORD *)(a3 + 16) = v5;
  result = *(__n128 *)&v4->tx;
  *(__n128 *)(a3 + 32) = result;
  return result;
}

uint64_t CGClipGlyphsGetFont(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 64);
  return result;
}

uint64_t CGClipGlyphsGetFontRenderingStyle(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 56);
  return result;
}

__n128 CGClipGlyphsGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  const CGAffineTransform *v2;
  __int128 v3;
  __n128 result;

  v2 = (const CGAffineTransform *)(a1 + 8);
  if (!a1)
    v2 = &CGAffineTransformIdentity;
  v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGClipGlyphsGetCount(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 88);
  return result;
}

uint64_t CGClipGlyphsGetGlyphs(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 72);
  return result;
}

uint64_t CGClipGlyphsGetAdvances(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

double CGClipGlyphsGetBounds(uint64_t a1)
{
  double result;

  result = -8.98846567e307;
  if (!a1)
    return INFINITY;
  return result;
}

void PDFMetaSetRelease(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;
  const void *v4;
  const void *v5;

  if (a1)
  {
    do
    {
      v2 = __ldxr(a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, a1));
    if (!v3)
    {
      v4 = (const void *)*((_QWORD *)a1 + 2);
      if (v4)
        CFRelease(v4);
      v5 = (const void *)*((_QWORD *)a1 + 3);
      if (v5)
        CFRelease(v5);
      free(a1);
    }
  }
}

const void *PDFMetaSetAddDictionary(uint64_t a1, const void *a2)
{
  const void *Value;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value)
  {
    Value = (const void *)PDFXRefTableAddObject(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 464));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, Value);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  }
  return Value;
}

void write_dictionary_entry(const __CFString *a1, __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!CFEqual(a1, CFSTR("/P")) && !CFEqual(a1, CFSTR("/%Stream")))
  {
    write_string(a3, a1);
    write_object_or_reference(a3, a2, v12, v13, v14, v15, v16, v17, a9);
  }
}

void write_object(uint64_t *a1, const __CFString *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFTypeID v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int128 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t Value;
  float valuePtr;
  _OWORD v70[2];

  v11 = CFGetTypeID(cf);
  if (v11 == CFNullGetTypeID())
  {
    PDFDocumentPrintf(a1[1], (uint64_t)"null", v12, v13, v14, v15, v16, v17, a9);
  }
  else if (v11 == CFBooleanGetTypeID())
  {
    v18 = a1[1];
    Value = CFBooleanGetValue((CFBooleanRef)cf);
    PDFDocumentPrintf(v18, (uint64_t)"%b", v19, v20, v21, v22, v23, v24, Value);
  }
  else if (v11 == CFNumberGetTypeID())
  {
    valuePtr = 0.0;
    LODWORD(v70[0]) = 0;
    if (CFNumberIsFloatType((CFNumberRef)cf))
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &valuePtr);
      PDFDocumentPrintf(a1[1], (uint64_t)"%f", v25, v26, v27, v28, v29, v30, COERCE__INT64(valuePtr));
    }
    else
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, v70);
      PDFDocumentPrintf(a1[1], (uint64_t)"%d", v43, v44, v45, v46, v47, v48, LODWORD(v70[0]));
    }
  }
  else if (v11 == CFDateGetTypeID())
  {
    PDFDocumentPrintf(a1[1], (uint64_t)"%D", v31, v32, v33, v34, v35, v36, (uint64_t)cf);
  }
  else if (v11 == CFURLGetTypeID())
  {
    PDFDocumentPrintf(a1[1], (uint64_t)"%U", v37, v38, v39, v40, v41, v42, (uint64_t)cf);
  }
  else if (v11 == CFStringGetTypeID())
  {
    write_string((uint64_t)a1, cf);
  }
  else if (v11 == CFDataGetTypeID())
  {
    write_data((uint64_t)a1, cf);
  }
  else
  {
    if (_block_invoke_once_6280 != -1)
      dispatch_once(&_block_invoke_once_6280, &__block_literal_global_4_6281);
    if (v11 == CGContainerGetTypeID_container_type_id)
    {
      if (cf)
      {
        v55 = *(_OWORD *)&cf[1].isa;
        v70[0] = *(_OWORD *)&cf->data;
        v70[1] = v55;
        PDFDocumentPrintf(a1[1], (uint64_t)"%r", v49, v50, v51, v52, v53, v54, (uint64_t)v70);
      }
    }
    else if (v11 == CFArrayGetTypeID())
    {
      write_array((uint64_t)a1, (const __CFArray *)cf, v56, v57, v58, v59, v60, v61, a9);
    }
    else if (v11 == CFDictionaryGetTypeID())
    {
      write_dictionary(a1, (const __CFDictionary *)cf, v62, v63, v64, v65, v66, v67, a9);
    }
  }
}

void write_string(uint64_t a1, CFStringRef theString)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *DestinationSet;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *Destination;
  uint64_t v24;
  const void *ObjectNumberForPageNumber;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  SInt32 IntValue;
  CFRange v33;
  CFRange v34;
  CFRange v35;

  if (!CFStringHasPrefix(theString, CFSTR("/")))
  {
    PDFDocumentPrintf(*(_QWORD *)(a1 + 8), (uint64_t)"%T", v4, v5, v6, v7, v8, v9, (uint64_t)theString);
    return;
  }
  if (CFStringHasPrefix(theString, CFSTR("//")))
  {
    v33.length = CFStringGetLength(theString) - 1;
    v33.location = 1;
    v10 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, v33);
    PDFDocumentPrintf(*(_QWORD *)(a1 + 8), (uint64_t)"%T", v11, v12, v13, v14, v15, v16, (uint64_t)v10);
LABEL_14:
    CFRelease(v10);
    return;
  }
  if (CFStringHasPrefix(theString, CFSTR("/>")))
  {
    v34.length = CFStringGetLength(theString) - 2;
    v34.location = 2;
    v10 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, v34);
    DestinationSet = PDFDocumentGetDestinationSet(*(_QWORD *)(a1 + 8));
    Destination = PDFDestinationSetGetDestination(DestinationSet, v10);
    v24 = *(_QWORD *)(a1 + 8);
    if (Destination)
    {
      ObjectNumberForPageNumber = (const void *)Destination[1];
LABEL_13:
      PDFDocumentPrintReference(v24, (uint64_t)"%R", (uint64_t)ObjectNumberForPageNumber, v18, v19, v20, v21, v22);
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  if (CFStringHasPrefix(theString, CFSTR("/#")))
  {
    v35.length = CFStringGetLength(theString) - 2;
    v35.location = 2;
    v10 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, v35);
    IntValue = CFStringGetIntValue(v10);
    v24 = *(_QWORD *)(a1 + 8);
    if (v24 && *(_QWORD *)(v24 + 456))
    {
      ObjectNumberForPageNumber = PDFPageTree::getObjectNumberForPageNumber(*(CFDictionaryRef **)(v24 + 456), (const void *)IntValue);
      v24 = *(_QWORD *)(a1 + 8);
      goto LABEL_13;
    }
LABEL_12:
    ObjectNumberForPageNumber = 0;
    goto LABEL_13;
  }
  PDFDocumentPrintf(*(_QWORD *)(a1 + 8), (uint64_t)"%/", v26, v27, v28, v29, v30, v31, (uint64_t)theString);
}

void write_data(uint64_t a1, const void *a2)
{
  const void *Value;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v29;
  uint64_t v30;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value)
    _CGHandleAssert("write_data", 228, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/Annotations/PDFMetaSet.c", "objectNumber != PDFObjectNumberInvalid", "invalid PDF object %lu", v5, v6, v7, 0);
  v8 = PDFStreamCreateWithObjectNumber(*(_QWORD *)(a1 + 8), (uint64_t)Value);
  PDFDocumentBeginObject(*v8, v8[1], v9, v10, v11, v12, v13, v14);
  PDFDocumentPrintf(*v8, (uint64_t)"<<", v15, v16, v17, v18, v19, v20, v29);
  PDFDocumentPrintf(*(_QWORD *)(a1 + 8), (uint64_t)"/Type /Data", v21, v22, v23, v24, v25, v26, v30);
  PDFStreamBeginData((CGDataConsumerRef)v8);
  BytePtr = CFDataGetBytePtr((CFDataRef)a2);
  Length = CFDataGetLength((CFDataRef)a2);
  CGDataConsumerPutBytes(v8[3], (uint64_t)BytePtr, Length);
  PDFStreamEndData(v8);
  PDFStreamEnd((CFDataRef *)v8);
  PDFStreamRelease((uint64_t)v8);
}

void write_array(uint64_t a1, const __CFArray *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFIndex Count;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v21;

  PDFDocumentPrintf(*(_QWORD *)(a1 + 8), (uint64_t)"[", a3, a4, a5, a6, a7, a8, v21);
  Count = CFArrayGetCount(a2);
  if (Count)
  {
    v18 = Count;
    for (i = 0; i != v18; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      write_object_or_reference(a1, ValueAtIndex);
    }
  }
  PDFDocumentPrintf(*(_QWORD *)(a1 + 8), (uint64_t)"]", v12, v13, v14, v15, v16, v17, a9);
}

void write_dictionary(uint64_t *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  PDFDocumentPrintf(a1[1], (uint64_t)"<<", a3, a4, a5, a6, a7, a8, v17);
  CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)write_dictionary_entry, a1);
  PDFDocumentPrintf(a1[1], (uint64_t)">>", v11, v12, v13, v14, v15, v16, a9);
}

void write_object_or_reference(uint64_t a1, __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  const void *Value;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeID v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    PDFDocumentPrintReference(*(_QWORD *)(a1 + 8), (uint64_t)"%R", (uint64_t)Value, v12, v13, v14, v15, v16);
    return;
  }
  v17 = CFGetTypeID(a2);
  if (v17 != CFDictionaryGetTypeID() && v17 != CFURLGetTypeID() && v17 != CFDataGetTypeID())
  {
    if (_ZZZ22CGDisplayListGetTypeIDEUb_E4once != -1)
      dispatch_once(&_ZZZ22CGDisplayListGetTypeIDEUb_E4once, &__block_literal_global_124_14047);
    if (v17 != CGDisplayListGetTypeID::display_list2_type_id)
    {
      write_object((uint64_t *)a1, a2, v18, v19, v20, v21, v22, v23, a9);
      return;
    }
    v24 = *((_QWORD *)PDFDocumentAddFormWithDisplayList(*(_QWORD *)(a1 + 8), a2) + 2);
    if (v24)
      v25 = *(const void **)(v24 + 8);
    else
      v25 = 0;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, v25);
  }
  write_object_reference(a1, a2);
}

void write_object_reference(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *Value;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value)
  {
    Value = (const void *)PDFXRefTableAddObject(*(_QWORD **)(*(_QWORD *)(a1 + 8) + 464));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, Value);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  }
  PDFDocumentPrintReference(*(_QWORD *)(a1 + 8), (uint64_t)"%R", (uint64_t)Value, v4, v5, v6, v7, v8);
}

void resample_filter_float(_DWORD *a1, unsigned int a2, int a3, double *a4, unsigned int a5, double a6, double a7)
{
  int v7;
  double v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  double v17;
  __double2 v18;
  int v19;
  double v20;
  int v21;
  double v22;
  double v23;
  double v24;
  int v25;
  _BOOL4 v26;
  int v27;
  double sinval;
  double cosval;
  __double2 v30;
  double v31;
  int v32;
  double *v33;
  double v34;
  double v35;
  float *v36;
  float v37;
  double *v38;
  int v39;
  float *v40;
  double v41;
  double v42;
  float v43;
  float v44;
  double v45;
  float __pattern4;

  v7 = a3;
  if (a7 == 0.0 || (v12 = fabs(a7), v12 >= INFINITY) && v12 <= INFINITY)
  {
    if (a5 >= a2)
      v13 = a2;
    else
      v13 = a5;
    if (a7 == 0.0)
      v14 = v13;
    else
      v14 = 1;
    __pattern4 = 1.0 / (float)v14;
    if (a3)
    {
      v15 = 4 * a2 + 8;
      do
      {
        *a1 = 0;
        a1[1] = v14;
        memset_pattern4(a1 + 2, &__pattern4, 4 * v14);
        if (a2 > v14)
          bzero(&a1[v14 + 2], 4 * (a2 - v14));
        a1 = (_DWORD *)((char *)a1 + v15);
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v17 = fmin(a7, 1.0);
    v18 = __sincos_stret(v17 * 1.57079633);
    if (v7)
    {
      v45 = 1.0 / a7;
      do
      {
        v19 = vcvtmd_s64_f64(a6);
        v20 = v17 * ((double)v19 - a6);
        v21 = (int)((v20 + 2.0) / v17);
        v22 = v20 - (double)v21 * v17;
        v23 = -0.0;
        if (v22 <= -2.0)
          v23 = v17;
        v24 = v22 + v23;
        v25 = (int)((2.0 - (v22 + v23)) / v17);
        v26 = v22 <= -2.0;
        if (v22 + v23 + (double)v25 * v17 < 2.0)
          ++v25;
        if (v25 >= (int)a2)
          v27 = a2;
        else
          v27 = v25;
        if (v27)
        {
          v30 = __sincos_stret(v24 * 1.57079633);
          cosval = v30.__cosval;
          sinval = v30.__sinval;
          v31 = 0.0;
          v32 = v27;
          v33 = a4;
          do
          {
            v34 = 1.0;
            if (fabs(v24) >= v17 * 0.5)
              v34 = sinval * sinval * cosval / (v24 * v24 * 1.57079633 * 1.57079633);
            *v33++ = v34;
            v31 = v31 + v34;
            v24 = v17 + v24;
            v35 = v18.__sinval * cosval;
            cosval = cosval * v18.__cosval - sinval * v18.__sinval;
            sinval = v35 + sinval * v18.__cosval;
            --v32;
          }
          while (v32);
          *a1 = v19 - v21 + v26;
          a1[1] = v27;
          v36 = (float *)(a1 + 2);
          v37 = 0.0;
          v38 = a4;
          v39 = v27;
          v40 = (float *)(a1 + 2);
          v41 = 1.0 / v31;
          do
          {
            v42 = *v38++;
            v43 = v41 * v42;
            *v40++ = v43;
            v37 = v37 + v43;
            --v39;
          }
          while (v39);
        }
        else
        {
          *(_QWORD *)a1 = (v19 - v21 + v26);
          v36 = (float *)(a1 + 2);
          v37 = 0.0;
          v40 = (float *)(a1 + 2);
        }
        v44 = v37 + -1.0;
        if (v44 != 0.0)
          resample_kernel_float_normalize(v36, v27, -v44);
        if ((int)(a2 - v27) >= 1)
          bzero(v40, 4 * (~v27 + a2) + 4);
        a6 = v45 + a6;
        a1 += a2 + 2;
        --v7;
      }
      while (v7);
    }
  }
}

void resample_filter_linear_float(uint64_t a1, unsigned int a2, int a3, double *a4, unsigned int a5, double a6, double a7)
{
  int v7;
  double v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  int v18;
  uint64_t v19;
  size_t v20;
  unsigned int v21;
  double v22;
  _BOOL4 v23;
  double v24;
  double v25;
  float v26;
  double v28;
  uint64_t v29;
  double v30;
  unsigned int v31;
  double v32;
  int v33;
  double *v34;
  int v35;
  uint64_t v36;
  double v37;
  float *v38;
  float v39;
  double v40;
  float v41;
  float __pattern4;

  v7 = a3;
  if (a7 == 0.0 || (v11 = fabs(a7), v11 >= INFINITY) && v11 <= INFINITY)
  {
    if (a5 >= a2)
      v12 = a2;
    else
      v12 = a5;
    if (a7 == 0.0)
      v13 = v12;
    else
      v13 = 1;
    __pattern4 = 1.0 / (float)v13;
    if (a3)
    {
      v14 = 4 * a2 + 8;
      do
      {
        *(_DWORD *)a1 = 0;
        *(_DWORD *)(a1 + 4) = v13;
        memset_pattern4((void *)(a1 + 8), &__pattern4, 4 * v13);
        if (a2 > v13)
          bzero((void *)(a1 + 8 + 4 * v13), 4 * (a2 - v13));
        a1 += v14;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    v15 = 1.0 / a7;
    v16 = 1.0 / a7 * 0.5;
    if (a7 <= 1.0)
    {
      if (a3)
      {
        v28 = v16 + a6;
        v29 = 4 * a2 + 8;
        do
        {
          v30 = (floor(v28 - v16) - (v28 - v16) + 1.0) * a7;
          v31 = vcvtmd_s64_f64(v28 - v16);
          if (v30 <= 1.0)
          {
            v33 = 0;
            v32 = 1.0;
            v34 = a4;
            do
            {
              *v34++ = v30;
              v32 = v32 - v30;
              ++v33;
              v30 = a7;
            }
            while (v32 >= a7);
          }
          else
          {
            v32 = 1.0;
            v33 = 0;
            v34 = a4;
          }
          *v34 = v32;
          v35 = v33 + 1;
          v36 = 0;
          *(_DWORD *)a1 = v31;
          *(_DWORD *)(a1 + 4) = v35;
          v37 = 0.0;
          v38 = (float *)(a1 + 8);
          do
          {
            v39 = a4[v36];
            *v38++ = v39;
            v37 = v37 + v39;
            ++v36;
          }
          while (v35 != (_DWORD)v36);
          v40 = v37 + -1.0;
          if (v40 != 0.0)
          {
            v41 = v40;
            resample_kernel_float_normalize((float *)(a1 + 8), v35, -v41);
          }
          if ((int)(a2 - v35) >= 1)
            bzero(v38, 4 * (~v35 + a2) + 4);
          v28 = v15 + v28;
          a1 += v29;
          --v7;
        }
        while (v7);
      }
    }
    else if (a3)
    {
      v17 = v16 + a6;
      v18 = a2 - 2;
      v19 = 4 * a2 + 8;
      v20 = 4 * (a2 - 2);
      do
      {
        v21 = vcvtmd_s64_f64(v17);
        v22 = v17 - floor(v17);
        v23 = v22 < 0.5;
        if (v22 >= 0.5)
          v24 = -0.5;
        else
          v24 = 0.5;
        v25 = v22 + v24;
        v26 = v25;
        *(float *)&v25 = 1.0 - v25;
        *(_DWORD *)(a1 + 8) = LODWORD(v25);
        *(float *)(a1 + 12) = v26;
        *(_DWORD *)a1 = v21 - v23;
        *(_DWORD *)(a1 + 4) = 2;
        if (v18 >= 1)
          bzero((void *)(a1 + 16), v20);
        v17 = v15 + v17;
        a1 += v19;
        --v7;
      }
      while (v7);
    }
  }
}

void resample_filter_float_normalize(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  int v5;
  _DWORD *v6;
  uint64_t v7;
  int v8;
  int *v9;
  int v10;
  uint64_t v11;
  int v12;
  _DWORD *v13;
  unsigned int v14;
  float v15;
  float *v16;
  float v17;
  uint64_t v19;
  void *v20;
  _DWORD *v21;
  int v22;
  int v23;
  int v24;
  float *v25;
  float v26;
  int v27;
  _DWORD *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  void *v34;

  v5 = a3;
  v6 = a1;
  v7 = 4 * a2 + 8;
  v8 = a3;
  v9 = a1;
  do
  {
    v10 = *v9;
    if ((*v9 & 0x80000000) == 0)
      break;
    --v8;
    v11 = v10;
    v12 = v9[1] + v10;
    *v9 = 0;
    v9[1] = v12;
    v13 = v9 + 2;
    v14 = ~v10;
    v15 = 0.0;
    v16 = (float *)(v9 + 2);
    do
    {
      v17 = *v16++;
      v15 = v15 + v17;
    }
    while (!__CFADD__(v10++, 1));
    *(float *)&v9[v14 + 3] = v15 + *(float *)&v9[v14 + 3];
    if (v12)
    {
      v19 = -1 * v11;
      do
      {
        v20 = v13 + 1;
        *v13 = v13[v19];
        ++v13;
        --v12;
      }
      while (v12);
    }
    else
    {
      v20 = v9 + 2;
    }
    bzero(v20, 4 * v14 + 4);
    v9 = (int *)((char *)v9 + v7);
  }
  while (v8);
  v21 = (_DWORD *)((char *)v6 + v7 * (v5 - 1));
  v22 = v5;
  do
  {
    v23 = v21[1];
    v24 = *v21 - a4 + v23;
    if (v24 < 1)
      break;
    --v22;
    v21[1] = a4 - *v21;
    v25 = (float *)&v21[v23 + 1];
    v26 = 0.0;
    do
    {
      v26 = v26 + *v25;
      *v25-- = 0.0;
      --v24;
    }
    while (v24);
    *v25 = v26 + *v25;
    v21 = (_DWORD *)((char *)v21 - v7);
  }
  while (v22);
  do
  {
    v27 = v6[1];
    if (v27)
    {
      v28 = v6 + 2;
      v29 = 4 * (v27 - 1) + 8;
      while (*(float *)((char *)v6 + v29) == 0.0)
      {
        v29 -= 4;
        if (!--v27)
          goto LABEL_33;
      }
      v30 = 0;
      v31 = 2;
      while (*(float *)&v6[v31] == 0.0)
      {
        ++v30;
        ++v31;
        if (v27 == v30)
        {
          v30 = v27;
          break;
        }
      }
      if (v30)
      {
        v32 = v27 - v30;
        if (v27 == v30)
        {
          v34 = v6 + 2;
        }
        else
        {
          v33 = v30;
          do
          {
            v34 = v28 + 1;
            *v28 = v28[v30];
            ++v33;
            ++v28;
          }
          while (v27 != v33);
        }
        *v6 += v30;
        bzero(v34, 4 * (v30 - 1) + 4);
        v27 = v32;
      }
    }
LABEL_33:
    v6[1] = v27;
    v6 = (_DWORD *)((char *)v6 + v7);
    --v5;
  }
  while (v5);
}

float resample_kernel_float_normalize(float *a1, int a2, float result)
{
  int v3;
  float v4;
  float *v5;
  float *v6;
  float v7;
  int v8;
  float *v9;
  int v10;

  if (a2)
  {
    v3 = 0;
    v4 = 0.0;
    v5 = a1;
LABEL_3:
    --a2;
    v6 = v5;
    do
    {
      if (v4 < *v6)
      {
        v5 = v6 + 1;
        v3 = 1;
        v4 = *v6;
        a1 = v6;
        if (a2)
          goto LABEL_3;
        goto LABEL_12;
      }
      if (v4 == *v6)
        ++v3;
      ++v6;
      --a2;
    }
    while (a2 != -1);
    v6 = a1;
    if (!v3)
      return result;
LABEL_12:
    v7 = result / (float)v3;
    if (v7 != 0.0)
    {
      v8 = v3;
      v9 = v6;
      do
      {
        *v9 = v7 + *v9;
        ++v9;
        --v8;
      }
      while (v8);
      result = result - (float)(v7 * (float)v3);
    }
    v10 = v3 >> 1;
    result = result + v6[v10];
    v6[v10] = result;
  }
  return result;
}

double gstate_init(uint64_t a1)
{
  CGColorSpace *DeviceGray;
  CGColorSpace *v3;
  double result;

  *(_OWORD *)(a1 + 104) = *(_OWORD *)&CGAffineTransformIdentity.a;
  *(_QWORD *)(a1 + 48) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 80) = 2;
  *(_QWORD *)(a1 + 64) = 0x4024000000000000;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&CGAffineTransformIdentity.c;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)&CGAffineTransformIdentity.tx;
  DeviceGray = CGColorSpaceCreateDeviceGray();
  v3 = CGColorSpaceCopyDefaultColor((uint64_t)DeviceGray);
  CGColorSpaceRelease(DeviceGray);
  if (v3)
  {
    CFRetain(v3);
    *(_QWORD *)(a1 + 152) = v3;
    CFRetain(v3);
    *(_QWORD *)(a1 + 160) = v3;
    CFRelease(v3);
  }
  else
  {
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 160) = 0;
  }
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  *(_DWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_OWORD *)(a1 + 220) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_DWORD *)(a1 + 248) = 2;
  return result;
}

void gstate_clear(uint64_t a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = *(unsigned int **)(a1 + 72);
  if (v2)
  {
    do
    {
      v3 = __ldxr(v2);
      v4 = v3 - 1;
    }
    while (__stxr(v4, v2));
    if (!v4)
      free(v2);
  }
  v5 = *(const void **)(a1 + 152);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 160);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 192);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 240);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 208);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 216);
  if (v10)
    CFRelease(v10);
  PDFClipMaskRelease(*(unsigned int ***)(a1 + 232));
  CGClipStackRelease(*(void **)(a1 + 256));
}

void PDFGStateReset(uint64_t a1)
{
  if (a1)
  {
    gstate_clear(a1);
    gstate_init(a1);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 40));
    addEmitFunction(a1, write_gstate_reset);
  }
}

void write_gstate_reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  PDFWriterAnnotate(*(_QWORD *)(a1 + 16), (uint64_t)"  BEGIN: resetting gstate.", a3, a4, a5, a6, a7, a8, v22);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"Q q", v10, v11, v12, v13, v14, v15, v23);
  PDFWriterAnnotate(*(_QWORD *)(a1 + 16), (uint64_t)"  END: resetting gstate.", v16, v17, v18, v19, v20, v21, a9);
}

void addEmitFunction(uint64_t a1, const void *a2)
{
  CFIndex FirstIndexOfValue;
  CFRange v5;

  v5.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  v5.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 40), v5, a2);
  if (FirstIndexOfValue != -1)
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 40), FirstIndexOfValue);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), a2);
}

void PDFGStateEmit(CFArrayRef *a1)
{
  CFRange v2;

  v2.length = CFArrayGetCount(a1[5]);
  v2.location = 0;
  CFArrayApplyFunction(a1[5], v2, (CFArrayApplierFunction)emit, a1);
  CFArrayRemoveAllValues(a1[5]);
}

uint64_t emit(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void emitLineWidthChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%f w", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 48));
}

void emitLineCapChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%d J", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 56));
}

void emitLineJoinChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%d j", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 60));
}

void emitMiterLimitChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%f M", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 64));
}

void PDFGStateSetLineDash(uint64_t a1, unsigned int *a2)
{
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v4 = *(unsigned int **)(a1 + 72);
  if (!CGDashEqualToDash((uint64_t)v4, (uint64_t)a2))
  {
    if (v4)
    {
      do
      {
        v5 = __ldxr(v4);
        v6 = v5 - 1;
      }
      while (__stxr(v6, v4));
      if (!v6)
        free(v4);
    }
    if (a2)
    {
      do
        v7 = __ldxr(a2);
      while (__stxr(v7 + 1, a2));
    }
    *(_QWORD *)(a1 + 72) = a2;
    addEmitFunction(a1, emitLineDashChange);
  }
}

void emitLineDashChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t *v10;
  uint64_t v11;
  _BYTE **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v10 = *(uint64_t **)(a1 + 72);
  if (!v10)
  {
    v12 = *(_BYTE ***)(a1 + 16);
    goto LABEL_7;
  }
  v11 = v10[2];
  v12 = *(_BYTE ***)(a1 + 16);
  if (!v11)
  {
LABEL_7:
    PDFWriterPrintf(v12, (uint64_t)"[] 0 d", a3, a4, a5, a6, a7, a8, a9);
    return;
  }
  v13 = v10[1];
  v14 = v10 + 3;
  PDFWriterPrintf(v12, (uint64_t)"[", a3, a4, a5, a6, a7, a8, v22);
  do
  {
    v21 = *v14++;
    PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%f", v15, v16, v17, v18, v19, v20, v21);
    --v11;
  }
  while (v11);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"] %f d", v15, v16, v17, v18, v19, v20, v13);
}

void emitRenderingIntentChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v9;

  v9 = *(_DWORD *)(a1 + 80) - 1;
  if (v9 <= 3)
    PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)off_1E1647C88[v9], a3, a4, a5, a6, a7, a8, a9);
}

void emitFlatnessChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%f i", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 88));
}

void emitStrokeAdjustChange(uint64_t a1)
{
  emitEStateWithBool(a1, "SA", *(_BYTE *)(a1 + 96));
}

void emitEStateWithBool(uint64_t a1, const char *a2, char a3)
{
  uint64_t v4;
  BOOL v5;
  void *v6;
  void **v9;
  char *v10;
  int v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *value;

  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (v5)
  {
    v6 = 0;
  }
  else
  {
    if (!*(_QWORD *)(v4 + 8))
      *(_QWORD *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v9 = PDFEStateCreate(*(void **)v4, a2);
    v10 = (char *)v9;
    if (v9)
    {
      *((_DWORD *)v9 + 11) = 0;
      *((_BYTE *)v9 + 48) = a3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v9, (const void **)&value))
    {
      v11 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v11;
      snprintf_l(v10 + 24, 0x10uLL, 0, "Gs%u", v11);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v10);
      value = v10;
    }
    PDFEStateRelease((void **)v10);
    v12 = *(const void ***)(v4 + 16);
    if (!v12)
    {
      v12 = CGOrderedSetCreate();
      *(_QWORD *)(v4 + 16) = v12;
    }
    CGOrderedSetAddValue((CFSetRef *)v12, value);
    v6 = value;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v6);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v13, v14, v15, v16, v17, v18, (uint64_t)v6 + 24);
}

void PDFGStateSetFillColor(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGColorSpace *ColorSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  PDFDocumentPrivate *v20;
  unint64_t v21;
  const void *v22;

  if (!CGColorEqualToColor(*(CGColorRef *)(a1 + 152), (CGColorRef)a2))
  {
    v11 = *(_QWORD *)(a1 + 8);
    if (a2)
    {
      if ((a2 & 0x8000000000000000) != 0)
        ColorSpace = CGTaggedColorGetColorSpace(a2, v4, v5, v6, v7, v8, v9, v10);
      else
        ColorSpace = *(CGColorSpace **)(a2 + 24);
    }
    else
    {
      ColorSpace = 0;
    }
    v20 = PDFDocumentResolveColorSpace(v11, ColorSpace);
    v21 = *(_QWORD *)(a1 + 152);
    if (v21)
    {
      if ((v21 & 0x8000000000000000) != 0)
        v21 = (unint64_t)CGTaggedColorGetColorSpace(v21, v13, v14, v15, v16, v17, v18, v19);
      else
        v21 = *(_QWORD *)(v21 + 24);
    }
    if ((PDFDocumentPrivate *)v21 != v20)
      addEmitFunction(a1, emitFillColorSpaceChange);
    v22 = *(const void **)(a1 + 152);
    if (v22)
      CFRelease(v22);
    if (a2)
      CFRetain((CFTypeRef)a2);
    *(_QWORD *)(a1 + 152) = a2;
    addEmitFunction(a1, emitFillColorChange);
  }
}

void emitFillColorSpaceChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  emitColorSpace(a1, 1, a3, a4, a5, a6, a7, a8, a9);
}

void emitFillColorChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t ColorSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  ColorSpace = *(_QWORD *)(a1 + 152);
  if (ColorSpace)
  {
    if ((ColorSpace & 0x8000000000000000) != 0)
      ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, a2, a3, a4, a5, a6, a7, a8);
    else
      ColorSpace = *(_QWORD *)(ColorSpace + 24);
  }
  if (CGColorSpaceGetType((_QWORD *)ColorSpace) == 9)
    emitPattern(a1, 1);
  else
    emitColor(a1, 1, v11, v12, v13, v14, v15, v16, a9);
}

void emitColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9;
  uint64_t v11;
  unint64_t v12;
  uint64_t NumberOfComponents;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const CGFloat *v20;
  uint64_t v21;
  const CGFloat *Components;
  uint64_t v23;
  uint64_t v24;
  CGColorSpace *ColorSpace;
  PDFDocumentPrivate *v26;
  int Type;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _BYTE **v34;
  const char *v35;
  const char *v36;
  uint64_t v37;

  v9 = a2;
  v11 = 160;
  if ((_DWORD)a2)
    v11 = 152;
  v12 = *(_QWORD *)(a1 + v11);
  if (v12)
  {
    if ((v12 & 0x8000000000000000) != 0)
      NumberOfComponents = CGTaggedColorGetNumberOfComponents(*(_QWORD *)(a1 + v11), a2, a3, a4, a5, a6, a7, a8);
    else
      NumberOfComponents = *(_QWORD *)(v12 + 56);
    Components = CGColorGetComponents((CGColorRef)v12);
    v21 = NumberOfComponents - 1;
    if (NumberOfComponents == 1)
      goto LABEL_12;
    v20 = Components;
  }
  else
  {
    v20 = CGColorGetComponents(0);
    v21 = -1;
  }
  do
  {
    v24 = *(_QWORD *)v20++;
    PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%f", v14, v15, v16, v17, v18, v19, v24);
    --v21;
  }
  while (v21);
  if (v12)
  {
LABEL_12:
    if ((v12 & 0x8000000000000000) != 0)
      ColorSpace = CGTaggedColorGetColorSpace(v12, v23, v14, v15, v16, v17, v18, v19);
    else
      ColorSpace = *(CGColorSpace **)(v12 + 24);
    goto LABEL_16;
  }
  ColorSpace = 0;
LABEL_16:
  v26 = PDFDocumentResolveColorSpace(*(_QWORD *)(a1 + 8), ColorSpace);
  Type = CGColorSpaceGetType(v26);
  if (Type == 2)
  {
    v34 = *(_BYTE ***)(a1 + 16);
    v35 = "K";
    v36 = "k";
  }
  else if (Type == 1)
  {
    v34 = *(_BYTE ***)(a1 + 16);
    v35 = "RG";
    v36 = "rg";
  }
  else if (Type)
  {
    v34 = *(_BYTE ***)(a1 + 16);
    v35 = "SC";
    v36 = "sc";
  }
  else
  {
    v34 = *(_BYTE ***)(a1 + 16);
    v35 = "G";
    v36 = "g";
  }
  if (v9)
    v37 = (uint64_t)v36;
  else
    v37 = (uint64_t)v35;
  PDFWriterPrintf(v34, v37, v28, v29, v30, v31, v32, v33, a9);
}

void emitPattern(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  void *v8;
  BOOL v9;
  _QWORD *Value;
  const __CFDictionary *Mutable;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void **v21;
  uint64_t v22;
  const void **v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  const CGFloat *Components;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t key;
  __int128 v47;
  __int128 v48;
  __int128 v49;

  v4 = 160;
  if (a2)
    v4 = 152;
  v5 = *(_QWORD *)(a1 + v4);
  if (v5 < 1)
    v6 = 0;
  else
    v6 = *(_DWORD **)(v5 + 32);
  v7 = *(_QWORD *)(a1 + 8);
  v43 = *(_OWORD *)(a1 + 104);
  v44 = *(_OWORD *)(a1 + 120);
  v45 = *(_OWORD *)(a1 + 136);
  v8 = *(void **)(v7 + 376);
  if (!v8)
  {
    v8 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v8)
      *(_QWORD *)v8 = v7;
    *(_QWORD *)(v7 + 376) = v8;
  }
  if (v8)
    v9 = v6 == 0;
  else
    v9 = 1;
  if (v9)
  {
    Value = 0;
  }
  else
  {
    Mutable = (const __CFDictionary *)*((_QWORD *)v8 + 1);
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &patternKeyCallbacks, &patternCallbacks);
      *((_QWORD *)v8 + 1) = Mutable;
    }
    key = 0;
    LODWORD(key) = v6[4];
    v48 = v44;
    v49 = v45;
    v47 = v43;
    Value = CFDictionaryGetValue(Mutable, &key);
    if (!Value)
    {
      v12 = *(_QWORD *)v8;
      v13 = (*((_DWORD *)v8 + 6) + 1);
      *((_DWORD *)v8 + 6) = v13;
      Value = malloc_type_calloc(1uLL, 0x68uLL, 0x33BCE901uLL);
      __CFSetLastAllocationEventName();
      if (Value)
      {
        *(_DWORD *)Value = 1;
        Value[1] = v12;
        Value[2] = PDFContentStreamCreate(v12, 0);
        CFRetain(v6);
        Value[3] = v6;
        *((_OWORD *)Value + 2) = v43;
        *((_OWORD *)Value + 3) = v44;
        *((_OWORD *)Value + 4) = v45;
        snprintf_l((char *)Value + 80, 0x10uLL, 0, "P%lu", v13);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)v8 + 1), &key, Value);
      PDFPatternRelease(Value, v14, v15, v16, v17, v18, v19, v20);
    }
    v21 = (const void **)*((_QWORD *)v8 + 2);
    if (!v21)
    {
      v21 = CGOrderedSetCreate();
      *((_QWORD *)v8 + 2) = v21;
    }
    CGOrderedSetAddValue((CFSetRef *)v21, Value);
  }
  v22 = *(_QWORD *)(a1 + 32);
  v23 = *(const void ***)(v22 + 72);
  if (!v23)
  {
    v23 = CGOrderedSetCreate();
    *(_QWORD *)(v22 + 72) = v23;
  }
  CGOrderedSetAddValue((CFSetRef *)v23, Value);
  if (v5)
  {
    v31 = v5 < 0 ? CGTaggedColorGetNumberOfComponents(v5, v24, v25, v26, v27, v28, v29, v30) : *(_QWORD *)(v5 + 56);
    if (v31 >= 2)
    {
      Components = CGColorGetComponents((CGColorRef)v5);
      v33 = v31 - 1;
      do
      {
        v34 = *(_QWORD *)Components++;
        PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%f", v25, v26, v27, v28, v29, v30, v34);
        --v33;
      }
      while (v33);
    }
  }
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N", v25, v26, v27, v28, v29, v30, (uint64_t)(Value + 10));
  if (a2)
    v41 = "scn";
  else
    v41 = "SCN";
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)v41, v35, v36, v37, v38, v39, v40, v42);
}

void emitColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9;
  uint64_t v11;
  unint64_t v12;
  CGColorSpace *ColorSpace;
  PDFDocumentPrivate *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  PDFDocumentPrivate *v18;
  unsigned int Type;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  const void **v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  const char *v43;
  char v44;

  v9 = a2;
  v11 = 160;
  if ((_DWORD)a2)
    v11 = 152;
  v12 = *(_QWORD *)(a1 + v11);
  if (v12)
  {
    if ((v12 & 0x8000000000000000) != 0)
      ColorSpace = CGTaggedColorGetColorSpace(v12, a2, a3, a4, a5, a6, a7, a8);
    else
      ColorSpace = *(CGColorSpace **)(v12 + 24);
  }
  else
  {
    ColorSpace = 0;
  }
  v14 = PDFDocumentResolveColorSpace(*(_QWORD *)(a1 + 8), ColorSpace);
  if (!v14)
    _CGHandleAssert("emitColorSpace", 471, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/ContentStreams/PDFGState.c", "space != NULL", "PDF document colorspace missing", v15, v16, v17, v44);
  v18 = v14;
  Type = CGColorSpaceGetType(v14);
  if (Type >= 3)
  {
    if (Type == 9 && !*(_QWORD *)(*((_QWORD *)v18 + 3) + 40))
    {
      v43 = "CS";
      if (v9)
        v43 = "cs";
      PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/Pattern %s", v20, v21, v22, v23, v24, v25, (uint64_t)v43);
    }
    else
    {
      v26 = PDFDocumentAddColorSpace(*(_QWORD *)(a1 + 8), v18);
      v27 = *(_QWORD *)(a1 + 32);
      v28 = *(const void ***)(v27 + 32);
      if (!v28)
      {
        v28 = CGOrderedSetCreate();
        *(_QWORD *)(v27 + 32) = v28;
      }
      CGOrderedSetAddValue((CFSetRef *)v28, v26);
      v35 = (uint64_t)v26 + 40;
      if (!v26)
        v35 = 0;
      PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N", v29, v30, v31, v32, v33, v34, v35);
      if (v9)
        v42 = "cs";
      else
        v42 = "CS";
      PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)v42, v36, v37, v38, v39, v40, v41, a9);
    }
  }
}

void PDFGStateSetStrokeColor(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGColorSpace *ColorSpace;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  PDFDocumentPrivate *v20;
  unint64_t v21;
  const void *v22;

  if (!CGColorEqualToColor(*(CGColorRef *)(a1 + 160), (CGColorRef)a2))
  {
    v11 = *(_QWORD *)(a1 + 8);
    if (a2)
    {
      if ((a2 & 0x8000000000000000) != 0)
        ColorSpace = CGTaggedColorGetColorSpace(a2, v4, v5, v6, v7, v8, v9, v10);
      else
        ColorSpace = *(CGColorSpace **)(a2 + 24);
    }
    else
    {
      ColorSpace = 0;
    }
    v20 = PDFDocumentResolveColorSpace(v11, ColorSpace);
    v21 = *(_QWORD *)(a1 + 160);
    if (v21)
    {
      if ((v21 & 0x8000000000000000) != 0)
        v21 = (unint64_t)CGTaggedColorGetColorSpace(v21, v13, v14, v15, v16, v17, v18, v19);
      else
        v21 = *(_QWORD *)(v21 + 24);
    }
    if ((PDFDocumentPrivate *)v21 != v20)
      addEmitFunction(a1, emitStrokeColorSpaceChange);
    v22 = *(const void **)(a1 + 160);
    if (v22)
      CFRelease(v22);
    if (a2)
      CFRetain((CFTypeRef)a2);
    *(_QWORD *)(a1 + 160) = a2;
    addEmitFunction(a1, emitStrokeColorChange);
  }
}

void emitStrokeColorSpaceChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  emitColorSpace(a1, 0, a3, a4, a5, a6, a7, a8, a9);
}

void emitStrokeColorChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t ColorSpace;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  ColorSpace = *(_QWORD *)(a1 + 160);
  if (ColorSpace)
  {
    if ((ColorSpace & 0x8000000000000000) != 0)
      ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, a2, a3, a4, a5, a6, a7, a8);
    else
      ColorSpace = *(_QWORD *)(ColorSpace + 24);
  }
  if (CGColorSpaceGetType((_QWORD *)ColorSpace) == 9)
    emitPattern(a1, 0);
  else
    emitColor(a1, 0, v11, v12, v13, v14, v15, v16, a9);
}

void PDFGStateSetPatternMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  int8x16_t v11;
  float64x2_t v12;
  int8x16_t v13;
  float64x2_t v14;
  __int128 v15;
  unint64_t ColorSpace;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;

  v11 = *(int8x16_t *)a2;
  v12 = *(float64x2_t *)(a2 + 16);
  v13 = (int8x16_t)vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 32), *(float64x2_t *)a2, a9), v12, a10);
  *(int8x16_t *)(a2 + 32) = v13;
  if (*(double *)(a1 + 104) != *(double *)v11.i64
    || (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 112), (float64x2_t)vextq_s8(v11, (int8x16_t)v12, 8uLL)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 128), (float64x2_t)vextq_s8((int8x16_t)v12, v13, 8uLL)))), 0xFuLL))) & 1) == 0|| *(double *)(a1 + 144) != *(double *)&v13.i64[1])
  {
    v14 = *(float64x2_t *)a2;
    v15 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 136) = v15;
    *(float64x2_t *)(a1 + 104) = v14;
    ColorSpace = *(_QWORD *)(a1 + 152);
    if (ColorSpace)
    {
      if ((ColorSpace & 0x8000000000000000) != 0)
        ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, a2, a3, a4, a5, a6, a7, a8);
      else
        ColorSpace = *(_QWORD *)(ColorSpace + 24);
    }
    if (CGColorSpaceGetType((_QWORD *)ColorSpace) == 9)
      addEmitFunction(a1, emitFillColorChange);
    v24 = *(_QWORD *)(a1 + 160);
    if (v24)
    {
      if ((v24 & 0x8000000000000000) != 0)
        v24 = (unint64_t)CGTaggedColorGetColorSpace(v24, v17, v18, v19, v20, v21, v22, v23);
      else
        v24 = *(_QWORD *)(v24 + 24);
    }
    if (CGColorSpaceGetType((_QWORD *)v24) == 9)
      addEmitFunction(a1, emitStrokeColorChange);
  }
}

void emitNonStrokeAlphaChange(uint64_t a1)
{
  uint64_t v1;
  int v2;
  _DWORD *v3;
  int v4;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_DWORD *)(v1 + 4);
  if (v2 <= 0)
  {
    *(_DWORD *)(v1 + 4) = 1;
    v3 = (_DWORD *)(v1 + 8);
LABEL_6:
    *v3 = 4;
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    v4 = *(_DWORD *)(v1 + 8);
    v3 = (_DWORD *)(v1 + 8);
    if (v4 <= 3)
      goto LABEL_6;
  }
LABEL_7:
  emitEStateWithReal(a1, "ca", *(double *)(a1 + 168));
}

void emitEStateWithReal(uint64_t a1, const char *a2, double a3)
{
  uint64_t v4;
  BOOL v5;
  void *v6;
  void **v9;
  char *v10;
  int v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *value;

  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (v5)
  {
    v6 = 0;
  }
  else
  {
    if (!*(_QWORD *)(v4 + 8))
      *(_QWORD *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v9 = PDFEStateCreate(*(void **)v4, a2);
    v10 = (char *)v9;
    if (v9)
    {
      *((_DWORD *)v9 + 11) = 2;
      *((double *)v9 + 6) = floor(a3 * 10000.0 + 0.5) / 10000.0;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v9, (const void **)&value))
    {
      v11 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v11;
      snprintf_l(v10 + 24, 0x10uLL, 0, "Gs%u", v11);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v10);
      value = v10;
    }
    PDFEStateRelease((void **)v10);
    v12 = *(const void ***)(v4 + 16);
    if (!v12)
    {
      v12 = CGOrderedSetCreate();
      *(_QWORD *)(v4 + 16) = v12;
    }
    CGOrderedSetAddValue((CFSetRef *)v12, value);
    v6 = value;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v6);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v13, v14, v15, v16, v17, v18, (uint64_t)v6 + 24);
}

void emitStrokeAlphaChange(uint64_t a1)
{
  uint64_t v1;
  int v2;
  _DWORD *v3;
  int v4;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_DWORD *)(v1 + 4);
  if (v2 <= 0)
  {
    *(_DWORD *)(v1 + 4) = 1;
    v3 = (_DWORD *)(v1 + 8);
LABEL_6:
    *v3 = 4;
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    v4 = *(_DWORD *)(v1 + 8);
    v3 = (_DWORD *)(v1 + 8);
    if (v4 <= 3)
      goto LABEL_6;
  }
LABEL_7:
  emitEStateWithReal(a1, "CA", *(double *)(a1 + 176));
}

void emitTextDrawingModeChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%d Tr", a3, a4, a5, a6, a7, a8, *(unsigned int *)(a1 + 184));
}

void PDFGStateSetStyle(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const void *v4;

  v2 = a2;
  v4 = *(const void **)(a1 + 192);
  if (!CGStyleEqualToStyle((uint64_t)v4, a2))
  {
    if (v4)
      CFRelease(v4);
    if (v2)
    {
      if (*(_DWORD *)(v2 + 20) == 1 && *(double *)(v2 + 40) == 45.0 && *(double *)(v2 + 80) == 1.0)
        CFRetain((CFTypeRef)v2);
      else
        v2 = 0;
    }
    *(_QWORD *)(a1 + 192) = v2;
    addEmitFunction(a1, emitStyleChange);
  }
}

void emitStyleChange(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  void **v4;
  void **v5;
  int v6;
  const void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *value;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = *(const void **)(a1 + 192);
    if (!*(_QWORD *)(v2 + 8))
      *(_QWORD *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v4 = PDFEStateCreate(*(void **)v2, "AAPL:ST");
    v5 = v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 5;
      if (v3)
        CFRetain(v3);
      v5[6] = (void *)v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v5, (const void **)&value))
    {
      v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l((char *)v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      value = v5;
    }
    PDFEStateRelease(v5);
    v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      v7 = CGOrderedSetCreate();
      *(_QWORD *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    v8 = value;
  }
  else
  {
    v8 = 0;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v8);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void emitNonStrokeOverprintChange(uint64_t a1)
{
  emitEStateWithBool(a1, "op", *(_BYTE *)(a1 + 200));
}

void PDFGStateSetStrokeOverprint(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 201) != a2)
  {
    *(_BYTE *)(a1 + 201) = a2;
    addEmitFunction(a1, emitStrokeOverprintChange);
    if (*(unsigned __int8 *)(a1 + 200) != *(unsigned __int8 *)(a1 + 201))
      addEmitFunction(a1, emitNonStrokeOverprintChange);
  }
}

void emitStrokeOverprintChange(uint64_t a1)
{
  emitEStateWithBool(a1, "OP", *(_BYTE *)(a1 + 201));
}

void PDFGStateSetOverprintMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unint64_t v10;
  CGColorSpace *ColorSpace;
  PDFDocumentPrivate *v12;

  v8 = a2;
  if (!(_DWORD)a2)
    goto LABEL_12;
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 8) + 91))
    goto LABEL_12;
  v10 = *(_QWORD *)(a1 + 152);
  if (!v10)
    goto LABEL_12;
  if ((v10 & 0x8000000000000000) != 0)
  {
    ColorSpace = CGTaggedColorGetColorSpace(v10, a2, a3, a4, a5, a6, a7, a8);
    if (!ColorSpace)
      goto LABEL_12;
  }
  else
  {
    ColorSpace = *(CGColorSpace **)(v10 + 24);
    if (!ColorSpace)
      goto LABEL_12;
  }
  v12 = PDFDocumentResolveColorSpace(*(_QWORD *)(a1 + 8), ColorSpace);
  if (v12 && *(_DWORD *)(*((_QWORD *)v12 + 3) + 24) == 2 && CGColorSpaceGetType(v12) == 6)
    v8 = 0;
LABEL_12:
  if (*(_DWORD *)(a1 + 204) != v8)
  {
    *(_DWORD *)(a1 + 204) = v8;
    addEmitFunction(a1, emitOverprintModeChange);
  }
}

void emitOverprintModeChange(uint64_t a1)
{
  uint64_t v2;
  int v3;
  void **v4;
  char *v5;
  int v6;
  const void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *value;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = *(_DWORD *)(a1 + 204);
    if (!*(_QWORD *)(v2 + 8))
      *(_QWORD *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v4 = PDFEStateCreate(*(void **)v2, "OPM");
    v5 = (char *)v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 1;
      *((_DWORD *)v4 + 12) = v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v4, (const void **)&value))
    {
      v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l(v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      value = v5;
    }
    PDFEStateRelease((void **)v5);
    v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      v7 = CGOrderedSetCreate();
      *(_QWORD *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    v8 = value;
  }
  else
  {
    v8 = 0;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v8);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void PDFGStateSetBlackGeneration(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 208);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
      CFRetain(cf);
    *(_QWORD *)(a1 + 208) = cf;
    addEmitFunction(a1, emitBlackGenerationChange);
  }
}

void emitBlackGenerationChange(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 208);
  if (v1)
    emitEStateWithFunction(a1, "BG", v1);
}

void emitEStateWithFunction(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v4;
  BOOL v5;
  void *v6;
  void **v9;
  void **v10;
  int v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *value;

  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (v5)
  {
    v6 = 0;
  }
  else
  {
    if (!*(_QWORD *)(v4 + 8))
      *(_QWORD *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v9 = PDFEStateCreate(*(void **)v4, a2);
    v10 = v9;
    if (v9)
    {
      *((_DWORD *)v9 + 11) = 4;
      if (a3)
        CFRetain(a3);
      v10[6] = (void *)a3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v10, (const void **)&value))
    {
      v11 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v11;
      snprintf_l((char *)v10 + 24, 0x10uLL, 0, "Gs%u", v11);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v10);
      value = v10;
    }
    PDFEStateRelease(v10);
    v12 = *(const void ***)(v4 + 16);
    if (!v12)
    {
      v12 = CGOrderedSetCreate();
      *(_QWORD *)(v4 + 16) = v12;
    }
    CGOrderedSetAddValue((CFSetRef *)v12, value);
    v6 = value;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v6);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v13, v14, v15, v16, v17, v18, (uint64_t)v6 + 24);
}

void PDFGStateSetUndercolorRemoval(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
      CFRetain(cf);
    *(_QWORD *)(a1 + 216) = cf;
    addEmitFunction(a1, emitUndercolorRemovalChange);
  }
}

void emitUndercolorRemovalChange(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 216);
  if (v1)
    emitEStateWithFunction(a1, "UCR", v1);
}

void emitSmoothnessChange(uint64_t a1)
{
  emitEStateWithReal(a1, "SM", *(double *)(a1 + 224));
}

void emitBlendModeChange(uint64_t a1)
{
  unsigned int v2;
  const char *v3;
  uint64_t v4;
  void **v5;
  void **v6;
  size_t v7;
  char *v8;
  int v9;
  const void **v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *value;

  v2 = *(_DWORD *)(a1 + 248) - 13;
  if (v2 > 0xE)
    v3 = "Normal";
  else
    v3 = off_1E1647CA8[v2];
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    if (!*(_QWORD *)(v4 + 8))
      *(_QWORD *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v5 = PDFEStateCreate(*(void **)v4, "BM");
    v6 = v5;
    if (v5)
    {
      *((_DWORD *)v5 + 11) = 3;
      v7 = strlen(v3);
      v8 = (char *)malloc_type_malloc(v7 + 1, 0x566C45D1uLL);
      __CFSetLastAllocationEventName();
      v6[6] = v8;
      strcpy(v8, v3);
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v6, (const void **)&value))
    {
      v9 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v9;
      snprintf_l((char *)v6 + 24, 0x10uLL, 0, "Gs%u", v9);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v6);
      value = v6;
    }
    PDFEStateRelease(v6);
    v10 = *(const void ***)(v4 + 16);
    if (!v10)
    {
      v10 = CGOrderedSetCreate();
      *(_QWORD *)(v4 + 16) = v10;
    }
    CGOrderedSetAddValue((CFSetRef *)v10, value);
    v11 = value;
  }
  else
  {
    v11 = 0;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v11);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v12, v13, v14, v15, v16, v17, (uint64_t)v11 + 24);
}

void PDFGStateSetSoftMask(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 240);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
      CFRetain(cf);
    *(_QWORD *)(a1 + 240) = cf;
    addEmitFunction(a1, emitSoftMaskChange);
  }
}

void emitSoftMaskChange(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  void **v4;
  void **v5;
  int v6;
  const void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *value;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = *(const void **)(a1 + 240);
    if (!*(_QWORD *)(v2 + 8))
      *(_QWORD *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v4 = PDFEStateCreate(*(void **)v2, "SMask");
    v5 = v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 6;
      if (v3)
        CFRetain(v3);
      v5[6] = (void *)v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v5, (const void **)&value))
    {
      v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l((char *)v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      value = v5;
    }
    PDFEStateRelease(v5);
    v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      v7 = CGOrderedSetCreate();
      *(_QWORD *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    v8 = value;
  }
  else
  {
    v8 = 0;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v8);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void PDFGStateSetClipStack(uint64_t a1, __CFArray *a2)
{
  __CFArray *v2;
  CFMutableArrayRef Mutable;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  const void *v10;
  uint64_t v11;
  uint64_t *v12;
  BOOL v13;
  _DWORD *v14;
  uint64_t v15;
  CFIndex Count;
  CFIndex v17;
  _QWORD *v18;
  CFIndex v19;
  const void *ValueAtIndex;
  unsigned int *v21;
  unsigned int v22;
  const void **v23;
  unsigned int **v24;
  void *value;

  v2 = *(__CFArray **)(a1 + 256);
  if (v2 != a2)
  {
    Mutable = a2;
    v5 = !v2 || a2 == 0;
    if (v5 || *((_DWORD *)v2 + 1) != *((_DWORD *)a2 + 1))
    {
      PDFGStateReset(a1);
      CGClipStackRelease(*(void **)(a1 + 256));
      *(_QWORD *)(a1 + 256) = CGClipStackCreateMutableCopy((uint64_t)Mutable);
      addEmitFunction(a1, emitClipStackChange);
      if (Mutable)
      {
        v6 = *((_QWORD *)Mutable + 15);
        if (v6)
        {
          v7 = 0;
          v8 = (char *)Mutable + 128;
          while (1)
          {
            v9 = (uint64_t)v8;
            if (*((_QWORD *)Mutable + 14) != 3)
              v9 = *((_QWORD *)Mutable + 16) + 8 * v7;
            v10 = *(const void **)v9;
            if (*(_BYTE *)(*(_QWORD *)v9 + 8) == 3)
              break;
            ++v7;
            v8 += 8;
            if (!--v6)
              goto LABEL_14;
          }
          Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
          CFArrayAppendValue(Mutable, v10);
        }
        else
        {
LABEL_14:
          Mutable = 0;
        }
      }
      v11 = *(_QWORD *)(a1 + 8);
      v12 = *(uint64_t **)(v11 + 392);
      if (!v12)
      {
        v12 = (uint64_t *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
        __CFSetLastAllocationEventName();
        if (v12)
          *v12 = v11;
        *(_QWORD *)(v11 + 392) = v12;
      }
      if (v12)
        v13 = Mutable == 0;
      else
        v13 = 1;
      if (v13)
      {
        v14 = 0;
      }
      else
      {
        if (!v12[1])
          v12[1] = (uint64_t)CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_982);
        value = 0;
        v15 = *v12;
        if (*v12 && (Count = CFArrayGetCount(Mutable)) != 0)
        {
          v17 = Count;
          v18 = malloc_type_calloc(1uLL, 8 * Count + 40, 0x33BCE901uLL);
          __CFSetLastAllocationEventName();
          if (v18)
          {
            v19 = 0;
            *(_DWORD *)v18 = 1;
            v18[1] = v15;
            v18[2] = 0;
            *((_BYTE *)v18 + 24) = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v19);
              if (*((_BYTE *)ValueAtIndex + 8) == 3)
              {
                v21 = (unsigned int *)*((_QWORD *)ValueAtIndex + 3);
                if (v21)
                {
                  do
                    v22 = __ldxr(v21);
                  while (__stxr(v22 + 1, v21));
                }
              }
              else
              {
                v21 = 0;
              }
              v18[v19++ + 5] = v21;
            }
            while (v19 != v17);
            v18[4] = v17;
          }
        }
        else
        {
          v18 = 0;
        }
        if (!CFSetGetValueIfPresent((CFSetRef)v12[1], v18, (const void **)&value))
        {
          CFSetAddValue((CFMutableSetRef)v12[1], v18);
          value = v18;
        }
        PDFClipMaskRelease((unsigned int **)v18);
        v23 = (const void **)v12[2];
        if (!v23)
        {
          v23 = CGOrderedSetCreate();
          v12[2] = (uint64_t)v23;
        }
        CGOrderedSetAddValue((CFSetRef *)v23, value);
        v14 = value;
      }
      v24 = *(unsigned int ***)(a1 + 232);
      if (!PDFClipMaskEqualToClipMask((uint64_t)v24, (uint64_t)v14))
      {
        PDFClipMaskRelease(v24);
        if (v14)
          ++*v14;
        *(_QWORD *)(a1 + 232) = v14;
        addEmitFunction(a1, emitClipMaskChange);
      }
      if (Mutable)
        CFRelease(Mutable);
    }
  }
}

void emitClipStackChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const CGRect *v16;
  uint64_t v17;
  uint64_t v18;
  const __CFArray *v19;
  const __CFArray *v20;
  const __CFAllocator *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v28;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFIndex v37;
  CFIndex v38;
  CFIndex j;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  CGFloat *p_height;
  CGFloat *p_y;
  CGSize *v61;
  const CGRect *v62;
  CGFloat *v63;
  CGFloat *v64;
  BOOL v65;
  CGSize *p_size;
  double v67;
  double x;
  double v69;
  double width;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  __int128 v78;
  __int128 v79;

  PDFWriterAnnotate(*(_QWORD *)(a1 + 16), (uint64_t)"  BEGIN: synchronizing clip.", a3, a4, a5, a6, a7, a8, v75);
  v15 = *(_QWORD *)(a1 + 256);
  v16 = &CGRectInfinite;
  if (v15)
  {
    v17 = *(_QWORD *)(v15 + 120);
    if (v17)
    {
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v22 = 128;
      while (2)
      {
        v23 = *(_QWORD *)(a1 + 256);
        if (*(_QWORD *)(v23 + 112) == 3)
          v24 = v23 + v22;
        else
          v24 = *(_QWORD *)(v23 + 128) + 8 * v18;
        v25 = *(const void **)v24;
        switch(*(_BYTE *)(*(_QWORD *)v24 + 8))
        {
          case 2:
            if (v19)
            {
              Mutable = v19;
            }
            else
            {
              Mutable = CFArrayCreateMutable(v21, 0, 0);
              v19 = Mutable;
            }
            goto LABEL_14;
          case 3:
            goto LABEL_15;
          case 4:
            if (v20)
            {
              Mutable = v20;
            }
            else
            {
              Mutable = CFArrayCreateMutable(v21, 0, 0);
              v20 = Mutable;
            }
LABEL_14:
            CFArrayAppendValue(Mutable, v25);
LABEL_15:
            ++v18;
            v22 += 8;
            if (v17 != v18)
              continue;
            if (v19)
            {
              Count = CFArrayGetCount(v19);
              if (Count)
              {
                v28 = Count;
                for (i = 0; i != v28; ++i)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(v19, i);
                  PDFWriteClipPath(*(_BYTE ***)(a1 + 16), (uint64_t)ValueAtIndex, v31, v32, v33, v34, v35, v36);
                }
              }
              CFRelease(v19);
            }
            if (v20)
            {
              v37 = CFArrayGetCount(v20);
              if (v37)
              {
                v38 = v37;
                for (j = 0; j != v38; ++j)
                {
                  v40 = CFArrayGetValueAtIndex(v20, j);
                  PDFWriterAnnotate(*(_QWORD *)(a1 + 16), (uint64_t)"Beginning glyph clip.", v41, v42, v43, v44, v45, v46, v76);
                  PDFWriteClipPath(*(_BYTE ***)(a1 + 16), (uint64_t)v40, v47, v48, v49, v50, v51, v52);
                  PDFWriterAnnotate(*(_QWORD *)(a1 + 16), (uint64_t)"Ending glyph clip.", v53, v54, v55, v56, v57, v58, v77);
                }
              }
              CFRelease(v20);
            }
            break;
          default:
            abort();
        }
        break;
      }
    }
    p_height = &CGRectInfinite.size.height;
    p_y = &CGRectInfinite.origin.y;
    v61 = *(CGSize **)(a1 + 256);
    v62 = (const CGRect *)&v61[1];
    v63 = &v61[1].height;
    v64 = &v61[2].height;
    v65 = v61 == 0;
    if (v61)
      p_size = v61 + 2;
    else
      p_size = &CGRectInfinite.size;
    if (!v65)
    {
      p_y = v63;
      v16 = v62;
      p_height = v64;
    }
  }
  else
  {
    p_height = &CGRectInfinite.size.height;
    p_y = &CGRectInfinite.origin.y;
    p_size = &CGRectInfinite.size;
  }
  v67 = *p_height;
  x = v16->origin.x;
  v69 = *p_y;
  width = p_size->width;
  *(double *)&v78 = x;
  *((double *)&v78 + 1) = v69;
  *(double *)&v79 = width;
  *((double *)&v79 + 1) = v67;
  if (x != -8.98846567e307 || v69 != -8.98846567e307 || width != 1.79769313e308 || v67 != 1.79769313e308)
  {
    if (x == INFINITY || v69 == INFINITY)
    {
      v78 = 0u;
      v79 = 0u;
    }
    PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"%*r re W n", v9, v10, v11, v12, v13, v14, (uint64_t)&v78);
  }
  PDFWriterAnnotate(*(_QWORD *)(a1 + 16), (uint64_t)"  END: synchronizing clip.", v9, v10, v11, v12, v13, v14, v76);
}

void emitClipMaskChange(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  void **v4;
  char *v5;
  int v6;
  const void **v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *value;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = *(_DWORD **)(a1 + 232);
    if (!*(_QWORD *)(v2 + 8))
      *(_QWORD *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_13530);
    value = 0;
    v4 = PDFEStateCreate(*(void **)v2, "SMask");
    v5 = (char *)v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 7;
      if (v3)
        ++*v3;
      v4[6] = v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v4, (const void **)&value))
    {
      v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l(v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      value = v5;
    }
    PDFEStateRelease((void **)v5);
    v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      v7 = CGOrderedSetCreate();
      *(_QWORD *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    v8 = value;
  }
  else
  {
    v8 = 0;
  }
  PDFResourceSetAddEState(*(_QWORD *)(a1 + 32), v8);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

uint64_t w16_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  unsigned int v41;
  unint64_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  unsigned int v45;
  int v46;
  int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unint64_t v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unsigned __int8 *v53;
  unsigned int v54;
  unsigned __int8 *v55;
  unint64_t v56;
  unint64_t v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  int v60;
  char v61;
  unsigned int v62;
  unsigned __int8 *v63;
  unsigned int v64;
  unsigned __int8 *v65;
  int v66;
  char v67;
  unsigned int v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unsigned __int8 *v72;
  int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v84 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v88 = *(_QWORD *)(result + 152) - 4;
  v86 = *(_QWORD *)(result + 88);
  v87 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v11 = 0;
  else
    v11 = -16777216;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v82 = *(_DWORD *)(result + 188);
  v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  v15 = v4 + v13 + (v12 * v6) - 1;
  v85 = *(_QWORD *)(result + 72);
  v83 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v85)
    {
      if (a3 <= v86)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v83;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v86;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_43;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v83;
        v25 = v82 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v85 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_43;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v83;
      v25 = v82 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v82;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(_BYTE *)++v87 = 0;
    v88 += 4;
    if (!a4)
      return result;
  }
  if (a2 <= v84)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_29;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v84;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_43;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v82;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_43;
  v36 = v26 >> 32;
  v37 = v4 + (int)v36 * (uint64_t)v6;
  v38 = v37 + (v31 >> 32);
  v39 = *(unsigned __int8 **)(result + 32);
  if (v15 >= v38)
    v40 = (unsigned __int8 *)(v37 + (v31 >> 32));
  else
    v40 = (unsigned __int8 *)v15;
  if (v40 < v39)
    v40 = *(unsigned __int8 **)(result + 32);
  v41 = *v40;
  if (!v5)
  {
    v42 = 0;
    if (!v8)
      goto LABEL_103;
LABEL_46:
    v45 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    v46 = v45 & 0xF;
    v47 = HIBYTE(v45) & 3;
    if (v46 == 1)
    {
      v63 = (unsigned __int8 *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      if (v15 < (unint64_t)v63)
        v63 = (unsigned __int8 *)v15;
      if (v63 < v39)
        v63 = v39;
      v64 = *v63;
      if (v5)
      {
        v65 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
        if (v14 < v65)
          v65 = v14;
        if ((unint64_t)v65 < *(_QWORD *)(result + 40))
          v65 = *(unsigned __int8 **)(result + 40);
        v64 |= *v65 << 24;
      }
      v66 = interpolate_8888_19472[v47];
      v67 = v47 + 1;
      v68 = v41 - ((v66 & v41) >> v67);
      v69 = (v66 & v64) >> v67;
    }
    else
    {
      if (v46 != 2)
      {
        if (v46 == 3)
        {
          v48 = (unsigned __int8 *)(v38 + SBYTE2(v45));
          if (v15 < (unint64_t)v48)
            v48 = (unsigned __int8 *)v15;
          if (v48 < v39)
            v48 = v39;
          v49 = *v48;
          v50 = v38 + SBYTE1(v45) * (uint64_t)v6;
          if (v15 >= v50)
            v51 = (unsigned __int8 *)(v38 + SBYTE1(v45) * (uint64_t)v6);
          else
            v51 = (unsigned __int8 *)v15;
          if (v51 < v39)
            v51 = v39;
          v52 = *v51;
          v53 = (unsigned __int8 *)(v50 + SBYTE2(v45));
          if (v15 < (unint64_t)v53)
            v53 = (unsigned __int8 *)v15;
          if (v53 < v39)
            v53 = v39;
          v54 = *v53;
          if (v5)
          {
            v55 = (unsigned __int8 *)(v42 + SBYTE2(v45));
            v56 = *(_QWORD *)(result + 40);
            if (v14 < v55)
              v55 = v14;
            if ((unint64_t)v55 < v56)
              v55 = *(unsigned __int8 **)(result + 40);
            v49 |= *v55 << 24;
            v57 = v42 + SBYTE1(v45) * (uint64_t)v7;
            if ((unint64_t)v14 >= v57)
              v58 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
            else
              v58 = v14;
            if ((unint64_t)v58 < v56)
              v58 = *(unsigned __int8 **)(result + 40);
            v52 |= *v58 << 24;
            v59 = (unsigned __int8 *)(v57 + SBYTE2(v45));
            if (v14 < v59)
              v59 = v14;
            if ((unint64_t)v59 < v56)
              v59 = *(unsigned __int8 **)(result + 40);
            v54 |= *v59 << 24;
          }
          v60 = interpolate_8888_19472[v47];
          v61 = v47 + 1;
          v62 = v41 - ((v60 & v41) >> v61) + ((v60 & v52) >> v61);
          v41 = v62
              - ((v62 & interpolate_8888_19472[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1))
              + (((v49 - ((v60 & v49) >> v61) + ((v60 & v54) >> v61)) & interpolate_8888_19472[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      v70 = (unsigned __int8 *)(v38 + SBYTE2(v45));
      if (v15 < (unint64_t)v70)
        v70 = (unsigned __int8 *)v15;
      if (v70 < v39)
        v70 = v39;
      v71 = *v70;
      if (v5)
      {
        v72 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v72)
          v72 = v14;
        if ((unint64_t)v72 < *(_QWORD *)(result + 40))
          v72 = *(unsigned __int8 **)(result + 40);
        v71 |= *v72 << 24;
      }
      v73 = (v45 >> 28) & 3;
      v74 = interpolate_8888_19472[v73];
      LOBYTE(v73) = v73 + 1;
      v68 = v41 - ((v74 & v41) >> v73);
      v69 = (v74 & v71) >> v73;
    }
    v41 = v68 + v69;
    goto LABEL_103;
  }
  v42 = v5 + (int)v36 * (uint64_t)v7 + (v31 >> 32);
  v43 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v42)
    v44 = (unsigned __int8 *)v42;
  else
    v44 = v14;
  if (v44 >= v43)
    v43 = v44;
  v41 |= *v43 << 24;
  if (v8)
    goto LABEL_46;
LABEL_103:
  v75 = 0;
  v76 = 0;
  a3 += v9;
  v77 = v86 - a3;
  a2 += v10;
  v78 = v84 - a2;
  while (1)
  {
    *(_DWORD *)(v88 + 4 + 4 * v75) = (v41 | v11) & 0xFF000000 | ((v41 | v11) >> 8) & 0xFFFF0000 | (v41 << 8) | v41;
    *(_BYTE *)(v87 + 1 + v75) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v75)
      return result;
    if ((v77 | v78 | (a3 - v85) | (a2 - v83)) < 0)
    {
      v87 += v75 + 1;
      v88 = v88 - v76 + 4;
      a4 += ~(_DWORD)v75;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32);
    v39 = *(unsigned __int8 **)(result + 32);
    if (v15 >= v38)
      v79 = (unsigned __int8 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32));
    else
      v79 = (unsigned __int8 *)v15;
    if (v79 < v39)
      v79 = *(unsigned __int8 **)(result + 32);
    v41 = *v79;
    if (v5)
    {
      v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      v80 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42)
        v81 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      else
        v81 = (unint64_t)v14;
      if (v81 >= (unint64_t)v80)
        v80 = (unsigned __int8 *)v81;
      v41 |= *v80 << 24;
    }
    if (v8)
    {
      v45 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        v87 += v75 + 1;
        v88 = v88 - v76 + 4;
        a4 += ~(_DWORD)v75;
        v25 = -1;
        goto LABEL_48;
      }
    }
    v76 -= 4;
    ++v75;
    a3 += v9;
    v77 -= v9;
    a2 += v10;
    v78 -= v10;
    v25 = -1;
  }
}

uint64_t w16_sample_W16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unsigned __int16 *v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unint64_t v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  int v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int16 *v73;
  unsigned int v74;
  unint64_t v75;
  unsigned __int16 *v76;
  unsigned int v77;
  unsigned __int16 *v78;
  unsigned int v79;
  uint64_t v80;
  unsigned __int16 *v81;
  unint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unsigned __int16 *v85;
  int v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned __int16 *v93;
  unsigned int v94;
  unsigned __int16 *v95;
  int v96;
  unsigned int v97;
  unsigned int v98;
  uint64_t v99;
  int64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned __int16 *v104;
  unsigned int v105;
  unsigned __int16 *v106;
  int v107;
  int v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unsigned __int16 *v122;
  unsigned __int16 *v123;
  unsigned __int16 *v124;
  int v125;
  unsigned int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;

  v4 = *(_DWORD *)(result + 24);
  v134 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v133 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v133 = v5 % v6;
  }
  else
  {
    v133 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 40);
  v135 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v132 = v11;
  }
  else
  {
    v132 = 0;
  }
  v128 = *(_QWORD *)(result + 80);
  v130 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 152) - 4;
  v13 = *(_QWORD *)(result + 144) - 1;
  if (v9)
    v14 = 0;
  else
    v14 = -65536;
  v15 = *(_DWORD *)(result + 260) - 1;
  v16 = *(unsigned int *)(result + 256);
  v127 = *(_DWORD *)(result + 188);
  v17 = v9 + (v15 * v134) + 2 * (v16 - 1);
  v18 = v135 + (v15 * v4) + 2 * v16 - 2;
  v129 = *(_QWORD *)(result + 64);
  v131 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 < v131)
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v131 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      if (v21 < 1)
        goto LABEL_61;
      if (v21 >= v19)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v30 = v127 | v23;
      v31 = v20 + 0x1000000;
      v28 = a3 - v31;
      v29 = 512;
      goto LABEL_25;
    }
    if (a3 <= v130)
    {
      v28 = 0;
      v29 = ((unint64_t)a3 >> 22) & 0x3C0;
      v30 = 0x3FFFFFFF;
      v31 = a3;
      v22 = a4;
LABEL_25:
      v32 = v129;
      goto LABEL_28;
    }
    v24 = *(_QWORD *)(result + 216);
    v25 = *(_QWORD *)(result + 224) + v130;
    v26 = v25 - a3 + (v24 >> 1);
    v22 = a4;
    if (v26 < 1)
      goto LABEL_61;
    if (v26 >= v24)
      LODWORD(v27) = 0x3FFFFFFF;
    else
      v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
    v32 = v129;
    v30 = v127 | v27;
    v31 = v25 - 0x1000000;
    v28 = a3 - v31;
    v29 = 448;
LABEL_28:
    if (a2 >= v32)
      break;
    v33 = *(_QWORD *)(result + 192);
    v34 = v32 - *(_QWORD *)(result + 200);
    v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v127;
      v36 = v34 + 0x1000000;
      v37 = a2 - (v34 + 0x1000000);
      v38 = 32;
      goto LABEL_39;
    }
LABEL_61:
    v56 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 4;
    *(_BYTE *)++v13 = 0;
LABEL_62:
    a4 = v56;
    if (!v56)
      return result;
  }
  if (a2 <= v128)
  {
    v37 = 0;
    v38 = ((unint64_t)a2 >> 26) & 0x3C;
    v36 = a2;
    goto LABEL_39;
  }
  v39 = *(_QWORD *)(result + 192);
  v40 = *(_QWORD *)(result + 200) + v128;
  v41 = v40 - a2 + (v39 >> 1);
  if (v41 < 1)
    goto LABEL_61;
  if (v41 < v39)
    v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v41) >> 32) >> 15)) | v127;
  v36 = v40 - 0x1000000;
  v37 = a2 - (v40 - 0x1000000);
  v38 = 28;
LABEL_39:
  if (v30 < 0x400000)
    goto LABEL_61;
  if (v6)
  {
    v42 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    v43 = (v6 & ((v36 % v6) >> 63)) + v36 % v6;
    if (v42 >= v7)
      v44 = v7;
    else
      v44 = 0;
    v31 = v42 - v44;
    if (v43 >= v6)
      v45 = v6;
    else
      v45 = 0;
    v36 = v43 - v45;
    v28 += v31;
    v37 += v36;
  }
  v46 = v31 >> 32;
  v47 = v36 >> 31;
  v48 = v47 & 0xFFFFFFFFFFFFFFFELL;
  v49 = v135 + (int)v46 * (uint64_t)v4 + (v47 & 0xFFFFFFFFFFFFFFFELL);
  v50 = *(unsigned __int16 **)(result + 32);
  if (v18 >= v49)
    v51 = (unsigned __int16 *)(v135 + (int)v46 * (uint64_t)v4 + (v47 & 0xFFFFFFFFFFFFFFFELL));
  else
    v51 = (unsigned __int16 *)v18;
  if (v51 < v50)
    v51 = *(unsigned __int16 **)(result + 32);
  v52 = bswap32(*v51) >> 16;
  if (!v9)
  {
    v53 = 0;
    if (!v8)
      goto LABEL_140;
LABEL_65:
    v57 = *(_DWORD *)(v8 + (v38 | v29));
LABEL_67:
    v58 = v57 & 0xF;
    v59 = v57 >> 8;
    v60 = HIBYTE(v57) & 3;
    if (v58 == 1)
    {
      LODWORD(v88) = SBYTE1(v57);
      if (v6)
      {
        v89 = v59 << 56;
        v90 = v28 + (v89 >> 24);
        v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7)
          v92 = v7;
        else
          v92 = 0;
        v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      v93 = (unsigned __int16 *)(v49 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93)
        v93 = (unsigned __int16 *)v18;
      if (v93 < v50)
        v93 = v50;
      v94 = bswap32(*v93) >> 16;
      if (v9)
      {
        v95 = (unsigned __int16 *)(v53 + (int)v88 * (uint64_t)v134);
        if (v17 < (unint64_t)v95)
          v95 = (unsigned __int16 *)v17;
        if ((unint64_t)v95 < *(_QWORD *)(result + 40))
          v95 = *(unsigned __int16 **)(result + 40);
        v94 |= bswap32(*v95) & 0xFFFF0000;
      }
      v96 = interpolate_1616[v60];
      v97 = v52 - ((v96 & v52) >> (v60 + 1));
      v98 = (v96 & v94) >> (v60 + 1);
    }
    else
    {
      if (v58 != 2)
      {
        if (v58 == 3)
        {
          v61 = HIBYTE(v57) & 3;
          v126 = v30;
          v125 = v22;
          LODWORD(v62) = SBYTE1(v57);
          v63 = SBYTE2(v57);
          if (v6)
          {
            v64 = v59 << 56;
            v65 = (unint64_t)HIWORD(v57) << 56;
            v66 = v28 + (v64 >> 24);
            v67 = v37 + (v65 >> 24);
            v68 = v7 & (v66 >> 63);
            v69 = v6 & (v67 >> 63);
            v70 = v69 + v67;
            if (v68 + v66 >= v7)
              v71 = v7;
            else
              v71 = 0;
            if (v70 >= v6)
              v72 = v6;
            else
              v72 = 0;
            v62 = (v68 + (v64 >> 24) - v71) >> 32;
            v63 = (v69 + (v65 >> 24) - v72) >> 32;
          }
          v73 = (unsigned __int16 *)(v49 + 2 * v63);
          if (v18 < (unint64_t)v73)
            v73 = (unsigned __int16 *)v18;
          if (v73 < v50)
            v73 = v50;
          v74 = bswap32(*v73) >> 16;
          v75 = v49 + (int)v62 * (uint64_t)v4;
          if (v18 >= v75)
            v76 = (unsigned __int16 *)(v49 + (int)v62 * (uint64_t)v4);
          else
            v76 = (unsigned __int16 *)v18;
          if (v76 < v50)
            v76 = v50;
          v77 = bswap32(*v76) >> 16;
          v78 = (unsigned __int16 *)(v75 + 2 * v63);
          if (v18 < (unint64_t)v78)
            v78 = (unsigned __int16 *)v18;
          if (v78 >= v50)
            v50 = v78;
          v79 = bswap32(*v50) >> 16;
          if (v9)
          {
            v80 = v63;
            v81 = (unsigned __int16 *)(v53 + 2 * v63);
            v82 = *(_QWORD *)(result + 40);
            if (v17 < (unint64_t)v81)
              v81 = (unsigned __int16 *)v17;
            if ((unint64_t)v81 < v82)
              v81 = *(unsigned __int16 **)(result + 40);
            v74 |= bswap32(*v81) & 0xFFFF0000;
            v83 = (unsigned __int16 *)(v53 + (int)v62 * (uint64_t)v134);
            if (v17 >= (unint64_t)v83)
              v84 = v83;
            else
              v84 = (unsigned __int16 *)v17;
            if ((unint64_t)v84 < v82)
              v84 = *(unsigned __int16 **)(result + 40);
            v77 |= bswap32(*v84) & 0xFFFF0000;
            v85 = &v83[v80];
            if (v17 < (unint64_t)v85)
              v85 = (unsigned __int16 *)v17;
            if ((unint64_t)v85 < v82)
              v85 = *(unsigned __int16 **)(result + 40);
            v79 |= bswap32(*v85) & 0xFFFF0000;
          }
          v86 = interpolate_1616[v61];
          v87 = v52 - ((v86 & v52) >> (v61 + 1)) + ((v86 & v77) >> (v61 + 1));
          v52 = v87
              - ((v87 & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1))
              + (((v74 - ((v86 & v74) >> (v61 + 1)) + ((v86 & v79) >> (v61 + 1))) & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1));
          v22 = v125;
          v30 = v126;
        }
        goto LABEL_140;
      }
      v99 = SBYTE2(v57);
      if (v6)
      {
        v100 = (unint64_t)HIWORD(v57) << 56;
        v101 = v37 + (v100 >> 24);
        v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6)
          v103 = v6;
        else
          v103 = 0;
        v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      v104 = (unsigned __int16 *)(v49 + 2 * v99);
      if (v18 < (unint64_t)v104)
        v104 = (unsigned __int16 *)v18;
      if (v104 < v50)
        v104 = v50;
      v105 = bswap32(*v104) >> 16;
      if (v9)
      {
        v106 = (unsigned __int16 *)(v53 + 2 * v99);
        if (v17 < (unint64_t)v106)
          v106 = (unsigned __int16 *)v17;
        if ((unint64_t)v106 < *(_QWORD *)(result + 40))
          v106 = *(unsigned __int16 **)(result + 40);
        v105 |= bswap32(*v106) & 0xFFFF0000;
      }
      v107 = (v57 >> 28) & 3;
      v108 = interpolate_1616[v107];
      LOBYTE(v107) = v107 + 1;
      v97 = v52 - ((v108 & v52) >> v107);
      v98 = (v108 & v105) >> v107;
    }
    v52 = v97 + v98;
    goto LABEL_140;
  }
  v53 = v9 + (int)v46 * (uint64_t)v134 + v48;
  v54 = *(unsigned __int16 **)(result + 40);
  if (v17 >= v53)
    v55 = (unsigned __int16 *)v53;
  else
    v55 = (unsigned __int16 *)v17;
  if (v55 >= v54)
    v54 = v55;
  v52 |= bswap32(*v54) & 0xFFFF0000;
  if (v8)
    goto LABEL_65;
LABEL_140:
  *(_DWORD *)(v12 + 4) = v52 | v14;
  *(_BYTE *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    v109 = v22;
    v110 = 0;
    a2 += v5;
    v111 = v128 - a2;
    a3 += v10;
    v112 = v130 - a3;
    v113 = -4;
    while (((v112 | v111 | (a3 - v131) | (a2 - v129)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        v115 = (v6 & ((v37 + v133) >> 63)) + v37 + v133;
        if (v114 >= v7)
          v116 = v7;
        else
          v116 = 0;
        v117 = v114 - v116;
        if (v115 >= v6)
          v118 = v6;
        else
          v118 = 0;
        v119 = v115 - v118;
        v37 = v119;
        v28 = v117;
      }
      else
      {
        v119 = a2;
        v117 = a3;
      }
      v120 = v117 >> 32;
      v121 = (v119 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      v49 = v135 + SHIDWORD(v117) * (uint64_t)v4 + v121;
      v50 = *(unsigned __int16 **)(result + 32);
      if (v18 >= v49)
        v122 = (unsigned __int16 *)v49;
      else
        v122 = (unsigned __int16 *)v18;
      if (v122 < v50)
        v122 = *(unsigned __int16 **)(result + 32);
      v52 = bswap32(*v122) >> 16;
      if (v9)
      {
        v53 = v9 + (int)v120 * (uint64_t)v134 + v121;
        v123 = *(unsigned __int16 **)(result + 40);
        if (v17 >= v53)
          v124 = (unsigned __int16 *)v53;
        else
          v124 = (unsigned __int16 *)v17;
        if (v124 >= v123)
          v123 = v124;
        v52 |= bswap32(*v123) & 0xFFFF0000;
      }
      if (v8)
      {
        v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v57 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          v22 = ~(_DWORD)v110 + v109;
          v30 = -1;
          goto LABEL_67;
        }
      }
      *(_DWORD *)(v12 + 4 * v110 + 8) = v52 | v14;
      *(_BYTE *)(v13 + v110++ + 2) = -1;
      v113 -= 4;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == (_DWORD)v110)
        return result;
    }
    v13 += v110 + 1;
    v12 -= v113;
    v56 = ~(_DWORD)v110 + v109;
    goto LABEL_62;
  }
  return result;
}

uint64_t w16_sample_w16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unsigned __int16 *v49;
  unsigned __int16 *v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unint64_t v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  int v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int16 *v73;
  unsigned int v74;
  unint64_t v75;
  unsigned __int16 *v76;
  unsigned int v77;
  unsigned __int16 *v78;
  unsigned int v79;
  uint64_t v80;
  unsigned __int16 *v81;
  unint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unsigned __int16 *v85;
  int v86;
  unsigned int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned __int16 *v93;
  unsigned int v94;
  unsigned __int16 *v95;
  int v96;
  unsigned int v97;
  unsigned int v98;
  uint64_t v99;
  int64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned __int16 *v104;
  unsigned int v105;
  unsigned __int16 *v106;
  int v107;
  int v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unsigned __int16 *v122;
  unsigned __int16 *v123;
  unsigned __int16 *v124;
  int v125;
  unsigned int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;

  v4 = *(_DWORD *)(result + 24);
  v134 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v133 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v133 = v5 % v6;
  }
  else
  {
    v133 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 40);
  v135 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v132 = v11;
  }
  else
  {
    v132 = 0;
  }
  v128 = *(_QWORD *)(result + 80);
  v130 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 152) - 4;
  v13 = *(_QWORD *)(result + 144) - 1;
  if (v9)
    v14 = 0;
  else
    v14 = -65536;
  v15 = *(_DWORD *)(result + 260) - 1;
  v16 = *(unsigned int *)(result + 256);
  v127 = *(_DWORD *)(result + 188);
  v17 = v9 + (v15 * v134) + 2 * (v16 - 1);
  v18 = v135 + (v15 * v4) + 2 * v16 - 2;
  v129 = *(_QWORD *)(result + 64);
  v131 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 < v131)
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v131 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      if (v21 < 1)
        goto LABEL_61;
      if (v21 >= v19)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v30 = v127 | v23;
      v31 = v20 + 0x1000000;
      v28 = a3 - (v20 + 0x1000000);
      v29 = 512;
      goto LABEL_25;
    }
    if (a3 <= v130)
    {
      v28 = 0;
      v29 = ((unint64_t)a3 >> 22) & 0x3C0;
      v30 = 0x3FFFFFFF;
      v31 = a3;
      v22 = a4;
LABEL_25:
      v32 = v129;
      goto LABEL_28;
    }
    v24 = *(_QWORD *)(result + 216);
    v25 = *(_QWORD *)(result + 224) + v130;
    v26 = v25 - a3 + (v24 >> 1);
    v22 = a4;
    if (v26 < 1)
      goto LABEL_61;
    if (v26 >= v24)
      LODWORD(v27) = 0x3FFFFFFF;
    else
      v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
    v32 = v129;
    v30 = v127 | v27;
    v31 = v25 - 0x1000000;
    v28 = a3 - (v25 - 0x1000000);
    v29 = 448;
LABEL_28:
    if (a2 >= v32)
      break;
    v33 = *(_QWORD *)(result + 192);
    v34 = v32 - *(_QWORD *)(result + 200);
    v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v127;
      v36 = v34 + 0x1000000;
      v37 = a2 - (v34 + 0x1000000);
      v38 = 32;
      goto LABEL_39;
    }
LABEL_61:
    v56 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 4;
    *(_BYTE *)++v13 = 0;
LABEL_62:
    a4 = v56;
    if (!v56)
      return result;
  }
  if (a2 <= v128)
  {
    v37 = 0;
    v38 = ((unint64_t)a2 >> 26) & 0x3C;
    v36 = a2;
    goto LABEL_39;
  }
  v39 = *(_QWORD *)(result + 192);
  v40 = *(_QWORD *)(result + 200) + v128;
  v41 = v40 - a2 + (v39 >> 1);
  if (v41 < 1)
    goto LABEL_61;
  if (v41 < v39)
    v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v41) >> 32) >> 15)) | v127;
  v36 = v40 - 0x1000000;
  v37 = a2 - (v40 - 0x1000000);
  v38 = 28;
LABEL_39:
  if (v30 < 0x400000)
    goto LABEL_61;
  if (v6)
  {
    v42 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    v43 = (v6 & ((v36 % v6) >> 63)) + v36 % v6;
    if (v42 >= v7)
      v44 = v7;
    else
      v44 = 0;
    v31 = v42 - v44;
    if (v43 >= v6)
      v45 = v6;
    else
      v45 = 0;
    v36 = v43 - v45;
    v28 += v31;
    v37 += v36;
  }
  v46 = v31 >> 32;
  v47 = v135 + SHIDWORD(v31) * (uint64_t)v4;
  v48 = (v36 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  v49 = (unsigned __int16 *)(v47 + v48);
  v50 = *(unsigned __int16 **)(result + 32);
  if (v18 >= v47 + v48)
    v51 = (unsigned __int16 *)(v47 + v48);
  else
    v51 = (unsigned __int16 *)v18;
  if (v51 < v50)
    v51 = *(unsigned __int16 **)(result + 32);
  v52 = *v51;
  if (!v9)
  {
    v53 = 0;
    if (!v8)
      goto LABEL_140;
LABEL_65:
    v57 = *(_DWORD *)(v8 + (v38 | v29));
LABEL_67:
    v58 = v57 & 0xF;
    v59 = v57 >> 8;
    v60 = HIBYTE(v57) & 3;
    if (v58 == 1)
    {
      LODWORD(v88) = SBYTE1(v57);
      if (v6)
      {
        v89 = v59 << 56;
        v90 = v28 + (v89 >> 24);
        v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7)
          v92 = v7;
        else
          v92 = 0;
        v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      v93 = (unsigned __int16 *)((char *)v49 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93)
        v93 = (unsigned __int16 *)v18;
      if (v93 < v50)
        v93 = v50;
      v94 = *v93;
      if (v9)
      {
        v95 = (unsigned __int16 *)(v53 + (int)v88 * (uint64_t)v134);
        if (v17 < (unint64_t)v95)
          v95 = (unsigned __int16 *)v17;
        if ((unint64_t)v95 < *(_QWORD *)(result + 40))
          v95 = *(unsigned __int16 **)(result + 40);
        v94 |= *v95 << 16;
      }
      v96 = interpolate_1616[v60];
      v97 = v52 - ((v96 & v52) >> (v60 + 1));
      v98 = (v96 & v94) >> (v60 + 1);
    }
    else
    {
      if (v58 != 2)
      {
        if (v58 == 3)
        {
          v61 = HIBYTE(v57) & 3;
          v126 = v30;
          v125 = v22;
          LODWORD(v62) = SBYTE1(v57);
          v63 = SBYTE2(v57);
          if (v6)
          {
            v64 = v59 << 56;
            v65 = (unint64_t)HIWORD(v57) << 56;
            v66 = v28 + (v64 >> 24);
            v67 = v37 + (v65 >> 24);
            v68 = v7 & (v66 >> 63);
            v69 = v6 & (v67 >> 63);
            v70 = v69 + v67;
            if (v68 + v66 >= v7)
              v71 = v7;
            else
              v71 = 0;
            if (v70 >= v6)
              v72 = v6;
            else
              v72 = 0;
            v62 = (v68 + (v64 >> 24) - v71) >> 32;
            v63 = (v69 + (v65 >> 24) - v72) >> 32;
          }
          v73 = &v49[v63];
          if (v18 < (unint64_t)v73)
            v73 = (unsigned __int16 *)v18;
          if (v73 < v50)
            v73 = v50;
          v74 = *v73;
          v75 = (unint64_t)v49 + (int)v62 * (uint64_t)v4;
          if (v18 >= v75)
            v76 = (unsigned __int16 *)((char *)v49 + (int)v62 * (uint64_t)v4);
          else
            v76 = (unsigned __int16 *)v18;
          if (v76 < v50)
            v76 = v50;
          v77 = *v76;
          v78 = (unsigned __int16 *)(v75 + 2 * v63);
          if (v18 < (unint64_t)v78)
            v78 = (unsigned __int16 *)v18;
          if (v78 >= v50)
            v50 = v78;
          v79 = *v50;
          if (v9)
          {
            v80 = v63;
            v81 = (unsigned __int16 *)(v53 + 2 * v63);
            v82 = *(_QWORD *)(result + 40);
            if (v17 < (unint64_t)v81)
              v81 = (unsigned __int16 *)v17;
            if ((unint64_t)v81 < v82)
              v81 = *(unsigned __int16 **)(result + 40);
            v74 |= *v81 << 16;
            v83 = (unsigned __int16 *)(v53 + (int)v62 * (uint64_t)v134);
            if (v17 >= (unint64_t)v83)
              v84 = v83;
            else
              v84 = (unsigned __int16 *)v17;
            if ((unint64_t)v84 < v82)
              v84 = *(unsigned __int16 **)(result + 40);
            v77 |= *v84 << 16;
            v85 = &v83[v80];
            if (v17 < (unint64_t)v85)
              v85 = (unsigned __int16 *)v17;
            if ((unint64_t)v85 < v82)
              v85 = *(unsigned __int16 **)(result + 40);
            v79 |= *v85 << 16;
          }
          v86 = interpolate_1616[v61];
          v87 = v52 - ((v86 & v52) >> (v61 + 1)) + ((v86 & v77) >> (v61 + 1));
          v52 = v87
              - ((v87 & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1))
              + (((v74 - ((v86 & v74) >> (v61 + 1)) + ((v86 & v79) >> (v61 + 1))) & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1));
          v22 = v125;
          v30 = v126;
        }
        goto LABEL_140;
      }
      v99 = SBYTE2(v57);
      if (v6)
      {
        v100 = (unint64_t)HIWORD(v57) << 56;
        v101 = v37 + (v100 >> 24);
        v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6)
          v103 = v6;
        else
          v103 = 0;
        v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      v104 = &v49[v99];
      if (v18 < (unint64_t)v104)
        v104 = (unsigned __int16 *)v18;
      if (v104 < v50)
        v104 = v50;
      v105 = *v104;
      if (v9)
      {
        v106 = (unsigned __int16 *)(v53 + 2 * v99);
        if (v17 < (unint64_t)v106)
          v106 = (unsigned __int16 *)v17;
        if ((unint64_t)v106 < *(_QWORD *)(result + 40))
          v106 = *(unsigned __int16 **)(result + 40);
        v105 |= *v106 << 16;
      }
      v107 = (v57 >> 28) & 3;
      v108 = interpolate_1616[v107];
      LOBYTE(v107) = v107 + 1;
      v97 = v52 - ((v108 & v52) >> v107);
      v98 = (v108 & v105) >> v107;
    }
    v52 = v97 + v98;
    goto LABEL_140;
  }
  v53 = v9 + (int)v46 * (uint64_t)v134 + v48;
  v54 = *(unsigned __int16 **)(result + 40);
  if (v17 >= v53)
    v55 = (unsigned __int16 *)v53;
  else
    v55 = (unsigned __int16 *)v17;
  if (v55 >= v54)
    v54 = v55;
  v52 |= *v54 << 16;
  if (v8)
    goto LABEL_65;
LABEL_140:
  *(_DWORD *)(v12 + 4) = v52 | v14;
  *(_BYTE *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    v109 = v22;
    v110 = 0;
    a2 += v5;
    v111 = v128 - a2;
    a3 += v10;
    v112 = v130 - a3;
    v113 = -4;
    while (((v112 | v111 | (a3 - v131) | (a2 - v129)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        v115 = (v6 & ((v37 + v133) >> 63)) + v37 + v133;
        if (v114 >= v7)
          v116 = v7;
        else
          v116 = 0;
        v117 = v114 - v116;
        if (v115 >= v6)
          v118 = v6;
        else
          v118 = 0;
        v119 = v115 - v118;
        v37 = v119;
        v28 = v117;
      }
      else
      {
        v119 = a2;
        v117 = a3;
      }
      v120 = v117 >> 32;
      v121 = (v119 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      v49 = (unsigned __int16 *)(v135 + SHIDWORD(v117) * (uint64_t)v4 + v121);
      v50 = *(unsigned __int16 **)(result + 32);
      if (v18 >= (unint64_t)v49)
        v122 = v49;
      else
        v122 = (unsigned __int16 *)v18;
      if (v122 < v50)
        v122 = *(unsigned __int16 **)(result + 32);
      v52 = *v122;
      if (v9)
      {
        v53 = v9 + (int)v120 * (uint64_t)v134 + v121;
        v123 = *(unsigned __int16 **)(result + 40);
        if (v17 >= v53)
          v124 = (unsigned __int16 *)v53;
        else
          v124 = (unsigned __int16 *)v17;
        if (v124 >= v123)
          v123 = v124;
        v52 |= *v123 << 16;
      }
      if (v8)
      {
        v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v57 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          v22 = ~(_DWORD)v110 + v109;
          v30 = -1;
          goto LABEL_67;
        }
      }
      *(_DWORD *)(v12 + 4 * v110 + 8) = v52 | v14;
      *(_BYTE *)(v13 + v110++ + 2) = -1;
      v113 -= 4;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == (_DWORD)v110)
        return result;
    }
    v13 += v110 + 1;
    v12 -= v113;
    v56 = ~(_DWORD)v110 + v109;
    goto LABEL_62;
  }
  return result;
}

uint64_t w16_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned __int16 *v43;
  unint64_t v44;
  unint64_t v45;
  unsigned __int16 *v46;
  unint64_t v47;
  unsigned __int16 *v48;
  uint64_t v49;
  char v50;
  unint64_t v51;
  unint64_t v52;
  unsigned int v53;
  uint64_t v54;
  char v55;
  unint64_t v56;
  unsigned __int16 *v57;
  uint64_t v58;
  char v59;
  unint64_t v60;
  unsigned __int16 *v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int16 *v68;
  int v69;
  uint64_t v70;
  uint64_t v71;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v70 = *(_QWORD *)(result + 64);
  v71 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  v69 = *(_DWORD *)(result + 188);
  v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        v22 = (a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        v25 = v70;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v8;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_34;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v25 = v70;
        v23 = v69 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v7 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_34;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v25 = v70;
      v23 = v69 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v25)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v25 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v69;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(_BYTE *)++v12 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v71)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v71;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v69;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v23 < 0x400000)
    goto LABEL_34;
  v34 = v29 >> 32;
  v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  v36 = v35 + 6 * (int)v34;
  v37 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v36)
    v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  else
    v38 = (unsigned __int16 *)v13;
  if (v38 < v37)
    v38 = *(unsigned __int16 **)(result + 32);
  v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6)
    goto LABEL_66;
  v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57)
        v57 = (unsigned __int16 *)v13;
      if (v57 < v37)
        v57 = v37;
      v58 = interpolate_16161616_19469[v42];
      v59 = v42 + 1;
      v56 = v39 - ((v58 & v39) >> v59);
      v60 = (((bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      v39 = v56 + v60;
      break;
    case 2:
      v61 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61)
        v61 = (unsigned __int16 *)v13;
      if (v61 < v37)
        v61 = v37;
      v52 = (bswap32(*v61) >> 16) | ((unint64_t)(bswap32(v61[1]) >> 16) << 16) | ((unint64_t)(bswap32(v61[2]) >> 16) << 32) | 0xFFFF000000000000;
      v62 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v62];
      v55 = v62 + 1;
      v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43)
        v43 = (unsigned __int16 *)v13;
      if (v43 < v37)
        v43 = v37;
      v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45)
        v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      else
        v46 = (unsigned __int16 *)v13;
      if (v46 < v37)
        v46 = v37;
      v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48)
        v48 = (unsigned __int16 *)v13;
      if (v48 < v37)
        v48 = v37;
      v49 = interpolate_16161616_19469[v42];
      v50 = v42 + 1;
      v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      v53 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v53];
      v55 = v53 + 1;
      v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  v63 = 0;
  v64 = 0;
  a3 += v10;
  v65 = v8 - a3;
  a2 += v9;
  v66 = v71 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = HIDWORD(v39) & 0xFFFF0000 | ((2 * (unsigned __int16)v39
                                                                               + WORD1(v39)
                                                                               + 4 * WORD1(v39)
                                                                               + WORD2(v39)) >> 3);
    *(_BYTE *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v65 | v66 | (a3 - v7) | (a2 - v70)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      v11 = v11 - v63 + 4;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v67 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v36 = v67 + 6 * SHIDWORD(a2);
    v37 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v36)
      v68 = (unsigned __int16 *)(v67 + 6 * SHIDWORD(a2));
    else
      v68 = (unsigned __int16 *)v13;
    if (v68 < v37)
      v68 = *(unsigned __int16 **)(result + 32);
    v39 = (bswap32(*v68) >> 16) | ((unint64_t)(bswap32(v68[1]) >> 16) << 16) | ((unint64_t)(bswap32(v68[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        v11 = v11 - v63 + 4;
        a4 += ~(_DWORD)v64;
        v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    v23 = -1;
  }
}

uint64_t w16_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  unsigned int *v37;
  unint64_t v38;
  unsigned int v39;
  int v40;
  int v41;
  unsigned int *v42;
  unint64_t v43;
  unint64_t v44;
  unsigned int *v45;
  unint64_t v46;
  unsigned int *v47;
  uint64_t v48;
  char v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  char v54;
  unint64_t v55;
  unsigned int *v56;
  uint64_t v57;
  char v58;
  unint64_t v59;
  unsigned int *v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v69 = *(_QWORD *)(result + 64);
  v70 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  v68 = *(_DWORD *)(result + 188);
  v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        v22 = (a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v8;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_34;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v23 = v68 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v7 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_34;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v23 = v68 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v69)
      break;
    v25 = *(_QWORD *)(result + 192);
    v26 = v69 - *(_QWORD *)(result + 200);
    v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v68;
      v28 = v26 + 0x1000000;
      v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(_BYTE *)++v12 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v70)
  {
    v29 = ((unint64_t)a2 >> 26) & 0x3C;
    v28 = a2;
    goto LABEL_26;
  }
  v30 = *(_QWORD *)(result + 192);
  v31 = *(_QWORD *)(result + 200) + v70;
  v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1)
    goto LABEL_34;
  if (v32 < v30)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v68;
  v28 = v31 - 0x1000000;
  v29 = 28;
LABEL_26:
  if (v23 < 0x400000)
    goto LABEL_34;
  v33 = v28 >> 32;
  v34 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  v35 = v34 + 6 * (int)v33;
  v36 = *(unsigned int **)(result + 32);
  if (v13 >= v35)
    v37 = (unsigned int *)(v34 + 6 * (int)v33);
  else
    v37 = (unsigned int *)v13;
  if (v37 < v36)
    v37 = *(unsigned int **)(result + 32);
  v38 = *v37 | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32) | 0xFFFF000000000000;
  if (!v6)
    goto LABEL_66;
  v39 = *(_DWORD *)(v6 + (v29 | v22));
LABEL_37:
  v40 = v39 & 0xF;
  v41 = HIBYTE(v39) & 3;
  switch(v40)
  {
    case 1:
      v56 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      if (v13 < (unint64_t)v56)
        v56 = (unsigned int *)v13;
      if (v56 < v36)
        v56 = v36;
      v57 = interpolate_16161616_19469[v41];
      v58 = v41 + 1;
      v55 = v38 - ((v57 & v38) >> v58);
      v59 = ((*v56 | ((unint64_t)*((unsigned __int16 *)v56 + 2) << 32) | 0xFFFF000000000000) & v57) >> v58;
LABEL_65:
      v38 = v55 + v59;
      break;
    case 2:
      v60 = (unsigned int *)(v35 + 6 * SBYTE2(v39));
      if (v13 < (unint64_t)v60)
        v60 = (unsigned int *)v13;
      if (v60 < v36)
        v60 = v36;
      v51 = *v60 | ((unint64_t)*((unsigned __int16 *)v60 + 2) << 32) | 0xFFFF000000000000;
      v61 = (v39 >> 28) & 3;
      v53 = interpolate_16161616_19469[v61];
      v54 = v61 + 1;
      v55 = v38 - ((v53 & v38) >> v54);
LABEL_64:
      v59 = (v51 & v53) >> v54;
      goto LABEL_65;
    case 3:
      v42 = (unsigned int *)(v35 + 6 * SBYTE2(v39));
      if (v13 < (unint64_t)v42)
        v42 = (unsigned int *)v13;
      if (v42 < v36)
        v42 = v36;
      v43 = *v42 | ((unint64_t)*((unsigned __int16 *)v42 + 2) << 32) | 0xFFFF000000000000;
      v44 = v35 + SBYTE1(v39) * (uint64_t)v5;
      if (v13 >= v44)
        v45 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      else
        v45 = (unsigned int *)v13;
      if (v45 < v36)
        v45 = v36;
      v46 = *v45 | ((unint64_t)*((unsigned __int16 *)v45 + 2) << 32) | 0xFFFF000000000000;
      v47 = (unsigned int *)(v44 + 6 * SBYTE2(v39));
      if (v13 < (unint64_t)v47)
        v47 = (unsigned int *)v13;
      if (v47 < v36)
        v47 = v36;
      v48 = interpolate_16161616_19469[v41];
      v49 = v41 + 1;
      v50 = v38 - ((v48 & v38) >> v49) + ((v46 & v48) >> v49);
      v51 = v43
          - ((v48 & v43) >> v49)
          + (((*v47 | ((unint64_t)*((unsigned __int16 *)v47 + 2) << 32) | 0xFFFF000000000000) & v48) >> v49);
      v52 = (v39 >> 28) & 3;
      v53 = interpolate_16161616_19469[v52];
      v54 = v52 + 1;
      v55 = v50 - ((v50 & v53) >> v54);
      goto LABEL_64;
  }
LABEL_66:
  v62 = 0;
  v63 = 0;
  a3 += v10;
  v64 = v8 - a3;
  a2 += v9;
  v65 = v70 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v63) = HIDWORD(v38) & 0xFFFF0000 | ((2 * (unsigned __int16)v38
                                                                               + WORD1(v38)
                                                                               + 4 * WORD1(v38)
                                                                               + WORD2(v38)) >> 3);
    *(_BYTE *)(v12 + 1 + v63) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v63)
      return result;
    if (((v64 | v65 | (a3 - v7) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v12 += v63 + 1;
      v11 = v11 - v62 + 4;
      a4 += ~(_DWORD)v63;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v66 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v35 = v66 + 6 * SHIDWORD(a2);
    v36 = *(unsigned int **)(result + 32);
    if (v13 >= v35)
      v67 = (unsigned int *)(v66 + 6 * SHIDWORD(a2));
    else
      v67 = (unsigned int *)v13;
    if (v67 < v36)
      v67 = *(unsigned int **)(result + 32);
    v38 = *v67 | ((unint64_t)*((unsigned __int16 *)v67 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v39 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v12 += v63 + 1;
        v11 = v11 - v62 + 4;
        a4 += ~(_DWORD)v63;
        v23 = -1;
        goto LABEL_37;
      }
    }
    ++v63;
    v62 -= 4;
    a3 += v10;
    v64 -= v10;
    a2 += v9;
    v65 -= v9;
    v23 = -1;
  }
}

uint64_t w16_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  unint64_t v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned __int16 *v45;
  unint64_t v46;
  unint64_t v47;
  unsigned __int16 *v48;
  unint64_t v49;
  unsigned __int16 *v50;
  uint64_t v51;
  char v52;
  unint64_t v53;
  unint64_t v54;
  int v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int16 *v59;
  uint64_t v60;
  char v61;
  unsigned __int16 *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned __int16 *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v73 = *(_QWORD *)(result + 80);
  v72 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  v8 = *(_QWORD *)(result + 120);
  v70 = *(_DWORD *)(result + 188);
  v9 = *(_QWORD *)(result + 152) - 4;
  v10 = *(_QWORD *)(result + 144) - 1;
  v11 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v12 = 0;
  else
    v12 = 0xFFFF000000000000;
  v13 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  v71 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v72)
      {
        v22 = (a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        v25 = v71;
        v26 = v73;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v72;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_37;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v25 = v71;
        v26 = v73;
        v23 = v70 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v6 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_37;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v25 = v71;
      v26 = v73;
      v23 = v70 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v25)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v25 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v70;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v7;
    a3 += v8;
    v9 += 4;
    *(_BYTE *)++v10 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v26)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_29;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v26;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_37;
  if (v34 < v32)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v70;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_29:
  if (v23 < 0x400000)
    goto LABEL_37;
  v35 = v11 + SHIDWORD(v24) * (uint64_t)v4;
  v36 = v30 >> 32;
  v37 = v35 + 8 * v36;
  v38 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v37)
    v39 = (unsigned __int16 *)(v35 + 8 * v36);
  else
    v39 = (unsigned __int16 *)v13;
  if (v39 < v38)
    v39 = *(unsigned __int16 **)(result + 32);
  v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    v41 = *(_DWORD *)(v5 + (v31 | v22));
LABEL_40:
    v42 = v41 & 0xF;
    v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        v59 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v13 < (unint64_t)v59)
          v59 = (unsigned __int16 *)v13;
        if (v59 < v38)
          v59 = v38;
        v60 = interpolate_16161616_19469[v43];
        v61 = v43 + 1;
        v57 = v40 - ((v60 & v40) >> v61);
        v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v60) >> v61;
LABEL_62:
        v40 = v57 + v58;
        break;
      case 2:
        v62 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
        if (v13 < (unint64_t)v62)
          v62 = (unsigned __int16 *)v13;
        if (v62 < v38)
          v62 = v38;
        v63 = (v41 >> 28) & 3;
        v40 = v40
            - ((interpolate_16161616_19469[v63] & v40) >> (v63 + 1))
            + (((((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16)) & interpolate_16161616_19469[v63]) >> (v63 + 1));
        break;
      case 3:
        v44 = (unint64_t)HIWORD(v41) << 56;
        v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
        if (v13 < (unint64_t)v45)
          v45 = (unsigned __int16 *)v13;
        if (v45 < v38)
          v45 = v38;
        v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
        v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v13 >= v47)
          v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        else
          v48 = (unsigned __int16 *)v13;
        if (v48 < v38)
          v48 = v38;
        v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
        v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
        if (v13 < (unint64_t)v50)
          v50 = (unsigned __int16 *)v13;
        if (v50 < v38)
          v50 = v38;
        v51 = interpolate_16161616_19469[v43];
        v52 = v43 + 1;
        v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
        v54 = v46
            - ((v51 & v46) >> v52)
            + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52);
        v55 = (v41 >> 28) & 3;
        v56 = interpolate_16161616_19469[v55];
        LOBYTE(v55) = v55 + 1;
        v57 = v53 - ((v53 & v56) >> v55);
        v58 = (v54 & v56) >> v55;
        goto LABEL_62;
    }
  }
  v64 = 0;
  v65 = 0;
  a3 += v8;
  v66 = v72 - a3;
  a2 += v7;
  v67 = v73 - a2;
  while (1)
  {
    *(_DWORD *)(v9 + 4 + 4 * v65) = ((v40 | v12) >> 32) & 0xFFFF0000 | ((2 * (unsigned __int16)v40
                                                                                     + WORD1(v40)
                                                                                     + 4 * WORD1(v40)
                                                                                     + (unsigned __int16)((v40 | v12) >> 32)) >> 3);
    *(_BYTE *)(v10 + 1 + v65) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v65)
      return result;
    if (((v66 | v67 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v10 += v65 + 1;
      v9 = v9 - v64 + 4;
      a4 += ~(_DWORD)v65;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v68 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    v37 = v68 + 8 * (a2 >> 32);
    v38 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v37)
      v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    else
      v69 = (unsigned __int16 *)v13;
    if (v69 < v38)
      v69 = *(unsigned __int16 **)(result + 32);
    v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v10 += v65 + 1;
        v9 = v9 - v64 + 4;
        a4 += ~(_DWORD)v65;
        v23 = -1;
        goto LABEL_40;
      }
    }
    ++v65;
    v64 -= 4;
    a3 += v8;
    v66 -= v8;
    a2 += v7;
    v67 -= v7;
    v23 = -1;
  }
}

uint64_t w16_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  int64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  int v54;
  unint64_t v55;
  char v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  char v61;
  unint64_t v62;
  unint64_t *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v7 = *(_QWORD *)(result + 88);
  v74 = *(_QWORD *)(result + 80);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v72 = *(_DWORD *)(result + 188);
  v10 = *(_QWORD *)(result + 152) - 4;
  v11 = *(_QWORD *)(result + 144) - 1;
  v12 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v13 = 0;
  else
    v13 = 0xFFFF000000000000;
  v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  v73 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v7;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_37;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v72 | v22;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v6 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_37;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v72 | v18;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v73)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v73 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v72;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 4;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v74)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_29;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v74;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_37;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v72;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_29:
  if (v24 < 0x400000)
    goto LABEL_37;
  v34 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  v35 = v29 >> 32;
  v36 = v34 + 8 * v35;
  v37 = *(unint64_t **)(result + 32);
  if (v14 >= v36)
    v38 = (unint64_t *)(v34 + 8 * v35);
  else
    v38 = (unint64_t *)v14;
  if (v38 < v37)
    v38 = *(unint64_t **)(result + 32);
  v39 = *v38;
  if (!v5)
    goto LABEL_69;
  v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_40:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v59 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59)
        v59 = (unint64_t *)v14;
      if (v59 < v37)
        v59 = v37;
      v60 = interpolate_16161616_19469[v42];
      v61 = v42 + 1;
      v57 = v39 - ((v60 & v39) >> v61);
      v62 = (v60 & *v59) >> v61;
LABEL_68:
      v39 = v57 + v62;
      break;
    case 2:
      v63 = (unint64_t *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 53));
      if (v14 < (unint64_t)v63)
        v63 = (unint64_t *)v14;
      if (v63 < v37)
        v63 = v37;
      v64 = (v40 >> 28) & 3;
      v65 = interpolate_16161616_19469[v64];
      v56 = v64 + 1;
      v57 = v39 - ((v65 & v39) >> v56);
      v58 = v65 & *v63;
LABEL_67:
      v62 = v58 >> v56;
      goto LABEL_68;
    case 3:
      v43 = (unint64_t)HIWORD(v40) << 56;
      v44 = (unint64_t *)(v36 + (v43 >> 53));
      if (v14 < (unint64_t)v44)
        v44 = (unint64_t *)v14;
      if (v44 < v37)
        v44 = v37;
      v45 = *v44;
      v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46)
        v47 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      else
        v47 = (unint64_t *)v14;
      if (v47 < v37)
        v47 = v37;
      v48 = *v47;
      v49 = (unint64_t *)(v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49)
        v49 = (unint64_t *)v14;
      if (v49 < v37)
        v49 = v37;
      v50 = interpolate_16161616_19469[v42];
      v51 = v42 + 1;
      v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      v54 = (v40 >> 28) & 3;
      v55 = interpolate_16161616_19469[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      v58 = v53 & v55;
      goto LABEL_67;
  }
LABEL_69:
  v66 = 0;
  v67 = 0;
  a3 += v9;
  v68 = v7 - a3;
  a2 += v8;
  v69 = v74 - a2;
  while (1)
  {
    *(_DWORD *)(v10 + 4 + 4 * v66) = ((v39 | v13) >> 32) & 0xFFFF0000 | ((2 * (unsigned __int16)v39
                                                                                      + WORD1(v39)
                                                                                      + 4 * WORD1(v39)
                                                                                      + (unsigned __int16)((v39 | v13) >> 32)) >> 3);
    *(_BYTE *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v66)
      return result;
    if (((v68 | v69 | (a3 - v6) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v10 = v10 - v67 + 4;
      v11 += v66 + 1;
      a4 += ~(_DWORD)v66;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v70 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    v36 = v70 + 8 * (a2 >> 32);
    v37 = *(unint64_t **)(result + 32);
    if (v14 >= v36)
      v71 = (unint64_t *)(v70 + 8 * (a2 >> 32));
    else
      v71 = (unint64_t *)v14;
    if (v71 < v37)
      v71 = *(unint64_t **)(result + 32);
    v39 = *v71;
    if (v5)
    {
      v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v10 = v10 - v67 + 4;
        v11 += v66 + 1;
        a4 += ~(_DWORD)v66;
        v24 = -1;
        goto LABEL_40;
      }
    }
    v67 -= 4;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    v24 = -1;
  }
}

uint64_t w16_sample_CMYK64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unsigned __int16 *v35;
  unsigned __int16 *v36;
  unint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  unsigned int v40;
  int v41;
  unint64_t v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  int64_t v46;
  unsigned __int16 *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned __int16 *v50;
  unint64_t v51;
  unsigned __int16 *v52;
  unint64_t v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned __int16 *v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int16 *v60;
  unsigned __int16 *v61;
  char *v62;
  uint64_t v63;
  char v64;
  unint64_t v65;
  unint64_t v66;
  unsigned int v67;
  unint64_t v68;
  unsigned int v69;
  unsigned int v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  unsigned int v74;
  unint64_t v75;
  unsigned int v76;
  unsigned __int16 *v77;
  unint64_t v78;
  unsigned int v79;
  unsigned __int16 *v80;
  char *v81;
  uint64_t v82;
  char v83;
  unint64_t v84;
  unint64_t v85;
  int64_t v86;
  unsigned __int16 *v87;
  unint64_t v88;
  unsigned int v89;
  unsigned __int16 *v90;
  unsigned int v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  unsigned __int16 *v98;
  unsigned __int16 *v99;
  unint64_t v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  int v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;

  v6 = *(_QWORD *)(result + 40);
  v7 = *(_QWORD *)(result + 176);
  v103 = *(_QWORD *)(result + 80);
  v104 = *(_QWORD *)(result + 88);
  v116 = *(_QWORD *)(result + 120);
  v117 = *(_QWORD *)(result + 112);
  v8 = (unsigned int *)(*(_QWORD *)(result + 152) - 4);
  v107 = *(_QWORD *)(result + 144) - 1;
  v9 = *(_DWORD *)(result + 260) - 1;
  v114 = *(_DWORD *)(result + 24);
  v111 = *(_QWORD *)(result + 32);
  v10 = *(unsigned int *)(result + 256);
  v102 = *(_DWORD *)(result + 188);
  v109 = *(_DWORD *)(result + 28);
  v110 = v6 + (v9 * v109) + 2 * (v10 - 1);
  v115 = v111 + (v9 * v114) + 8 * v10 - 16;
  v105 = *(_QWORD *)(result + 72);
  v106 = *(_QWORD *)(result + 64);
  v112 = result;
  v113 = v6;
  while (1)
  {
    if (a3 >= v105)
    {
      if (a3 <= v104)
      {
        v21 = ((unint64_t)a3 >> 22) & 0x3C0;
        v22 = 0x3FFFFFFF;
        v23 = a3;
        v14 = a4;
        v15 = v106;
      }
      else
      {
        v17 = *(_QWORD *)(result + 216);
        v18 = *(_QWORD *)(result + 224) + v104;
        v19 = v18 - a3 + (v17 >> 1);
        v14 = a4;
        v15 = v106;
        if (v19 < 1)
          goto LABEL_37;
        if (v19 >= v17)
          LODWORD(v20) = 0x3FFFFFFF;
        else
          v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
        v22 = v102 | v20;
        v23 = v18 - 0x1000000;
        v21 = 448;
      }
    }
    else
    {
      v11 = *(_QWORD *)(result + 216);
      v12 = v105 - *(_QWORD *)(result + 224);
      v13 = a3 - v12 + (v11 >> 1);
      v14 = a4;
      v15 = v106;
      if (v13 < 1)
        goto LABEL_37;
      if (v13 >= v11)
        LODWORD(v16) = 0x3FFFFFFF;
      else
        v16 = (unint64_t)(*(_QWORD *)(result + 232) * v13) >> 32;
      v22 = v102 | v16;
      v23 = v12 + 0x1000000;
      v21 = 512;
    }
    if (a2 >= v15)
    {
      if (a2 <= v103)
      {
        v28 = ((unint64_t)a2 >> 26) & 0x3C;
        v27 = a2;
      }
      else
      {
        v29 = *(_QWORD *)(result + 192);
        v30 = *(_QWORD *)(result + 200) + v103;
        v31 = v30 - a2 + (v29 >> 1);
        if (v31 < 1)
          goto LABEL_37;
        if (v31 < v29)
          v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v31) >> 32) >> 15)) | v102;
        v27 = v30 - 0x1000000;
        v28 = 28;
      }
    }
    else
    {
      v24 = *(_QWORD *)(result + 192);
      v25 = v15 - *(_QWORD *)(result + 200);
      v26 = a2 - v25 + (v24 >> 1);
      if (v26 < 1)
        goto LABEL_37;
      if (v26 < v24)
        v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v26) >> 32) >> 15)) | v102;
      v27 = v25 + 0x1000000;
      v28 = 32;
    }
    if (v22 >= 0x400000)
      break;
LABEL_37:
    v41 = v14 - 1;
    a2 += v117;
    a3 += v116;
    ++v8;
    *(_BYTE *)++v107 = 0;
LABEL_38:
    a4 = v41;
    if (!v41)
      return result;
  }
  v32 = v23 >> 32;
  v33 = v27 >> 32;
  v34 = v111 + SHIDWORD(v23) * (uint64_t)v114 + 8 * (v27 >> 32);
  v35 = *(unsigned __int16 **)(result + 32);
  v36 = (unsigned __int16 *)v115;
  if (v115 >= v34)
    v36 = (unsigned __int16 *)v34;
  if (v36 < v35)
    v36 = *(unsigned __int16 **)(result + 32);
  if (v6)
  {
    v37 = v6 + (int)v32 * (uint64_t)v109 + 2 * v33;
    v38 = *(unsigned __int16 **)(result + 40);
    v39 = (unsigned __int16 *)v110;
    v108 = v37;
    if (v110 >= v37)
      v39 = (unsigned __int16 *)v37;
    if (v39 >= v38)
      v38 = v39;
    v40 = bswap32(*v38) >> 16;
  }
  else
  {
    v108 = 0;
    v40 = 0xFFFF;
  }
  v42 = ((unint64_t)(bswap32(v36[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36[3]) >> 16) << 48) | bswap32(v36[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v36) >> 16);
  if (!v7)
    goto LABEL_100;
  v43 = *(_DWORD *)(v7 + (v28 | v21));
LABEL_44:
  v44 = v43 & 0xF;
  v45 = HIBYTE(v43) & 3;
  switch(v44)
  {
    case 1:
      v77 = (unsigned __int16 *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      if (v115 < (unint64_t)v77)
        v77 = (unsigned __int16 *)v115;
      if (v77 >= v35)
        v35 = v77;
      v78 = ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
      v79 = 0xFFFF;
      if (v6)
      {
        v80 = (unsigned __int16 *)(v108 + SBYTE1(v43) * (uint64_t)v109);
        if (v110 < (unint64_t)v80)
          v80 = (unsigned __int16 *)v110;
        if ((unint64_t)v80 < *(_QWORD *)(result + 40))
          v80 = *(unsigned __int16 **)(result + 40);
        v79 = bswap32(*v80) >> 16;
      }
      v81 = (char *)&interpolate_cmyk64 + 16 * v45;
      v82 = *(_QWORD *)v81;
      v83 = v45 + 1;
      v84 = v42 - ((*(_QWORD *)v81 & v42) >> v83);
      LODWORD(v81) = *((unsigned __int16 *)v81 + 4);
      v74 = v40 - ((v81 & v40) >> v83);
      v85 = (v82 & v78) >> v83;
      v76 = (v81 & v79) >> v83;
      goto LABEL_98;
    case 2:
      v86 = (unint64_t)HIWORD(v43) << 56;
      v87 = (unsigned __int16 *)(v34 + (v86 >> 53));
      if (v115 < (unint64_t)v87)
        v87 = (unsigned __int16 *)v115;
      if (v87 >= v35)
        v35 = v87;
      v88 = ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
      v89 = 0xFFFF;
      if (v6)
      {
        v90 = (unsigned __int16 *)(v108 + (v86 >> 55));
        if (v110 < (unint64_t)v90)
          v90 = (unsigned __int16 *)v110;
        if ((unint64_t)v90 < *(_QWORD *)(result + 40))
          v90 = *(unsigned __int16 **)(result + 40);
        v89 = bswap32(*v90) >> 16;
      }
      v91 = (v43 >> 28) & 3;
      v92 = (char *)&interpolate_cmyk64 + 16 * v91;
      v93 = *(_QWORD *)v92;
      LOBYTE(v91) = v91 + 1;
      v84 = v42 - ((*(_QWORD *)v92 & v42) >> v91);
      LODWORD(v92) = *((unsigned __int16 *)v92 + 4);
      v74 = v40 - ((v92 & v40) >> v91);
      v85 = (v93 & v88) >> v91;
      v76 = (v92 & v89) >> v91;
LABEL_98:
      v42 = v84 + v85;
      goto LABEL_99;
    case 3:
      v46 = (unint64_t)HIWORD(v43) << 56;
      v47 = (unsigned __int16 *)(v34 + (v46 >> 53));
      if (v115 < (unint64_t)v47)
        v47 = (unsigned __int16 *)v115;
      if (v47 < v35)
        v47 = v35;
      v48 = ((unint64_t)(bswap32(v47[2]) >> 16) << 32) | ((unint64_t)(bswap32(v47[3]) >> 16) << 48) | bswap32(v47[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v47) >> 16);
      v49 = v34 + SBYTE1(v43) * (uint64_t)v114;
      if (v115 >= v49)
        v50 = (unsigned __int16 *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      else
        v50 = (unsigned __int16 *)v115;
      if (v50 < v35)
        v50 = v35;
      v51 = ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16);
      v52 = (unsigned __int16 *)(v49 + (v46 >> 53));
      if (v115 < (unint64_t)v52)
        v52 = (unsigned __int16 *)v115;
      if (v52 >= v35)
        v35 = v52;
      v53 = ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
      v54 = 0xFFFF;
      v55 = 0xFFFF;
      v56 = 0xFFFF;
      if (v6)
      {
        v57 = (unsigned __int16 *)(v108 + (v46 >> 55));
        v58 = *(_QWORD *)(result + 40);
        if (v110 < (unint64_t)v57)
          v57 = (unsigned __int16 *)v110;
        if ((unint64_t)v57 < v58)
          v57 = *(unsigned __int16 **)(result + 40);
        v54 = bswap32(*v57) >> 16;
        v59 = v108 + SBYTE1(v43) * (uint64_t)v109;
        if (v110 >= v59)
          v60 = (unsigned __int16 *)(v108 + SBYTE1(v43) * (uint64_t)v109);
        else
          v60 = (unsigned __int16 *)v110;
        if ((unint64_t)v60 < v58)
          v60 = *(unsigned __int16 **)(result + 40);
        v55 = bswap32(*v60) >> 16;
        v61 = (unsigned __int16 *)(v59 + (v46 >> 55));
        if (v110 < (unint64_t)v61)
          v61 = (unsigned __int16 *)v110;
        if ((unint64_t)v61 < v58)
          v61 = *(unsigned __int16 **)(result + 40);
        v56 = bswap32(*v61) >> 16;
      }
      v62 = (char *)&interpolate_cmyk64 + 16 * v45;
      v63 = *(_QWORD *)v62;
      v64 = v45 + 1;
      v65 = v42 - ((*(_QWORD *)v62 & v42) >> v64);
      LODWORD(v62) = *((unsigned __int16 *)v62 + 4);
      v66 = v65 + ((v63 & v51) >> v64);
      v67 = v40 - ((v62 & v40) >> v64) + ((v62 & v55) >> v64);
      v68 = v48 - ((v63 & v48) >> v64) + ((v63 & v53) >> v64);
      v69 = v54 - ((v62 & v54) >> v64) + ((v62 & v56) >> v64);
      v70 = (v43 >> 28) & 3;
      v71 = (char *)&interpolate_cmyk64 + 16 * v70;
      v72 = *(_QWORD *)v71;
      LOBYTE(v70) = v70 + 1;
      v73 = v66 - ((v66 & *(_QWORD *)v71) >> v70);
      LODWORD(v71) = *((unsigned __int16 *)v71 + 4);
      v74 = v67 - ((v67 & v71) >> v70);
      v75 = (v68 & v72) >> v70;
      v76 = (v69 & v71) >> v70;
      v42 = v73 + v75;
LABEL_99:
      v40 = (unsigned __int16)(v74 + v76);
      break;
  }
LABEL_100:
  v94 = 0;
  ++v8;
  v101 = v14;
  v95 = v14 - 1;
  a3 += v116;
  v96 = v104 - a3;
  a2 += v117;
  v97 = v103 - a2;
  while (1)
  {
    CMYK64(v8, v42, v40);
    *(_BYTE *)(v107 + 1 + v94) = v22 >> 22;
    result = v112;
    v6 = v113;
    if (v95 == (_DWORD)v94)
      return result;
    if ((v96 | v97 | (a3 - v105) | (a2 - v106)) < 0)
    {
      v107 += v94 + 1;
      v41 = ~(_DWORD)v94 + v101;
      goto LABEL_38;
    }
    v34 = v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32);
    v35 = *(unsigned __int16 **)(v112 + 32);
    v98 = (unsigned __int16 *)v115;
    if (v115 >= v34)
      v98 = (unsigned __int16 *)(v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32));
    if (v98 < v35)
      v98 = *(unsigned __int16 **)(v112 + 32);
    if (v113)
    {
      v99 = *(unsigned __int16 **)(v112 + 40);
      v100 = v110;
      v108 = v113 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      if (v110 >= v108)
        v100 = v113 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      if (v100 >= (unint64_t)v99)
        v99 = (unsigned __int16 *)v100;
      v40 = bswap32(*v99) >> 16;
    }
    else
    {
      v40 = 0xFFFF;
    }
    v42 = ((unint64_t)(bswap32(v98[2]) >> 16) << 32) | ((unint64_t)(bswap32(v98[3]) >> 16) << 48) | bswap32(v98[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v98) >> 16);
    if (v7)
    {
      v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v107 += v94 + 1;
        v14 = ~(_DWORD)v94 + v101;
        v22 = -1;
        goto LABEL_44;
      }
    }
    ++v94;
    ++v8;
    a3 += v116;
    v96 -= v116;
    a2 += v117;
    v97 -= v117;
    v22 = -1;
  }
}

uint64_t w16_sample_cmyk64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t *v36;
  unint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  int v40;
  int v41;
  unint64_t v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  int64_t v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  int v55;
  int v56;
  int v57;
  unsigned __int16 *v58;
  unint64_t v59;
  unint64_t v60;
  unsigned __int16 *v61;
  unsigned __int16 *v62;
  char *v63;
  uint64_t v64;
  char v65;
  unint64_t v66;
  unint64_t v67;
  unsigned int v68;
  unint64_t v69;
  unsigned int v70;
  unsigned int v71;
  char *v72;
  unint64_t v73;
  unint64_t v74;
  unsigned int v75;
  unint64_t v76;
  unsigned int v77;
  unint64_t *v78;
  unint64_t v79;
  __int16 v80;
  __int16 *v81;
  char *v82;
  char v83;
  int64_t v84;
  unint64_t *v85;
  unint64_t v86;
  int v87;
  unsigned __int16 *v88;
  unsigned int v89;
  char *v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t *v98;
  unsigned __int16 *v99;
  unint64_t v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  int v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;

  v6 = *(_QWORD *)(result + 40);
  v7 = *(_QWORD *)(result + 176);
  v103 = *(_QWORD *)(result + 80);
  v106 = *(_QWORD *)(result + 88);
  v116 = *(_QWORD *)(result + 120);
  v117 = *(_QWORD *)(result + 112);
  v8 = (unsigned int *)(*(_QWORD *)(result + 152) - 4);
  v107 = *(_QWORD *)(result + 144) - 1;
  v9 = *(_DWORD *)(result + 260) - 1;
  v114 = *(_DWORD *)(result + 24);
  v111 = *(_QWORD *)(result + 32);
  v10 = *(unsigned int *)(result + 256);
  v102 = *(_DWORD *)(result + 188);
  v109 = *(_DWORD *)(result + 28);
  v110 = v6 + (v9 * v109) + 2 * (v10 - 1);
  v115 = v111 + (v9 * v114) + 8 * v10 - 16;
  v104 = *(_QWORD *)(result + 72);
  v105 = *(_QWORD *)(result + 64);
  v112 = v6;
  v113 = result;
  while (1)
  {
    if (a3 >= v104)
    {
      if (a3 <= v106)
      {
        v21 = ((unint64_t)a3 >> 22) & 0x3C0;
        v22 = 0x3FFFFFFF;
        v23 = a3;
        v14 = a4;
        v15 = v105;
      }
      else
      {
        v17 = *(_QWORD *)(result + 216);
        v18 = *(_QWORD *)(result + 224) + v106;
        v19 = v18 - a3 + (v17 >> 1);
        v14 = a4;
        v15 = v105;
        if (v19 < 1)
          goto LABEL_37;
        if (v19 >= v17)
          LODWORD(v20) = 0x3FFFFFFF;
        else
          v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
        v22 = v102 | v20;
        v23 = v18 - 0x1000000;
        v21 = 448;
      }
    }
    else
    {
      v11 = *(_QWORD *)(result + 216);
      v12 = v104 - *(_QWORD *)(result + 224);
      v13 = a3 - v12 + (v11 >> 1);
      v14 = a4;
      v15 = v105;
      if (v13 < 1)
        goto LABEL_37;
      if (v13 >= v11)
        LODWORD(v16) = 0x3FFFFFFF;
      else
        v16 = (unint64_t)(*(_QWORD *)(result + 232) * v13) >> 32;
      v22 = v102 | v16;
      v23 = v12 + 0x1000000;
      v21 = 512;
    }
    if (a2 >= v15)
    {
      if (a2 <= v103)
      {
        v28 = ((unint64_t)a2 >> 26) & 0x3C;
        v27 = a2;
      }
      else
      {
        v29 = *(_QWORD *)(result + 192);
        v30 = *(_QWORD *)(result + 200) + v103;
        v31 = v30 - a2 + (v29 >> 1);
        if (v31 < 1)
          goto LABEL_37;
        if (v31 < v29)
          v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v31) >> 32) >> 15)) | v102;
        v27 = v30 - 0x1000000;
        v28 = 28;
      }
    }
    else
    {
      v24 = *(_QWORD *)(result + 192);
      v25 = v15 - *(_QWORD *)(result + 200);
      v26 = a2 - v25 + (v24 >> 1);
      if (v26 < 1)
        goto LABEL_37;
      if (v26 < v24)
        v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v26) >> 32) >> 15)) | v102;
      v27 = v25 + 0x1000000;
      v28 = 32;
    }
    if (v22 >= 0x400000)
      break;
LABEL_37:
    v41 = v14 - 1;
    a2 += v117;
    a3 += v116;
    ++v8;
    *(_BYTE *)++v107 = 0;
LABEL_38:
    a4 = v41;
    if (!v41)
      return result;
  }
  v32 = v23 >> 32;
  v33 = v27 >> 32;
  v34 = v111 + SHIDWORD(v23) * (uint64_t)v114 + 8 * (v27 >> 32);
  v35 = *(unint64_t **)(result + 32);
  v36 = (unint64_t *)v115;
  if (v115 >= v34)
    v36 = (unint64_t *)v34;
  if (v36 < v35)
    v36 = *(unint64_t **)(result + 32);
  if (v6)
  {
    v37 = v6 + (int)v32 * (uint64_t)v109 + 2 * v33;
    v38 = *(unsigned __int16 **)(result + 40);
    v39 = (unsigned __int16 *)v110;
    v108 = v37;
    if (v110 >= v37)
      v39 = (unsigned __int16 *)v37;
    if (v39 >= v38)
      v38 = v39;
    v40 = *v38;
  }
  else
  {
    v108 = 0;
    v40 = 0xFFFF;
  }
  v42 = *v36;
  if (!v7)
    goto LABEL_100;
  v43 = *(_DWORD *)(v7 + (v28 | v21));
LABEL_44:
  v44 = v43 & 0xF;
  v45 = v43 >> 8;
  v46 = HIBYTE(v43) & 3;
  switch(v44)
  {
    case 1:
      v78 = (unint64_t *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      if (v115 < (unint64_t)v78)
        v78 = (unint64_t *)v115;
      if (v78 < v35)
        v78 = v35;
      v79 = *v78;
      v80 = -1;
      if (v6)
      {
        v81 = (__int16 *)(v108 + (char)v45 * (uint64_t)v109);
        if (v110 < (unint64_t)v81)
          v81 = (__int16 *)v110;
        if ((unint64_t)v81 < *(_QWORD *)(result + 40))
          v81 = *(__int16 **)(result + 40);
        v80 = *v81;
      }
      v82 = (char *)&interpolate_cmyk64 + 16 * v46;
      v83 = v46 + 1;
      v42 = v42 - ((*(_QWORD *)v82 & v42) >> v83) + ((*(_QWORD *)v82 & v79) >> v83);
      v77 = v40
          - ((unsigned __int16)(*((_WORD *)v82 + 4) & v40) >> v83)
          + ((unsigned __int16)(*((_WORD *)v82 + 4) & v80) >> v83);
LABEL_99:
      v40 = (unsigned __int16)v77;
      break;
    case 2:
      v84 = (unint64_t)HIWORD(v43) << 56;
      v85 = (unint64_t *)(v34 + (v84 >> 53));
      if (v115 < (unint64_t)v85)
        v85 = (unint64_t *)v115;
      if (v85 >= v35)
        v35 = v85;
      v86 = *v35;
      v87 = 0xFFFF;
      if (v6)
      {
        v88 = (unsigned __int16 *)(v108 + (v84 >> 55));
        if (v110 < (unint64_t)v88)
          v88 = (unsigned __int16 *)v110;
        if ((unint64_t)v88 < *(_QWORD *)(result + 40))
          v88 = *(unsigned __int16 **)(result + 40);
        v87 = *v88;
      }
      v89 = (v43 >> 28) & 3;
      v90 = (char *)&interpolate_cmyk64 + 16 * v89;
      v91 = *(_QWORD *)v90;
      LOBYTE(v89) = v89 + 1;
      v92 = v42 - ((*(_QWORD *)v90 & v42) >> v89);
      LODWORD(v90) = *((unsigned __int16 *)v90 + 4);
      v75 = v40 - ((v90 & v40) >> v89);
      v93 = (v91 & v86) >> v89;
      v77 = (v90 & v87) >> v89;
      v42 = v92 + v93;
LABEL_98:
      LOWORD(v77) = v75 + v77;
      goto LABEL_99;
    case 3:
      v47 = (unint64_t)HIWORD(v43) << 56;
      v48 = (unint64_t *)(v34 + (v47 >> 53));
      if (v115 < (unint64_t)v48)
        v48 = (unint64_t *)v115;
      if (v48 < v35)
        v48 = v35;
      v49 = *v48;
      v50 = v34 + SBYTE1(v43) * (uint64_t)v114;
      if (v115 >= v50)
        v51 = (unint64_t *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      else
        v51 = (unint64_t *)v115;
      if (v51 < v35)
        v51 = v35;
      v52 = *v51;
      v53 = (unint64_t *)(v50 + (v47 >> 53));
      if (v115 < (unint64_t)v53)
        v53 = (unint64_t *)v115;
      if (v53 >= v35)
        v35 = v53;
      v54 = *v35;
      v55 = 0xFFFF;
      v56 = 0xFFFF;
      v57 = 0xFFFF;
      if (v6)
      {
        v58 = (unsigned __int16 *)(v108 + (v47 >> 55));
        v59 = *(_QWORD *)(result + 40);
        if (v110 < (unint64_t)v58)
          v58 = (unsigned __int16 *)v110;
        if ((unint64_t)v58 < v59)
          v58 = *(unsigned __int16 **)(result + 40);
        v55 = *v58;
        v60 = v108 + SBYTE1(v43) * (uint64_t)v109;
        if (v110 >= v60)
          v61 = (unsigned __int16 *)(v108 + SBYTE1(v43) * (uint64_t)v109);
        else
          v61 = (unsigned __int16 *)v110;
        if ((unint64_t)v61 < v59)
          v61 = *(unsigned __int16 **)(result + 40);
        v56 = *v61;
        v62 = (unsigned __int16 *)(v60 + (v47 >> 55));
        if (v110 < (unint64_t)v62)
          v62 = (unsigned __int16 *)v110;
        if ((unint64_t)v62 < v59)
          v62 = *(unsigned __int16 **)(result + 40);
        v57 = *v62;
      }
      v63 = (char *)&interpolate_cmyk64 + 16 * v46;
      v64 = *(_QWORD *)v63;
      v65 = v46 + 1;
      v66 = v42 - ((*(_QWORD *)v63 & v42) >> v65);
      LODWORD(v63) = *((unsigned __int16 *)v63 + 4);
      v67 = v66 + ((v64 & v52) >> v65);
      v68 = v40 - ((v63 & v40) >> v65) + ((v63 & v56) >> v65);
      v69 = v49 - ((v64 & v49) >> v65) + ((v64 & v54) >> v65);
      v70 = v55 - ((v63 & v55) >> v65) + ((v63 & v57) >> v65);
      v71 = (v43 >> 28) & 3;
      v72 = (char *)&interpolate_cmyk64 + 16 * v71;
      v73 = *(_QWORD *)v72;
      LOBYTE(v71) = v71 + 1;
      v74 = v67 - ((v67 & *(_QWORD *)v72) >> v71);
      LODWORD(v72) = *((unsigned __int16 *)v72 + 4);
      v75 = v68 - ((v68 & v72) >> v71);
      v76 = (v69 & v73) >> v71;
      v77 = (v70 & v72) >> v71;
      v42 = v74 + v76;
      goto LABEL_98;
  }
LABEL_100:
  v94 = 0;
  ++v8;
  v101 = v14;
  v95 = v14 - 1;
  a3 += v116;
  v96 = v106 - a3;
  a2 += v117;
  v97 = v103 - a2;
  while (1)
  {
    CMYK64(v8, v42, v40);
    *(_BYTE *)(v107 + 1 + v94) = v22 >> 22;
    v6 = v112;
    result = v113;
    if (v95 == (_DWORD)v94)
      return result;
    if ((v96 | v97 | (a3 - v104) | (a2 - v105)) < 0)
    {
      v107 += v94 + 1;
      v41 = ~(_DWORD)v94 + v101;
      goto LABEL_38;
    }
    v34 = v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32);
    v35 = *(unint64_t **)(v113 + 32);
    v98 = (unint64_t *)v115;
    if (v115 >= v34)
      v98 = (unint64_t *)(v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32));
    if (v98 < v35)
      v98 = *(unint64_t **)(v113 + 32);
    if (v112)
    {
      v99 = *(unsigned __int16 **)(v113 + 40);
      v100 = v110;
      v108 = v112 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      if (v110 >= v108)
        v100 = v112 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      if (v100 >= (unint64_t)v99)
        v99 = (unsigned __int16 *)v100;
      v40 = *v99;
    }
    else
    {
      v40 = 0xFFFF;
    }
    v42 = *v98;
    if (v7)
    {
      v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v107 += v94 + 1;
        v14 = ~(_DWORD)v94 + v101;
        v22 = -1;
        goto LABEL_44;
      }
    }
    ++v8;
    ++v94;
    a3 += v116;
    v96 -= v116;
    a2 += v117;
    v97 -= v117;
    v22 = -1;
  }
}

uint64_t w16_sample_WF(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int *v41;
  unint64_t v42;
  unsigned int *v43;
  unsigned int *v44;
  float v45;
  float v46;
  unsigned int v47;
  int v48;
  int v49;
  unint64_t v50;
  unsigned int *v51;
  float v52;
  unsigned int *v53;
  float v54;
  float v55;
  float v56;
  unint64_t v57;
  unint64_t v58;
  unsigned int *v59;
  unsigned int *v60;
  float v61;
  float v62;
  unsigned int *v63;
  float v64;
  float v65;
  unsigned int *v66;
  unsigned int *v67;
  unsigned int *v68;
  float v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  unsigned int *v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v84 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v82 = *(_DWORD *)(result + 188);
  v86 = *(_QWORD *)(result + 88);
  v87 = *(_QWORD *)(result + 152) - 4;
  v11 = *(_QWORD *)(result + 144) - 1;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v14 = v5 + (v12 * v7) + 4 * (v13 - 1);
  v15 = v4 + (v12 * v6) + 4 * v13 - 4;
  v85 = *(_QWORD *)(result + 72);
  v83 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v85)
    {
      if (a3 <= v86)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v83;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v86;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_39;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v83;
        v25 = v82 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v85 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_39;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v83;
      v25 = v82 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v82;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v10;
    a3 += v9;
    v87 += 4;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v84)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_26;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v84;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_39;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v82;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_26:
  if (v25 < 0x400000)
    goto LABEL_39;
  v36 = v26 >> 32;
  v37 = v4 + SHIDWORD(v26) * (uint64_t)v6;
  v38 = (v31 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v39 = v37 + v38;
  v40 = *(unsigned int **)(result + 32);
  if (v15 >= v37 + v38)
    v41 = (unsigned int *)(v37 + v38);
  else
    v41 = (unsigned int *)v15;
  if (v41 < v40)
    v41 = *(unsigned int **)(result + 32);
  if (v5)
  {
    v42 = v5 + (int)v36 * (uint64_t)v7 + v38;
    v43 = *(unsigned int **)(result + 40);
    if (v14 >= v42)
      v44 = (unsigned int *)v42;
    else
      v44 = (unsigned int *)v14;
    if (v44 >= v43)
      v43 = v44;
    v45 = COERCE_FLOAT(bswap32(*v43));
  }
  else
  {
    v42 = 0;
    v45 = 1.0;
  }
  v46 = COERCE_FLOAT(bswap32(*v41));
  if (v8)
  {
    v47 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_45:
    v48 = v47 & 0xF;
    v49 = HIBYTE(v47) & 3;
    if (v48 == 1)
    {
      v63 = (unsigned int *)(v39 + SBYTE1(v47) * (uint64_t)v6);
      if (v15 < (unint64_t)v63)
        v63 = (unsigned int *)v15;
      if (v63 < v40)
        v63 = v40;
      v64 = COERCE_FLOAT(bswap32(*v63));
      v65 = 1.0;
      if (v5)
      {
        v66 = (unsigned int *)(v42 + SBYTE1(v47) * (uint64_t)v7);
        if (v14 < (unint64_t)v66)
          v66 = (unsigned int *)v14;
        if ((unint64_t)v66 < *(_QWORD *)(result + 40))
          v66 = *(unsigned int **)(result + 40);
        v65 = COERCE_FLOAT(bswap32(*v66));
      }
    }
    else
    {
      if (v48 != 2)
      {
        if (v48 == 3)
        {
          v50 = v39 + 4 * SBYTE2(v47);
          if (v15 >= v50)
            v51 = (unsigned int *)(v39 + 4 * SBYTE2(v47));
          else
            v51 = (unsigned int *)v15;
          if (v51 < v40)
            v51 = v40;
          v52 = COERCE_FLOAT(bswap32(*v51));
          v53 = (unsigned int *)(v50 + SBYTE1(v47) * (uint64_t)v6);
          if (v15 < (unint64_t)v53)
            v53 = (unsigned int *)v15;
          if (v53 < v40)
            v53 = v40;
          v54 = COERCE_FLOAT(bswap32(*v53));
          v55 = 1.0;
          v56 = 1.0;
          if (v5)
          {
            v57 = v42 + 4 * SBYTE2(v47);
            v58 = *(_QWORD *)(result + 40);
            if (v14 >= v57)
              v59 = (unsigned int *)(v42 + 4 * SBYTE2(v47));
            else
              v59 = (unsigned int *)v14;
            if ((unint64_t)v59 < v58)
              v59 = *(unsigned int **)(result + 40);
            v55 = COERCE_FLOAT(bswap32(*v59));
            v60 = (unsigned int *)(v57 + SBYTE1(v47) * (uint64_t)v7);
            if (v14 < (unint64_t)v60)
              v60 = (unsigned int *)v14;
            if ((unint64_t)v60 < v58)
              v60 = *(unsigned int **)(result + 40);
            v56 = COERCE_FLOAT(bswap32(*v60));
          }
          v61 = interpolate_waf[2 * v49 + 1];
          v62 = interpolate_waf[2 * ((v47 >> 28) & 3) + 1];
          v46 = (float)((float)((float)(v46 - (float)(v46 * v61)) + (float)(v52 * v61))
                      - (float)((float)((float)(v46 - (float)(v46 * v61)) + (float)(v52 * v61)) * v62))
              + (float)((float)((float)(v52 - (float)(v52 * v61)) + (float)(v54 * v61)) * v62);
          v45 = (float)((float)((float)(v45 - (float)(v45 * v61)) + (float)(v55 * v61))
                      - (float)((float)((float)(v45 - (float)(v45 * v61)) + (float)(v55 * v61)) * v62))
              + (float)((float)((float)(v55 - (float)(v55 * v61)) + (float)(v56 * v61)) * v62);
        }
        goto LABEL_91;
      }
      v67 = (unsigned int *)(v39 + 4 * SBYTE2(v47));
      if (v15 < (unint64_t)v67)
        v67 = (unsigned int *)v15;
      if (v67 < v40)
        v67 = v40;
      v64 = COERCE_FLOAT(bswap32(*v67));
      v65 = 1.0;
      if (v5)
      {
        v68 = (unsigned int *)(v42 + 4 * SBYTE2(v47));
        if (v14 < (unint64_t)v68)
          v68 = (unsigned int *)v14;
        if ((unint64_t)v68 < *(_QWORD *)(result + 40))
          v68 = *(unsigned int **)(result + 40);
        v65 = COERCE_FLOAT(bswap32(*v68));
      }
      v49 = (v47 >> 28) & 3;
    }
    v69 = interpolate_waf[2 * v49 + 1];
    v46 = (float)(v46 - (float)(v46 * v69)) + (float)(v64 * v69);
    v45 = (float)(v45 - (float)(v45 * v69)) + (float)(v65 * v69);
  }
LABEL_91:
  v70 = 0;
  v71 = 0;
  a3 += v9;
  v72 = v86 - a3;
  a2 += v10;
  v73 = v84 - a2;
  while (1)
  {
    if (v45 <= 0.0)
    {
      v76 = 0;
    }
    else
    {
      v74 = (int)(float)((float)(v45 * 65535.0) + 0.5);
      if (v45 > 1.0)
      {
        v74 = 0xFFFF;
        v45 = 1.0;
      }
      v75 = v74;
      if (v46 <= v45)
      {
        if (v46 >= 0.0)
          v75 = (int)(float)((float)(v46 * 65535.0) + 0.5);
        else
          v75 = 0;
      }
      v76 = v75 | (v74 << 16);
    }
    *(_DWORD *)(v87 + 4 + 4 * v71) = v76;
    *(_BYTE *)(v11 + 1 + v71) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v71)
      return result;
    if ((v72 | v73 | (a3 - v85) | (a2 - v83)) < 0)
    {
      v11 += v71 + 1;
      v87 = v87 - v70 + 4;
      a4 += ~(_DWORD)v71;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v77 = v4 + SHIDWORD(a3) * (uint64_t)v6;
    v78 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v39 = v77 + v78;
    v40 = *(unsigned int **)(result + 32);
    if (v15 >= v77 + v78)
      v79 = (unsigned int *)(v77 + v78);
    else
      v79 = (unsigned int *)v15;
    if (v79 < v40)
      v79 = *(unsigned int **)(result + 32);
    if (v5)
    {
      v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v78;
      v80 = *(unsigned int **)(result + 40);
      if (v14 >= v42)
        v81 = (unsigned int *)v42;
      else
        v81 = (unsigned int *)v14;
      if (v81 >= v80)
        v80 = v81;
      v45 = COERCE_FLOAT(bswap32(*v80));
    }
    else
    {
      v45 = 1.0;
    }
    v46 = COERCE_FLOAT(bswap32(*v79));
    if (v8)
    {
      v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        v11 += v71 + 1;
        v87 = v87 - v70 + 4;
        a4 += ~(_DWORD)v71;
        v25 = -1;
        goto LABEL_45;
      }
    }
    ++v71;
    v70 -= 4;
    a3 += v9;
    v72 -= v9;
    a2 += v10;
    v73 -= v10;
    v25 = -1;
  }
}

uint64_t w16_sample_Wf(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  float *v40;
  float *v41;
  unint64_t v42;
  float *v43;
  float *v44;
  float v45;
  uint64_t v46;
  float v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  int v51;
  float *v52;
  float *v53;
  float v54;
  float *v55;
  float v56;
  float v57;
  float v58;
  unint64_t v59;
  unint64_t v60;
  float *v61;
  float *v62;
  float v63;
  float v64;
  int v65;
  float *v66;
  float v67;
  float *v68;
  float v69;
  float *v70;
  float v71;
  float *v72;
  float v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  unint64_t v82;
  float *v83;
  float *v84;
  float *v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v88 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v86 = *(_DWORD *)(result + 188);
  v90 = *(_QWORD *)(result + 88);
  v91 = *(_QWORD *)(result + 152) - 4;
  v11 = *(_QWORD *)(result + 144) - 1;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v14 = v5 + (v12 * v7) + 4 * (v13 - 1);
  v15 = v4 + (v12 * v6) + 4 * v13 - 4;
  v89 = *(_QWORD *)(result + 72);
  v87 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v89)
    {
      if (a3 <= v90)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v87;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v90;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_39;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v87;
        v25 = v86 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v89 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_39;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v87;
      v25 = v86 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v86;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v10;
    a3 += v9;
    v91 += 4;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v88)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_26;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v88;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_39;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v86;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_26:
  if (v25 < 0x400000)
    goto LABEL_39;
  v36 = v26 >> 32;
  v37 = v4 + SHIDWORD(v26) * (uint64_t)v6;
  v38 = (v31 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v39 = v37 + v38;
  v40 = *(float **)(result + 32);
  if (v15 >= v37 + v38)
    v41 = (float *)(v37 + v38);
  else
    v41 = (float *)v15;
  if (v41 < v40)
    v41 = *(float **)(result + 32);
  if (v5)
  {
    v42 = v5 + (int)v36 * (uint64_t)v7 + v38;
    v43 = *(float **)(result + 40);
    if (v14 >= v42)
      v44 = (float *)v42;
    else
      v44 = (float *)v14;
    if (v44 >= v43)
      v43 = v44;
    v45 = *v43;
  }
  else
  {
    v42 = 0;
    v45 = 1.0;
  }
  v46 = v88;
  v47 = *v41;
  if (v8)
  {
    v48 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_45:
    v49 = v48 & 0xF;
    v50 = v48 >> 8;
    v51 = HIBYTE(v48) & 3;
    if (v49 == 1)
    {
      v65 = SBYTE1(v48);
      v66 = (float *)(v39 + (char)v50 * (uint64_t)v6);
      if (v15 < (unint64_t)v66)
        v66 = (float *)v15;
      if (v66 < v40)
        v66 = v40;
      v67 = 1.0;
      if (v5)
      {
        v68 = (float *)(v42 + v65 * (uint64_t)v7);
        if (v14 < (unint64_t)v68)
          v68 = (float *)v14;
        if ((unint64_t)v68 < *(_QWORD *)(result + 40))
          v68 = *(float **)(result + 40);
        v67 = *v68;
      }
      v69 = interpolate_waf[2 * v51 + 1];
      v47 = (float)(v47 - (float)(v47 * v69)) + (float)(*v66 * v69);
      v45 = (float)(v45 - (float)(v45 * v69)) + (float)(v67 * v69);
LABEL_80:
      v46 = v88;
    }
    else
    {
      if (v49 != 2)
      {
        if (v49 == 3)
        {
          v52 = (float *)(v39 + 4 * SBYTE2(v48));
          if (v15 >= (unint64_t)v52)
            v53 = v52;
          else
            v53 = (float *)v15;
          if (v53 < v40)
            v53 = v40;
          v54 = *v53;
          v55 = (float *)((char *)v52 + SBYTE1(v48) * (uint64_t)v6);
          if (v15 < (unint64_t)v55)
            v55 = (float *)v15;
          if (v55 < v40)
            v55 = v40;
          v56 = *v55;
          v57 = 1.0;
          v58 = 1.0;
          if (v5)
          {
            v59 = v42 + 4 * SBYTE2(v48);
            v60 = *(_QWORD *)(result + 40);
            if (v14 >= v59)
              v61 = (float *)(v42 + 4 * SBYTE2(v48));
            else
              v61 = (float *)v14;
            if ((unint64_t)v61 < v60)
              v61 = *(float **)(result + 40);
            v57 = *v61;
            v62 = (float *)(v59 + SBYTE1(v48) * (uint64_t)v7);
            if (v14 < (unint64_t)v62)
              v62 = (float *)v14;
            if ((unint64_t)v62 < v60)
              v62 = *(float **)(result + 40);
            v58 = *v62;
          }
          v63 = interpolate_waf[2 * v51 + 1];
          v64 = interpolate_waf[2 * ((v48 >> 28) & 3) + 1];
          v47 = (float)((float)((float)(v47 - (float)(v47 * v63)) + (float)(v54 * v63))
                      - (float)((float)((float)(v47 - (float)(v47 * v63)) + (float)(v54 * v63)) * v64))
              + (float)((float)((float)(v54 - (float)(v54 * v63)) + (float)(v56 * v63)) * v64);
          v45 = (float)((float)((float)(v45 - (float)(v45 * v63)) + (float)(v57 * v63))
                      - (float)((float)((float)(v45 - (float)(v45 * v63)) + (float)(v57 * v63)) * v64))
              + (float)((float)((float)(v57 - (float)(v57 * v63)) + (float)(v58 * v63)) * v64);
        }
        goto LABEL_80;
      }
      v70 = (float *)(v39 + 4 * SBYTE2(v48));
      if (v15 < (unint64_t)v70)
        v70 = (float *)v15;
      if (v70 < v40)
        v70 = v40;
      v71 = 1.0;
      v46 = v88;
      if (v5)
      {
        v72 = (float *)(v42 + 4 * SBYTE2(v48));
        if (v14 < (unint64_t)v72)
          v72 = (float *)v14;
        if ((unint64_t)v72 < *(_QWORD *)(result + 40))
          v72 = *(float **)(result + 40);
        v71 = *v72;
      }
      v73 = interpolate_waf[2 * ((v48 >> 28) & 3) + 1];
      v47 = (float)(v47 - (float)(v47 * v73)) + (float)(*v70 * v73);
      v45 = (float)(v45 - (float)(v45 * v73)) + (float)(v71 * v73);
    }
  }
  v74 = 0;
  v75 = 0;
  a3 += v9;
  v76 = v90 - a3;
  a2 += v10;
  v77 = v46 - a2;
  while (1)
  {
    if (v45 <= 0.0)
    {
      v80 = 0;
    }
    else
    {
      v78 = (int)(float)((float)(v45 * 65535.0) + 0.5);
      if (v45 > 1.0)
      {
        v78 = 0xFFFF;
        v45 = 1.0;
      }
      v79 = v78;
      if (v47 <= v45)
      {
        if (v47 >= 0.0)
          v79 = (int)(float)((float)(v47 * 65535.0) + 0.5);
        else
          v79 = 0;
      }
      v80 = v79 | (v78 << 16);
    }
    *(_DWORD *)(v91 + 4 + 4 * v75) = v80;
    *(_BYTE *)(v11 + 1 + v75) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v75)
      return result;
    if ((v76 | v77 | (a3 - v89) | (a2 - v87)) < 0)
    {
      v11 += v75 + 1;
      v91 = v91 - v74 + 4;
      a4 += ~(_DWORD)v75;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v81 = v4 + SHIDWORD(a3) * (uint64_t)v6;
    v82 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v39 = v81 + v82;
    v40 = *(float **)(result + 32);
    if (v15 >= v81 + v82)
      v83 = (float *)(v81 + v82);
    else
      v83 = (float *)v15;
    if (v83 < v40)
      v83 = *(float **)(result + 32);
    if (v5)
    {
      v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v82;
      v84 = *(float **)(result + 40);
      if (v14 >= v42)
        v85 = (float *)v42;
      else
        v85 = (float *)v14;
      if (v85 >= v84)
        v84 = v85;
      v45 = *v84;
    }
    else
    {
      v45 = 1.0;
    }
    v47 = *v83;
    if (v8)
    {
      v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v48 & 0xF) != 0)
      {
        v11 += v75 + 1;
        v91 = v91 - v74 + 4;
        a4 += ~(_DWORD)v75;
        v25 = -1;
        goto LABEL_45;
      }
    }
    ++v75;
    v74 -= 4;
    a3 += v9;
    v76 -= v9;
    a2 += v10;
    v77 -= v10;
    v25 = -1;
  }
}

unsigned int *CMYK64(unsigned int *result, unint64_t a2, int a3)
{
  int v3;
  int v4;
  int v5;

  v3 = (unsigned __int16)a3 - (HIWORD(a2) + (unsigned __int16)a2);
  v4 = (unsigned __int16)a3 - (HIWORD(a2) + WORD1(a2));
  v5 = (unsigned __int16)a3 - (HIWORD(a2) + WORD2(a2));
  *result = (((v5 & ~(v5 >> 31)) + (v4 & ~(v4 >> 31)) + 2 * (v3 & ~(v3 >> 31)) + 4 * (v4 & ~(v4 >> 31))) >> 3) | (a3 << 16);
  return result;
}

_DWORD *w16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8;

  v8 = PIXELCONSTANT_8085(*(float **)(*(_QWORD *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_185004DB0;
    a2[6] = 0;
    *((_QWORD *)a2 + 2) = 1;
    a2[12] = (unsigned __int16)v8 | ((unsigned __int16)v8 << 16);
    *((_QWORD *)a2 + 4) = a2 + 12;
    if (HIWORD(v8) == 0xFFFF)
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = v8 & 0xFFFF0000 | HIWORD(v8);
      *((_QWORD *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t w16_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unint64_t v3;
  int8x8_t v4;
  char *v5;
  uint64_t v6;
  int v7;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint16x4_t *v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  unsigned int v26;
  size_t v27;
  _BYTE *v28;
  _BYTE *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint16x4_t *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  unint64_t v41;
  unint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  void *v48;
  _WORD *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int v62;
  _BYTE *v63;
  _WORD *v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  int v74;
  int *v75;
  int v76;
  signed int v77;
  int *v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  int v92;
  int v93;
  unsigned int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  unsigned int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  int v113;
  uint64_t v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  unsigned int v128;
  int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  int v133;
  int v134;
  unsigned int v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  int64_t v140;
  unint64_t v141;
  int v142;
  int v143;
  unsigned int v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  int64_t v148;
  unint64_t v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  uint64_t v166;
  int v167;
  int v168;
  unsigned int v169;
  uint64_t v170;
  int64_t v171;
  unint64_t v172;
  unint64_t v173;
  int64_t v174;
  unint64_t v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  __int16 v183;
  int v184;
  unint64_t v185;
  int16x4_t v186;
  unsigned int v187;
  uint16x4_t v188;
  int32x4_t v189;
  unsigned int v190;
  uint32x4_t v191;
  int v192;
  unsigned int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  unint64_t v199;
  uint64_t v200;
  _BYTE *v201;
  unsigned int v202;
  uint64_t v203;
  char *v204;
  uint64_t v205;
  int v206;
  char *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  int v212;
  int v213;
  int v214;
  unsigned int v215;
  _WORD *v216;
  uint64_t v217;
  _WORD *v218;
  BOOL v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t v222;
  uint64_t v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  _WORD *v229;
  uint64_t v230;
  _WORD *v231;
  BOOL v232;
  uint64_t v233;
  unint64_t v234;
  uint64_t v235;
  int v236;
  int v237;
  int v238;
  unsigned int v239;
  int v240;
  _WORD *v241;
  uint64_t v242;
  _WORD *v243;
  BOOL v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  uint64_t v248;
  int v249;
  int v250;
  int v251;
  int v252;
  unsigned int v253;
  _WORD *v254;
  uint64_t v255;
  _WORD *v256;
  BOOL v257;
  uint64_t v258;
  unint64_t v259;
  uint64_t v260;
  int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  int v266;
  _WORD *v267;
  uint64_t v268;
  _WORD *v269;
  BOOL v270;
  uint64_t v271;
  unint64_t v272;
  uint64_t v273;
  uint64_t v274;
  int v275;
  int v276;
  int v277;
  int v278;
  int v279;
  _WORD *v280;
  uint64_t v281;
  _WORD *v282;
  BOOL v283;
  uint64_t v284;
  unint64_t v285;
  uint64_t v286;
  uint64_t v287;
  int v288;
  int v289;
  int v290;
  int v291;
  int v292;
  _WORD *v293;
  uint64_t v294;
  _WORD *v295;
  BOOL v296;
  uint64_t v297;
  unint64_t v298;
  uint64_t v299;
  uint64_t v300;
  int v301;
  int v302;
  int v303;
  int v304;
  unsigned int v305;
  _WORD *v306;
  uint64_t v307;
  _WORD *v308;
  BOOL v309;
  uint64_t v310;
  unint64_t v311;
  uint64_t v312;
  uint64_t v313;
  int v314;
  int v315;
  int v316;
  int v317;
  unsigned int v318;
  _WORD *v319;
  uint64_t v320;
  _WORD *v321;
  BOOL v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  int v326;
  int v327;
  int v328;
  int v329;
  int v330;
  unsigned int v331;
  _WORD *v332;
  uint64_t v333;
  _WORD *v334;
  BOOL v335;
  uint64_t v336;
  unint64_t v337;
  uint64_t v338;
  int v339;
  int v340;
  int v341;
  unsigned int v342;
  unsigned int v343;
  _WORD *v344;
  uint64_t v345;
  _WORD *v346;
  BOOL v347;
  uint64_t v348;
  unint64_t v349;
  uint64_t v350;
  int v351;
  int v352;
  unsigned int v353;
  unsigned int v354;
  unint64_t v355;
  unint64_t v356;
  unint64_t v357;
  int64_t v358;
  unint64_t v359;
  _WORD *v360;
  uint64_t v361;
  _WORD *v362;
  BOOL v363;
  uint64_t v364;
  unint64_t v365;
  uint64_t v366;
  int v367;
  int v368;
  unsigned int v369;
  unsigned int v370;
  unint64_t v371;
  unint64_t v372;
  unint64_t v373;
  int64_t v374;
  unint64_t v375;
  _WORD *v376;
  uint64_t v377;
  _WORD *v378;
  BOOL v379;
  uint64_t v380;
  unint64_t v381;
  uint64_t v382;
  uint64_t v383;
  int v384;
  uint64_t v385;
  int v386;
  unint64_t v387;
  unsigned int v388;
  int v389;
  __int16 v390;
  _WORD *v391;
  uint64_t v392;
  _WORD *v393;
  BOOL v394;
  uint64_t v395;
  unint64_t v396;
  uint64_t v397;
  uint64_t v398;
  int v399;
  uint64_t v400;
  int v401;
  unint64_t v402;
  unsigned int v403;
  int v404;
  __int16 v405;
  _WORD *v406;
  uint64_t v407;
  _WORD *v408;
  BOOL v409;
  uint64_t v410;
  unint64_t v411;
  uint64_t v412;
  uint64_t v413;
  int v414;
  uint64_t v415;
  int v416;
  unint64_t v417;
  unsigned int v418;
  int v419;
  __int16 v420;
  _WORD *v421;
  uint64_t v422;
  _WORD *v423;
  BOOL v424;
  uint64_t v425;
  unint64_t v426;
  uint64_t v427;
  uint64_t v428;
  int v429;
  uint64_t v430;
  int v431;
  unint64_t v432;
  unsigned int v433;
  int v434;
  __int16 v435;
  _WORD *v436;
  uint64_t v437;
  _WORD *v438;
  BOOL v439;
  uint64_t v440;
  unint64_t v441;
  uint64_t v442;
  uint64_t v443;
  int v444;
  uint64_t v445;
  int v446;
  unint64_t v447;
  unsigned int v448;
  int v449;
  __int16 v450;
  _WORD *v451;
  uint64_t v452;
  _WORD *v453;
  BOOL v454;
  uint64_t v455;
  unint64_t v456;
  uint64_t v457;
  uint64_t v458;
  int v459;
  uint64_t v460;
  int v461;
  unint64_t v462;
  unsigned int v463;
  int v464;
  __int16 v465;
  _WORD *v466;
  uint64_t v467;
  _WORD *v468;
  BOOL v469;
  uint64_t v470;
  unint64_t v471;
  uint64_t v472;
  uint64_t v473;
  int v474;
  uint64_t v475;
  int v476;
  unint64_t v477;
  unsigned int v478;
  int v479;
  __int16 v480;
  _WORD *v481;
  uint64_t v482;
  _WORD *v483;
  BOOL v484;
  uint64_t v485;
  unint64_t v486;
  uint64_t v487;
  uint64_t v488;
  int v489;
  uint64_t v490;
  int v491;
  unint64_t v492;
  unsigned int v493;
  int v494;
  __int16 v495;
  _WORD *v496;
  uint64_t v497;
  _WORD *v498;
  BOOL v499;
  uint64_t v500;
  unint64_t v501;
  uint64_t v502;
  int v503;
  int v504;
  unsigned int v505;
  unsigned int v506;
  uint64_t v507;
  uint64_t v508;
  int64_t v509;
  unint64_t v510;
  unint64_t v511;
  int64_t v512;
  unint64_t v513;
  _WORD *v514;
  uint64_t v515;
  _WORD *v516;
  BOOL v517;
  uint64_t v518;
  unint64_t v519;
  uint64_t v520;
  uint64_t v521;
  int v522;
  uint64_t v523;
  int v524;
  unint64_t v525;
  unsigned int v526;
  int v527;
  __int16 v528;
  _WORD *v529;
  uint64_t v530;
  _WORD *v531;
  BOOL v532;
  uint64_t v533;
  unint64_t v534;
  uint64_t v535;
  uint64_t v536;
  int v537;
  uint64_t v538;
  int v539;
  unint64_t v540;
  unsigned int v541;
  int v542;
  __int16 v543;
  _WORD *v544;
  uint64_t v545;
  _WORD *v546;
  BOOL v547;
  uint64_t v548;
  unint64_t v549;
  uint64_t v550;
  uint64_t v551;
  int v552;
  uint64_t v553;
  int v554;
  unint64_t v555;
  unsigned int v556;
  unsigned int v557;
  int v558;
  __int16 v559;
  _WORD *v560;
  uint64_t v561;
  _WORD *v562;
  BOOL v563;
  uint64_t v564;
  unint64_t v565;
  uint64_t v566;
  uint64_t v567;
  int v568;
  uint64_t v569;
  uint64_t v570;
  int v571;
  unsigned int v572;
  unint64_t v573;
  uint64_t v574;
  int v575;
  unsigned int v576;
  unint64_t v577;
  _WORD *v578;
  uint64_t v579;
  _WORD *v580;
  BOOL v581;
  uint64_t v582;
  unint64_t v583;
  uint64_t v584;
  uint64_t v585;
  int v586;
  int v587;
  int v588;
  unsigned int v589;
  _WORD *v590;
  uint64_t v591;
  _WORD *v592;
  BOOL v593;
  uint64_t v594;
  unint64_t v595;
  uint64_t v596;
  int v597;
  int v598;
  unsigned int v599;
  _WORD *v600;
  uint64_t v601;
  _WORD *v602;
  BOOL v603;
  uint64_t v604;
  unint64_t v605;
  uint64_t v606;
  uint64_t v607;
  int v608;
  int v609;
  unsigned int v610;
  _WORD *v611;
  uint64_t v612;
  _WORD *v613;
  BOOL v614;
  uint64_t v615;
  unint64_t v616;
  uint64_t v617;
  int v618;
  int v619;
  int v620;
  unsigned int v621;
  _WORD *v622;
  uint64_t v623;
  _WORD *v624;
  BOOL v625;
  uint64_t v626;
  unint64_t v627;
  uint64_t v628;
  int v629;
  int v630;
  int v631;
  int v632;
  _WORD *v633;
  uint64_t v634;
  _WORD *v635;
  BOOL v636;
  uint64_t v637;
  unint64_t v638;
  uint64_t v639;
  uint64_t v640;
  int v641;
  int v642;
  _WORD *v643;
  uint64_t v644;
  _WORD *v645;
  BOOL v646;
  uint64_t v647;
  unint64_t v648;
  uint64_t v649;
  uint8x8_t v650;
  int v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  int v655;
  int v656;
  _WORD *v657;
  uint64_t v658;
  _WORD *v659;
  BOOL v660;
  uint64_t v661;
  unint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  int v666;
  int v667;
  _WORD *v668;
  uint64_t v669;
  _WORD *v670;
  BOOL v671;
  uint64_t v672;
  unint64_t v673;
  uint64_t v674;
  int v675;
  int v676;
  _WORD *v677;
  uint64_t v678;
  _WORD *v679;
  BOOL v680;
  uint64_t v681;
  unint64_t v682;
  uint64_t v683;
  int v684;
  int v685;
  unint64_t v686;
  unint64_t v687;
  uint64_t v688;
  int v689;
  int v690;
  unint64_t v691;
  uint64_t v692;
  unint64_t v693;
  unint64_t v694;
  uint64_t v695;
  unint64_t v696;
  char *v697;
  int v698;
  uint64_t v699;
  uint64_t v700;
  char *v701;
  uint64_t v702;
  char *v703;
  unint64_t v704;
  uint64_t v705;
  uint64_t v706;
  char *v707;
  uint64_t v708;
  int v709;
  int v710;
  unint64_t v711;
  char *v712;
  unint64_t v713;
  unint64_t v714;
  int v715;
  uint64_t v716;
  unint64_t v717;
  char *v718;
  int v719;
  int v720;
  int v721;
  uint64_t v722;
  int v723;
  int v724;
  int v725;
  int v726;
  int v727;
  int v728;
  int v729;
  int v730;
  int v731;
  int v732;
  int v733;
  int v734;
  unint64_t v735;
  _WORD *v736;
  unint64_t v737;
  unint64_t v738;
  unint64_t v739;
  unsigned __int16 v740;
  unint64_t v741;
  unint64_t v742;
  int v743;
  uint64_t v744;
  int v745;
  unsigned int v746;
  char *v747;
  int v748[2];
  int v749[2];
  int v750;
  char *v751;
  unint64_t v752;
  int v753[2];
  int v754[2];
  unsigned int v755;
  uint64_t v756;
  unint64_t v757;
  unint64_t v758;
  uint64_t v759;
  uint64_t v760;
  int v761[4];
  __int128 v762;
  __int128 v763;
  __int128 v764;
  __int128 v765;
  __int128 v766;
  __int128 v767;
  __int128 v768;
  __int128 v769;
  __int128 v770;
  _DWORD v771[1024];
  uint64_t v772;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v772 = *MEMORY[0x1E0C80C00];
  v5 = *(char **)(v3 + 96);
  v6 = *(_QWORD *)(v3 + 48);
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v5 == 0)
                 + 4 * (v6 == 0));
  if (v7 > 27)
    return 0xFFFFFFFFLL;
  v9 = v3;
  v10 = *(unsigned int *)(v3 + 4);
  v11 = v10 - 1;
  if ((int)v10 < 1)
    return 0;
  v12 = *(_DWORD *)(v3 + 8);
  v13 = (v12 - 1);
  if (v12 < 1)
    return 0;
  v14 = *(uint16x4_t **)(v3 + 136);
  v715 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                   + 16 * *(_DWORD *)v3
                   + 8 * (v5 == 0)
                   + 4 * (v6 == 0));
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v14)
  {
    v16 = *(_DWORD *)v3 & 0xFF00;
    if (v16 == 1024)
    {
      v771[0] = *(_DWORD *)(v3 + 4);
      v761[0] = v12;
      v17 = **(unsigned __int16 **)(v3 + 88);
      if (v5)
        v18 = *(unsigned __int16 *)v5;
      else
        v18 = 0xFFFF;
      v30 = (unint64_t)*(int *)(v3 + 28) >> 1;
      v32 = *(int *)(v3 + 12);
      v31 = *(int *)(v3 + 16);
      if (v6)
      {
        v33 = (unint64_t)*(int *)(v3 + 32) >> 1;
        v751 = (char *)(v6 + 2 * (v32 + v33 * v31));
        v746 = 1;
      }
      else
      {
        v33 = 0;
        v751 = 0;
        v746 = 0;
      }
      v740 = ~(_WORD)v18;
      v742 = v33;
      v37 = (uint16x4_t *)(*(_QWORD *)(v3 + 40) + 2 * (v32 + v31 * v30));
      *(_QWORD *)v748 = v37;
      if (v14)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v14, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
        v39 = v38;
        v758 = v33;
        v40 = v751;
        if (v38)
          goto LABEL_393;
        return 1;
      }
      *(_QWORD *)v753 = 0;
      if (v6)
        v41 = v10;
      else
        v41 = 0;
      v758 = v33 - v41;
      v42 = v10;
      v40 = v751;
LABEL_66:
      v757 = v30 - v42;
      v743 = v10;
      switch(v7)
      {
        case 0:
          v738 = v30;
          v65 = v757 + (int)v10;
          v66 = v10;
          v67 = v761[0];
          v68 = v761[0] - 1;
          v69 = (v65 * v68) & (v65 >> 63);
          if (v65 < 0)
            v65 = -v65;
          CGBlt_fillBytes(2 * v66, v761[0], 0, (char *)v37 + 2 * v69, 2 * v65);
          if (v6)
          {
            v70 = v758 + v66;
            if (v70 >= 0)
              v71 = v758 + v66;
            else
              v71 = -v70;
            v40 += 2 * ((v70 * v68) & (v70 >> 63));
            v758 = v71;
            CGBlt_fillBytes(2 * v66, v67, 0, v40, 2 * v71);
          }
          goto LABEL_367;
        case 1:
          v72 = v757 + (int)v10;
          v744 = (int)v10;
          if (v72 < 0)
          {
            v37 = (uint16x4_t *)((char *)v37 + 2 * v72 * (v761[0] - 1));
            v72 = -v72;
          }
          v73 = v30;
          v74 = 0;
          v75 = *(int **)(v9 + 88);
          if (v75)
            v74 = *v75;
          v76 = 2 * v10;
          v77 = v761[0];
          CGBlt_fillBytes(v76, v761[0], v74, (char *)v37, 2 * v72);
          if (v6)
          {
            v78 = *(int **)(v9 + 96);
            if (!v78)
              v78 = (int *)&PIXELALPHAPLANARCONSTANT_15938;
            v79 = v758 + v744;
            if ((uint64_t)(v758 + v744) >= 0)
              v80 = v758 + v744;
            else
              v80 = -v79;
            v40 += 2 * (((v758 + v744) * (v77 - 1)) & (v79 >> 63));
            v758 = v80;
            CGBlt_fillBytes(v76, v77, *v78, v40, 2 * v80);
          }
          v30 = v73;
          goto LABEL_354;
        case 2:
          v81 = v761[0];
          v82 = v10 >> 2;
          if (v6)
          {
            v83 = v82 + 1;
            do
            {
              if ((int)v10 < 4)
              {
                v89 = v10;
              }
              else
              {
                v84 = v83;
                do
                {
                  v85 = *(unsigned __int16 *)v40 * v740 + ((*(unsigned __int16 *)v40 * v740) >> 16) + 1;
                  v37->i16[0] = v17 + ((v37->u16[0] * v740 + ((v37->u16[0] * v740) >> 16) + 1) >> 16);
                  *(_WORD *)v40 = v18 + HIWORD(v85);
                  v86 = *((unsigned __int16 *)v40 + 1) * v740
                      + ((*((unsigned __int16 *)v40 + 1) * v740) >> 16)
                      + 1;
                  v37->i16[1] = v17 + ((v37->u16[1] * v740 + ((v37->u16[1] * v740) >> 16) + 1) >> 16);
                  *((_WORD *)v40 + 1) = v18 + HIWORD(v86);
                  v87 = *((unsigned __int16 *)v40 + 2) * v740
                      + ((*((unsigned __int16 *)v40 + 2) * v740) >> 16)
                      + 1;
                  v37->i16[2] = v17 + ((v37->u16[2] * v740 + ((v37->u16[2] * v740) >> 16) + 1) >> 16);
                  *((_WORD *)v40 + 2) = v18 + HIWORD(v87);
                  v88 = *((unsigned __int16 *)v40 + 3) * v740
                      + ((*((unsigned __int16 *)v40 + 3) * v740) >> 16)
                      + 1;
                  v37->i16[3] = v17 + ((v37->u16[3] * v740 + ((v37->u16[3] * v740) >> 16) + 1) >> 16);
                  *((_WORD *)v40 + 3) = v18 + HIWORD(v88);
                  ++v37;
                  v40 += 8 * v746;
                  --v84;
                }
                while (v84 > 1);
                v89 = v10 & 3;
              }
              if (v89 >= 1)
              {
                v90 = v89 + 1;
                do
                {
                  v91 = *(unsigned __int16 *)v40 * v740 + ((*(unsigned __int16 *)v40 * v740) >> 16);
                  v37->i16[0] = v17 + ((v37->u16[0] * v740 + ((v37->u16[0] * v740) >> 16) + 1) >> 16);
                  v37 = (uint16x4_t *)((char *)v37 + 2);
                  *(_WORD *)v40 = v18 + ((v91 + 1) >> 16);
                  --v90;
                  v40 += 2 * v746;
                }
                while (v90 > 1);
              }
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v81;
            }
            while (v81);
          }
          else
          {
            v186 = vdup_n_s16(v17);
            v187 = v82 + 1;
            v188 = (uint16x4_t)vdup_n_s16(v740);
            v189.i64[0] = 0x100000001;
            v189.i64[1] = 0x100000001;
            do
            {
              if ((int)v10 < 4)
              {
                v192 = v10;
              }
              else
              {
                v190 = v187;
                do
                {
                  v191 = vmull_u16(v188, *v37);
                  *v37++ = (uint16x4_t)vadd_s16(v186, vaddhn_s32((int32x4_t)vsraq_n_u32(v191, v191, 0x10uLL), v189));
                  v40 += 8 * v746;
                  --v190;
                }
                while (v190 > 1);
                v192 = v10 & 3;
              }
              if (v192 >= 1)
              {
                v193 = v192 + 1;
                do
                {
                  v37->i16[0] = v17 + ((v37->u16[0] * v740 + ((v37->u16[0] * v740) >> 16) + 1) >> 16);
                  v37 = (uint16x4_t *)((char *)v37 + 2);
                  --v193;
                  v40 += 2 * v746;
                }
                while (v193 > 1);
              }
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v81;
            }
            while (v81);
          }
          goto LABEL_390;
        case 3:
          v92 = v761[0];
          do
          {
            v93 = v10;
            do
            {
              v94 = *(unsigned __int16 *)v40;
              if (v94 == 0xFFFF)
              {
                v37->i16[0] = v17;
                LOWORD(v94) = v18;
              }
              else if (*(_WORD *)v40)
              {
                v95 = v94 ^ 0xFFFF;
                v37->i16[0] = v17 - ((v95 * v17 + ((v95 * v17) >> 16) + 1) >> 16);
                v94 = v18 - ((v95 * v18 + ((v95 * v18) >> 16) + 1) >> 16);
              }
              else
              {
                v37->i16[0] = 0;
              }
              *(_WORD *)v40 = v94;
              v37 = (uint16x4_t *)((char *)v37 + 2);
              v40 += 2 * v746;
              --v93;
            }
            while (v93);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            --v92;
          }
          while (v92);
          goto LABEL_390;
        case 4:
          v96 = v761[0];
          do
          {
            v97 = v10;
            do
            {
              v98 = *(unsigned __int16 *)v40;
              if (*(_WORD *)v40)
              {
                if (v98 != 0xFFFF)
                {
                  v37->i16[0] = v17 - ((v98 * v17 + ((v98 * v17) >> 16) + 1) >> 16);
                  v99 = v18 - ((v98 * v18 + ((v98 * v18) >> 16) + 1) >> 16);
                }
                else
                {
                  LOWORD(v99) = 0;
                  v37->i16[0] = 0;
                }
              }
              else
              {
                v37->i16[0] = v17;
                LOWORD(v99) = v18;
              }
              *(_WORD *)v40 = v99;
              v37 = (uint16x4_t *)((char *)v37 + 2);
              v40 += 2 * v746;
              --v97;
            }
            while (v97);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            --v96;
          }
          while (v96);
          goto LABEL_390;
        case 5:
          v100 = v761[0];
          do
          {
            v101 = v10;
            do
            {
              v102 = *(unsigned __int16 *)v40;
              v37->i16[0] = (v102 * v17 + v37->u16[0] * v740 + ((v102 * v17 + v37->u16[0] * v740) >> 16) + 1) >> 16;
              v37 = (uint16x4_t *)((char *)v37 + 2);
              *(_WORD *)v40 = ((v102 + v740) * v18 + (((v102 + v740) * v18) >> 16) + 1) >> 16;
              v40 += 2 * v746;
              --v101;
            }
            while (v101);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            --v100;
          }
          while (v100);
          goto LABEL_390;
        case 6:
          v103 = v761[0];
          do
          {
            v104 = v10;
            do
            {
              v105 = *(unsigned __int16 *)v40;
              if ((_WORD)v105 != 0xFFFF)
              {
                if ((unsigned __int16)~(_WORD)v105 == 0xFFFF)
                {
                  v37->i16[0] = v17;
                  LOWORD(v106) = v18;
                }
                else
                {
                  v107 = (unsigned __int16)~(_WORD)v105;
                  v37->i16[0] += (v107 * v17 + ((v107 * v17) >> 16) + 1) >> 16;
                  v106 = v105 + ((v107 * v18 + ((v107 * v18) >> 16) + 1) >> 16);
                }
                *(_WORD *)v40 = v106;
              }
              v37 = (uint16x4_t *)((char *)v37 + 2);
              v40 += 2 * v746;
              --v104;
            }
            while (v104);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            --v103;
          }
          while (v103);
          goto LABEL_390;
        case 7:
          v108 = v761[0];
          v109 = 2 * v746;
          if (v6)
          {
            do
            {
              v110 = v10;
              do
              {
                v111 = *(unsigned __int16 *)v40;
                v37->i16[0] -= (v37->u16[0] * v740 + ((v37->u16[0] * v740) >> 16) + 1) >> 16;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                *(_WORD *)v40 = v111 - ((v111 * v740 + ((v111 * v740) >> 16) + 1) >> 16);
                v40 += v109;
                --v110;
              }
              while (v110);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v108;
            }
            while (v108);
          }
          else
          {
            do
            {
              v112 = v10;
              do
              {
                v37->i16[0] -= (v37->u16[0] * v740 + ((v37->u16[0] * v740) >> 16) + 1) >> 16;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                v40 += v109;
                --v112;
              }
              while (v112);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v108;
            }
            while (v108);
          }
          goto LABEL_390;
        case 8:
          v113 = v761[0];
          v114 = 2 * v746;
          if (v6)
          {
            do
            {
              v115 = v10;
              do
              {
                v116 = *(unsigned __int16 *)v40;
                v37->i16[0] -= (v37->u16[0] * v18 + ((v37->u16[0] * v18) >> 16) + 1) >> 16;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                *(_WORD *)v40 = v116 - ((v116 * v18 + ((v116 * v18) >> 16) + 1) >> 16);
                v40 += v114;
                --v115;
              }
              while (v115);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v113;
            }
            while (v113);
          }
          else
          {
            do
            {
              v117 = v10;
              do
              {
                v37->i16[0] -= (v37->u16[0] * v18 + ((v37->u16[0] * v18) >> 16) + 1) >> 16;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                v40 += v114;
                --v117;
              }
              while (v117);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v113;
            }
            while (v113);
          }
          goto LABEL_390;
        case 9:
          v118 = v761[0];
          do
          {
            v119 = v10;
            do
            {
              v120 = *(unsigned __int16 *)v40 ^ 0xFFFF;
              v37->i16[0] = (v120 * v17 + v37->u16[0] * v18 + ((v120 * v17 + v37->u16[0] * v18) >> 16) + 1) >> 16;
              v37 = (uint16x4_t *)((char *)v37 + 2);
              *(_WORD *)v40 = ((v120 + v18) * v18 + (((v120 + v18) * v18) >> 16) + 1) >> 16;
              v40 += 2 * v746;
              --v119;
            }
            while (v119);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            --v118;
          }
          while (v118);
          goto LABEL_390;
        case 10:
          v121 = v761[0];
          do
          {
            v122 = v10;
            do
            {
              v123 = *(unsigned __int16 *)v40 ^ 0xFFFF;
              v37->i16[0] = (v123 * v17 + v37->u16[0] * v740 + ((v123 * v17 + v37->u16[0] * v740) >> 16) + 1) >> 16;
              v37 = (uint16x4_t *)((char *)v37 + 2);
              *(_WORD *)v40 = ((v123 + v740) * v18 + (((v123 + v740) * v18) >> 16) + 1) >> 16;
              v40 += 2 * v746;
              --v122;
            }
            while (v122);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            --v121;
          }
          while (v121);
          goto LABEL_390;
        case 11:
          if (v6)
          {
            v124 = v761[0];
            do
            {
              v125 = v10;
              do
              {
                v126 = *(unsigned __int16 *)v40;
                v127 = v18 - v17 - v37->u16[0] + v126;
                v128 = v126 + v18;
                if (v127 >= 0xFFFF)
                  LOWORD(v127) = -1;
                if (v128 >= 0xFFFF)
                  LOWORD(v128) = -1;
                v37->i16[0] = v128 - v127;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                *(_WORD *)v40 = v128;
                v40 += 2 * v746;
                --v125;
              }
              while (v125);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v124;
            }
            while (v124);
          }
          else
          {
            v194 = v761[0];
            do
            {
              v195 = v10;
              do
              {
                v196 = v18 - v17 + (v37->u16[0] ^ 0xFFFF);
                if (v196 >= 0xFFFF)
                  LOWORD(v196) = -1;
                v37->i16[0] = ~(_WORD)v196;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                v40 += 2 * v746;
                --v195;
              }
              while (v195);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v194;
            }
            while (v194);
          }
          goto LABEL_390;
        case 12:
          if (v6)
          {
            v129 = v761[0];
            do
            {
              v130 = v10;
              do
              {
                v131 = v37->u16[0] + v17;
                v132 = *(unsigned __int16 *)v40 + v18;
                if (v131 >= 0xFFFF)
                  LOWORD(v131) = -1;
                if (v132 >= 0xFFFF)
                  LOWORD(v132) = -1;
                v37->i16[0] = v131;
                v37 = (uint16x4_t *)((char *)v37 + 2);
                *(_WORD *)v40 = v132;
                v40 += 2 * v746;
                --v130;
              }
              while (v130);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v129;
            }
            while (v129);
          }
          else
          {
            v197 = v761[0];
            do
            {
              v198 = v10;
              do
              {
                v37->i16[0] = (2 * v37->i16[0]) | (v37->i16[0] >> 15);
                v37 = (uint16x4_t *)((char *)v37 + 2);
                v40 += 2 * v746;
                --v198;
              }
              while (v198);
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v197;
            }
            while (v197);
          }
          goto LABEL_390;
        case 13:
          if (!v18)
            goto LABEL_391;
          v133 = v761[0];
          while (1)
          {
            v134 = v10;
            do
            {
              if (v6)
              {
                v135 = *(unsigned __int16 *)v40;
                if (!*(_WORD *)v40)
                {
                  v37->i16[0] = v17;
                  *(_WORD *)v40 = v18;
                  goto LABEL_197;
                }
              }
              else
              {
                v135 = 0xFFFF;
              }
              v136 = v135;
              v137 = (v135 ^ 0xFFFF) * (unint64_t)v17 + ((v18 ^ 0xFFFF) + v17) * (unint64_t)v37->u16[0];
              if (v137 <= 0xFFFE8000)
                v138 = v137 + 0x8000;
              else
                v138 = 4294868992;
              v139 = (v138 + (v138 >> 16)) >> 16;
              if (v6)
              {
                v140 = 0xFFFF * (v136 + v18) - v136 * (unint64_t)v18;
                if (v140 <= 4294868992)
                  v141 = v140 + 0x8000;
                else
                  v141 = 4294868992;
                v37->i16[0] = v139;
                *(_WORD *)v40 = (v139 | ((v141 >> 16) + (_DWORD)v141)) >> 16;
              }
              else
              {
                v37->i16[0] = v139;
              }
LABEL_197:
              v37 = (uint16x4_t *)((char *)v37 + 2);
              v40 += 2 * v746;
              --v134;
            }
            while (v134);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            if (!--v133)
            {
LABEL_390:
              v761[0] = 0;
LABEL_391:
              v37 = *(uint16x4_t **)v748;
              v39 = *(_QWORD *)v753;
              if (!*(_QWORD *)v753)
                return 1;
              v760 = 0;
LABEL_393:
              if (!shape_enum_clip_next(v39, (int *)&v760 + 1, &v760, v771, v761))
              {
                v48 = (void *)v39;
                goto LABEL_1262;
              }
              *(_QWORD *)v753 = v39;
              v37 = (uint16x4_t *)((char *)v37 + 2 * v30 * (int)v760 + 2 * SHIDWORD(v760));
              v42 = v771[0];
              v199 = v758;
              if (v6)
                v199 = v33 - v771[0];
              v758 = v199;
              if (v6)
                v40 = &v751[2 * v33 * (int)v760 + 2 * SHIDWORD(v760)];
              LODWORD(v10) = v771[0];
              goto LABEL_66;
            }
          }
        case 14:
          if (!v18)
            goto LABEL_391;
          v142 = v761[0];
          while (1)
          {
            v143 = v10;
            do
            {
              if (v6)
              {
                v144 = *(unsigned __int16 *)v40;
                if (!*(_WORD *)v40)
                {
                  v37->i16[0] = v17;
                  *(_WORD *)v40 = v18;
                  goto LABEL_216;
                }
              }
              else
              {
                v144 = 0xFFFF;
              }
              v145 = (v37->u16[0] ^ 0xFFFFu) * (unint64_t)v17
                   - v37->u16[0]
                   + ((unint64_t)v37->u16[0] << 16);
              if (v145 <= 0xFFFE8000)
                v146 = v145 + 0x8000;
              else
                v146 = 4294868992;
              v147 = (v146 + (v146 >> 16)) >> 16;
              if (v6)
              {
                v148 = 0xFFFF * (v18 + (unint64_t)v144) - v18 * (unint64_t)v144;
                if (v148 <= 4294868992)
                  v149 = v148 + 0x8000;
                else
                  v149 = 4294868992;
                v37->i16[0] = v147;
                *(_WORD *)v40 = (v147 | ((v149 >> 16) + (_DWORD)v149)) >> 16;
              }
              else
              {
                v37->i16[0] = v147;
              }
LABEL_216:
              v37 = (uint16x4_t *)((char *)v37 + 2);
              v40 += 2 * v746;
              --v143;
            }
            while (v143);
            v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
            v40 += 2 * v758;
            if (!--v142)
              goto LABEL_390;
          }
        case 15:
          if (!v18)
            goto LABEL_391;
          v150 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v151 = PDAoverlayPDA_8071(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v151;
                *(_WORD *)v40 = HIWORD(v151);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAoverlayPDA_8071(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v150;
              LODWORD(v10) = v743;
              if (!v150)
                break;
            }
          }
          goto LABEL_353;
        case 16:
          if (!v18)
            goto LABEL_391;
          v152 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v153 = PDAdarkenPDA_8073(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v153;
                *(_WORD *)v40 = HIWORD(v153);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAdarkenPDA_8073(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v152;
              LODWORD(v10) = v743;
              if (!v152)
                break;
            }
          }
          goto LABEL_353;
        case 17:
          if (!v18)
            goto LABEL_391;
          v154 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v155 = PDAlightenPDA_8072(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v155;
                *(_WORD *)v40 = HIWORD(v155);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAlightenPDA_8072(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v154;
              LODWORD(v10) = v743;
              if (!v154)
                break;
            }
          }
          goto LABEL_353;
        case 18:
          if (!v18)
            goto LABEL_391;
          v156 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v157 = PDAcolordodgePDA_8074(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v157;
                *(_WORD *)v40 = HIWORD(v157);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAcolordodgePDA_8074(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v156;
              LODWORD(v10) = v743;
              if (!v156)
                break;
            }
          }
          goto LABEL_353;
        case 19:
          if (!v18)
            goto LABEL_391;
          v158 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v159 = PDAcolorburnPDA_8075(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v159;
                *(_WORD *)v40 = HIWORD(v159);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAcolorburnPDA_8075(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v158;
              LODWORD(v10) = v743;
              if (!v158)
                break;
            }
          }
          goto LABEL_353;
        case 20:
          if (!v18)
            goto LABEL_391;
          v160 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v161 = PDAsoftlightPDA_8077(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v161;
                *(_WORD *)v40 = HIWORD(v161);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAsoftlightPDA_8077(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v160;
              LODWORD(v10) = v743;
              if (!v160)
                break;
            }
          }
          goto LABEL_353;
        case 21:
          if (!v18)
            goto LABEL_391;
          v162 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v163 = PDAhardlightPDA_8076(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v163;
                *(_WORD *)v40 = HIWORD(v163);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAhardlightPDA_8076(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v162;
              LODWORD(v10) = v743;
              if (!v162)
                break;
            }
          }
          goto LABEL_353;
        case 22:
          if (!v18)
            goto LABEL_391;
          v164 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v165 = PDAdifferencePDA_8078(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v165;
                *(_WORD *)v40 = HIWORD(v165);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAdifferencePDA_8078(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v164;
              LODWORD(v10) = v743;
              if (!v164)
                break;
            }
          }
          goto LABEL_353;
        case 23:
          if (!v18)
            goto LABEL_391;
          if (v17 >= v18)
            v166 = v18;
          else
            v166 = v17;
          v167 = v761[0];
          break;
        case 24:
          if (!v18)
            goto LABEL_391;
          v176 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v177 = PDAhuePDA_8079(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v177;
                *(_WORD *)v40 = HIWORD(v177);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAhuePDA_8079(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v176;
              LODWORD(v10) = v743;
              if (!v176)
                break;
            }
          }
          goto LABEL_353;
        case 25:
          if (!v18)
            goto LABEL_391;
          v178 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v179 = PDAhuePDA_8079(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v179;
                *(_WORD *)v40 = HIWORD(v179);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAhuePDA_8079(v37->u16[0], 0xFFFFu, v17, v18);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v178;
              LODWORD(v10) = v743;
              if (!v178)
                break;
            }
          }
          goto LABEL_353;
        case 26:
          if (!v18)
            goto LABEL_391;
          v180 = v761[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v181 = PDAluminosityPDA_8081(v17, v18, v37->u16[0], *(unsigned __int16 *)v40);
                v37->i16[0] = v181;
                *(_WORD *)v40 = HIWORD(v181);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v37->i16[0] = PDAluminosityPDA_8081(v17, v18, v37->u16[0], 0xFFFFu);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v180;
              LODWORD(v10) = v743;
              if (!v180)
                break;
            }
          }
LABEL_353:
          v761[0] = 0;
          v7 = v715;
          goto LABEL_354;
        case 27:
          if (!v18)
            goto LABEL_391;
          v738 = v30;
          v182 = v761[0];
          if (v17 >= v18)
            v183 = v18;
          else
            v183 = v17;
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v40)
              {
                v184 = PDAluminosityPDA_8081(v37->u16[0], *(unsigned __int16 *)v40, v17, v18);
                v37->i16[0] = v184;
                *(_WORD *)v40 = HIWORD(v184);
              }
              else
              {
                v37->i16[0] = v17;
                *(_WORD *)v40 = v18;
              }
            }
            else
            {
              v185 = v37->u16[0] * (unint64_t)v740 + 0x8000;
              v37->i16[0] = v183 + (((v185 >> 16) + v185) >> 16);
            }
            v37 = (uint16x4_t *)((char *)v37 + 2);
            v40 += 2 * v746;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
              v40 += 2 * v758;
              --v182;
              LODWORD(v10) = v743;
              if (!v182)
                break;
            }
          }
          v761[0] = 0;
          v7 = v715;
LABEL_367:
          v30 = v738;
LABEL_354:
          v33 = v742;
          goto LABEL_391;
        default:
          goto LABEL_391;
      }
LABEL_304:
      v168 = v10;
      while (v6)
      {
        v169 = *(unsigned __int16 *)v40;
        if (*(_WORD *)v40)
          goto LABEL_309;
        v37->i16[0] = v17;
        *(_WORD *)v40 = v18;
LABEL_321:
        v37 = (uint16x4_t *)((char *)v37 + 2);
        v40 += 2 * v746;
        if (!--v168)
        {
          v37 = (uint16x4_t *)((char *)v37 + 2 * v757);
          v40 += 2 * v758;
          if (!--v167)
            goto LABEL_390;
          goto LABEL_304;
        }
      }
      v169 = 0xFFFF;
LABEL_309:
      if (v37->u16[0] >= v169)
        v170 = v169;
      else
        v170 = v37->u16[0];
      v171 = 0xFFFF * (v170 + v166) - (2 * v166) * (unint64_t)v170;
      if (v171 <= 4294868992)
        v172 = v171 + 0x8000;
      else
        v172 = 4294868992;
      v173 = (v172 + (v172 >> 16)) >> 16;
      if (v6)
      {
        v174 = 0xFFFF * (v18 + (unint64_t)v169) - v18 * (unint64_t)v169;
        if (v174 <= 4294868992)
          v175 = v174 + 0x8000;
        else
          v175 = 4294868992;
        v37->i16[0] = v173;
        *(_WORD *)v40 = (v173 | ((v175 >> 16) + (_DWORD)v175)) >> 16;
      }
      else
      {
        v37->i16[0] = v173;
      }
      goto LABEL_321;
    }
    v771[0] = *(_DWORD *)(v3 + 4);
    v761[0] = v12;
    v19 = *(_QWORD *)(v3 + 88);
    v21 = *(int *)(v3 + 12);
    v20 = *(int *)(v3 + 16);
    v735 = (unint64_t)*(int *)(v3 + 28) >> 1;
    if (v6)
    {
      v22 = (unint64_t)*(int *)(v3 + 32) >> 1;
      v718 = (char *)(v6 + 2 * (v21 + v22 * v20));
      v23 = 0xFFFFFFFFLL;
    }
    else
    {
      v22 = 0;
      v718 = 0;
      v23 = 0;
    }
    v717 = *(_QWORD *)(v3 + 40) + 2 * (v21 + v20 * v735);
    v35 = *(_DWORD *)(v3 + 56);
    v34 = *(_DWORD *)(v3 + 60);
    v741 = (unint64_t)*(int *)(v3 + 76) >> 1;
    v711 = v3;
    if (v16 == 256)
    {
      v710 = *(_DWORD *)(v3 + 60);
      if (v5)
      {
        v739 = (unint64_t)*(int *)(v3 + 80) >> 1;
        v5 += 2 * v35 + 2 * v739 * v34;
        v36 = 0xFFFFFFFFLL;
      }
      else
      {
        v739 = 0;
        v36 = 0;
      }
      v49 = (_WORD *)(v19 + 2 * (v35 + v34 * v741));
      if (v741 == v735 && (uint64_t)(v717 - (_QWORD)v49) >= 1)
      {
        if (v10 >= (v717 - (unint64_t)v49) >> 1)
        {
          v717 += 2 * v11;
          v49 += v11;
          v718 += 2 * (v23 & v11);
          v50 = -1;
          v741 = (unint64_t)*(int *)(v3 + 28) >> 1;
          v5 += 2 * (v36 & v11);
          goto LABEL_49;
        }
        if (v717 <= (unint64_t)&v49[v735 * v13 + v11])
        {
          v717 += 2 * v735 * v13;
          v718 += 2 * v22 * v13;
          v22 = -(uint64_t)v22;
          v5 += 2 * v739 * v13;
          v23 &= 1u;
          v739 = -(uint64_t)v739;
          v741 = -(uint64_t)v735;
          v36 &= 1u;
          v50 = 1;
          v49 += v735 * v13;
          v735 = -(uint64_t)v735;
          goto LABEL_49;
        }
      }
      v23 &= 1u;
      v36 &= 1u;
      v50 = 1;
LABEL_49:
      v709 = *(_DWORD *)(v3 + 56);
      if (v14)
      {
        v756 = v36;
        v759 = v23;
        v736 = 0;
        v737 = 0;
        v19 = -1;
        v721 = v741;
        v720 = v739;
        goto LABEL_54;
      }
      v56 = v50 * (int)v10;
      v752 = v22 - (int)v23 * (int)v10;
      v57 = -1;
      v58 = v739;
      v719 = v50;
      v720 = v739;
      v59 = v741;
      v721 = v741;
LABEL_62:
      v722 = 0;
      v64 = 0;
      v741 = v59 - v56;
      v737 = 0;
      v739 = v58 - (int)v36 * (int)v10;
      v716 = (uint64_t)v49;
      v63 = (_BYTE *)v717;
      v53 = v718;
      v54 = v5;
      v747 = v5;
      goto LABEL_400;
    }
    v721 = *(_DWORD *)(v3 + 64);
    v720 = *(_DWORD *)(v3 + 68);
    if (v5)
    {
      v739 = (unint64_t)*(int *)(v3 + 80) >> 1;
      v36 = 1;
    }
    else
    {
      v739 = 0;
      v36 = 0;
    }
    v737 = v19 + 2 * v741 * v720;
    v23 &= 1u;
    if (v14)
    {
      v709 = *(_DWORD *)(v3 + 56);
      v710 = *(_DWORD *)(v3 + 60);
      v756 = v36;
      v759 = v23;
      v50 = 1;
      v736 = *(_WORD **)(v3 + 88);
      v49 = v736;
LABEL_54:
      v719 = v50;
      shape_enum_clip_alloc(v2, v3, (int *)v14, v50, v735, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
      v52 = v51;
      v716 = (uint64_t)v49;
      v752 = v22;
      v53 = v718;
      v54 = v5;
      v55 = v5;
      if (!v51)
        return 1;
      goto LABEL_1238;
    }
    v752 = v22 - (v23 * v10);
    if (!v19)
    {
      v709 = *(_DWORD *)(v3 + 56);
      v710 = *(_DWORD *)(v3 + 60);
      v49 = 0;
      v57 = 0;
      v719 = 1;
      v56 = v10;
      v58 = v739;
      v59 = (unint64_t)*(int *)(v3 + 76) >> 1;
      goto LABEL_62;
    }
    v60 = v34 % v720;
    v710 = v34 % v720;
    v716 = *(_QWORD *)(v3 + 88);
    v61 = v19 + 2 * v741 * v60;
    v62 = v35 % v721;
    v49 = (_WORD *)(v61 + 2 * v62);
    v57 = v61 + 2 * v721;
    v709 = v62;
    v722 = 0;
    if (v5)
    {
      v54 = &v5[2 * v739 * v60 + 2 * v62];
      v719 = 1;
      v36 = 1;
      v63 = (_BYTE *)v717;
      v53 = v718;
      v64 = (_WORD *)(v61 + 2 * v62);
      v747 = v54;
    }
    else
    {
      v54 = 0;
      v747 = 0;
      v719 = 1;
      v63 = (_BYTE *)v717;
      v53 = v718;
      v64 = (_WORD *)(v61 + 2 * v62);
    }
    v56 = v10;
LABEL_400:
    v756 = v36;
    v759 = v23;
    *(_QWORD *)v749 = v735 - v56;
    switch(v7)
    {
      case 0:
        v736 = v64;
        v19 = v57;
        v712 = v5;
        v713 = v22;
        v200 = *(_QWORD *)v749 - (int)v10;
        v201 = &v63[-2 * (int)v10 + 2];
        if (v719 >= 0)
        {
          v201 = v63;
          v200 = *(_QWORD *)v749 + (int)v10;
        }
        v202 = v761[0];
        v203 = v761[0] - 1;
        v204 = &v201[2 * ((v200 * v203) & (v200 >> 63))];
        if (v200 < 0)
          v200 = -v200;
        CGBlt_fillBytes(2 * v10, v761[0], 0, v204, 2 * v200);
        if ((_DWORD)v759)
        {
          if (v719 < 0)
          {
            v205 = v752 - (int)v10;
            v53 += -2 * (int)v10 + 2;
          }
          else
          {
            v205 = v752 + (int)v10;
          }
          if (v205 >= 0)
            v664 = v205;
          else
            v664 = -v205;
          v53 += 2 * ((v205 * v203) & (v205 >> 63));
          v752 = v664;
          CGBlt_fillBytes(2 * v10, v202, 0, v53, 2 * v664);
        }
        goto LABEL_1043;
      case 1:
        v206 = *(unsigned __int8 *)(v711 + 1);
        if (v206 == 2)
        {
          if ((int)v10 >= 16 && (2 * v721) <= 0x40)
          {
            v4.i32[0] = 2 * v721;
            v650 = (uint8x8_t)vcnt_s8(v4);
            v650.i16[0] = vaddlv_u8(v650);
            if (v650.i32[0] <= 1u)
            {
              v736 = v64;
              v19 = v57;
              v651 = 2 * (v10 + v749[0]);
              v755 = 2 * v10;
              v750 = v761[0];
              CGSFillDRAM64(v63, v651, 2 * v10, v761[0], v716, 2 * v741, 2 * v721, v720, 2 * v709, v710);
              if (!(_DWORD)v759)
                goto LABEL_1153;
              v52 = v722;
              if ((_DWORD)v36)
                CGSFillDRAM64(v53, 2 * (v10 + v752), v755, v750, (uint64_t)v5, 2 * v739, 2 * v721, v720, 2 * v709, v710);
              else
                CGBlt_fillBytes(v755, v750, -1, v53, 2 * (v10 + v752));
              goto LABEL_1154;
            }
          }
        }
        else if (v206 == 1)
        {
          v736 = v64;
          v713 = v22;
          v19 = v57;
          v207 = v5;
          if (v719 < 0)
          {
            v208 = v741 - (int)v10;
            v49 += -(int)v10 + 1;
            v209 = *(_QWORD *)v749 - (int)v10;
            v63 += -2 * (int)v10 + 2;
          }
          else
          {
            v208 = v741 + (int)v10;
            v209 = *(_QWORD *)v749 + (int)v10;
          }
          v695 = v761[0] - 1;
          if (v208 >= 0)
            v696 = v208;
          else
            v696 = -v208;
          v697 = (char *)&v49[(v208 * v695) & (v208 >> 63)];
          v698 = v761[0];
          if (v209 >= 0)
            LODWORD(v699) = v209;
          else
            v699 = -v209;
          v741 = v696;
          CGBlt_copyBytes(2 * v10, v761[0], v697, &v63[2 * ((v209 * v695) & (v209 >> 63))], 2 * v696, 2 * v699);
          if ((_DWORD)v759)
          {
            if ((_DWORD)v36)
            {
              v700 = v739 - (int)v10;
              v701 = &v54[-2 * (int)v10 + 2];
              v702 = v752 - (int)v10;
              v703 = &v53[-2 * (int)v10 + 2];
              if (v719 >= 0)
              {
                v700 = v739 + (int)v10;
                v702 = v752 + (int)v10;
                v703 = v53;
                v701 = v54;
              }
              if (v700 >= 0)
                v704 = v700;
              else
                v704 = -v700;
              v54 = &v701[2 * ((v700 * v695) & (v700 >> 63))];
              v53 = &v703[2 * ((v702 * v695) & (v702 >> 63))];
              if (v702 >= 0)
                v705 = v702;
              else
                v705 = -v702;
              v739 = v704;
              v752 = v705;
              CGBlt_copyBytes(2 * v10, v698, v54, &v703[2 * ((v702 * v695) & (v702 >> 63))], 2 * v704, 2 * v705);
            }
            else
            {
              v706 = v752 - (int)v10;
              v707 = &v53[-2 * (int)v10 + 2];
              if (v719 >= 0)
              {
                v706 = v752 + (int)v10;
                v707 = v53;
              }
              if (v706 >= 0)
                v708 = v706;
              else
                v708 = -v706;
              v53 = &v707[2 * ((v706 * v695) & (v706 >> 63))];
              v752 = v708;
              CGBlt_fillBytes(2 * v10, v698, -1, v53, 2 * v708);
            }
          }
          v5 = v207;
          goto LABEL_1044;
        }
        if ((_DWORD)v23)
        {
          v652 = 2 * v719;
          v653 = 2 * (int)v23;
          if ((_DWORD)v36)
          {
            v654 = (int)v36;
            v655 = v761[0];
            v55 = v747;
            do
            {
              v656 = v10;
              do
              {
                *(_WORD *)v63 = *v49;
                *(_WORD *)v53 = *(_WORD *)v54;
                v657 = &v49[v719];
                if ((unint64_t)v657 >= v57)
                  v658 = -(uint64_t)v721;
                else
                  v658 = 0;
                v49 = &v657[v658];
                v54 += 2 * v654 + 2 * v658;
                v63 += v652;
                v53 += v653;
                --v656;
              }
              while (v656);
              if (v737)
              {
                v659 = &v64[v741];
                v660 = (unint64_t)v659 >= v737;
                if ((unint64_t)v659 >= v737)
                  v661 = -(uint64_t)(v741 * v720);
                else
                  v661 = 0;
                v49 = &v659[v661];
                v662 = v57 + 2 * v661;
                if (v660)
                  v663 = -(uint64_t)(v739 * v720);
                else
                  v663 = 0;
                v54 = &v55[2 * v739 + 2 * v663];
                v57 = v662 + 2 * v741;
                v64 = v49;
                v55 = v54;
              }
              else
              {
                v49 += v741;
                v54 += 2 * v739;
              }
              v63 += 2 * *(_QWORD *)v749;
              v53 += 2 * v752;
              --v655;
            }
            while (v655);
          }
          else
          {
            v675 = v761[0];
            v55 = v747;
            do
            {
              v676 = v10;
              do
              {
                *(_WORD *)v63 = *v49;
                *(_WORD *)v53 = -1;
                v677 = &v49[v719];
                if ((unint64_t)v677 >= v57)
                  v678 = -(uint64_t)v721;
                else
                  v678 = 0;
                v49 = &v677[v678];
                v54 += 2 * v678;
                v63 += v652;
                v53 += v653;
                --v676;
              }
              while (v676);
              if (v737)
              {
                v679 = &v64[v741];
                v680 = (unint64_t)v679 >= v737;
                if ((unint64_t)v679 >= v737)
                  v681 = -(uint64_t)(v741 * v720);
                else
                  v681 = 0;
                v49 = &v679[v681];
                v682 = v57 + 2 * v681;
                if (v680)
                  v683 = -(uint64_t)(v739 * v720);
                else
                  v683 = 0;
                v54 = &v55[2 * v739 + 2 * v683];
                v57 = v682 + 2 * v741;
                v64 = v49;
                v55 = v54;
              }
              else
              {
                v49 += v741;
                v54 += 2 * v739;
              }
              v63 += 2 * *(_QWORD *)v749;
              v53 += 2 * v752;
              --v675;
            }
            while (v675);
          }
        }
        else
        {
          v665 = (int)v36;
          v666 = v761[0];
          v55 = v747;
          do
          {
            v667 = v10;
            do
            {
              *(_WORD *)v63 = *v49;
              v668 = &v49[v719];
              if ((unint64_t)v668 >= v57)
                v669 = -(uint64_t)v721;
              else
                v669 = 0;
              v49 = &v668[v669];
              v54 += 2 * v665 + 2 * v669;
              v63 += 2 * v719;
              --v667;
            }
            while (v667);
            if (v737)
            {
              v670 = &v64[v741];
              v671 = (unint64_t)v670 >= v737;
              if ((unint64_t)v670 >= v737)
                v672 = -(uint64_t)(v741 * v720);
              else
                v672 = 0;
              v49 = &v670[v672];
              v673 = v57 + 2 * v672;
              if (v671)
                v674 = -(uint64_t)(v739 * v720);
              else
                v674 = 0;
              v54 = &v55[2 * v739 + 2 * v674];
              v57 = v673 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v666;
          }
          while (v666);
        }
        goto LABEL_1236;
      case 2:
        if ((_DWORD)v23)
        {
          v210 = (int)v36;
          v211 = v761[0];
          v55 = v747;
          do
          {
            v212 = v10;
            do
            {
              v213 = *(unsigned __int16 *)v54;
              if (*(_WORD *)v54)
              {
                if (v213 == 0xFFFF)
                {
                  *(_WORD *)v63 = *v49;
                  LOWORD(v214) = *(_WORD *)v54;
                }
                else
                {
                  v215 = *(unsigned __int16 *)v53 * (v213 ^ 0xFFFF)
                       + ((*(unsigned __int16 *)v53 * (v213 ^ 0xFFFFu)) >> 16)
                       + 1;
                  *(_WORD *)v63 = *v49
                                + ((*(unsigned __int16 *)v63 * (v213 ^ 0xFFFF)
                                  + ((*(unsigned __int16 *)v63 * (v213 ^ 0xFFFFu)) >> 16)
                                  + 1) >> 16);
                  v214 = v213 + HIWORD(v215);
                }
                *(_WORD *)v53 = v214;
              }
              v216 = &v49[v719];
              if ((unint64_t)v216 >= v57)
                v217 = -(uint64_t)v721;
              else
                v217 = 0;
              v49 = &v216[v217];
              v54 += 2 * v210 + 2 * v217;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v212;
            }
            while (v212);
            if (v737)
            {
              v218 = &v64[v741];
              v219 = (unint64_t)v218 >= v737;
              if ((unint64_t)v218 >= v737)
                v220 = -(uint64_t)(v741 * v720);
              else
                v220 = 0;
              v49 = &v218[v220];
              v221 = v57 + 2 * v220;
              if (v219)
                v222 = -(uint64_t)(v739 * v720);
              else
                v222 = 0;
              v54 = &v55[2 * v739 + 2 * v222];
              v57 = v221 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v211;
          }
          while (v211);
        }
        else
        {
          v585 = (int)v36;
          v586 = v761[0];
          v55 = v747;
          do
          {
            v587 = v10;
            do
            {
              v588 = *(unsigned __int16 *)v54;
              if (*(_WORD *)v54)
              {
                if (v588 == 0xFFFF)
                  LOWORD(v589) = *v49;
                else
                  v589 = (unsigned __int16)*v49
                       + ((*(unsigned __int16 *)v63 * (v588 ^ 0xFFFF)
                         + ((*(unsigned __int16 *)v63 * (v588 ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                *(_WORD *)v63 = v589;
              }
              v590 = &v49[v719];
              if ((unint64_t)v590 >= v57)
                v591 = -(uint64_t)v721;
              else
                v591 = 0;
              v49 = &v590[v591];
              v54 += 2 * v585 + 2 * v591;
              v63 += 2 * v719;
              --v587;
            }
            while (v587);
            if (v737)
            {
              v592 = &v64[v741];
              v593 = (unint64_t)v592 >= v737;
              if ((unint64_t)v592 >= v737)
                v594 = -(uint64_t)(v741 * v720);
              else
                v594 = 0;
              v49 = &v592[v594];
              v595 = v57 + 2 * v594;
              if (v593)
                v596 = -(uint64_t)(v739 * v720);
              else
                v596 = 0;
              v54 = &v55[2 * v739 + 2 * v596];
              v57 = v595 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v586;
          }
          while (v586);
        }
        goto LABEL_1236;
      case 3:
        if ((_DWORD)v36)
        {
          v223 = (int)v36;
          v224 = v761[0];
          v55 = v747;
          do
          {
            v225 = v10;
            do
            {
              v226 = *(unsigned __int16 *)v53;
              if (v226 == 0xFFFF)
              {
                *(_WORD *)v63 = *v49;
                LOWORD(v226) = *(_WORD *)v54;
              }
              else if (*(_WORD *)v53)
              {
                v227 = *(unsigned __int16 *)v54;
                v228 = v226 ^ 0xFFFF;
                *(_WORD *)v63 = *v49
                              - (((unsigned __int16)*v49 * v228
                                + (((unsigned __int16)*v49 * v228) >> 16)
                                + 1) >> 16);
                v226 = v227 - ((v227 * v228 + ((v227 * v228) >> 16) + 1) >> 16);
              }
              else
              {
                *(_WORD *)v63 = 0;
              }
              *(_WORD *)v53 = v226;
              v229 = &v49[v719];
              if ((unint64_t)v229 >= v57)
                v230 = -(uint64_t)v721;
              else
                v230 = 0;
              v49 = &v229[v230];
              v54 += 2 * v223 + 2 * v230;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v225;
            }
            while (v225);
            if (v737)
            {
              v231 = &v64[v741];
              v232 = (unint64_t)v231 >= v737;
              if ((unint64_t)v231 >= v737)
                v233 = -(uint64_t)(v741 * v720);
              else
                v233 = 0;
              v49 = &v231[v233];
              v234 = v57 + 2 * v233;
              if (v232)
                v235 = -(uint64_t)(v739 * v720);
              else
                v235 = 0;
              v54 = &v55[2 * v739 + 2 * v235];
              v57 = v234 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v224;
          }
          while (v224);
        }
        else
        {
          v597 = v761[0];
          v55 = v747;
          do
          {
            v598 = v10;
            do
            {
              v599 = *(unsigned __int16 *)v53;
              if (*(_WORD *)v53)
              {
                if (v599 == 0xFFFF)
                  LOWORD(v599) = *v49;
                else
                  v599 = (unsigned __int16)*v49
                       - (((unsigned __int16)*v49 * (v599 ^ 0xFFFF)
                         + (((unsigned __int16)*v49 * (v599 ^ 0xFFFF)) >> 16)
                         + 1) >> 16);
              }
              *(_WORD *)v63 = v599;
              v600 = &v49[v719];
              if ((unint64_t)v600 >= v57)
                v601 = -(uint64_t)v721;
              else
                v601 = 0;
              v49 = &v600[v601];
              v54 += 2 * v601;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v598;
            }
            while (v598);
            if (v737)
            {
              v602 = &v64[v741];
              v603 = (unint64_t)v602 >= v737;
              if ((unint64_t)v602 >= v737)
                v604 = -(uint64_t)(v741 * v720);
              else
                v604 = 0;
              v49 = &v602[v604];
              v605 = v57 + 2 * v604;
              if (v603)
                v606 = -(uint64_t)(v739 * v720);
              else
                v606 = 0;
              v54 = &v55[2 * v739 + 2 * v606];
              v57 = v605 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v597;
          }
          while (v597);
        }
        goto LABEL_1236;
      case 4:
        v236 = v761[0];
        do
        {
          v237 = v10;
          do
          {
            v238 = *(unsigned __int16 *)v53;
            if (*(_WORD *)v53)
            {
              if (v238 != 0xFFFF)
              {
                if ((_DWORD)v36)
                  v240 = *(unsigned __int16 *)v54;
                else
                  v240 = 0xFFFF;
                *(_WORD *)v63 = *v49
                              - (((unsigned __int16)*v49 * v238
                                + (((unsigned __int16)*v49 * v238) >> 16)
                                + 1) >> 16);
                v239 = v240 - ((v240 * v238 + ((v240 * v238) >> 16) + 1) >> 16);
              }
              else
              {
                LOWORD(v239) = 0;
                *(_WORD *)v63 = 0;
              }
            }
            else if ((_DWORD)v36)
            {
              LOWORD(v239) = *(_WORD *)v54;
            }
            else
            {
              LOWORD(v239) = -1;
            }
            *(_WORD *)v53 = v239;
            v241 = &v49[v719];
            if ((unint64_t)v241 >= v57)
              v242 = -(uint64_t)v721;
            else
              v242 = 0;
            v49 = &v241[v242];
            v54 += 2 * (int)v36 + 2 * v242;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v237;
          }
          while (v237);
          if (v737)
          {
            v243 = &v64[v741];
            v244 = (unint64_t)v243 >= v737;
            if ((unint64_t)v243 >= v737)
              v245 = -(uint64_t)(v741 * v720);
            else
              v245 = 0;
            v49 = &v243[v245];
            v246 = v57 + 2 * v245;
            if (v244)
              v247 = -(uint64_t)(v739 * v720);
            else
              v247 = 0;
            v54 = &v747[2 * v739 + 2 * v247];
            v57 = v246 + 2 * v741;
            v64 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          --v236;
        }
        while (v236);
        goto LABEL_1152;
      case 5:
        v248 = (int)v36;
        v249 = v761[0];
        v55 = v747;
        do
        {
          v250 = v10;
          do
          {
            v251 = *(unsigned __int16 *)v53;
            v252 = *(unsigned __int16 *)v54;
            v253 = (unsigned __int16)*v49 * v251 + *(unsigned __int16 *)v63 * (v252 ^ 0xFFFF);
            *(_WORD *)v63 = (v253 + HIWORD(v253) + 1) >> 16;
            *(_WORD *)v53 = (((v252 ^ 0xFFFF) + v251) * v252 + ((((v252 ^ 0xFFFFu) + v251) * v252) >> 16) + 1) >> 16;
            v254 = &v49[v719];
            if ((unint64_t)v254 >= v57)
              v255 = -(uint64_t)v721;
            else
              v255 = 0;
            v49 = &v254[v255];
            v54 += 2 * v248 + 2 * v255;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v250;
          }
          while (v250);
          if (v737)
          {
            v256 = &v64[v741];
            v257 = (unint64_t)v256 >= v737;
            if ((unint64_t)v256 >= v737)
              v258 = -(uint64_t)(v741 * v720);
            else
              v258 = 0;
            v49 = &v256[v258];
            v259 = v57 + 2 * v258;
            if (v257)
              v260 = -(uint64_t)(v739 * v720);
            else
              v260 = 0;
            v54 = &v55[2 * v739 + 2 * v260];
            v57 = v259 + 2 * v741;
            v64 = v49;
            v55 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          --v249;
        }
        while (v249);
        goto LABEL_1236;
      case 6:
        v261 = v761[0];
        do
        {
          v262 = v10;
          do
          {
            v263 = *(unsigned __int16 *)v53;
            if ((_WORD)v263 != 0xFFFF)
            {
              if ((unsigned __int16)~(_WORD)v263 == 0xFFFF)
              {
                *(_WORD *)v63 = *v49;
                if ((_DWORD)v36)
                  LOWORD(v264) = *(_WORD *)v54;
                else
                  LOWORD(v264) = -1;
              }
              else
              {
                if ((_DWORD)v36)
                  v265 = *(unsigned __int16 *)v54;
                else
                  v265 = 0xFFFF;
                v266 = (unsigned __int16)~(_WORD)v263;
                *(_WORD *)v63 += ((unsigned __int16)*v49 * v266
                                + (((unsigned __int16)*v49 * v266) >> 16)
                                + 1) >> 16;
                v264 = v263 + ((v265 * v266 + ((v265 * v266) >> 16) + 1) >> 16);
              }
              *(_WORD *)v53 = v264;
            }
            v267 = &v49[v719];
            if ((unint64_t)v267 >= v57)
              v268 = -(uint64_t)v721;
            else
              v268 = 0;
            v49 = &v267[v268];
            v54 += 2 * (int)v36 + 2 * v268;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v262;
          }
          while (v262);
          if (v737)
          {
            v269 = &v64[v741];
            v270 = (unint64_t)v269 >= v737;
            if ((unint64_t)v269 >= v737)
              v271 = -(uint64_t)(v741 * v720);
            else
              v271 = 0;
            v49 = &v269[v271];
            v272 = v57 + 2 * v271;
            if (v270)
              v273 = -(uint64_t)(v739 * v720);
            else
              v273 = 0;
            v54 = &v747[2 * v739 + 2 * v273];
            v57 = v272 + 2 * v741;
            v64 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          --v261;
        }
        while (v261);
        goto LABEL_1152;
      case 7:
        if ((_DWORD)v23)
        {
          v274 = (int)v36;
          v275 = v761[0];
          v55 = v747;
          do
          {
            v276 = v10;
            do
            {
              v277 = *(unsigned __int16 *)v54;
              if (v277 != 0xFFFF)
              {
                if (*(_WORD *)v54)
                {
                  v278 = *(unsigned __int16 *)v53;
                  v279 = v277 ^ 0xFFFF;
                  *(_WORD *)v63 -= (*(unsigned __int16 *)v63 * v279
                                  + ((*(unsigned __int16 *)v63 * v279) >> 16)
                                  + 1) >> 16;
                  v277 = v278 - ((v278 * v279 + ((v278 * v279) >> 16) + 1) >> 16);
                }
                else
                {
                  *(_WORD *)v63 = 0;
                }
                *(_WORD *)v53 = v277;
              }
              v280 = &v49[v719];
              if ((unint64_t)v280 >= v57)
                v281 = -(uint64_t)v721;
              else
                v281 = 0;
              v49 = &v280[v281];
              v54 += 2 * v274 + 2 * v281;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v276;
            }
            while (v276);
            if (v737)
            {
              v282 = &v64[v741];
              v283 = (unint64_t)v282 >= v737;
              if ((unint64_t)v282 >= v737)
                v284 = -(uint64_t)(v741 * v720);
              else
                v284 = 0;
              v49 = &v282[v284];
              v285 = v57 + 2 * v284;
              if (v283)
                v286 = -(uint64_t)(v739 * v720);
              else
                v286 = 0;
              v54 = &v55[2 * v739 + 2 * v286];
              v57 = v285 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v275;
          }
          while (v275);
          goto LABEL_1236;
        }
        v607 = (int)v36;
        v608 = v761[0];
        v55 = v747;
LABEL_1089:
        v609 = v10;
        while (1)
        {
          v610 = *(unsigned __int16 *)v54;
          if (!*(_WORD *)v54)
            goto LABEL_1093;
          if (v610 != 0xFFFF)
            break;
LABEL_1094:
          v611 = &v49[v719];
          if ((unint64_t)v611 >= v57)
            v612 = -(uint64_t)v721;
          else
            v612 = 0;
          v49 = &v611[v612];
          v54 += 2 * v607 + 2 * v612;
          v63 += 2 * v719;
          if (!--v609)
          {
            if (v737)
            {
              v613 = &v64[v741];
              v614 = (unint64_t)v613 >= v737;
              if ((unint64_t)v613 >= v737)
                v615 = -(uint64_t)(v741 * v720);
              else
                v615 = 0;
              v49 = &v613[v615];
              v616 = v57 + 2 * v615;
              if (v614)
                v617 = -(uint64_t)(v739 * v720);
              else
                v617 = 0;
              v54 = &v55[2 * v739 + 2 * v617];
              v57 = v616 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            if (!--v608)
              goto LABEL_1236;
            goto LABEL_1089;
          }
        }
        v610 = *(unsigned __int16 *)v63
             - ((*(unsigned __int16 *)v63 * (v610 ^ 0xFFFF) + ((*(unsigned __int16 *)v63 * (v610 ^ 0xFFFF)) >> 16) + 1) >> 16);
LABEL_1093:
        *(_WORD *)v63 = v610;
        goto LABEL_1094;
      case 8:
        v287 = (int)v36;
        if ((_DWORD)v23)
        {
          v288 = v761[0];
          v55 = v747;
          do
          {
            v289 = v10;
            do
            {
              v290 = *(unsigned __int16 *)v54;
              if (*(_WORD *)v54)
              {
                if (v290 != 0xFFFF)
                {
                  v292 = *(unsigned __int16 *)v53;
                  *(_WORD *)v63 -= (*(unsigned __int16 *)v63 * v290
                                  + ((*(unsigned __int16 *)v63 * v290) >> 16)
                                  + 1) >> 16;
                  v291 = v292 - ((v292 * v290 + ((v292 * v290) >> 16) + 1) >> 16);
                }
                else
                {
                  LOWORD(v291) = 0;
                  *(_WORD *)v63 = 0;
                }
                *(_WORD *)v53 = v291;
              }
              v293 = &v49[v719];
              if ((unint64_t)v293 >= v57)
                v294 = -(uint64_t)v721;
              else
                v294 = 0;
              v49 = &v293[v294];
              v54 += 2 * v287 + 2 * v294;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v289;
            }
            while (v289);
            if (v737)
            {
              v295 = &v64[v741];
              v296 = (unint64_t)v295 >= v737;
              if ((unint64_t)v295 >= v737)
                v297 = -(uint64_t)(v741 * v720);
              else
                v297 = 0;
              v49 = &v295[v297];
              v298 = v57 + 2 * v297;
              if (v296)
                v299 = -(uint64_t)(v739 * v720);
              else
                v299 = 0;
              v54 = &v55[2 * v739 + 2 * v299];
              v57 = v298 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v288;
          }
          while (v288);
LABEL_1236:
          v736 = v64;
          v19 = v57;
          v761[0] = 0;
          v52 = v722;
          if (!v722)
            return 1;
          goto LABEL_1237;
        }
        v618 = v761[0];
        v55 = v747;
LABEL_1110:
        v619 = v10;
        while (1)
        {
          v620 = *(unsigned __int16 *)v54;
          if ((_WORD)v620 == 0xFFFF)
            break;
          if ((unsigned __int16)~(_WORD)v620 != 0xFFFF)
          {
            v621 = *(unsigned __int16 *)v63
                 - ((*(unsigned __int16 *)v63 * v620 + ((*(unsigned __int16 *)v63 * v620) >> 16) + 1) >> 16);
LABEL_1115:
            *(_WORD *)v63 = v621;
          }
          v622 = &v49[v719];
          if ((unint64_t)v622 >= v57)
            v623 = -(uint64_t)v721;
          else
            v623 = 0;
          v49 = &v622[v623];
          v54 += 2 * v287 + 2 * v623;
          v63 += 2 * v719;
          if (!--v619)
          {
            if (v737)
            {
              v624 = &v64[v741];
              v625 = (unint64_t)v624 >= v737;
              if ((unint64_t)v624 >= v737)
                v626 = -(uint64_t)(v741 * v720);
              else
                v626 = 0;
              v49 = &v624[v626];
              v627 = v57 + 2 * v626;
              if (v625)
                v628 = -(uint64_t)(v739 * v720);
              else
                v628 = 0;
              v54 = &v55[2 * v739 + 2 * v628];
              v57 = v627 + 2 * v741;
              v64 = v49;
              v55 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            if (!--v618)
              goto LABEL_1236;
            goto LABEL_1110;
          }
        }
        LOWORD(v621) = 0;
        goto LABEL_1115;
      case 9:
        v300 = (int)v36;
        v301 = v761[0];
        v55 = v747;
        do
        {
          v302 = v10;
          do
          {
            v303 = *(unsigned __int16 *)v54;
            v304 = *(unsigned __int16 *)v53 ^ 0xFFFF;
            v305 = (unsigned __int16)*v49 * v304 + *(unsigned __int16 *)v63 * v303;
            *(_WORD *)v63 = (v305 + HIWORD(v305) + 1) >> 16;
            *(_WORD *)v53 = ((v303 + v304) * v303 + (((v303 + v304) * v303) >> 16) + 1) >> 16;
            v306 = &v49[v719];
            if ((unint64_t)v306 >= v57)
              v307 = -(uint64_t)v721;
            else
              v307 = 0;
            v49 = &v306[v307];
            v54 += 2 * v300 + 2 * v307;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v302;
          }
          while (v302);
          if (v737)
          {
            v308 = &v64[v741];
            v309 = (unint64_t)v308 >= v737;
            if ((unint64_t)v308 >= v737)
              v310 = -(uint64_t)(v741 * v720);
            else
              v310 = 0;
            v49 = &v308[v310];
            v311 = v57 + 2 * v310;
            if (v309)
              v312 = -(uint64_t)(v739 * v720);
            else
              v312 = 0;
            v54 = &v55[2 * v739 + 2 * v312];
            v57 = v311 + 2 * v741;
            v64 = v49;
            v55 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          --v301;
        }
        while (v301);
        goto LABEL_1236;
      case 10:
        v313 = (int)v36;
        v314 = v761[0];
        v55 = v747;
        do
        {
          v315 = v10;
          do
          {
            v316 = *(unsigned __int16 *)v54;
            v317 = *(unsigned __int16 *)v53 ^ 0xFFFF;
            v318 = (unsigned __int16)*v49 * v317 + *(unsigned __int16 *)v63 * (v316 ^ 0xFFFF);
            *(_WORD *)v63 = (v318 + HIWORD(v318) + 1) >> 16;
            *(_WORD *)v53 = (((v316 ^ 0xFFFF) + v317) * v316 + ((((v316 ^ 0xFFFFu) + v317) * v316) >> 16) + 1) >> 16;
            v319 = &v49[v719];
            if ((unint64_t)v319 >= v57)
              v320 = -(uint64_t)v721;
            else
              v320 = 0;
            v49 = &v319[v320];
            v54 += 2 * v313 + 2 * v320;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v315;
          }
          while (v315);
          if (v737)
          {
            v321 = &v64[v741];
            v322 = (unint64_t)v321 >= v737;
            if ((unint64_t)v321 >= v737)
              v323 = -(uint64_t)(v741 * v720);
            else
              v323 = 0;
            v49 = &v321[v323];
            v324 = v57 + 2 * v323;
            if (v322)
              v325 = -(uint64_t)(v739 * v720);
            else
              v325 = 0;
            v54 = &v55[2 * v739 + 2 * v325];
            v57 = v324 + 2 * v741;
            v64 = v49;
            v55 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          --v314;
        }
        while (v314);
        goto LABEL_1236;
      case 11:
        if ((_DWORD)v23)
        {
          v326 = v761[0];
          do
          {
            v327 = v10;
            do
            {
              if ((_DWORD)v36)
                v328 = *(unsigned __int16 *)v54;
              else
                v328 = 0xFFFF;
              v329 = *(unsigned __int16 *)v53;
              v330 = v329 - (*(unsigned __int16 *)v63 + (unsigned __int16)*v49) + v328;
              v331 = v328 + v329;
              if (v330 >= 0xFFFF)
                LOWORD(v330) = -1;
              if (v331 >= 0xFFFF)
                LOWORD(v331) = -1;
              *(_WORD *)v63 = v331 - v330;
              *(_WORD *)v53 = v331;
              v332 = &v49[v719];
              if ((unint64_t)v332 >= v57)
                v333 = -(uint64_t)v721;
              else
                v333 = 0;
              v49 = &v332[v333];
              v54 += 2 * (int)v36 + 2 * v333;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v327;
            }
            while (v327);
            if (v737)
            {
              v334 = &v64[v741];
              v335 = (unint64_t)v334 >= v737;
              if ((unint64_t)v334 >= v737)
                v336 = -(uint64_t)(v741 * v720);
              else
                v336 = 0;
              v49 = &v334[v336];
              v337 = v57 + 2 * v336;
              if (v335)
                v338 = -(uint64_t)(v739 * v720);
              else
                v338 = 0;
              v54 = &v747[2 * v739 + 2 * v338];
              v57 = v337 + 2 * v741;
              v64 = v49;
              v747 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v326;
          }
          while (v326);
        }
        else
        {
          v629 = v761[0];
          do
          {
            v630 = v10;
            do
            {
              if ((_DWORD)v36)
                v631 = *(unsigned __int16 *)v54;
              else
                v631 = 0xFFFF;
              v632 = v631 - (unsigned __int16)*v49 + (*(unsigned __int16 *)v63 ^ 0xFFFF);
              if (v632 >= 0xFFFF)
                LOWORD(v632) = -1;
              *(_WORD *)v63 = ~(_WORD)v632;
              v633 = &v49[v719];
              if ((unint64_t)v633 >= v57)
                v634 = -(uint64_t)v721;
              else
                v634 = 0;
              v49 = &v633[v634];
              v54 += 2 * (int)v36 + 2 * v634;
              v63 += 2 * v719;
              --v630;
            }
            while (v630);
            if (v737)
            {
              v635 = &v64[v741];
              v636 = (unint64_t)v635 >= v737;
              if ((unint64_t)v635 >= v737)
                v637 = -(uint64_t)(v741 * v720);
              else
                v637 = 0;
              v49 = &v635[v637];
              v638 = v57 + 2 * v637;
              if (v636)
                v639 = -(uint64_t)(v739 * v720);
              else
                v639 = 0;
              v54 = &v747[2 * v739 + 2 * v639];
              v57 = v638 + 2 * v741;
              v64 = v49;
              v747 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v629;
          }
          while (v629);
        }
        goto LABEL_1152;
      case 12:
        if ((_DWORD)v23)
        {
          v339 = v761[0];
          do
          {
            v340 = v10;
            do
            {
              if ((_DWORD)v36)
                v341 = *(unsigned __int16 *)v54;
              else
                v341 = 0xFFFF;
              v342 = (unsigned __int16)*v49 + *(unsigned __int16 *)v63;
              v343 = v341 + *(unsigned __int16 *)v53;
              if (v342 >= 0xFFFF)
                LOWORD(v342) = -1;
              if (v343 >= 0xFFFF)
                LOWORD(v343) = -1;
              *(_WORD *)v63 = v342;
              *(_WORD *)v53 = v343;
              v344 = &v49[v719];
              if ((unint64_t)v344 >= v57)
                v345 = -(uint64_t)v721;
              else
                v345 = 0;
              v49 = &v344[v345];
              v54 += 2 * (int)v36 + 2 * v345;
              v63 += 2 * v719;
              v53 += 2 * (int)v23;
              --v340;
            }
            while (v340);
            if (v737)
            {
              v346 = &v64[v741];
              v347 = (unint64_t)v346 >= v737;
              if ((unint64_t)v346 >= v737)
                v348 = -(uint64_t)(v741 * v720);
              else
                v348 = 0;
              v49 = &v346[v348];
              v349 = v57 + 2 * v348;
              if (v347)
                v350 = -(uint64_t)(v739 * v720);
              else
                v350 = 0;
              v54 = &v747[2 * v739 + 2 * v350];
              v57 = v349 + 2 * v741;
              v64 = v49;
              v747 = v54;
            }
            else
            {
              v49 += v741;
              v54 += 2 * v739;
            }
            v63 += 2 * *(_QWORD *)v749;
            v53 += 2 * v752;
            --v339;
          }
          while (v339);
          goto LABEL_1152;
        }
        v640 = (int)v36;
        v641 = v761[0];
        v55 = v747;
        do
        {
          v642 = v10;
          do
          {
            *(_WORD *)v63 = (2 * *(_WORD *)v63) | (*(__int16 *)v63 >> 15);
            v643 = &v49[v719];
            if ((unint64_t)v643 >= v57)
              v644 = -(uint64_t)v721;
            else
              v644 = 0;
            v49 = &v643[v644];
            v54 += 2 * v640 + 2 * v644;
            v63 += 2 * v719;
            --v642;
          }
          while (v642);
          if (v737)
          {
            v645 = &v64[v741];
            v646 = (unint64_t)v645 >= v737;
            if ((unint64_t)v645 >= v737)
              v647 = -(uint64_t)(v741 * v720);
            else
              v647 = 0;
            v49 = &v645[v647];
            v648 = v57 + 2 * v647;
            if (v646)
              v649 = -(uint64_t)(v739 * v720);
            else
              v649 = 0;
            v54 = &v55[2 * v739 + 2 * v649];
            v57 = v648 + 2 * v741;
            v64 = v49;
            v55 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          --v641;
        }
        while (v641);
        goto LABEL_1236;
      case 13:
        v351 = v761[0];
        while (1)
        {
          v352 = v10;
          do
          {
            if ((_DWORD)v36)
            {
              v353 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_678;
              if (!(_DWORD)v23)
              {
LABEL_668:
                v354 = 0xFFFF;
                goto LABEL_669;
              }
            }
            else
            {
              v353 = 0xFFFF;
              if (!(_DWORD)v23)
                goto LABEL_668;
            }
            v354 = *(unsigned __int16 *)v53;
            if (!*(_WORD *)v53)
            {
              *(_WORD *)v63 = *v49;
              *(_WORD *)v53 = v353;
              goto LABEL_678;
            }
LABEL_669:
            v355 = (v354 ^ 0xFFFF) * (unint64_t)(unsigned __int16)*v49
                 + ((v353 ^ 0xFFFF) + (unsigned __int16)*v49) * (unint64_t)*(unsigned __int16 *)v63;
            if (v355 <= 0xFFFE8000)
              v356 = v355 + 0x8000;
            else
              v356 = 4294868992;
            v357 = (v356 + (v356 >> 16)) >> 16;
            if ((_DWORD)v23)
            {
              v358 = 0xFFFF * (v354 + (unint64_t)v353) - v354 * (unint64_t)v353;
              if (v358 <= 4294868992)
                v359 = v358 + 0x8000;
              else
                v359 = 4294868992;
              *(_WORD *)v63 = v357;
              *(_WORD *)v53 = (v357 | ((v359 >> 16) + (_DWORD)v359)) >> 16;
            }
            else
            {
              *(_WORD *)v63 = v357;
            }
LABEL_678:
            v360 = &v49[v719];
            if ((unint64_t)v360 >= v57)
              v361 = -(uint64_t)v721;
            else
              v361 = 0;
            v49 = &v360[v361];
            v54 += 2 * (int)v36 + 2 * v361;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v352;
          }
          while (v352);
          if (v737)
          {
            v362 = &v64[v741];
            v363 = (unint64_t)v362 >= v737;
            if ((unint64_t)v362 >= v737)
              v364 = -(uint64_t)(v741 * v720);
            else
              v364 = 0;
            v49 = &v362[v364];
            v365 = v57 + 2 * v364;
            if (v363)
              v366 = -(uint64_t)(v739 * v720);
            else
              v366 = 0;
            v54 = &v747[2 * v739 + 2 * v366];
            v57 = v365 + 2 * v741;
            v64 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          if (!--v351)
            goto LABEL_1152;
        }
      case 14:
        v367 = v761[0];
        while (1)
        {
          v368 = v10;
          do
          {
            if ((_DWORD)v36)
            {
              v369 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_711;
              if (!(_DWORD)v23)
              {
LABEL_701:
                v370 = 0xFFFF;
                goto LABEL_702;
              }
            }
            else
            {
              v369 = 0xFFFF;
              if (!(_DWORD)v23)
                goto LABEL_701;
            }
            v370 = *(unsigned __int16 *)v53;
            if (!*(_WORD *)v53)
            {
              *(_WORD *)v63 = *v49;
              *(_WORD *)v53 = v369;
              goto LABEL_711;
            }
LABEL_702:
            v371 = (*(unsigned __int16 *)v63 ^ 0xFFFFu) * (unint64_t)(unsigned __int16)*v49
                 - *(unsigned __int16 *)v63
                 + ((unint64_t)*(unsigned __int16 *)v63 << 16);
            if (v371 <= 0xFFFE8000)
              v372 = v371 + 0x8000;
            else
              v372 = 4294868992;
            v373 = (v372 + (v372 >> 16)) >> 16;
            if ((_DWORD)v23)
            {
              v374 = 0xFFFF * (v370 + (unint64_t)v369) - v370 * (unint64_t)v369;
              if (v374 <= 4294868992)
                v375 = v374 + 0x8000;
              else
                v375 = 4294868992;
              *(_WORD *)v63 = v373;
              *(_WORD *)v53 = (v373 | ((v375 >> 16) + (_DWORD)v375)) >> 16;
            }
            else
            {
              *(_WORD *)v63 = v373;
            }
LABEL_711:
            v376 = &v49[v719];
            if ((unint64_t)v376 >= v57)
              v377 = -(uint64_t)v721;
            else
              v377 = 0;
            v49 = &v376[v377];
            v54 += 2 * (int)v36 + 2 * v377;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v368;
          }
          while (v368);
          if (v737)
          {
            v378 = &v64[v741];
            v379 = (unint64_t)v378 >= v737;
            if ((unint64_t)v378 >= v737)
              v380 = -(uint64_t)(v741 * v720);
            else
              v380 = 0;
            v49 = &v378[v380];
            v381 = v57 + 2 * v380;
            if (v379)
              v382 = -(uint64_t)(v739 * v720);
            else
              v382 = 0;
            v54 = &v747[2 * v739 + 2 * v382];
            v57 = v381 + 2 * v741;
            v64 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          if (!--v367)
            goto LABEL_1152;
        }
      case 15:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v383 = (int)v36;
        v384 = v761[0];
        v385 = 2 * (int)v23;
        while (1)
        {
          v723 = v384;
          v386 = v10;
          v387 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v388 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_736;
              if ((_DWORD)v23)
                goto LABEL_731;
            }
            else
            {
              v388 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_731:
                if (*(_WORD *)v53)
                {
                  v389 = PDAoverlayPDA_8071(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v388);
                  v57 = v387;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v389;
                  *(_WORD *)v53 = HIWORD(v389);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v388;
                }
                goto LABEL_736;
              }
            }
            v390 = PDAoverlayPDA_8071(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v388);
            v57 = v387;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v390;
LABEL_736:
            v391 = &v49[v719];
            if ((unint64_t)v391 >= v57)
              v392 = -(uint64_t)v721;
            else
              v392 = 0;
            v49 = &v391[v392];
            v54 += 2 * v383 + 2 * v392;
            v63 += 2 * v719;
            v53 += v385;
            --v386;
          }
          while (v386);
          if (v737)
          {
            v393 = &v736[v741];
            v394 = (unint64_t)v393 >= v737;
            v395 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v393 < v737)
              v395 = 0;
            v49 = &v393[v395];
            v396 = v57 + 2 * v395;
            v397 = -(uint64_t)(v739 * v720);
            if (!v394)
              v397 = 0;
            v54 = &v747[2 * v739 + 2 * v397];
            v57 = v396 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v384 = v723 - 1;
          if (v723 == 1)
          {
LABEL_1042:
            v19 = v57;
            v761[0] = 0;
            v7 = v715;
LABEL_1043:
            v5 = v712;
LABEL_1044:
            v22 = v713;
LABEL_1153:
            v52 = v722;
LABEL_1154:
            v55 = v747;
            if (!v52)
              return 1;
LABEL_1237:
            v760 = 0;
LABEL_1238:
            v747 = v55;
            if (!shape_enum_clip_next(v52, (int *)&v760 + 1, &v760, v771, v761))
            {
              v48 = (void *)v52;
LABEL_1262:
              free(v48);
              return 1;
            }
            v722 = v52;
            if (v737)
            {
              v63 = (_BYTE *)(v717 + 2 * v735 * (int)v760 + 2 * SHIDWORD(v760));
              v684 = ((int)v760 + *(_DWORD *)(v711 + 60)) % v720;
              v56 = v771[0];
              v685 = (HIDWORD(v760) + *(_DWORD *)(v711 + 56)) % v721;
              v686 = v716 + 2 * v741 * v684;
              v49 = (_WORD *)(v686 + 2 * v685);
              v57 = v686 + 2 * v721;
              v23 = v759;
              v687 = v752;
              if ((_DWORD)v759)
                v687 = v22 - v771[0];
              v752 = v687;
              if ((_DWORD)v759)
                v53 = &v718[2 * v22 * (int)v760 + 2 * SHIDWORD(v760)];
              if ((_DWORD)v756)
                v36 = v756;
              else
                v36 = 0;
              if ((_DWORD)v756)
                v54 = &v5[2 * v739 * v684 + 2 * v685];
              v688 = (uint64_t)v747;
              if ((_DWORD)v756)
                v688 = (uint64_t)&v5[2 * v739 * v684 + 2 * v685];
              v747 = (char *)v688;
              LODWORD(v10) = v771[0];
              v64 = v49;
              v709 = (HIDWORD(v760) + *(_DWORD *)(v711 + 56)) % v721;
              v710 = ((int)v760 + *(_DWORD *)(v711 + 60)) % v720;
            }
            else
            {
              v737 = 0;
              v689 = HIDWORD(v760) * v719;
              LODWORD(v10) = v771[0];
              v690 = v771[0] * v719;
              v63 = (_BYTE *)(v717 + 2 * v735 * (int)v760 + 2 * HIDWORD(v760) * v719);
              v56 = v771[0] * v719;
              v49 = (_WORD *)(v716 + 2 * (int)v760 * v721 + 2 * HIDWORD(v760) * v719);
              v741 = v721 - v771[0] * v719;
              v36 = v756;
              v23 = v759;
              v691 = v752;
              if ((_DWORD)v759)
                v691 = v22 - v690;
              v752 = v691;
              if ((_DWORD)v759)
                v53 = &v718[2 * v22 * (int)v760 + 2 * v689];
              v692 = (uint64_t)&v5[2 * (int)v760 * v720 + 2 * v689];
              v693 = v720 - v690;
              v694 = v739;
              if ((_DWORD)v756)
                v694 = v693;
              v739 = v694;
              if ((_DWORD)v756)
                v54 = (char *)v692;
              v57 = v19;
              v64 = v736;
            }
            goto LABEL_400;
          }
        }
      case 16:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v398 = (int)v36;
        v399 = v761[0];
        v400 = 2 * (int)v23;
        while (1)
        {
          v724 = v399;
          v401 = v10;
          v402 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v403 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_759;
              if ((_DWORD)v23)
                goto LABEL_754;
            }
            else
            {
              v403 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_754:
                if (*(_WORD *)v53)
                {
                  v404 = PDAdarkenPDA_8073(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v403);
                  v57 = v402;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v404;
                  *(_WORD *)v53 = HIWORD(v404);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v403;
                }
                goto LABEL_759;
              }
            }
            v405 = PDAdarkenPDA_8073(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v403);
            v57 = v402;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v405;
LABEL_759:
            v406 = &v49[v719];
            if ((unint64_t)v406 >= v57)
              v407 = -(uint64_t)v721;
            else
              v407 = 0;
            v49 = &v406[v407];
            v54 += 2 * v398 + 2 * v407;
            v63 += 2 * v719;
            v53 += v400;
            --v401;
          }
          while (v401);
          if (v737)
          {
            v408 = &v736[v741];
            v409 = (unint64_t)v408 >= v737;
            v410 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v408 < v737)
              v410 = 0;
            v49 = &v408[v410];
            v411 = v57 + 2 * v410;
            v412 = -(uint64_t)(v739 * v720);
            if (!v409)
              v412 = 0;
            v54 = &v747[2 * v739 + 2 * v412];
            v57 = v411 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v399 = v724 - 1;
          if (v724 == 1)
            goto LABEL_1042;
        }
      case 17:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v413 = (int)v36;
        v414 = v761[0];
        v415 = 2 * (int)v23;
        while (1)
        {
          v725 = v414;
          v416 = v10;
          v417 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v418 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_782;
              if ((_DWORD)v23)
                goto LABEL_777;
            }
            else
            {
              v418 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_777:
                if (*(_WORD *)v53)
                {
                  v419 = PDAlightenPDA_8072(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v418);
                  v57 = v417;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v419;
                  *(_WORD *)v53 = HIWORD(v419);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v418;
                }
                goto LABEL_782;
              }
            }
            v420 = PDAlightenPDA_8072(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v418);
            v57 = v417;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v420;
LABEL_782:
            v421 = &v49[v719];
            if ((unint64_t)v421 >= v57)
              v422 = -(uint64_t)v721;
            else
              v422 = 0;
            v49 = &v421[v422];
            v54 += 2 * v413 + 2 * v422;
            v63 += 2 * v719;
            v53 += v415;
            --v416;
          }
          while (v416);
          if (v737)
          {
            v423 = &v736[v741];
            v424 = (unint64_t)v423 >= v737;
            v425 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v423 < v737)
              v425 = 0;
            v49 = &v423[v425];
            v426 = v57 + 2 * v425;
            v427 = -(uint64_t)(v739 * v720);
            if (!v424)
              v427 = 0;
            v54 = &v747[2 * v739 + 2 * v427];
            v57 = v426 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v414 = v725 - 1;
          if (v725 == 1)
            goto LABEL_1042;
        }
      case 18:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v428 = (int)v36;
        v429 = v761[0];
        v430 = 2 * (int)v23;
        while (1)
        {
          v726 = v429;
          v431 = v10;
          v432 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v433 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_805;
              if ((_DWORD)v23)
                goto LABEL_800;
            }
            else
            {
              v433 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_800:
                if (*(_WORD *)v53)
                {
                  v434 = PDAcolordodgePDA_8074(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v433);
                  v57 = v432;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v434;
                  *(_WORD *)v53 = HIWORD(v434);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v433;
                }
                goto LABEL_805;
              }
            }
            v435 = PDAcolordodgePDA_8074(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v433);
            v57 = v432;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v435;
LABEL_805:
            v436 = &v49[v719];
            if ((unint64_t)v436 >= v57)
              v437 = -(uint64_t)v721;
            else
              v437 = 0;
            v49 = &v436[v437];
            v54 += 2 * v428 + 2 * v437;
            v63 += 2 * v719;
            v53 += v430;
            --v431;
          }
          while (v431);
          if (v737)
          {
            v438 = &v736[v741];
            v439 = (unint64_t)v438 >= v737;
            v440 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v438 < v737)
              v440 = 0;
            v49 = &v438[v440];
            v441 = v57 + 2 * v440;
            v442 = -(uint64_t)(v739 * v720);
            if (!v439)
              v442 = 0;
            v54 = &v747[2 * v739 + 2 * v442];
            v57 = v441 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v429 = v726 - 1;
          if (v726 == 1)
            goto LABEL_1042;
        }
      case 19:
        v736 = v64;
        v714 = v22;
        v443 = (int)v36;
        v444 = v761[0];
        v445 = 2 * (int)v23;
        while (1)
        {
          v727 = v444;
          v446 = v10;
          v447 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v448 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_828;
              if ((_DWORD)v23)
                goto LABEL_823;
            }
            else
            {
              v448 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_823:
                if (*(_WORD *)v53)
                {
                  v449 = PDAcolorburnPDA_8075(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v448);
                  v57 = v447;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v449;
                  *(_WORD *)v53 = HIWORD(v449);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v448;
                }
                goto LABEL_828;
              }
            }
            v450 = PDAcolorburnPDA_8075(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v448);
            v57 = v447;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v450;
LABEL_828:
            v451 = &v49[v719];
            if ((unint64_t)v451 >= v57)
              v452 = -(uint64_t)v721;
            else
              v452 = 0;
            v49 = &v451[v452];
            v54 += 2 * v443 + 2 * v452;
            v63 += 2 * v719;
            v53 += v445;
            --v446;
          }
          while (v446);
          if (v737)
          {
            v453 = &v736[v741];
            v454 = (unint64_t)v453 >= v737;
            v455 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v453 < v737)
              v455 = 0;
            v49 = &v453[v455];
            v456 = v57 + 2 * v455;
            v457 = -(uint64_t)(v739 * v720);
            if (!v454)
              v457 = 0;
            v54 = &v747[2 * v739 + 2 * v457];
            v57 = v456 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v444 = v727 - 1;
          if (v727 == 1)
          {
            v19 = v57;
            v761[0] = 0;
            v22 = v714;
            v7 = v715;
            goto LABEL_1153;
          }
        }
      case 20:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v458 = (int)v36;
        v459 = v761[0];
        v460 = 2 * (int)v23;
        while (1)
        {
          v728 = v459;
          v461 = v10;
          v462 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v463 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_851;
              if ((_DWORD)v23)
                goto LABEL_846;
            }
            else
            {
              v463 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_846:
                if (*(_WORD *)v53)
                {
                  v464 = PDAsoftlightPDA_8077(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v463);
                  v57 = v462;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v464;
                  *(_WORD *)v53 = HIWORD(v464);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v463;
                }
                goto LABEL_851;
              }
            }
            v465 = PDAsoftlightPDA_8077(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v463);
            v57 = v462;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v465;
LABEL_851:
            v466 = &v49[v719];
            if ((unint64_t)v466 >= v57)
              v467 = -(uint64_t)v721;
            else
              v467 = 0;
            v49 = &v466[v467];
            v54 += 2 * v458 + 2 * v467;
            v63 += 2 * v719;
            v53 += v460;
            --v461;
          }
          while (v461);
          if (v737)
          {
            v468 = &v736[v741];
            v469 = (unint64_t)v468 >= v737;
            v470 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v468 < v737)
              v470 = 0;
            v49 = &v468[v470];
            v471 = v57 + 2 * v470;
            v472 = -(uint64_t)(v739 * v720);
            if (!v469)
              v472 = 0;
            v54 = &v747[2 * v739 + 2 * v472];
            v57 = v471 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v459 = v728 - 1;
          if (v728 == 1)
            goto LABEL_1042;
        }
      case 21:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v473 = (int)v36;
        v474 = v761[0];
        v475 = 2 * (int)v23;
        while (1)
        {
          v729 = v474;
          v476 = v10;
          v477 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v478 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_874;
              if ((_DWORD)v23)
                goto LABEL_869;
            }
            else
            {
              v478 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_869:
                if (*(_WORD *)v53)
                {
                  v479 = PDAhardlightPDA_8076(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v478);
                  v57 = v477;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v479;
                  *(_WORD *)v53 = HIWORD(v479);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v478;
                }
                goto LABEL_874;
              }
            }
            v480 = PDAhardlightPDA_8076(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v478);
            v57 = v477;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v480;
LABEL_874:
            v481 = &v49[v719];
            if ((unint64_t)v481 >= v57)
              v482 = -(uint64_t)v721;
            else
              v482 = 0;
            v49 = &v481[v482];
            v54 += 2 * v473 + 2 * v482;
            v63 += 2 * v719;
            v53 += v475;
            --v476;
          }
          while (v476);
          if (v737)
          {
            v483 = &v736[v741];
            v484 = (unint64_t)v483 >= v737;
            v485 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v483 < v737)
              v485 = 0;
            v49 = &v483[v485];
            v486 = v57 + 2 * v485;
            v487 = -(uint64_t)(v739 * v720);
            if (!v484)
              v487 = 0;
            v54 = &v747[2 * v739 + 2 * v487];
            v57 = v486 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v474 = v729 - 1;
          if (v729 == 1)
            goto LABEL_1042;
        }
      case 22:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v488 = (int)v36;
        v489 = v761[0];
        v490 = 2 * (int)v23;
        while (1)
        {
          v730 = v489;
          v491 = v10;
          v492 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v493 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_897;
              if ((_DWORD)v23)
                goto LABEL_892;
            }
            else
            {
              v493 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_892:
                if (*(_WORD *)v53)
                {
                  v494 = PDAdifferencePDA_8078(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v493);
                  v57 = v492;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v494;
                  *(_WORD *)v53 = HIWORD(v494);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v493;
                }
                goto LABEL_897;
              }
            }
            v495 = PDAdifferencePDA_8078(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v493);
            v57 = v492;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v495;
LABEL_897:
            v496 = &v49[v719];
            if ((unint64_t)v496 >= v57)
              v497 = -(uint64_t)v721;
            else
              v497 = 0;
            v49 = &v496[v497];
            v54 += 2 * v488 + 2 * v497;
            v63 += 2 * v719;
            v53 += v490;
            --v491;
          }
          while (v491);
          if (v737)
          {
            v498 = &v736[v741];
            v499 = (unint64_t)v498 >= v737;
            v500 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v498 < v737)
              v500 = 0;
            v49 = &v498[v500];
            v501 = v57 + 2 * v500;
            v502 = -(uint64_t)(v739 * v720);
            if (!v499)
              v502 = 0;
            v54 = &v747[2 * v739 + 2 * v502];
            v57 = v501 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v489 = v730 - 1;
          if (v730 == 1)
            goto LABEL_1042;
        }
      case 23:
        v503 = v761[0];
        while (1)
        {
          v504 = v10;
          do
          {
            if ((_DWORD)v36)
            {
              v505 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_934;
              if (!(_DWORD)v23)
              {
LABEL_918:
                v506 = 0xFFFF;
                goto LABEL_919;
              }
            }
            else
            {
              v505 = 0xFFFF;
              if (!(_DWORD)v23)
                goto LABEL_918;
            }
            v506 = *(unsigned __int16 *)v53;
            if (!*(_WORD *)v53)
            {
              *(_WORD *)v63 = *v49;
              *(_WORD *)v53 = v505;
              goto LABEL_934;
            }
LABEL_919:
            if ((unsigned __int16)*v49 >= v505)
              v507 = v505;
            else
              v507 = (unsigned __int16)*v49;
            if (*(unsigned __int16 *)v63 >= v506)
              v508 = v506;
            else
              v508 = *(unsigned __int16 *)v63;
            v509 = 0xFFFF * (v507 + v508) - 2 * v508 * (unint64_t)v507;
            if (v509 <= 4294868992)
              v510 = v509 + 0x8000;
            else
              v510 = 4294868992;
            v511 = (v510 + (v510 >> 16)) >> 16;
            if ((_DWORD)v23)
            {
              v512 = 0xFFFF * (v506 + (unint64_t)v505) - v506 * (unint64_t)v505;
              if (v512 <= 4294868992)
                v513 = v512 + 0x8000;
              else
                v513 = 4294868992;
              *(_WORD *)v63 = v511;
              *(_WORD *)v53 = (v511 | ((v513 >> 16) + (_DWORD)v513)) >> 16;
            }
            else
            {
              *(_WORD *)v63 = v511;
            }
LABEL_934:
            v514 = &v49[v719];
            if ((unint64_t)v514 >= v57)
              v515 = -(uint64_t)v721;
            else
              v515 = 0;
            v49 = &v514[v515];
            v54 += 2 * (int)v36 + 2 * v515;
            v63 += 2 * v719;
            v53 += 2 * (int)v23;
            --v504;
          }
          while (v504);
          if (v737)
          {
            v516 = &v64[v741];
            v517 = (unint64_t)v516 >= v737;
            if ((unint64_t)v516 >= v737)
              v518 = -(uint64_t)(v741 * v720);
            else
              v518 = 0;
            v49 = &v516[v518];
            v519 = v57 + 2 * v518;
            if (v517)
              v520 = -(uint64_t)(v739 * v720);
            else
              v520 = 0;
            v54 = &v747[2 * v739 + 2 * v520];
            v57 = v519 + 2 * v741;
            v64 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          if (!--v503)
          {
LABEL_1152:
            v736 = v64;
            v19 = v57;
            v761[0] = 0;
            goto LABEL_1153;
          }
        }
      case 24:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v521 = (int)v36;
        v522 = v761[0];
        v523 = 2 * (int)v23;
        while (1)
        {
          v731 = v522;
          v524 = v10;
          v525 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v526 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_959;
              if ((_DWORD)v23)
                goto LABEL_954;
            }
            else
            {
              v526 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_954:
                if (*(_WORD *)v53)
                {
                  v527 = PDAhuePDA_8079(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v526);
                  v57 = v525;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v527;
                  *(_WORD *)v53 = HIWORD(v527);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v526;
                }
                goto LABEL_959;
              }
            }
            v528 = PDAhuePDA_8079(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v526);
            v57 = v525;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v528;
LABEL_959:
            v529 = &v49[v719];
            if ((unint64_t)v529 >= v57)
              v530 = -(uint64_t)v721;
            else
              v530 = 0;
            v49 = &v529[v530];
            v54 += 2 * v521 + 2 * v530;
            v63 += 2 * v719;
            v53 += v523;
            --v524;
          }
          while (v524);
          if (v737)
          {
            v531 = &v736[v741];
            v532 = (unint64_t)v531 >= v737;
            v533 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v531 < v737)
              v533 = 0;
            v49 = &v531[v533];
            v534 = v57 + 2 * v533;
            v535 = -(uint64_t)(v739 * v720);
            if (!v532)
              v535 = 0;
            v54 = &v747[2 * v739 + 2 * v535];
            v57 = v534 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v522 = v731 - 1;
          if (v731 == 1)
            goto LABEL_1042;
        }
      case 25:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v536 = (int)v36;
        v537 = v761[0];
        v538 = 2 * (int)v23;
        while (1)
        {
          v732 = v537;
          v539 = v10;
          v540 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v541 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_982;
              if ((_DWORD)v23)
                goto LABEL_977;
            }
            else
            {
              v541 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_977:
                if (*(_WORD *)v53)
                {
                  v542 = PDAhuePDA_8079(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v541);
                  v57 = v540;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v542;
                  *(_WORD *)v53 = HIWORD(v542);
                }
                else
                {
                  *(_WORD *)v63 = *v49;
                  *(_WORD *)v53 = v541;
                }
                goto LABEL_982;
              }
            }
            v543 = PDAhuePDA_8079(*(unsigned __int16 *)v63, 0xFFFFu, (unsigned __int16)*v49, v541);
            v57 = v540;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v543;
LABEL_982:
            v544 = &v49[v719];
            if ((unint64_t)v544 >= v57)
              v545 = -(uint64_t)v721;
            else
              v545 = 0;
            v49 = &v544[v545];
            v54 += 2 * v536 + 2 * v545;
            v63 += 2 * v719;
            v53 += v538;
            --v539;
          }
          while (v539);
          if (v737)
          {
            v546 = &v736[v741];
            v547 = (unint64_t)v546 >= v737;
            v548 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v546 < v737)
              v548 = 0;
            v49 = &v546[v548];
            v549 = v57 + 2 * v548;
            v550 = -(uint64_t)(v739 * v720);
            if (!v547)
              v550 = 0;
            v54 = &v747[2 * v739 + 2 * v550];
            v57 = v549 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v537 = v732 - 1;
          if (v732 == 1)
            goto LABEL_1042;
        }
      case 26:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v551 = (int)v36;
        v552 = v761[0];
        v553 = 2 * (int)v23;
        while (1)
        {
          v733 = v552;
          v554 = v10;
          v555 = v57;
          do
          {
            if ((_DWORD)v36)
            {
              v556 = *(unsigned __int16 *)v54;
              if (!*(_WORD *)v54)
                goto LABEL_1005;
              if ((_DWORD)v23)
                goto LABEL_1000;
            }
            else
            {
              v556 = 0xFFFF;
              if ((_DWORD)v23)
              {
LABEL_1000:
                v557 = (unsigned __int16)*v49;
                if (*(_WORD *)v53)
                {
                  v558 = PDAluminosityPDA_8081(v557, v556, *(unsigned __int16 *)v63, *(unsigned __int16 *)v53);
                  v57 = v555;
                  LODWORD(v36) = v756;
                  LODWORD(v23) = v759;
                  *(_WORD *)v63 = v558;
                  *(_WORD *)v53 = HIWORD(v558);
                }
                else
                {
                  *(_WORD *)v63 = v557;
                  *(_WORD *)v53 = v556;
                }
                goto LABEL_1005;
              }
            }
            v559 = PDAluminosityPDA_8081((unsigned __int16)*v49, v556, *(unsigned __int16 *)v63, 0xFFFFu);
            v57 = v555;
            LODWORD(v36) = v756;
            LODWORD(v23) = v759;
            *(_WORD *)v63 = v559;
LABEL_1005:
            v560 = &v49[v719];
            if ((unint64_t)v560 >= v57)
              v561 = -(uint64_t)v721;
            else
              v561 = 0;
            v49 = &v560[v561];
            v54 += 2 * v551 + 2 * v561;
            v63 += 2 * v719;
            v53 += v553;
            --v554;
          }
          while (v554);
          if (v737)
          {
            v562 = &v736[v741];
            v563 = (unint64_t)v562 >= v737;
            v564 = -(uint64_t)(v741 * v720);
            if ((unint64_t)v562 < v737)
              v564 = 0;
            v49 = &v562[v564];
            v565 = v57 + 2 * v564;
            v566 = -(uint64_t)(v739 * v720);
            if (!v563)
              v566 = 0;
            v54 = &v747[2 * v739 + 2 * v566];
            v57 = v565 + 2 * v741;
            v736 = v49;
            v747 = v54;
          }
          else
          {
            v49 += v741;
            v54 += 2 * v739;
          }
          v63 += 2 * *(_QWORD *)v749;
          v53 += 2 * v752;
          v552 = v733 - 1;
          if (v733 == 1)
            goto LABEL_1042;
        }
      case 27:
        v736 = v64;
        v712 = v5;
        v713 = v22;
        v745 = v10;
        v567 = (int)v36;
        v568 = v761[0];
        v569 = 2 * (int)v23;
        v570 = -(uint64_t)v721;
        break;
      default:
        v736 = v64;
        v19 = v57;
        goto LABEL_1153;
    }
LABEL_1019:
    v734 = v568;
    v571 = v745;
    while (1)
    {
      if ((_DWORD)v36)
      {
        v572 = *(unsigned __int16 *)v54;
        if (!*(_WORD *)v54)
          goto LABEL_1030;
        if (!(_DWORD)v23)
          goto LABEL_1026;
      }
      else
      {
        v572 = 0xFFFF;
        if (!(_DWORD)v23)
        {
LABEL_1026:
          v576 = (unsigned __int16)*v49;
          if (v576 >= v572)
            LOWORD(v576) = v572;
          v577 = *(unsigned __int16 *)v63 * (unint64_t)(unsigned __int16)~(_WORD)v572 + 0x8000;
          *(_WORD *)v63 = v576 + (((v577 >> 16) + v577) >> 16);
          goto LABEL_1030;
        }
      }
      if (*(_WORD *)v53)
      {
        v573 = v57;
        *(_QWORD *)v754 = v54;
        v574 = v570;
        v575 = PDAluminosityPDA_8081(*(unsigned __int16 *)v63, *(unsigned __int16 *)v53, (unsigned __int16)*v49, v572);
        v570 = v574;
        v54 = *(char **)v754;
        LODWORD(v36) = v756;
        v57 = v573;
        LODWORD(v23) = v759;
        *(_WORD *)v63 = v575;
        *(_WORD *)v53 = HIWORD(v575);
      }
      else
      {
        *(_WORD *)v63 = *v49;
        *(_WORD *)v53 = v572;
      }
LABEL_1030:
      v578 = &v49[v719];
      if ((unint64_t)v578 >= v57)
        v579 = v570;
      else
        v579 = 0;
      v49 = &v578[v579];
      v54 += 2 * v567 + 2 * v579;
      v63 += 2 * v719;
      v53 += v569;
      if (!--v571)
      {
        if (v737)
        {
          v580 = &v736[v741];
          v581 = (unint64_t)v580 >= v737;
          v582 = -(uint64_t)(v741 * v720);
          if ((unint64_t)v580 < v737)
            v582 = 0;
          v49 = &v580[v582];
          v583 = v57 + 2 * v582;
          v584 = -(uint64_t)(v739 * v720);
          if (!v581)
            v584 = 0;
          v54 = &v747[2 * v739 + 2 * v584];
          v57 = v583 + 2 * v741;
          v736 = v49;
          v747 = v54;
        }
        else
        {
          v49 += v741;
          v54 += 2 * v739;
        }
        v63 += 2 * *(_QWORD *)v749;
        v53 += 2 * v752;
        v568 = v734 - 1;
        if (v734 == 1)
          goto LABEL_1042;
        goto LABEL_1019;
      }
    }
  }
  v15 = *(_DWORD *)(v3 + 128);
  if ((v15 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      w16_mark_constmask(v3, v7);
    else
      w16_mark_pixelmask(v3, v7);
  }
  else
  {
    v24 = *(_DWORD *)(v3 + 112);
    v25 = *(_DWORD *)(v3 + 116);
    v26 = (v24 + 15) & 0xFFFFFFF0;
    v27 = v26 * v25;
    if ((int)v27 <= 4096)
    {
      v29 = v771;
    }
    else
    {
      v28 = malloc_type_malloc(v27, 0x8303D2FuLL);
      if (!v28)
        return 1;
      v29 = v28;
      v14 = *(uint16x4_t **)(v9 + 136);
      v15 = *(_DWORD *)(v9 + 128);
    }
    CGSConvertBitsToMask(v14, *(_DWORD *)(v9 + 124), v29, v26, v24, v25, v15);
    v43 = *(_OWORD *)(v9 + 112);
    v767 = *(_OWORD *)(v9 + 96);
    v768 = v43;
    v44 = *(_OWORD *)(v9 + 144);
    v769 = *(_OWORD *)(v9 + 128);
    v770 = v44;
    v45 = *(_OWORD *)(v9 + 48);
    v763 = *(_OWORD *)(v9 + 32);
    v764 = v45;
    v46 = *(_OWORD *)(v9 + 80);
    v765 = *(_OWORD *)(v9 + 64);
    v766 = v46;
    v47 = *(_OWORD *)(v9 + 16);
    *(_OWORD *)v761 = *(_OWORD *)v9;
    v762 = v47;
    HIDWORD(v768) = (v24 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v769 + 1) = v29;
    if (BYTE1(v761[0]) << 8 == 1024)
      w16_mark_constmask((uint64_t)v761, v715);
    else
      w16_mark_pixelmask((unint64_t)v761, v715);
    if (v29 != (_BYTE *)v771)
    {
      v48 = v29;
      goto LABEL_1262;
    }
  }
  return 1;
}

uint64_t w16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL4 v7;
  signed int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  unint64_t v23;
  uint64_t (*v24)(uint64_t, int *, int, int, int, int);
  uint64_t v25;
  int v26;
  int v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _OWORD v45[64];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v28 = 0u;
  memset(v45, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*(_QWORD *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v28, (uint64_t)v45) < 1)
    return 0xFFFFFFFFLL;
  v18 = 68161828;
  v19 = *(_DWORD *)a3;
  *((_QWORD *)&v28 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 68161828)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(_QWORD *)&v28 = *(_QWORD *)&W16_image_sample[2 * v20 + 2];
      if ((_QWORD)v28)
      {
LABEL_27:
        DWORD2(v28) = v18;
        if ((v21 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v29) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v20 <= 0xB)
        {
          HIDWORD(v23) = v22;
          LODWORD(v23) = v22;
          switch((v23 >> 3))
          {
            case 0u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = w16_image_mark_RGB32;
              goto LABEL_50;
            case 1u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = w16_image_mark_RGB32;
              goto LABEL_52;
            case 2u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = w16_image_mark_W8;
              goto LABEL_50;
            case 3u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = w16_image_mark_RGB24;
              goto LABEL_50;
            case 4u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = w16_image_mark_rgb32;
LABEL_50:
              v25 = (uint64_t)a2;
              v26 = v8;
              v27 = 0;
              break;
            case 5u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = w16_image_mark_rgb32;
LABEL_52:
              v25 = (uint64_t)a2;
              v26 = v8;
              v27 = 8;
              break;
            default:
              goto LABEL_28;
          }
          w16_image_mark_image(v25, (uint64_t)&v28, v26, v27, (void (*)(_QWORD, _QWORD))v24);
          return 1;
        }
        goto LABEL_28;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(_QWORD *)&v28 = *(_QWORD *)&W8_image_sample[2 * v20 + 2];
        if ((_QWORD)v28)
        {
          v18 = 34083076;
          goto LABEL_27;
        }
      }
      *(_QWORD *)&v28 = *(_QWORD *)&WF_image_sample[2 * v20 + 2];
      if ((_QWORD)v28)
      {
        LODWORD(v29) = 8;
        v18 = 136319269;
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(_QWORD)v39 && (~DWORD1(v29) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((BYTE4(v29) & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      w16_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(_QWORD *)&v28 = w16_sample_w16;
LABEL_28:
  w16_image_mark((uint64_t)a2, (uint64_t)&v28, v8, v17);
  return 1;
}

uint64_t w16_shade(uint64_t a1, __n128 a2)
{
  uint64_t *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  signed int v11;
  __n128 v13;
  void *v14;
  unint64_t v15;
  _BYTE *v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38[2];
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[2];
  int v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[40];
  uint64_t v47;

  v2 = (uint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v7 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v8 = *v2;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  v9 = *(_QWORD *)(v8 + 56);
  v10 = *v3;
  if (!*((_QWORD *)v3 + 12))
  {
    if (*(_QWORD *)(v4 + 72))
      v7 = 0;
    else
      v7 = *(float *)(v4 + 4) >= 1.0;
  }
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v11 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) == 0x1000000)
  {
    if (*(_QWORD *)(v5 + 16))
    {
      v14 = w16_shade_radial_W;
    }
    else if (*(_QWORD *)(v5 + 24))
    {
      v14 = w16_shade_conic_W;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      v14 = w16_shade_axial_W;
    }
    else
    {
      v14 = w16_shade_custom_W;
    }
    *(_QWORD *)&v17[0] = v14;
    if ((_QWORD)v40)
    {
      *((_QWORD *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 1, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    v15 = *((_QWORD *)&v19 + 1) * v19;
    if ((uint64_t)(*((_QWORD *)&v19 + 1) * v19) <= 960)
    {
      v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 1, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(_BYTE *)(v5 + 1))
        *(_QWORD *)&v39 = &_blt_shade_samples_noise;
      goto LABEL_29;
    }
    v16 = malloc_type_malloc(4 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      v15 = *((_QWORD *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)&v17[0])
    return 0xFFFFFFFFLL;
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  w16_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1]))
    free(v38[1]);
  return 1;
}

void w16_shade_radial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float *v12;
  float v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  _BYTE *v22;
  _DWORD *v23;
  uint64_t v24;
  _DWORD *v25;
  uint64_t v26;
  float v27;
  float v28;
  int v29;
  int v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  BOOL v42;
  float v43;
  BOOL v44;
  int v45;
  float v46;
  _DWORD *v47;
  float v48;
  float v49;
  float v50;
  int v51;
  float v52;
  float v53;
  float v54;
  float v56;
  float v57;
  float v58;
  int v59;
  int v60;
  uint64_t v62;
  int v63;
  _DWORD *v64;
  char v65;
  uint64_t v66;
  int *v67;
  int v68;
  int v69;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(a1 + 284);
  v6 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v7 = v6 * (float)a2;
  v8 = v6 * (float)a3;
  v9 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v8) + (float)(v4 * v7));
  v10 = *(float *)(a1 + 300) + (float)((float)(v8 * *(float *)(a1 + 292)) + (float)(v5 * v7));
  v12 = *(float **)(a1 + 400);
  v13 = *(float *)(a1 + 336);
  v14 = *(float *)(a1 + 344);
  v15 = *(float *)(a1 + 304);
  v16 = *(float *)(a1 + 308);
  v17 = *(unsigned int *)(a1 + 324);
  v18 = v12[2];
  v19 = v12[4];
  v20 = v12[5];
  v21 = v12[7];
  v24 = a1 + 144;
  v22 = *(_BYTE **)(a1 + 144);
  v23 = *(_DWORD **)(v24 + 8);
  v25 = *(_DWORD **)(a1 + 376);
  v26 = *(_QWORD *)(a1 + 360);
  if (v18 != 0.0 || v21 != 0.0 || v5 != 0.0)
  {
    v30 = *(_DWORD *)(a1 + 320);
    v31 = v12[3];
    v32 = v12[8];
    v33 = -v12[6];
    v34 = v16 - v15;
    while (1)
    {
      v35 = v33 + (float)((float)(v9 + v9) * v18);
      v36 = (float)((float)(v10 * v10) + (float)(v9 * v9)) - v21;
      if (v20 == 0.0)
      {
        v43 = v36 / v35;
      }
      else
      {
        v37 = (float)((float)(v20 * -4.0) * v36) + (float)(v35 * v35);
        if (v37 < 0.0)
          goto LABEL_39;
        v38 = sqrtf(v37);
        v39 = v32 * (float)(v35 - v38);
        v40 = v35 + v38;
        v41 = v32 * v40;
        v42 = (float)(v32 * v40) <= v39;
        if ((float)(v32 * v40) <= v39)
          v43 = v32 * v40;
        else
          v43 = v39;
        if (v42)
          v41 = v39;
        if (v41 < 0.0)
        {
          v44 = v41 < v31;
LABEL_25:
          v45 = v30;
          if (v44)
            goto LABEL_39;
LABEL_26:
          if ((v45 & 0x80000000) == 0)
            goto LABEL_38;
          goto LABEL_39;
        }
        if (v41 <= 1.0)
        {
          v46 = v15 + (float)(v41 * v34);
          goto LABEL_37;
        }
        if ((v17 & 0x80000000) == 0)
        {
          v45 = v17;
          if (v41 <= v19)
          {
LABEL_38:
            v47 = (_DWORD *)(v26 + 2 * (2 * v45));
LABEL_40:
            *v23 = *v47;
            LOBYTE(v47) = -1;
            goto LABEL_41;
          }
        }
      }
      if (v43 < 0.0)
      {
        v44 = v43 < v31;
        goto LABEL_25;
      }
      if (v43 > 1.0)
      {
        v45 = v17;
        if (v43 > v19)
          goto LABEL_39;
        goto LABEL_26;
      }
      v46 = v15 + (float)(v43 * v34);
LABEL_37:
      v45 = (int)(float)(v14 * (float)(v46 - v13));
      if ((v45 & 0x80000000) == 0)
        goto LABEL_38;
LABEL_39:
      v47 = v25;
      if (v25)
        goto LABEL_40;
LABEL_41:
      v9 = v4 + v9;
      v10 = v5 + v10;
      ++v23;
      *v22++ = (_BYTE)v47;
      if (!--a4)
        return;
    }
  }
  v27 = v10 * v10;
  v28 = -v20;
  if (v27 <= (float)-v20)
  {
    v48 = fabsf(v12[8]);
    v49 = v20 * -4.0;
    v50 = v16 - v15;
    v51 = a4 + 2;
    while (1)
    {
      v52 = v27 + (float)(v9 * v9);
      v53 = v4 + v9;
      v54 = v27 + (float)(v53 * v53);
      if (v52 > v28 && v54 > v28)
      {
        if ((v17 & 0x80000000) != 0)
        {
          if (!v25)
          {
            v65 = 0;
            LOBYTE(v64) = 0;
            goto LABEL_65;
          }
          v63 = *v25;
        }
        else
        {
          v63 = *(_DWORD *)(v26 + 4 * v17);
        }
        *v23 = v63;
        goto LABEL_63;
      }
      v56 = sqrtf(v49 * v54);
      v57 = v48 * sqrtf(v49 * v52);
      v58 = v48 * v56;
      v59 = (int)(float)(v14 * (float)((float)(v15 + (float)(v57 * v50)) - v13));
      v60 = (int)(float)(v14 * (float)((float)(v15 + (float)((float)(v48 * v56) * v50)) - v13));
      if (v57 <= 1.0 && v58 <= 1.0)
      {
        v63 = *(_DWORD *)(v26 + 4 * v60);
        *v23 = *(_DWORD *)(v26 + 4 * v59);
LABEL_63:
        LOBYTE(v64) = -1;
        goto LABEL_64;
      }
      if (v57 <= 1.0)
      {
        if ((v59 & 0x80000000) == 0)
        {
          v62 = (2 * v59);
LABEL_69:
          v64 = (_DWORD *)(v26 + 2 * v62);
LABEL_71:
          *v23 = *v64;
          LOBYTE(v64) = -1;
          goto LABEL_72;
        }
      }
      else if (v57 <= v19)
      {
        v62 = 2 * v17;
        if ((v17 & 0x80000000) == 0)
          goto LABEL_69;
      }
      v64 = v25;
      if (v25)
        goto LABEL_71;
LABEL_72:
      if (v58 <= 1.0)
      {
        if (v60 < 0)
          goto LABEL_79;
        v66 = (2 * v60);
      }
      else if (v58 > v19 || (v66 = 2 * v17, (v17 & 0x80000000) != 0))
      {
LABEL_79:
        if (!v25)
        {
          v65 = 0;
          goto LABEL_65;
        }
        v63 = *v25;
        goto LABEL_64;
      }
      v63 = *(_DWORD *)(v26 + 2 * v66);
LABEL_64:
      v23[1] = v63;
      v65 = -1;
LABEL_65:
      v9 = v4 + v53;
      v23 += 2;
      *v22 = (_BYTE)v64;
      v22[1] = v65;
      v22 += 2;
      v51 -= 2;
      if (v51 <= 2)
        return;
    }
  }
  if (v25 || (v17 & 0x80000000) == 0)
  {
    v67 = (int *)(v26 + 4 * v17);
    if ((int)v17 < 0)
      v67 = v25;
    v68 = *v67;
    v69 = a4 + 4;
    do
    {
      *v23 = v68;
      v23[1] = v68;
      v23[2] = v68;
      v23[3] = v68;
      v69 -= 4;
      v23 += 4;
      *(_DWORD *)v22 = -1;
      v22 += 4;
    }
    while (v69 > 4);
  }
  else
  {
    if (a4 >= 4)
      v29 = 4;
    else
      v29 = a4;
    bzero(v22, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

void w16_shade_conic_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v12;
  uint64_t v13;
  unsigned int *v14;
  _BYTE *v15;
  float v16;
  float v17;
  unsigned int v18;
  float v19;
  float v20;
  unsigned int v21;
  float v22;
  float v23;
  int v24;
  unsigned __int16 *v25;
  float v26;
  float v27;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  v9 = *(float *)(a1 + 284);
  v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  v26 = *(float *)(a1 + 336);
  v27 = *(float *)(a1 + 304);
  v12 = *(float *)(a1 + 344);
  v13 = *(_QWORD *)(a1 + 360);
  v15 = *(_BYTE **)(a1 + 144);
  v14 = *(unsigned int **)(a1 + 152);
  v16 = *(float *)(a1 + 308) - v27;
  do
  {
    v17 = v12 * (float)((float)(v27 + (float)((float)((float)(atan2f(v10, v8) * 0.15915) + 0.5) * v16)) - v26);
    v18 = vcvtms_s32_f32(v17);
    v19 = ceilf(v17);
    v20 = (float)((float)(v17 - (float)(int)floorf(v17)) * 255.0) + 0.5;
    v21 = vcvtms_s32_f32(v12 + v17);
    v22 = ceilf(v17 - v12);
    if (v17 < 0.0)
      v18 = v21;
    if (v17 <= v12)
      v23 = v19;
    else
      v23 = v22;
    v24 = (int)v20;
    v25 = (unsigned __int16 *)(v13 + 4 * (int)v23);
    *v14++ = ((v24 * v25[1] + (255 - v24) * *(unsigned __int16 *)(v13 + 2 * (int)(2 * v18) + 2)) << 8) & 0xFFFF0000 | (unsigned __int16)((v24 * *v25 + (255 - v24) * *(unsigned __int16 *)(v13 + 2 * (int)(2 * v18))) >> 8);
    v8 = v4 + v8;
    v10 = v9 + v10;
    *v15++ = -1;
    --a4;
  }
  while (a4);
}

float w16_shade_custom_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  _DWORD *v19;
  uint64_t v20;
  int v21;
  _DWORD *v22;
  _BYTE *v23;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  _DWORD *v29;

  result = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(result * v6));
  v9 = *(float *)(a1 + 284);
  v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  v11 = *(float *)(a1 + 304);
  v12 = *(float *)(a1 + 308);
  v13 = *(float *)(a1 + 312);
  v14 = *(float *)(a1 + 316);
  v15 = *(float *)(a1 + 336);
  v16 = *(float *)(a1 + 348);
  v17 = *(float *)(a1 + 344);
  v18 = *(float *)(a1 + 356);
  v19 = *(_DWORD **)(a1 + 376);
  v20 = *(_QWORD *)(a1 + 360);
  v21 = 2 * *(_DWORD *)(a1 + 48);
  v23 = *(_BYTE **)(a1 + 144);
  v22 = *(_DWORD **)(a1 + 152);
  do
  {
    if (v8 < v11 || v10 < v13)
    {
      v25 = 0;
      v26 = 0;
    }
    else
    {
      v25 = v8 == v12;
      v26 = v8 < v12;
    }
    if (v26 || v25)
    {
      v27 = v10 == v14;
      v28 = v10 < v14;
    }
    else
    {
      v27 = 0;
      v28 = 0;
    }
    if (v28 || v27)
    {
      v29 = (_DWORD *)(v20
                     + 2 * v21 * (int)(float)(v18 * (float)(v10 - v16))
                     + 4 * (int)(float)(v17 * (float)(v8 - v15)));
LABEL_15:
      *v22 = *v29;
      LOBYTE(v29) = -1;
      goto LABEL_16;
    }
    v29 = v19;
    if (v19)
      goto LABEL_15;
LABEL_16:
    v8 = result + v8;
    v10 = v9 + v10;
    ++v22;
    *v23++ = (_BYTE)v29;
    --a4;
  }
  while (a4);
  return result;
}

void w16_shade_axial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v7;
  float v8;
  float v9;
  float v10;
  int v11;
  int v12;
  _DWORD *v13;
  _DWORD *v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  int v19;
  _DWORD *v20;
  int *v21;
  int v22;
  int v23;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a3))
             + (float)(v4 * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a2)));
  v7 = *(float *)(a1 + 336);
  v8 = *(float *)(a1 + 344);
  v9 = *(float *)(a1 + 304);
  v10 = *(float *)(a1 + 308);
  v11 = *(_DWORD *)(a1 + 320);
  v12 = *(_DWORD *)(a1 + 324);
  v15 = a1 + 144;
  v13 = *(_DWORD **)(a1 + 144);
  v14 = *(_DWORD **)(v15 + 8);
  v16 = *(_DWORD **)(a1 + 376);
  v17 = *(_QWORD *)(a1 + 360);
  if (v4 != 0.0)
  {
    while (1)
    {
      v19 = v11;
      if (v5 >= v9)
      {
        v19 = v12;
        if (v5 <= v10)
          v19 = (int)(float)(v8 * (float)(v5 - v7));
      }
      if ((v19 & 0x80000000) == 0)
        break;
      v20 = v16;
      if (v16)
        goto LABEL_17;
LABEL_18:
      v5 = v4 + v5;
      ++v14;
      *(_BYTE *)v13 = (_BYTE)v20;
      v13 = (_DWORD *)((char *)v13 + 1);
      if (!--a4)
        return;
    }
    v20 = (_DWORD *)(v17 + 2 * (2 * v19));
LABEL_17:
    *v14 = *v20;
    LOBYTE(v20) = -1;
    goto LABEL_18;
  }
  if (v5 >= v9)
  {
    v11 = v12;
    if (v5 <= v10)
      v11 = (int)(float)(v8 * (float)(v5 - v7));
  }
  if ((v11 & 0x80000000) == 0 || v16)
  {
    v21 = (int *)(v17 + 2 * (2 * v11));
    if (v11 < 0)
      v21 = v16;
    v22 = *v21;
    v23 = a4 + 4;
    do
    {
      *v14 = v22;
      v14[1] = v22;
      v14[2] = v22;
      v14[3] = v22;
      v23 -= 4;
      v14 += 4;
      *v13++ = -1;
    }
    while (v23 > 4);
  }
  else
  {
    if (a4 >= 4)
      v18 = 4;
    else
      v18 = a4;
    bzero(v13, ((a4 - v18 + 3) & 0xFFFFFFFC) + 4);
  }
}

void w16_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  float v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _WORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int16 *v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  int v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  int32x2_t v58;
  uint64_t v59;
  int32x2_t v60;
  int *v61;
  uint64_t v62;
  void (*v63)(_QWORD *, uint64_t, uint64_t, uint64_t);
  int32x2_t v64;
  unsigned __int16 *v65;
  _BYTE *v66;
  unsigned int v67;
  int v68;
  _BYTE *v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  float *v74;
  float v75;
  int v76;
  float v77;
  int v78;
  unsigned int v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  int32x2_t v83;
  int32x2_t v84;
  uint32x2_t v85;
  int32x2_t v86;
  uint64_t v87;
  float *v88;
  float v89;
  int v90;
  float v91;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  unsigned __int8 *v97;
  uint64_t v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  unsigned __int8 *v104;
  _WORD *v105;
  unsigned __int16 *v106;
  int v107;
  uint64_t v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  int v112;
  unsigned int v113;
  int v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  int v118;
  unsigned __int8 *v119;
  unsigned __int16 *v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  int v124;
  int v125;
  int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  int v136;
  int v137;
  unsigned __int8 *v138;
  int v139;
  int v140;
  int v141;
  unsigned int v142;
  int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  unsigned int v151;
  int v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  unsigned int v170;
  uint64_t v171;
  int v172;
  int v173;
  int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  unsigned int v178;
  int v179;
  unsigned int v180;
  int v181;
  unsigned int v182;
  uint64_t v183;
  int v184;
  int v185;
  int v186;
  int v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v190;
  int v191;
  unsigned int v192;
  int v193;
  unsigned int v194;
  int v195;
  int v196;
  unsigned __int16 v197;
  unsigned int v198;
  int v199;
  unsigned int v200;
  unsigned int v201;
  int v202;
  int v203;
  int v204;
  unsigned int v205;
  unsigned int v206;
  int v207;
  unsigned int v208;
  uint64_t v209;
  int v210;
  int v211;
  int v212;
  unsigned int v213;
  unsigned int v214;
  int v215;
  int v216;
  unsigned int v217;
  int v218;
  int v219;
  unsigned int v220;
  signed int v221;
  uint64_t v222;
  int v223;
  int v224;
  int v225;
  unsigned int v226;
  unsigned int v227;
  unsigned int v228;
  int v229;
  int v230;
  int v231;
  unsigned int v232;
  unsigned int v233;
  unint64_t v234;
  unsigned int v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  int64_t v239;
  int v240;
  int v241;
  int v242;
  unsigned int v243;
  unsigned int v244;
  unsigned int v245;
  unsigned int v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  int64_t v250;
  unint64_t v251;
  unsigned __int8 *v252;
  int v253;
  int v254;
  int v255;
  unsigned int v256;
  unsigned int v257;
  unsigned int v258;
  unsigned __int16 v259;
  int v260;
  int v261;
  int v262;
  unsigned int v263;
  unsigned int v264;
  unsigned int v265;
  unsigned __int16 v266;
  int v267;
  int v268;
  int v269;
  unsigned int v270;
  unsigned int v271;
  unsigned int v272;
  unsigned __int16 v273;
  int v274;
  int v275;
  int v276;
  unsigned int v277;
  unsigned int v278;
  unsigned int v279;
  unsigned __int16 v280;
  int v281;
  int v282;
  int v283;
  unsigned int v284;
  unsigned int v285;
  unsigned int v286;
  unsigned __int16 v287;
  int v288;
  int v289;
  int v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  unsigned __int16 v294;
  int v295;
  int v296;
  int v297;
  unsigned int v298;
  unsigned int v299;
  unsigned int v300;
  unsigned __int16 v301;
  int v302;
  int v303;
  int v304;
  unsigned int v305;
  unsigned int v306;
  unsigned int v307;
  unsigned __int16 v308;
  int v309;
  int v310;
  int v311;
  unsigned int v312;
  unsigned int v313;
  unsigned int v314;
  unsigned int v315;
  uint64_t v316;
  uint64_t v317;
  int64_t v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  int64_t v322;
  unint64_t v323;
  int v324;
  int v325;
  int v326;
  unsigned int v327;
  unsigned int v328;
  unsigned int v329;
  unsigned __int16 v330;
  int v331;
  int v332;
  int v333;
  unsigned int v334;
  unsigned int v335;
  unsigned int v336;
  unsigned __int16 v337;
  int v338;
  unsigned __int8 *v339;
  int v340;
  int v341;
  int v342;
  int v343;
  unsigned int v344;
  unsigned int v345;
  unsigned int v346;
  unsigned __int16 v347;
  int v348;
  int v349;
  int v350;
  int v351;
  int v352;
  unsigned int v353;
  unsigned int v354;
  unsigned int v355;
  unsigned int v356;
  unint64_t v357;
  int v358;
  unsigned int v359;
  uint64_t v360;
  unsigned __int8 *v361;
  int v362;
  unsigned int v363;
  unsigned __int16 *v364;
  unsigned __int16 *v365;
  unsigned int v366;
  int v367;
  int v368;
  unsigned __int8 *v369;
  int v370;
  unsigned int v371;
  unsigned int v372;
  int v373;
  int v374;
  unsigned int v375;
  int v376;
  int v377;
  unsigned int v378;
  unsigned int v379;
  int v380;
  unsigned int v381;
  unsigned int v382;
  int v383;
  int v384;
  unsigned __int16 *v385;
  unsigned int v386;
  int v387;
  int v388;
  int v389;
  unsigned int v390;
  unsigned int v391;
  unsigned int v392;
  int v393;
  unsigned int v394;
  unsigned int v395;
  int v396;
  unsigned int v397;
  unsigned int v398;
  int v399;
  unsigned __int16 *v400;
  unsigned __int8 *v401;
  int v402;
  unsigned int v403;
  int v404;
  int v405;
  unsigned int v406;
  int v407;
  int v408;
  unsigned int v409;
  int v410;
  int v411;
  unsigned int v412;
  unsigned int v413;
  int v414;
  uint64_t v415;
  unint64_t v416;
  uint64_t v417;
  uint64_t v418;
  char *v419;
  uint64_t v420;
  unsigned __int16 *v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  unsigned int v425;
  uint64_t v426;
  _QWORD *v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  int v431;
  int v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  int *v436;
  uint64_t v437;
  uint64_t v438;

  v438 = *MEMORY[0x1E0C80C00];
  v426 = *(unsigned int *)(a1 + 4);
  v424 = (int)v426;
  v4 = ((int)v426 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 <= 0x1FFFFFF)
  {
    v8 = *(_QWORD *)(a1 + 40);
    v7 = *(_QWORD *)(a1 + 48);
    v9 = *(float *)(a2 + 184);
    v436 = *(int **)(a1 + 136);
    v437 = v7;
    v10 = *(_QWORD *)(a2 + 104);
    v433 = *(_QWORD *)(a2 + 96);
    v434 = v10;
    v11 = *(int *)(a1 + 24);
    v12 = *(int *)(a1 + 28);
    v13 = *(int *)(a1 + 16);
    v435 = *(int *)(a1 + 20);
    v14 = *(int *)(a1 + 12);
    v432 = *(_DWORD *)(a1 + 8);
    v427 = (_QWORD *)a2;
    v15 = *(int *)(a2 + 16);
    v16 = (v15 + 6) * v4;
    if (v16 > 65439)
    {
      v20 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
      v18 = v20;
      v21 = v427;
      if (!v20)
        return;
    }
    else
    {
      MEMORY[0x1E0C80A78](a1, a4);
      v18 = (char *)&v415 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v18, v17);
      v20 = 0;
      v21 = v427;
    }
    v423 = a1;
    v425 = a3;
    v22 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
    v23 = v22 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    v21[20] = v23;
    if ((_DWORD)v15)
      v24 = 4 * v4;
    else
      v24 = 0;
    v25 = v23 + v24;
    v26 = v8 + (v11 - 1) * v12;
    v27 = v12 >> 1;
    v21[18] = v22;
    v21[19] = v25;
    if (v437)
    {
      v28 = v423;
      v29 = (unint64_t)*(int *)(v423 + 32) >> 1;
      v30 = (_WORD *)(v437 + 2 * (v14 + v29 * v13));
      v430 = v29 - v424;
      v31 = v424;
      v32 = 1;
    }
    else
    {
      v30 = 0;
      v430 = 0;
      v32 = 0;
      v28 = v423;
      v31 = v424;
    }
    v431 = (int)(v9 * 65535.9);
    v33 = v26 + 2 * v435;
    v34 = (unsigned __int16 *)(v8 + 2 * (v14 + v27 * v13));
    v429 = v27 - v31;
    v35 = *(int *)(v28 + 104);
    v36 = *(_DWORD *)(v28 + 108);
    v37 = *(unsigned __int8 *)(v28 + 2);
    if (v37 == 6 || v37 == 1)
    {
      v38 = v425;
      v40 = v426;
      v39 = v427;
      v41 = v433;
      v42 = v434;
      if (v436)
      {
        v416 = v27;
        v419 = v20;
        v43 = 0;
        v44 = 0;
        v45 = *(int *)(v423 + 124);
        v46 = (unsigned __int8 *)v436 + v35 + (int)v45 * (uint64_t)v36;
        v31 = v424;
        v428 = v45 - v424;
        goto LABEL_32;
      }
      goto LABEL_578;
    }
    v419 = v20;
    v40 = v426;
    v39 = v427;
    v42 = v434;
    if (!v436)
    {
      v416 = v27;
      v46 = 0;
      v43 = 0;
      v428 = 0;
      v44 = 0;
      v38 = v425;
      v41 = v433;
      goto LABEL_32;
    }
    v417 = v33;
    v418 = v32;
    shape_enum_clip_alloc((uint64_t)v20, v19, v436, 1, 1, 1, v35, v36, v426, v432);
    if (!v47)
    {
LABEL_577:
      v20 = v419;
LABEL_578:
      if (v20)
        free(v20);
      return;
    }
    v436 = v47;
    v416 = v27;
    v48 = 0;
    v49 = (int)((v15 * v4 + 15) & 0xFFFFFFF0);
    if (!(_DWORD)v15)
      v49 = 4 * v4;
    v50 = v424;
    v428 = -v424;
    v46 = (unsigned __int8 *)(v25 + v49 + 16);
    v38 = v425;
    v51 = v437;
    v41 = v433;
LABEL_21:
    v435 = v430 + v50;
    while (1)
    {
      v52 = v38;
      while (1)
      {
        v53 = *((_DWORD *)v46 - 4);
        v54 = v53 - v48;
        if (v53 > v48)
          break;
        v44 = v48;
        if (v48 < *((_DWORD *)v46 - 3) + v53)
        {
          v31 = v424;
          v32 = v418;
          v33 = v417;
          v43 = v436;
          v38 = v52;
LABEL_32:
          v57 = v431 ^ 0xFFFF;
          v58 = vdup_n_s32(v431 ^ 0xFFFFu);
          v422 = (v40 - 1) + 1;
          v420 = -v31;
          v417 = v33;
          v421 = (unsigned __int16 *)(v33 - 2);
          v418 = v32;
          v59 = 2 * v32;
          v60 = vdup_n_s32(0x101u);
          v61 = v43;
LABEL_33:
          v62 = v38;
          LODWORD(v435) = v44;
          v436 = v61;
          v63 = (void (*)(_QWORD *, uint64_t, uint64_t, uint64_t))*v39;
          v433 = v41;
          v434 = v42;
          v63(v39, v41, v42, v40);
          v65 = (unsigned __int16 *)v39[20];
          v66 = (_BYTE *)v39[18];
          v67 = *((_DWORD *)v39 + 2);
          if (v67 == *((_DWORD *)v39 + 3))
          {
            v38 = v62;
            if (v431 == 0xFFFF)
            {
              v51 = v437;
              v70 = v435;
            }
            else
            {
              v68 = v40;
              v69 = (_BYTE *)v39[18];
              v51 = v437;
              v70 = v435;
              do
              {
                if (*v69)
                  *(_DWORD *)v65 = ((unsigned __int16)*(_DWORD *)v65
                                  - (((unsigned __int16)*(_DWORD *)v65 * v57
                                    + (((unsigned __int16)*(_DWORD *)v65 * v57) >> 16)
                                    + 1) >> 16)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((HIWORD(*(_DWORD *)v65) * v57
                                                     + ((HIWORD(*(_DWORD *)v65) * v57) >> 16)
                                                     + 1) >> 16)) << 16);
                ++v69;
                v65 += 2;
                --v68;
              }
              while (v68);
              v65 += 2 * v420;
              v66 += v422 + v420;
            }
          }
          else
          {
            v71 = v39[19];
            v72 = HIWORD(v67) & 0x3F;
            v38 = v62;
            if (v72 == 16)
            {
              v51 = v437;
              v70 = v435;
              v80 = 0;
              if (v431 == 0xFFFF)
              {
                do
                {
                  if (v66[v80])
                    *(_DWORD *)&v65[2 * v80] = *(_DWORD *)(v71 + 4 * v80);
                  ++v80;
                }
                while ((_DWORD)v40 != (_DWORD)v80);
              }
              else
              {
                do
                {
                  if (v66[v80])
                  {
                    v81 = (unsigned __int16)*(_DWORD *)(v71 + 4 * v80);
                    *(_DWORD *)&v65[2 * v80] = (v81 - ((v81 * v57 + ((v81 * v57) >> 16) + 1) >> 16)) | ((HIWORD(*(_DWORD *)(v71 + 4 * v80)) - ((HIWORD(*(_DWORD *)(v71 + 4 * v80)) * v57 + ((HIWORD(*(_DWORD *)(v71 + 4 * v80)) * v57) >> 16) + 1) >> 16)) << 16);
                  }
                  ++v80;
                }
                while ((_DWORD)v40 != (_DWORD)v80);
              }
            }
            else
            {
              v51 = v437;
              v70 = v435;
              if (v72 == 32)
              {
                if (v431 == 0xFFFF)
                {
                  v87 = 0;
                  v88 = (float *)(v71 + 4);
                  do
                  {
                    if (v66[v87])
                    {
                      v89 = *v88;
                      if (*v88 <= 0.0)
                      {
                        v93 = 0;
                      }
                      else
                      {
                        v90 = (int)(float)((float)(v89 * 65535.0) + 0.5);
                        v91 = *(v88 - 1);
                        if (v89 > 1.0)
                        {
                          v90 = 0xFFFF;
                          v89 = 1.0;
                        }
                        v92 = v90;
                        if (v91 <= v89)
                        {
                          if (v91 >= 0.0)
                            v92 = (int)(float)((float)(v91 * 65535.0) + 0.5);
                          else
                            v92 = 0;
                        }
                        v93 = v92 | (v90 << 16);
                      }
                      *(_DWORD *)&v65[2 * v87] = v93;
                    }
                    v88 += 2;
                    ++v87;
                  }
                  while ((_DWORD)v40 != (_DWORD)v87);
                }
                else
                {
                  v73 = 0;
                  v74 = (float *)(v71 + 4);
                  do
                  {
                    if (v66[v73])
                    {
                      v75 = *v74;
                      if (*v74 <= 0.0)
                      {
                        v79 = 0;
                      }
                      else
                      {
                        v76 = (int)(float)((float)(v75 * 65535.0) + 0.5);
                        v77 = *(v74 - 1);
                        if (v75 > 1.0)
                        {
                          v76 = 0xFFFF;
                          v75 = 1.0;
                        }
                        v78 = v76;
                        if (v77 <= v75)
                        {
                          if (v77 >= 0.0)
                            v78 = (int)(float)((float)(v77 * 65535.0) + 0.5);
                          else
                            v78 = 0;
                        }
                        v79 = (v78 - ((v78 * v57 + ((v78 * v57) >> 16) + 1) >> 16)) | ((v76 - ((v76 * v57 + ((v76 * v57) >> 16) + 1) >> 16)) << 16);
                      }
                      *(_DWORD *)&v65[2 * v73] = v79;
                    }
                    v74 += 2;
                    ++v73;
                  }
                  while ((_DWORD)v40 != (_DWORD)v73);
                }
              }
              else if (v431 == 0xFFFF)
              {
                v94 = 0;
                do
                {
                  if (v66[v94])
                    *(_DWORD *)&v65[2 * v94] = *(_DWORD *)(v71 + 4 * v94) & 0xFF000000 | (*(_DWORD *)(v71 + 4 * v94) >> 8) & 0xFFFF0000 | (*(_DWORD *)(v71 + 4 * v94) << 8) | *(_DWORD *)(v71 + 4 * v94);
                  ++v94;
                }
                while ((_DWORD)v40 != (_DWORD)v94);
              }
              else
              {
                v82 = 0;
                do
                {
                  if (v66[v82])
                  {
                    v64.i32[0] = *(_DWORD *)(v71 + 4 * v82);
                    v83.i32[0] = vshr_n_u32((uint32x2_t)v64, 0x18uLL).u32[0];
                    v83.i32[1] = vdup_n_s32(*(_DWORD *)(v71 + 4 * v82)).u8[4];
                    v84 = vmul_s32(v83, v60);
                    v85 = (uint32x2_t)vmul_s32(v84, v58);
                    v64 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v85, v85, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL);
                    v86 = vsub_s32(v84, v64);
                    *(_DWORD *)&v65[2 * v82] = v86.i32[1] | (v86.i32[0] << 16);
                  }
                  ++v82;
                }
                while ((_DWORD)v40 != (_DWORD)v82);
              }
            }
          }
          switch((int)v38)
          {
            case 0:
              v95 = v46 != 0;
              v96 = v40;
              v97 = v46;
              if (v51)
              {
                v98 = v433;
                do
                {
                  v99 = *v66;
                  if (*v66)
                  {
                    if (v46)
                      v99 = ((unsigned __int16)(*v97 * (_WORD)v99
                                                               + ((*v97 * v99) >> 8)
                                                               + 1) >> 8);
                    if (v99)
                    {
                      if (v99 == 255)
                      {
                        LOWORD(v100) = 0;
                        *v34 = 0;
                      }
                      else
                      {
                        v101 = (unsigned __int16)*v30;
                        v102 = v99 | (v99 << 8);
                        *v34 -= (v102 * *v34 + ((v102 * *v34) >> 16) + 1) >> 16;
                        v100 = v101 - ((v102 * v101 + ((v102 * v101) >> 16) + 1) >> 16);
                      }
                      *v30 = v100;
                    }
                  }
                  ++v66;
                  v97 += v95;
                  ++v34;
                  ++v30;
                  --v96;
                }
                while (v96);
              }
              else
              {
                v98 = v433;
                do
                {
                  v358 = *v66;
                  if (*v66)
                  {
                    if (v46)
                      v358 = ((unsigned __int16)(*v97 * (_WORD)v358
                                                                + ((*v97 * v358) >> 8)
                                                                + 1) >> 8);
                    if (v358)
                    {
                      if (v358 == 255)
                        LOWORD(v359) = 0;
                      else
                        v359 = *v34 - ((257 * v358 * *v34 + ((257 * v358 * *v34) >> 16) + 1) >> 16);
                      *v34 = v359;
                    }
                  }
                  ++v66;
                  v97 += v95;
                  ++v34;
                  --v96;
                }
                while (v96);
              }
              v360 = v428;
              goto LABEL_525;
            case 1:
              v103 = *v66;
              if (v51)
              {
                v104 = v66 + 1;
                v105 = v30 - 1;
                v106 = v34 - 1;
                v107 = v40;
                if (v46)
                {
                  v108 = v434;
                  do
                  {
                    if (v103)
                    {
                      v109 = *v46 * v103 + ((*v46 * v103) >> 8) + 1;
                      if (BYTE1(v109))
                      {
                        if (BYTE1(v109) == 255)
                        {
                          v110 = *(_DWORD *)v65;
                          v111 = *(_DWORD *)v65;
                        }
                        else
                        {
                          v112 = 257 * (v109 >> 8);
                          v113 = (unsigned __int16)v112;
                          v114 = (unsigned __int16)~(_WORD)v112;
                          v115 = (unsigned __int16)*(_DWORD *)v65 * v113 + v106[1] * v114;
                          v116 = v115 + HIWORD(v115) + 1;
                          v111 = HIWORD(*(_DWORD *)v65) * (v114 | v113)
                               + ((HIWORD(*(_DWORD *)v65) * (v114 | v113)) >> 16)
                               + 1;
                          v110 = HIWORD(v116);
                        }
                        v106[1] = v110;
                        v105[1] = HIWORD(v111);
                      }
                    }
                    v117 = *v104++;
                    v103 = v117;
                    v65 += 2;
                    ++v46;
                    ++v105;
                    ++v106;
                    --v107;
                  }
                  while (v107);
                  v46 += v428;
                }
                else
                {
                  v108 = v434;
                  do
                  {
                    if (v103)
                    {
                      if (v103 == 255)
                      {
                        v381 = *(_DWORD *)v65;
                        v382 = *(_DWORD *)v65;
                      }
                      else
                      {
                        v383 = v103 | (v103 << 8);
                        v382 = 0xFFFF * HIWORD(*(_DWORD *)v65)
                             + ((0xFFFF * HIWORD(*(_DWORD *)v65)) >> 16)
                             + 1;
                        v381 = ((unsigned __int16)*(_DWORD *)v65 * v383
                              + v106[1] * (v383 ^ 0xFFFF)
                              + (((unsigned __int16)*(_DWORD *)v65 * v383 + v106[1] * (v383 ^ 0xFFFFu)) >> 16)
                              + 1) >> 16;
                      }
                      v106[1] = v381;
                      v105[1] = HIWORD(v382);
                    }
                    v384 = *v104++;
                    v103 = v384;
                    v65 += 2;
                    ++v105;
                    ++v106;
                    --v107;
                  }
                  while (v107);
                  v46 = 0;
                }
                v385 = &v106[v429];
                goto LABEL_548;
              }
              if (v46)
              {
                v361 = v66 + 1;
                v362 = v40;
                v108 = v434;
                do
                {
                  if (v103)
                  {
                    v363 = *v46 * v103 + ((*v46 * v103) >> 8) + 1;
                    v364 = *(unsigned __int16 **)(v423 + 40);
                    v365 = v421;
                    if (v421 >= v34)
                      v365 = v34;
                    if (v365 >= v364)
                      v364 = v365;
                    if (BYTE1(v363))
                    {
                      if (BYTE1(v363) == 255)
                      {
                        v366 = *(_DWORD *)v65;
                      }
                      else
                      {
                        v367 = 257 * (v363 >> 8);
                        v366 = (*v65 * (unsigned __int16)v367
                              + *v364 * (unsigned __int16)~(_WORD)v367
                              + ((*v65 * (unsigned __int16)v367 + *v364 * (unsigned __int16)~(_WORD)v367) >> 16)
                              + 1) >> 16;
                      }
                      *v364 = v366;
                    }
                  }
                  else
                  {
                    v364 = v34;
                  }
                  v368 = *v361++;
                  v103 = v368;
                  v65 += 2;
                  ++v46;
                  v34 = v364 + 1;
                  --v362;
                }
                while (v362);
                goto LABEL_515;
              }
              v400 = *(unsigned __int16 **)(v423 + 40);
              v401 = v66 + 1;
              v402 = v40;
              v108 = v434;
              do
              {
                v364 = v421;
                if (v421 >= v34)
                  v364 = v34;
                if (v364 < v400)
                  v364 = v400;
                if (v103)
                {
                  if (v103 == 255)
                  {
                    v403 = *(_DWORD *)v65;
                  }
                  else
                  {
                    v404 = v103 | (v103 << 8);
                    v403 = (*v65 * v404 + *v364 * (v404 ^ 0xFFFF) + ((*v65 * v404 + *v364 * (v404 ^ 0xFFFFu)) >> 16) + 1) >> 16;
                  }
                  *v364 = v403;
                }
                v405 = *v401++;
                v103 = v405;
                v65 += 2;
                v34 = v364 + 1;
                --v402;
              }
              while (v402);
              goto LABEL_572;
            case 2:
              v118 = *v66;
              if (v51)
              {
                v119 = v66 + 1;
                v105 = v30 - 1;
                v120 = v34 - 1;
                v121 = v40;
                if (v46)
                {
                  v108 = v434;
                  while (1)
                  {
                    if (!v118)
                      goto LABEL_128;
                    v122 = *v46 * v118 + ((*v46 * v118) >> 8) + 1;
                    if (!BYTE1(v122))
                      goto LABEL_128;
                    if (BYTE1(v122) == 255)
                    {
                      v123 = *(_DWORD *)v65;
                      v124 = HIWORD(*(_DWORD *)v65);
                      if (v124)
                      {
                        if (v124 == 0xFFFF)
                        {
                          v120[1] = v123;
                          LOWORD(v123) = -1;
                        }
                        else
                        {
                          v133 = v124 ^ 0xFFFF;
                          v134 = v133 * v120[1];
                          v135 = (v133 * (unsigned __int16)v105[1]
                                + ((v133 * (unsigned __int16)v105[1]) >> 16)
                                + 1) >> 16;
                          v120[1] = v123 + ((v134 + HIWORD(v134) + 1) >> 16);
                          v123 = v135 + HIWORD(v123);
                        }
                        goto LABEL_127;
                      }
                    }
                    else
                    {
                      v125 = HIWORD(*(_DWORD *)v65);
                      v126 = (257 * (v122 >> 8)) ^ 0xFFFF;
                      v127 = v125 * v126 + ((v125 * v126) >> 16) + 1;
                      v128 = (unsigned __int16)*(_DWORD *)v65
                           - (((unsigned __int16)*(_DWORD *)v65 * v126
                             + (((unsigned __int16)*(_DWORD *)v65 * v126) >> 16)
                             + 1) >> 16);
                      v129 = v128 | ((v125 - HIWORD(v127)) << 16);
                      if (HIWORD(v129))
                      {
                        v130 = HIWORD(v129) ^ 0xFFFF;
                        v131 = v130 * v120[1] + ((v130 * v120[1]) >> 16) + 1;
                        v132 = (v130 * (unsigned __int16)v105[1]
                              + ((v130 * (unsigned __int16)v105[1]) >> 16)
                              + 1) >> 16;
                        v120[1] = v128 + HIWORD(v131);
                        v123 = v132 + HIWORD(v129);
LABEL_127:
                        v105[1] = v123;
                      }
                    }
LABEL_128:
                    v136 = *v119++;
                    v118 = v136;
                    v65 += 2;
                    ++v46;
                    ++v105;
                    ++v120;
                    if (!--v121)
                    {
                      v46 += v428;
                      goto LABEL_547;
                    }
                  }
                }
                v108 = v434;
                while (1)
                {
                  if (v118)
                  {
                    if (v118 == 255)
                    {
                      v386 = *(_DWORD *)v65;
                      v387 = HIWORD(*(_DWORD *)v65);
                      if (v387)
                      {
                        if (v387 == 0xFFFF)
                        {
                          v120[1] = v386;
                          LOWORD(v386) = -1;
                        }
                        else
                        {
                          v396 = v387 ^ 0xFFFF;
                          v397 = v396 * v120[1];
                          v398 = (v396 * (unsigned __int16)v105[1]
                                + ((v396 * (unsigned __int16)v105[1]) >> 16)
                                + 1) >> 16;
                          v120[1] = v386 + ((v397 + HIWORD(v397) + 1) >> 16);
                          v386 = v398 + HIWORD(v386);
                        }
                        goto LABEL_544;
                      }
                    }
                    else
                    {
                      v388 = HIWORD(*(_DWORD *)v65);
                      v389 = (257 * v118) ^ 0xFFFF;
                      v390 = v388 * v389 + ((v388 * v389) >> 16) + 1;
                      v391 = (unsigned __int16)*(_DWORD *)v65
                           - (((unsigned __int16)*(_DWORD *)v65 * v389
                             + (((unsigned __int16)*(_DWORD *)v65 * v389) >> 16)
                             + 1) >> 16);
                      v392 = v391 | ((v388 - HIWORD(v390)) << 16);
                      if (HIWORD(v392))
                      {
                        v393 = HIWORD(v392) ^ 0xFFFF;
                        v394 = v393 * v120[1] + ((v393 * v120[1]) >> 16) + 1;
                        v395 = (v393 * (unsigned __int16)v105[1]
                              + ((v393 * (unsigned __int16)v105[1]) >> 16)
                              + 1) >> 16;
                        v120[1] = v391 + HIWORD(v394);
                        v386 = v395 + HIWORD(v392);
LABEL_544:
                        v105[1] = v386;
                      }
                    }
                  }
                  v399 = *v119++;
                  v118 = v399;
                  v65 += 2;
                  ++v105;
                  ++v120;
                  if (!--v121)
                  {
                    v46 = 0;
LABEL_547:
                    v385 = &v120[v429];
LABEL_548:
                    v34 = v385 + 1;
                    v30 = &v105[v430 + 1];
LABEL_574:
                    v98 = v433;
LABEL_447:
                    if (v432 == 1)
                      goto LABEL_575;
                    --v432;
                    v61 = 0;
                    v44 = v70 + 1;
                    v41 = v39[16] + v98;
                    v42 = v39[17] + v108;
                    if (v436)
                    {
                      v48 = v44;
                      v50 = v424;
                      goto LABEL_21;
                    }
                    goto LABEL_33;
                  }
                }
              }
              v369 = v66 + 1;
              v364 = v34 - 1;
              v370 = v40;
              if (v46)
              {
                v108 = v434;
                while (1)
                {
                  if (!v118)
                    goto LABEL_514;
                  v371 = *v46 * v118 + ((*v46 * v118) >> 8) + 1;
                  if (!BYTE1(v371))
                    goto LABEL_514;
                  if (BYTE1(v371) == 255)
                  {
                    v372 = *(_DWORD *)v65;
                    v373 = HIWORD(*(_DWORD *)v65);
                    if (v373)
                    {
                      if (v373 != 0xFFFF)
                      {
                        v374 = v364[1];
                        v375 = v373 ^ 0xFFFF;
                        goto LABEL_512;
                      }
                      goto LABEL_513;
                    }
                  }
                  else
                  {
                    v376 = HIWORD(*(_DWORD *)v65);
                    v377 = (257 * (v371 >> 8)) ^ 0xFFFF;
                    v378 = v376 * v377 + ((v376 * v377) >> 16) + 1;
                    v372 = (unsigned __int16)*(_DWORD *)v65
                         - (((unsigned __int16)*(_DWORD *)v65 * v377
                           + (((unsigned __int16)*(_DWORD *)v65 * v377) >> 16)
                           + 1) >> 16);
                    v379 = v372 | ((v376 - HIWORD(v378)) << 16);
                    if (v379 >= 0x10000)
                    {
                      v374 = v364[1];
                      v375 = ~v379 >> 16;
LABEL_512:
                      v372 += (v375 * v374 + ((v375 * v374) >> 16) + 1) >> 16;
LABEL_513:
                      v364[1] = v372;
                    }
                  }
LABEL_514:
                  v380 = *v369++;
                  v118 = v380;
                  v65 += 2;
                  ++v46;
                  ++v364;
                  if (!--v370)
                  {
LABEL_515:
                    v46 += v428;
LABEL_573:
                    v34 = &v364[v429 + 1];
                    v30 += v430;
                    goto LABEL_574;
                  }
                }
              }
              v108 = v434;
              while (1)
              {
                if (v118)
                {
                  if (v118 == 255)
                  {
                    v406 = *(_DWORD *)v65;
                    v407 = HIWORD(*(_DWORD *)v65);
                    if (v407)
                    {
                      if (v407 != 0xFFFF)
                      {
                        v408 = v364[1];
                        v409 = v407 ^ 0xFFFF;
                        goto LABEL_569;
                      }
                      goto LABEL_570;
                    }
                  }
                  else
                  {
                    v410 = HIWORD(*(_DWORD *)v65);
                    v411 = (257 * v118) ^ 0xFFFF;
                    v412 = v410 * v411 + ((v410 * v411) >> 16) + 1;
                    v406 = (unsigned __int16)*(_DWORD *)v65
                         - (((unsigned __int16)*(_DWORD *)v65 * v411
                           + (((unsigned __int16)*(_DWORD *)v65 * v411) >> 16)
                           + 1) >> 16);
                    v413 = v406 | ((v410 - HIWORD(v412)) << 16);
                    if (v413 >= 0x10000)
                    {
                      v408 = v364[1];
                      v409 = ~v413 >> 16;
LABEL_569:
                      v406 += (v409 * v408 + ((v409 * v408) >> 16) + 1) >> 16;
LABEL_570:
                      v364[1] = v406;
                    }
                  }
                }
                v414 = *v369++;
                v118 = v414;
                v65 += 2;
                ++v364;
                if (!--v370)
                {
LABEL_572:
                  v46 = 0;
                  goto LABEL_573;
                }
              }
            case 3:
              v137 = v40;
              v138 = v46;
              do
              {
                v139 = *v66;
                if (*v66)
                {
                  if (v46)
                    v139 = ((unsigned __int16)(*v138 * (_WORD)v139
                                                              + ((*v138 * v139) >> 8)
                                                              + 1) >> 8);
                  if (v139)
                  {
                    if (v139 == 255)
                    {
                      v140 = HIWORD(*(_DWORD *)v65);
                      v141 = (unsigned __int16)*v30 ^ 0xFFFF;
                      *v34 = *(_DWORD *)v65
                           - (((unsigned __int16)*(_DWORD *)v65 * v141
                             + (((unsigned __int16)*(_DWORD *)v65 * v141) >> 16)
                             + 1) >> 16);
                      v142 = v140 - ((v140 * v141 + ((v140 * v141) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      v143 = v139 | (v139 << 8);
                      v144 = (unsigned __int16)*v30 * v143 + (((unsigned __int16)*v30 * v143) >> 16) + 1;
                      v143 ^= 0xFFFFu;
                      v145 = *v34 * v143 + HIWORD(v144) * (unsigned __int16)*(_DWORD *)v65;
                      v146 = (v143 + HIWORD(v144)) * HIWORD(*(_DWORD *)v65);
                      v142 = (v146 + HIWORD(v146) + 1) >> 16;
                      *v34 = (v145 + HIWORD(v145) + 1) >> 16;
                    }
                    *v30 = v142;
                  }
                }
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v137;
              }
              while (v137);
              goto LABEL_420;
            case 4:
              v147 = v40;
              v138 = v46;
              do
              {
                v148 = *v66;
                if (*v66)
                {
                  if (v46)
                    v148 = ((unsigned __int16)(*v138 * (_WORD)v148
                                                              + ((*v138 * v148) >> 8)
                                                              + 1) >> 8);
                  if (v148)
                  {
                    if (v148 == 255)
                    {
                      v149 = HIWORD(*(_DWORD *)v65);
                      v150 = (unsigned __int16)*v30;
                      *v34 = *(_DWORD *)v65
                           - (((unsigned __int16)*(_DWORD *)v65 * v150
                             + (((unsigned __int16)*(_DWORD *)v65 * v150) >> 16)
                             + 1) >> 16);
                      v151 = v149 - ((v149 * v150 + ((v149 * v150) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      v152 = v148 | (v148 << 8);
                      v153 = ((unsigned __int16)*v30 ^ 0xFFFF) * v152
                           + ((((unsigned __int16)*v30 ^ 0xFFFFu) * v152) >> 16)
                           + 1;
                      v152 ^= 0xFFFFu;
                      v154 = *v34 * v152 + HIWORD(v153) * (unsigned __int16)*(_DWORD *)v65;
                      v155 = (v152 + HIWORD(v153)) * HIWORD(*(_DWORD *)v65);
                      v151 = (v155 + HIWORD(v155) + 1) >> 16;
                      *v34 = (v154 + HIWORD(v154) + 1) >> 16;
                    }
                    *v30 = v151;
                  }
                }
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v147;
              }
              while (v147);
              goto LABEL_420;
            case 5:
              v156 = v40;
              v138 = v46;
              do
              {
                v157 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v157 = ((unsigned __int16)(*v138 * (_WORD)v157
                                                                  + ((*v138 * v157) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v158 = (unsigned __int16)*v30;
                    v159 = (v157 | (v157 << 8)) ^ 0xFFFF;
                    v160 = (unsigned __int16)*(_DWORD *)v65
                         - (((unsigned __int16)*(_DWORD *)v65 * v159
                           + (((unsigned __int16)*(_DWORD *)v65 * v159) >> 16)
                           + 1) >> 16);
                    v161 = (v160 | ((HIWORD(*(_DWORD *)v65)
                                   - ((HIWORD(*(_DWORD *)v65) * v159
                                     + ((HIWORD(*(_DWORD *)v65) * v159) >> 16)
                                     + 1) >> 16)) << 16)) >> 16;
                    v162 = (unsigned __int16)v160 * v158 + (v161 ^ 0xFFFF) * *v34;
                    *v34 = (v162 + HIWORD(v162) + 1) >> 16;
                    *v30 = (((v161 ^ 0xFFFF) + v158) * v161 + ((((v161 ^ 0xFFFF) + v158) * v161) >> 16) + 1) >> 16;
                  }
                }
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v156;
              }
              while (v156);
              goto LABEL_420;
            case 6:
              v163 = v40;
              v138 = v46;
              do
              {
                v164 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v164 = ((unsigned __int16)(*v138 * (_WORD)v164
                                                                  + ((*v138 * v164) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v165 = (unsigned __int16)*v30;
                    if ((_WORD)v165 != 0xFFFF)
                    {
                      if ((unsigned __int16)~(_WORD)v165 == 0xFFFF)
                      {
                        v166 = HIWORD(*(_DWORD *)v65);
                        v167 = (v164 | (v164 << 8)) ^ 0xFFFF;
                        *v34 = *v65
                             - (((unsigned __int16)*(_DWORD *)v65 * v167
                               + (((unsigned __int16)*(_DWORD *)v65 * v167) >> 16)
                               + 1) >> 16);
                        v168 = v166 - ((v166 * v167 + ((v166 * v167) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v169 = HIWORD(*(_DWORD *)v65);
                        v170 = (257 * v164 * (unsigned __int16)~(_WORD)v165
                              + ((257 * v164 * (unsigned __int16)~(_WORD)v165) >> 16)
                              + 1) >> 16;
                        *v34 += ((unsigned __int16)*(_DWORD *)v65 * v170
                               + (((unsigned __int16)*(_DWORD *)v65 * v170) >> 16)
                               + 1) >> 16;
                        v168 = v165 + ((v169 * v170 + ((v169 * v170) >> 16) + 1) >> 16);
                      }
                      *v30 = v168;
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v163;
              }
              while (v163);
              goto LABEL_420;
            case 7:
              v171 = v46 != 0;
              v172 = v40;
              v138 = v46;
              if (v51)
              {
                do
                {
                  v173 = *v66;
                  if (*v66)
                  {
                    if (v46)
                      v173 = ((unsigned __int16)(*v138 * (_WORD)v173
                                                                + ((*v138 * v173) >> 8)
                                                                + 1) >> 8);
                    if (v173)
                    {
                      if (v173 == 255)
                      {
                        v174 = (unsigned __int16)*v30;
                        v175 = ~*(_DWORD *)v65 >> 16;
                        *v34 -= (v175 * *v34 + ((v175 * *v34) >> 16) + 1) >> 16;
                        v176 = v174 - ((v175 * v174 + ((v175 * v174) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v177 = ((v173 | (v173 << 8)) ^ 0xFFFF)
                             + ((v65[1] * (v173 | (v173 << 8))
                               + ((v65[1] * (v173 | (v173 << 8))) >> 16)
                               + 1) >> 16);
                        v178 = v177 * *v34;
                        v176 = (v177 * (unsigned __int16)*v30 + ((v177 * (unsigned __int16)*v30) >> 16) + 1) >> 16;
                        *v34 = (v178 + HIWORD(v178) + 1) >> 16;
                      }
                      *v30 = v176;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v171;
                  ++v34;
                  ++v30;
                  --v172;
                }
                while (v172);
              }
              else
              {
                do
                {
                  v179 = *v66;
                  if (*v66)
                  {
                    if (v46)
                      v179 = ((unsigned __int16)(*v138 * (_WORD)v179
                                                                + ((*v138 * v179) >> 8)
                                                                + 1) >> 8);
                    if (v179)
                    {
                      if (v179 == 255)
                      {
                        v180 = *v34
                             - (((~*(_DWORD *)v65 >> 16) * *v34
                               + (((~*(_DWORD *)v65 >> 16) * *v34) >> 16)
                               + 1) >> 16);
                      }
                      else
                      {
                        v181 = v179 | (v179 << 8);
                        v182 = v65[1] * v181 + ((v65[1] * v181) >> 16) + 1;
                        v180 = (((v181 ^ 0xFFFF) + HIWORD(v182)) * *v34
                              + ((((v181 ^ 0xFFFF) + HIWORD(v182)) * *v34) >> 16)
                              + 1) >> 16;
                      }
                      *v34 = v180;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v171;
                  ++v34;
                  --v172;
                }
                while (v172);
              }
              goto LABEL_420;
            case 8:
              v183 = v46 != 0;
              v184 = v40;
              v138 = v46;
              if (v51)
              {
                do
                {
                  v185 = *v66;
                  if (*v66)
                  {
                    if (v46)
                      v185 = ((unsigned __int16)(*v138 * (_WORD)v185
                                                                + ((*v138 * v185) >> 8)
                                                                + 1) >> 8);
                    if (v185)
                    {
                      if (v185 == 255)
                      {
                        v186 = (unsigned __int16)*v30;
                        v187 = HIWORD(*(_DWORD *)v65);
                        *v34 -= (v187 * *v34 + ((v187 * *v34) >> 16) + 1) >> 16;
                        v188 = v186 - ((v187 * v186 + ((v187 * v186) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v189 = ((v185 | (v185 << 8)) ^ 0xFFFF)
                             + (((~*(_DWORD *)v65 >> 16) * (v185 | (v185 << 8))
                               + (((~*(_DWORD *)v65 >> 16) * (v185 | (v185 << 8))) >> 16)
                               + 1) >> 16);
                        v190 = v189 * *v34;
                        v188 = (v189 * (unsigned __int16)*v30 + ((v189 * (unsigned __int16)*v30) >> 16) + 1) >> 16;
                        *v34 = (v190 + HIWORD(v190) + 1) >> 16;
                      }
                      *v30 = v188;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v183;
                  ++v34;
                  ++v30;
                  --v184;
                }
                while (v184);
              }
              else
              {
                do
                {
                  v191 = *v66;
                  if (*v66)
                  {
                    if (v46)
                      v191 = ((unsigned __int16)(*v138 * (_WORD)v191
                                                                + ((*v138 * v191) >> 8)
                                                                + 1) >> 8);
                    if (v191)
                    {
                      if (v191 == 255)
                      {
                        v192 = *v34 - ((v65[1] * *v34 + ((v65[1] * *v34) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v193 = v191 | (v191 << 8);
                        v194 = (~*(_DWORD *)v65 >> 16) * v193
                             + (((~*(_DWORD *)v65 >> 16) * v193) >> 16)
                             + 1;
                        v192 = (((v193 ^ 0xFFFF) + HIWORD(v194)) * *v34
                              + ((((v193 ^ 0xFFFF) + HIWORD(v194)) * *v34) >> 16)
                              + 1) >> 16;
                      }
                      *v34 = v192;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v183;
                  ++v34;
                  --v184;
                }
                while (v184);
              }
              goto LABEL_420;
            case 9:
              v195 = v40;
              v138 = v46;
              do
              {
                v196 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v196 = ((unsigned __int16)(*v138 * (_WORD)v196
                                                                  + ((*v138 * v196) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v197 = ~(v196 | ((_WORD)v196 << 8));
                    v198 = ((unsigned __int16)*(_DWORD *)v65
                          - (((unsigned __int16)*(_DWORD *)v65 * v197
                            + (((unsigned __int16)*(_DWORD *)v65 * v197) >> 16)
                            + 1) >> 16)) | ((HIWORD(*(_DWORD *)v65)
                                           - ((HIWORD(*(_DWORD *)v65) * v197
                                             + ((HIWORD(*(_DWORD *)v65) * v197) >> 16)
                                             + 1) >> 16)) << 16);
                    v199 = (unsigned __int16)*v30 ^ 0xFFFF;
                    v200 = (unsigned __int16)(*(_DWORD *)v65
                                            - (((unsigned __int16)*(_DWORD *)v65 * v197
                                              + (((unsigned __int16)*(_DWORD *)v65 * v197) >> 16)
                                              + 1) >> 16))
                         * v199
                         + (unsigned __int16)(v197 + HIWORD(v198)) * *v34;
                    v201 = (v199 + (unsigned __int16)(v197 + HIWORD(v198))) * HIWORD(v198);
                    *v34 = (v200 + HIWORD(v200) + 1) >> 16;
                    *v30 = (v201 + HIWORD(v201) + 1) >> 16;
                  }
                }
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v195;
              }
              while (v195);
              goto LABEL_420;
            case 10:
              v202 = v40;
              v138 = v46;
              do
              {
                v203 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v203 = ((unsigned __int16)(*v138 * (_WORD)v203
                                                                  + ((*v138 * v203) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v204 = (v203 | (v203 << 8)) ^ 0xFFFF;
                    v205 = (unsigned __int16)*(_DWORD *)v65
                         - (((unsigned __int16)*(_DWORD *)v65 * v204
                           + (((unsigned __int16)*(_DWORD *)v65 * v204) >> 16)
                           + 1) >> 16);
                    v206 = (v205 | ((HIWORD(*(_DWORD *)v65)
                                   - ((HIWORD(*(_DWORD *)v65) * v204
                                     + ((HIWORD(*(_DWORD *)v65) * v204) >> 16)
                                     + 1) >> 16)) << 16)) >> 16;
                    v207 = (unsigned __int16)*v30 ^ 0xFFFF;
                    v208 = (unsigned __int16)v205 * v207 + (v206 ^ 0xFFFF) * *v34;
                    *v34 = (v208 + HIWORD(v208) + 1) >> 16;
                    *v30 = (((v206 ^ 0xFFFF) + v207) * v206 + ((((v206 ^ 0xFFFF) + v207) * v206) >> 16) + 1) >> 16;
                  }
                }
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v202;
              }
              while (v202);
              goto LABEL_420;
            case 11:
              v209 = v46 != 0;
              v210 = v40;
              v138 = v46;
              if (v51)
              {
                do
                {
                  v211 = *v66;
                  if (*v66)
                  {
                    if (!v46
                      || (v211 = ((unsigned __int16)(*v138 * (_WORD)v211
                                                                    + ((*v138 * v211) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      v212 = (v211 | (v211 << 8)) ^ 0xFFFF;
                      v213 = (unsigned __int16)*(_DWORD *)v65
                           - ((v212 * (unsigned __int16)*(_DWORD *)v65
                             + ((v212 * (unsigned __int16)*(_DWORD *)v65) >> 16)
                             + 1) >> 16);
                      v214 = v213 | ((HIWORD(*(_DWORD *)v65)
                                    - ((v212 * HIWORD(*(_DWORD *)v65)
                                      + ((v212 * HIWORD(*(_DWORD *)v65)) >> 16)
                                      + 1) >> 16)) << 16);
                      v215 = (unsigned __int16)*v30;
                      v216 = v215 - (*v34 + (unsigned __int16)v213) + HIWORD(v214);
                      v217 = v215 + HIWORD(v214);
                      if (v216 >= 0xFFFF)
                        LOWORD(v216) = -1;
                      if (v217 >= 0xFFFF)
                        LOWORD(v217) = -1;
                      *v34 = v217 - v216;
                      *v30 = v217;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v209;
                  ++v34;
                  ++v30;
                  --v210;
                }
                while (v210);
              }
              else
              {
                do
                {
                  v218 = *v66;
                  if (*v66)
                  {
                    if (!v46
                      || (v218 = ((unsigned __int16)(*v138 * (_WORD)v218
                                                                    + ((*v138 * v218) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      v219 = (v218 | (v218 << 8)) ^ 0xFFFF;
                      v220 = (unsigned __int16)*(_DWORD *)v65
                           - ((v219 * (unsigned __int16)*(_DWORD *)v65
                             + ((v219 * (unsigned __int16)*(_DWORD *)v65) >> 16)
                             + 1) >> 16);
                      v221 = (*v34 ^ 0xFFFF)
                           - (unsigned __int16)v220
                           + ((v220 | ((HIWORD(*(_DWORD *)v65)
                                      - ((v219 * HIWORD(*(_DWORD *)v65)
                                        + ((v219 * HIWORD(*(_DWORD *)v65)) >> 16)
                                        + 1) >> 16)) << 16)) >> 16);
                      if (v221 >= 0xFFFF)
                        LOWORD(v221) = -1;
                      *v34 = ~(_WORD)v221;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v209;
                  ++v34;
                  --v210;
                }
                while (v210);
              }
              goto LABEL_420;
            case 12:
              v222 = v46 != 0;
              v223 = v40;
              v138 = v46;
              if (v51)
              {
                do
                {
                  v224 = *v66;
                  if (*v66)
                  {
                    if (!v46
                      || (v224 = ((unsigned __int16)(*v138 * (_WORD)v224
                                                                    + ((*v138 * v224) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      v225 = (v224 | (v224 << 8)) ^ 0xFFFF;
                      v226 = (unsigned __int16)*(_DWORD *)v65
                           - ((v225 * (unsigned __int16)*(_DWORD *)v65
                             + ((v225 * (unsigned __int16)*(_DWORD *)v65) >> 16)
                             + 1) >> 16);
                      v227 = *v34 + (unsigned __int16)v226;
                      v228 = (unsigned __int16)*v30
                           + ((v226 | ((HIWORD(*(_DWORD *)v65)
                                      - ((v225 * HIWORD(*(_DWORD *)v65)
                                        + ((v225 * HIWORD(*(_DWORD *)v65)) >> 16)
                                        + 1) >> 16)) << 16)) >> 16);
                      if (v227 >= 0xFFFF)
                        LOWORD(v227) = -1;
                      if (v228 >= 0xFFFF)
                        LOWORD(v228) = -1;
                      *v34 = v227;
                      *v30 = v228;
                    }
                  }
                  ++v66;
                  v65 += 2;
                  v138 += v222;
                  ++v34;
                  ++v30;
                  --v223;
                }
                while (v223);
                goto LABEL_420;
              }
              v98 = v433;
              do
              {
                if (*v66
                  && (!v46
                   || ((*v138 * *v66 + ((*v138 * *v66) >> 8) + 1) & 0xFF00) != 0))
                {
                  *v34 = (2 * *v34) | ((__int16)*v34 >> 15);
                }
                ++v66;
                v138 += v222;
                ++v34;
                --v223;
              }
              while (v223);
              v360 = v422;
              if (!v46)
                v360 = 0;
              v97 = &v46[v428];
LABEL_525:
              v46 = &v97[v360];
              v34 += v429;
              v30 += v430;
              v108 = v434;
              goto LABEL_447;
            case 13:
              v229 = v40;
              v138 = v46;
              while (1)
              {
                v230 = *v66;
                if (!*v66)
                  goto LABEL_275;
                if (v46)
                {
                  v230 = ((unsigned __int16)(*v138 * (_WORD)v230
                                                            + ((*v138 * v230) >> 8)
                                                            + 1) >> 8);
                  if (!v230)
                    goto LABEL_275;
                }
                v231 = (v230 | (v230 << 8)) ^ 0xFFFF;
                v232 = (unsigned __int16)*(_DWORD *)v65
                     - ((v231 * (unsigned __int16)*(_DWORD *)v65
                       + ((v231 * (unsigned __int16)*(_DWORD *)v65) >> 16)
                       + 1) >> 16);
                v233 = v232 | ((HIWORD(*(_DWORD *)v65)
                              - ((v231 * HIWORD(*(_DWORD *)v65)
                                + ((v231 * HIWORD(*(_DWORD *)v65)) >> 16)
                                + 1) >> 16)) << 16);
                if (v233 < 0x10000)
                  goto LABEL_275;
                v234 = HIWORD(v233);
                if (v51)
                {
                  v235 = (unsigned __int16)*v30;
                  if (!*v30)
                    goto LABEL_273;
                }
                else
                {
                  v235 = 0xFFFF;
                }
                v236 = ((v234 ^ 0xFFFF) + (unsigned __int16)v232) * (unint64_t)*v34
                     + (v235 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v232;
                if (v236 <= 0xFFFE8000)
                  v237 = v236 + 0x8000;
                else
                  v237 = 4294868992;
                v238 = (v237 + (v237 >> 16)) >> 16;
                if (!v51)
                {
                  *v34 = v238;
                  goto LABEL_275;
                }
                v239 = 0xFFFF * (v235 + v234) - v235 * (unint64_t)v234;
                if (v239 <= 4294868992)
                  v234 = v239 + 0x8000;
                else
                  v234 = 4294868992;
                v233 = ((v234 >> 16) + v234) & 0xFFFF0000 | v238;
                LODWORD(v234) = HIWORD(v233);
LABEL_273:
                *v34 = v233;
                *v30 = v234;
LABEL_275:
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                if (!--v229)
                  goto LABEL_420;
              }
            case 14:
              v240 = v40;
              v138 = v46;
              while (1)
              {
                v241 = *v66;
                if (!*v66)
                  goto LABEL_296;
                if (v46)
                {
                  v241 = ((unsigned __int16)(*v138 * (_WORD)v241
                                                            + ((*v138 * v241) >> 8)
                                                            + 1) >> 8);
                  if (!v241)
                    goto LABEL_296;
                }
                v242 = (v241 | (v241 << 8)) ^ 0xFFFF;
                v243 = (unsigned __int16)*(_DWORD *)v65
                     - ((v242 * (unsigned __int16)*(_DWORD *)v65
                       + ((v242 * (unsigned __int16)*(_DWORD *)v65) >> 16)
                       + 1) >> 16);
                v244 = v243 | ((HIWORD(*(_DWORD *)v65)
                              - ((v242 * HIWORD(*(_DWORD *)v65)
                                + ((v242 * HIWORD(*(_DWORD *)v65)) >> 16)
                                + 1) >> 16)) << 16);
                if (v244 < 0x10000)
                  goto LABEL_296;
                v245 = HIWORD(v244);
                if (v51)
                {
                  v246 = (unsigned __int16)*v30;
                  if (!*v30)
                    goto LABEL_294;
                }
                else
                {
                  v246 = 0xFFFF;
                }
                v247 = (*v34 ^ 0xFFFFu) * (unint64_t)(unsigned __int16)v243
                     - *v34
                     + ((unint64_t)*v34 << 16);
                if (v247 <= 0xFFFE8000)
                  v248 = v247 + 0x8000;
                else
                  v248 = 4294868992;
                v249 = (v248 + (v248 >> 16)) >> 16;
                if (!v51)
                {
                  *v34 = v249;
                  goto LABEL_296;
                }
                v250 = 0xFFFF * (v246 + (unint64_t)v245) - v246 * (unint64_t)v245;
                if (v250 <= 4294868992)
                  v251 = v250 + 0x8000;
                else
                  v251 = 4294868992;
                v244 = ((v251 >> 16) + v251) & 0xFFFF0000 | v249;
                v245 = HIWORD(v244);
LABEL_294:
                *v34 = v244;
                *v30 = v245;
LABEL_296:
                ++v66;
                v65 += 2;
                v138 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                if (!--v240)
                  goto LABEL_420;
              }
            case 15:
              v252 = v46;
              do
              {
                v253 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v253 = ((unsigned __int16)(*v252 * (_WORD)v253
                                                                  + ((*v252 * v253) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v254 = (unsigned __int16)*(_DWORD *)v65;
                    v255 = (v253 | (v253 << 8)) ^ 0xFFFF;
                    v256 = v255 * v254 + ((v255 * v254) >> 16) + 1;
                    v257 = (v254 - HIWORD(v256)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v255 * HIWORD(*(_DWORD *)v65)
                                                     + ((v255 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v258 = HIWORD(v257);
                    if (HIWORD(v257))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v257 = PDAoverlayPDA_8071(*v34, (unsigned __int16)*v30, (unsigned __int16)(v254 - HIWORD(v256)), v258);
                          v51 = v437;
                          v258 = HIWORD(v257);
                        }
                        *v34 = v257;
                        *v30 = v258;
                      }
                      else
                      {
                        v259 = PDAoverlayPDA_8071(*v34, 0xFFFFu, (unsigned __int16)(v254 - HIWORD(v256)), v258);
                        v51 = v437;
                        *v34 = v259;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 16:
              v252 = v46;
              do
              {
                v260 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v260 = ((unsigned __int16)(*v252 * (_WORD)v260
                                                                  + ((*v252 * v260) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v261 = (unsigned __int16)*(_DWORD *)v65;
                    v262 = (v260 | (v260 << 8)) ^ 0xFFFF;
                    v263 = v262 * v261 + ((v262 * v261) >> 16) + 1;
                    v264 = (v261 - HIWORD(v263)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v262 * HIWORD(*(_DWORD *)v65)
                                                     + ((v262 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v265 = HIWORD(v264);
                    if (HIWORD(v264))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v264 = PDAdarkenPDA_8073(*v34, (unsigned __int16)*v30, (unsigned __int16)(v261 - HIWORD(v263)), v265);
                          v51 = v437;
                          v265 = HIWORD(v264);
                        }
                        *v34 = v264;
                        *v30 = v265;
                      }
                      else
                      {
                        v266 = PDAdarkenPDA_8073(*v34, 0xFFFFu, (unsigned __int16)(v261 - HIWORD(v263)), v265);
                        v51 = v437;
                        *v34 = v266;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 17:
              v252 = v46;
              do
              {
                v267 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v267 = ((unsigned __int16)(*v252 * (_WORD)v267
                                                                  + ((*v252 * v267) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v268 = (unsigned __int16)*(_DWORD *)v65;
                    v269 = (v267 | (v267 << 8)) ^ 0xFFFF;
                    v270 = v269 * v268 + ((v269 * v268) >> 16) + 1;
                    v271 = (v268 - HIWORD(v270)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v269 * HIWORD(*(_DWORD *)v65)
                                                     + ((v269 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v272 = HIWORD(v271);
                    if (HIWORD(v271))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v271 = PDAlightenPDA_8072(*v34, (unsigned __int16)*v30, (unsigned __int16)(v268 - HIWORD(v270)), v272);
                          v51 = v437;
                          v272 = HIWORD(v271);
                        }
                        *v34 = v271;
                        *v30 = v272;
                      }
                      else
                      {
                        v273 = PDAlightenPDA_8072(*v34, 0xFFFFu, (unsigned __int16)(v268 - HIWORD(v270)), v272);
                        v51 = v437;
                        *v34 = v273;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 18:
              v252 = v46;
              do
              {
                v274 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v274 = ((unsigned __int16)(*v252 * (_WORD)v274
                                                                  + ((*v252 * v274) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v275 = (unsigned __int16)*(_DWORD *)v65;
                    v276 = (v274 | (v274 << 8)) ^ 0xFFFF;
                    v277 = v276 * v275 + ((v276 * v275) >> 16) + 1;
                    v278 = (v275 - HIWORD(v277)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v276 * HIWORD(*(_DWORD *)v65)
                                                     + ((v276 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v279 = HIWORD(v278);
                    if (HIWORD(v278))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v278 = PDAcolordodgePDA_8074(*v34, (unsigned __int16)*v30, (unsigned __int16)(v275 - HIWORD(v277)), v279);
                          v51 = v437;
                          v279 = HIWORD(v278);
                        }
                        *v34 = v278;
                        *v30 = v279;
                      }
                      else
                      {
                        v280 = PDAcolordodgePDA_8074(*v34, 0xFFFFu, (unsigned __int16)(v275 - HIWORD(v277)), v279);
                        v51 = v437;
                        *v34 = v280;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 19:
              v252 = v46;
              do
              {
                v281 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v281 = ((unsigned __int16)(*v252 * (_WORD)v281
                                                                  + ((*v252 * v281) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v282 = (unsigned __int16)*(_DWORD *)v65;
                    v283 = (v281 | (v281 << 8)) ^ 0xFFFF;
                    v284 = v283 * v282 + ((v283 * v282) >> 16) + 1;
                    v285 = (v282 - HIWORD(v284)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v283 * HIWORD(*(_DWORD *)v65)
                                                     + ((v283 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v286 = HIWORD(v285);
                    if (HIWORD(v285))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v285 = PDAcolorburnPDA_8075(*v34, (unsigned __int16)*v30, (unsigned __int16)(v282 - HIWORD(v284)), v286);
                          v51 = v437;
                          v286 = HIWORD(v285);
                        }
                        *v34 = v285;
                        *v30 = v286;
                      }
                      else
                      {
                        v287 = PDAcolorburnPDA_8075(*v34, 0xFFFFu, (unsigned __int16)(v282 - HIWORD(v284)), v286);
                        v51 = v437;
                        *v34 = v287;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 20:
              v252 = v46;
              do
              {
                v288 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v288 = ((unsigned __int16)(*v252 * (_WORD)v288
                                                                  + ((*v252 * v288) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v289 = (unsigned __int16)*(_DWORD *)v65;
                    v290 = (v288 | (v288 << 8)) ^ 0xFFFF;
                    v291 = v290 * v289 + ((v290 * v289) >> 16) + 1;
                    v292 = (v289 - HIWORD(v291)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v290 * HIWORD(*(_DWORD *)v65)
                                                     + ((v290 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v293 = HIWORD(v292);
                    if (HIWORD(v292))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v292 = PDAsoftlightPDA_8077(*v34, (unsigned __int16)*v30, (unsigned __int16)(v289 - HIWORD(v291)), v293);
                          v51 = v437;
                          v293 = HIWORD(v292);
                        }
                        *v34 = v292;
                        *v30 = v293;
                      }
                      else
                      {
                        v294 = PDAsoftlightPDA_8077(*v34, 0xFFFFu, (unsigned __int16)(v289 - HIWORD(v291)), v293);
                        v51 = v437;
                        *v34 = v294;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 21:
              v252 = v46;
              do
              {
                v295 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v295 = ((unsigned __int16)(*v252 * (_WORD)v295
                                                                  + ((*v252 * v295) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v296 = (unsigned __int16)*(_DWORD *)v65;
                    v297 = (v295 | (v295 << 8)) ^ 0xFFFF;
                    v298 = v297 * v296 + ((v297 * v296) >> 16) + 1;
                    v299 = (v296 - HIWORD(v298)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v297 * HIWORD(*(_DWORD *)v65)
                                                     + ((v297 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v300 = HIWORD(v299);
                    if (HIWORD(v299))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v299 = PDAhardlightPDA_8076(*v34, (unsigned __int16)*v30, (unsigned __int16)(v296 - HIWORD(v298)), v300);
                          v51 = v437;
                          v300 = HIWORD(v299);
                        }
                        *v34 = v299;
                        *v30 = v300;
                      }
                      else
                      {
                        v301 = PDAhardlightPDA_8076(*v34, 0xFFFFu, (unsigned __int16)(v296 - HIWORD(v298)), v300);
                        v51 = v437;
                        *v34 = v301;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 22:
              v252 = v46;
              do
              {
                v302 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v302 = ((unsigned __int16)(*v252 * (_WORD)v302
                                                                  + ((*v252 * v302) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v303 = (unsigned __int16)*(_DWORD *)v65;
                    v304 = (v302 | (v302 << 8)) ^ 0xFFFF;
                    v305 = v304 * v303 + ((v304 * v303) >> 16) + 1;
                    v306 = (v303 - HIWORD(v305)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v304 * HIWORD(*(_DWORD *)v65)
                                                     + ((v304 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v307 = HIWORD(v306);
                    if (HIWORD(v306))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v306 = PDAdifferencePDA_8078(*v34, (unsigned __int16)*v30, (unsigned __int16)(v303 - HIWORD(v305)), v307);
                          v51 = v437;
                          v307 = HIWORD(v306);
                        }
                        *v34 = v306;
                        *v30 = v307;
                      }
                      else
                      {
                        v308 = PDAdifferencePDA_8078(*v34, 0xFFFFu, (unsigned __int16)(v303 - HIWORD(v305)), v307);
                        v51 = v437;
                        *v34 = v308;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 23:
              v309 = v40;
              v138 = v46;
              break;
            case 24:
              v252 = v46;
              do
              {
                v324 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v324 = ((unsigned __int16)(*v252 * (_WORD)v324
                                                                  + ((*v252 * v324) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v325 = (unsigned __int16)*(_DWORD *)v65;
                    v326 = (v324 | (v324 << 8)) ^ 0xFFFF;
                    v327 = v326 * v325 + ((v326 * v325) >> 16) + 1;
                    v328 = (v325 - HIWORD(v327)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v326 * HIWORD(*(_DWORD *)v65)
                                                     + ((v326 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v329 = HIWORD(v328);
                    if (HIWORD(v328))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v328 = PDAhuePDA_8079(*v34, (unsigned __int16)*v30, (unsigned __int16)(v325 - HIWORD(v327)), v329);
                          v51 = v437;
                          v329 = HIWORD(v328);
                        }
                        *v34 = v328;
                        *v30 = v329;
                      }
                      else
                      {
                        v330 = PDAhuePDA_8079(*v34, 0xFFFFu, (unsigned __int16)(v325 - HIWORD(v327)), v329);
                        v51 = v437;
                        *v34 = v330;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
              goto LABEL_445;
            case 25:
              v252 = v46;
              do
              {
                v331 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v331 = ((unsigned __int16)(*v252 * (_WORD)v331
                                                                  + ((*v252 * v331) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v332 = (unsigned __int16)*(_DWORD *)v65;
                    v333 = (v331 | (v331 << 8)) ^ 0xFFFF;
                    v334 = v333 * v332 + ((v333 * v332) >> 16) + 1;
                    v335 = (v332 - HIWORD(v334)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v333 * HIWORD(*(_DWORD *)v65)
                                                     + ((v333 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v336 = HIWORD(v335);
                    if (HIWORD(v335))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v335 = PDAhuePDA_8079(*v34, (unsigned __int16)*v30, (unsigned __int16)(v332 - HIWORD(v334)), v336);
                          v51 = v437;
                          v336 = HIWORD(v335);
                        }
                        *v34 = v335;
                        *v30 = v336;
                      }
                      else
                      {
                        v337 = PDAhuePDA_8079(*v34, 0xFFFFu, (unsigned __int16)(v332 - HIWORD(v334)), v336);
                        v51 = v437;
                        *v34 = v337;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v252 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                LODWORD(v40) = v40 - 1;
              }
              while ((_DWORD)v40);
LABEL_445:
              v46 = &v252[v428];
              goto LABEL_446;
            case 26:
              v338 = v40;
              v339 = v46;
              v340 = v338;
              do
              {
                v341 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v341 = ((unsigned __int16)(*v339 * (_WORD)v341
                                                                  + ((*v339 * v341) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v342 = (unsigned __int16)*(_DWORD *)v65;
                    v343 = (v341 | (v341 << 8)) ^ 0xFFFF;
                    v344 = v343 * v342 + ((v343 * v342) >> 16) + 1;
                    v345 = (v342 - HIWORD(v344)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v343 * HIWORD(*(_DWORD *)v65)
                                                     + ((v343 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v346 = HIWORD(v345);
                    if (HIWORD(v345))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v345 = PDAluminosityPDA_8081((unsigned __int16)(v342 - HIWORD(v344)), v346, *v34, (unsigned __int16)*v30);
                          v51 = v437;
                          v346 = HIWORD(v345);
                        }
                        *v34 = v345;
                        *v30 = v346;
                      }
                      else
                      {
                        v347 = PDAluminosityPDA_8081((unsigned __int16)(v342 - HIWORD(v344)), v346, *v34, 0xFFFFu);
                        v51 = v437;
                        *v34 = v347;
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v339 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v340;
              }
              while (v340);
              goto LABEL_475;
            case 27:
              v348 = v40;
              v339 = v46;
              v349 = v348;
              do
              {
                v350 = *v66;
                if (*v66)
                {
                  if (!v46
                    || (v350 = ((unsigned __int16)(*v339 * (_WORD)v350
                                                                  + ((*v339 * v350) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v351 = (unsigned __int16)*(_DWORD *)v65;
                    v352 = (v350 | (v350 << 8)) ^ 0xFFFF;
                    v353 = v352 * v351 + ((v352 * v351) >> 16) + 1;
                    v354 = (v351 - HIWORD(v353)) | ((HIWORD(*(_DWORD *)v65)
                                                   - ((v352 * HIWORD(*(_DWORD *)v65)
                                                     + ((v352 * HIWORD(*(_DWORD *)v65)) >> 16)
                                                     + 1) >> 16)) << 16);
                    v355 = HIWORD(v354);
                    if (HIWORD(v354))
                    {
                      if (v51)
                      {
                        if (*v30)
                        {
                          v354 = PDAluminosityPDA_8081(*v34, (unsigned __int16)*v30, (unsigned __int16)(v351 - HIWORD(v353)), v355);
                          v51 = v437;
                          v355 = HIWORD(v354);
                        }
                        *v34 = v354;
                        *v30 = v355;
                      }
                      else
                      {
                        v356 = (unsigned __int16)(v351 - HIWORD(v353));
                        if (v356 >= HIWORD(v354))
                          LOWORD(v356) = HIWORD(v354);
                        v357 = *v34 * (unint64_t)(v355 ^ 0xFFFF) + 0x8000;
                        *v34 = v356 + (((v357 >> 16) + v357) >> 16);
                      }
                    }
                  }
                }
                ++v66;
                v65 += 2;
                v339 += v46 != 0;
                ++v34;
                v30 = (_WORD *)((char *)v30 + v59);
                --v349;
              }
              while (v349);
LABEL_475:
              v46 = &v339[v428];
LABEL_446:
              v34 += v429;
              v30 += v430;
              v38 = v425;
              v40 = v426;
              v39 = v427;
              v98 = v433;
              v108 = v434;
              v70 = v435;
              goto LABEL_447;
            default:
              goto LABEL_421;
          }
          while (2)
          {
            v310 = *v66;
            if (*v66)
            {
              if (!v46
                || (v310 = ((unsigned __int16)(*v138 * (_WORD)v310
                                                              + ((*v138 * v310) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                v311 = (v310 | (v310 << 8)) ^ 0xFFFF;
                v312 = (unsigned __int16)*(_DWORD *)v65
                     - ((v311 * (unsigned __int16)*(_DWORD *)v65
                       + ((v311 * (unsigned __int16)*(_DWORD *)v65) >> 16)
                       + 1) >> 16);
                v313 = v312 | ((HIWORD(*(_DWORD *)v65)
                              - ((v311 * HIWORD(*(_DWORD *)v65)
                                + ((v311 * HIWORD(*(_DWORD *)v65)) >> 16)
                                + 1) >> 16)) << 16);
                v314 = HIWORD(v313);
                if (HIWORD(v313))
                {
                  if (v51)
                  {
                    v315 = (unsigned __int16)*v30;
                    if (!*v30)
                      goto LABEL_417;
                  }
                  else
                  {
                    v315 = 0xFFFF;
                  }
                  if ((unsigned __int16)v312 >= HIWORD(v313))
                    v316 = v314;
                  else
                    v316 = (unsigned __int16)v312;
                  if (*v34 >= v315)
                    v317 = v315;
                  else
                    v317 = *v34;
                  v318 = 0xFFFF * (v317 + v316) - 2 * v316 * (unint64_t)v317;
                  if (v318 <= 4294868992)
                    v319 = v318 + 0x8000;
                  else
                    v319 = 4294868992;
                  v320 = v319 + (v319 >> 16);
                  if (v51)
                  {
                    v321 = v320 >> 16;
                    v322 = 0xFFFF * (v315 + (unint64_t)v314) - v315 * (unint64_t)v314;
                    if (v322 <= 4294868992)
                      v323 = v322 + 0x8000;
                    else
                      v323 = 4294868992;
                    v313 = ((v323 >> 16) + v323) & 0xFFFF0000 | v321;
                    v314 = HIWORD(v313);
LABEL_417:
                    *v34 = v313;
                    *v30 = v314;
                  }
                  else
                  {
                    *v34 = WORD1(v320);
                  }
                }
              }
            }
            ++v66;
            v65 += 2;
            v138 += v46 != 0;
            ++v34;
            v30 = (_WORD *)((char *)v30 + v59);
            if (!--v309)
            {
LABEL_420:
              v46 = &v138[v428];
              v34 += v429;
              v30 += v430;
LABEL_421:
              v98 = v433;
              v108 = v434;
              goto LABEL_447;
            }
            continue;
          }
        }
        v55 = shape_enum_clip_scan((uint64_t)v436, (_DWORD *)v46 - 4);
        v51 = v437;
        if (!v55)
          goto LABEL_575;
      }
      v432 -= v54;
      if (v432 < 1)
      {
LABEL_575:
        if (v436)
          free(v436);
        goto LABEL_577;
      }
      v38 = v52;
      v41 += v39[16] * v54;
      v42 += v39[17] * v54;
      v34 += v416 * v54;
      v56 = v435 * v54;
      if (!v51)
        v56 = 0;
      v30 += v56;
      v48 = v53;
    }
  }
}

uint64_t PDAoverlayPDA_8071(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  v6 = 2 * v5 * (unint64_t)v4;
  v7 = a4 * (unint64_t)a2;
  v8 = (a4 + 0xFFFF) * (unint64_t)v5 + (a2 + 0xFFFF) * (unint64_t)v4 - (v7 + v6);
  v9 = (a2 ^ 0xFFFF) * (unint64_t)v4 + (a4 ^ 0xFFFF) * (unint64_t)v5 + v6;
  if (v5 >= ((unint64_t)a2 + 1) >> 1)
    v9 = v8;
  v10 = 0xFFFF * (a4 + (unint64_t)a2) - v7;
  v11 = v9 + 0x8000;
  if (v9 > 4294868992)
    v11 = 4294868992;
  v12 = (v11 + (v11 >> 16)) >> 16;
  if (v10 <= 4294868992)
    v13 = v10 + 0x8000;
  else
    v13 = 4294868992;
  return ((v13 >> 16) + (_DWORD)v13) & 0xFFFF0000 | v12;
}

uint64_t PDAlightenPDA_8072(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  int64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  v6 = a4 * (unint64_t)v5;
  if (v4 * (unint64_t)a2 > v6)
    v6 = v4 * (unint64_t)a2;
  v7 = (a4 ^ 0xFFFF) * (unint64_t)v5 + (a2 ^ 0xFFFF) * (unint64_t)v4 + v6;
  v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 <= 0xFFFE8000)
    v9 = v7 + 0x8000;
  else
    v9 = 4294868992;
  v10 = (v9 + (v9 >> 16)) >> 16;
  if (v8 <= 4294868992)
    v11 = v8 + 0x8000;
  else
    v11 = 4294868992;
  return ((v11 >> 16) + (_DWORD)v11) & 0xFFFF0000 | v10;
}

uint64_t PDAdarkenPDA_8073(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  int64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  v6 = a4 * (unint64_t)v5;
  if (v4 * (unint64_t)a2 < v6)
    v6 = v4 * (unint64_t)a2;
  v7 = (a4 ^ 0xFFFF) * (unint64_t)v5 + (a2 ^ 0xFFFF) * (unint64_t)v4 + v6;
  v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 <= 0xFFFE8000)
    v9 = v7 + 0x8000;
  else
    v9 = 4294868992;
  v10 = (v9 + (v9 >> 16)) >> 16;
  if (v8 <= 4294868992)
    v11 = v8 + 0x8000;
  else
    v11 = 4294868992;
  return ((v11 >> 16) + (_DWORD)v11) & 0xFFFF0000 | v10;
}

uint64_t PDAcolordodgePDA_8074(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  int64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  if (a1 >= a2)
    v4 = a2;
  else
    v4 = a1;
  if (a3 >= a4)
    v5 = a4;
  else
    v5 = a3;
  if (v4)
  {
    if (a3 >= a4)
      v6 = 4294836225;
    else
      v6 = (uint64_t)(a4 * v4 * (unint64_t)a4) / (a4 - v5);
  }
  else
  {
    v6 = 0;
  }
  v7 = (a4 ^ 0xFFFF) * (unint64_t)v4 + (a2 ^ 0xFFFF) * (unint64_t)v5 + v6;
  v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 >= v8)
    v7 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 <= 4294868992)
    v9 = v7 + 0x8000;
  else
    v9 = 4294868992;
  v10 = (v9 + (v9 >> 16)) >> 16;
  if (v8 <= 4294868992)
    v11 = v8 + 0x8000;
  else
    v11 = 4294868992;
  return ((v11 >> 16) + (_DWORD)v11) & 0xFFFF0000 | v10;
}

uint64_t PDAcolorburnPDA_8075(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int64_t v10;

  v4 = 4294868992;
  if (a3 >= a4)
    v5 = a4;
  else
    v5 = a3;
  if (a1 >= a2)
    v6 = a2;
  else
    v6 = a1;
  v7 = (a4 ^ 0xFFFF) * (unint64_t)v6
     + a4 * (unint64_t)a2
     + (a2 ^ 0xFFFF) * (unint64_t)v5;
  if (a2 > a1)
  {
    if (!(_DWORD)v5)
    {
      v9 = 0x8000;
      goto LABEL_14;
    }
    v8 = v7 - (uint64_t)(a4 * (unint64_t)a4 * (a2 - v6)) / v5;
    v7 = v8 & ~(v8 >> 63);
  }
  v9 = v7 + 0x8000;
  if (v7 > 0xFFFE8000)
    v9 = 4294868992;
LABEL_14:
  v10 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v10 <= 4294868992)
    v4 = v10 + 0x8000;
  return ((v4 >> 16) + (_DWORD)v4) & 0xFFFF0000 | ((v9 + (v9 >> 16)) >> 16);
}

uint64_t PDAhardlightPDA_8076(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unint64_t v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  v6 = 2 * v5 * (unint64_t)v4;
  v7 = a4 * (unint64_t)a2;
  v8 = (a2 ^ 0xFFFF) * (unint64_t)v4 + (a4 ^ 0xFFFF) * (unint64_t)v5 + v6;
  v9 = (a4 + 0xFFFF) * (unint64_t)v5 + (a2 + 0xFFFF) * (unint64_t)v4 - (v7 + v6);
  if (v4 > ((unint64_t)a4 + 1) >> 1)
    v10 = v9;
  else
    v10 = v8;
  v11 = 0xFFFF * (a4 + (unint64_t)a2) - v7;
  v12 = v10 + 0x8000;
  if (v10 > 4294868992)
    v12 = 4294868992;
  v13 = (v12 + (v12 >> 16)) >> 16;
  if (v11 <= 4294868992)
    v14 = v11 + 0x8000;
  else
    v14 = 4294868992;
  return ((v14 >> 16) + (_DWORD)v14) & 0xFFFF0000 | v13;
}

uint64_t PDAsoftlightPDA_8077(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int v5;
  int64_t v6;
  uint64_t v7;
  unint64_t v8;
  int64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  if (a2)
  {
    v6 = 2 * v5 * (unint64_t)v4 - (uint64_t)(v5 * (unint64_t)v5 * (2 * v4 - a4)) / a2;
    v7 = v6 & ~(v6 >> 63);
  }
  else
  {
    v7 = 0;
  }
  v8 = (a4 ^ 0xFFFF) * (unint64_t)v5 + (a2 ^ 0xFFFF) * (unint64_t)v4 + v7;
  v9 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  v10 = v8 + 0x8000;
  if (v8 > 0xFFFE8000)
    v10 = 4294868992;
  v11 = (v10 + (v10 >> 16)) >> 16;
  if (v9 <= 4294868992)
    v12 = v9 + 0x8000;
  else
    v12 = 4294868992;
  return ((v12 >> 16) + (_DWORD)v12) & 0xFFFF0000 | v11;
}

uint64_t PDAdifferencePDA_8078(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  unint64_t v7;
  int64_t v8;
  uint64_t v9;
  int64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  v6 = a4 * (unint64_t)v5 - v4 * (unint64_t)a2;
  v7 = 0xFFFF * (v4 + v5) - v4 * (unint64_t)a2 - a4 * (unint64_t)v5;
  if (v6 >= 0)
    v8 = v6;
  else
    v8 = -v6;
  v9 = v7 + v8;
  v10 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v9 <= 4294868992)
    v11 = v9 + 0x8000;
  else
    v11 = 4294868992;
  v12 = (v11 + (v11 >> 16)) >> 16;
  if (v10 <= 4294868992)
    v13 = v10 + 0x8000;
  else
    v13 = 4294868992;
  return ((v13 >> 16) + (_DWORD)v13) & 0xFFFF0000 | v12;
}

uint64_t PDAhuePDA_8079(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;

  if (a1 >= a2)
    LODWORD(v4) = a2;
  else
    LODWORD(v4) = a1;
  v5 = (a4 ^ 0xFFFF) * (unint64_t)v4;
  if (a4 == 0xFFFF)
    v5 = 0;
  else
    v4 = (a4 * (unint64_t)v4 + 0x8000 + ((a4 * (unint64_t)v4 + 0x8000) >> 16)) >> 16;
  if (a3 >= a4)
    v6 = a4;
  else
    v6 = a3;
  v7 = v5 + (a2 ^ 0xFFFF) * (unint64_t)v6;
  if (v7 <= 0xFFFE8000)
    v8 = v7 + 0x8000;
  else
    v8 = 4294868992;
  return (((v8 + (v8 >> 16)) >> 16) + (_DWORD)v4) | ((a4
                                                                  + a2
                                                                  - ((((a4 * (unint64_t)a2 + 0x8000) >> 16)
                                                                    + a4 * a2
                                                                    + 0x8000) >> 16)) << 16);
}

uint64_t PDAluminosityPDA_8081(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unint64_t v4;
  unsigned int v5;
  int64_t v6;
  unint64_t v7;

  if (a3 >= a4)
    v4 = a4;
  else
    v4 = a3;
  if (a1 >= a2)
    v5 = a2;
  else
    v5 = a1;
  v6 = (a4 ^ 0xFFFF) * (unint64_t)v5;
  if (a2 != 0xFFFF)
  {
    v6 = v6 - v4 + (v4 << 16) - v4 * (unint64_t)a2;
    v4 = (v4 * (unint64_t)a2 + 0x8000 + ((v4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  }
  v7 = v6 + 0x8000;
  if (v6 > 4294868992)
    v7 = 4294868992;
  return (((v7 + (v7 >> 16)) >> 16) + (_DWORD)v4) | ((a4
                                                                  + a2
                                                                  - ((((a4 * (unint64_t)a2 + 0x8000) >> 16)
                                                                    + a4 * a2
                                                                    + 0x8000) >> 16)) << 16);
}

uint64_t w16_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  _WORD *v6;
  _WORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t result;
  unsigned __int8 *v17;
  int v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned int v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  unsigned __int8 *v45;
  unsigned int v46;
  unsigned __int8 *v47;
  unsigned int v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  unsigned int v51;
  unsigned __int8 *v52;
  int v53;
  unsigned __int8 *v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t *v62;
  unsigned __int8 *v63;
  int v64;
  unsigned int v65;
  unsigned __int8 *v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 *v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned __int8 *v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  int v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;

  v6 = (_WORD *)*((_QWORD *)a2 + 2);
  v7 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v7)
    v91 = *((_QWORD *)a2 + 5) - a5;
  else
    v91 = 0;
  v8 = *((unsigned __int16 *)a2 + 4);
  v90 = *a2;
  v89 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v9 = *((_QWORD *)a2 + 18);
  v11 = *((_QWORD *)a2 + 9);
  v88 = *((_QWORD *)a2 + 11);
  v12 = *((_QWORD *)a2 + 7) + v88 * a4;
  v13 = *(unsigned __int8 **)(a1 + 32);
  v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v15 = *(_QWORD *)(a1 + 176);
  result = 2 * (v7 != 0);
  if (v15)
  {
    v87 = *((_QWORD *)a2 + 13);
    v86 = *((_QWORD *)a2 + 15);
    v17 = v14 - 4;
    v18 = v8 ^ 0xFFFF;
    v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    v85 = v9 + 16 * a3 + 8;
    do
    {
      if (((v86 - v12) | (v12 - v87)) < 0)
      {
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9)
          v21 = -v10;
        else
          v21 = v10;
        v22 = weights_19497[v20] & 0xF;
      }
      v23 = &v13[(v12 >> v11) * v10];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          v24 = (uint64_t *)v85;
          v25 = a5;
          do
          {
            v26 = *v24;
            v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27)
              v28 = &v23[*(v24 - 1)];
            else
              v28 = v17;
            if (v28 < v13)
              v28 = v13;
            v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30)
                v30 = v17;
              if (v30 < v13)
                v30 = v13;
              v31 = *v30;
              if (v22)
              {
                v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v33 < v13)
                  v33 = v13;
                v34 = *v33;
                v35 = &v32[v26 >> 4];
                if (v17 < v35)
                  v35 = v17;
                if (v35 < v13)
                  v35 = v13;
                v36 = BLEND8_19499[v22];
                v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                v31 = v31 - ((v36 & v31) >> v22) + ((v36 & *v35) >> v22);
              }
              v29 = v29
                  - ((BLEND8_19499[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_19499[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37)
                v37 = v17;
              if (v37 < v13)
                v37 = v13;
              v29 = v29 - ((BLEND8_19499[v22] & v29) >> v22) + ((BLEND8_19499[v22] & *v37) >> v22);
            }
            v38 = v29 | (v29 << 8);
            v39 = v38 | 0xFFFF0000;
            v40 = (v38 - ((v38 * v18 + ((v38 * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF)
              v40 = v39;
            *v6 = v40;
            if (v7)
              *v7 = HIWORD(v40);
            v24 += 2;
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        v42 = (uint64_t *)v85;
        v41 = a5;
        do
        {
          v43 = *v42;
          v44 = (unint64_t)&v23[*(v42 - 1)];
          if ((unint64_t)v17 >= v44)
            v45 = &v23[*(v42 - 1)];
          else
            v45 = v17;
          if (v45 < v13)
            v45 = v13;
          v46 = *v45;
          if ((v43 & 0xF) != 0)
          {
            v47 = (unsigned __int8 *)(v44 + (v43 >> 4));
            if (v17 < v47)
              v47 = v17;
            if (v47 < v13)
              v47 = v13;
            v48 = *v47;
            if (v22)
            {
              v49 = (unsigned __int8 *)(v44 + v21);
              if (v17 >= v49)
                v50 = v49;
              else
                v50 = v17;
              if (v50 < v13)
                v50 = v13;
              v51 = *v50;
              v52 = &v49[v43 >> 4];
              if (v17 < v52)
                v52 = v17;
              if (v52 < v13)
                v52 = v13;
              v53 = BLEND8_19499[v22];
              v46 = v46 - ((v53 & v46) >> v22) + ((v53 & v51) >> v22);
              v48 = v48 - ((v53 & v48) >> v22) + ((v53 & *v52) >> v22);
            }
            v46 = v46
                - ((BLEND8_19499[*v42 & 0xF] & v46) >> (*v42 & 0xF))
                + ((BLEND8_19499[*v42 & 0xF] & v48) >> (*v42 & 0xF));
          }
          else if (v22)
          {
            v54 = (unsigned __int8 *)(v44 + v21);
            if (v17 < v54)
              v54 = v17;
            if (v54 < v13)
              v54 = v13;
            v46 = v46 - ((BLEND8_19499[v22] & v46) >> v22) + ((BLEND8_19499[v22] & *v54) >> v22);
          }
          v55 = v46 | (v46 << 8);
          v56 = v55 | 0xFFFF0000;
          v57 = (v55 - ((v55 * v18 + ((v55 * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF)
            v58 = v56;
          else
            v58 = v57;
          v59 = HIWORD(v58);
          if (v7)
          {
            if (v59)
            {
              if (v59 == 0xFFFF)
              {
                *v6 = v58;
                *v7 = -1;
              }
              else
              {
                v60 = (unsigned __int16)*v7;
                v61 = v59 ^ 0xFFFF;
                *v6 = v58
                    + ((v61 * (unsigned __int16)*v6 + ((v61 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                *v7 = ((v61 * v60 + ((v61 * v60) >> 16) + 1) >> 16) + HIWORD(v58);
              }
            }
          }
          else if (v59)
          {
            if (v59 == 0xFFFF)
              *v6 = v58;
            else
              *v6 = v58
                  + (((v59 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v59 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
          }
          v42 += 2;
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          --v41;
        }
        while (v41);
      }
      v6 += v89;
      v12 += v88;
      v7 += v91;
      --a6;
    }
    while (a6);
  }
  else
  {
    v62 = (uint64_t *)(v9 + 16 * a3);
    v63 = v14 - 4;
    v64 = v8 ^ 0xFFFF;
    v65 = ~(0xFFFF * v64 + ((0xFFFF * v64) >> 16) + 1) & 0xFFFF0000;
    do
    {
      v66 = &v13[(v12 >> v11) * v10];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          v67 = v62;
          v68 = a5;
          do
          {
            v69 = *v67;
            v67 += 2;
            v70 = &v66[v69];
            if (v63 < &v66[v69])
              v70 = v63;
            if (v70 < v13)
              v70 = v13;
            v71 = *v70 | (*v70 << 8);
            v72 = v71 | 0xFFFF0000;
            v73 = (v71 - ((v71 * v64 + ((v71 * v64) >> 16) + 1) >> 16)) | v65;
            if (v8 == 0xFFFF)
              v73 = v72;
            *v6 = v73;
            if (v7)
              *v7 = HIWORD(v73);
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v68;
          }
          while (v68);
        }
      }
      else
      {
        v74 = v62;
        v75 = a5;
        if (a5 >= 1)
        {
          do
          {
            v76 = *v74;
            v74 += 2;
            v77 = &v66[v76];
            if (v63 < &v66[v76])
              v77 = v63;
            if (v77 < v13)
              v77 = v13;
            v78 = *v77 | (*v77 << 8);
            v79 = v78 | 0xFFFF0000;
            v80 = (v78 - ((v78 * v64 + ((v78 * v64) >> 16) + 1) >> 16)) | v65;
            if (v8 == 0xFFFF)
              v81 = v79;
            else
              v81 = v80;
            v82 = HIWORD(v81);
            if (v7)
            {
              if (v82)
              {
                if (v82 == 0xFFFF)
                {
                  *v6 = v81;
                  *v7 = -1;
                }
                else
                {
                  v83 = (unsigned __int16)*v7;
                  v84 = v82 ^ 0xFFFF;
                  *v6 = v81
                      + ((v84 * (unsigned __int16)*v6 + ((v84 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                  *v7 = ((v84 * v83 + ((v84 * v83) >> 16) + 1) >> 16) + HIWORD(v81);
                }
              }
            }
            else if (v82)
            {
              if (v82 == 0xFFFF)
                *v6 = v81;
              else
                *v6 = v81
                    + (((v82 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v82 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
            }
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v75;
          }
          while (v75);
        }
      }
      v6 += v89;
      v12 += v88;
      v7 += v91;
      --a6;
    }
    while (a6);
  }
  return result;
}

void w16_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(_QWORD, _QWORD))
{
  __n128 v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  unint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  int v49;
  int v50;
  int *v51;
  int v52;
  void *v53;
  void *v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(_QWORD, _QWORD);
  char *v65;
  uint64_t *v66;
  _DWORD v67[2];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  int v77;
  int v78;
  _QWORD v79[3];

  v79[1] = *MEMORY[0x1E0C80C00];
  v8.n128_u64[1] = 0;
  v68 = 0u;
  v69 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v70 = 0u;
  v8.n128_f64[0] = *(float *)(a2 + 184) * 65535.9;
  v67[0] = a3;
  v67[1] = a4;
  LOWORD(v68) = (int)v8.n128_f64[0];
  v9 = (unint64_t)*(int *)(a1 + 28) >> 1;
  *(_QWORD *)&v69 = v9;
  if (*(_QWORD *)(a1 + 48))
    v10 = (unint64_t)*(int *)(a1 + 32) >> 1;
  else
    v10 = 0;
  *(_QWORD *)&v70 = v10;
  v11 = *(_QWORD *)(a2 + 120);
  v12 = *(_DWORD *)(a2 + 20);
  v13 = HIBYTE(v12);
  v14 = BYTE2(v12);
  if (v11)
  {
    v15 = *(int *)(a2 + 24);
    v16 = (uint64_t *)(a2 + 104);
    v17 = (uint64_t *)(a2 + 72);
    v18 = (uint64_t *)(a2 + 88);
    v19 = v13;
  }
  else
  {
    v15 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v16 = (uint64_t *)(a2 + 96);
    v17 = (uint64_t *)(a2 + 64);
    v18 = (uint64_t *)(a2 + 80);
    v11 = *(_QWORD *)(a2 + 112);
    v19 = v14;
  }
  v20 = *v18;
  v21 = *v17;
  v22 = *v16;
  v23 = v19;
  *((_QWORD *)&v71 + 1) = v19;
  *((_QWORD *)&v70 + 1) = v22;
  *((_QWORD *)&v75 + 1) = v15;
  *((_QWORD *)&v74 + 1) = v20;
  *((_QWORD *)&v73 + 1) = v21;
  *((_QWORD *)&v72 + 1) = v11;
  v24 = *(_QWORD *)(a2 + 128);
  if (v24)
  {
    v25 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v26 = (uint64_t *)(a2 + 96);
    v27 = (uint64_t *)(a2 + 64);
    v28 = (uint64_t *)(a2 + 80);
    v13 = v14;
  }
  else
  {
    v25 = *(int *)(a2 + 24);
    v26 = (uint64_t *)(a2 + 104);
    v27 = (uint64_t *)(a2 + 72);
    v28 = (uint64_t *)(a2 + 88);
    v24 = *(_QWORD *)(a2 + 136);
  }
  v66 = &v62;
  v29 = *v28;
  v30 = *v27;
  v31 = *v26;
  *(_QWORD *)&v72 = v13;
  *(_QWORD *)&v71 = v31;
  *(_QWORD *)&v76 = v25;
  *(_QWORD *)&v75 = v29;
  *(_QWORD *)&v74 = v30;
  *(_QWORD *)&v73 = v24;
  v32 = *(int *)(a1 + 4);
  MEMORY[0x1E0C80A78](a1, v8);
  v65 = (char *)&v62 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL)
    v37 = (char *)&v62 - v34 - 15;
  else
    v37 = 0;
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    v63 = v33;
    v64 = a5;
    v38 = v36;
    v37 = (char *)malloc_type_malloc(16 * v32, 0x1B1F656EuLL);
    v33 = v63;
    v36 = v38;
    a5 = v64;
  }
  *((_QWORD *)&v76 + 1) = v37;
  if (v37)
  {
    v39 = v32;
    if (*(_QWORD *)(a2 + 176))
    {
      if ((int)v32 >= 1)
      {
        v40 = (uint64_t *)(v37 + 8);
        v41 = -v33;
        v42 = v36 - v22;
        do
        {
          if (((v41 + v22) | v42) < 0)
          {
            v45 = 0;
            v46 = 0;
          }
          else
          {
            v43 = ((v22 & (unint64_t)~(-1 << v23)) >> (v23 - 4)) & 0xF;
            v44 = weights_19497[v43];
            if (v43 - 7 >= 9)
              v45 = -(uint64_t)v15;
            else
              v45 = v15;
            v46 = v44 & 0xF;
          }
          v33 = v15 * (v22 >> v23);
          *(v40 - 1) = v33;
          *v40 = v46 | (16 * v45);
          v40 += 2;
          v22 += v11;
          v42 -= v11;
          --v39;
        }
        while (v39);
      }
    }
    else if ((int)v32 >= 1)
    {
      v47 = v37 + 8;
      do
      {
        *(v47 - 1) = v15 * (v22 >> v23);
        *v47 = 0;
        v47 += 2;
        v22 += v11;
        --v39;
      }
      while (v39);
    }
    v48 = v37;
    v49 = *(_DWORD *)(a1 + 4);
    v50 = *(_DWORD *)(a1 + 8);
    v77 = v50;
    v78 = v49;
    v51 = *(int **)(a1 + 136);
    if (v51)
    {
      v52 = *(_DWORD *)(a1 + 104);
      LODWORD(v79[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v79[0]) = v52;
      shape_enum_clip_alloc((uint64_t)v37, v33, v51, 1, 1, 1, v52, v79[0], v49, v50);
      v54 = v53;
      if (v53)
        goto LABEL_36;
    }
    v55 = 0;
    v56 = 0;
    v54 = 0;
    v79[0] = 0;
    while (1)
    {
      v57 = *(int *)(a1 + 16) + (uint64_t)v56;
      v58 = *(_QWORD *)(a1 + 48);
      v59 = v55 + *(_DWORD *)(a1 + 12);
      v60 = *(_QWORD *)(a1 + 40) + 2 * v9 * v57 + 2 * v59;
      v61 = v58 + 2 * v10 * v57 + 2 * v59;
      if (!v58)
        v61 = 0;
      *((_QWORD *)&v68 + 1) = v60;
      *((_QWORD *)&v69 + 1) = v61;
      a5(a2, v67);
      if (!v54)
        break;
LABEL_36:
      if (!shape_enum_clip_next((uint64_t)v54, (int *)v79 + 1, v79, &v78, &v77))
      {
        free(v54);
        break;
      }
      v56 = v79[0];
      v55 = HIDWORD(v79[0]);
      v9 = v69;
      v10 = v70;
    }
    if (v48 != v65)
      free(v48);
  }
}

uint64_t w16_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  _WORD *v6;
  _WORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t result;
  unsigned __int8 *v17;
  int v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  unsigned __int8 *v30;
  int v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 *v35;
  unsigned int v36;
  unsigned __int8 *v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  unsigned __int8 *v46;
  unsigned int v47;
  unsigned __int8 *v48;
  int v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  int v52;
  unsigned __int8 *v53;
  unsigned int v54;
  unsigned __int8 *v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  uint64_t *v64;
  unsigned __int8 *v65;
  int v66;
  unsigned int v67;
  unsigned __int8 *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 *v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t *v77;
  uint64_t v78;
  uint64_t v79;
  unsigned __int8 *v80;
  unsigned int v81;
  int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  uint64_t v94;

  v6 = (_WORD *)*((_QWORD *)a2 + 2);
  v7 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v7)
    v94 = *((_QWORD *)a2 + 5) - a5;
  else
    v94 = 0;
  v8 = *((unsigned __int16 *)a2 + 4);
  v93 = *a2;
  v92 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v9 = *((_QWORD *)a2 + 18);
  v11 = *((_QWORD *)a2 + 9);
  v91 = *((_QWORD *)a2 + 11);
  v12 = *((_QWORD *)a2 + 7) + v91 * a4;
  v13 = *(unsigned __int8 **)(a1 + 32);
  v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v15 = *(_QWORD *)(a1 + 176);
  result = 2 * (v7 != 0);
  if (v15)
  {
    v90 = *((_QWORD *)a2 + 13);
    v89 = *((_QWORD *)a2 + 15);
    v17 = v14 - 3;
    v18 = v8 ^ 0xFFFF;
    v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    do
    {
      if (((v89 - v12) | (v12 - v90)) < 0)
      {
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9)
          v21 = -v10;
        else
          v21 = v10;
        v22 = weights_19497[v20] & 0xF;
      }
      v23 = &v13[(v12 >> v11) * v10];
      if (v93 == 1)
      {
        if (a5 >= 1)
        {
          v24 = (uint64_t *)(v9 + 16 * a3 + 8);
          v25 = a5;
          do
          {
            v26 = *v24;
            v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27)
              v28 = &v23[*(v24 - 1)];
            else
              v28 = v17;
            if (v28 < v13)
              v28 = v13;
            v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30)
                v30 = v17;
              if (v30 < v13)
                v30 = v13;
              v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
              if (v22)
              {
                v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v33 < v13)
                  v33 = v13;
                v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
                v35 = &v32[v26 >> 4];
                if (v17 < v35)
                  v35 = v17;
                if (v35 < v13)
                  v35 = v13;
                v36 = BLEND8_19499[v22];
                v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                v31 = v31 - ((v36 & v31) >> v22) + ((((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8)) & v36) >> v22);
              }
              v29 = v29
                  - ((BLEND8_19499[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_19499[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37)
                v37 = v17;
              if (v37 < v13)
                v37 = v13;
              v29 = v29
                  - ((BLEND8_19499[v22] & v29) >> v22)
                  + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & BLEND8_19499[v22]) >> v22);
            }
            v38 = ((v29 >> 23) & 0x1FE) + BYTE1(v29) + (((v29 >> 8) & 0xFF00) >> 6) + (((v29 >> 8) & 0xFF00) >> 8);
            v39 = 32 * v38;
            v38 >>= 6;
            v40 = (unsigned __int16)v38 | (unsigned __int16)v39 | 0xFFFF0000;
            v41 = ((v39 | v38) - (((v39 | v38) * v18 + (((v39 | v38) * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF)
              v41 = v40;
            *v6 = v41;
            if (v7)
              *v7 = HIWORD(v41);
            v24 += 2;
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        v43 = (uint64_t *)(v9 + 16 * a3 + 8);
        v42 = a5;
        do
        {
          v44 = *v43;
          v45 = (unint64_t)&v23[*(v43 - 1)];
          if ((unint64_t)v17 >= v45)
            v46 = &v23[*(v43 - 1)];
          else
            v46 = v17;
          if (v46 < v13)
            v46 = v13;
          v47 = (*v46 << 24) | (v46[1] << 16) | (v46[2] << 8);
          if ((v44 & 0xF) != 0)
          {
            v48 = (unsigned __int8 *)(v45 + (v44 >> 4));
            if (v17 < v48)
              v48 = v17;
            if (v48 < v13)
              v48 = v13;
            v49 = (*v48 << 24) | (v48[1] << 16) | (v48[2] << 8);
            if (v22)
            {
              v50 = (unsigned __int8 *)(v45 + v21);
              if (v17 >= v50)
                v51 = v50;
              else
                v51 = v17;
              if (v51 < v13)
                v51 = v13;
              v52 = (*v51 << 24) | (v51[1] << 16) | (v51[2] << 8);
              v53 = &v50[v44 >> 4];
              if (v17 < v53)
                v53 = v17;
              if (v53 < v13)
                v53 = v13;
              v54 = BLEND8_19499[v22];
              v47 = v47 - ((v54 & v47) >> v22) + ((v54 & v52) >> v22);
              v49 = v49 - ((v54 & v49) >> v22) + ((((*v53 << 24) | (v53[1] << 16) | (v53[2] << 8)) & v54) >> v22);
            }
            v47 = v47
                - ((BLEND8_19499[*v43 & 0xF] & v47) >> (*v43 & 0xF))
                + ((BLEND8_19499[*v43 & 0xF] & v49) >> (*v43 & 0xF));
          }
          else if (v22)
          {
            v55 = (unsigned __int8 *)(v45 + v21);
            if (v17 < v55)
              v55 = v17;
            if (v55 < v13)
              v55 = v13;
            v47 = v47
                - ((BLEND8_19499[v22] & v47) >> v22)
                + ((((*v55 << 24) | (v55[1] << 16) | (v55[2] << 8)) & BLEND8_19499[v22]) >> v22);
          }
          v56 = ((v47 >> 23) & 0x1FE) + BYTE1(v47) + (((v47 >> 8) & 0xFF00) >> 6) + (((v47 >> 8) & 0xFF00) >> 8);
          v57 = 32 * v56;
          v56 >>= 6;
          v58 = (unsigned __int16)v56 | (unsigned __int16)v57 | 0xFFFF0000;
          v59 = ((v57 | v56) - (((v57 | v56) * v18 + (((v57 | v56) * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF)
            v60 = v58;
          else
            v60 = v59;
          v61 = HIWORD(v60);
          if (v7)
          {
            if (v61)
            {
              if (v61 == 0xFFFF)
              {
                *v6 = v60;
                *v7 = -1;
              }
              else
              {
                v62 = (unsigned __int16)*v7;
                v63 = v61 ^ 0xFFFF;
                *v6 = v60
                    + ((v63 * (unsigned __int16)*v6 + ((v63 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                *v7 = ((v63 * v62 + ((v63 * v62) >> 16) + 1) >> 16) + HIWORD(v60);
              }
            }
          }
          else if (v61)
          {
            if (v61 == 0xFFFF)
              *v6 = v60;
            else
              *v6 = v60
                  + (((v61 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v61 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
          }
          v43 += 2;
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          --v42;
        }
        while (v42);
      }
      v6 += v92;
      v12 += v91;
      v7 += v94;
      --a6;
    }
    while (a6);
  }
  else
  {
    v64 = (uint64_t *)(v9 + 16 * a3);
    v65 = v14 - 3;
    v66 = v8 ^ 0xFFFF;
    v67 = ~(0xFFFF * v66 + ((0xFFFF * v66) >> 16) + 1) & 0xFFFF0000;
    do
    {
      v68 = &v13[(v12 >> v11) * v10];
      if (v93 == 1)
      {
        if (a5 >= 1)
        {
          v69 = v64;
          v70 = a5;
          do
          {
            v71 = *v69;
            v69 += 2;
            v72 = &v68[v71];
            if (v65 < &v68[v71])
              v72 = v65;
            if (v72 < v13)
              v72 = v13;
            v73 = v72[2] + 2 * *v72 + 4 * v72[1] + v72[1];
            v74 = 32 * v73;
            v73 >>= 6;
            v75 = (unsigned __int16)v73 | (unsigned __int16)v74 | 0xFFFF0000;
            v76 = ((v74 | v73) - (((v74 | v73) * v66 + (((v74 | v73) * v66) >> 16) + 1) >> 16)) | v67;
            if (v8 == 0xFFFF)
              v76 = v75;
            *v6 = v76;
            if (v7)
              *v7 = HIWORD(v76);
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v70;
          }
          while (v70);
        }
      }
      else
      {
        v77 = v64;
        v78 = a5;
        if (a5 >= 1)
        {
          do
          {
            v79 = *v77;
            v77 += 2;
            v80 = &v68[v79];
            if (v65 < &v68[v79])
              v80 = v65;
            if (v80 < v13)
              v80 = v13;
            v81 = v80[2] + 2 * *v80 + 4 * v80[1] + v80[1];
            v82 = 32 * v81;
            v81 >>= 6;
            v83 = (unsigned __int16)v81 | (unsigned __int16)v82 | 0xFFFF0000;
            v84 = ((v82 | v81) - (((v82 | v81) * v66 + (((v82 | v81) * v66) >> 16) + 1) >> 16)) | v67;
            if (v8 == 0xFFFF)
              v85 = v83;
            else
              v85 = v84;
            v86 = HIWORD(v85);
            if (v7)
            {
              if (v86)
              {
                if (v86 == 0xFFFF)
                {
                  *v6 = v85;
                  *v7 = -1;
                }
                else
                {
                  v87 = (unsigned __int16)*v7;
                  v88 = v86 ^ 0xFFFF;
                  *v6 = v85
                      + ((v88 * (unsigned __int16)*v6 + ((v88 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                  *v7 = ((v88 * v87 + ((v88 * v87) >> 16) + 1) >> 16) + HIWORD(v85);
                }
              }
            }
            else if (v86)
            {
              if (v86 == 0xFFFF)
                *v6 = v85;
              else
                *v6 = v85
                    + (((v86 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v86 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
            }
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v78;
          }
          while (v78);
        }
      }
      v6 += v92;
      v12 += v91;
      v7 += v94;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t w16_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  _WORD *v7;
  _WORD *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  uint64_t v17;
  uint64_t result;
  unsigned int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unsigned int *v30;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  unsigned int *v56;
  unsigned int v57;
  char v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int *v61;
  unsigned int *v62;
  unsigned int v63;
  unsigned int *v64;
  int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int *v69;
  int v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  int v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t *v81;
  unsigned int *v82;
  int v83;
  char *v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int *v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  int v92;
  int v93;
  unsigned int v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int *v98;
  unsigned int v99;
  int v100;
  unsigned int v101;
  int v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  char v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (_WORD *)*((_QWORD *)a2 + 2);
  v8 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v8)
    v120 = *((_QWORD *)a2 + 5) - a5;
  else
    v120 = 0;
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = a2[1];
  v119 = *a2;
  v118 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v117 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v117 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  v17 = *(_QWORD *)(a1 + 176);
  result = 2 * (v8 != 0);
  if (v17)
  {
    v114 = *((_QWORD *)a2 + 13);
    v112 = ~(-1 << v13);
    v113 = *((_QWORD *)a2 + 15);
    v111 = v13 - 4;
    v19 = (unsigned int *)(v16 - 4);
    v20 = v9 ^ 0xFFFF;
    v110 = a5;
    v109 = v11 + 16 * a3 + 8;
    v115 = *((_QWORD *)a2 + 9);
    v116 = a5;
    while (1)
    {
      if (((v113 - v14) | (v14 - v114)) < 0)
      {
        v23 = 0;
        v22 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)v112) >> v111) & 0xF;
        v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        v23 = weights_19497[v21] & 0xF;
      }
      v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v119 != 1)
        break;
      if (a5 >= 1)
      {
        v25 = (uint64_t *)v109;
        v26 = v110;
        while (1)
        {
          v28 = *(v25 - 1);
          v27 = *v25;
          v29 = &v24[v28];
          if (v19 >= (unsigned int *)&v24[v28])
            v30 = (unsigned int *)&v24[v28];
          else
            v30 = v19;
          if (v30 < v15)
            v30 = v15;
          v31 = bswap32(*v30);
          v32 = v27 & 0xF;
          if ((v27 & 0xF) != 0)
            break;
          if (v23)
          {
            v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22])
              v43 = v19;
            if (v43 < v15)
              v43 = v15;
            v44 = BLEND8_19499[v23];
            v41 = v31 - ((v44 & v31) >> v23);
            v42 = (bswap32(*v43) & v44) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          v45 = __ROL4__(v31, v10);
          v46 = v45 | v6;
          v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          v48 = 32 * v47;
          v47 >>= 6;
          v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v50 = v49;
          *v7 = v50;
          if (v8)
            *v8 = HIWORD(v50);
          v25 += 2;
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          if (!--v26)
            goto LABEL_96;
        }
        v33 = (unsigned int *)&v29[v27 >> 4];
        if (v19 < v33)
          v33 = v19;
        if (v33 < v15)
          v33 = v15;
        v34 = bswap32(*v33);
        if (v23)
        {
          v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35)
            v36 = v35;
          else
            v36 = v19;
          if (v36 < v15)
            v36 = v15;
          v37 = bswap32(*v36);
          v38 = (unsigned int *)((char *)v35 + (v27 >> 4));
          if (v19 < v38)
            v38 = v19;
          if (v38 < v15)
            v38 = v15;
          v39 = BLEND8_19499[v23];
          v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          v34 = v34 - ((v39 & v34) >> v23) + ((bswap32(*v38) & v39) >> v23);
        }
        v40 = BLEND8_19499[*v25 & 0xF];
        v41 = v31 - ((v40 & v31) >> v32);
        v42 = (v40 & v34) >> v32;
LABEL_46:
        v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v118;
      a5 = v116;
      v14 += v117;
      v8 += v120;
      --a6;
      LOBYTE(v13) = v115;
      if (!a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_96;
    v52 = (uint64_t *)v109;
    v51 = v110;
    while (1)
    {
      v54 = *(v52 - 1);
      v53 = *v52;
      v55 = &v24[v54];
      if (v19 >= (unsigned int *)&v24[v54])
        v56 = (unsigned int *)&v24[v54];
      else
        v56 = v19;
      if (v56 < v15)
        v56 = v15;
      v57 = bswap32(*v56);
      v58 = v53 & 0xF;
      if ((v53 & 0xF) != 0)
        break;
      if (v23)
      {
        v69 = (unsigned int *)&v55[v22];
        if (v19 < (unsigned int *)&v55[v22])
          v69 = v19;
        if (v69 < v15)
          v69 = v15;
        v70 = BLEND8_19499[v23];
        v67 = v57 - ((v70 & v57) >> v23);
        v68 = (bswap32(*v69) & v70) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      v71 = __ROL4__(v57, v10);
      v72 = v71 | v6;
      v73 = ((v71 >> 23) & 0x1FE) + BYTE1(v71) + (((v71 >> 8) & 0xFF00) >> 6) + (((v71 >> 8) & 0xFF00) >> 8);
      v74 = 32 * v73;
      v73 >>= 6;
      v75 = v73 | (v72 << 24) | (v72 << 16) | v74;
      v76 = ((v74 | v73) - (((v74 | v73) * v20 + (((v74 | v73) * v20) >> 16) + 1) >> 16)) | (((v72 | (v72 << 8))
                                                                                            - (((v72 | (v72 << 8))
                                                                                              * v20
                                                                                              + (((v72 | (v72 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF)
        v76 = v75;
      v77 = HIWORD(v76);
      if (v8)
      {
        if (v77)
        {
          if (v77 == 0xFFFF)
          {
            *v7 = v76;
            *v8 = -1;
          }
          else
          {
            v78 = v77 ^ 0xFFFF;
            v79 = v78 * (unsigned __int16)*v7;
            v80 = (v78 * (unsigned __int16)*v8 + ((v78 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
            *v7 = v76 + ((v79 + HIWORD(v79) + 1) >> 16);
            *v8 = v80 + HIWORD(v76);
          }
        }
      }
      else if (v77)
      {
        if (v77 != 0xFFFF)
          v76 += ((v77 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v77 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
        *v7 = v76;
      }
      v52 += 2;
      ++v7;
      v8 = (_WORD *)((char *)v8 + result);
      if (!--v51)
        goto LABEL_96;
    }
    v59 = (unsigned int *)&v55[v53 >> 4];
    if (v19 < v59)
      v59 = v19;
    if (v59 < v15)
      v59 = v15;
    v60 = bswap32(*v59);
    if (v23)
    {
      v61 = (unsigned int *)&v55[v22];
      if (v19 >= v61)
        v62 = v61;
      else
        v62 = v19;
      if (v62 < v15)
        v62 = v15;
      v63 = bswap32(*v62);
      v64 = (unsigned int *)((char *)v61 + (v53 >> 4));
      if (v19 < v64)
        v64 = v19;
      if (v64 < v15)
        v64 = v15;
      v65 = BLEND8_19499[v23];
      v57 = v57 - ((v65 & v57) >> v23) + ((v65 & v63) >> v23);
      v60 = v60 - ((v65 & v60) >> v23) + ((bswap32(*v64) & v65) >> v23);
    }
    v66 = BLEND8_19499[*v52 & 0xF];
    v67 = v57 - ((v66 & v57) >> v58);
    v68 = (v66 & v60) >> v58;
LABEL_83:
    v57 = v67 + v68;
    goto LABEL_84;
  }
  v81 = (uint64_t *)(v11 + 16 * a3);
  v82 = (unsigned int *)(v16 - 4);
  v83 = v9 ^ 0xFFFF;
  do
  {
    v84 = (char *)v15 + (v14 >> v13) * v12;
    if (v119 == 1)
    {
      if (a5 >= 1)
      {
        v85 = v81;
        v86 = a5;
        do
        {
          v87 = *v85;
          v85 += 2;
          v88 = (unsigned int *)&v84[v87];
          if (v82 < (unsigned int *)&v84[v87])
            v88 = v82;
          if (v88 < v15)
            v88 = v15;
          v89 = __ROL4__(bswap32(*v88), v10);
          v90 = v89 | v6;
          v91 = ((v89 >> 23) & 0x1FE) + BYTE1(v89) + (((v89 >> 8) & 0xFF00) >> 6) + (((v89 >> 8) & 0xFF00) >> 8);
          v92 = 32 * v91;
          v91 >>= 6;
          v93 = v91 | (v90 << 24) | (v90 << 16) | v92;
          v94 = ((v92 | v91) - (((v92 | v91) * v83 + (((v92 | v91) * v83) >> 16) + 1) >> 16)) | (((v90 | (v90 << 8))
                                                                                                - (((v90 | (v90 << 8)) * v83
                                                                                                  + (((v90 | (v90 << 8)) * v83) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v94 = v93;
          *v7 = v94;
          if (v8)
            *v8 = HIWORD(v94);
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v86;
        }
        while (v86);
      }
    }
    else
    {
      v95 = v81;
      v96 = a5;
      if (a5 >= 1)
      {
        do
        {
          v97 = *v95;
          v95 += 2;
          v98 = (unsigned int *)&v84[v97];
          if (v82 < (unsigned int *)&v84[v97])
            v98 = v82;
          if (v98 < v15)
            v98 = v15;
          v99 = __ROL4__(bswap32(*v98), v10);
          v100 = v99 | v6;
          v101 = ((v99 >> 23) & 0x1FE) + BYTE1(v99) + (((v99 >> 8) & 0xFF00) >> 6) + (((v99 >> 8) & 0xFF00) >> 8);
          v102 = 32 * v101;
          v101 >>= 6;
          v103 = v101 | (v100 << 24) | (v100 << 16) | v102;
          v104 = ((v102 | v101) - (((v102 | v101) * v83 + (((v102 | v101) * v83) >> 16) + 1) >> 16)) | (((v100 | (v100 << 8)) - (((v100 | (v100 << 8)) * v83 + (((v100 | (v100 << 8)) * v83) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v104 = v103;
          v105 = HIWORD(v104);
          if (v8)
          {
            if (v105)
            {
              if (v105 == 0xFFFF)
              {
                *v7 = v104;
                *v8 = -1;
              }
              else
              {
                v106 = v105 ^ 0xFFFF;
                v107 = v106 * (unsigned __int16)*v7;
                v108 = (v106 * (unsigned __int16)*v8 + ((v106 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
                *v7 = v104 + ((v107 + HIWORD(v107) + 1) >> 16);
                *v8 = v108 + HIWORD(v104);
              }
            }
          }
          else if (v105)
          {
            if (v105 != 0xFFFF)
              v104 += ((v105 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v105 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
            *v7 = v104;
          }
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v96;
        }
        while (v96);
      }
    }
    v7 += v118;
    v14 += v117;
    v8 += v120;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t w16_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  _WORD *v7;
  _WORD *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  uint64_t v17;
  uint64_t result;
  unsigned int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unsigned int *v30;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  unsigned int *v56;
  unsigned int v57;
  char v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int *v61;
  unsigned int *v62;
  unsigned int v63;
  unsigned int *v64;
  int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int *v69;
  int v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  int v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t *v81;
  char *v82;
  int v83;
  char *v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int *v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  int v92;
  int v93;
  unsigned int v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int *v98;
  unsigned int v99;
  int v100;
  unsigned int v101;
  int v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  char v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (_WORD *)*((_QWORD *)a2 + 2);
  v8 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v8)
    v120 = *((_QWORD *)a2 + 5) - a5;
  else
    v120 = 0;
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = a2[1];
  v119 = *a2;
  v118 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v117 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v117 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  v17 = *(_QWORD *)(a1 + 176);
  result = 2 * (v8 != 0);
  if (v17)
  {
    v114 = *((_QWORD *)a2 + 13);
    v112 = ~(-1 << v13);
    v113 = *((_QWORD *)a2 + 15);
    v111 = v13 - 4;
    v19 = (unsigned int *)(v16 - 4);
    v20 = v9 ^ 0xFFFF;
    v110 = a5;
    v109 = v11 + 16 * a3 + 8;
    v115 = *((_QWORD *)a2 + 9);
    v116 = a5;
    while (1)
    {
      if (((v113 - v14) | (v14 - v114)) < 0)
      {
        v23 = 0;
        v22 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)v112) >> v111) & 0xF;
        v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        v23 = weights_19497[v21] & 0xF;
      }
      v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v119 != 1)
        break;
      if (a5 >= 1)
      {
        v25 = (uint64_t *)v109;
        v26 = v110;
        while (1)
        {
          v28 = *(v25 - 1);
          v27 = *v25;
          v29 = &v24[v28];
          if (v19 >= (unsigned int *)&v24[v28])
            v30 = (unsigned int *)&v24[v28];
          else
            v30 = v19;
          if (v30 < v15)
            v30 = v15;
          v31 = *v30;
          v32 = v27 & 0xF;
          if ((v27 & 0xF) != 0)
            break;
          if (v23)
          {
            v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22])
              v43 = v19;
            if (v43 < v15)
              v43 = v15;
            v44 = BLEND8_19499[v23];
            v41 = v31 - ((v44 & v31) >> v23);
            v42 = (v44 & *v43) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          v45 = __ROL4__(v31, v10);
          v46 = v45 | v6;
          v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          v48 = 32 * v47;
          v47 >>= 6;
          v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v50 = v49;
          *v7 = v50;
          if (v8)
            *v8 = HIWORD(v50);
          v25 += 2;
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          if (!--v26)
            goto LABEL_96;
        }
        v33 = (unsigned int *)&v29[v27 >> 4];
        if (v19 < v33)
          v33 = v19;
        if (v33 < v15)
          v33 = v15;
        v34 = *v33;
        if (v23)
        {
          v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35)
            v36 = v35;
          else
            v36 = v19;
          if (v36 < v15)
            v36 = v15;
          v37 = *v36;
          v38 = (unsigned int *)((char *)v35 + (v27 >> 4));
          if (v19 < v38)
            v38 = v19;
          if (v38 < v15)
            v38 = v15;
          v39 = BLEND8_19499[v23];
          v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
        }
        v40 = BLEND8_19499[*v25 & 0xF];
        v41 = v31 - ((v40 & v31) >> v32);
        v42 = (v40 & v34) >> v32;
LABEL_46:
        v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v118;
      a5 = v116;
      v14 += v117;
      v8 += v120;
      --a6;
      LOBYTE(v13) = v115;
      if (!a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_96;
    v52 = (uint64_t *)v109;
    v51 = v110;
    while (1)
    {
      v54 = *(v52 - 1);
      v53 = *v52;
      v55 = &v24[v54];
      if (v19 >= (unsigned int *)&v24[v54])
        v56 = (unsigned int *)&v24[v54];
      else
        v56 = v19;
      if (v56 < v15)
        v56 = v15;
      v57 = *v56;
      v58 = v53 & 0xF;
      if ((v53 & 0xF) != 0)
        break;
      if (v23)
      {
        v69 = (unsigned int *)&v55[v22];
        if (v19 < (unsigned int *)&v55[v22])
          v69 = v19;
        if (v69 < v15)
          v69 = v15;
        v70 = BLEND8_19499[v23];
        v67 = v57 - ((v70 & v57) >> v23);
        v68 = (v70 & *v69) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      v71 = __ROL4__(v57, v10);
      v72 = v71 | v6;
      v73 = ((v71 >> 23) & 0x1FE) + BYTE1(v71) + (((v71 >> 8) & 0xFF00) >> 6) + (((v71 >> 8) & 0xFF00) >> 8);
      v74 = 32 * v73;
      v73 >>= 6;
      v75 = v73 | (v72 << 24) | (v72 << 16) | v74;
      v76 = ((v74 | v73) - (((v74 | v73) * v20 + (((v74 | v73) * v20) >> 16) + 1) >> 16)) | (((v72 | (v72 << 8))
                                                                                            - (((v72 | (v72 << 8))
                                                                                              * v20
                                                                                              + (((v72 | (v72 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF)
        v76 = v75;
      v77 = HIWORD(v76);
      if (v8)
      {
        if (v77)
        {
          if (v77 == 0xFFFF)
          {
            *v7 = v76;
            *v8 = -1;
          }
          else
          {
            v78 = v77 ^ 0xFFFF;
            v79 = v78 * (unsigned __int16)*v7;
            v80 = (v78 * (unsigned __int16)*v8 + ((v78 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
            *v7 = v76 + ((v79 + HIWORD(v79) + 1) >> 16);
            *v8 = v80 + HIWORD(v76);
          }
        }
      }
      else if (v77)
      {
        if (v77 != 0xFFFF)
          v76 += ((v77 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v77 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
        *v7 = v76;
      }
      v52 += 2;
      ++v7;
      v8 = (_WORD *)((char *)v8 + result);
      if (!--v51)
        goto LABEL_96;
    }
    v59 = (unsigned int *)&v55[v53 >> 4];
    if (v19 < v59)
      v59 = v19;
    if (v59 < v15)
      v59 = v15;
    v60 = *v59;
    if (v23)
    {
      v61 = (unsigned int *)&v55[v22];
      if (v19 >= v61)
        v62 = v61;
      else
        v62 = v19;
      if (v62 < v15)
        v62 = v15;
      v63 = *v62;
      v64 = (unsigned int *)((char *)v61 + (v53 >> 4));
      if (v19 < v64)
        v64 = v19;
      if (v64 < v15)
        v64 = v15;
      v65 = BLEND8_19499[v23];
      v57 = v57 - ((v65 & v57) >> v23) + ((v65 & v63) >> v23);
      v60 = v60 - ((v65 & v60) >> v23) + ((v65 & *v64) >> v23);
    }
    v66 = BLEND8_19499[*v52 & 0xF];
    v67 = v57 - ((v66 & v57) >> v58);
    v68 = (v66 & v60) >> v58;
LABEL_83:
    v57 = v67 + v68;
    goto LABEL_84;
  }
  v81 = (uint64_t *)(v11 + 16 * a3);
  v82 = v16 - 4;
  v83 = v9 ^ 0xFFFF;
  do
  {
    v84 = (char *)v15 + (v14 >> v13) * v12;
    if (v119 == 1)
    {
      if (a5 >= 1)
      {
        v85 = v81;
        v86 = a5;
        do
        {
          v87 = *v85;
          v85 += 2;
          v88 = (unsigned int *)&v84[v87];
          if (v82 < &v84[v87])
            v88 = (unsigned int *)v82;
          if (v88 < v15)
            v88 = v15;
          v89 = __ROL4__(*v88, v10);
          v90 = v89 | v6;
          v91 = ((v89 >> 23) & 0x1FE) + BYTE1(v89) + (((v89 >> 8) & 0xFF00) >> 6) + (((v89 >> 8) & 0xFF00) >> 8);
          v92 = 32 * v91;
          v91 >>= 6;
          v93 = v91 | (v90 << 24) | (v90 << 16) | v92;
          v94 = ((v92 | v91) - (((v92 | v91) * v83 + (((v92 | v91) * v83) >> 16) + 1) >> 16)) | (((v90 | (v90 << 8))
                                                                                                - (((v90 | (v90 << 8)) * v83
                                                                                                  + (((v90 | (v90 << 8)) * v83) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v94 = v93;
          *v7 = v94;
          if (v8)
            *v8 = HIWORD(v94);
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v86;
        }
        while (v86);
      }
    }
    else
    {
      v95 = v81;
      v96 = a5;
      if (a5 >= 1)
      {
        do
        {
          v97 = *v95;
          v95 += 2;
          v98 = (unsigned int *)&v84[v97];
          if (v82 < &v84[v97])
            v98 = (unsigned int *)v82;
          if (v98 < v15)
            v98 = v15;
          v99 = __ROL4__(*v98, v10);
          v100 = v99 | v6;
          v101 = ((v99 >> 23) & 0x1FE) + BYTE1(v99) + (((v99 >> 8) & 0xFF00) >> 6) + (((v99 >> 8) & 0xFF00) >> 8);
          v102 = 32 * v101;
          v101 >>= 6;
          v103 = v101 | (v100 << 24) | (v100 << 16) | v102;
          v104 = ((v102 | v101) - (((v102 | v101) * v83 + (((v102 | v101) * v83) >> 16) + 1) >> 16)) | (((v100 | (v100 << 8)) - (((v100 | (v100 << 8)) * v83 + (((v100 | (v100 << 8)) * v83) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v104 = v103;
          v105 = HIWORD(v104);
          if (v8)
          {
            if (v105)
            {
              if (v105 == 0xFFFF)
              {
                *v7 = v104;
                *v8 = -1;
              }
              else
              {
                v106 = v105 ^ 0xFFFF;
                v107 = v106 * (unsigned __int16)*v7;
                v108 = (v106 * (unsigned __int16)*v8 + ((v106 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
                *v7 = v104 + ((v107 + HIWORD(v107) + 1) >> 16);
                *v8 = v108 + HIWORD(v104);
              }
            }
          }
          else if (v105)
          {
            if (v105 != 0xFFFF)
              v104 += ((v105 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v105 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
            *v7 = v104;
          }
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v96;
        }
        while (v96);
      }
    }
    v7 += v118;
    v14 += v117;
    v8 += v120;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t w16_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned int v5;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  char *v16;
  unsigned int v17;
  unint64_t result;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int8x16_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned __int16 *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unsigned int v42;
  int v43;
  int16x4_t *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unsigned int *v63;
  uint64_t v64;
  int16x4_t *v65;
  unsigned __int16 *v66;
  char v67;
  int v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  unsigned int *v74;
  uint64_t v75;
  int16x4_t *v76;
  unsigned __int16 *v77;
  char v78;
  int v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  uint64_t v83;
  int v84;
  int v85;
  unsigned int v86;
  unsigned int v87;
  int v88;
  int v89;
  unsigned int v90;
  uint64_t v91;
  int v92;
  int v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  int v100;
  int v101;
  unsigned int v102;
  int v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  int v111;
  int v112;
  uint64_t v113;
  int v114;
  int v115;
  int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  unsigned int v124;
  int v125;
  int v126;
  int v127;
  uint64_t v128;
  int v129;
  int v130;
  unsigned int v131;
  int v132;
  int v133;
  int v134;
  unsigned int v135;
  uint64_t v136;
  int v137;
  unsigned int v138;
  int v139;
  unsigned __int16 v140;
  uint64_t v141;
  int v142;
  unsigned int v143;
  int v144;
  int v145;
  uint64_t v146;
  int v147;
  unsigned int v148;
  int v149;
  int v150;
  unsigned int v151;
  uint64_t v152;
  int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  uint64_t v157;
  int v158;
  unint64_t v159;
  unint64_t v160;
  unsigned int v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  int64_t v165;
  uint64_t v166;
  int v167;
  unint64_t v168;
  unint64_t v169;
  unsigned int v170;
  unint64_t v171;
  unint64_t v172;
  int64_t v173;
  uint64_t v174;
  int v175;
  unsigned int v176;
  uint64_t v177;
  int v178;
  unsigned int v179;
  uint64_t v180;
  int v181;
  unsigned int v182;
  uint64_t v183;
  int v184;
  unsigned int v185;
  uint64_t v186;
  int v187;
  unsigned int v188;
  uint64_t v189;
  int v190;
  unsigned int v191;
  uint64_t v192;
  int v193;
  unsigned int v194;
  uint64_t v195;
  int v196;
  unsigned int v197;
  uint64_t v198;
  int v199;
  unint64_t v200;
  unint64_t v201;
  unsigned int v202;
  uint64_t v203;
  uint64_t v204;
  int64_t v205;
  unint64_t v206;
  unint64_t v207;
  int64_t v208;
  uint64_t v209;
  int v210;
  unsigned int v211;
  uint64_t v212;
  int v213;
  unsigned int v214;
  uint64_t v215;
  int v216;
  unsigned int v217;
  uint64_t v218;
  int v219;
  uint64_t v220;
  unint64_t v221;
  unsigned __int16 v222;
  unint64_t v223;
  int v224;
  char v225;
  unsigned int *v226;
  int16x4_t *v227;
  int v228;
  int v229;
  unsigned int v230;
  unsigned int v231;
  int v232;
  char v233;
  unsigned int *v234;
  int16x4_t *v235;
  int v236;
  int v237;
  unsigned int v238;
  unsigned int v239;
  int v240;
  unsigned int v241;
  int v242;
  uint64_t v243;
  uint64_t v244;
  unint64_t v245;
  int v246;
  unsigned int v247;
  int v248;
  unsigned int v249;
  unsigned int v250;
  unsigned int v251;
  int v252;
  int v253;
  unsigned int v254;
  unsigned int v255;
  int v256;
  unsigned int v257;
  unsigned int v258;
  unsigned int v259;
  unsigned int v260;
  int v261;
  int v262;
  unsigned int v263;
  int v264;
  int v265;
  unsigned int v266;
  unsigned int v267;
  int v268;
  uint64_t v269;
  unint64_t v270;
  int v271;
  unint64_t v272;
  unsigned int v273;
  int v274;
  unsigned int v275;
  unsigned int v276;
  unsigned int v277;
  unsigned int v278;
  int v279;
  int v280;
  int v281;
  int v282;
  unsigned int v283;
  unsigned int v284;
  unsigned int v285;
  int v286;
  unsigned int v287;
  unsigned int v288;
  unsigned int v289;
  int v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  int v294;
  unsigned int v295;
  unsigned int v296;
  unsigned int v297;
  int v298;
  uint64_t v299;
  unint64_t v300;
  int16x4_t v301;
  unint64_t v302;
  unsigned int v303;
  unint64_t v304;
  unsigned int v305;
  unsigned int v306;
  unsigned int v307;
  unsigned int v308;
  unsigned int v309;
  unsigned int v310;
  uint64_t v311;
  int v312;
  int v313;
  unint64_t v314;
  unsigned int v315;
  unsigned int v316;
  unsigned int v317;
  int v318;
  int v319;
  unsigned int v320;
  int v321;
  int v322;
  unint64_t v323;
  uint64_t v324;
  uint64_t v325;
  unint64_t v326;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned __int16 **)(a1 + 96);
  v5 = **(unsigned __int16 **)(a1 + 88);
  if (v4)
    v7 = *v4 << 16;
  else
    v7 = -65536;
  v9 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 136);
  v11 = v7 | v5;
  v323 = *(int *)(a1 + 28);
  v325 = *(_QWORD *)(a1 + 40);
  pthread_mutex_lock(&w16_cacheColorLock);
  v12 = w16_cacheColor;
  v322 = v9;
  if (!w16_cacheColor || *(_DWORD *)(w16_cacheColor + 16) != v11)
  {
    v13 = 0;
    while (1)
    {
      if (!v12)
        goto LABEL_11;
      v14 = v12;
      v15 = v13;
      if (*(_DWORD *)(v12 + 16) == v11)
        break;
      v12 = *(_QWORD *)v12;
      v13 = (_QWORD *)v14;
      if (!*(_QWORD *)v14)
      {
        if (w16_cacheColorCount > 6)
        {
          *v15 = 0;
          v20 = a2;
        }
        else
        {
LABEL_11:
          v16 = (char *)w16_cacheColorBase;
          if (w16_cacheColorBase)
          {
            v17 = w16_cacheColorCount;
          }
          else
          {
            v16 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            v17 = 0;
            w16_cacheColorBase = (uint64_t)v16;
          }
          v20 = a2;
          v14 = (uint64_t)&v16[24 * v17];
          *(_QWORD *)(v14 + 8) = &v16[1024 * (unint64_t)v17 + 168];
          w16_cacheColorCount = v17 + 1;
        }
        v21 = 0;
        *(_QWORD *)v14 = w16_cacheColor;
        w16_cacheColor = v14;
        *(_DWORD *)(v14 + 16) = v11;
        v23 = *(_QWORD *)(v14 + 8);
        v19 = v14 + 8;
        v22 = v23;
        v24 = vdupq_n_s32(v5);
        v25 = vdupq_n_s32(HIWORD(v7));
        v26 = (int32x4_t)xmmword_185004DC0;
        v27 = vdupq_n_s32(0x101u);
        v28.i64[0] = 0xFFFF0000FFFFLL;
        v28.i64[1] = 0xFFFF0000FFFFLL;
        v29.i64[0] = 0x400000004;
        v29.i64[1] = 0x400000004;
        do
        {
          v30 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v26, v27), v28);
          v31 = (int8x16_t)vmulq_s32(v30, v24);
          v32 = (int8x16_t)vmulq_s32(v30, v25);
          *(int8x16_t *)(v22 + v21) = vorrq_s8((int8x16_t)vshlq_n_s32(vsubq_s32(v25, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x10uLL), (int32x4_t)vmvnq_s8(v32)), 0x10uLL)), 0x10uLL), (int8x16_t)vsubq_s32(v24, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v31, 0x10uLL), (int32x4_t)vmvnq_s8(v31)),
                                                                  0x10uLL)));
          v26 = vaddq_s32(v26, v29);
          v21 += 16;
        }
        while (v21 != 1024);
        result = pthread_mutex_unlock(&w16_cacheColorLock);
        goto LABEL_22;
      }
    }
    if (v13)
    {
      *v13 = *(_QWORD *)v12;
      *(_QWORD *)v12 = w16_cacheColor;
      w16_cacheColor = v12;
    }
  }
  result = pthread_mutex_unlock(&w16_cacheColorLock);
  v19 = v12 + 8;
  v20 = a2;
LABEL_22:
  v33 = *(_QWORD *)v19;
  v34 = *(_DWORD *)(*(_QWORD *)v19 + 1020);
  v36 = *(int *)(a1 + 12);
  v35 = *(int *)(a1 + 16);
  if (v3)
  {
    v37 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v38 = (unsigned __int16 *)(v3 + 2 * (v36 + v37 * v35));
    v39 = 1;
  }
  else
  {
    v38 = 0;
    v37 = 0;
    v39 = 0;
  }
  if (v10)
  {
    v40 = v37 - v322;
    if (v3)
      v41 = v37 - v322;
    else
      v41 = v37;
    v43 = v20;
    v42 = HIWORD(v34);
    v44 = (int16x4_t *)(v325 + 2 * (v36 + (v323 >> 1) * v35));
    v45 = *(int *)(a1 + 124);
    v46 = v10 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v45;
    v47 = v45 - v322;
    v48 = (v323 >> 1) - v322;
    v324 = v47;
    v326 = v48;
    v49 = v41;
    switch(v43)
    {
      case 0:
        if (v3)
        {
          v50 = 2 * v39;
          do
          {
            v51 = v322;
            do
            {
              v52 = *(unsigned __int8 *)v46;
              if (*(_BYTE *)v46)
              {
                if (v52 == 255)
                {
                  LOWORD(v53) = 0;
                  v44->i16[0] = 0;
                }
                else
                {
                  v54 = *v38;
                  v55 = (v52 ^ 0xFF | ((v52 ^ 0xFF) << 8)) ^ 0xFFFF;
                  v44->i16[0] -= (v55 * v44->u16[0] + ((v55 * v44->u16[0]) >> 16) + 1) >> 16;
                  v53 = v54 - ((v55 * v54 + ((v55 * v54) >> 16) + 1) >> 16);
                }
                *v38 = v53;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              v38 = (unsigned __int16 *)((char *)v38 + v50);
              --v51;
            }
            while (v51);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            v38 += v41;
            --v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v56 = v322;
            do
            {
              v57 = *(unsigned __int8 *)v46;
              if (*(_BYTE *)v46)
              {
                if (v57 == 255)
                {
                  LOWORD(v58) = 0;
                }
                else
                {
                  v59 = v44->u16[0];
                  v60 = ((v57 ^ 0xFF | ((v57 ^ 0xFF) << 8)) ^ 0xFFFF) * v59;
                  v58 = v59 - ((v60 + HIWORD(v60) + 1) >> 16);
                }
                v44->i16[0] = v58;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              --v56;
            }
            while (v56);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            --v8;
          }
          while (v8);
        }
        return result;
      case 1:
        v61 = v46 & 3;
        if (!v3)
        {
          v224 = -1 << (8 * v61);
          if ((v46 & 3) != 0)
            v225 = v46 & 0xFC;
          else
            v225 = v46;
          if ((v46 & 3) != 0)
          {
            v226 = (unsigned int *)(v46 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            v224 = -1;
            v226 = (unsigned int *)v46;
          }
          if ((v46 & 3) != 0)
            v227 = (int16x4_t *)((char *)v44 - 2 * (v46 & 3));
          else
            v227 = v44;
          if ((v46 & 3) != 0)
            v228 = v61 + v322;
          else
            v228 = v322;
          if ((((_BYTE)v228 + v225) & 3) != 0)
          {
            v229 = 4 - (((_BYTE)v228 + v225) & 3);
            v61 += v229;
            v230 = 0xFFFFFFFF >> (8 * v229);
            if (v228 >= 4)
              v231 = v230;
            else
              v231 = 0;
            if (v228 >= 4)
              v230 = -1;
            v224 &= v230;
          }
          else
          {
            v231 = 0;
          }
          v299 = v47 - v61;
          v300 = (v228 >> 2);
          v301 = vdup_n_s16(v34);
          v302 = v48 - v61;
          while (1)
          {
            v303 = *v226 & v224;
            v304 = v300;
            v305 = v231;
            if (!v303)
              goto LABEL_532;
LABEL_514:
            if (v303 == -1)
            {
              *v227 = v301;
              goto LABEL_532;
            }
            while (1)
            {
              if ((_BYTE)v303)
              {
                LOWORD(v306) = v34;
                if (v303 != 255)
                {
                  v307 = v227->u16[0] * ((v303 | (v303 << 8)) ^ 0xFFFF);
                  v306 = *(_DWORD *)(v33 + 4 * v303) + ((v307 + HIWORD(v307) + 1) >> 16);
                }
                v227->i16[0] = v306;
              }
              if (BYTE1(v303))
              {
                LOWORD(v308) = v34;
                if (BYTE1(v303) != 255)
                  v308 = *(_DWORD *)(v33 + 4 * BYTE1(v303))
                       + ((v227->u16[1] * ((BYTE1(v303) | (BYTE1(v303) << 8)) ^ 0xFFFF)
                         + ((v227->u16[1] * ((BYTE1(v303) | (BYTE1(v303) << 8)) ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                v227->i16[1] = v308;
              }
              if (BYTE2(v303))
              {
                LOWORD(v309) = v34;
                if (BYTE2(v303) != 255)
                  v309 = *(_DWORD *)(v33 + 4 * BYTE2(v303))
                       + ((v227->u16[2] * ((BYTE2(v303) | (BYTE2(v303) << 8)) ^ 0xFFFF)
                         + ((v227->u16[2] * ((BYTE2(v303) | (BYTE2(v303) << 8)) ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                v227->i16[2] = v309;
              }
              v310 = HIBYTE(v303);
              if (v310 == 255)
              {
                v227->i16[3] = v34;
              }
              else if (v310)
              {
                v227->i16[3] = *(_WORD *)(v33 + 4 * v310)
                             + ((((v310 | (v310 << 8)) ^ 0xFFFF) * v227->u16[3]
                               + ((((v310 | (v310 << 8)) ^ 0xFFFF) * v227->u16[3]) >> 16)
                               + 1) >> 16);
              }
LABEL_532:
              while (1)
              {
                result = v304;
                ++v227;
                v304 = (v304 - 1);
                ++v226;
                if ((int)result < 2)
                  break;
                v303 = *v226;
                if (*v226)
                  goto LABEL_514;
              }
              if (!v305)
                break;
              v305 = 0;
              v303 = *v226 & v231;
            }
            v226 = (unsigned int *)((char *)v226 + v299);
            v227 = (int16x4_t *)((char *)v227 + 2 * v302);
            if (!--v8)
              return result;
          }
        }
        v62 = -1 << (8 * v61);
        v63 = (unsigned int *)(v46 & 0xFFFFFFFFFFFFFFFCLL);
        v64 = 2 * (v46 & 3);
        v65 = (int16x4_t *)((char *)v44 - v64);
        v66 = &v38[v64 / 0xFFFFFFFFFFFFFFFELL];
        if ((v46 & 3) != 0)
          v67 = v46 & 0xFC;
        else
          v67 = v46;
        if ((v46 & 3) != 0)
        {
          v68 = v61 + v322;
        }
        else
        {
          v62 = -1;
          v63 = (unsigned int *)v46;
          v66 = v38;
          v65 = v44;
          v68 = v322;
        }
        if ((((_BYTE)v68 + v67) & 3) != 0)
        {
          v69 = 4 - (((_BYTE)v68 + v67) & 3);
          v61 += v69;
          v70 = 0xFFFFFFFF >> (8 * v69);
          if (v68 >= 4)
            v71 = v70;
          else
            v71 = 0;
          if (v68 >= 4)
            v70 = -1;
          v62 &= v70;
        }
        else
        {
          v71 = 0;
        }
        v244 = v47 - v61;
        v245 = v48 - v61;
        v246 = v68 >> 2;
        result = v40 - v61;
        do
        {
          v247 = *v63 & v62;
          v248 = v246;
          v249 = v71;
          if (!v247)
            goto LABEL_483;
LABEL_462:
          if (v247 == -1)
          {
            v65->i16[0] = v34;
            *v66 = HIWORD(v34);
            v65->i16[1] = v34;
            v66[1] = HIWORD(v34);
            v65->i16[2] = v34;
            v66[2] = HIWORD(v34);
LABEL_480:
            v65->i16[3] = v34;
            v66[3] = HIWORD(v34);
            goto LABEL_483;
          }
          while (1)
          {
            if ((_BYTE)v247)
            {
              if (v247 == 255)
              {
                v65->i16[0] = v34;
                v250 = HIWORD(v34);
              }
              else
              {
                v251 = *(_DWORD *)(v33 + 4 * v247);
                v252 = *v66;
                v253 = (v247 | (v247 << 8)) ^ 0xFFFF;
                v65->i16[0] = v251 + ((v65->u16[0] * v253 + ((v65->u16[0] * v253) >> 16) + 1) >> 16);
                v250 = ((v252 * v253 + ((v252 * v253) >> 16) + 1) >> 16) + HIWORD(v251);
              }
              *v66 = v250;
            }
            if (BYTE1(v247))
            {
              if (BYTE1(v247) == 255)
              {
                v65->i16[1] = v34;
                v254 = HIWORD(v34);
              }
              else
              {
                v255 = *(_DWORD *)(v33 + 4 * BYTE1(v247));
                v256 = (BYTE1(v247) | (BYTE1(v247) << 8)) ^ 0xFFFF;
                v257 = v65->u16[1] * v256;
                v258 = (v66[1] * v256 + ((v66[1] * v256) >> 16) + 1) >> 16;
                v65->i16[1] = v255 + ((v257 + HIWORD(v257) + 1) >> 16);
                v254 = v258 + HIWORD(v255);
              }
              v66[1] = v254;
            }
            if (BYTE2(v247))
            {
              if (BYTE2(v247) == 255)
              {
                v65->i16[2] = v34;
                v259 = HIWORD(v34);
              }
              else
              {
                v260 = *(_DWORD *)(v33 + 4 * BYTE2(v247));
                v261 = v66[2];
                v262 = (BYTE2(v247) | (BYTE2(v247) << 8)) ^ 0xFFFF;
                v65->i16[2] = v260 + ((v65->u16[2] * v262 + ((v65->u16[2] * v262) >> 16) + 1) >> 16);
                v259 = ((v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16) + HIWORD(v260);
              }
              v66[2] = v259;
            }
            v263 = HIBYTE(v247);
            if (v263 == 255)
              goto LABEL_480;
            if (v263)
            {
              v264 = v263 | (v263 << 8);
              v265 = *(_DWORD *)(v33 + 4 * v263);
              v264 ^= 0xFFFFu;
              v266 = v264 * v65->u16[3];
              v267 = (v264 * v66[3] + ((v264 * v66[3]) >> 16) + 1) >> 16;
              v65->i16[3] = v265 + ((v266 + HIWORD(v266) + 1) >> 16);
              v66[3] = v267 + HIWORD(v265);
            }
LABEL_483:
            while (1)
            {
              v268 = v248;
              ++v65;
              v66 += 4;
              --v248;
              ++v63;
              if (v268 < 2)
                break;
              v247 = *v63;
              if (*v63)
                goto LABEL_462;
            }
            if (!v249)
              break;
            v249 = 0;
            v247 = *v63 & v71;
          }
          v63 = (unsigned int *)((char *)v63 + v244);
          v65 = (int16x4_t *)((char *)v65 + 2 * v245);
          v66 += result;
          --v8;
        }
        while (v8);
        return result;
      case 2:
        v72 = v46 & 3;
        if (v3)
        {
          v73 = -1 << (8 * v72);
          v74 = (unsigned int *)(v46 & 0xFFFFFFFFFFFFFFFCLL);
          v75 = 2 * (v46 & 3);
          v76 = (int16x4_t *)((char *)v44 - v75);
          v77 = &v38[v75 / 0xFFFFFFFFFFFFFFFELL];
          if ((v46 & 3) != 0)
            v78 = v46 & 0xFC;
          else
            v78 = v46;
          if ((v46 & 3) != 0)
          {
            v79 = v72 + v322;
          }
          else
          {
            v73 = -1;
            v74 = (unsigned int *)v46;
            v77 = v38;
            v76 = v44;
            v79 = v322;
          }
          if ((((_BYTE)v79 + v78) & 3) != 0)
          {
            v80 = 4 - (((_BYTE)v79 + v78) & 3);
            v72 += v80;
            v81 = 0xFFFFFFFF >> (8 * v80);
            if (v79 >= 4)
              v82 = v81;
            else
              v82 = 0;
            if (v79 >= 4)
              v81 = -1;
            v73 &= v81;
          }
          else
          {
            v82 = 0;
          }
          v269 = v47 - v72;
          v270 = v48 - v72;
          v271 = v79 >> 2;
          result = (unsigned __int16)~HIWORD(v34);
          v272 = v40 - v72;
          while (1)
          {
            v273 = *v74 & v73;
            v274 = v271;
            v275 = v82;
            if (!v273)
              goto LABEL_504;
LABEL_493:
            if (v273 == -1)
              break;
            while (1)
            {
              if ((_BYTE)v273)
              {
                v285 = *(_DWORD *)(v33 + 4 * v273);
                v286 = HIWORD(v285) ^ 0xFFFF;
                v287 = v286 * v76->u16[0];
                v288 = (v286 * *v77 + ((v286 * *v77) >> 16) + 1) >> 16;
                v76->i16[0] = v285 + ((v287 + HIWORD(v287) + 1) >> 16);
                *v77 = v288 + HIWORD(v285);
              }
              if ((v273 & 0xFF00) != 0)
              {
                v289 = *(_DWORD *)(v33 + 4 * BYTE1(v273));
                v290 = HIWORD(v289) ^ 0xFFFF;
                v291 = v290 * v76->u16[1];
                v292 = (v290 * v77[1] + ((v290 * v77[1]) >> 16) + 1) >> 16;
                v76->i16[1] = v289 + ((v291 + HIWORD(v291) + 1) >> 16);
                v77[1] = v292 + HIWORD(v289);
              }
              if ((v273 & 0xFF0000) != 0)
              {
                v293 = *(_DWORD *)(v33 + 4 * BYTE2(v273));
                v294 = HIWORD(v293) ^ 0xFFFF;
                v295 = v294 * v76->u16[2];
                v296 = (v294 * v77[2] + ((v294 * v77[2]) >> 16) + 1) >> 16;
                v76->i16[2] = v293 + ((v295 + HIWORD(v295) + 1) >> 16);
                v77[2] = v296 + HIWORD(v293);
              }
              v297 = HIBYTE(v273);
              if (v297)
              {
                v283 = *(_DWORD *)(v33 + 4 * v297);
                v284 = HIWORD(v283);
                v281 = v76->u16[3];
                v282 = v77[3];
                v279 = HIWORD(v283) ^ 0xFFFF;
                v280 = v279;
                goto LABEL_503;
              }
LABEL_504:
              while (1)
              {
                v298 = v274;
                ++v76;
                v77 += 4;
                --v274;
                ++v74;
                if (v298 < 2)
                  break;
                v273 = *v74;
                if (*v74)
                  goto LABEL_493;
              }
              if (!v275)
                break;
              v275 = 0;
              v273 = *v74 & v82;
            }
            v74 = (unsigned int *)((char *)v74 + v269);
            v76 = (int16x4_t *)((char *)v76 + 2 * v270);
            v77 += v272;
            if (!--v8)
              return result;
          }
          v276 = (*v77 * (_DWORD)result + ((*v77 * result) >> 16) + 1) >> 16;
          v76->i16[0] = v34 + ((v76->u16[0] * (_DWORD)result + ((v76->u16[0] * result) >> 16) + 1) >> 16);
          *v77 = v276 + HIWORD(v34);
          v277 = (v77[1] * (_DWORD)result + ((v77[1] * result) >> 16) + 1) >> 16;
          v76->i16[1] = v34 + ((v76->u16[1] * (_DWORD)result + ((v76->u16[1] * result) >> 16) + 1) >> 16);
          v77[1] = v277 + HIWORD(v34);
          v278 = (v77[2] * (_DWORD)result + ((v77[2] * result) >> 16) + 1) >> 16;
          v76->i16[2] = v34 + ((v76->u16[2] * (_DWORD)result + ((v76->u16[2] * result) >> 16) + 1) >> 16);
          v77[2] = v278 + HIWORD(v34);
          v279 = v76->u16[3];
          v280 = v77[3];
          v281 = (unsigned __int16)~HIWORD(v34);
          v282 = v281;
          LOWORD(v283) = v34;
          v284 = HIWORD(v34);
LABEL_503:
          v76->i16[3] = v283 + ((v279 * v281 + ((v279 * v281) >> 16) + 1) >> 16);
          v77[3] = v284 + ((v280 * v282 + ((v280 * v282) >> 16) + 1) >> 16);
          goto LABEL_504;
        }
        v232 = -1 << (8 * v72);
        if ((v46 & 3) != 0)
          v233 = v46 & 0xFC;
        else
          v233 = v46;
        if ((v46 & 3) != 0)
        {
          v234 = (unsigned int *)(v46 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v232 = -1;
          v234 = (unsigned int *)v46;
        }
        if ((v46 & 3) != 0)
          v235 = (int16x4_t *)((char *)v44 - 2 * (v46 & 3));
        else
          v235 = v44;
        if ((v46 & 3) != 0)
          v236 = v72 + v322;
        else
          v236 = v322;
        if ((((_BYTE)v236 + v233) & 3) != 0)
        {
          v237 = 4 - (((_BYTE)v236 + v233) & 3);
          v72 += v237;
          v238 = 0xFFFFFFFF >> (8 * v237);
          if (v236 >= 4)
            v239 = -1;
          else
            v239 = 0xFFFFFFFF >> (8 * v237);
          v232 &= v239;
          if (v236 < 4)
            v238 = 0;
        }
        else
        {
          v238 = 0;
        }
        v311 = v47 - v72;
        v312 = v236 >> 2;
        v313 = (unsigned __int16)~HIWORD(v34);
        v314 = v48 - v72;
        while (1)
        {
          v315 = *v234 & v232;
          v316 = v238;
          LODWORD(result) = v312;
          if (!v315)
            goto LABEL_553;
LABEL_542:
          if (v315 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v315)
              v235->i16[0] = *(_WORD *)(v33 + 4 * v315)
                           + (((~*(_DWORD *)(v33 + 4 * v315) >> 16) * v235->u16[0]
                             + (((~*(_DWORD *)(v33 + 4 * v315) >> 16) * v235->u16[0]) >> 16)
                             + 1) >> 16);
            if ((v315 & 0xFF00) != 0)
              v235->i16[1] = *(_WORD *)(v33 + 4 * BYTE1(v315))
                           + (((~*(_DWORD *)(v33 + 4 * BYTE1(v315)) >> 16) * v235->u16[1]
                             + (((~*(_DWORD *)(v33 + 4 * BYTE1(v315)) >> 16) * v235->u16[1]) >> 16)
                             + 1) >> 16);
            if ((v315 & 0xFF0000) != 0)
              v235->i16[2] = *(_WORD *)(v33 + 4 * BYTE2(v315))
                           + (((~*(_DWORD *)(v33 + 4 * BYTE2(v315)) >> 16) * v235->u16[2]
                             + (((~*(_DWORD *)(v33 + 4 * BYTE2(v315)) >> 16) * v235->u16[2]) >> 16)
                             + 1) >> 16);
            v320 = HIBYTE(v315);
            if (v320)
            {
              v319 = *(_DWORD *)(v33 + 4 * v320);
              v318 = v235->u16[3];
              v317 = ~v319 >> 16;
              goto LABEL_552;
            }
LABEL_553:
            while (1)
            {
              v321 = result;
              ++v235;
              result = (result - 1);
              ++v234;
              if (v321 < 2)
                break;
              v315 = *v234;
              if (*v234)
                goto LABEL_542;
            }
            if (!v316)
              break;
            v316 = 0;
            v315 = *v234 & v238;
          }
          v234 = (unsigned int *)((char *)v234 + v311);
          v235 = (int16x4_t *)((char *)v235 + 2 * v314);
          if (!--v8)
            return result;
        }
        v235->i16[0] = v34 + ((v235->u16[0] * v313 + ((v235->u16[0] * v313) >> 16) + 1) >> 16);
        v235->i16[1] = v34 + ((v235->u16[1] * v313 + ((v235->u16[1] * v313) >> 16) + 1) >> 16);
        v235->i16[2] = v34 + ((v235->u16[2] * v313 + ((v235->u16[2] * v313) >> 16) + 1) >> 16);
        v317 = v235->u16[3];
        v318 = (unsigned __int16)~HIWORD(v34);
        LOWORD(v319) = v34;
LABEL_552:
        v235->i16[3] = v319 + ((v317 * v318 + ((v317 * v318) >> 16) + 1) >> 16);
        goto LABEL_553;
      case 3:
        v83 = 2 * v39;
        do
        {
          v84 = v322;
          do
          {
            v85 = *(unsigned __int8 *)v46;
            if (*(_BYTE *)v46)
            {
              if (v85 == 255)
              {
                v86 = *(_DWORD *)(v33 + (((unint64_t)*v38 >> 6) & 0x3FC));
                v44->i16[0] = v86;
                v87 = HIWORD(v86);
              }
              else
              {
                v88 = v85 | (v85 << 8);
                v89 = *v38;
                v90 = *(_DWORD *)(v33 + 4 * ((v89 * v88 + ((v89 * v88) >> 16) + 1) >> 24));
                v88 ^= 0xFFFFu;
                v44->i16[0] = v90 + ((v44->u16[0] * v88 + ((v44->u16[0] * v88) >> 16) + 1) >> 16);
                v87 = ((v89 * v88 + ((v89 * v88) >> 16) + 1) >> 16) + HIWORD(v90);
              }
              *v38 = v87;
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v83);
            --v84;
          }
          while (v84);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          --v8;
        }
        while (v8);
        return result;
      case 4:
        v91 = 2 * v39;
        do
        {
          v92 = v322;
          do
          {
            v93 = *(unsigned __int8 *)v46;
            if (*(_BYTE *)v46)
            {
              if (v93 == 255)
              {
                v94 = *(_DWORD *)(v33 + 4 * ((unsigned __int16)~*v38 >> 8));
                v44->i16[0] = v94;
                v95 = HIWORD(v94);
              }
              else
              {
                v96 = v93 | (v93 << 8);
                v97 = *v38;
                v98 = *(_DWORD *)(v33 + 4 * (((v97 ^ 0xFFFF) * v96 + (((v97 ^ 0xFFFFu) * v96) >> 16) + 1) >> 24));
                v96 ^= 0xFFFFu;
                v44->i16[0] = v98 + ((v44->u16[0] * v96 + ((v44->u16[0] * v96) >> 16) + 1) >> 16);
                v95 = ((v97 * v96 + ((v97 * v96) >> 16) + 1) >> 16) + HIWORD(v98);
              }
              *v38 = v95;
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v91);
            --v92;
          }
          while (v92);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          --v8;
        }
        while (v8);
        return result;
      case 5:
        v99 = 2 * v39;
        do
        {
          v100 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              v101 = *v38;
              v102 = *(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
              v103 = HIWORD(v102) ^ 0xFFFF;
              v44->i16[0] = ((unsigned __int16)v102 * v101
                           + v103 * v44->u16[0]
                           + (((unsigned __int16)v102 * v101 + v103 * v44->u16[0]) >> 16)
                           + 1) >> 16;
              *v38 = ((v103 + v101) * HIWORD(v102) + (((v103 + v101) * HIWORD(v102)) >> 16) + 1) >> 16;
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v99);
            --v100;
          }
          while (v100);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          --v8;
        }
        while (v8);
        return result;
      case 6:
        v104 = 2 * v39;
        do
        {
          v105 = v322;
          do
          {
            v106 = *(unsigned __int8 *)v46;
            if (*(_BYTE *)v46)
            {
              v107 = *v38;
              if ((_WORD)v107 != 0xFFFF)
              {
                if ((unsigned __int16)~(_WORD)v107 == 0xFFFF)
                {
                  v108 = *(_DWORD *)(v33 + 4 * v106);
                  v44->i16[0] = v108;
                  v109 = HIWORD(v108);
                }
                else
                {
                  v110 = *(_DWORD *)(v33 + 4 * v106);
                  v111 = (unsigned __int16)~(_WORD)v107;
                  v44->i16[0] += ((unsigned __int16)v110 * v111
                                + (((unsigned __int16)v110 * v111) >> 16)
                                + 1) >> 16;
                  v109 = v107 + ((HIWORD(v110) * v111 + ((HIWORD(v110) * v111) >> 16) + 1) >> 16);
                }
                *v38 = v109;
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v104);
            --v105;
          }
          while (v105);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          --v8;
        }
        while (v8);
        return result;
      case 7:
        v112 = v42 ^ 0xFFFF;
        if (v3)
        {
          v113 = 2 * v39;
          do
          {
            v114 = v322;
            do
            {
              v115 = *(unsigned __int8 *)v46;
              if (*(_BYTE *)v46)
              {
                if (v115 == 255)
                {
                  v116 = v44->u16[0];
                  v117 = *v38;
                  v118 = v112 * v116;
                  v119 = v112 * v117;
                }
                else
                {
                  v120 = v115 | (v115 << 8);
                  v116 = v44->u16[0];
                  v117 = *v38;
                  v121 = (unsigned __int16)(v120 - ((v42 * v120 + ((v42 * v120) >> 16) + 1) >> 16));
                  v118 = v116 * v121;
                  v119 = v117 * v121;
                }
                v44->i16[0] = v116 - ((v118 + HIWORD(v118) + 1) >> 16);
                *v38 = v117 - ((v119 + HIWORD(v119) + 1) >> 16);
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              v38 = (unsigned __int16 *)((char *)v38 + v113);
              --v114;
            }
            while (v114);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            v38 += v41;
            --v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v122 = v322;
            do
            {
              v123 = *(unsigned __int8 *)v46;
              if (*(_BYTE *)v46)
              {
                if (v123 == 255)
                {
                  LOWORD(v124) = v44->i16[0];
                  v125 = v42 ^ 0xFFFF;
                }
                else
                {
                  v126 = v123 | (v123 << 8);
                  v125 = v44->u16[0];
                  v124 = v126 - ((v42 * v126 + ((v42 * v126) >> 16) + 1) >> 16);
                }
                v44->i16[0] -= (v125 * (unsigned __int16)v124 + ((v125 * (unsigned __int16)v124) >> 16) + 1) >> 16;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              --v122;
            }
            while (v122);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            --v8;
          }
          while (v8);
        }
        return result;
      case 8:
        v127 = 257 * v42;
        if (v3)
        {
          v128 = 2 * v39;
          do
          {
            v129 = v322;
            do
            {
              v130 = *(unsigned __int8 *)v46;
              if (*(_BYTE *)v46)
              {
                v131 = v42;
                if (v130 != 255)
                  v131 = (v127 * v130 + ((v127 * v130) >> 16) + 1) >> 16;
                v132 = *v38;
                v44->i16[0] -= (v131 * v44->u16[0] + ((v131 * v44->u16[0]) >> 16) + 1) >> 16;
                *v38 = v132 - ((v131 * v132 + ((v131 * v132) >> 16) + 1) >> 16);
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              v38 = (unsigned __int16 *)((char *)v38 + v128);
              --v129;
            }
            while (v129);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            v38 += v41;
            --v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v133 = v322;
            do
            {
              v134 = *(unsigned __int8 *)v46;
              if (*(_BYTE *)v46)
              {
                v135 = v42;
                if (v134 != 255)
                  v135 = (v127 * v134 + ((v127 * v134) >> 16) + 1) >> 16;
                v44->i16[0] -= (v135 * v44->u16[0] + ((v135 * v44->u16[0]) >> 16) + 1) >> 16;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              --v133;
            }
            while (v133);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            --v8;
          }
          while (v8);
        }
        return result;
      case 9:
        v136 = 2 * v39;
        do
        {
          v137 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              v138 = *(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
              v139 = *v38 ^ 0xFFFF;
              v140 = ~(*(unsigned __int8 *)v46 | (*(unsigned __int8 *)v46 << 8)) + HIWORD(v138);
              v44->i16[0] = ((unsigned __int16)v138 * v139
                           + v140 * v44->u16[0]
                           + (((unsigned __int16)v138 * v139 + v140 * v44->u16[0]) >> 16)
                           + 1) >> 16;
              *v38 = ((v139 + v140) * HIWORD(v138) + (((v139 + v140) * HIWORD(v138)) >> 16) + 1) >> 16;
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v136);
            --v137;
          }
          while (v137);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          --v8;
        }
        while (v8);
        return result;
      case 10:
        v141 = 2 * v39;
        do
        {
          v142 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              v143 = *(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
              v144 = *v38 ^ 0xFFFF;
              v145 = HIWORD(v143) ^ 0xFFFF;
              v44->i16[0] = ((unsigned __int16)v143 * v144
                           + v145 * v44->u16[0]
                           + (((unsigned __int16)v143 * v144 + v145 * v44->u16[0]) >> 16)
                           + 1) >> 16;
              *v38 = ((v145 + v144) * HIWORD(v143) + (((v145 + v144) * HIWORD(v143)) >> 16) + 1) >> 16;
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v141);
            --v142;
          }
          while (v142);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          --v8;
        }
        while (v8);
        return result;
      case 11:
        if (v3)
        {
          v146 = 2 * v39;
          do
          {
            v147 = v322;
            do
            {
              if (*(_BYTE *)v46)
              {
                v148 = *(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
                v149 = *v38;
                v150 = HIWORD(v148) - (v44->u16[0] + (unsigned __int16)v148) + v149;
                v151 = v149 + HIWORD(v148);
                if (v150 >= 0xFFFF)
                  LOWORD(v150) = -1;
                if (v151 >= 0xFFFF)
                  LOWORD(v151) = -1;
                v44->i16[0] = v151 - v150;
                *v38 = v151;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              v38 = (unsigned __int16 *)((char *)v38 + v146);
              --v147;
            }
            while (v147);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            v38 += v41;
            --v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v240 = v322;
            do
            {
              if (*(_BYTE *)v46)
              {
                v241 = *(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
                v242 = (v44->u16[0] ^ 0xFFFF) - (unsigned __int16)v241 + HIWORD(v241);
                if (v242 >= 0xFFFF)
                  LOWORD(v242) = -1;
                v44->i16[0] = ~(_WORD)v242;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              --v240;
            }
            while (v240);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            --v8;
          }
          while (v8);
        }
        return result;
      case 12:
        if (v3)
        {
          v152 = 2 * v39;
          do
          {
            v153 = v322;
            do
            {
              if (*(_BYTE *)v46)
              {
                v154 = *(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
                v155 = v44->u16[0] + (unsigned __int16)v154;
                v156 = *v38 + HIWORD(v154);
                if (v155 >= 0xFFFF)
                  LOWORD(v155) = -1;
                if (v156 >= 0xFFFF)
                  LOWORD(v156) = -1;
                v44->i16[0] = v155;
                *v38 = v156;
              }
              ++v46;
              v44 = (int16x4_t *)((char *)v44 + 2);
              v38 = (unsigned __int16 *)((char *)v38 + v152);
              --v153;
            }
            while (v153);
            v46 += v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            v38 += v41;
            --v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v243 = 0;
            do
            {
              if (*(_BYTE *)(v46 + v243))
                v44->i16[0] = (2 * v44->i16[0]) | (v44->i16[0] >> 15);
              v44 = (int16x4_t *)((char *)v44 + 2);
              ++v243;
            }
            while (v322 != (_DWORD)v243);
            v46 += (v322 - 1) + 1 + v47;
            v44 = (int16x4_t *)((char *)v44 + 2 * v48);
            --v8;
          }
          while (v8);
        }
        return result;
      case 13:
        v157 = 2 * v39;
        while (1)
        {
          v158 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              v159 = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              if (v159 >= 0x10000)
              {
                v160 = v159 >> 16;
                if (v3)
                {
                  v161 = *v38;
                  if (!*v38)
                    goto LABEL_208;
                }
                else
                {
                  v161 = 0xFFFF;
                }
                v162 = (v161 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v159
                     + ((v160 ^ 0xFFFF) + (unsigned __int16)v159) * (unint64_t)v44->u16[0];
                if (v162 <= 0xFFFE8000)
                  v163 = v162 + 0x8000;
                else
                  v163 = 4294868992;
                v164 = v163 + (v163 >> 16);
                if (v3)
                {
                  v159 = v164 >> 16;
                  v165 = 0xFFFF * (v161 + v160) - v161 * (unint64_t)v160;
                  if (v165 <= 4294868992)
                    v160 = v165 + 0x8000;
                  else
                    v160 = 4294868992;
                  LODWORD(v159) = ((v160 >> 16) + v160) & 0xFFFF0000 | v159;
                  LODWORD(v160) = WORD1(v159);
LABEL_208:
                  v44->i16[0] = v159;
                  *v38 = v160;
                  goto LABEL_210;
                }
                v44->i16[0] = WORD1(v164);
              }
            }
LABEL_210:
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v157);
            --v158;
          }
          while (v158);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          if (!--v8)
            return result;
        }
      case 14:
        v166 = 2 * v39;
        while (1)
        {
          v167 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              v168 = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              if (v168 >= 0x10000)
              {
                v169 = v168 >> 16;
                if (v3)
                {
                  v170 = *v38;
                  if (!*v38)
                    goto LABEL_229;
                }
                else
                {
                  v170 = 0xFFFF;
                }
                v171 = (v44->u16[0] ^ 0xFFFFu)
                     * (unint64_t)(unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46)
                     - v44->u16[0]
                     + ((unint64_t)v44->u16[0] << 16);
                if (v171 <= 0xFFFE8000)
                  v172 = v171 + 0x8000;
                else
                  v172 = 4294868992;
                v168 = (v172 + (v172 >> 16)) >> 16;
                if (v3)
                {
                  v173 = 0xFFFF * (v169 + v170) - v169 * (unint64_t)v170;
                  if (v173 <= 4294868992)
                    v169 = v173 + 0x8000;
                  else
                    v169 = 4294868992;
                  LODWORD(v168) = ((v169 >> 16) + v169) & 0xFFFF0000 | v168;
                  LODWORD(v169) = WORD1(v168);
LABEL_229:
                  v44->i16[0] = v168;
                  *v38 = v169;
                  goto LABEL_231;
                }
                v44->i16[0] = v168;
              }
            }
LABEL_231:
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v166);
            --v167;
          }
          while (v167);
          v46 += v47;
          v44 = (int16x4_t *)((char *)v44 + 2 * v48);
          v38 += v41;
          if (!--v8)
            return result;
        }
      case 15:
        v174 = 2 * v39;
        do
        {
          v175 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v176 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAoverlayPDA_8071(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v176);
                    v176 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v176;
                }
                else
                {
                  result = PDAoverlayPDA_8071(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v176);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v174);
            --v175;
          }
          while (v175);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 16:
        v177 = 2 * v39;
        do
        {
          v178 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v179 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAdarkenPDA_8073(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v179);
                    v179 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v179;
                }
                else
                {
                  result = PDAdarkenPDA_8073(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v179);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v177);
            --v178;
          }
          while (v178);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 17:
        v180 = 2 * v39;
        do
        {
          v181 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v182 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAlightenPDA_8072(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v182);
                    v182 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v182;
                }
                else
                {
                  result = PDAlightenPDA_8072(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v182);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v180);
            --v181;
          }
          while (v181);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 18:
        v183 = 2 * v39;
        do
        {
          v184 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v185 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAcolordodgePDA_8074(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v185);
                    v185 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v185;
                }
                else
                {
                  result = PDAcolordodgePDA_8074(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v185);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v183);
            --v184;
          }
          while (v184);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 19:
        v186 = 2 * v39;
        do
        {
          v187 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v188 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAcolorburnPDA_8075(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v188);
                    v188 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v188;
                }
                else
                {
                  result = PDAcolorburnPDA_8075(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v188);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v186);
            --v187;
          }
          while (v187);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 20:
        v189 = 2 * v39;
        do
        {
          v190 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v191 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAsoftlightPDA_8077(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v191);
                    v191 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v191;
                }
                else
                {
                  result = PDAsoftlightPDA_8077(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v191);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v189);
            --v190;
          }
          while (v190);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 21:
        v192 = 2 * v39;
        do
        {
          v193 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v194 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAhardlightPDA_8076(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v194);
                    v194 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v194;
                }
                else
                {
                  result = PDAhardlightPDA_8076(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v194);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v192);
            --v193;
          }
          while (v193);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 22:
        v195 = 2 * v39;
        do
        {
          v196 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v197 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAdifferencePDA_8078(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v197);
                    v197 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v197;
                }
                else
                {
                  result = PDAdifferencePDA_8078(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v197);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v195);
            --v196;
          }
          while (v196);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 23:
        v198 = 2 * v39;
        break;
      case 24:
        v209 = 2 * v39;
        do
        {
          v210 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v211 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAhuePDA_8079(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v211);
                    v211 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v211;
                }
                else
                {
                  result = PDAhuePDA_8079(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v211);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v209);
            --v210;
          }
          while (v210);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 25:
        v212 = 2 * v39;
        do
        {
          v213 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v214 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAhuePDA_8079(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v214);
                    v214 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v214;
                }
                else
                {
                  result = PDAhuePDA_8079(v44->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v214);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v212);
            --v213;
          }
          while (v213);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 26:
        v215 = 2 * v39;
        do
        {
          v216 = v322;
          do
          {
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
              v217 = WORD1(result);
              if (WORD1(result))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAluminosityPDA_8081((unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v217, v44->u16[0], *v38);
                    v217 = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v217;
                }
                else
                {
                  result = PDAluminosityPDA_8081((unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46), v217, v44->u16[0], 0xFFFFu);
                  v44->i16[0] = result;
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v215);
            --v216;
          }
          while (v216);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      case 27:
        v218 = 2 * v39;
        do
        {
          v219 = v322;
          do
          {
            v220 = *(unsigned __int8 *)v46;
            if (*(_BYTE *)v46)
            {
              result = *(unsigned int *)(v33 + 4 * v220);
              v221 = result >> 16;
              if (HIWORD(*(_DWORD *)(v33 + 4 * v220)))
              {
                if (v3)
                {
                  if (*v38)
                  {
                    result = PDAluminosityPDA_8081(v44->u16[0], *v38, (unsigned __int16)*(_DWORD *)(v33 + 4 * v220), v221);
                    LODWORD(v221) = WORD1(result);
                  }
                  v44->i16[0] = result;
                  *v38 = v221;
                }
                else
                {
                  v222 = *(_DWORD *)(v33 + 4 * v220);
                  if (v222 >= v221)
                    v222 = HIWORD(*(_DWORD *)(v33 + 4 * v220));
                  v223 = (v221 ^ 0xFFFF) * (unint64_t)v44->u16[0] + 0x8000;
                  v44->i16[0] = v222 + (((v223 >> 16) + v223) >> 16);
                }
              }
            }
            ++v46;
            v44 = (int16x4_t *)((char *)v44 + 2);
            v38 = (unsigned __int16 *)((char *)v38 + v218);
            --v219;
          }
          while (v219);
          v46 += v324;
          v44 = (int16x4_t *)((char *)v44 + 2 * v326);
          v38 += v49;
          --v8;
        }
        while (v8);
        return result;
      default:
        return result;
    }
LABEL_331:
    v199 = v322;
    while (1)
    {
      if (!*(_BYTE *)v46)
        goto LABEL_354;
      v200 = *(unsigned int *)(v33 + 4 * *(unsigned __int8 *)v46);
      v201 = v200 >> 16;
      if (!HIWORD(*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46)))
        goto LABEL_354;
      if (v3)
      {
        v202 = *v38;
        if (!*v38)
          goto LABEL_352;
      }
      else
      {
        v202 = 0xFFFF;
      }
      if ((unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46) >= v201)
        v203 = v201;
      else
        v203 = (unsigned __int16)*(_DWORD *)(v33 + 4 * *(unsigned __int8 *)v46);
      if (v44->u16[0] >= v202)
        v204 = v202;
      else
        v204 = v44->u16[0];
      v205 = 0xFFFF * (v204 + v203) - 2 * v203 * (unint64_t)v204;
      if (v205 <= 4294868992)
        v206 = v205 + 0x8000;
      else
        v206 = 4294868992;
      v207 = v206 + (v206 >> 16);
      if (!v3)
      {
        v44->i16[0] = WORD1(v207);
        goto LABEL_354;
      }
      v200 = v207 >> 16;
      v208 = 0xFFFF * (v201 + v202) - v201 * (unint64_t)v202;
      if (v208 <= 4294868992)
        v201 = v208 + 0x8000;
      else
        v201 = 4294868992;
      LODWORD(v200) = ((v201 >> 16) + v201) & 0xFFFF0000 | v200;
      LODWORD(v201) = WORD1(v200);
LABEL_352:
      v44->i16[0] = v200;
      *v38 = v201;
LABEL_354:
      ++v46;
      v44 = (int16x4_t *)((char *)v44 + 2);
      v38 = (unsigned __int16 *)((char *)v38 + v198);
      if (!--v199)
      {
        v46 += v47;
        v44 = (int16x4_t *)((char *)v44 + 2 * v48);
        v38 += v41;
        if (!--v8)
          return result;
        goto LABEL_331;
      }
    }
  }
  return result;
}

unint64_t w16_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _WORD *v7;
  int v8;
  int v9;
  int v10;
  _WORD *v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  int v23;
  int v24;
  char *v25;
  uint64_t v26;
  int v27;
  unint64_t v28;
  char *v29;
  int v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _WORD *v45;
  int v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  char *v51;
  _WORD *v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _WORD *v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  _WORD *v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned __int16 *v87;
  uint64_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  unsigned int v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  char *v98;
  unsigned __int16 *v99;
  char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unsigned __int16 *v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  unsigned int v115;
  int v116;
  unsigned int v117;
  unsigned int v118;
  char *v119;
  unsigned __int16 *v120;
  char *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unsigned __int16 *v129;
  uint64_t v130;
  int v131;
  int v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  char *v137;
  unsigned __int16 *v138;
  char *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unsigned __int16 *v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned __int16 *v156;
  uint64_t v157;
  char *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  unsigned __int16 *v166;
  uint64_t v167;
  int v168;
  int v169;
  int v170;
  int v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;
  char *v175;
  unsigned __int16 *v176;
  char *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  unsigned __int16 *v184;
  uint64_t v185;
  int v186;
  int v187;
  int v188;
  unsigned int v189;
  char *v190;
  unsigned __int16 *v191;
  char *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  unsigned __int16 *v200;
  int v201;
  unsigned __int16 v202;
  int v203;
  unsigned int v204;
  unsigned int v205;
  int v206;
  unsigned int v207;
  unsigned int v208;
  unsigned __int16 *v209;
  uint64_t v210;
  char *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  unsigned __int16 *v220;
  uint64_t v221;
  int v222;
  int v223;
  unsigned int v224;
  unsigned int v225;
  int v226;
  unsigned int v227;
  char *v228;
  unsigned __int16 *v229;
  char *v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  unsigned __int16 *v237;
  uint64_t v238;
  int v239;
  int v240;
  int v241;
  unsigned int v242;
  int v243;
  int v244;
  unsigned int v245;
  unsigned __int16 *v246;
  uint64_t v247;
  char *v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  unsigned __int16 *v255;
  uint64_t v256;
  int v257;
  int v258;
  int v259;
  unsigned int v260;
  unsigned int v261;
  unsigned int v262;
  unsigned __int16 *v263;
  uint64_t v264;
  char *v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  unsigned __int16 *v276;
  int v277;
  int v278;
  int v279;
  unsigned int v280;
  unsigned int v281;
  unint64_t v282;
  unsigned int v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unint64_t v287;
  int64_t v288;
  unsigned __int16 *v289;
  uint64_t v290;
  char *v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  unsigned __int16 *v302;
  int v303;
  int v304;
  int v305;
  unsigned int v306;
  unsigned int v307;
  unsigned int v308;
  unsigned int v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  int64_t v313;
  unint64_t v314;
  unsigned __int16 *v315;
  uint64_t v316;
  char *v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  unsigned __int16 *v325;
  uint64_t v326;
  int v327;
  int v328;
  int v329;
  int v330;
  unsigned int v331;
  unsigned int v332;
  char *v333;
  uint64_t v334;
  char *v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  unsigned __int16 *v342;
  uint64_t v343;
  int v344;
  int v345;
  int v346;
  int v347;
  unsigned int v348;
  unsigned int v349;
  char *v350;
  uint64_t v351;
  char *v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  unsigned __int16 *v359;
  uint64_t v360;
  int v361;
  int v362;
  int v363;
  int v364;
  unsigned int v365;
  unsigned int v366;
  char *v367;
  uint64_t v368;
  char *v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  unsigned __int16 *v376;
  uint64_t v377;
  int v378;
  int v379;
  int v380;
  int v381;
  unsigned int v382;
  unsigned int v383;
  char *v384;
  uint64_t v385;
  char *v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  unsigned __int16 *v393;
  uint64_t v394;
  int v395;
  int v396;
  int v397;
  int v398;
  unsigned int v399;
  unsigned int v400;
  char *v401;
  uint64_t v402;
  char *v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  unsigned __int16 *v410;
  uint64_t v411;
  int v412;
  int v413;
  int v414;
  int v415;
  unsigned int v416;
  unsigned int v417;
  char *v418;
  uint64_t v419;
  char *v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  unsigned __int16 *v427;
  uint64_t v428;
  int v429;
  int v430;
  int v431;
  int v432;
  unsigned int v433;
  unsigned int v434;
  char *v435;
  uint64_t v436;
  char *v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  unsigned __int16 *v444;
  uint64_t v445;
  int v446;
  int v447;
  int v448;
  int v449;
  unsigned int v450;
  unsigned int v451;
  char *v452;
  uint64_t v453;
  char *v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  unsigned __int16 *v465;
  int v466;
  int v467;
  int v468;
  unsigned int v469;
  unsigned int v470;
  unsigned int v471;
  unsigned int v472;
  uint64_t v473;
  uint64_t v474;
  int64_t v475;
  unint64_t v476;
  unint64_t v477;
  unint64_t v478;
  int64_t v479;
  unint64_t v480;
  unsigned __int16 *v481;
  uint64_t v482;
  char *v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  unsigned __int16 *v491;
  uint64_t v492;
  int v493;
  int v494;
  int v495;
  int v496;
  unsigned int v497;
  unsigned int v498;
  char *v499;
  uint64_t v500;
  char *v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  unsigned __int16 *v508;
  uint64_t v509;
  int v510;
  int v511;
  int v512;
  int v513;
  unsigned int v514;
  unsigned int v515;
  char *v516;
  uint64_t v517;
  char *v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  unsigned __int16 *v525;
  uint64_t v526;
  int v527;
  int v528;
  int v529;
  int v530;
  unsigned int v531;
  unsigned int v532;
  char *v533;
  uint64_t v534;
  char *v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  unsigned __int16 *v542;
  uint64_t v543;
  int v544;
  int v545;
  int v546;
  int v547;
  unsigned int v548;
  unsigned int v549;
  unsigned int v550;
  unint64_t v551;
  char *v552;
  uint64_t v553;
  char *v554;
  uint64_t v555;
  uint64_t v556;
  int v557;
  int v558;
  unsigned int v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  int v564;
  int v565;
  unsigned int v566;
  char *v567;
  uint64_t v568;
  char *v569;
  char *v570;
  uint64_t v571;
  char *v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  _WORD *v578;
  int v579;
  int v580;
  int v581;
  unsigned int v582;
  int v583;
  int v584;
  unsigned int v585;
  unsigned int v586;
  unsigned int v587;
  char *v588;
  _WORD *v589;
  char *v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  unsigned __int16 *v597;
  int v598;
  int v599;
  unsigned int v600;
  int v601;
  char *v602;
  unsigned __int16 *v603;
  uint64_t v604;
  char *v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  unsigned __int16 *v613;
  int v614;
  int v615;
  unsigned int v616;
  char *v617;
  unsigned __int16 *v618;
  uint64_t v619;
  char *v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  unsigned __int16 *v628;
  int v629;
  int v630;
  int v631;
  signed int v632;
  char *v633;
  unsigned __int16 *v634;
  char *v635;
  uint64_t v636;
  uint64_t v637;
  int v638;
  _BYTE *v639;
  uint64_t v640;
  uint64_t v641;
  int v642;
  int v643;
  unsigned int v644;
  char *v645;
  uint64_t v646;
  char *v647;
  char *v648;
  uint64_t v649;
  char *v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  unint64_t v688;
  unint64_t v689;
  uint64_t v690;
  uint64_t v691;
  int v692;
  unint64_t v693;
  int v694;
  int v695;
  int v696;
  int v697;
  int v698;
  int v699;
  int v700;
  int v701;
  int v702;
  int v703;
  int v704;
  int v705;
  unint64_t v706;
  _WORD *v707;
  char *v708;
  unint64_t v709;
  unint64_t v710;
  unint64_t v711;
  unint64_t v712;
  unint64_t v713;
  unint64_t v714;
  unint64_t v715;
  unint64_t v716;
  unint64_t v717;
  unint64_t v718;
  unint64_t v719;
  uint64_t v720;
  int v721;
  int v722;

  v2 = *(_QWORD *)(result + 48);
  v3 = *(_QWORD *)(result + 136);
  v5 = *(int *)(result + 12);
  v4 = *(int *)(result + 16);
  if (v2)
  {
    v6 = (unint64_t)*(int *)(result + 32) >> 1;
    v7 = (_WORD *)(v2 + 2 * (v5 + v6 * v4));
    v8 = -1;
    if (!v3)
      return result;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return result;
  }
  v10 = *(_DWORD *)(result + 4);
  v9 = *(_DWORD *)(result + 8);
  v12 = *(_QWORD *)(result + 88);
  v11 = *(_WORD **)(result + 96);
  v13 = (unint64_t)*(int *)(result + 28) >> 1;
  v14 = (char *)(*(_QWORD *)(result + 40) + 2 * (v5 + v13 * v4));
  v15 = *(int *)(result + 124);
  v16 = (_BYTE *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(result + 56);
  v18 = *(int *)(result + 60);
  v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    v23 = *(_DWORD *)(result + 64);
    v24 = *(_DWORD *)(result + 68);
    v20 = v19 >> 1;
    if (v11)
    {
      v21 = (unint64_t)*(int *)(result + 80) >> 1;
      v22 = 1;
    }
    else
    {
      v21 = 0;
      v22 = 0;
    }
    v28 = v12 + 2 * v20 * v24;
    v8 &= 1u;
    v27 = 1;
    v29 = *(char **)(result + 88);
    v25 = v29;
    goto LABEL_19;
  }
  v20 = v19 >> 1;
  if (v11)
  {
    v21 = (unint64_t)*(int *)(result + 80) >> 1;
    v11 += v17 + v21 * v18;
    v22 = -1;
  }
  else
  {
    v21 = 0;
    v22 = 0;
  }
  v25 = (char *)(v12 + 2 * (v17 + v20 * v18));
  if (v20 == v13 && v14 - v25 >= 1)
  {
    if (v10 >= (uint64_t)((unint64_t)(v14 - v25) >> 1))
    {
      v14 += 2 * v10 - 2;
      v25 += 2 * v10 - 2;
      v16 += v10 - 1;
      v7 += v8 & (v10 - 1);
      v27 = -1;
      v20 = (unint64_t)*(int *)(result + 28) >> 1;
      v11 += v22 & (v10 - 1);
      goto LABEL_16;
    }
    v26 = v9 - 1;
    if (v14 <= &v25[2 * v13 * v26 - 2 + 2 * v10])
    {
      v14 += 2 * v13 * v26;
      v20 = -(uint64_t)v13;
      v16 += v15 * v26;
      v15 = -v15;
      v7 += v6 * v26;
      v6 = -(uint64_t)v6;
      v8 &= 1u;
      v11 += v21 * v26;
      v21 = -(uint64_t)v21;
      v22 &= 1u;
      v27 = 1;
      v25 += 2 * v13 * v26;
      v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v22 &= 1u;
  v27 = 1;
LABEL_16:
  v28 = 0;
  v29 = 0;
  v12 = -1;
  v24 = v21;
  v23 = v20;
LABEL_19:
  v30 = v27 * v10;
  if (v28)
  {
    v31 = (int)v18 % v24;
    v32 = &v25[2 * v20 * v31];
    result = (int)v17 % v23;
    v25 = &v32[2 * result];
    v12 = (unint64_t)&v32[2 * v23];
    if ((v22 & 1) != 0)
      v11 += v21 * v31 + result;
    v707 = v11;
    v708 = &v32[2 * result];
  }
  else
  {
    v707 = v11;
    v708 = v29;
    v20 -= v30;
    v21 -= v22 * v10;
  }
  v33 = v15 - v30;
  v34 = v13 - v30;
  v706 = v6 - v8 * v10;
  v691 = v20;
  v692 = v10;
  v689 = v34;
  v690 = v33;
  v693 = v28;
  v688 = v21;
  v721 = v22;
  v722 = v8;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          v35 = v10;
          do
          {
            v36 = *v16;
            if (*v16)
            {
              if (v36 == 255)
              {
                LOWORD(v37) = 0;
                *(_WORD *)v14 = 0;
              }
              else
              {
                v38 = (unsigned __int16)*v7;
                v39 = v36 | (v36 << 8);
                *(_WORD *)v14 -= (v39 * *(unsigned __int16 *)v14
                                + ((v39 * *(unsigned __int16 *)v14) >> 16)
                                + 1) >> 16;
                v37 = v38 - ((v39 * v38 + ((v39 * v38) >> 16) + 1) >> 16);
              }
              *v7 = v37;
            }
            v16 += v27;
            v7 += v8;
            v14 += 2 * v27;
            --v35;
          }
          while (v35);
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v557 = v10;
          do
          {
            v558 = *v16;
            if (*v16)
            {
              if (v558 == 255)
                LOWORD(v559) = 0;
              else
                v559 = *(unsigned __int16 *)v14
                     - ((257 * v558 * *(unsigned __int16 *)v14
                       + ((257 * v558 * *(unsigned __int16 *)v14) >> 16)
                       + 1) >> 16);
              *(_WORD *)v14 = v559;
            }
            v16 += v27;
            v14 += 2 * v27;
            --v557;
          }
          while (v557);
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 1:
      if (v8)
      {
        v40 = v27;
        if (v22)
        {
          v41 = -(uint64_t)v23;
          v42 = v24;
          v43 = -(v20 * v24);
          v44 = -(uint64_t)(v21 * v42);
          v45 = v707;
          do
          {
            v46 = v10;
            do
            {
              v47 = *v16;
              if (*v16)
              {
                if (v47 == 255)
                {
                  *(_WORD *)v14 = *(_WORD *)v25;
                  LOWORD(v48) = *v45;
                }
                else
                {
                  v49 = *(unsigned __int16 *)v25 * (v47 | (v47 << 8))
                      + *(unsigned __int16 *)v14 * ((v47 | (v47 << 8)) ^ 0xFFFF);
                  v50 = (v49 + HIWORD(v49) + 1) >> 16;
                  v48 = (0xFFFF * (unsigned __int16)*v45 + ((0xFFFF * (unsigned __int16)*v45) >> 16) + 1) >> 16;
                  *(_WORD *)v14 = v50;
                }
                *v7 = v48;
              }
              v16 += v40;
              v51 = &v25[2 * v40];
              v52 = &v45[v22];
              if ((unint64_t)v51 >= v12)
                result = v41;
              else
                result = 0;
              v45 = &v52[result];
              v25 = &v51[2 * result];
              v7 += v8;
              v14 += 2 * v40;
              --v46;
            }
            while (v46);
            if (v28)
            {
              v53 = &v708[2 * v20];
              if ((unint64_t)v53 >= v28)
                v54 = v44;
              else
                v54 = 0;
              result = (unint64_t)&v707[v21 + v54];
              if ((unint64_t)v53 >= v28)
                v55 = v43;
              else
                v55 = 0;
              v25 = &v53[2 * v55];
              v12 += 2 * v55 + 2 * v20;
              v707 += v21 + v54;
              v708 = v25;
              v45 = (_WORD *)result;
            }
            else
            {
              v25 += 2 * v20;
              v45 += v21;
            }
            v16 += v33;
            v14 += 2 * v34;
            v7 += v706;
            --v9;
          }
          while (v9);
        }
        else
        {
          v640 = -(uint64_t)v23;
          v641 = -(v20 * v24);
          do
          {
            v642 = v10;
            do
            {
              v643 = *v16;
              if (*v16)
              {
                if (v643 == 255)
                  LOWORD(v644) = *(_WORD *)v25;
                else
                  v644 = (*(unsigned __int16 *)v25 * (v643 | (v643 << 8))
                        + *(unsigned __int16 *)v14 * ((v643 | (v643 << 8)) ^ 0xFFFF)
                        + ((*(unsigned __int16 *)v25 * (v643 | (v643 << 8))
                          + *(unsigned __int16 *)v14 * ((v643 | (v643 << 8)) ^ 0xFFFFu)) >> 16)
                        + 1) >> 16;
                *(_WORD *)v14 = v644;
                *v7 = -1;
              }
              v16 += v40;
              v645 = &v25[2 * v40];
              if ((unint64_t)v645 >= v12)
                v646 = v640;
              else
                v646 = 0;
              v25 = &v645[2 * v646];
              v7 += v8;
              v14 += 2 * v40;
              --v642;
            }
            while (v642);
            v16 += v33;
            v14 += 2 * v34;
            v7 += v706;
            v647 = v708;
            v648 = &v708[2 * v20];
            if ((unint64_t)v648 >= v28)
              v649 = v641;
            else
              v649 = 0;
            v650 = &v648[2 * v649];
            v651 = v12 + 2 * v649 + 2 * v20;
            if (v28)
            {
              v12 = v651;
              v647 = v650;
            }
            v708 = v647;
            if (v28)
              v25 = v650;
            else
              v25 += 2 * v20;
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        v560 = v27;
        v561 = -(uint64_t)v23;
        v562 = -(v20 * v24);
        v563 = 2 * v27;
        do
        {
          v564 = v10;
          do
          {
            v565 = *v16;
            if (*v16)
            {
              if (v565 == 255)
                LOWORD(v566) = *(_WORD *)v25;
              else
                v566 = (*(unsigned __int16 *)v25 * (v565 | (v565 << 8))
                      + *(unsigned __int16 *)v14 * ((v565 | (v565 << 8)) ^ 0xFFFF)
                      + ((*(unsigned __int16 *)v25 * (v565 | (v565 << 8))
                        + *(unsigned __int16 *)v14 * ((v565 | (v565 << 8)) ^ 0xFFFFu)) >> 16)
                      + 1) >> 16;
              *(_WORD *)v14 = v566;
            }
            v16 += v560;
            v567 = &v25[2 * v560];
            if ((unint64_t)v567 >= v12)
              v568 = v561;
            else
              v568 = 0;
            v25 = &v567[2 * v568];
            v14 += v563;
            --v564;
          }
          while (v564);
          v16 += v33;
          v14 += 2 * v34;
          v569 = v708;
          v570 = &v708[2 * v20];
          if ((unint64_t)v570 >= v28)
            v571 = v562;
          else
            v571 = 0;
          v572 = &v570[2 * v571];
          v573 = v12 + 2 * v571 + 2 * v20;
          if (v28)
          {
            v12 = v573;
            v569 = v572;
          }
          v708 = v569;
          if (v28)
            v25 = v572;
          else
            v25 += 2 * v20;
          --v9;
        }
        while (v9);
      }
      return result;
    case 2:
      v56 = v27;
      if (v8)
      {
        v57 = v24;
        v58 = -(v20 * v24);
        v59 = -(uint64_t)(v21 * v57);
        v60 = 2 * v8;
        v61 = v707;
        v62 = -(uint64_t)v23;
        while (1)
        {
          v63 = v10;
          do
          {
            v64 = *v16;
            if (!*v16)
              goto LABEL_73;
            if (v64 == 255)
            {
              v65 = (unsigned __int16)*v61;
              if (!*v61)
                goto LABEL_73;
              if (v65 == 0xFFFF)
              {
                *(_WORD *)v14 = *(_WORD *)v25;
                LOWORD(v66) = -1;
              }
              else
              {
                v75 = (unsigned __int16)*v7 * (v65 ^ 0xFFFF) + (((unsigned __int16)*v7 * (v65 ^ 0xFFFFu)) >> 16) + 1;
                *(_WORD *)v14 = *(_WORD *)v25
                              + ((*(unsigned __int16 *)v14 * (v65 ^ 0xFFFF)
                                + ((*(unsigned __int16 *)v14 * (v65 ^ 0xFFFFu)) >> 16)
                                + 1) >> 16);
                v66 = v65 + HIWORD(v75);
              }
            }
            else
            {
              v67 = (unsigned __int16)*v61;
              v68 = (v64 | (v64 << 8)) ^ 0xFFFF;
              v69 = v68 * v67 + ((v68 * v67) >> 16) + 1;
              v70 = *(unsigned __int16 *)v25
                  - ((v68 * *(unsigned __int16 *)v25 + ((v68 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
              v71 = v70 | ((v67 - HIWORD(v69)) << 16);
              if (!HIWORD(v71))
                goto LABEL_73;
              v72 = HIWORD(v71) ^ 0xFFFF;
              v73 = v72 * *(unsigned __int16 *)v14 + ((v72 * *(unsigned __int16 *)v14) >> 16) + 1;
              v74 = (v72 * (unsigned __int16)*v7 + ((v72 * (unsigned __int16)*v7) >> 16) + 1) >> 16;
              *(_WORD *)v14 = v70 + HIWORD(v73);
              v66 = v74 + HIWORD(v71);
            }
            *v7 = v66;
LABEL_73:
            v16 += v27;
            result = (unint64_t)&v25[2 * v27];
            v76 = &v61[v22];
            if (result >= v12)
              v77 = v62;
            else
              v77 = 0;
            v61 = &v76[v77];
            v25 = (char *)(result + 2 * v77);
            v7 = (_WORD *)((char *)v7 + v60);
            v14 += 2 * v27;
            --v63;
          }
          while (v63);
          if (v28)
          {
            v78 = &v708[2 * v20];
            if ((unint64_t)v78 >= v28)
              v79 = v59;
            else
              v79 = 0;
            v80 = (uint64_t)&v707[v21 + v79];
            if ((unint64_t)v78 >= v28)
              v81 = v58;
            else
              v81 = 0;
            result = v12 + 2 * v81;
            v25 = &v78[2 * v81];
            v12 = result + 2 * v20;
            v707 = (_WORD *)v80;
            v708 = v25;
            v61 = (_WORD *)v80;
          }
          else
          {
            v25 += 2 * v20;
            v61 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          if (!--v9)
            return result;
        }
      }
      v574 = -(uint64_t)v23;
      v575 = v24;
      v576 = -(v20 * v24);
      v577 = -(uint64_t)(v21 * v575);
      v578 = v707;
LABEL_777:
      v579 = v10;
      while (1)
      {
        v580 = *v16;
        if (*v16)
        {
          if (v580 == 255)
          {
            v581 = (unsigned __int16)*v578;
            if (*v578)
            {
              if (v581 == 0xFFFF)
                LOWORD(v582) = *(_WORD *)v25;
              else
                v582 = *(unsigned __int16 *)v25
                     + ((*(unsigned __int16 *)v14 * (v581 ^ 0xFFFF)
                       + ((*(unsigned __int16 *)v14 * (v581 ^ 0xFFFFu)) >> 16)
                       + 1) >> 16);
              goto LABEL_786;
            }
          }
          else
          {
            v583 = (unsigned __int16)*v578;
            v584 = (v580 | (v580 << 8)) ^ 0xFFFF;
            v585 = v584 * v583 + ((v584 * v583) >> 16) + 1;
            v586 = *(unsigned __int16 *)v25
                 - ((v584 * *(unsigned __int16 *)v25 + ((v584 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            v587 = v586 | ((v583 - HIWORD(v585)) << 16);
            if (v587 >= 0x10000)
            {
              v582 = v586
                   + (((~v587 >> 16) * *(unsigned __int16 *)v14 + (((~v587 >> 16) * *(unsigned __int16 *)v14) >> 16) + 1) >> 16);
LABEL_786:
              *(_WORD *)v14 = v582;
            }
          }
        }
        v16 += v56;
        v588 = &v25[2 * v56];
        v589 = &v578[v22];
        if ((unint64_t)v588 >= v12)
          result = v574;
        else
          result = 0;
        v578 = &v589[result];
        v25 = &v588[2 * result];
        v14 += 2 * v56;
        if (!--v579)
        {
          if (v28)
          {
            v590 = &v708[2 * v20];
            if ((unint64_t)v590 >= v28)
              v591 = v577;
            else
              v591 = 0;
            result = (unint64_t)&v707[v21 + v591];
            if ((unint64_t)v590 >= v28)
              v592 = v576;
            else
              v592 = 0;
            v25 = &v590[2 * v592];
            v12 += 2 * v592 + 2 * v20;
            v707 += v21 + v591;
            v708 = v25;
            v578 = (_WORD *)result;
          }
          else
          {
            v25 += 2 * v20;
            v578 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          if (!--v9)
            return result;
          goto LABEL_777;
        }
      }
    case 3:
      v82 = v27;
      v83 = v24;
      v84 = -(v20 * v24);
      v85 = -(uint64_t)(v21 * v83);
      v86 = 2 * v27;
      v87 = v707;
      v88 = -(uint64_t)v23;
      do
      {
        v89 = v10;
        do
        {
          v90 = *v16;
          if (*v16)
          {
            if (v90 == 255)
            {
              if (v22)
                v91 = *v87;
              else
                v91 = 0xFFFF;
              v93 = (unsigned __int16)*v7 ^ 0xFFFF;
              *(_WORD *)v14 = *(_WORD *)v25
                            - ((v93 * *(unsigned __int16 *)v25
                              + ((v93 * *(unsigned __int16 *)v25) >> 16)
                              + 1) >> 16);
              v94 = v91 - ((v93 * v91 + ((v93 * v91) >> 16) + 1) >> 16);
            }
            else
            {
              if (v22)
                v92 = *v87;
              else
                v92 = 0xFFFF;
              v95 = v90 | (v90 << 8);
              v96 = (unsigned __int16)*v7 * v95 + (((unsigned __int16)*v7 * v95) >> 16) + 1;
              v95 ^= 0xFFFFu;
              v97 = HIWORD(v96) * *(unsigned __int16 *)v25 + *(unsigned __int16 *)v14 * v95;
              v94 = ((v95 + HIWORD(v96)) * v92 + (((v95 + HIWORD(v96)) * v92) >> 16) + 1) >> 16;
              *(_WORD *)v14 = (v97 + HIWORD(v97) + 1) >> 16;
            }
            *v7 = v94;
          }
          v16 += v82;
          v98 = &v25[2 * v82];
          v99 = &v87[v22];
          if ((unint64_t)v98 >= v12)
            result = v88;
          else
            result = 0;
          v87 = &v99[result];
          v25 = &v98[2 * result];
          v7 += v8;
          v14 += v86;
          --v89;
        }
        while (v89);
        if (v28)
        {
          v100 = &v708[2 * v20];
          if ((unint64_t)v100 >= v28)
            v101 = v85;
          else
            v101 = 0;
          result = (unint64_t)&v707[v21 + v101];
          if ((unint64_t)v100 >= v28)
            v102 = v84;
          else
            v102 = 0;
          v25 = &v100[2 * v102];
          v12 += 2 * v102 + 2 * v20;
          v707 += v21 + v101;
          v708 = v25;
          v87 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v87 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 4:
      v103 = v27;
      v104 = v24;
      v105 = -(v20 * v24);
      v106 = -(uint64_t)(v21 * v104);
      v107 = 2 * v27;
      v108 = v707;
      v109 = -(uint64_t)v23;
      do
      {
        v110 = v10;
        do
        {
          v111 = *v16;
          if (*v16)
          {
            if (v111 == 255)
            {
              if (v22)
                v112 = *v108;
              else
                v112 = 0xFFFF;
              v114 = (unsigned __int16)*v7;
              *(_WORD *)v14 = *(_WORD *)v25
                            - ((v114 * *(unsigned __int16 *)v25
                              + ((v114 * *(unsigned __int16 *)v25) >> 16)
                              + 1) >> 16);
              v115 = v112 - ((v114 * v112 + ((v114 * v112) >> 16) + 1) >> 16);
            }
            else
            {
              if (v22)
                v113 = *v108;
              else
                v113 = 0xFFFF;
              v116 = v111 | (v111 << 8);
              v117 = ((unsigned __int16)*v7 ^ 0xFFFF) * v116 + ((((unsigned __int16)*v7 ^ 0xFFFFu) * v116) >> 16) + 1;
              v116 ^= 0xFFFFu;
              v118 = HIWORD(v117) * *(unsigned __int16 *)v25 + *(unsigned __int16 *)v14 * v116;
              v115 = ((v116 + HIWORD(v117)) * v113 + (((v116 + HIWORD(v117)) * v113) >> 16) + 1) >> 16;
              *(_WORD *)v14 = (v118 + HIWORD(v118) + 1) >> 16;
            }
            *v7 = v115;
          }
          v16 += v103;
          v119 = &v25[2 * v103];
          v120 = &v108[v22];
          if ((unint64_t)v119 >= v12)
            result = v109;
          else
            result = 0;
          v108 = &v120[result];
          v25 = &v119[2 * result];
          v7 += v8;
          v14 += v107;
          --v110;
        }
        while (v110);
        if (v28)
        {
          v121 = &v708[2 * v20];
          if ((unint64_t)v121 >= v28)
            v122 = v106;
          else
            v122 = 0;
          result = (unint64_t)&v707[v21 + v122];
          if ((unint64_t)v121 >= v28)
            v123 = v105;
          else
            v123 = 0;
          v25 = &v121[2 * v123];
          v12 += 2 * v123 + 2 * v20;
          v707 += v21 + v122;
          v708 = v25;
          v108 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v108 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 5:
      v124 = v27;
      v125 = v24;
      v126 = -(v20 * v24);
      v127 = -(uint64_t)(v21 * v125);
      v128 = 2 * v27;
      v129 = v707;
      v130 = -(uint64_t)v23;
      do
      {
        v131 = v10;
        do
        {
          if (*v16)
          {
            v132 = (unsigned __int16)*v7;
            v133 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v134 = *(unsigned __int16 *)v25
                 - ((v133 * *(unsigned __int16 *)v25 + ((v133 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            v135 = (v134 | ((*v129 - ((v133 * *v129 + ((v133 * *v129) >> 16) + 1) >> 16)) << 16)) >> 16;
            v136 = (unsigned __int16)v134 * v132 + (v135 ^ 0xFFFF) * *(unsigned __int16 *)v14;
            *(_WORD *)v14 = (v136 + HIWORD(v136) + 1) >> 16;
            *v7 = (((v135 ^ 0xFFFF) + v132) * v135 + ((((v135 ^ 0xFFFF) + v132) * v135) >> 16) + 1) >> 16;
          }
          v16 += v124;
          v137 = &v25[2 * v124];
          v138 = &v129[v22];
          if ((unint64_t)v137 >= v12)
            result = v130;
          else
            result = 0;
          v129 = &v138[result];
          v25 = &v137[2 * result];
          v7 += v8;
          v14 += v128;
          --v131;
        }
        while (v131);
        if (v28)
        {
          v139 = &v708[2 * v20];
          if ((unint64_t)v139 >= v28)
            v140 = v127;
          else
            v140 = 0;
          result = (unint64_t)&v707[v21 + v140];
          if ((unint64_t)v139 >= v28)
            v141 = v126;
          else
            v141 = 0;
          v25 = &v139[2 * v141];
          v12 += 2 * v141 + 2 * v20;
          v707 += v21 + v140;
          v708 = v25;
          v129 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v129 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 6:
      v142 = v22;
      v143 = -(uint64_t)v23;
      v144 = v24;
      v145 = -(v20 * v24);
      v146 = -(uint64_t)(v21 * v144);
      v147 = v707;
      do
      {
        v148 = v10;
        do
        {
          v149 = *v16;
          if (*v16)
          {
            v150 = (unsigned __int16)*v7;
            if ((_WORD)v150 != 0xFFFF)
            {
              if ((unsigned __int16)~(_WORD)v150 == 0xFFFF)
              {
                if (v22)
                  v151 = *v147;
                else
                  v151 = 0xFFFF;
                v153 = (v149 | (v149 << 8)) ^ 0xFFFF;
                *(_WORD *)v14 = *(_WORD *)v25
                              - ((v153 * *(unsigned __int16 *)v25
                                + ((v153 * *(unsigned __int16 *)v25) >> 16)
                                + 1) >> 16);
                v154 = v151 - ((v153 * v151 + ((v153 * v151) >> 16) + 1) >> 16);
              }
              else
              {
                if (v22)
                  v152 = *v147;
                else
                  v152 = 0xFFFF;
                v155 = (257 * v149 * (unsigned __int16)~(_WORD)v150
                      + ((257 * v149 * (unsigned __int16)~(_WORD)v150) >> 16)
                      + 1) >> 16;
                *(_WORD *)v14 += (v155 * *(unsigned __int16 *)v25 + ((v155 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16;
                v154 = v150 + ((v155 * v152 + ((v155 * v152) >> 16) + 1) >> 16);
                v22 = v721;
              }
              *v7 = v154;
            }
          }
          v16 += v27;
          result = (unint64_t)&v25[2 * v27];
          v156 = &v147[v142];
          if (result >= v12)
            v157 = v143;
          else
            v157 = 0;
          v147 = &v156[v157];
          v25 = (char *)(result + 2 * v157);
          v7 += v8;
          v14 += 2 * v27;
          --v148;
        }
        while (v148);
        if (v28)
        {
          v158 = &v708[2 * v20];
          if ((unint64_t)v158 >= v28)
            v159 = v146;
          else
            v159 = 0;
          v160 = (uint64_t)&v707[v21 + v159];
          if ((unint64_t)v158 >= v28)
            v161 = v145;
          else
            v161 = 0;
          result = v12 + 2 * v161;
          v25 = &v158[2 * v161];
          v12 = result + 2 * v20;
          v707 = (_WORD *)v160;
          v708 = v25;
          v147 = (unsigned __int16 *)v160;
        }
        else
        {
          v25 += 2 * v20;
          v147 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 7:
      v162 = v27;
      if (v8)
      {
        v163 = v24;
        v164 = -(v20 * v24);
        v165 = -(uint64_t)(v21 * v163);
        v166 = v707;
        v167 = -(uint64_t)v23;
        do
        {
          v168 = v10;
          do
          {
            v169 = *v16;
            if (*v16)
            {
              if (v169 == 255)
              {
                v170 = (unsigned __int16)*v7;
                v171 = *v166 ^ 0xFFFF;
                *(_WORD *)v14 -= (v171 * *(unsigned __int16 *)v14
                                + ((v171 * *(unsigned __int16 *)v14) >> 16)
                                + 1) >> 16;
                v172 = v170 - ((v171 * v170 + ((v171 * v170) >> 16) + 1) >> 16);
              }
              else
              {
                v173 = ((v169 | (v169 << 8)) ^ 0xFFFF)
                     + ((*v166 * (v169 | (v169 << 8)) + ((*v166 * (v169 | (v169 << 8))) >> 16) + 1) >> 16);
                v174 = v173 * *(unsigned __int16 *)v14;
                v172 = (v173 * (unsigned __int16)*v7 + ((v173 * (unsigned __int16)*v7) >> 16) + 1) >> 16;
                *(_WORD *)v14 = (v174 + HIWORD(v174) + 1) >> 16;
              }
              *v7 = v172;
            }
            v16 += v162;
            v175 = &v25[2 * v162];
            v176 = &v166[v22];
            if ((unint64_t)v175 >= v12)
              result = v167;
            else
              result = 0;
            v166 = &v176[result];
            v25 = &v175[2 * result];
            v7 += v8;
            v14 += 2 * v162;
            --v168;
          }
          while (v168);
          if (v28)
          {
            v177 = &v708[2 * v20];
            if ((unint64_t)v177 >= v28)
              v178 = v165;
            else
              v178 = 0;
            result = (unint64_t)&v707[v21 + v178];
            if ((unint64_t)v177 >= v28)
              v179 = v164;
            else
              v179 = 0;
            v25 = &v177[2 * v179];
            v12 += 2 * v179 + 2 * v20;
            v707 += v21 + v178;
            v708 = v25;
            v166 = (unsigned __int16 *)result;
          }
          else
          {
            v25 += 2 * v20;
            v166 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        v593 = -(uint64_t)v23;
        v594 = v24;
        v595 = -(v20 * v24);
        v596 = -(uint64_t)(v21 * v594);
        v597 = v707;
        do
        {
          v598 = v10;
          do
          {
            v599 = *v16;
            if (*v16)
            {
              if (v599 == 255)
              {
                v600 = *(unsigned __int16 *)v14
                     - (((*v597 ^ 0xFFFF) * *(unsigned __int16 *)v14
                       + (((*v597 ^ 0xFFFF) * *(unsigned __int16 *)v14) >> 16)
                       + 1) >> 16);
              }
              else
              {
                v601 = v599 | (v599 << 8);
                result = *v597 * v601 + ((*v597 * v601) >> 16) + 1;
                v600 = (((v601 ^ 0xFFFF) + WORD1(result)) * *(unsigned __int16 *)v14
                      + ((((v601 ^ 0xFFFF) + WORD1(result)) * *(unsigned __int16 *)v14) >> 16)
                      + 1) >> 16;
              }
              *(_WORD *)v14 = v600;
            }
            v16 += v162;
            v602 = &v25[2 * v162];
            v603 = &v597[v22];
            if ((unint64_t)v602 >= v12)
              v604 = v593;
            else
              v604 = 0;
            v597 = &v603[v604];
            v25 = &v602[2 * v604];
            v14 += 2 * v162;
            --v598;
          }
          while (v598);
          if (v28)
          {
            v605 = &v708[2 * v20];
            if ((unint64_t)v605 >= v28)
              v606 = v596;
            else
              v606 = 0;
            v607 = (uint64_t)&v707[v21 + v606];
            if ((unint64_t)v605 >= v28)
              v608 = v595;
            else
              v608 = 0;
            v25 = &v605[2 * v608];
            v12 += 2 * v608 + 2 * v20;
            v707 += v21 + v606;
            v708 = v25;
            v597 = (unsigned __int16 *)v607;
          }
          else
          {
            v25 += 2 * v20;
            v597 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 8:
      v180 = v27;
      if (v8)
      {
        v181 = v24;
        v182 = -(v20 * v24);
        v183 = -(uint64_t)(v21 * v181);
        v184 = v707;
        v185 = -(uint64_t)v23;
        do
        {
          v186 = v10;
          do
          {
            v187 = *v16;
            if (*v16)
            {
              v188 = (unsigned __int16)*v7;
              if (v187 == 255)
                v189 = *v184;
              else
                v189 = (257 * v187 * *v184 + ((257 * v187 * *v184) >> 16) + 1) >> 16;
              *(_WORD *)v14 -= (v189 * *(unsigned __int16 *)v14 + ((v189 * *(unsigned __int16 *)v14) >> 16) + 1) >> 16;
              *v7 = v188 - ((v189 * v188 + ((v189 * v188) >> 16) + 1) >> 16);
            }
            v16 += v180;
            v190 = &v25[2 * v180];
            v191 = &v184[v22];
            if ((unint64_t)v190 >= v12)
              result = v185;
            else
              result = 0;
            v184 = &v191[result];
            v25 = &v190[2 * result];
            v7 += v8;
            v14 += 2 * v180;
            --v186;
          }
          while (v186);
          if (v28)
          {
            v192 = &v708[2 * v20];
            if ((unint64_t)v192 >= v28)
              v193 = v183;
            else
              v193 = 0;
            result = (unint64_t)&v707[v21 + v193];
            if ((unint64_t)v192 >= v28)
              v194 = v182;
            else
              v194 = 0;
            v25 = &v192[2 * v194];
            v12 += 2 * v194 + 2 * v20;
            v707 += v21 + v193;
            v708 = v25;
            v184 = (unsigned __int16 *)result;
          }
          else
          {
            v25 += 2 * v20;
            v184 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        v609 = -(uint64_t)v23;
        v610 = v24;
        v611 = -(v20 * v24);
        v612 = -(uint64_t)(v21 * v610);
        v613 = v707;
        do
        {
          v614 = v10;
          do
          {
            v615 = *v16;
            if (*v16)
            {
              if (v615 == 255)
                v616 = *v613;
              else
                v616 = (257 * v615 * *v613 + ((257 * v615 * *v613) >> 16) + 1) >> 16;
              *(_WORD *)v14 -= (v616 * *(unsigned __int16 *)v14 + ((v616 * *(unsigned __int16 *)v14) >> 16) + 1) >> 16;
            }
            v16 += v180;
            v617 = &v25[2 * v180];
            v618 = &v613[v22];
            if ((unint64_t)v617 >= v12)
              v619 = v609;
            else
              v619 = 0;
            v613 = &v618[v619];
            v25 = &v617[2 * v619];
            v14 += 2 * v180;
            --v614;
          }
          while (v614);
          if (v28)
          {
            v620 = &v708[2 * v20];
            if ((unint64_t)v620 >= v28)
              v621 = v612;
            else
              v621 = 0;
            v622 = (uint64_t)&v707[v21 + v621];
            if ((unint64_t)v620 >= v28)
              v623 = v611;
            else
              v623 = 0;
            v25 = &v620[2 * v623];
            v12 += 2 * v623 + 2 * v20;
            v707 += v21 + v621;
            v708 = v25;
            v613 = (unsigned __int16 *)v622;
          }
          else
          {
            v25 += 2 * v20;
            v613 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 9:
      v195 = -(uint64_t)v23;
      v196 = v24;
      v197 = -(v20 * v24);
      v198 = -(uint64_t)(v21 * v196);
      v199 = 2 * v8;
      v200 = v707;
      do
      {
        v201 = v10;
        do
        {
          if (*v16)
          {
            v202 = ~(*v16 | (*v16 << 8));
            v203 = v202;
            v204 = *(unsigned __int16 *)v25
                 - ((*(unsigned __int16 *)v25 * v203 + ((*(unsigned __int16 *)v25 * v203) >> 16) + 1) >> 16);
            v205 = v204 | ((*v200 - ((*v200 * v203 + ((*v200 * v203) >> 16) + 1) >> 16)) << 16);
            v206 = (unsigned __int16)*v7 ^ 0xFFFF;
            v207 = (unsigned __int16)v204 * v206 + (unsigned __int16)(v202 + HIWORD(v205)) * *(unsigned __int16 *)v14;
            v208 = (v206 + (unsigned __int16)(v202 + HIWORD(v205))) * HIWORD(v205);
            *(_WORD *)v14 = (v207 + HIWORD(v207) + 1) >> 16;
            *v7 = (v208 + HIWORD(v208) + 1) >> 16;
          }
          v16 += v27;
          result = (unint64_t)&v25[2 * v27];
          v209 = &v200[v22];
          if (result >= v12)
            v210 = v195;
          else
            v210 = 0;
          v200 = &v209[v210];
          v25 = (char *)(result + 2 * v210);
          v7 = (_WORD *)((char *)v7 + v199);
          v14 += 2 * v27;
          --v201;
        }
        while (v201);
        if (v28)
        {
          v211 = &v708[2 * v20];
          if ((unint64_t)v211 >= v28)
            v212 = v198;
          else
            v212 = 0;
          v213 = (uint64_t)&v707[v21 + v212];
          if ((unint64_t)v211 >= v28)
            v214 = v197;
          else
            v214 = 0;
          result = v12 + 2 * v214;
          v25 = &v211[2 * v214];
          v12 = result + 2 * v20;
          v707 = (_WORD *)v213;
          v708 = v25;
          v200 = (unsigned __int16 *)v213;
        }
        else
        {
          v25 += 2 * v20;
          v200 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 10:
      v215 = v27;
      v216 = v24;
      v217 = -(v20 * v24);
      v218 = -(uint64_t)(v21 * v216);
      v219 = 2 * v27;
      v220 = v707;
      v221 = -(uint64_t)v23;
      do
      {
        v222 = v10;
        do
        {
          if (*v16)
          {
            v223 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v224 = *(unsigned __int16 *)v25
                 - ((v223 * *(unsigned __int16 *)v25 + ((v223 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            v225 = (v224 | ((*v220 - ((v223 * *v220 + ((v223 * *v220) >> 16) + 1) >> 16)) << 16)) >> 16;
            v226 = (unsigned __int16)*v7 ^ 0xFFFF;
            v227 = (unsigned __int16)v224 * v226 + (v225 ^ 0xFFFF) * *(unsigned __int16 *)v14;
            *(_WORD *)v14 = (v227 + HIWORD(v227) + 1) >> 16;
            *v7 = (((v225 ^ 0xFFFF) + v226) * v225 + ((((v225 ^ 0xFFFF) + v226) * v225) >> 16) + 1) >> 16;
          }
          v16 += v215;
          v228 = &v25[2 * v215];
          v229 = &v220[v22];
          if ((unint64_t)v228 >= v12)
            result = v221;
          else
            result = 0;
          v220 = &v229[result];
          v25 = &v228[2 * result];
          v7 += v8;
          v14 += v219;
          --v222;
        }
        while (v222);
        if (v28)
        {
          v230 = &v708[2 * v20];
          if ((unint64_t)v230 >= v28)
            v231 = v218;
          else
            v231 = 0;
          result = (unint64_t)&v707[v21 + v231];
          if ((unint64_t)v230 >= v28)
            v232 = v217;
          else
            v232 = 0;
          v25 = &v230[2 * v232];
          v12 += 2 * v232 + 2 * v20;
          v707 += v21 + v231;
          v708 = v25;
          v220 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v220 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 11:
      v233 = v27;
      if (v8)
      {
        v234 = v24;
        v235 = -(v20 * v24);
        v236 = -(uint64_t)(v21 * v234);
        v237 = v707;
        v238 = -(uint64_t)v23;
        do
        {
          v239 = v10;
          do
          {
            if (*v16)
            {
              if (v22)
                v240 = *v237;
              else
                v240 = 0xFFFF;
              v241 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v242 = (*(unsigned __int16 *)v25
                    - ((v241 * *(unsigned __int16 *)v25 + ((v241 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16)) | ((v240 - ((v240 * v241 + ((v240 * v241) >> 16) + 1) >> 16)) << 16);
              v243 = (unsigned __int16)*v7;
              v244 = v243
                   - (*(unsigned __int16 *)v14
                    + (unsigned __int16)(*(_WORD *)v25
                                       - ((v241 * *(unsigned __int16 *)v25
                                         + ((v241 * *(unsigned __int16 *)v25) >> 16)
                                         + 1) >> 16)))
                   + HIWORD(v242);
              v245 = v243 + HIWORD(v242);
              if (v244 >= 0xFFFF)
                LOWORD(v244) = -1;
              if (v245 >= 0xFFFF)
                LOWORD(v245) = -1;
              *(_WORD *)v14 = v245 - v244;
              *v7 = v245;
            }
            v16 += v27;
            result = (unint64_t)&v25[2 * v27];
            v246 = &v237[v22];
            if (result >= v12)
              v247 = v238;
            else
              v247 = 0;
            v237 = &v246[v247];
            v25 = (char *)(result + 2 * v247);
            v7 += v8;
            v14 += 2 * v27;
            --v239;
          }
          while (v239);
          if (v28)
          {
            v248 = &v708[2 * v20];
            if ((unint64_t)v248 >= v28)
              v249 = v236;
            else
              v249 = 0;
            v250 = (uint64_t)&v707[v21 + v249];
            if ((unint64_t)v248 >= v28)
              v251 = v235;
            else
              v251 = 0;
            result = v12 + 2 * v251;
            v25 = &v248[2 * v251];
            v12 = result + 2 * v20;
            v707 = (_WORD *)v250;
            v708 = v25;
            v237 = (unsigned __int16 *)v250;
          }
          else
          {
            v25 += 2 * v20;
            v237 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        v624 = -(uint64_t)v23;
        v625 = v24;
        v626 = -(v20 * v24);
        v627 = -(uint64_t)(v21 * v625);
        v628 = v707;
        do
        {
          v629 = v10;
          do
          {
            if (*v16)
            {
              if (v22)
                v630 = *v628;
              else
                v630 = 0xFFFF;
              v631 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v632 = (*(unsigned __int16 *)v14 ^ 0xFFFF)
                   - (unsigned __int16)(*(_WORD *)v25
                                      - ((v631 * *(unsigned __int16 *)v25
                                        + ((v631 * *(unsigned __int16 *)v25) >> 16)
                                        + 1) >> 16))
                   + (((*(unsigned __int16 *)v25
                      - ((v631 * *(unsigned __int16 *)v25 + ((v631 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16)) | ((v630 - ((v630 * v631 + ((v630 * v631) >> 16) + 1) >> 16)) << 16)) >> 16);
              if (v632 >= 0xFFFF)
                LOWORD(v632) = -1;
              *(_WORD *)v14 = ~(_WORD)v632;
            }
            v16 += v233;
            v633 = &v25[2 * v233];
            v634 = &v628[v22];
            if ((unint64_t)v633 >= v12)
              result = v624;
            else
              result = 0;
            v628 = &v634[result];
            v25 = &v633[2 * result];
            v14 += 2 * v233;
            --v629;
          }
          while (v629);
          if (v28)
          {
            v635 = &v708[2 * v20];
            if ((unint64_t)v635 >= v28)
              v636 = v627;
            else
              v636 = 0;
            result = (unint64_t)&v707[v21 + v636];
            if ((unint64_t)v635 >= v28)
              v637 = v626;
            else
              v637 = 0;
            v25 = &v635[2 * v637];
            v12 += 2 * v637 + 2 * v20;
            v707 += v21 + v636;
            v708 = v25;
            v628 = (unsigned __int16 *)result;
          }
          else
          {
            v25 += 2 * v20;
            v628 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 12:
      if (v8)
      {
        v252 = v24;
        v253 = -(v20 * v24);
        v254 = -(uint64_t)(v21 * v252);
        v255 = v707;
        v256 = -(uint64_t)v23;
        do
        {
          v257 = v10;
          do
          {
            if (*v16)
            {
              if (v22)
                v258 = *v255;
              else
                v258 = 0xFFFF;
              v259 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v260 = (*(unsigned __int16 *)v25
                    - ((v259 * *(unsigned __int16 *)v25 + ((v259 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16)) | ((v258 - ((v258 * v259 + ((v258 * v259) >> 16) + 1) >> 16)) << 16);
              v261 = *(unsigned __int16 *)v14
                   + (unsigned __int16)(*(_WORD *)v25
                                      - ((v259 * *(unsigned __int16 *)v25
                                        + ((v259 * *(unsigned __int16 *)v25) >> 16)
                                        + 1) >> 16));
              v262 = (unsigned __int16)*v7 + HIWORD(v260);
              if (v261 >= 0xFFFF)
                LOWORD(v261) = -1;
              if (v262 >= 0xFFFF)
                LOWORD(v262) = -1;
              *(_WORD *)v14 = v261;
              *v7 = v262;
            }
            v16 += v27;
            result = (unint64_t)&v25[2 * v27];
            v263 = &v255[v22];
            if (result >= v12)
              v264 = v256;
            else
              v264 = 0;
            v255 = &v263[v264];
            v25 = (char *)(result + 2 * v264);
            v7 += v8;
            v14 += 2 * v27;
            --v257;
          }
          while (v257);
          if (v28)
          {
            v265 = &v708[2 * v20];
            if ((unint64_t)v265 >= v28)
              v266 = v254;
            else
              v266 = 0;
            v267 = (uint64_t)&v707[v21 + v266];
            if ((unint64_t)v265 >= v28)
              v268 = v253;
            else
              v268 = 0;
            result = v12 + 2 * v268;
            v25 = &v265[2 * v268];
            v12 = result + 2 * v20;
            v707 = (_WORD *)v267;
            v708 = v25;
            v255 = (unsigned __int16 *)v267;
          }
          else
          {
            v25 += 2 * v20;
            v255 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v638 = v10;
          v639 = v16;
          do
          {
            if (*v639)
              *(_WORD *)v14 = (2 * *(_WORD *)v14) | (*(__int16 *)v14 >> 15);
            v639 += v27;
            v14 += 2 * v27;
            --v638;
          }
          while (v638);
          v16 += v27 + v27 * (unint64_t)(v10 - 1) + v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 13:
      v269 = v27;
      v270 = v24;
      v271 = -(uint64_t)v23;
      v272 = -(v20 * v24);
      v273 = -(uint64_t)(v21 * v270);
      v274 = 2 * v8;
      v275 = 2 * v27;
      v276 = v707;
      while (1)
      {
        v277 = v10;
        do
        {
          if (*v16)
          {
            v278 = v22 ? *v276 : 0xFFFF;
            v279 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v280 = *(unsigned __int16 *)v25
                 - ((v279 * *(unsigned __int16 *)v25 + ((v279 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            v281 = v280 | ((v278 - ((v278 * v279 + ((v278 * v279) >> 16) + 1) >> 16)) << 16);
            if (v281 >= 0x10000)
            {
              v282 = HIWORD(v281);
              if (v8)
              {
                v283 = (unsigned __int16)*v7;
                if (!*v7)
                  goto LABEL_349;
              }
              else
              {
                v283 = 0xFFFF;
              }
              v284 = ((v282 ^ 0xFFFF) + (unsigned __int16)v280)
                   * (unint64_t)*(unsigned __int16 *)v14
                   + (v283 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v280;
              v8 = v722;
              if (v284 <= 0xFFFE8000)
                v285 = v284 + 0x8000;
              else
                v285 = 4294868992;
              v286 = v285 + (v285 >> 16);
              if (v722)
              {
                v287 = v286 >> 16;
                v8 = v722;
                v288 = 0xFFFF * (v283 + v282) - v283 * (unint64_t)v282;
                if (v288 <= 4294868992)
                  v282 = v288 + 0x8000;
                else
                  v282 = 4294868992;
                v281 = ((v282 >> 16) + v282) & 0xFFFF0000 | v287;
                LODWORD(v282) = HIWORD(v281);
LABEL_349:
                *(_WORD *)v14 = v281;
                *v7 = v282;
                goto LABEL_351;
              }
              *(_WORD *)v14 = WORD1(v286);
            }
          }
LABEL_351:
          v16 += v269;
          result = (unint64_t)&v25[2 * v269];
          v289 = &v276[v22];
          if (result >= v12)
            v290 = v271;
          else
            v290 = 0;
          v276 = &v289[v290];
          v25 = (char *)(result + 2 * v290);
          v7 = (_WORD *)((char *)v7 + v274);
          v14 += v275;
          --v277;
        }
        while (v277);
        if (v28)
        {
          v291 = &v708[2 * v20];
          if ((unint64_t)v291 >= v28)
            v292 = v273;
          else
            v292 = 0;
          v293 = (uint64_t)&v707[v21 + v292];
          if ((unint64_t)v291 >= v28)
            v294 = v272;
          else
            v294 = 0;
          result = v12 + 2 * v294;
          v25 = &v291[2 * v294];
          v12 = result + 2 * v20;
          v707 = (_WORD *)v293;
          v708 = v25;
          v276 = (unsigned __int16 *)v293;
        }
        else
        {
          v25 += 2 * v20;
          v276 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        if (!--v9)
          return result;
      }
    case 14:
      v295 = v27;
      v296 = v24;
      v297 = -(uint64_t)v23;
      v298 = -(v20 * v24);
      v299 = -(uint64_t)(v21 * v296);
      v300 = 2 * v8;
      v301 = 2 * v27;
      v302 = v707;
      while (1)
      {
        v303 = v10;
        do
        {
          if (*v16)
          {
            v304 = v22 ? *v302 : 0xFFFF;
            v305 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v306 = *(unsigned __int16 *)v25
                 - ((v305 * *(unsigned __int16 *)v25 + ((v305 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            v307 = v306 | ((v304 - ((v304 * v305 + ((v304 * v305) >> 16) + 1) >> 16)) << 16);
            if (v307 >= 0x10000)
            {
              v308 = HIWORD(v307);
              if (v8)
              {
                v309 = (unsigned __int16)*v7;
                if (!*v7)
                  goto LABEL_385;
              }
              else
              {
                v309 = 0xFFFF;
              }
              v8 = v722;
              v310 = (*(unsigned __int16 *)v14 ^ 0xFFFFu) * (unint64_t)(unsigned __int16)v306
                   - *(unsigned __int16 *)v14
                   + ((unint64_t)*(unsigned __int16 *)v14 << 16);
              if (v310 <= 0xFFFE8000)
                v311 = v310 + 0x8000;
              else
                v311 = 4294868992;
              v312 = (v311 + (v311 >> 16)) >> 16;
              if (v722)
              {
                v8 = v722;
                v313 = 0xFFFF * (v309 + (unint64_t)v308) - v309 * (unint64_t)v308;
                if (v313 <= 4294868992)
                  v314 = v313 + 0x8000;
                else
                  v314 = 4294868992;
                v307 = ((v314 >> 16) + v314) & 0xFFFF0000 | v312;
                v308 = HIWORD(v307);
LABEL_385:
                *(_WORD *)v14 = v307;
                *v7 = v308;
                goto LABEL_387;
              }
              *(_WORD *)v14 = v312;
            }
          }
LABEL_387:
          v16 += v295;
          result = (unint64_t)&v25[2 * v295];
          v315 = &v302[v22];
          if (result >= v12)
            v316 = v297;
          else
            v316 = 0;
          v302 = &v315[v316];
          v25 = (char *)(result + 2 * v316);
          v7 = (_WORD *)((char *)v7 + v300);
          v14 += v301;
          --v303;
        }
        while (v303);
        if (v28)
        {
          v317 = &v708[2 * v20];
          if ((unint64_t)v317 >= v28)
            v318 = v299;
          else
            v318 = 0;
          v319 = (uint64_t)&v707[v21 + v318];
          if ((unint64_t)v317 >= v28)
            v320 = v298;
          else
            v320 = 0;
          result = v12 + 2 * v320;
          v25 = &v317[2 * v320];
          v12 = result + 2 * v20;
          v707 = (_WORD *)v319;
          v708 = v25;
          v302 = (unsigned __int16 *)v319;
        }
        else
        {
          v25 += 2 * v20;
          v302 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        if (!--v9)
          return result;
      }
    case 15:
      v321 = v27;
      v322 = v22;
      v652 = -(uint64_t)(v21 * v24);
      v664 = -(v20 * v24);
      v323 = 2 * v8;
      v324 = 2 * v27;
      v325 = v707;
      v326 = -(uint64_t)v23;
      v676 = v22;
      do
      {
        v694 = v9;
        v327 = v10;
        v709 = v12;
        do
        {
          if (*v16)
          {
            v328 = v22 ? *v325 : 0xFFFF;
            v329 = *(unsigned __int16 *)v25;
            v330 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v331 = v330 * v329 + ((v330 * v329) >> 16) + 1;
            result = (v329 - HIWORD(v331)) | ((v328 - ((v328 * v330 + ((v328 * v330) >> 16) + 1) >> 16)) << 16);
            v332 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAoverlayPDA_8071(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v329 - HIWORD(v331)), v332);
                  v322 = v676;
                  v22 = v721;
                  v8 = v722;
                  v12 = v709;
                  v332 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v332;
              }
              else
              {
                result = PDAoverlayPDA_8071(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v329 - HIWORD(v331)), v332);
                v322 = v676;
                v22 = v721;
                v8 = v722;
                v12 = v709;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v321;
          v333 = &v25[2 * v321];
          if ((unint64_t)v333 >= v12)
            v334 = v326;
          else
            v334 = 0;
          v325 += v322 + v334;
          v25 = &v333[2 * v334];
          v7 = (_WORD *)((char *)v7 + v323);
          v14 += v324;
          --v327;
        }
        while (v327);
        if (v693)
        {
          v335 = &v708[2 * v691];
          v336 = v652;
          if ((unint64_t)v335 < v693)
            v336 = 0;
          v325 = &v707[v688 + v336];
          v337 = v664;
          if ((unint64_t)v335 < v693)
            v337 = 0;
          v25 = &v335[2 * v337];
          v12 += 2 * v337 + 2 * v691;
          v707 += v688 + v336;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v325 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v694 - 1;
      }
      while (v694 != 1);
      return result;
    case 16:
      v338 = v27;
      v339 = v22;
      v653 = -(uint64_t)(v21 * v24);
      v665 = -(v20 * v24);
      v340 = 2 * v8;
      v341 = 2 * v27;
      v342 = v707;
      v343 = -(uint64_t)v23;
      v677 = v22;
      do
      {
        v695 = v9;
        v344 = v10;
        v710 = v12;
        do
        {
          if (*v16)
          {
            v345 = v22 ? *v342 : 0xFFFF;
            v346 = *(unsigned __int16 *)v25;
            v347 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v348 = v347 * v346 + ((v347 * v346) >> 16) + 1;
            result = (v346 - HIWORD(v348)) | ((v345 - ((v345 * v347 + ((v345 * v347) >> 16) + 1) >> 16)) << 16);
            v349 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAdarkenPDA_8073(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v346 - HIWORD(v348)), v349);
                  v339 = v677;
                  v22 = v721;
                  v8 = v722;
                  v12 = v710;
                  v349 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v349;
              }
              else
              {
                result = PDAdarkenPDA_8073(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v346 - HIWORD(v348)), v349);
                v339 = v677;
                v22 = v721;
                v8 = v722;
                v12 = v710;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v338;
          v350 = &v25[2 * v338];
          if ((unint64_t)v350 >= v12)
            v351 = v343;
          else
            v351 = 0;
          v342 += v339 + v351;
          v25 = &v350[2 * v351];
          v7 = (_WORD *)((char *)v7 + v340);
          v14 += v341;
          --v344;
        }
        while (v344);
        if (v693)
        {
          v352 = &v708[2 * v691];
          v353 = v653;
          if ((unint64_t)v352 < v693)
            v353 = 0;
          v342 = &v707[v688 + v353];
          v354 = v665;
          if ((unint64_t)v352 < v693)
            v354 = 0;
          v25 = &v352[2 * v354];
          v12 += 2 * v354 + 2 * v691;
          v707 += v688 + v353;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v342 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v695 - 1;
      }
      while (v695 != 1);
      return result;
    case 17:
      v355 = v27;
      v356 = v22;
      v654 = -(uint64_t)(v21 * v24);
      v666 = -(v20 * v24);
      v357 = 2 * v8;
      v358 = 2 * v27;
      v359 = v707;
      v360 = -(uint64_t)v23;
      v678 = v22;
      do
      {
        v696 = v9;
        v361 = v10;
        v711 = v12;
        do
        {
          if (*v16)
          {
            v362 = v22 ? *v359 : 0xFFFF;
            v363 = *(unsigned __int16 *)v25;
            v364 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v365 = v364 * v363 + ((v364 * v363) >> 16) + 1;
            result = (v363 - HIWORD(v365)) | ((v362 - ((v362 * v364 + ((v362 * v364) >> 16) + 1) >> 16)) << 16);
            v366 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAlightenPDA_8072(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v363 - HIWORD(v365)), v366);
                  v356 = v678;
                  v22 = v721;
                  v8 = v722;
                  v12 = v711;
                  v366 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v366;
              }
              else
              {
                result = PDAlightenPDA_8072(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v363 - HIWORD(v365)), v366);
                v356 = v678;
                v22 = v721;
                v8 = v722;
                v12 = v711;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v355;
          v367 = &v25[2 * v355];
          if ((unint64_t)v367 >= v12)
            v368 = v360;
          else
            v368 = 0;
          v359 += v356 + v368;
          v25 = &v367[2 * v368];
          v7 = (_WORD *)((char *)v7 + v357);
          v14 += v358;
          --v361;
        }
        while (v361);
        if (v693)
        {
          v369 = &v708[2 * v691];
          v370 = v654;
          if ((unint64_t)v369 < v693)
            v370 = 0;
          v359 = &v707[v688 + v370];
          v371 = v666;
          if ((unint64_t)v369 < v693)
            v371 = 0;
          v25 = &v369[2 * v371];
          v12 += 2 * v371 + 2 * v691;
          v707 += v688 + v370;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v359 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v696 - 1;
      }
      while (v696 != 1);
      return result;
    case 18:
      v372 = v27;
      v373 = v22;
      v655 = -(uint64_t)(v21 * v24);
      v667 = -(v20 * v24);
      v374 = 2 * v8;
      v375 = 2 * v27;
      v376 = v707;
      v377 = -(uint64_t)v23;
      v679 = v22;
      do
      {
        v697 = v9;
        v378 = v10;
        v712 = v12;
        do
        {
          if (*v16)
          {
            v379 = v22 ? *v376 : 0xFFFF;
            v380 = *(unsigned __int16 *)v25;
            v381 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v382 = v381 * v380 + ((v381 * v380) >> 16) + 1;
            result = (v380 - HIWORD(v382)) | ((v379 - ((v379 * v381 + ((v379 * v381) >> 16) + 1) >> 16)) << 16);
            v383 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAcolordodgePDA_8074(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v380 - HIWORD(v382)), v383);
                  v373 = v679;
                  v22 = v721;
                  v8 = v722;
                  v12 = v712;
                  v383 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v383;
              }
              else
              {
                result = PDAcolordodgePDA_8074(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v380 - HIWORD(v382)), v383);
                v373 = v679;
                v22 = v721;
                v8 = v722;
                v12 = v712;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v372;
          v384 = &v25[2 * v372];
          if ((unint64_t)v384 >= v12)
            v385 = v377;
          else
            v385 = 0;
          v376 += v373 + v385;
          v25 = &v384[2 * v385];
          v7 = (_WORD *)((char *)v7 + v374);
          v14 += v375;
          --v378;
        }
        while (v378);
        if (v693)
        {
          v386 = &v708[2 * v691];
          v387 = v655;
          if ((unint64_t)v386 < v693)
            v387 = 0;
          v376 = &v707[v688 + v387];
          v388 = v667;
          if ((unint64_t)v386 < v693)
            v388 = 0;
          v25 = &v386[2 * v388];
          v12 += 2 * v388 + 2 * v691;
          v707 += v688 + v387;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v376 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v697 - 1;
      }
      while (v697 != 1);
      return result;
    case 19:
      v389 = v27;
      v390 = v22;
      v656 = -(uint64_t)(v21 * v24);
      v668 = -(v20 * v24);
      v391 = 2 * v8;
      v392 = 2 * v27;
      v393 = v707;
      v394 = -(uint64_t)v23;
      v680 = v22;
      do
      {
        v698 = v9;
        v395 = v10;
        v713 = v12;
        do
        {
          if (*v16)
          {
            v396 = v22 ? *v393 : 0xFFFF;
            v397 = *(unsigned __int16 *)v25;
            v398 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v399 = v398 * v397 + ((v398 * v397) >> 16) + 1;
            result = (v397 - HIWORD(v399)) | ((v396 - ((v396 * v398 + ((v396 * v398) >> 16) + 1) >> 16)) << 16);
            v400 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAcolorburnPDA_8075(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v397 - HIWORD(v399)), v400);
                  v390 = v680;
                  v22 = v721;
                  v8 = v722;
                  v12 = v713;
                  v400 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v400;
              }
              else
              {
                result = PDAcolorburnPDA_8075(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v397 - HIWORD(v399)), v400);
                v390 = v680;
                v22 = v721;
                v8 = v722;
                v12 = v713;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v389;
          v401 = &v25[2 * v389];
          if ((unint64_t)v401 >= v12)
            v402 = v394;
          else
            v402 = 0;
          v393 += v390 + v402;
          v25 = &v401[2 * v402];
          v7 = (_WORD *)((char *)v7 + v391);
          v14 += v392;
          --v395;
        }
        while (v395);
        if (v693)
        {
          v403 = &v708[2 * v691];
          v404 = v656;
          if ((unint64_t)v403 < v693)
            v404 = 0;
          v393 = &v707[v688 + v404];
          v405 = v668;
          if ((unint64_t)v403 < v693)
            v405 = 0;
          v25 = &v403[2 * v405];
          v12 += 2 * v405 + 2 * v691;
          v707 += v688 + v404;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v393 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v698 - 1;
      }
      while (v698 != 1);
      return result;
    case 20:
      v406 = v27;
      v407 = v22;
      v657 = -(uint64_t)(v21 * v24);
      v669 = -(v20 * v24);
      v408 = 2 * v8;
      v409 = 2 * v27;
      v410 = v707;
      v411 = -(uint64_t)v23;
      v681 = v22;
      do
      {
        v699 = v9;
        v412 = v10;
        v714 = v12;
        do
        {
          if (*v16)
          {
            v413 = v22 ? *v410 : 0xFFFF;
            v414 = *(unsigned __int16 *)v25;
            v415 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v416 = v415 * v414 + ((v415 * v414) >> 16) + 1;
            result = (v414 - HIWORD(v416)) | ((v413 - ((v413 * v415 + ((v413 * v415) >> 16) + 1) >> 16)) << 16);
            v417 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAsoftlightPDA_8077(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v414 - HIWORD(v416)), v417);
                  v407 = v681;
                  v22 = v721;
                  v8 = v722;
                  v12 = v714;
                  v417 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v417;
              }
              else
              {
                result = PDAsoftlightPDA_8077(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v414 - HIWORD(v416)), v417);
                v407 = v681;
                v22 = v721;
                v8 = v722;
                v12 = v714;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v406;
          v418 = &v25[2 * v406];
          if ((unint64_t)v418 >= v12)
            v419 = v411;
          else
            v419 = 0;
          v410 += v407 + v419;
          v25 = &v418[2 * v419];
          v7 = (_WORD *)((char *)v7 + v408);
          v14 += v409;
          --v412;
        }
        while (v412);
        if (v693)
        {
          v420 = &v708[2 * v691];
          v421 = v657;
          if ((unint64_t)v420 < v693)
            v421 = 0;
          v410 = &v707[v688 + v421];
          v422 = v669;
          if ((unint64_t)v420 < v693)
            v422 = 0;
          v25 = &v420[2 * v422];
          v12 += 2 * v422 + 2 * v691;
          v707 += v688 + v421;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v410 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v699 - 1;
      }
      while (v699 != 1);
      return result;
    case 21:
      v423 = v27;
      v424 = v22;
      v658 = -(uint64_t)(v21 * v24);
      v670 = -(v20 * v24);
      v425 = 2 * v8;
      v426 = 2 * v27;
      v427 = v707;
      v428 = -(uint64_t)v23;
      v682 = v22;
      do
      {
        v700 = v9;
        v429 = v10;
        v715 = v12;
        do
        {
          if (*v16)
          {
            v430 = v22 ? *v427 : 0xFFFF;
            v431 = *(unsigned __int16 *)v25;
            v432 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v433 = v432 * v431 + ((v432 * v431) >> 16) + 1;
            result = (v431 - HIWORD(v433)) | ((v430 - ((v430 * v432 + ((v430 * v432) >> 16) + 1) >> 16)) << 16);
            v434 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAhardlightPDA_8076(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v431 - HIWORD(v433)), v434);
                  v424 = v682;
                  v22 = v721;
                  v8 = v722;
                  v12 = v715;
                  v434 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v434;
              }
              else
              {
                result = PDAhardlightPDA_8076(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v431 - HIWORD(v433)), v434);
                v424 = v682;
                v22 = v721;
                v8 = v722;
                v12 = v715;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v423;
          v435 = &v25[2 * v423];
          if ((unint64_t)v435 >= v12)
            v436 = v428;
          else
            v436 = 0;
          v427 += v424 + v436;
          v25 = &v435[2 * v436];
          v7 = (_WORD *)((char *)v7 + v425);
          v14 += v426;
          --v429;
        }
        while (v429);
        if (v693)
        {
          v437 = &v708[2 * v691];
          v438 = v658;
          if ((unint64_t)v437 < v693)
            v438 = 0;
          v427 = &v707[v688 + v438];
          v439 = v670;
          if ((unint64_t)v437 < v693)
            v439 = 0;
          v25 = &v437[2 * v439];
          v12 += 2 * v439 + 2 * v691;
          v707 += v688 + v438;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v427 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v700 - 1;
      }
      while (v700 != 1);
      return result;
    case 22:
      v440 = v27;
      v441 = v22;
      v659 = -(uint64_t)(v21 * v24);
      v671 = -(v20 * v24);
      v442 = 2 * v8;
      v443 = 2 * v27;
      v444 = v707;
      v445 = -(uint64_t)v23;
      v683 = v22;
      do
      {
        v701 = v9;
        v446 = v10;
        v716 = v12;
        do
        {
          if (*v16)
          {
            v447 = v22 ? *v444 : 0xFFFF;
            v448 = *(unsigned __int16 *)v25;
            v449 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v450 = v449 * v448 + ((v449 * v448) >> 16) + 1;
            result = (v448 - HIWORD(v450)) | ((v447 - ((v447 * v449 + ((v447 * v449) >> 16) + 1) >> 16)) << 16);
            v451 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAdifferencePDA_8078(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v448 - HIWORD(v450)), v451);
                  v441 = v683;
                  v22 = v721;
                  v8 = v722;
                  v12 = v716;
                  v451 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v451;
              }
              else
              {
                result = PDAdifferencePDA_8078(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v448 - HIWORD(v450)), v451);
                v441 = v683;
                v22 = v721;
                v8 = v722;
                v12 = v716;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v440;
          v452 = &v25[2 * v440];
          if ((unint64_t)v452 >= v12)
            v453 = v445;
          else
            v453 = 0;
          v444 += v441 + v453;
          v25 = &v452[2 * v453];
          v7 = (_WORD *)((char *)v7 + v442);
          v14 += v443;
          --v446;
        }
        while (v446);
        if (v693)
        {
          v454 = &v708[2 * v691];
          v455 = v659;
          if ((unint64_t)v454 < v693)
            v455 = 0;
          v444 = &v707[v688 + v455];
          v456 = v671;
          if ((unint64_t)v454 < v693)
            v456 = 0;
          v25 = &v454[2 * v456];
          v12 += 2 * v456 + 2 * v691;
          v707 += v688 + v455;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v444 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v701 - 1;
      }
      while (v701 != 1);
      return result;
    case 23:
      v457 = v27;
      v458 = v22;
      v459 = v24;
      v460 = -(uint64_t)v23;
      v461 = -(v20 * v24);
      v462 = -(uint64_t)(v21 * v459);
      v463 = 2 * v8;
      v464 = 2 * v27;
      v465 = v707;
      break;
    case 24:
      v487 = v27;
      v488 = v22;
      v660 = -(uint64_t)(v21 * v24);
      v672 = -(v20 * v24);
      v489 = 2 * v8;
      v490 = 2 * v27;
      v491 = v707;
      v492 = -(uint64_t)v23;
      v684 = v22;
      do
      {
        v702 = v9;
        v493 = v10;
        v717 = v12;
        do
        {
          if (*v16)
          {
            v494 = v22 ? *v491 : 0xFFFF;
            v495 = *(unsigned __int16 *)v25;
            v496 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v497 = v496 * v495 + ((v496 * v495) >> 16) + 1;
            result = (v495 - HIWORD(v497)) | ((v494 - ((v494 * v496 + ((v494 * v496) >> 16) + 1) >> 16)) << 16);
            v498 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAhuePDA_8079(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v495 - HIWORD(v497)), v498);
                  v488 = v684;
                  v22 = v721;
                  v8 = v722;
                  v12 = v717;
                  v498 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v498;
              }
              else
              {
                result = PDAhuePDA_8079(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v495 - HIWORD(v497)), v498);
                v488 = v684;
                v22 = v721;
                v8 = v722;
                v12 = v717;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v487;
          v499 = &v25[2 * v487];
          if ((unint64_t)v499 >= v12)
            v500 = v492;
          else
            v500 = 0;
          v491 += v488 + v500;
          v25 = &v499[2 * v500];
          v7 = (_WORD *)((char *)v7 + v489);
          v14 += v490;
          --v493;
        }
        while (v493);
        if (v693)
        {
          v501 = &v708[2 * v691];
          v502 = v660;
          if ((unint64_t)v501 < v693)
            v502 = 0;
          v491 = &v707[v688 + v502];
          v503 = v672;
          if ((unint64_t)v501 < v693)
            v503 = 0;
          v25 = &v501[2 * v503];
          v12 += 2 * v503 + 2 * v691;
          v707 += v688 + v502;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v491 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v702 - 1;
      }
      while (v702 != 1);
      return result;
    case 25:
      v504 = v27;
      v505 = v22;
      v661 = -(uint64_t)(v21 * v24);
      v673 = -(v20 * v24);
      v506 = 2 * v8;
      v507 = 2 * v27;
      v508 = v707;
      v509 = -(uint64_t)v23;
      v685 = v22;
      do
      {
        v703 = v9;
        v510 = v10;
        v718 = v12;
        do
        {
          if (*v16)
          {
            v511 = v22 ? *v508 : 0xFFFF;
            v512 = *(unsigned __int16 *)v25;
            v513 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v514 = v513 * v512 + ((v513 * v512) >> 16) + 1;
            result = (v512 - HIWORD(v514)) | ((v511 - ((v511 * v513 + ((v511 * v513) >> 16) + 1) >> 16)) << 16);
            v515 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAhuePDA_8079(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v512 - HIWORD(v514)), v515);
                  v505 = v685;
                  v22 = v721;
                  v8 = v722;
                  v12 = v718;
                  v515 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v515;
              }
              else
              {
                result = PDAhuePDA_8079(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v512 - HIWORD(v514)), v515);
                v505 = v685;
                v22 = v721;
                v8 = v722;
                v12 = v718;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v504;
          v516 = &v25[2 * v504];
          if ((unint64_t)v516 >= v12)
            v517 = v509;
          else
            v517 = 0;
          v508 += v505 + v517;
          v25 = &v516[2 * v517];
          v7 = (_WORD *)((char *)v7 + v506);
          v14 += v507;
          --v510;
        }
        while (v510);
        if (v693)
        {
          v518 = &v708[2 * v691];
          v519 = v661;
          if ((unint64_t)v518 < v693)
            v519 = 0;
          v508 = &v707[v688 + v519];
          v520 = v673;
          if ((unint64_t)v518 < v693)
            v520 = 0;
          v25 = &v518[2 * v520];
          v12 += 2 * v520 + 2 * v691;
          v707 += v688 + v519;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v508 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v703 - 1;
      }
      while (v703 != 1);
      return result;
    case 26:
      v521 = v27;
      v522 = v22;
      v662 = -(uint64_t)(v21 * v24);
      v674 = -(v20 * v24);
      v523 = 2 * v8;
      v524 = 2 * v27;
      v525 = v707;
      v526 = -(uint64_t)v23;
      v686 = v22;
      do
      {
        v704 = v9;
        v527 = v10;
        v719 = v12;
        do
        {
          if (*v16)
          {
            v528 = v22 ? *v525 : 0xFFFF;
            v529 = *(unsigned __int16 *)v25;
            v530 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v531 = v530 * v529 + ((v530 * v529) >> 16) + 1;
            result = (v529 - HIWORD(v531)) | ((v528 - ((v528 * v530 + ((v528 * v530) >> 16) + 1) >> 16)) << 16);
            v532 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAluminosityPDA_8081((unsigned __int16)(v529 - HIWORD(v531)), v532, *(unsigned __int16 *)v14, (unsigned __int16)*v7);
                  v522 = v686;
                  v22 = v721;
                  v8 = v722;
                  v12 = v719;
                  v532 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v532;
              }
              else
              {
                result = PDAluminosityPDA_8081((unsigned __int16)(v529 - HIWORD(v531)), v532, *(unsigned __int16 *)v14, 0xFFFFu);
                v522 = v686;
                v22 = v721;
                v8 = v722;
                v12 = v719;
                *(_WORD *)v14 = result;
              }
            }
          }
          v16 += v521;
          v533 = &v25[2 * v521];
          if ((unint64_t)v533 >= v12)
            v534 = v526;
          else
            v534 = 0;
          v525 += v522 + v534;
          v25 = &v533[2 * v534];
          v7 = (_WORD *)((char *)v7 + v523);
          v14 += v524;
          --v527;
        }
        while (v527);
        if (v693)
        {
          v535 = &v708[2 * v691];
          v536 = v662;
          if ((unint64_t)v535 < v693)
            v536 = 0;
          v525 = &v707[v688 + v536];
          v537 = v674;
          if ((unint64_t)v535 < v693)
            v537 = 0;
          v25 = &v535[2 * v537];
          v12 += 2 * v537 + 2 * v691;
          v707 += v688 + v536;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v525 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v704 - 1;
      }
      while (v704 != 1);
      return result;
    case 27:
      v538 = v27;
      v539 = v22;
      v663 = -(uint64_t)(v21 * v24);
      v675 = -(v20 * v24);
      v540 = 2 * v8;
      v541 = 2 * v27;
      v542 = v707;
      v543 = -(uint64_t)v23;
      v720 = v27;
      v687 = v540;
      do
      {
        v705 = v9;
        v544 = v10;
        do
        {
          if (*v16)
          {
            v545 = v22 ? *v542 : 0xFFFF;
            v546 = *(unsigned __int16 *)v25;
            v547 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v548 = v547 * v546 + ((v547 * v546) >> 16) + 1;
            result = (v546 - HIWORD(v548)) | ((v545 - ((v545 * v547 + ((v545 * v547) >> 16) + 1) >> 16)) << 16);
            v549 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  result = PDAluminosityPDA_8081(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v546 - HIWORD(v548)), v549);
                  v538 = v720;
                  v540 = v687;
                  v22 = v721;
                  v8 = v722;
                  v549 = WORD1(result);
                }
                *(_WORD *)v14 = result;
                *v7 = v549;
              }
              else
              {
                v550 = (unsigned __int16)(v546 - HIWORD(v548));
                if (v550 >= WORD1(result))
                  LOWORD(v550) = WORD1(result);
                v551 = *(unsigned __int16 *)v14 * (unint64_t)(v549 ^ 0xFFFF) + 0x8000;
                *(_WORD *)v14 = v550 + (((v551 >> 16) + v551) >> 16);
              }
            }
          }
          v16 += v538;
          v552 = &v25[2 * v538];
          if ((unint64_t)v552 >= v12)
            v553 = v543;
          else
            v553 = 0;
          v542 += v539 + v553;
          v25 = &v552[2 * v553];
          v7 = (_WORD *)((char *)v7 + v540);
          v14 += v541;
          --v544;
        }
        while (v544);
        if (v693)
        {
          v554 = &v708[2 * v20];
          v555 = v663;
          if ((unint64_t)v554 < v693)
            v555 = 0;
          v542 = &v707[v688 + v555];
          v556 = v675;
          if ((unint64_t)v554 < v693)
            v556 = 0;
          v25 = &v554[2 * v556];
          v12 += 2 * v556 + 2 * v20;
          v707 += v688 + v555;
          v708 = v25;
        }
        else
        {
          v25 += 2 * v20;
          v542 += v688;
        }
        v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        v9 = v705 - 1;
      }
      while (v705 != 1);
      return result;
    default:
      return result;
  }
  do
  {
    v466 = v10;
    do
    {
      if (*v16)
      {
        v467 = v22 ? *v465 : 0xFFFF;
        v468 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        v469 = *(unsigned __int16 *)v25
             - ((v468 * *(unsigned __int16 *)v25 + ((v468 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
        v470 = v469 | ((v467 - ((v467 * v468 + ((v467 * v468) >> 16) + 1) >> 16)) << 16);
        v471 = HIWORD(v470);
        if (HIWORD(v470))
        {
          if (v8)
          {
            v472 = (unsigned __int16)*v7;
            if (!*v7)
              goto LABEL_627;
          }
          else
          {
            v472 = 0xFFFF;
          }
          if ((unsigned __int16)v469 >= HIWORD(v470))
            v473 = v471;
          else
            v473 = (unsigned __int16)v469;
          if (*(unsigned __int16 *)v14 >= v472)
            v474 = v472;
          else
            v474 = *(unsigned __int16 *)v14;
          v475 = 0xFFFF * (v474 + v473) - 2 * v473 * (unint64_t)v474;
          v8 = v722;
          if (v475 <= 4294868992)
            v476 = v475 + 0x8000;
          else
            v476 = 4294868992;
          v477 = v476 + (v476 >> 16);
          if (v722)
          {
            v478 = v477 >> 16;
            v22 = v721;
            v8 = v722;
            v479 = 0xFFFF * (v472 + (unint64_t)v471) - v472 * (unint64_t)v471;
            if (v479 <= 4294868992)
              v480 = v479 + 0x8000;
            else
              v480 = 4294868992;
            v470 = ((v480 >> 16) + v480) & 0xFFFF0000 | v478;
            v471 = HIWORD(v470);
LABEL_627:
            *(_WORD *)v14 = v470;
            *v7 = v471;
            goto LABEL_629;
          }
          *(_WORD *)v14 = WORD1(v477);
          v22 = v721;
        }
      }
LABEL_629:
      v16 += v457;
      result = (unint64_t)&v25[2 * v457];
      v481 = &v465[v458];
      if (result >= v12)
        v482 = v460;
      else
        v482 = 0;
      v465 = &v481[v482];
      v25 = (char *)(result + 2 * v482);
      v7 = (_WORD *)((char *)v7 + v463);
      v14 += v464;
      --v466;
    }
    while (v466);
    if (v28)
    {
      v483 = &v708[2 * v20];
      if ((unint64_t)v483 >= v28)
        v484 = v462;
      else
        v484 = 0;
      v485 = (uint64_t)&v707[v21 + v484];
      if ((unint64_t)v483 >= v28)
        v486 = v461;
      else
        v486 = 0;
      result = v12 + 2 * v486;
      v25 = &v483[2 * v486];
      v12 = result + 2 * v20;
      v707 = (_WORD *)v485;
      v708 = v25;
      v465 = (unsigned __int16 *)v485;
    }
    else
    {
      v25 += 2 * v20;
      v465 += v21;
    }
    v16 += v33;
    v14 += 2 * v34;
    v7 += v706;
    --v9;
  }
  while (v9);
  return result;
}

uint64_t PIXELCONSTANT_8085(float *a1, int a2, float *a3, float a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  int v9;
  int v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  BOOL v23;
  float v24;
  float v25;

  v4 = *a1;
  v5 = a1[1];
  v6 = v5;
  if (v5 >= a4)
  {
    v6 = a4;
    if (v4 > a4)
      v6 = *a1;
  }
  v7 = a1[3];
  v8 = v6 * a1[2];
  if (a3)
    v9 = a2;
  else
    v9 = 0;
  if (v9 == 4)
  {
    v15 = a3[4];
    v16 = *a3;
    v17 = a1[1];
    if (v15 <= v5)
    {
      v17 = a3[4];
      if (v15 < v4)
        v17 = *a1;
    }
    v19 = a3[1];
    v18 = a3[2];
    v20 = a1[1];
    if (v16 <= v5)
    {
      v20 = *a3;
      if (v16 < v4)
        v20 = *a1;
    }
    if (v19 < v4)
      v21 = *a1;
    else
      v21 = a3[1];
    if (v19 > v5)
      v21 = a1[1];
    if (v18 < v4)
      v22 = *a1;
    else
      v22 = a3[2];
    v23 = v18 <= v5;
    v24 = v5 - (float)(a1[4] * v20);
    if (v23)
      v5 = v22;
    v25 = (float)((float)(v24 - (float)(a1[5] * v21)) - (float)(a1[6] * v5)) - v17;
    if (v25 >= v4)
      v4 = v7 + (float)(v25 * v8);
    goto LABEL_46;
  }
  if (v9 == 3)
  {
    v11 = a3[1];
    v12 = a1[1];
    if (*a3 <= v5)
    {
      v12 = *a3;
      if (*a3 < v4)
        v12 = *a1;
    }
    v13 = a3[2];
    v14 = a1[1];
    if (v11 <= v5)
    {
      v14 = a3[1];
      if (v11 < v4)
        v14 = *a1;
    }
    if (v13 >= v4)
      v4 = a3[2];
    if (v13 > v5)
      v4 = a1[1];
    v4 = (float)((float)(v14 * a1[5]) + (float)(a1[4] * v12)) + (float)(a1[6] * v4);
    goto LABEL_26;
  }
  v10 = 0;
  if (v9 == 1)
  {
    if (*a3 >= v4)
      v4 = *a3;
    if (*a3 > v5)
      v4 = a1[1];
LABEL_26:
    v4 = v7 + (float)(v4 * v8);
LABEL_46:
    v10 = (int)v4;
  }
  return v10 | ((int)(float)(v7 + v8) << 16);
}

_DWORD *W16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8;

  v8 = PIXELCONSTANT_8085(*(float **)(*(_QWORD *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_185004DB0;
    a2[6] = 0;
    *((_QWORD *)a2 + 2) = 1;
    a2[12] = bswap32((unsigned __int16)v8 | ((unsigned __int16)v8 << 16));
    *((_QWORD *)a2 + 4) = a2 + 12;
    if (HIWORD(v8) == 0xFFFF)
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = bswap32(v8 & 0xFFFF0000 | HIWORD(v8));
      *((_QWORD *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t W16_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unint64_t v3;
  int8x8_t v4;
  unsigned int *v5;
  uint64_t v6;
  int v7;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint16x4_t *v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  unsigned int v26;
  size_t v27;
  _BYTE *v28;
  _BYTE *v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  int8x8_t *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  void *v53;
  _WORD *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  char *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  int v67;
  _BYTE *v68;
  _WORD *v69;
  uint64_t v70;
  _BYTE *v71;
  unsigned int v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  _WORD *v87;
  uint64_t v88;
  _WORD *v89;
  BOOL v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  int v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  int v100;
  _WORD *v101;
  uint64_t v102;
  _WORD *v103;
  BOOL v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  _WORD *v114;
  uint64_t v115;
  _WORD *v116;
  BOOL v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  int v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  _WORD *v128;
  uint64_t v129;
  _WORD *v130;
  BOOL v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  int v142;
  unsigned int v143;
  _WORD *v144;
  uint64_t v145;
  _WORD *v146;
  BOOL v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  int v157;
  _WORD *v158;
  uint64_t v159;
  _WORD *v160;
  BOOL v161;
  uint64_t v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  int v166;
  int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  _WORD *v172;
  uint64_t v173;
  _WORD *v174;
  BOOL v175;
  uint64_t v176;
  unint64_t v177;
  uint64_t v178;
  uint64_t v179;
  int v180;
  int v181;
  unsigned int v182;
  unsigned int v183;
  unsigned int v184;
  _WORD *v185;
  uint64_t v186;
  _WORD *v187;
  BOOL v188;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  int v194;
  unsigned int v195;
  unsigned int v196;
  unsigned int v197;
  _WORD *v198;
  uint64_t v199;
  _WORD *v200;
  BOOL v201;
  uint64_t v202;
  unint64_t v203;
  uint64_t v204;
  int v205;
  int v206;
  unsigned int v207;
  unsigned int v208;
  int v209;
  unsigned int v210;
  _WORD *v211;
  uint64_t v212;
  _WORD *v213;
  BOOL v214;
  uint64_t v215;
  unint64_t v216;
  uint64_t v217;
  int v218;
  int v219;
  unsigned int v220;
  unsigned int v221;
  unsigned int v222;
  _WORD *v223;
  uint64_t v224;
  _WORD *v225;
  BOOL v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t v229;
  int v230;
  int v231;
  unint64_t v232;
  unsigned int v233;
  unsigned int v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  int64_t v238;
  unint64_t v239;
  char *v240;
  _WORD *v241;
  uint64_t v242;
  _WORD *v243;
  BOOL v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  int v248;
  int v249;
  unint64_t v250;
  unsigned int v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  int64_t v256;
  unint64_t v257;
  char *v258;
  _WORD *v259;
  uint64_t v260;
  _WORD *v261;
  BOOL v262;
  uint64_t v263;
  unint64_t v264;
  uint64_t v265;
  uint64_t v266;
  int v267;
  uint64_t v268;
  int v269;
  unint64_t v270;
  unsigned int v271;
  unsigned int v272;
  unsigned int v273;
  _WORD *v274;
  uint64_t v275;
  _WORD *v276;
  BOOL v277;
  uint64_t v278;
  unint64_t v279;
  uint64_t v280;
  uint64_t v281;
  int v282;
  uint64_t v283;
  int v284;
  unint64_t v285;
  unsigned int v286;
  unsigned int v287;
  unsigned int v288;
  _WORD *v289;
  uint64_t v290;
  _WORD *v291;
  BOOL v292;
  uint64_t v293;
  unint64_t v294;
  uint64_t v295;
  uint64_t v296;
  int v297;
  uint64_t v298;
  int v299;
  unint64_t v300;
  unsigned int v301;
  unsigned int v302;
  unsigned int v303;
  _WORD *v304;
  uint64_t v305;
  _WORD *v306;
  BOOL v307;
  uint64_t v308;
  unint64_t v309;
  uint64_t v310;
  uint64_t v311;
  int v312;
  uint64_t v313;
  int v314;
  unint64_t v315;
  unsigned int v316;
  unsigned int v317;
  unsigned int v318;
  _WORD *v319;
  uint64_t v320;
  _WORD *v321;
  BOOL v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  uint64_t v326;
  int v327;
  uint64_t v328;
  int v329;
  unint64_t v330;
  unsigned int v331;
  unsigned int v332;
  unsigned int v333;
  _WORD *v334;
  uint64_t v335;
  _WORD *v336;
  BOOL v337;
  uint64_t v338;
  unint64_t v339;
  uint64_t v340;
  uint64_t v341;
  int v342;
  uint64_t v343;
  int v344;
  unint64_t v345;
  unsigned int v346;
  unsigned int v347;
  unsigned int v348;
  _WORD *v349;
  uint64_t v350;
  _WORD *v351;
  BOOL v352;
  uint64_t v353;
  unint64_t v354;
  uint64_t v355;
  uint64_t v356;
  int v357;
  uint64_t v358;
  int v359;
  unint64_t v360;
  unsigned int v361;
  unsigned int v362;
  unsigned int v363;
  _WORD *v364;
  uint64_t v365;
  _WORD *v366;
  BOOL v367;
  uint64_t v368;
  unint64_t v369;
  uint64_t v370;
  uint64_t v371;
  int v372;
  uint64_t v373;
  int v374;
  unint64_t v375;
  unsigned int v376;
  unsigned int v377;
  unsigned int v378;
  _WORD *v379;
  uint64_t v380;
  _WORD *v381;
  BOOL v382;
  uint64_t v383;
  unint64_t v384;
  uint64_t v385;
  int v386;
  int v387;
  unint64_t v388;
  unsigned int v389;
  uint64_t v390;
  uint64_t v391;
  int64_t v392;
  unint64_t v393;
  unint64_t v394;
  int64_t v395;
  unint64_t v396;
  char *v397;
  _WORD *v398;
  uint64_t v399;
  _WORD *v400;
  BOOL v401;
  uint64_t v402;
  unint64_t v403;
  uint64_t v404;
  uint64_t v405;
  int v406;
  uint64_t v407;
  int v408;
  unint64_t v409;
  unsigned int v410;
  unsigned int v411;
  unsigned int v412;
  _WORD *v413;
  uint64_t v414;
  _WORD *v415;
  BOOL v416;
  uint64_t v417;
  unint64_t v418;
  uint64_t v419;
  uint64_t v420;
  int v421;
  uint64_t v422;
  int v423;
  unint64_t v424;
  unsigned int v425;
  unsigned int v426;
  unsigned int v427;
  _WORD *v428;
  uint64_t v429;
  _WORD *v430;
  BOOL v431;
  uint64_t v432;
  unint64_t v433;
  uint64_t v434;
  uint64_t v435;
  int v436;
  uint64_t v437;
  int v438;
  unint64_t v439;
  unsigned int v440;
  unsigned int v441;
  unsigned int v442;
  _WORD *v443;
  uint64_t v444;
  _WORD *v445;
  BOOL v446;
  uint64_t v447;
  unint64_t v448;
  uint64_t v449;
  uint64_t v450;
  int v451;
  uint64_t v452;
  int v453;
  unint64_t v454;
  unsigned int v455;
  unsigned int v456;
  unsigned int v457;
  _WORD *v458;
  uint64_t v459;
  _WORD *v460;
  BOOL v461;
  uint64_t v462;
  unint64_t v463;
  uint64_t v464;
  uint64_t v465;
  int v466;
  int v467;
  unsigned int v468;
  unsigned int v469;
  unsigned int v470;
  _WORD *v471;
  uint64_t v472;
  _WORD *v473;
  BOOL v474;
  uint64_t v475;
  unint64_t v476;
  uint64_t v477;
  int v478;
  int v479;
  unsigned int v480;
  unsigned int v481;
  _WORD *v482;
  uint64_t v483;
  _WORD *v484;
  BOOL v485;
  uint64_t v486;
  unint64_t v487;
  uint64_t v488;
  uint64_t v489;
  int v490;
  int v491;
  unsigned int v492;
  unsigned int v493;
  _WORD *v494;
  uint64_t v495;
  _WORD *v496;
  BOOL v497;
  uint64_t v498;
  unint64_t v499;
  uint64_t v500;
  int v501;
  int v502;
  unsigned int v503;
  unsigned int v504;
  unsigned int v505;
  _WORD *v506;
  uint64_t v507;
  _WORD *v508;
  BOOL v509;
  uint64_t v510;
  unint64_t v511;
  uint64_t v512;
  int v513;
  int v514;
  unsigned int v515;
  signed int v516;
  _WORD *v517;
  uint64_t v518;
  _WORD *v519;
  BOOL v520;
  uint64_t v521;
  unint64_t v522;
  uint64_t v523;
  uint64_t v524;
  int v525;
  int v526;
  int v527;
  _WORD *v528;
  uint64_t v529;
  _WORD *v530;
  BOOL v531;
  uint64_t v532;
  unint64_t v533;
  uint64_t v534;
  uint8x8_t v535;
  int v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  int v540;
  int v541;
  _WORD *v542;
  uint64_t v543;
  _WORD *v544;
  BOOL v545;
  uint64_t v546;
  unint64_t v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  int v551;
  int v552;
  _WORD *v553;
  uint64_t v554;
  _WORD *v555;
  BOOL v556;
  uint64_t v557;
  unint64_t v558;
  uint64_t v559;
  int v560;
  int v561;
  _WORD *v562;
  uint64_t v563;
  _WORD *v564;
  BOOL v565;
  uint64_t v566;
  unint64_t v567;
  uint64_t v568;
  int v569;
  int v570;
  _WORD *v571;
  unint64_t v572;
  uint64_t v573;
  int v574;
  int v575;
  unint64_t v576;
  uint64_t v577;
  unint64_t v578;
  unint64_t v579;
  int v580;
  uint64_t v581;
  unint64_t v582;
  char *v583;
  char *v584;
  uint64_t v585;
  int v586;
  int v587;
  uint64_t v588;
  char *v589;
  uint64_t v590;
  char *v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  char *v595;
  uint64_t v596;
  unint64_t v597;
  uint64_t v598;
  unsigned int v599;
  int v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  int v606;
  int *v607;
  signed int v608;
  int *v609;
  uint64_t v610;
  uint64_t v611;
  int v612;
  unsigned int v613;
  unsigned int v614;
  unsigned int v615;
  unsigned int v616;
  unsigned int v617;
  unsigned int v618;
  unsigned int v619;
  unsigned int v620;
  unsigned int v621;
  unsigned int v622;
  unsigned int v623;
  int v624;
  unsigned int v625;
  unsigned int v626;
  unsigned int v627;
  __int16 v628;
  int v629;
  int v630;
  unsigned int v631;
  int v632;
  __int16 v633;
  int v634;
  int v635;
  unsigned int v636;
  unsigned int v637;
  int v638;
  int v639;
  unsigned int v640;
  unsigned int v641;
  __int16 v642;
  int v643;
  int v644;
  unsigned int v645;
  unsigned int v646;
  unsigned int v647;
  int v648;
  int v649;
  uint64_t v650;
  int v651;
  unsigned int v652;
  unsigned int v653;
  int v654;
  uint64_t v655;
  int v656;
  unsigned int v657;
  unsigned int v658;
  int v659;
  int v660;
  unsigned int v661;
  unsigned int v662;
  int v663;
  int v664;
  unsigned int v665;
  unsigned int v666;
  int v667;
  int v668;
  unsigned int v669;
  int v670;
  unsigned int v671;
  int v672;
  int v673;
  unsigned int v674;
  unsigned int v675;
  unsigned int v676;
  __int16 v677;
  int v678;
  int v679;
  unsigned int v680;
  uint64_t v681;
  unint64_t v682;
  unint64_t v683;
  unint64_t v684;
  int64_t v685;
  unint64_t v686;
  __int16 v687;
  int v688;
  int v689;
  unsigned int v690;
  unsigned int v691;
  unint64_t v692;
  unint64_t v693;
  unint64_t v694;
  int64_t v695;
  unint64_t v696;
  __int16 v697;
  int v698;
  unsigned int v699;
  unsigned int v700;
  __int16 v701;
  int v702;
  unsigned int v703;
  unsigned int v704;
  __int16 v705;
  int v706;
  unsigned int v707;
  unsigned int v708;
  __int16 v709;
  int v710;
  unsigned int v711;
  unsigned int v712;
  __int16 v713;
  int v714;
  unsigned int v715;
  unsigned int v716;
  __int16 v717;
  int v718;
  unsigned int v719;
  unsigned int v720;
  __int16 v721;
  int v722;
  unsigned int v723;
  unsigned int v724;
  __int16 v725;
  int v726;
  unsigned int v727;
  unsigned int v728;
  __int16 v729;
  uint64_t v730;
  int v731;
  int v732;
  unsigned int v733;
  uint64_t v734;
  int64_t v735;
  unint64_t v736;
  unint64_t v737;
  int64_t v738;
  unint64_t v739;
  __int16 v740;
  int v741;
  unsigned int v742;
  unsigned int v743;
  __int16 v744;
  int v745;
  unsigned int v746;
  unsigned int v747;
  __int16 v748;
  int v749;
  unsigned int v750;
  unsigned int v751;
  __int16 v752;
  int v753;
  unsigned int v754;
  unsigned int v755;
  int16x4_t v756;
  unsigned int v757;
  uint16x4_t v758;
  int32x4_t v759;
  unsigned int v760;
  uint32x4_t v761;
  int v762;
  unsigned int v763;
  unsigned int v764;
  int v765;
  unsigned int v766;
  int v767;
  unsigned int v768;
  int v769;
  int v770;
  int v771;
  int v772;
  int v773;
  int v774;
  unint64_t v775;
  int v776;
  int v777;
  unint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  int v782;
  unint64_t v783;
  unint64_t v784;
  char *v785;
  int v786;
  int v787;
  int v788;
  uint64_t v789;
  uint64_t v790;
  int v791;
  int v792;
  int v793;
  int v794;
  int v795;
  int v796;
  int v797;
  int v798;
  int v799;
  int v800;
  int v801;
  int v802;
  unint64_t v803;
  int v804;
  unint64_t v805;
  _WORD *v806;
  int v807;
  unint64_t v808;
  unsigned int v809;
  unint64_t v810;
  int v811;
  int v812;
  int v813;
  int v814;
  int v815;
  int v816;
  int v817;
  int v818;
  int v819;
  int v820;
  int v821;
  int v822;
  int v823;
  uint64_t v824;
  uint64_t v825;
  unsigned int v826;
  unint64_t v827;
  char *v828;
  unint64_t v829;
  unint64_t v830;
  unint64_t v831;
  int v832[2];
  int v833;
  uint64_t v834;
  unint64_t v835;
  unint64_t v836;
  uint64_t v837;
  uint64_t v838;
  int v839[4];
  __int128 v840;
  __int128 v841;
  __int128 v842;
  __int128 v843;
  __int128 v844;
  __int128 v845;
  __int128 v846;
  __int128 v847;
  __int128 v848;
  _DWORD v849[1024];
  uint64_t v850;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v850 = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned int **)(v3 + 96);
  v6 = *(_QWORD *)(v3 + 48);
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v5 == 0)
                 + 4 * (v6 == 0));
  if (v7 > 27)
    return 0xFFFFFFFFLL;
  v9 = v3;
  v10 = *(unsigned int *)(v3 + 4);
  v11 = v10 - 1;
  if ((int)v10 < 1)
    return 0;
  v12 = *(_DWORD *)(v3 + 8);
  v13 = (v12 - 1);
  if (v12 < 1)
    return 0;
  v14 = *(uint16x4_t **)(v3 + 136);
  v782 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                   + 16 * *(_DWORD *)v3
                   + 8 * (v5 == 0)
                   + 4 * (v6 == 0));
  v778 = v3;
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v14)
  {
    v16 = *(_DWORD *)v3 & 0xFF00;
    if (v16 == 1024)
    {
      v849[0] = *(_DWORD *)(v3 + 4);
      v839[0] = v12;
      v826 = **(_DWORD **)(v3 + 88);
      v17 = bswap32(v826);
      if (v5)
        v18 = bswap32(*v5);
      else
        v18 = 0xFFFF;
      v31 = *(_QWORD *)(v3 + 40);
      v32 = (unint64_t)*(int *)(v3 + 28) >> 1;
      v34 = *(int *)(v3 + 12);
      v33 = *(int *)(v3 + 16);
      v35 = v17 | (v18 << 16);
      if (v6)
      {
        v830 = (unint64_t)*(int *)(v3 + 32) >> 1;
        v828 = (char *)(v6 + 2 * (v34 + v830 * v33));
        v809 = 1;
      }
      else
      {
        v828 = 0;
        v830 = 0;
        v809 = 0;
      }
      v40 = HIWORD(v35);
      v804 = ~HIWORD(v35);
      v41 = v31 + 2 * (v34 + v33 * v32);
      v805 = (unint64_t)*(int *)(v3 + 28) >> 1;
      v807 = v17 | (v18 << 16);
      v824 = v41;
      if (v14)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v14, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
        v43 = v42;
        v44 = v828;
        v836 = v830;
        if (v42)
          goto LABEL_1373;
        return 1;
      }
      *(_QWORD *)v832 = 0;
      if (v6)
        v45 = v10;
      else
        v45 = 0;
      v44 = v828;
      v836 = v830 - v45;
      v46 = v10;
      v47 = (int8x8_t *)(v31 + 2 * (v34 + v33 * v32));
LABEL_1003:
      v835 = v32 - v46;
      v41 = HIWORD(v826);
      v823 = v10;
      switch(v7)
      {
        case 0:
          v597 = v32;
          v598 = v835 + (int)v10;
          v599 = v839[0];
          v600 = v10;
          v601 = v839[0] - 1;
          v602 = (v598 * v601) & (v598 >> 63);
          if (v598 < 0)
            v598 = -v598;
          CGBlt_fillBytes(2 * v600, v839[0], 0, (char *)v47 + 2 * v602, 2 * v598);
          if (v6)
          {
            v603 = v836 + v600;
            if (v603 >= 0)
              v604 = v836 + v600;
            else
              v604 = -v603;
            v44 += 2 * ((v603 * v601) & (v603 >> 63));
            v836 = v604;
            CGBlt_fillBytes(2 * v600, v599, 0, v44, 2 * v604);
          }
          v32 = v597;
          goto LABEL_1336;
        case 1:
          v605 = v835 + (int)v10;
          if (v605 < 0)
          {
            v47 = (int8x8_t *)((char *)v47 + 2 * v605 * (v839[0] - 1));
            v605 = -v605;
          }
          v606 = 0;
          v607 = *(int **)(v778 + 88);
          if (v607)
            v606 = *v607;
          v608 = v839[0];
          CGBlt_fillBytes(2 * v10, v839[0], v606, (char *)v47, 2 * v605);
          if (v6)
          {
            v609 = *(int **)(v778 + 96);
            if (!v609)
              v609 = (int *)&PIXELALPHAPLANARCONSTANT_15938;
            v610 = v836 + (int)v10;
            if (v610 >= 0)
              v611 = v836 + (int)v10;
            else
              v611 = -v610;
            v44 += 2 * (((v836 + (int)v10) * (v608 - 1)) & (v610 >> 63));
            v836 = v611;
            CGBlt_fillBytes(2 * v10, v608, *v609, v44, 2 * v611);
          }
          goto LABEL_1337;
        case 2:
          v612 = v839[0];
          v613 = v10 >> 2;
          if (v6)
          {
            v614 = v613 + 1;
            v41 = v824;
            do
            {
              if ((int)v10 < 4)
              {
                v624 = v10;
              }
              else
              {
                v615 = v614;
                do
                {
                  v616 = bswap32(v47->u16[0]);
                  v617 = bswap32(*(unsigned __int16 *)v44);
                  v47->i16[0] = bswap32(v17+ ((HIWORD(v616) * (unsigned __int16)v804+ ((HIWORD(v616) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                  *(_WORD *)v44 = bswap32(((HIWORD(v617) * (unsigned __int16)v804+ ((HIWORD(v617) * (unsigned __int16)v804) >> 16)+ 1) >> 16)+ HIWORD(v35)) >> 16;
                  v618 = bswap32(v47->u16[1]);
                  v619 = bswap32(*((unsigned __int16 *)v44 + 1));
                  v47->i16[1] = bswap32(v17+ ((HIWORD(v618) * (unsigned __int16)v804+ ((HIWORD(v618) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                  *((_WORD *)v44 + 1) = bswap32(((HIWORD(v619) * (unsigned __int16)v804+ ((HIWORD(v619) * (unsigned __int16)v804) >> 16)+ 1) >> 16)+ HIWORD(v35)) >> 16;
                  v620 = bswap32(v47->u16[2]);
                  v621 = bswap32(*((unsigned __int16 *)v44 + 2));
                  v47->i16[2] = bswap32(v17+ ((HIWORD(v620) * (unsigned __int16)v804+ ((HIWORD(v620) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                  *((_WORD *)v44 + 2) = bswap32(((HIWORD(v621) * (unsigned __int16)v804+ ((HIWORD(v621) * (unsigned __int16)v804) >> 16)+ 1) >> 16)+ HIWORD(v35)) >> 16;
                  v622 = bswap32(v47->u16[3]);
                  v623 = bswap32(*((unsigned __int16 *)v44 + 3));
                  v47->i16[3] = bswap32(v17+ ((HIWORD(v622) * (unsigned __int16)v804+ ((HIWORD(v622) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                  *((_WORD *)v44 + 3) = bswap32(((HIWORD(v623) * (unsigned __int16)v804+ ((HIWORD(v623) * (unsigned __int16)v804) >> 16)+ 1) >> 16)+ HIWORD(v35)) >> 16;
                  ++v47;
                  v44 += 8 * v809;
                  --v615;
                }
                while (v615 > 1);
                v624 = v10 & 3;
              }
              if (v624 >= 1)
              {
                v625 = v624 + 1;
                do
                {
                  v626 = bswap32(v47->u16[0]);
                  v627 = bswap32(*(unsigned __int16 *)v44);
                  v47->i16[0] = bswap32(v17+ ((HIWORD(v626) * (unsigned __int16)v804+ ((HIWORD(v626) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                  v47 = (int8x8_t *)((char *)v47 + 2);
                  *(_WORD *)v44 = bswap32(((HIWORD(v627) * (unsigned __int16)v804+ ((HIWORD(v627) * (unsigned __int16)v804) >> 16)+ 1) >> 16)+ HIWORD(v35)) >> 16;
                  --v625;
                  v44 += 2 * v809;
                }
                while (v625 > 1);
              }
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v612;
            }
            while (v612);
          }
          else
          {
            v756 = vdup_n_s16(v17);
            v757 = v613 + 1;
            v758 = (uint16x4_t)vdup_n_s16((unsigned __int16)v804);
            v759.i64[0] = 0x100000001;
            v759.i64[1] = 0x100000001;
            v41 = v824;
            do
            {
              if ((int)v10 < 4)
              {
                v762 = v10;
              }
              else
              {
                v760 = v757;
                do
                {
                  v761 = vmull_u16(v758, (uint16x4_t)vrev16_s8(*v47));
                  *v47++ = vrev16_s8((int8x8_t)vadd_s16(v756, vaddhn_s32((int32x4_t)vsraq_n_u32(v761, v761, 0x10uLL), v759)));
                  v44 += 8 * v809;
                  --v760;
                }
                while (v760 > 1);
                v762 = v10 & 3;
              }
              if (v762 >= 1)
              {
                v763 = v762 + 1;
                do
                {
                  v764 = bswap32(v47->u16[0]);
                  v47->i16[0] = bswap32(v17+ ((HIWORD(v764) * (unsigned __int16)v804+ ((HIWORD(v764) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                  v47 = (int8x8_t *)((char *)v47 + 2);
                  --v763;
                  v44 += 2 * v809;
                }
                while (v763 > 1);
              }
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v612;
            }
            while (v612);
          }
          goto LABEL_1370;
        case 3:
          v628 = bswap32(v35);
          v629 = v839[0];
          do
          {
            v630 = v10;
            do
            {
              v631 = bswap32(*(unsigned __int16 *)v44) >> 16;
              if (v631 == 0xFFFF)
              {
                v47->i16[0] = HIWORD(v826);
                LOWORD(v631) = v628;
              }
              else if (v631)
              {
                v632 = v631 ^ 0xFFFF;
                v47->i16[0] = bswap32(v17- (((unsigned __int16)v17 * v632 + (((unsigned __int16)v17 * v632) >> 16) + 1) >> 16)) >> 16;
                v631 = bswap32(v40 - (((_DWORD)v40 * v632 + ((v40 * v632) >> 16) + 1) >> 16)) >> 16;
              }
              else
              {
                v47->i16[0] = 0;
              }
              *(_WORD *)v44 = v631;
              v47 = (int8x8_t *)((char *)v47 + 2);
              v44 += 2 * v809;
              --v630;
            }
            while (v630);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            --v629;
          }
          while (v629);
          goto LABEL_1283;
        case 4:
          v633 = bswap32(v35);
          v634 = v839[0];
          do
          {
            v635 = v10;
            do
            {
              v636 = bswap32(*(unsigned __int16 *)v44) >> 16;
              if (v636)
              {
                if (v636 != 0xFFFF)
                {
                  v47->i16[0] = bswap32(v17- (((unsigned __int16)v17 * v636 + (((unsigned __int16)v17 * v636) >> 16) + 1) >> 16)) >> 16;
                  v637 = bswap32(v40 - (((_DWORD)v40 * v636 + ((v40 * v636) >> 16) + 1) >> 16)) >> 16;
                }
                else
                {
                  LOWORD(v637) = 0;
                  v47->i16[0] = 0;
                }
              }
              else
              {
                v47->i16[0] = HIWORD(v826);
                LOWORD(v637) = v633;
              }
              *(_WORD *)v44 = v637;
              v47 = (int8x8_t *)((char *)v47 + 2);
              v44 += 2 * v809;
              --v635;
            }
            while (v635);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            --v634;
          }
          while (v634);
          goto LABEL_1283;
        case 5:
          v638 = v839[0];
          v41 = v824;
          do
          {
            v639 = v10;
            do
            {
              v640 = bswap32(*(unsigned __int16 *)v44);
              v641 = bswap32(v47->u16[0]);
              v47->i16[0] = bswap32((unsigned __int16)v17 * HIWORD(v640)+ HIWORD(v641) * (unsigned __int16)v804+ (((unsigned __int16)v17 * HIWORD(v640)+ HIWORD(v641) * (unsigned __int16)v804) >> 16)+ 1);
              v47 = (int8x8_t *)((char *)v47 + 2);
              *(_WORD *)v44 = bswap32(((unsigned __int16)v804 + HIWORD(v640)) * v40+ ((((unsigned __int16)v804 + HIWORD(v640)) * v40) >> 16)+ 1);
              v44 += 2 * v809;
              --v639;
            }
            while (v639);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            --v638;
          }
          while (v638);
          goto LABEL_1370;
        case 6:
          v642 = bswap32(v35);
          v643 = v839[0];
          do
          {
            v644 = v10;
            do
            {
              v645 = bswap32(*(unsigned __int16 *)v44);
              if (HIWORD(v645) != 0xFFFF)
              {
                if ((unsigned __int16)~HIWORD(v645) == 0xFFFF)
                {
                  v47->i16[0] = HIWORD(v826);
                  LOWORD(v646) = v642;
                }
                else
                {
                  v647 = HIWORD(v645);
                  v648 = (unsigned __int16)~HIWORD(v645);
                  v47->i16[0] = bswap32((bswap32(v47->u16[0]) >> 16)+ (((unsigned __int16)v17 * v648+ (((unsigned __int16)v17 * v648) >> 16)+ 1) >> 16)) >> 16;
                  v646 = bswap32(v647 + (((_DWORD)v40 * v648 + ((v40 * v648) >> 16) + 1) >> 16)) >> 16;
                }
                *(_WORD *)v44 = v646;
              }
              v47 = (int8x8_t *)((char *)v47 + 2);
              v44 += 2 * v809;
              --v644;
            }
            while (v644);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            --v643;
          }
          while (v643);
          goto LABEL_1283;
        case 7:
          v649 = v839[0];
          v650 = 2 * v809;
          if (v6)
          {
            v41 = v824;
            do
            {
              v651 = v10;
              do
              {
                v652 = bswap32(v47->u16[0]);
                v653 = bswap32(*(unsigned __int16 *)v44);
                v47->i16[0] = bswap32(HIWORD(v652)- ((HIWORD(v652) * (unsigned __int16)v804+ ((HIWORD(v652) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                *(_WORD *)v44 = bswap32(HIWORD(v653)- ((HIWORD(v653) * (unsigned __int16)v804+ ((HIWORD(v653) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                v44 += v650;
                --v651;
              }
              while (v651);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v649;
            }
            while (v649);
          }
          else
          {
            v41 = v824;
            do
            {
              v765 = v10;
              do
              {
                v766 = bswap32(v47->u16[0]);
                v47->i16[0] = bswap32(HIWORD(v766)- ((HIWORD(v766) * (unsigned __int16)v804+ ((HIWORD(v766) * (unsigned __int16)v804) >> 16)+ 1) >> 16)) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                v44 += v650;
                --v765;
              }
              while (v765);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v649;
            }
            while (v649);
          }
          goto LABEL_1370;
        case 8:
          v654 = v839[0];
          v655 = 2 * v809;
          if (v6)
          {
            v41 = v824;
            do
            {
              v656 = v10;
              do
              {
                v657 = bswap32(v47->u16[0]);
                v658 = bswap32(*(unsigned __int16 *)v44);
                v47->i16[0] = bswap32(HIWORD(v657)- (((_DWORD)v40 * HIWORD(v657) + ((v40 * HIWORD(v657)) >> 16) + 1) >> 16)) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                *(_WORD *)v44 = bswap32(HIWORD(v658)- (((_DWORD)v40 * HIWORD(v658) + ((v40 * HIWORD(v658)) >> 16) + 1) >> 16)) >> 16;
                v44 += v655;
                --v656;
              }
              while (v656);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v654;
            }
            while (v654);
          }
          else
          {
            v41 = v824;
            do
            {
              v767 = v10;
              do
              {
                v768 = bswap32(v47->u16[0]);
                v47->i16[0] = bswap32(HIWORD(v768)- (((_DWORD)v40 * HIWORD(v768) + ((v40 * HIWORD(v768)) >> 16) + 1) >> 16)) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                v44 += v655;
                --v767;
              }
              while (v767);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v654;
            }
            while (v654);
          }
          goto LABEL_1370;
        case 9:
          v659 = v839[0];
          v41 = v824;
          do
          {
            v660 = v10;
            do
            {
              v661 = bswap32(~*(unsigned __int16 *)v44);
              v662 = bswap32(v47->u16[0]);
              v47->i16[0] = bswap32((unsigned __int16)v17 * HIWORD(v661)+ v40 * HIWORD(v662)+ (((unsigned __int16)v17 * HIWORD(v661) + v40 * HIWORD(v662)) >> 16)+ 1);
              v47 = (int8x8_t *)((char *)v47 + 2);
              *(_WORD *)v44 = bswap32((v40 + HIWORD(v661)) * v40+ (((v40 + HIWORD(v661)) * v40) >> 16)+ 1);
              v44 += 2 * v809;
              --v660;
            }
            while (v660);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            --v659;
          }
          while (v659);
          goto LABEL_1370;
        case 10:
          v663 = v839[0];
          v41 = v824;
          do
          {
            v664 = v10;
            do
            {
              v665 = bswap32(~*(unsigned __int16 *)v44);
              v666 = bswap32(v47->u16[0]);
              v47->i16[0] = bswap32((unsigned __int16)v17 * HIWORD(v665)+ HIWORD(v666) * (unsigned __int16)v804+ (((unsigned __int16)v17 * HIWORD(v665)+ HIWORD(v666) * (unsigned __int16)v804) >> 16)+ 1);
              v47 = (int8x8_t *)((char *)v47 + 2);
              *(_WORD *)v44 = bswap32(((unsigned __int16)v804 + HIWORD(v665)) * v40+ ((((unsigned __int16)v804 + HIWORD(v665)) * v40) >> 16)+ 1);
              v44 += 2 * v809;
              --v664;
            }
            while (v664);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            --v663;
          }
          while (v663);
          goto LABEL_1370;
        case 11:
          if (v6)
          {
            v667 = v839[0];
            v41 = v824;
            do
            {
              v668 = v10;
              do
              {
                v669 = bswap32(*(unsigned __int16 *)v44);
                v670 = v40 - ((unsigned __int16)v17 + (bswap32(v47->u16[0]) >> 16)) + HIWORD(v669);
                v671 = v40 + HIWORD(v669);
                if (v670 >= 0xFFFF)
                  v670 = 0xFFFF;
                if (v671 >= 0xFFFF)
                  v671 = 0xFFFF;
                v47->i16[0] = bswap32(v671 - v670) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                *(_WORD *)v44 = bswap32(v671) >> 16;
                v44 += 2 * v809;
                --v668;
              }
              while (v668);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v667;
            }
            while (v667);
          }
          else
          {
            v769 = v839[0];
            v41 = v824;
            do
            {
              v770 = v10;
              do
              {
                v771 = v40 - (unsigned __int16)v17 + (bswap32(~v47->u16[0]) >> 16);
                if (v771 >= 0xFFFF)
                  v771 = 0xFFFF;
                v47->i16[0] = bswap32(~v771) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                v44 += 2 * v809;
                --v770;
              }
              while (v770);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v769;
            }
            while (v769);
          }
          goto LABEL_1370;
        case 12:
          if (v6)
          {
            v672 = v839[0];
            v41 = v824;
            do
            {
              v673 = v10;
              do
              {
                v674 = (unsigned __int16)v17 + (bswap32(v47->u16[0]) >> 16);
                v675 = v40 + (bswap32(*(unsigned __int16 *)v44) >> 16);
                if (v674 >= 0xFFFF)
                  v674 = 0xFFFF;
                v47->i16[0] = bswap32(v674) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                if (v675 >= 0xFFFF)
                  v676 = 0xFFFF;
                else
                  v676 = v675;
                *(_WORD *)v44 = bswap32(v676) >> 16;
                v44 += 2 * v809;
                --v673;
              }
              while (v673);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v672;
            }
            while (v672);
          }
          else
          {
            v772 = v839[0];
            v41 = v824;
            do
            {
              v773 = v10;
              do
              {
                v774 = bswap32(v47->u16[0]);
                v47->i16[0] = bswap32((v774 >> 15) & 0xFFFE | ((v774 >> 16) >> 15)) >> 16;
                v47 = (int8x8_t *)((char *)v47 + 2);
                v44 += 2 * v809;
                --v773;
              }
              while (v773);
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v772;
            }
            while (v772);
          }
LABEL_1370:
          v839[0] = 0;
          goto LABEL_1371;
        case 13:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v677 = bswap32(v35);
          v678 = v839[0];
          while (1)
          {
            v679 = v10;
            do
            {
              if (v6)
              {
                if (!*(_WORD *)v44)
                {
                  v47->i16[0] = HIWORD(v826);
                  *(_WORD *)v44 = v677;
                  goto LABEL_1131;
                }
                v680 = __rev16(*(unsigned __int16 *)v44);
              }
              else
              {
                v680 = 0xFFFF;
              }
              v681 = v680;
              v682 = (v680 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v17
                   + ((v40 ^ 0xFFFF) + (unsigned __int16)v17)
                   * (unint64_t)(bswap32(v47->u16[0]) >> 16);
              if (v682 <= 0xFFFE8000)
                v683 = v682 + 0x8000;
              else
                v683 = 4294868992;
              v684 = v683 + (v683 >> 16);
              if (v6)
              {
                v685 = 0xFFFF * (v681 + v40) - v681 * (unint64_t)v40;
                if (v685 <= 4294868992)
                  v686 = v685 + 0x8000;
                else
                  v686 = 4294868992;
                v47->i16[0] = bswap32(v684);
                *(_WORD *)v44 = bswap32((v684 >> 16) | ((v686 >> 16) + v686));
              }
              else
              {
                v47->i16[0] = bswap32(v684);
              }
LABEL_1131:
              v47 = (int8x8_t *)((char *)v47 + 2);
              v44 += 2 * v809;
              --v679;
            }
            while (v679);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            if (!--v678)
              goto LABEL_1283;
          }
        case 14:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v687 = bswap32(v35);
          v688 = v839[0];
          while (1)
          {
            v689 = v10;
            do
            {
              if (v6)
              {
                if (!*(_WORD *)v44)
                {
                  v47->i16[0] = HIWORD(v826);
                  *(_WORD *)v44 = v687;
                  goto LABEL_1151;
                }
                v690 = __rev16(*(unsigned __int16 *)v44);
              }
              else
              {
                v690 = 0xFFFF;
              }
              v691 = bswap32(v47->u16[0]);
              v692 = (HIWORD(v691) ^ 0xFFFF) * (unint64_t)(unsigned __int16)v17
                   - HIWORD(v691)
                   + ((unint64_t)HIWORD(v691) << 16);
              if (v692 <= 0xFFFE8000)
                v693 = v692 + 0x8000;
              else
                v693 = 4294868992;
              v694 = v693 + (v693 >> 16);
              if (v6)
              {
                v695 = 0xFFFF * (v40 + v690) - v40 * (unint64_t)v690;
                if (v695 <= 4294868992)
                  v696 = v695 + 0x8000;
                else
                  v696 = 4294868992;
                v47->i16[0] = bswap32(v694);
                *(_WORD *)v44 = bswap32((v694 >> 16) | ((v696 >> 16) + v696));
              }
              else
              {
                v47->i16[0] = bswap32(v694);
              }
LABEL_1151:
              v47 = (int8x8_t *)((char *)v47 + 2);
              v44 += 2 * v809;
              --v689;
            }
            while (v689);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            if (!--v688)
            {
LABEL_1283:
              v839[0] = 0;
LABEL_1337:
              v41 = v824;
LABEL_1371:
              v43 = *(_QWORD *)v832;
              if (!*(_QWORD *)v832)
                return 1;
              v838 = 0;
LABEL_1373:
              if (!shape_enum_clip_next(v43, (int *)&v838 + 1, &v838, v849, v839))
                goto LABEL_1379;
              *(_QWORD *)v832 = v43;
              v47 = (int8x8_t *)(v41 + 2 * v32 * (int)v838 + 2 * SHIDWORD(v838));
              v46 = v849[0];
              v775 = v836;
              if (v6)
                v775 = v830 - v849[0];
              v836 = v775;
              if (v6)
                v44 = &v828[2 * v830 * (int)v838 + 2 * SHIDWORD(v838)];
              LODWORD(v10) = v849[0];
              goto LABEL_1003;
            }
          }
        case 15:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v697 = bswap32(v35);
          v698 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v699 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1160;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v700) = v697;
LABEL_1163:
            *(_WORD *)v44 = v700;
LABEL_1164:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v698;
              LODWORD(v10) = v823;
              if (!v698)
                goto LABEL_1335;
            }
          }
          v699 = 0xFFFF;
LABEL_1160:
          v700 = bswap32(PDAoverlayPDA_8071(bswap32(v47->u16[0]) >> 16, v699, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v700);
          if (!v6)
            goto LABEL_1164;
          goto LABEL_1163;
        case 16:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v701 = bswap32(v35);
          v702 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v703 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1173;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v704) = v701;
LABEL_1176:
            *(_WORD *)v44 = v704;
LABEL_1177:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v702;
              LODWORD(v10) = v823;
              if (!v702)
                goto LABEL_1335;
            }
          }
          v703 = 0xFFFF;
LABEL_1173:
          v704 = bswap32(PDAdarkenPDA_8073(bswap32(v47->u16[0]) >> 16, v703, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v704);
          if (!v6)
            goto LABEL_1177;
          goto LABEL_1176;
        case 17:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v705 = bswap32(v35);
          v706 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v707 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1186;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v708) = v705;
LABEL_1189:
            *(_WORD *)v44 = v708;
LABEL_1190:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v706;
              LODWORD(v10) = v823;
              if (!v706)
                goto LABEL_1335;
            }
          }
          v707 = 0xFFFF;
LABEL_1186:
          v708 = bswap32(PDAlightenPDA_8072(bswap32(v47->u16[0]) >> 16, v707, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v708);
          if (!v6)
            goto LABEL_1190;
          goto LABEL_1189;
        case 18:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v709 = bswap32(v35);
          v710 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v711 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1199;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v712) = v709;
LABEL_1202:
            *(_WORD *)v44 = v712;
LABEL_1203:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v710;
              LODWORD(v10) = v823;
              if (!v710)
                goto LABEL_1335;
            }
          }
          v711 = 0xFFFF;
LABEL_1199:
          v712 = bswap32(PDAcolordodgePDA_8074(bswap32(v47->u16[0]) >> 16, v711, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v712);
          if (!v6)
            goto LABEL_1203;
          goto LABEL_1202;
        case 19:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v713 = bswap32(v35);
          v714 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v715 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1212;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v716) = v713;
LABEL_1215:
            *(_WORD *)v44 = v716;
LABEL_1216:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v714;
              LODWORD(v10) = v823;
              if (!v714)
                goto LABEL_1335;
            }
          }
          v715 = 0xFFFF;
LABEL_1212:
          v716 = bswap32(PDAcolorburnPDA_8075(bswap32(v47->u16[0]) >> 16, v715, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v716);
          if (!v6)
            goto LABEL_1216;
          goto LABEL_1215;
        case 20:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v717 = bswap32(v35);
          v718 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v719 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1225;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v720) = v717;
LABEL_1228:
            *(_WORD *)v44 = v720;
LABEL_1229:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v718;
              LODWORD(v10) = v823;
              if (!v718)
                goto LABEL_1335;
            }
          }
          v719 = 0xFFFF;
LABEL_1225:
          v720 = bswap32(PDAsoftlightPDA_8077(bswap32(v47->u16[0]) >> 16, v719, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v720);
          if (!v6)
            goto LABEL_1229;
          goto LABEL_1228;
        case 21:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v721 = bswap32(v35);
          v722 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v723 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1238;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v724) = v721;
LABEL_1241:
            *(_WORD *)v44 = v724;
LABEL_1242:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v722;
              LODWORD(v10) = v823;
              if (!v722)
                goto LABEL_1335;
            }
          }
          v723 = 0xFFFF;
LABEL_1238:
          v724 = bswap32(PDAhardlightPDA_8076(bswap32(v47->u16[0]) >> 16, v723, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v724);
          if (!v6)
            goto LABEL_1242;
          goto LABEL_1241;
        case 22:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v725 = bswap32(v35);
          v726 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v727 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1251;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v728) = v725;
LABEL_1254:
            *(_WORD *)v44 = v728;
LABEL_1255:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v726;
              LODWORD(v10) = v823;
              if (!v726)
                goto LABEL_1335;
            }
          }
          v727 = 0xFFFF;
LABEL_1251:
          v728 = bswap32(PDAdifferencePDA_8078(bswap32(v47->u16[0]) >> 16, v727, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v728);
          if (!v6)
            goto LABEL_1255;
          goto LABEL_1254;
        case 23:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v729 = __rev16(v40);
          if ((unsigned __int16)v17 >= HIWORD(v35))
            v730 = v40;
          else
            v730 = (unsigned __int16)v17;
          v731 = v839[0];
          while (1)
          {
            v732 = v10;
            do
            {
              if (v6)
              {
                if (!*(_WORD *)v44)
                {
                  v47->i16[0] = HIWORD(v826);
                  *(_WORD *)v44 = v729;
                  goto LABEL_1281;
                }
                v733 = __rev16(*(unsigned __int16 *)v44);
              }
              else
              {
                v733 = 0xFFFF;
              }
              LODWORD(v734) = bswap32(v47->u16[0]) >> 16;
              if (v734 >= v733)
                v734 = v733;
              else
                v734 = v734;
              v735 = 0xFFFF * (v734 + v730) - (2 * v730) * (unint64_t)v734;
              if (v735 <= 4294868992)
                v736 = v735 + 0x8000;
              else
                v736 = 4294868992;
              v737 = v736 + (v736 >> 16);
              if (v6)
              {
                v738 = 0xFFFF * (v40 + v733) - v40 * (unint64_t)v733;
                if (v738 <= 4294868992)
                  v739 = v738 + 0x8000;
                else
                  v739 = 4294868992;
                v47->i16[0] = bswap32(v737);
                *(_WORD *)v44 = bswap32((v737 >> 16) | ((v739 >> 16) + v739));
              }
              else
              {
                v47->i16[0] = bswap32(v737);
              }
LABEL_1281:
              v47 = (int8x8_t *)((char *)v47 + 2);
              v44 += 2 * v809;
              --v732;
            }
            while (v732);
            v47 = (int8x8_t *)((char *)v47 + 2 * v835);
            v44 += 2 * v836;
            if (!--v731)
              goto LABEL_1283;
          }
        case 24:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v740 = bswap32(v35);
          v741 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v742 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1290;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v743) = v740;
LABEL_1293:
            *(_WORD *)v44 = v743;
LABEL_1294:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v741;
              LODWORD(v10) = v823;
              if (!v741)
                goto LABEL_1335;
            }
          }
          v742 = 0xFFFF;
LABEL_1290:
          v743 = bswap32(PDAhuePDA_8079(bswap32(v47->u16[0]) >> 16, v742, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v743);
          if (!v6)
            goto LABEL_1294;
          goto LABEL_1293;
        case 25:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v744 = bswap32(v35);
          v745 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v746 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1303;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v747) = v744;
LABEL_1306:
            *(_WORD *)v44 = v747;
LABEL_1307:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v745;
              LODWORD(v10) = v823;
              if (!v745)
                goto LABEL_1335;
            }
          }
          v746 = 0xFFFF;
LABEL_1303:
          v747 = bswap32(PDAhuePDA_8079(bswap32(v47->u16[0]) >> 16, v746, (unsigned __int16)v17, v40));
          v47->i16[0] = HIWORD(v747);
          if (!v6)
            goto LABEL_1307;
          goto LABEL_1306;
        case 26:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v748 = bswap32(v35);
          v749 = v839[0];
          while (v6)
          {
            if (*(_WORD *)v44)
            {
              v750 = __rev16(*(unsigned __int16 *)v44);
              goto LABEL_1316;
            }
            v47->i16[0] = HIWORD(v826);
            LOWORD(v751) = v748;
LABEL_1319:
            *(_WORD *)v44 = v751;
LABEL_1320:
            v47 = (int8x8_t *)((char *)v47 + 2);
            v44 += 2 * v809;
            LODWORD(v10) = v10 - 1;
            if (!(_DWORD)v10)
            {
              v47 = (int8x8_t *)((char *)v47 + 2 * v835);
              v44 += 2 * v836;
              --v749;
              LODWORD(v10) = v823;
              if (!v749)
                goto LABEL_1335;
            }
          }
          v750 = 0xFFFF;
LABEL_1316:
          v751 = bswap32(PDAluminosityPDA_8081((unsigned __int16)v17, v40, bswap32(v47->u16[0]) >> 16, v750));
          v47->i16[0] = HIWORD(v751);
          if (!v6)
            goto LABEL_1320;
          goto LABEL_1319;
        case 27:
          if (!(_DWORD)v40)
            goto LABEL_1337;
          v752 = bswap32(v35);
          v753 = v839[0];
          break;
        default:
          goto LABEL_1371;
      }
      while (v6)
      {
        if (*(_WORD *)v44)
        {
          v754 = __rev16(*(unsigned __int16 *)v44);
          goto LABEL_1329;
        }
        v47->i16[0] = HIWORD(v826);
        LOWORD(v755) = v752;
LABEL_1332:
        *(_WORD *)v44 = v755;
LABEL_1333:
        v47 = (int8x8_t *)((char *)v47 + 2);
        v44 += 2 * v809;
        LODWORD(v10) = v10 - 1;
        if (!(_DWORD)v10)
        {
          v47 = (int8x8_t *)((char *)v47 + 2 * v835);
          v44 += 2 * v836;
          --v753;
          LODWORD(v10) = v823;
          if (!v753)
          {
LABEL_1335:
            v839[0] = 0;
            v7 = v782;
            v32 = v805;
LABEL_1336:
            v35 = v807;
            goto LABEL_1337;
          }
        }
      }
      v754 = 0xFFFF;
LABEL_1329:
      v755 = bswap32(PDAluminosityPDA_8081(bswap32(v47->u16[0]) >> 16, v754, (unsigned __int16)v17, v40));
      v47->i16[0] = HIWORD(v755);
      if (!v6)
        goto LABEL_1333;
      goto LABEL_1332;
    }
    v849[0] = *(_DWORD *)(v3 + 4);
    v839[0] = v12;
    v19 = *(_QWORD *)(v3 + 88);
    v21 = *(int *)(v3 + 12);
    v20 = *(int *)(v3 + 16);
    v803 = (unint64_t)*(int *)(v3 + 28) >> 1;
    if (v6)
    {
      v22 = (unint64_t)*(int *)(v3 + 32) >> 1;
      v785 = (char *)(v6 + 2 * (v21 + v22 * v20));
      v23 = 0xFFFFFFFFLL;
    }
    else
    {
      v22 = 0;
      v785 = 0;
      v23 = 0;
    }
    v783 = *(_QWORD *)(v3 + 40) + 2 * (v21 + v20 * v803);
    v784 = v22;
    v36 = *(_DWORD *)(v3 + 56);
    v37 = *(_DWORD *)(v3 + 60);
    v810 = (unint64_t)*(int *)(v3 + 76) >> 1;
    if (v16 != 256)
    {
      v788 = *(_DWORD *)(v3 + 64);
      v787 = *(_DWORD *)(v3 + 68);
      if (v5)
      {
        v38 = (unint64_t)*(int *)(v3 + 80) >> 1;
        v39 = 1;
      }
      else
      {
        v38 = 0;
        v39 = 0;
      }
      v808 = v19 + 2 * v810 * v787;
      v23 &= 1u;
      if (v14)
      {
        v776 = *(_DWORD *)(v3 + 56);
        v777 = *(_DWORD *)(v3 + 60);
        v834 = v39;
        v837 = v23;
        v831 = v38;
        v55 = 1;
        v806 = *(_WORD **)(v3 + 88);
        v56 = (uint64_t)v806;
        v54 = v806;
        goto LABEL_54;
      }
      v829 = v22 - (v23 * v10);
      if (v19)
      {
        v65 = v37 % v787;
        v777 = v37 % v787;
        v790 = *(_QWORD *)(v3 + 88);
        v66 = v19 + 2 * v810 * v65;
        v67 = v36 % v788;
        v54 = (_WORD *)(v66 + 2 * v67);
        v63 = v66 + 2 * v788;
        v59 = (uint64_t)v5;
        v831 = v38;
        v776 = v67;
        v789 = 0;
        if (v5)
        {
          v60 = (char *)v5 + 2 * v38 * v65 + 2 * v67;
          v786 = 1;
          v39 = 1;
          v68 = (_BYTE *)v783;
          v58 = v785;
          v69 = (_WORD *)(v66 + 2 * v67);
          v825 = (uint64_t)v60;
        }
        else
        {
          v60 = 0;
          v825 = 0;
          v786 = 1;
          v68 = (_BYTE *)v783;
          v58 = v785;
          v69 = (_WORD *)(v66 + 2 * v67);
        }
        v62 = v10;
        goto LABEL_66;
      }
      v776 = *(_DWORD *)(v3 + 56);
      v777 = *(_DWORD *)(v3 + 60);
      v54 = 0;
      v63 = 0;
      v786 = 1;
      v62 = v10;
      v64 = (unint64_t)*(int *)(v3 + 76) >> 1;
LABEL_62:
      v59 = (uint64_t)v5;
      v789 = 0;
      v790 = (uint64_t)v54;
      v69 = 0;
      v808 = 0;
      v810 = v64 - v62;
      v831 = v38 - (int)v39 * (int)v10;
      v68 = (_BYTE *)v783;
      v58 = v785;
      v60 = (char *)v59;
      v825 = v59;
      goto LABEL_66;
    }
    if (v5)
    {
      v38 = (unint64_t)*(int *)(v3 + 80) >> 1;
      v5 = (unsigned int *)((char *)v5 + 2 * v36 + 2 * v38 * v37);
      v39 = 0xFFFFFFFFLL;
    }
    else
    {
      v38 = 0;
      v39 = 0;
    }
    v54 = (_WORD *)(v19 + 2 * (v36 + v37 * v810));
    if (v810 == v803 && (uint64_t)(v783 - (_QWORD)v54) >= 1)
    {
      if (v10 >= (v783 - (unint64_t)v54) >> 1)
      {
        v783 += 2 * v11;
        v54 += v11;
        v785 += 2 * (v23 & v11);
        v55 = -1;
        v810 = (unint64_t)*(int *)(v3 + 28) >> 1;
        v5 = (unsigned int *)((char *)v5 + 2 * (v39 & v11));
        goto LABEL_49;
      }
      if (v783 <= (unint64_t)&v54[v803 * v13 + v11])
      {
        v783 += 2 * v803 * v13;
        v784 = -(uint64_t)v22;
        v785 += 2 * v22 * v13;
        v5 = (unsigned int *)((char *)v5 + 2 * v38 * v13);
        v23 &= 1u;
        v38 = -(uint64_t)v38;
        v39 &= 1u;
        v55 = 1;
        v54 += v803 * v13;
        v810 = -(uint64_t)v803;
        v803 = -(uint64_t)v803;
        goto LABEL_49;
      }
    }
    v23 &= 1u;
    v39 &= 1u;
    v55 = 1;
LABEL_49:
    v776 = *(_DWORD *)(v3 + 56);
    v777 = *(_DWORD *)(v3 + 60);
    if (v14)
    {
      v834 = v39;
      v837 = v23;
      v806 = 0;
      v808 = 0;
      v56 = -1;
      v831 = v38;
      v787 = v38;
      v788 = v810;
LABEL_54:
      v786 = v55;
      shape_enum_clip_alloc(v19, v3, (int *)v14, v55, v803, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
      v43 = v57;
      v58 = v785;
      v829 = v784;
      v59 = (uint64_t)v5;
      v60 = (char *)v5;
      v61 = (char *)v5;
      if (!v57)
        return 1;
      while (2)
      {
        v825 = (uint64_t)v61;
        if (!shape_enum_clip_next(v43, (int *)&v838 + 1, &v838, v849, v839))
        {
LABEL_1379:
          v53 = (void *)v43;
LABEL_1380:
          free(v53);
          return 1;
        }
        v789 = v43;
        v790 = (uint64_t)v54;
        if (v808)
        {
          v68 = (_BYTE *)(v783 + 2 * v803 * (int)v838 + 2 * SHIDWORD(v838));
          v569 = ((int)v838 + *(_DWORD *)(v9 + 60)) % v787;
          v62 = v849[0];
          v570 = (HIDWORD(v838) + *(_DWORD *)(v9 + 56)) % v788;
          v571 = &v54[v810 * v569];
          v54 = &v571[v570];
          v63 = (unint64_t)&v571[v788];
          v23 = v837;
          v572 = v829;
          if ((_DWORD)v837)
            v572 = v784 - v849[0];
          v829 = v572;
          if ((_DWORD)v837)
            v58 = &v785[2 * v784 * (int)v838 + 2 * SHIDWORD(v838)];
          if ((_DWORD)v834)
            v39 = v834;
          else
            v39 = 0;
          if ((_DWORD)v834)
            v60 = (char *)(v59 + 2 * v831 * v569 + 2 * v570);
          v573 = v825;
          if ((_DWORD)v834)
            v573 = v59 + 2 * v831 * v569 + 2 * v570;
          v825 = v573;
          LODWORD(v10) = v849[0];
          v69 = v54;
          v776 = (HIDWORD(v838) + *(_DWORD *)(v9 + 56)) % v788;
          v777 = ((int)v838 + *(_DWORD *)(v9 + 60)) % v787;
        }
        else
        {
          v574 = HIDWORD(v838) * v786;
          LODWORD(v10) = v849[0];
          v575 = v849[0] * v786;
          v68 = (_BYTE *)(v783 + 2 * v803 * (int)v838 + 2 * HIDWORD(v838) * v786);
          v62 = v849[0] * v786;
          v54 += (int)v838 * v788 + HIDWORD(v838) * v786;
          v808 = 0;
          v810 = v788 - v849[0] * v786;
          v39 = v834;
          v23 = v837;
          if ((_DWORD)v837)
            v576 = v784 - v575;
          else
            v576 = v829;
          if ((_DWORD)v837)
            v58 = &v785[2 * v784 * (int)v838 + 2 * v574];
          v577 = v59 + 2 * (int)v838 * v787 + 2 * v574;
          v578 = v787 - v575;
          v579 = v831;
          if ((_DWORD)v834)
            v579 = v578;
          v829 = v576;
          v831 = v579;
          if ((_DWORD)v834)
            v60 = (char *)v577;
          v63 = v56;
          v69 = v806;
        }
LABEL_66:
        v834 = v39;
        v837 = v23;
        v827 = v803 - v62;
        switch(v7)
        {
          case 0:
            v779 = v59;
            v806 = v69;
            v56 = v63;
            v70 = v827 - (int)v10;
            v71 = &v68[-2 * (int)v10 + 2];
            if (v786 >= 0)
            {
              v71 = v68;
              v70 = v827 + (int)v10;
            }
            v72 = v839[0];
            v73 = v839[0] - 1;
            v74 = &v71[2 * ((v70 * v73) & (v70 >> 63))];
            if (v70 < 0)
              v70 = -v70;
            CGBlt_fillBytes(2 * v10, v839[0], 0, v74, 2 * v70);
            if (!(_DWORD)v837)
            {
              v54 = (_WORD *)v790;
              goto LABEL_999;
            }
            if (v786 < 0)
            {
              v75 = v829 - (int)v10;
              v58 += -2 * (int)v10 + 2;
            }
            else
            {
              v75 = v829 + (int)v10;
            }
            if (v75 >= 0)
              v549 = v75;
            else
              v549 = -v75;
            v58 += 2 * ((v75 * v73) & (v75 >> 63));
            v829 = v549;
            CGBlt_fillBytes(2 * v10, v72, 0, v58, 2 * v549);
            goto LABEL_911;
          case 1:
            v76 = *(unsigned __int8 *)(v9 + 1);
            if (v76 == 2)
            {
              if ((int)v10 < 16
                || (2 * v788) > 0x40
                || (v4.i32[0] = 2 * v788, v535 = (uint8x8_t)vcnt_s8(v4), v535.i16[0] = vaddlv_u8(v535), v535.i32[0] > 1u))
              {
LABEL_887:
                if ((_DWORD)v23)
                {
                  v537 = 2 * v786;
                  v538 = 2 * (int)v23;
                  if ((_DWORD)v39)
                  {
                    v539 = (int)v39;
                    v540 = v839[0];
                    v61 = (char *)v825;
                    do
                    {
                      v541 = v10;
                      do
                      {
                        *(_WORD *)v68 = *v54;
                        *(_WORD *)v58 = *(_WORD *)v60;
                        v542 = &v54[v786];
                        if ((unint64_t)v542 >= v63)
                          v543 = -(uint64_t)v788;
                        else
                          v543 = 0;
                        v54 = &v542[v543];
                        v60 += 2 * v539 + 2 * v543;
                        v68 += v537;
                        v58 += v538;
                        --v541;
                      }
                      while (v541);
                      if (v808)
                      {
                        v544 = &v69[v810];
                        v545 = (unint64_t)v544 >= v808;
                        if ((unint64_t)v544 >= v808)
                          v546 = -(uint64_t)(v810 * v787);
                        else
                          v546 = 0;
                        v54 = &v544[v546];
                        v547 = v63 + 2 * v546;
                        if (v545)
                          v548 = -(uint64_t)(v831 * v787);
                        else
                          v548 = 0;
                        v60 = &v61[2 * v831 + 2 * v548];
                        v63 = v547 + 2 * v810;
                        v69 = v54;
                        v61 = v60;
                      }
                      else
                      {
                        v54 += v810;
                        v60 += 2 * v831;
                      }
                      v68 += 2 * v827;
                      v58 += 2 * v829;
                      --v540;
                    }
                    while (v540);
                  }
                  else
                  {
                    v560 = v839[0];
                    v61 = (char *)v825;
                    do
                    {
                      v561 = v10;
                      do
                      {
                        *(_WORD *)v68 = *v54;
                        *(_WORD *)v58 = -1;
                        v562 = &v54[v786];
                        if ((unint64_t)v562 >= v63)
                          v563 = -(uint64_t)v788;
                        else
                          v563 = 0;
                        v54 = &v562[v563];
                        v60 += 2 * v563;
                        v68 += v537;
                        v58 += v538;
                        --v561;
                      }
                      while (v561);
                      if (v808)
                      {
                        v564 = &v69[v810];
                        v565 = (unint64_t)v564 >= v808;
                        if ((unint64_t)v564 >= v808)
                          v566 = -(uint64_t)(v810 * v787);
                        else
                          v566 = 0;
                        v54 = &v564[v566];
                        v567 = v63 + 2 * v566;
                        if (v565)
                          v568 = -(uint64_t)(v831 * v787);
                        else
                          v568 = 0;
                        v60 = &v61[2 * v831 + 2 * v568];
                        v63 = v567 + 2 * v810;
                        v69 = v54;
                        v61 = v60;
                      }
                      else
                      {
                        v54 += v810;
                        v60 += 2 * v831;
                      }
                      v68 += 2 * v827;
                      v58 += 2 * v829;
                      --v560;
                    }
                    while (v560);
                  }
                }
                else
                {
                  v550 = (int)v39;
                  v551 = v839[0];
                  v61 = (char *)v825;
                  do
                  {
                    v552 = v10;
                    do
                    {
                      *(_WORD *)v68 = *v54;
                      v553 = &v54[v786];
                      if ((unint64_t)v553 >= v63)
                        v554 = -(uint64_t)v788;
                      else
                        v554 = 0;
                      v54 = &v553[v554];
                      v60 += 2 * v550 + 2 * v554;
                      v68 += 2 * v786;
                      --v552;
                    }
                    while (v552);
                    if (v808)
                    {
                      v555 = &v69[v810];
                      v556 = (unint64_t)v555 >= v808;
                      if ((unint64_t)v555 >= v808)
                        v557 = -(uint64_t)(v810 * v787);
                      else
                        v557 = 0;
                      v54 = &v555[v557];
                      v558 = v63 + 2 * v557;
                      if (v556)
                        v559 = -(uint64_t)(v831 * v787);
                      else
                        v559 = 0;
                      v60 = &v61[2 * v831 + 2 * v559];
                      v63 = v558 + 2 * v810;
                      v69 = v54;
                      v61 = v60;
                    }
                    else
                    {
                      v54 += v810;
                      v60 += 2 * v831;
                    }
                    v68 += 2 * v827;
                    v58 += 2 * v829;
                    --v551;
                  }
                  while (v551);
                }
                goto LABEL_947;
              }
              v806 = v69;
              v56 = v63;
              v536 = v839[0];
              CGSFillDRAM64(v68, 2 * (v10 + v827), 2 * v10, v839[0], v790, 2 * v810, 2 * v788, v787, 2 * v776, v777);
              if (!(_DWORD)v837)
              {
                v61 = (char *)v825;
                goto LABEL_948;
              }
              if ((_DWORD)v39)
                CGSFillDRAM64(v58, 2 * (v10 + v829), 2 * v10, v536, v59, 2 * v831, 2 * v788, v787, 2 * v776, v777);
              else
                CGBlt_fillBytes(2 * v10, v536, -1, v58, 2 * (v10 + v829));
LABEL_862:
              v43 = v789;
              v54 = (_WORD *)v790;
              v61 = (char *)v825;
              if (!v789)
                return 1;
            }
            else
            {
              if (v76 != 1)
                goto LABEL_887;
              v806 = v69;
              v77 = (int)v10;
              v779 = v59;
              v56 = v63;
              if (v786 < 0)
              {
                v78 = v810 - (int)v10;
                v54 += -(int)v10 + 1;
                v79 = v827 - (int)v10;
                v68 += -2 * (int)v10 + 2;
              }
              else
              {
                v78 = v810 + (int)v10;
                v79 = v827 + (int)v10;
              }
              v580 = v10;
              v581 = v839[0] - 1;
              if (v78 >= 0)
                v582 = v78;
              else
                v582 = -v78;
              v583 = (char *)&v54[(v78 * v581) & (v78 >> 63)];
              v584 = &v68[2 * ((v79 * v581) & (v79 >> 63))];
              if (v79 >= 0)
                LODWORD(v585) = v79;
              else
                v585 = -v79;
              v586 = v580;
              v587 = 2 * v580;
              v810 = v582;
              v833 = v839[0];
              CGBlt_copyBytes(2 * v580, v839[0], v583, v584, 2 * v582, 2 * v585);
              if ((_DWORD)v837)
              {
                v54 = (_WORD *)v790;
                if ((_DWORD)v39)
                {
                  v588 = v831 - v77;
                  v589 = &v60[-2 * v586 + 2];
                  v590 = v829 - v77;
                  v591 = &v58[-2 * v586 + 2];
                  if (v786 >= 0)
                  {
                    v588 = v831 + v77;
                    v590 = v829 + v77;
                    v591 = v58;
                    v589 = v60;
                  }
                  if (v588 >= 0)
                    v592 = v588;
                  else
                    v592 = -v588;
                  v60 = &v589[2 * ((v588 * v581) & (v588 >> 63))];
                  v58 = &v591[2 * ((v590 * v581) & (v590 >> 63))];
                  if (v590 >= 0)
                    v593 = v590;
                  else
                    v593 = -v590;
                  v829 = v593;
                  v831 = v592;
                  CGBlt_copyBytes(v587, v833, v60, &v591[2 * ((v590 * v581) & (v590 >> 63))], 2 * v592, 2 * v593);
                }
                else
                {
                  v594 = v829 - v77;
                  v595 = &v58[-2 * v586 + 2];
                  if (v786 >= 0)
                  {
                    v594 = v829 + v77;
                    v595 = v58;
                  }
                  if (v594 >= 0)
                    v596 = v594;
                  else
                    v596 = -v594;
                  v58 = &v595[2 * ((v594 * v581) & (v594 >> 63))];
                  v829 = v596;
                  CGBlt_fillBytes(v587, v833, -1, v58, 2 * v596);
                }
LABEL_999:
                v43 = v789;
                v61 = (char *)v825;
                v59 = v779;
                if (!v789)
                  return 1;
              }
              else
              {
LABEL_911:
                v43 = v789;
                v61 = (char *)v825;
LABEL_912:
                v59 = v779;
                v54 = (_WORD *)v790;
                if (!v43)
                  return 1;
              }
            }
            goto LABEL_949;
          case 2:
            if ((_DWORD)v23)
            {
              v779 = v59;
              v80 = (int)v39;
              v81 = v839[0];
              v61 = (char *)v825;
              do
              {
                v82 = v10;
                do
                {
                  v83 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  if (v83)
                  {
                    if (v83 == 0xFFFF)
                    {
                      *(_WORD *)v68 = *v54;
                      LOWORD(v84) = *(_WORD *)v60;
                    }
                    else
                    {
                      v85 = bswap32(*(unsigned __int16 *)v68);
                      v86 = bswap32(*(unsigned __int16 *)v58);
                      *(_WORD *)v68 = bswap32((bswap32((unsigned __int16)*v54) >> 16)+ ((HIWORD(v85) * (v83 ^ 0xFFFF) + ((HIWORD(v85) * (v83 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                      v84 = bswap32(v83 + ((HIWORD(v86) * (v83 ^ 0xFFFF) + ((HIWORD(v86) * (v83 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                    }
                    *(_WORD *)v58 = v84;
                  }
                  v87 = &v54[v786];
                  if ((unint64_t)v87 >= v63)
                    v88 = -(uint64_t)v788;
                  else
                    v88 = 0;
                  v54 = &v87[v88];
                  v60 += 2 * v80 + 2 * v88;
                  v68 += 2 * v786;
                  v58 += 2 * (int)v23;
                  --v82;
                }
                while (v82);
                if (v808)
                {
                  v89 = &v69[v810];
                  v90 = (unint64_t)v89 >= v808;
                  if ((unint64_t)v89 >= v808)
                    v91 = -(uint64_t)(v810 * v787);
                  else
                    v91 = 0;
                  v54 = &v89[v91];
                  v92 = v63 + 2 * v91;
                  if (v90)
                    v93 = -(uint64_t)(v831 * v787);
                  else
                    v93 = 0;
                  v60 = &v61[2 * v831 + 2 * v93];
                  v63 = v92 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v81;
              }
              while (v81);
              v806 = v69;
              v56 = v63;
              v839[0] = 0;
              v43 = v789;
              goto LABEL_912;
            }
            v465 = (int)v39;
            v466 = v839[0];
            v61 = (char *)v825;
            do
            {
              v467 = v10;
              do
              {
                v468 = bswap32(*(unsigned __int16 *)v60) >> 16;
                if (v468)
                {
                  if (v468 == 0xFFFF)
                  {
                    LOWORD(v469) = *v54;
                  }
                  else
                  {
                    v470 = bswap32(*(unsigned __int16 *)v68) >> 16;
                    v469 = bswap32((bswap32((unsigned __int16)*v54) >> 16)+ ((v470 * (v468 ^ 0xFFFF) + ((v470 * (v468 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                  }
                  *(_WORD *)v68 = v469;
                }
                v471 = &v54[v786];
                if ((unint64_t)v471 >= v63)
                  v472 = -(uint64_t)v788;
                else
                  v472 = 0;
                v54 = &v471[v472];
                v60 += 2 * v465 + 2 * v472;
                v68 += 2 * v786;
                --v467;
              }
              while (v467);
              if (v808)
              {
                v473 = &v69[v810];
                v474 = (unint64_t)v473 >= v808;
                if ((unint64_t)v473 >= v808)
                  v475 = -(uint64_t)(v810 * v787);
                else
                  v475 = 0;
                v54 = &v473[v475];
                v476 = v63 + 2 * v475;
                if (v474)
                  v477 = -(uint64_t)(v831 * v787);
                else
                  v477 = 0;
                v60 = &v61[2 * v831 + 2 * v477];
                v63 = v476 + 2 * v810;
                v69 = v54;
                v61 = v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v466;
            }
            while (v466);
            goto LABEL_947;
          case 3:
            if ((_DWORD)v39)
            {
              v94 = (int)v39;
              v95 = v839[0];
              v61 = (char *)v825;
              do
              {
                v96 = v10;
                do
                {
                  v97 = bswap32(*(unsigned __int16 *)v58) >> 16;
                  if (v97 == 0xFFFF)
                  {
                    *(_WORD *)v68 = *v54;
                    LOWORD(v97) = *(_WORD *)v60;
                  }
                  else if (v97)
                  {
                    v98 = bswap32((unsigned __int16)*v54) >> 16;
                    v99 = bswap32(*(unsigned __int16 *)v60) >> 16;
                    v100 = v97 ^ 0xFFFF;
                    *(_WORD *)v68 = bswap32(v98 - ((v98 * v100 + ((v98 * v100) >> 16) + 1) >> 16)) >> 16;
                    v97 = bswap32(v99 - ((v99 * v100 + ((v99 * v100) >> 16) + 1) >> 16)) >> 16;
                  }
                  else
                  {
                    *(_WORD *)v68 = 0;
                  }
                  *(_WORD *)v58 = v97;
                  v101 = &v54[v786];
                  if ((unint64_t)v101 >= v63)
                    v102 = -(uint64_t)v788;
                  else
                    v102 = 0;
                  v54 = &v101[v102];
                  v60 += 2 * v94 + 2 * v102;
                  v68 += 2 * v786;
                  v58 += 2 * (int)v23;
                  --v96;
                }
                while (v96);
                if (v808)
                {
                  v103 = &v69[v810];
                  v104 = (unint64_t)v103 >= v808;
                  if ((unint64_t)v103 >= v808)
                    v105 = -(uint64_t)(v810 * v787);
                  else
                    v105 = 0;
                  v54 = &v103[v105];
                  v106 = v63 + 2 * v105;
                  if (v104)
                    v107 = -(uint64_t)(v831 * v787);
                  else
                    v107 = 0;
                  v60 = &v61[2 * v831 + 2 * v107];
                  v63 = v106 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v95;
              }
              while (v95);
            }
            else
            {
              v478 = v839[0];
              v61 = (char *)v825;
              do
              {
                v479 = v10;
                do
                {
                  v480 = bswap32(*(unsigned __int16 *)v58) >> 16;
                  if (v480)
                  {
                    if (v480 == 0xFFFF)
                    {
                      LOWORD(v480) = *v54;
                    }
                    else
                    {
                      v481 = bswap32((unsigned __int16)*v54) >> 16;
                      v480 = bswap32(v481 - ((v481 * (v480 ^ 0xFFFF) + ((v481 * (v480 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                    }
                  }
                  *(_WORD *)v68 = v480;
                  v482 = &v54[v786];
                  if ((unint64_t)v482 >= v63)
                    v483 = -(uint64_t)v788;
                  else
                    v483 = 0;
                  v54 = &v482[v483];
                  v60 += 2 * v483;
                  v68 += 2 * v786;
                  v58 += 2 * (int)v23;
                  --v479;
                }
                while (v479);
                if (v808)
                {
                  v484 = &v69[v810];
                  v485 = (unint64_t)v484 >= v808;
                  if ((unint64_t)v484 >= v808)
                    v486 = -(uint64_t)(v810 * v787);
                  else
                    v486 = 0;
                  v54 = &v484[v486];
                  v487 = v63 + 2 * v486;
                  if (v485)
                    v488 = -(uint64_t)(v831 * v787);
                  else
                    v488 = 0;
                  v60 = &v61[2 * v831 + 2 * v488];
                  v63 = v487 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v478;
              }
              while (v478);
            }
            goto LABEL_947;
          case 4:
            v108 = v839[0];
            do
            {
              v109 = v10;
              do
              {
                v110 = bswap32(*(unsigned __int16 *)v58) >> 16;
                if (v110)
                {
                  if (v110 != 0xFFFF)
                  {
                    if ((_DWORD)v39)
                      v112 = bswap32(*(unsigned __int16 *)v60) >> 16;
                    else
                      v112 = 0xFFFF;
                    v113 = bswap32((unsigned __int16)*v54) >> 16;
                    *(_WORD *)v68 = bswap32(v113 - ((v113 * v110 + ((v113 * v110) >> 16) + 1) >> 16)) >> 16;
                    v111 = bswap32(v112 - ((v112 * v110 + ((v112 * v110) >> 16) + 1) >> 16)) >> 16;
                  }
                  else
                  {
                    LOWORD(v111) = 0;
                    *(_WORD *)v68 = 0;
                  }
                }
                else
                {
                  if ((_DWORD)v39)
                    v111 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  else
                    v111 = 0xFFFF;
                  LOWORD(v111) = __rev16(v111);
                }
                *(_WORD *)v58 = v111;
                v114 = &v54[v786];
                if ((unint64_t)v114 >= v63)
                  v115 = -(uint64_t)v788;
                else
                  v115 = 0;
                v54 = &v114[v115];
                v60 += 2 * (int)v39 + 2 * v115;
                v68 += 2 * v786;
                v58 += 2 * (int)v23;
                --v109;
              }
              while (v109);
              if (v808)
              {
                v116 = &v69[v810];
                v117 = (unint64_t)v116 >= v808;
                if ((unint64_t)v116 >= v808)
                  v118 = -(uint64_t)(v810 * v787);
                else
                  v118 = 0;
                v54 = &v116[v118];
                v119 = v63 + 2 * v118;
                if (v117)
                  v120 = -(uint64_t)(v831 * v787);
                else
                  v120 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v120);
                v63 = v119 + 2 * v810;
                v69 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v108;
            }
            while (v108);
            goto LABEL_861;
          case 5:
            v121 = (int)v39;
            v122 = v839[0];
            v61 = (char *)v825;
            do
            {
              v123 = v10;
              do
              {
                v124 = bswap32(*(unsigned __int16 *)v58);
                v125 = bswap32(*(unsigned __int16 *)v60) >> 16;
                v126 = bswap32(*(unsigned __int16 *)v68);
                v127 = (bswap32((unsigned __int16)*v54) >> 16) * HIWORD(v124);
                *(_WORD *)v68 = bswap32(v127+ HIWORD(v126) * (v125 ^ 0xFFFF)+ ((v127 + HIWORD(v126) * (v125 ^ 0xFFFF)) >> 16)+ 1);
                *(_WORD *)v58 = bswap32(((v125 ^ 0xFFFF) + HIWORD(v124)) * v125+ ((((v125 ^ 0xFFFF) + HIWORD(v124)) * v125) >> 16)+ 1);
                v128 = &v54[v786];
                if ((unint64_t)v128 >= v63)
                  v129 = -(uint64_t)v788;
                else
                  v129 = 0;
                v54 = &v128[v129];
                v60 += 2 * v121 + 2 * v129;
                v68 += 2 * v786;
                v58 += 2 * (int)v23;
                --v123;
              }
              while (v123);
              if (v808)
              {
                v130 = &v69[v810];
                v131 = (unint64_t)v130 >= v808;
                if ((unint64_t)v130 >= v808)
                  v132 = -(uint64_t)(v810 * v787);
                else
                  v132 = 0;
                v54 = &v130[v132];
                v133 = v63 + 2 * v132;
                if (v131)
                  v134 = -(uint64_t)(v831 * v787);
                else
                  v134 = 0;
                v60 = &v61[2 * v831 + 2 * v134];
                v63 = v133 + 2 * v810;
                v69 = v54;
                v61 = v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v122;
            }
            while (v122);
            goto LABEL_947;
          case 6:
            v135 = v839[0];
            v136 = 2 * (int)v23;
            do
            {
              v137 = v10;
              do
              {
                v138 = bswap32(*(unsigned __int16 *)v58);
                if (HIWORD(v138) != 0xFFFF)
                {
                  if ((unsigned __int16)~HIWORD(v138) == 0xFFFF)
                  {
                    *(_WORD *)v68 = *v54;
                    if ((_DWORD)v39)
                      v139 = bswap32(*(unsigned __int16 *)v60) >> 16;
                    else
                      v139 = 0xFFFF;
                  }
                  else
                  {
                    if ((_DWORD)v39)
                      v140 = bswap32(*(unsigned __int16 *)v60) >> 16;
                    else
                      v140 = 0xFFFF;
                    v141 = HIWORD(v138);
                    v142 = (unsigned __int16)~HIWORD(v138);
                    v143 = (bswap32((unsigned __int16)*v54) >> 16) * v142;
                    *(_WORD *)v68 = bswap32((bswap32(*(unsigned __int16 *)v68) >> 16) + ((v143 + HIWORD(v143) + 1) >> 16)) >> 16;
                    v139 = v141 + ((v140 * v142 + ((v140 * v142) >> 16) + 1) >> 16);
                  }
                  *(_WORD *)v58 = bswap32(v139) >> 16;
                }
                v144 = &v54[v786];
                if ((unint64_t)v144 >= v63)
                  v145 = -(uint64_t)v788;
                else
                  v145 = 0;
                v54 = &v144[v145];
                v60 += 2 * (int)v39 + 2 * v145;
                v68 += 2 * v786;
                v58 += v136;
                --v137;
              }
              while (v137);
              if (v808)
              {
                v146 = &v69[v810];
                v147 = (unint64_t)v146 >= v808;
                if ((unint64_t)v146 >= v808)
                  v148 = -(uint64_t)(v810 * v787);
                else
                  v148 = 0;
                v54 = &v146[v148];
                v149 = v63 + 2 * v148;
                if (v147)
                  v150 = -(uint64_t)(v831 * v787);
                else
                  v150 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v150);
                v63 = v149 + 2 * v810;
                v69 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v135;
            }
            while (v135);
            goto LABEL_861;
          case 7:
            if ((_DWORD)v23)
            {
              v151 = (int)v39;
              v152 = v839[0];
              v61 = (char *)v825;
              do
              {
                v153 = v10;
                do
                {
                  v154 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  if (v154 != 0xFFFF)
                  {
                    if (v154)
                    {
                      v155 = bswap32(*(unsigned __int16 *)v68) >> 16;
                      v156 = bswap32(*(unsigned __int16 *)v58) >> 16;
                      v157 = v154 ^ 0xFFFF;
                      *(_WORD *)v68 = bswap32(v155 - ((v155 * v157 + ((v155 * v157) >> 16) + 1) >> 16)) >> 16;
                      v154 = bswap32(v156 - ((v156 * v157 + ((v156 * v157) >> 16) + 1) >> 16)) >> 16;
                    }
                    else
                    {
                      *(_WORD *)v68 = 0;
                    }
                    *(_WORD *)v58 = v154;
                  }
                  v158 = &v54[v786];
                  if ((unint64_t)v158 >= v63)
                    v159 = -(uint64_t)v788;
                  else
                    v159 = 0;
                  v54 = &v158[v159];
                  v60 += 2 * v151 + 2 * v159;
                  v68 += 2 * v786;
                  v58 += 2 * (int)v23;
                  --v153;
                }
                while (v153);
                if (v808)
                {
                  v160 = &v69[v810];
                  v161 = (unint64_t)v160 >= v808;
                  if ((unint64_t)v160 >= v808)
                    v162 = -(uint64_t)(v810 * v787);
                  else
                    v162 = 0;
                  v54 = &v160[v162];
                  v163 = v63 + 2 * v162;
                  if (v161)
                    v164 = -(uint64_t)(v831 * v787);
                  else
                    v164 = 0;
                  v60 = &v61[2 * v831 + 2 * v164];
                  v63 = v163 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v152;
              }
              while (v152);
              goto LABEL_947;
            }
            v489 = (int)v39;
            v490 = v839[0];
            v61 = (char *)v825;
LABEL_798:
            v491 = v10;
            while (1)
            {
              v492 = bswap32(*(unsigned __int16 *)v60) >> 16;
              if (!v492)
                goto LABEL_802;
              if (v492 != 0xFFFF)
                break;
LABEL_803:
              v494 = &v54[v786];
              if ((unint64_t)v494 >= v63)
                v495 = -(uint64_t)v788;
              else
                v495 = 0;
              v54 = &v494[v495];
              v60 += 2 * v489 + 2 * v495;
              v68 += 2 * v786;
              if (!--v491)
              {
                if (v808)
                {
                  v496 = &v69[v810];
                  v497 = (unint64_t)v496 >= v808;
                  if ((unint64_t)v496 >= v808)
                    v498 = -(uint64_t)(v810 * v787);
                  else
                    v498 = 0;
                  v54 = &v496[v498];
                  v499 = v63 + 2 * v498;
                  if (v497)
                    v500 = -(uint64_t)(v831 * v787);
                  else
                    v500 = 0;
                  v60 = &v61[2 * v831 + 2 * v500];
                  v63 = v499 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                if (!--v490)
                  goto LABEL_947;
                goto LABEL_798;
              }
            }
            v493 = bswap32(*(unsigned __int16 *)v68) >> 16;
            v492 = bswap32(v493 - ((v493 * (v492 ^ 0xFFFF) + ((v493 * (v492 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
LABEL_802:
            *(_WORD *)v68 = v492;
            goto LABEL_803;
          case 8:
            v165 = (int)v39;
            if (!(_DWORD)v23)
            {
              v501 = v839[0];
              v61 = (char *)v825;
              while (1)
              {
                v502 = v10;
                do
                {
                  v503 = bswap32(*(unsigned __int16 *)v60);
                  if (HIWORD(v503) == 0xFFFF)
                  {
                    v505 = ~HIWORD(v503);
                  }
                  else
                  {
                    if ((unsigned __int16)~HIWORD(v503) == 0xFFFF)
                      goto LABEL_825;
                    v504 = bswap32(*(unsigned __int16 *)v68) >> 16;
                    v505 = bswap32(v504 - ((v504 * HIWORD(v503) + ((v504 * HIWORD(v503)) >> 16) + 1) >> 16)) >> 16;
                  }
                  *(_WORD *)v68 = v505;
LABEL_825:
                  v506 = &v54[v786];
                  if ((unint64_t)v506 >= v63)
                    v507 = -(uint64_t)v788;
                  else
                    v507 = 0;
                  v54 = &v506[v507];
                  v60 += 2 * v165 + 2 * v507;
                  v68 += 2 * v786;
                  --v502;
                }
                while (v502);
                if (v808)
                {
                  v508 = &v69[v810];
                  v509 = (unint64_t)v508 >= v808;
                  if ((unint64_t)v508 >= v808)
                    v510 = -(uint64_t)(v810 * v787);
                  else
                    v510 = 0;
                  v54 = &v508[v510];
                  v511 = v63 + 2 * v510;
                  if (v509)
                    v512 = -(uint64_t)(v831 * v787);
                  else
                    v512 = 0;
                  v60 = &v61[2 * v831 + 2 * v512];
                  v63 = v511 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                if (!--v501)
                  goto LABEL_947;
              }
            }
            v166 = v839[0];
            v61 = (char *)v825;
            do
            {
              v167 = v10;
              do
              {
                v168 = bswap32(*(unsigned __int16 *)v60) >> 16;
                if (v168)
                {
                  if (v168 != 0xFFFF)
                  {
                    v170 = bswap32(*(unsigned __int16 *)v68) >> 16;
                    v171 = bswap32(*(unsigned __int16 *)v58) >> 16;
                    *(_WORD *)v68 = bswap32(v170 - ((v170 * v168 + ((v170 * v168) >> 16) + 1) >> 16)) >> 16;
                    v169 = bswap32(v171 - ((v171 * v168 + ((v171 * v168) >> 16) + 1) >> 16)) >> 16;
                  }
                  else
                  {
                    LOWORD(v169) = 0;
                    *(_WORD *)v68 = 0;
                  }
                  *(_WORD *)v58 = v169;
                }
                v172 = &v54[v786];
                if ((unint64_t)v172 >= v63)
                  v173 = -(uint64_t)v788;
                else
                  v173 = 0;
                v54 = &v172[v173];
                v60 += 2 * v165 + 2 * v173;
                v68 += 2 * v786;
                v58 += 2 * (int)v23;
                --v167;
              }
              while (v167);
              if (v808)
              {
                v174 = &v69[v810];
                v175 = (unint64_t)v174 >= v808;
                if ((unint64_t)v174 >= v808)
                  v176 = -(uint64_t)(v810 * v787);
                else
                  v176 = 0;
                v54 = &v174[v176];
                v177 = v63 + 2 * v176;
                if (v175)
                  v178 = -(uint64_t)(v831 * v787);
                else
                  v178 = 0;
                v60 = &v61[2 * v831 + 2 * v178];
                v63 = v177 + 2 * v810;
                v69 = v54;
                v61 = v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v166;
            }
            while (v166);
LABEL_947:
            v806 = v69;
            v56 = v63;
            v839[0] = 0;
LABEL_948:
            v43 = v789;
            v54 = (_WORD *)v790;
            if (!v789)
              return 1;
LABEL_949:
            v838 = 0;
            continue;
          case 9:
            v179 = (int)v39;
            v180 = v839[0];
            v61 = (char *)v825;
            do
            {
              v181 = v10;
              do
              {
                v182 = bswap32(*(unsigned __int16 *)v60) >> 16;
                v183 = bswap32(~*(unsigned __int16 *)v58);
                v184 = (bswap32((unsigned __int16)*v54) >> 16) * HIWORD(v183)
                     + (bswap32(*(unsigned __int16 *)v68) >> 16) * v182;
                *(_WORD *)v68 = bswap32(v184 + HIWORD(v184) + 1);
                *(_WORD *)v58 = bswap32((v182 + HIWORD(v183)) * v182 + (((v182 + HIWORD(v183)) * v182) >> 16) + 1);
                v185 = &v54[v786];
                if ((unint64_t)v185 >= v63)
                  v186 = -(uint64_t)v788;
                else
                  v186 = 0;
                v54 = &v185[v186];
                v60 += 2 * v179 + 2 * v186;
                v68 += 2 * v786;
                v58 += 2 * (int)v23;
                --v181;
              }
              while (v181);
              if (v808)
              {
                v187 = &v69[v810];
                v188 = (unint64_t)v187 >= v808;
                if ((unint64_t)v187 >= v808)
                  v189 = -(uint64_t)(v810 * v787);
                else
                  v189 = 0;
                v54 = &v187[v189];
                v190 = v63 + 2 * v189;
                if (v188)
                  v191 = -(uint64_t)(v831 * v787);
                else
                  v191 = 0;
                v60 = &v61[2 * v831 + 2 * v191];
                v63 = v190 + 2 * v810;
                v69 = v54;
                v61 = v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v180;
            }
            while (v180);
            goto LABEL_947;
          case 10:
            v192 = (int)v39;
            v193 = v839[0];
            v61 = (char *)v825;
            do
            {
              v194 = v10;
              do
              {
                v195 = bswap32(*(unsigned __int16 *)v60) >> 16;
                v196 = bswap32(~*(unsigned __int16 *)v58);
                v197 = (bswap32((unsigned __int16)*v54) >> 16) * HIWORD(v196)
                     + (bswap32(*(unsigned __int16 *)v68) >> 16) * (v195 ^ 0xFFFF);
                *(_WORD *)v68 = bswap32(v197 + HIWORD(v197) + 1);
                *(_WORD *)v58 = bswap32(((v195 ^ 0xFFFF) + HIWORD(v196)) * v195+ ((((v195 ^ 0xFFFF) + HIWORD(v196)) * v195) >> 16)+ 1);
                v198 = &v54[v786];
                if ((unint64_t)v198 >= v63)
                  v199 = -(uint64_t)v788;
                else
                  v199 = 0;
                v54 = &v198[v199];
                v60 += 2 * v192 + 2 * v199;
                v68 += 2 * v786;
                v58 += 2 * (int)v23;
                --v194;
              }
              while (v194);
              if (v808)
              {
                v200 = &v69[v810];
                v201 = (unint64_t)v200 >= v808;
                if ((unint64_t)v200 >= v808)
                  v202 = -(uint64_t)(v810 * v787);
                else
                  v202 = 0;
                v54 = &v200[v202];
                v203 = v63 + 2 * v202;
                if (v201)
                  v204 = -(uint64_t)(v831 * v787);
                else
                  v204 = 0;
                v60 = &v61[2 * v831 + 2 * v204];
                v63 = v203 + 2 * v810;
                v69 = v54;
                v61 = v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v193;
            }
            while (v193);
            goto LABEL_947;
          case 11:
            if ((_DWORD)v23)
            {
              v205 = v839[0];
              do
              {
                v206 = v10;
                do
                {
                  if ((_DWORD)v39)
                    v207 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  else
                    v207 = 0xFFFF;
                  v208 = bswap32(*(unsigned __int16 *)v58) >> 16;
                  v209 = v208
                       - ((bswap32(*(unsigned __int16 *)v68) >> 16)
                        + (bswap32((unsigned __int16)*v54) >> 16))
                       + v207;
                  v210 = v207 + v208;
                  if (v209 >= 0xFFFF)
                    v209 = 0xFFFF;
                  if (v210 >= 0xFFFF)
                    v210 = 0xFFFF;
                  *(_WORD *)v68 = bswap32(v210 - v209) >> 16;
                  *(_WORD *)v58 = bswap32(v210) >> 16;
                  v211 = &v54[v786];
                  if ((unint64_t)v211 >= v63)
                    v212 = -(uint64_t)v788;
                  else
                    v212 = 0;
                  v54 = &v211[v212];
                  v60 += 2 * (int)v39 + 2 * v212;
                  v68 += 2 * v786;
                  v58 += 2 * (int)v23;
                  --v206;
                }
                while (v206);
                if (v808)
                {
                  v213 = &v69[v810];
                  v214 = (unint64_t)v213 >= v808;
                  if ((unint64_t)v213 >= v808)
                    v215 = -(uint64_t)(v810 * v787);
                  else
                    v215 = 0;
                  v54 = &v213[v215];
                  v216 = v63 + 2 * v215;
                  if (v214)
                    v217 = -(uint64_t)(v831 * v787);
                  else
                    v217 = 0;
                  v60 = (char *)(v825 + 2 * v831 + 2 * v217);
                  v63 = v216 + 2 * v810;
                  v69 = v54;
                  v825 = (uint64_t)v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v205;
              }
              while (v205);
            }
            else
            {
              v513 = v839[0];
              do
              {
                v514 = v10;
                do
                {
                  if ((_DWORD)v39)
                    v515 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  else
                    v515 = 0xFFFF;
                  v516 = v515 - (bswap32((unsigned __int16)*v54) >> 16) + (bswap32(~*(unsigned __int16 *)v68) >> 16);
                  if (v516 >= 0xFFFF)
                    v516 = 0xFFFF;
                  *(_WORD *)v68 = bswap32(~v516) >> 16;
                  v517 = &v54[v786];
                  if ((unint64_t)v517 >= v63)
                    v518 = -(uint64_t)v788;
                  else
                    v518 = 0;
                  v54 = &v517[v518];
                  v60 += 2 * (int)v39 + 2 * v518;
                  v68 += 2 * v786;
                  --v514;
                }
                while (v514);
                if (v808)
                {
                  v519 = &v69[v810];
                  v520 = (unint64_t)v519 >= v808;
                  if ((unint64_t)v519 >= v808)
                    v521 = -(uint64_t)(v810 * v787);
                  else
                    v521 = 0;
                  v54 = &v519[v521];
                  v522 = v63 + 2 * v521;
                  if (v520)
                    v523 = -(uint64_t)(v831 * v787);
                  else
                    v523 = 0;
                  v60 = (char *)(v825 + 2 * v831 + 2 * v523);
                  v63 = v522 + 2 * v810;
                  v69 = v54;
                  v825 = (uint64_t)v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v513;
              }
              while (v513);
            }
            goto LABEL_861;
          case 12:
            if (!(_DWORD)v23)
            {
              v524 = (int)v39;
              v525 = v839[0];
              v61 = (char *)v825;
              do
              {
                v526 = v10;
                do
                {
                  v527 = bswap32(*(unsigned __int16 *)v68);
                  *(_WORD *)v68 = bswap32((v527 >> 15) & 0xFFFE | ((v527 >> 16) >> 15)) >> 16;
                  v528 = &v54[v786];
                  if ((unint64_t)v528 >= v63)
                    v529 = -(uint64_t)v788;
                  else
                    v529 = 0;
                  v54 = &v528[v529];
                  v60 += 2 * v524 + 2 * v529;
                  v68 += 2 * v786;
                  --v526;
                }
                while (v526);
                if (v808)
                {
                  v530 = &v69[v810];
                  v531 = (unint64_t)v530 >= v808;
                  if ((unint64_t)v530 >= v808)
                    v532 = -(uint64_t)(v810 * v787);
                  else
                    v532 = 0;
                  v54 = &v530[v532];
                  v533 = v63 + 2 * v532;
                  if (v531)
                    v534 = -(uint64_t)(v831 * v787);
                  else
                    v534 = 0;
                  v60 = &v61[2 * v831 + 2 * v534];
                  v63 = v533 + 2 * v810;
                  v69 = v54;
                  v61 = v60;
                }
                else
                {
                  v54 += v810;
                  v60 += 2 * v831;
                }
                v68 += 2 * v827;
                v58 += 2 * v829;
                --v525;
              }
              while (v525);
              goto LABEL_947;
            }
            v218 = v839[0];
            do
            {
              v219 = v10;
              do
              {
                if ((_DWORD)v39)
                  v220 = bswap32(*(unsigned __int16 *)v60) >> 16;
                else
                  v220 = 0xFFFF;
                v221 = (bswap32((unsigned __int16)*v54) >> 16) + (bswap32(*(unsigned __int16 *)v68) >> 16);
                v222 = v220 + (bswap32(*(unsigned __int16 *)v58) >> 16);
                if (v221 >= 0xFFFF)
                  v221 = 0xFFFF;
                if (v222 >= 0xFFFF)
                  v222 = 0xFFFF;
                *(_WORD *)v68 = bswap32(v221) >> 16;
                *(_WORD *)v58 = bswap32(v222) >> 16;
                v223 = &v54[v786];
                if ((unint64_t)v223 >= v63)
                  v224 = -(uint64_t)v788;
                else
                  v224 = 0;
                v54 = &v223[v224];
                v60 += 2 * (int)v39 + 2 * v224;
                v68 += 2 * v786;
                v58 += 2 * (int)v23;
                --v219;
              }
              while (v219);
              if (v808)
              {
                v225 = &v69[v810];
                v226 = (unint64_t)v225 >= v808;
                if ((unint64_t)v225 >= v808)
                  v227 = -(uint64_t)(v810 * v787);
                else
                  v227 = 0;
                v54 = &v225[v227];
                v228 = v63 + 2 * v227;
                if (v226)
                  v229 = -(uint64_t)(v831 * v787);
                else
                  v229 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v229);
                v63 = v228 + 2 * v810;
                v69 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              --v218;
            }
            while (v218);
LABEL_861:
            v806 = v69;
            v56 = v63;
            v839[0] = 0;
            goto LABEL_862;
          case 13:
            v230 = v839[0];
            while (1)
            {
              v231 = v10;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_348;
                  LODWORD(v232) = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_335:
                    v233 = 0xFFFF;
                    goto LABEL_336;
                  }
                }
                else
                {
                  LODWORD(v232) = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_335;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
LABEL_346:
                  v240 = v58;
                  goto LABEL_347;
                }
                v233 = __rev16(*(unsigned __int16 *)v58);
LABEL_336:
                v234 = bswap32((unsigned __int16)*v54);
                v235 = (v233 ^ 0xFFFF) * (unint64_t)HIWORD(v234)
                     + ((v232 ^ 0xFFFF) + HIWORD(v234))
                     * (unint64_t)(bswap32(*(unsigned __int16 *)v68) >> 16);
                if (v235 <= 0xFFFE8000)
                  v236 = v235 + 0x8000;
                else
                  v236 = 4294868992;
                v237 = v236 + (v236 >> 16);
                if ((_DWORD)v23)
                {
                  v238 = 0xFFFF * (v233 + (unint64_t)v232)
                       - v233 * (unint64_t)v232;
                  if (v238 <= 4294868992)
                    v239 = v238 + 0x8000;
                  else
                    v239 = 4294868992;
                  *(_WORD *)v68 = bswap32(v237);
                  v232 = ((v237 >> 16) | (v239 + (v239 >> 16))) >> 16;
                  goto LABEL_346;
                }
                v232 = v237 >> 16;
                v240 = v68;
LABEL_347:
                *(_WORD *)v240 = bswap32(v232) >> 16;
LABEL_348:
                v58 += 2 * (int)v23;
                v241 = &v54[v786];
                if ((unint64_t)v241 >= v63)
                  v242 = -(uint64_t)v788;
                else
                  v242 = 0;
                v54 = &v241[v242];
                v60 += 2 * (int)v39 + 2 * v242;
                v68 += 2 * v786;
                --v231;
              }
              while (v231);
              if (v808)
              {
                v243 = &v69[v810];
                v244 = (unint64_t)v243 >= v808;
                if ((unint64_t)v243 >= v808)
                  v245 = -(uint64_t)(v810 * v787);
                else
                  v245 = 0;
                v54 = &v243[v245];
                v246 = v63 + 2 * v245;
                if (v244)
                  v247 = -(uint64_t)(v831 * v787);
                else
                  v247 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v247);
                v63 = v246 + 2 * v810;
                v69 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              if (!--v230)
                goto LABEL_861;
            }
          case 14:
            v248 = v839[0];
            while (1)
            {
              v249 = v10;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_384;
                  LODWORD(v250) = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_371:
                    v251 = 0xFFFF;
                    goto LABEL_372;
                  }
                }
                else
                {
                  LODWORD(v250) = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_371;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
LABEL_382:
                  v258 = v58;
                  goto LABEL_383;
                }
                v251 = __rev16(*(unsigned __int16 *)v58);
LABEL_372:
                v252 = bswap32(*(unsigned __int16 *)v68) >> 16;
                v253 = (v252 ^ 0xFFFF) * (unint64_t)(bswap32((unsigned __int16)*v54) >> 16)
                     - v252
                     + (v252 << 16);
                if (v253 <= 0xFFFE8000)
                  v254 = v253 + 0x8000;
                else
                  v254 = 4294868992;
                v255 = v254 + (v254 >> 16);
                if ((_DWORD)v23)
                {
                  v256 = 0xFFFF * (v251 + (unint64_t)v250)
                       - v251 * (unint64_t)v250;
                  if (v256 <= 4294868992)
                    v257 = v256 + 0x8000;
                  else
                    v257 = 4294868992;
                  *(_WORD *)v68 = bswap32(v255);
                  v250 = ((v255 >> 16) | (v257 + (v257 >> 16))) >> 16;
                  goto LABEL_382;
                }
                v250 = v255 >> 16;
                v258 = v68;
LABEL_383:
                *(_WORD *)v258 = bswap32(v250) >> 16;
LABEL_384:
                v58 += 2 * (int)v23;
                v259 = &v54[v786];
                if ((unint64_t)v259 >= v63)
                  v260 = -(uint64_t)v788;
                else
                  v260 = 0;
                v54 = &v259[v260];
                v60 += 2 * (int)v39 + 2 * v260;
                v68 += 2 * v786;
                --v249;
              }
              while (v249);
              if (v808)
              {
                v261 = &v69[v810];
                v262 = (unint64_t)v261 >= v808;
                if ((unint64_t)v261 >= v808)
                  v263 = -(uint64_t)(v810 * v787);
                else
                  v263 = 0;
                v54 = &v261[v263];
                v264 = v63 + 2 * v263;
                if (v262)
                  v265 = -(uint64_t)(v831 * v787);
                else
                  v265 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v265);
                v63 = v264 + 2 * v810;
                v69 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              if (!--v248)
                goto LABEL_861;
            }
          case 15:
            v806 = v69;
            v780 = v59;
            v811 = v10;
            v266 = (int)v39;
            v267 = v839[0];
            v268 = 2 * (int)v23;
            while (1)
            {
              v791 = v267;
              v269 = v811;
              v270 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_412;
                  v271 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_407:
                    v272 = 0xFFFF;
                    goto LABEL_408;
                  }
                }
                else
                {
                  v271 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_407;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_411;
                }
                v272 = __rev16(*(unsigned __int16 *)v58);
LABEL_408:
                v273 = PDAoverlayPDA_8071(bswap32(*(unsigned __int16 *)v68) >> 16, v272, bswap32((unsigned __int16)*v54) >> 16, v271);
                *(_WORD *)v68 = bswap32(v273) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v270;
                if (!(_DWORD)v837)
                  goto LABEL_412;
                v271 = HIWORD(v273);
LABEL_411:
                *(_WORD *)v58 = __rev16(v271);
LABEL_412:
                v274 = &v54[v786];
                if ((unint64_t)v274 >= v63)
                  v275 = -(uint64_t)v788;
                else
                  v275 = 0;
                v54 = &v274[v275];
                v60 += 2 * v266 + 2 * v275;
                v68 += 2 * v786;
                v58 += v268;
                --v269;
              }
              while (v269);
              if (v808)
              {
                v276 = &v806[v810];
                v277 = (unint64_t)v276 >= v808;
                v278 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v276 < v808)
                  v278 = 0;
                v54 = &v276[v278];
                v279 = v63 + 2 * v278;
                v280 = -(uint64_t)(v831 * v787);
                if (!v277)
                  v280 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v280);
                v63 = v279 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v267 = v791 - 1;
              if (v791 == 1)
                goto LABEL_752;
            }
          case 16:
            v806 = v69;
            v780 = v59;
            v812 = v10;
            v281 = (int)v39;
            v282 = v839[0];
            v283 = 2 * (int)v23;
            while (1)
            {
              v792 = v282;
              v284 = v812;
              v285 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_438;
                  v286 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_433:
                    v287 = 0xFFFF;
                    goto LABEL_434;
                  }
                }
                else
                {
                  v286 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_433;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_437;
                }
                v287 = __rev16(*(unsigned __int16 *)v58);
LABEL_434:
                v288 = PDAdarkenPDA_8073(bswap32(*(unsigned __int16 *)v68) >> 16, v287, bswap32((unsigned __int16)*v54) >> 16, v286);
                *(_WORD *)v68 = bswap32(v288) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v285;
                if (!(_DWORD)v837)
                  goto LABEL_438;
                v286 = HIWORD(v288);
LABEL_437:
                *(_WORD *)v58 = __rev16(v286);
LABEL_438:
                v289 = &v54[v786];
                if ((unint64_t)v289 >= v63)
                  v290 = -(uint64_t)v788;
                else
                  v290 = 0;
                v54 = &v289[v290];
                v60 += 2 * v281 + 2 * v290;
                v68 += 2 * v786;
                v58 += v283;
                --v284;
              }
              while (v284);
              if (v808)
              {
                v291 = &v806[v810];
                v292 = (unint64_t)v291 >= v808;
                v293 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v291 < v808)
                  v293 = 0;
                v54 = &v291[v293];
                v294 = v63 + 2 * v293;
                v295 = -(uint64_t)(v831 * v787);
                if (!v292)
                  v295 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v295);
                v63 = v294 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v282 = v792 - 1;
              if (v792 == 1)
                goto LABEL_752;
            }
          case 17:
            v806 = v69;
            v780 = v59;
            v813 = v10;
            v296 = (int)v39;
            v297 = v839[0];
            v298 = 2 * (int)v23;
            while (1)
            {
              v793 = v297;
              v299 = v813;
              v300 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_464;
                  v301 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_459:
                    v302 = 0xFFFF;
                    goto LABEL_460;
                  }
                }
                else
                {
                  v301 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_459;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_463;
                }
                v302 = __rev16(*(unsigned __int16 *)v58);
LABEL_460:
                v303 = PDAlightenPDA_8072(bswap32(*(unsigned __int16 *)v68) >> 16, v302, bswap32((unsigned __int16)*v54) >> 16, v301);
                *(_WORD *)v68 = bswap32(v303) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v300;
                if (!(_DWORD)v837)
                  goto LABEL_464;
                v301 = HIWORD(v303);
LABEL_463:
                *(_WORD *)v58 = __rev16(v301);
LABEL_464:
                v304 = &v54[v786];
                if ((unint64_t)v304 >= v63)
                  v305 = -(uint64_t)v788;
                else
                  v305 = 0;
                v54 = &v304[v305];
                v60 += 2 * v296 + 2 * v305;
                v68 += 2 * v786;
                v58 += v298;
                --v299;
              }
              while (v299);
              if (v808)
              {
                v306 = &v806[v810];
                v307 = (unint64_t)v306 >= v808;
                v308 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v306 < v808)
                  v308 = 0;
                v54 = &v306[v308];
                v309 = v63 + 2 * v308;
                v310 = -(uint64_t)(v831 * v787);
                if (!v307)
                  v310 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v310);
                v63 = v309 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v297 = v793 - 1;
              if (v793 == 1)
                goto LABEL_752;
            }
          case 18:
            v806 = v69;
            v780 = v59;
            v814 = v10;
            v311 = (int)v39;
            v312 = v839[0];
            v313 = 2 * (int)v23;
            while (1)
            {
              v794 = v312;
              v314 = v814;
              v315 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_490;
                  v316 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_485:
                    v317 = 0xFFFF;
                    goto LABEL_486;
                  }
                }
                else
                {
                  v316 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_485;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_489;
                }
                v317 = __rev16(*(unsigned __int16 *)v58);
LABEL_486:
                v318 = PDAcolordodgePDA_8074(bswap32(*(unsigned __int16 *)v68) >> 16, v317, bswap32((unsigned __int16)*v54) >> 16, v316);
                *(_WORD *)v68 = bswap32(v318) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v315;
                if (!(_DWORD)v837)
                  goto LABEL_490;
                v316 = HIWORD(v318);
LABEL_489:
                *(_WORD *)v58 = __rev16(v316);
LABEL_490:
                v319 = &v54[v786];
                if ((unint64_t)v319 >= v63)
                  v320 = -(uint64_t)v788;
                else
                  v320 = 0;
                v54 = &v319[v320];
                v60 += 2 * v311 + 2 * v320;
                v68 += 2 * v786;
                v58 += v313;
                --v314;
              }
              while (v314);
              if (v808)
              {
                v321 = &v806[v810];
                v322 = (unint64_t)v321 >= v808;
                v323 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v321 < v808)
                  v323 = 0;
                v54 = &v321[v323];
                v324 = v63 + 2 * v323;
                v325 = -(uint64_t)(v831 * v787);
                if (!v322)
                  v325 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v325);
                v63 = v324 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v312 = v794 - 1;
              if (v794 == 1)
                goto LABEL_752;
            }
          case 19:
            v806 = v69;
            v780 = v59;
            v815 = v10;
            v326 = (int)v39;
            v327 = v839[0];
            v328 = 2 * (int)v23;
            while (1)
            {
              v795 = v327;
              v329 = v815;
              v330 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_516;
                  v331 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_511:
                    v332 = 0xFFFF;
                    goto LABEL_512;
                  }
                }
                else
                {
                  v331 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_511;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_515;
                }
                v332 = __rev16(*(unsigned __int16 *)v58);
LABEL_512:
                v333 = PDAcolorburnPDA_8075(bswap32(*(unsigned __int16 *)v68) >> 16, v332, bswap32((unsigned __int16)*v54) >> 16, v331);
                *(_WORD *)v68 = bswap32(v333) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v330;
                if (!(_DWORD)v837)
                  goto LABEL_516;
                v331 = HIWORD(v333);
LABEL_515:
                *(_WORD *)v58 = __rev16(v331);
LABEL_516:
                v334 = &v54[v786];
                if ((unint64_t)v334 >= v63)
                  v335 = -(uint64_t)v788;
                else
                  v335 = 0;
                v54 = &v334[v335];
                v60 += 2 * v326 + 2 * v335;
                v68 += 2 * v786;
                v58 += v328;
                --v329;
              }
              while (v329);
              if (v808)
              {
                v336 = &v806[v810];
                v337 = (unint64_t)v336 >= v808;
                v338 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v336 < v808)
                  v338 = 0;
                v54 = &v336[v338];
                v339 = v63 + 2 * v338;
                v340 = -(uint64_t)(v831 * v787);
                if (!v337)
                  v340 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v340);
                v63 = v339 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v327 = v795 - 1;
              if (v795 == 1)
                goto LABEL_752;
            }
          case 20:
            v806 = v69;
            v781 = v59;
            v816 = v10;
            v341 = (int)v39;
            v342 = v839[0];
            v343 = 2 * (int)v23;
            while (1)
            {
              v796 = v342;
              v344 = v816;
              v345 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_542;
                  v346 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_537:
                    v347 = 0xFFFF;
                    goto LABEL_538;
                  }
                }
                else
                {
                  v346 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_537;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_541;
                }
                v347 = __rev16(*(unsigned __int16 *)v58);
LABEL_538:
                v348 = PDAsoftlightPDA_8077(bswap32(*(unsigned __int16 *)v68) >> 16, v347, bswap32((unsigned __int16)*v54) >> 16, v346);
                *(_WORD *)v68 = bswap32(v348) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v345;
                if (!(_DWORD)v837)
                  goto LABEL_542;
                v346 = HIWORD(v348);
LABEL_541:
                *(_WORD *)v58 = __rev16(v346);
LABEL_542:
                v349 = &v54[v786];
                if ((unint64_t)v349 >= v63)
                  v350 = -(uint64_t)v788;
                else
                  v350 = 0;
                v54 = &v349[v350];
                v60 += 2 * v341 + 2 * v350;
                v68 += 2 * v786;
                v58 += v343;
                --v344;
              }
              while (v344);
              if (v808)
              {
                v351 = &v806[v810];
                v352 = (unint64_t)v351 >= v808;
                v353 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v351 < v808)
                  v353 = 0;
                v54 = &v351[v353];
                v354 = v63 + 2 * v353;
                v355 = -(uint64_t)(v831 * v787);
                if (!v352)
                  v355 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v355);
                v63 = v354 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v342 = v796 - 1;
              if (v796 == 1)
                goto LABEL_726;
            }
          case 21:
            v806 = v69;
            v780 = v59;
            v817 = v10;
            v356 = (int)v39;
            v357 = v839[0];
            v358 = 2 * (int)v23;
            while (1)
            {
              v797 = v357;
              v359 = v817;
              v360 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_568;
                  v361 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_563:
                    v362 = 0xFFFF;
                    goto LABEL_564;
                  }
                }
                else
                {
                  v361 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_563;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_567;
                }
                v362 = __rev16(*(unsigned __int16 *)v58);
LABEL_564:
                v363 = PDAhardlightPDA_8076(bswap32(*(unsigned __int16 *)v68) >> 16, v362, bswap32((unsigned __int16)*v54) >> 16, v361);
                *(_WORD *)v68 = bswap32(v363) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v360;
                if (!(_DWORD)v837)
                  goto LABEL_568;
                v361 = HIWORD(v363);
LABEL_567:
                *(_WORD *)v58 = __rev16(v361);
LABEL_568:
                v364 = &v54[v786];
                if ((unint64_t)v364 >= v63)
                  v365 = -(uint64_t)v788;
                else
                  v365 = 0;
                v54 = &v364[v365];
                v60 += 2 * v356 + 2 * v365;
                v68 += 2 * v786;
                v58 += v358;
                --v359;
              }
              while (v359);
              if (v808)
              {
                v366 = &v806[v810];
                v367 = (unint64_t)v366 >= v808;
                v368 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v366 < v808)
                  v368 = 0;
                v54 = &v366[v368];
                v369 = v63 + 2 * v368;
                v370 = -(uint64_t)(v831 * v787);
                if (!v367)
                  v370 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v370);
                v63 = v369 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v357 = v797 - 1;
              if (v797 == 1)
                goto LABEL_752;
            }
          case 22:
            v806 = v69;
            v781 = v59;
            v818 = v10;
            v371 = (int)v39;
            v372 = v839[0];
            v373 = 2 * (int)v23;
            while (1)
            {
              v798 = v372;
              v374 = v818;
              v375 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_594;
                  v376 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_589:
                    v377 = 0xFFFF;
                    goto LABEL_590;
                  }
                }
                else
                {
                  v376 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_589;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_593;
                }
                v377 = __rev16(*(unsigned __int16 *)v58);
LABEL_590:
                v378 = PDAdifferencePDA_8078(bswap32(*(unsigned __int16 *)v68) >> 16, v377, bswap32((unsigned __int16)*v54) >> 16, v376);
                *(_WORD *)v68 = bswap32(v378) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v375;
                if (!(_DWORD)v837)
                  goto LABEL_594;
                v376 = HIWORD(v378);
LABEL_593:
                *(_WORD *)v58 = __rev16(v376);
LABEL_594:
                v379 = &v54[v786];
                if ((unint64_t)v379 >= v63)
                  v380 = -(uint64_t)v788;
                else
                  v380 = 0;
                v54 = &v379[v380];
                v60 += 2 * v371 + 2 * v380;
                v68 += 2 * v786;
                v58 += v373;
                --v374;
              }
              while (v374);
              if (v808)
              {
                v381 = &v806[v810];
                v382 = (unint64_t)v381 >= v808;
                v383 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v381 < v808)
                  v383 = 0;
                v54 = &v381[v383];
                v384 = v63 + 2 * v383;
                v385 = -(uint64_t)(v831 * v787);
                if (!v382)
                  v385 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v385);
                v63 = v384 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v372 = v798 - 1;
              if (v798 == 1)
                goto LABEL_726;
            }
          case 23:
            v386 = v839[0];
            while (1)
            {
              v387 = v10;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_634;
                  LODWORD(v388) = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_615:
                    v389 = 0xFFFF;
                    goto LABEL_616;
                  }
                }
                else
                {
                  LODWORD(v388) = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_615;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
LABEL_632:
                  v397 = v58;
                  goto LABEL_633;
                }
                v389 = __rev16(*(unsigned __int16 *)v58);
LABEL_616:
                LODWORD(v390) = bswap32(*(unsigned __int16 *)v68) >> 16;
                LODWORD(v391) = bswap32((unsigned __int16)*v54) >> 16;
                if (v391 >= v388)
                  v391 = v388;
                else
                  v391 = v391;
                if (v390 >= v389)
                  v390 = v389;
                else
                  v390 = v390;
                v392 = 0xFFFF * (v391 + v390) - 2 * v390 * (unint64_t)v391;
                if (v392 <= 4294868992)
                  v393 = v392 + 0x8000;
                else
                  v393 = 4294868992;
                v394 = v393 + (v393 >> 16);
                if ((_DWORD)v23)
                {
                  v395 = 0xFFFF * (v389 + (unint64_t)v388)
                       - v389 * (unint64_t)v388;
                  if (v395 <= 4294868992)
                    v396 = v395 + 0x8000;
                  else
                    v396 = 4294868992;
                  *(_WORD *)v68 = bswap32(v394);
                  v388 = ((v394 >> 16) | (v396 + (v396 >> 16))) >> 16;
                  goto LABEL_632;
                }
                v388 = v394 >> 16;
                v397 = v68;
LABEL_633:
                *(_WORD *)v397 = bswap32(v388) >> 16;
LABEL_634:
                v58 += 2 * (int)v23;
                v398 = &v54[v786];
                if ((unint64_t)v398 >= v63)
                  v399 = -(uint64_t)v788;
                else
                  v399 = 0;
                v54 = &v398[v399];
                v60 += 2 * (int)v39 + 2 * v399;
                v68 += 2 * v786;
                --v387;
              }
              while (v387);
              if (v808)
              {
                v400 = &v69[v810];
                v401 = (unint64_t)v400 >= v808;
                if ((unint64_t)v400 >= v808)
                  v402 = -(uint64_t)(v810 * v787);
                else
                  v402 = 0;
                v54 = &v400[v402];
                v403 = v63 + 2 * v402;
                if (v401)
                  v404 = -(uint64_t)(v831 * v787);
                else
                  v404 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v404);
                v63 = v403 + 2 * v810;
                v69 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              if (!--v386)
                goto LABEL_861;
            }
          case 24:
            v806 = v69;
            v781 = v59;
            v819 = v10;
            v405 = (int)v39;
            v406 = v839[0];
            v407 = 2 * (int)v23;
            while (1)
            {
              v799 = v406;
              v408 = v819;
              v409 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_662;
                  v410 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_657:
                    v411 = 0xFFFF;
                    goto LABEL_658;
                  }
                }
                else
                {
                  v410 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_657;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_661;
                }
                v411 = __rev16(*(unsigned __int16 *)v58);
LABEL_658:
                v412 = PDAhuePDA_8079(bswap32(*(unsigned __int16 *)v68) >> 16, v411, bswap32((unsigned __int16)*v54) >> 16, v410);
                *(_WORD *)v68 = bswap32(v412) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v409;
                if (!(_DWORD)v837)
                  goto LABEL_662;
                v410 = HIWORD(v412);
LABEL_661:
                *(_WORD *)v58 = __rev16(v410);
LABEL_662:
                v413 = &v54[v786];
                if ((unint64_t)v413 >= v63)
                  v414 = -(uint64_t)v788;
                else
                  v414 = 0;
                v54 = &v413[v414];
                v60 += 2 * v405 + 2 * v414;
                v68 += 2 * v786;
                v58 += v407;
                --v408;
              }
              while (v408);
              if (v808)
              {
                v415 = &v806[v810];
                v416 = (unint64_t)v415 >= v808;
                v417 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v415 < v808)
                  v417 = 0;
                v54 = &v415[v417];
                v418 = v63 + 2 * v417;
                v419 = -(uint64_t)(v831 * v787);
                if (!v416)
                  v419 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v419);
                v63 = v418 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v406 = v799 - 1;
              if (v799 == 1)
                goto LABEL_726;
            }
          case 25:
            v806 = v69;
            v781 = v59;
            v820 = v10;
            v420 = (int)v39;
            v421 = v839[0];
            v422 = 2 * (int)v23;
            while (1)
            {
              v800 = v421;
              v423 = v820;
              v424 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_688;
                  v425 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_683:
                    v426 = 0xFFFF;
                    goto LABEL_684;
                  }
                }
                else
                {
                  v425 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_683;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_687;
                }
                v426 = __rev16(*(unsigned __int16 *)v58);
LABEL_684:
                v427 = PDAhuePDA_8079(bswap32(*(unsigned __int16 *)v68) >> 16, v426, bswap32((unsigned __int16)*v54) >> 16, v425);
                *(_WORD *)v68 = bswap32(v427) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v424;
                if (!(_DWORD)v837)
                  goto LABEL_688;
                v425 = HIWORD(v427);
LABEL_687:
                *(_WORD *)v58 = __rev16(v425);
LABEL_688:
                v428 = &v54[v786];
                if ((unint64_t)v428 >= v63)
                  v429 = -(uint64_t)v788;
                else
                  v429 = 0;
                v54 = &v428[v429];
                v60 += 2 * v420 + 2 * v429;
                v68 += 2 * v786;
                v58 += v422;
                --v423;
              }
              while (v423);
              if (v808)
              {
                v430 = &v806[v810];
                v431 = (unint64_t)v430 >= v808;
                v432 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v430 < v808)
                  v432 = 0;
                v54 = &v430[v432];
                v433 = v63 + 2 * v432;
                v434 = -(uint64_t)(v831 * v787);
                if (!v431)
                  v434 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v434);
                v63 = v433 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v421 = v800 - 1;
              if (v800 == 1)
                goto LABEL_726;
            }
          case 26:
            v806 = v69;
            v781 = v59;
            v821 = v10;
            v435 = (int)v39;
            v436 = v839[0];
            v437 = 2 * (int)v23;
            while (1)
            {
              v801 = v436;
              v438 = v821;
              v439 = v63;
              do
              {
                if ((_DWORD)v39)
                {
                  if (!*(_WORD *)v60)
                    goto LABEL_714;
                  v440 = __rev16(*(unsigned __int16 *)v60);
                  if (!(_DWORD)v23)
                  {
LABEL_709:
                    v441 = 0xFFFF;
                    goto LABEL_710;
                  }
                }
                else
                {
                  v440 = 0xFFFF;
                  if (!(_DWORD)v23)
                    goto LABEL_709;
                }
                if (!*(_WORD *)v58)
                {
                  *(_WORD *)v68 = *v54;
                  goto LABEL_713;
                }
                v441 = __rev16(*(unsigned __int16 *)v58);
LABEL_710:
                v442 = PDAluminosityPDA_8081(bswap32((unsigned __int16)*v54) >> 16, v440, bswap32(*(unsigned __int16 *)v68) >> 16, v441);
                *(_WORD *)v68 = bswap32(v442) >> 16;
                LODWORD(v39) = v834;
                LODWORD(v23) = v837;
                v63 = v439;
                if (!(_DWORD)v837)
                  goto LABEL_714;
                v440 = HIWORD(v442);
LABEL_713:
                *(_WORD *)v58 = __rev16(v440);
LABEL_714:
                v443 = &v54[v786];
                if ((unint64_t)v443 >= v63)
                  v444 = -(uint64_t)v788;
                else
                  v444 = 0;
                v54 = &v443[v444];
                v60 += 2 * v435 + 2 * v444;
                v68 += 2 * v786;
                v58 += v437;
                --v438;
              }
              while (v438);
              if (v808)
              {
                v445 = &v806[v810];
                v446 = (unint64_t)v445 >= v808;
                v447 = -(uint64_t)(v810 * v787);
                if ((unint64_t)v445 < v808)
                  v447 = 0;
                v54 = &v445[v447];
                v448 = v63 + 2 * v447;
                v449 = -(uint64_t)(v831 * v787);
                if (!v446)
                  v449 = 0;
                v60 = (char *)(v825 + 2 * v831 + 2 * v449);
                v63 = v448 + 2 * v810;
                v806 = v54;
                v825 = (uint64_t)v60;
              }
              else
              {
                v54 += v810;
                v60 += 2 * v831;
              }
              v68 += 2 * v827;
              v58 += 2 * v829;
              v436 = v801 - 1;
              if (v801 == 1)
              {
LABEL_726:
                v56 = v63;
                v839[0] = 0;
                v59 = v781;
                v7 = v782;
                v9 = v778;
                goto LABEL_862;
              }
            }
          case 27:
            v806 = v69;
            v780 = v59;
            v822 = v10;
            v450 = (int)v39;
            v451 = v839[0];
            v452 = 2 * (int)v23;
            break;
          default:
            v806 = v69;
            v56 = v63;
            goto LABEL_862;
        }
        break;
      }
LABEL_728:
      v802 = v451;
      v453 = v822;
      v454 = v63;
      while (1)
      {
        if ((_DWORD)v39)
        {
          if (!*(_WORD *)v60)
            goto LABEL_740;
          v455 = __rev16(*(unsigned __int16 *)v60);
          if ((_DWORD)v23)
          {
LABEL_732:
            if (!*(_WORD *)v58)
            {
              *(_WORD *)v68 = *v54;
              goto LABEL_739;
            }
            v456 = __rev16(*(unsigned __int16 *)v58);
            goto LABEL_736;
          }
        }
        else
        {
          v455 = 0xFFFF;
          if ((_DWORD)v23)
            goto LABEL_732;
        }
        v456 = 0xFFFF;
LABEL_736:
        v457 = PDAluminosityPDA_8081(bswap32(*(unsigned __int16 *)v68) >> 16, v456, bswap32((unsigned __int16)*v54) >> 16, v455);
        *(_WORD *)v68 = bswap32(v457) >> 16;
        LODWORD(v39) = v834;
        LODWORD(v23) = v837;
        v63 = v454;
        if ((_DWORD)v837)
        {
          v455 = HIWORD(v457);
LABEL_739:
          *(_WORD *)v58 = __rev16(v455);
        }
LABEL_740:
        v458 = &v54[v786];
        if ((unint64_t)v458 >= v63)
          v459 = -(uint64_t)v788;
        else
          v459 = 0;
        v54 = &v458[v459];
        v60 += 2 * v450 + 2 * v459;
        v68 += 2 * v786;
        v58 += v452;
        if (!--v453)
        {
          if (v808)
          {
            v460 = &v806[v810];
            v461 = (unint64_t)v460 >= v808;
            v462 = -(uint64_t)(v810 * v787);
            if ((unint64_t)v460 < v808)
              v462 = 0;
            v54 = &v460[v462];
            v463 = v63 + 2 * v462;
            v464 = -(uint64_t)(v831 * v787);
            if (!v461)
              v464 = 0;
            v60 = (char *)(v825 + 2 * v831 + 2 * v464);
            v63 = v463 + 2 * v810;
            v806 = v54;
            v825 = (uint64_t)v60;
          }
          else
          {
            v54 += v810;
            v60 += 2 * v831;
          }
          v68 += 2 * v827;
          v58 += 2 * v829;
          v451 = v802 - 1;
          if (v802 == 1)
          {
LABEL_752:
            v56 = v63;
            v839[0] = 0;
            v59 = v780;
            v7 = v782;
            v9 = v778;
            goto LABEL_862;
          }
          goto LABEL_728;
        }
      }
    }
    v62 = v55 * (int)v10;
    v829 = v784 - (int)v23 * (int)v10;
    v63 = -1;
    v786 = v55;
    v787 = v38;
    v64 = v810;
    v788 = v810;
    goto LABEL_62;
  }
  v15 = *(_DWORD *)(v3 + 128);
  if ((v15 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      W16_mark_constmask(v3, v7);
    else
      W16_mark_pixelmask(v3, v7);
    return 1;
  }
  v24 = *(_DWORD *)(v3 + 112);
  v25 = *(_DWORD *)(v3 + 116);
  v26 = (v24 + 15) & 0xFFFFFFF0;
  v27 = v26 * v25;
  if ((int)v27 <= 4096)
  {
    v29 = v849;
    v30 = v3;
    goto LABEL_38;
  }
  v28 = malloc_type_malloc(v27, 0x8303D2FuLL);
  if (v28)
  {
    v29 = v28;
    v30 = v778;
    v14 = *(uint16x4_t **)(v778 + 136);
    v15 = *(_DWORD *)(v778 + 128);
LABEL_38:
    CGSConvertBitsToMask(v14, *(_DWORD *)(v30 + 124), v29, v26, v24, v25, v15);
    v48 = *(_OWORD *)(v30 + 112);
    v845 = *(_OWORD *)(v30 + 96);
    v846 = v48;
    v49 = *(_OWORD *)(v30 + 144);
    v847 = *(_OWORD *)(v30 + 128);
    v848 = v49;
    v50 = *(_OWORD *)(v30 + 48);
    v841 = *(_OWORD *)(v30 + 32);
    v842 = v50;
    v51 = *(_OWORD *)(v30 + 80);
    v843 = *(_OWORD *)(v30 + 64);
    v844 = v51;
    v52 = *(_OWORD *)(v30 + 16);
    *(_OWORD *)v839 = *(_OWORD *)v30;
    v840 = v52;
    HIDWORD(v846) = (v24 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v847 + 1) = v29;
    if (BYTE1(v839[0]) << 8 == 1024)
      W16_mark_constmask((uint64_t)v839, v782);
    else
      W16_mark_pixelmask((unint64_t)v839, v782);
    if (v29 == (_BYTE *)v849)
      return 1;
    v53 = v29;
    goto LABEL_1380;
  }
  return 1;
}

uint64_t W16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL4 v7;
  signed int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  unsigned int v18;
  unsigned int v19;
  char v20;
  int v21;
  int v22;
  unint64_t v23;
  uint64_t (*v24)(uint64_t, int *, int, int, int, int);
  uint64_t v25;
  int v26;
  int v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _OWORD v45[64];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v28 = 0u;
  memset(v45, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*(_QWORD *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v28, (uint64_t)v45) < 1)
    return 0xFFFFFFFFLL;
  v18 = *(_DWORD *)a3;
  *((_QWORD *)&v28 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v18 != 68161796)
  {
    v19 = SAMPLEINDEX(v18, v10, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      if (v19 > 0xB)
      {
LABEL_20:
        v21 = 255;
        v20 = 1;
      }
      else
      {
        v20 = 0;
        v21 = 0;
        switch(v19)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v20 = 0;
            v21 = 16;
            break;
          case 5u:
            v20 = 0;
            v21 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v20 = 0;
            v21 = 32;
            break;
          case 8u:
            v20 = 0;
            v21 = 8;
            break;
          case 9u:
            v20 = 0;
            v21 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(_QWORD *)&v28 = *(_QWORD *)&W16_image_sample[2 * v19 + 2];
      if ((_QWORD)v28)
      {
        v22 = 68161828;
        goto LABEL_28;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(_QWORD *)&v28 = *(_QWORD *)&W8_image_sample[2 * v19 + 2];
        if ((_QWORD)v28)
        {
          v22 = 34083076;
          goto LABEL_28;
        }
      }
      *(_QWORD *)&v28 = *(_QWORD *)&WF_image_sample[2 * v19 + 2];
      if ((_QWORD)v28)
      {
        LODWORD(v29) = 8;
        v22 = 136319269;
LABEL_28:
        DWORD2(v28) = v22;
        if ((v20 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v29) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v19 <= 0xB)
        {
          HIDWORD(v23) = v21;
          LODWORD(v23) = v21;
          switch((v23 >> 3))
          {
            case 0u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = W16_image_mark_RGB32;
              goto LABEL_51;
            case 1u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = W16_image_mark_RGB32;
              goto LABEL_53;
            case 2u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = W16_image_mark_W8;
              goto LABEL_51;
            case 3u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = W16_image_mark_RGB24;
              goto LABEL_51;
            case 4u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = W16_image_mark_rgb32;
LABEL_51:
              v25 = (uint64_t)a2;
              v26 = v8;
              v27 = 0;
              break;
            case 5u:
              DWORD2(v28) = *(_DWORD *)a3;
              v24 = W16_image_mark_rgb32;
LABEL_53:
              v25 = (uint64_t)a2;
              v26 = v8;
              v27 = 8;
              break;
            default:
              goto LABEL_29;
          }
          w16_image_mark_image(v25, (uint64_t)&v28, v26, v27, (void (*)(_QWORD, _QWORD))v24);
          return 1;
        }
        goto LABEL_29;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(_QWORD)v39 && (~DWORD1(v29) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((BYTE4(v29) & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      W16_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(_QWORD *)&v28 = w16_sample_W16;
LABEL_29:
  W16_image_mark((uint64_t)a2, (uint64_t)&v28, v8, v17);
  return 1;
}

uint64_t W16_shade(uint64_t a1, __n128 a2)
{
  uint64_t *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  signed int v11;
  __n128 v13;
  void *v14;
  unint64_t v15;
  _BYTE *v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38[2];
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[2];
  int v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[40];
  uint64_t v47;

  v2 = (uint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v7 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v8 = *v2;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  v9 = *(_QWORD *)(v8 + 56);
  v10 = *v3;
  if (!*((_QWORD *)v3 + 12))
  {
    if (*(_QWORD *)(v4 + 72))
      v7 = 0;
    else
      v7 = *(float *)(v4 + 4) >= 1.0;
  }
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v11 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) == 0x1000000)
  {
    if (*(_QWORD *)(v5 + 16))
    {
      v14 = w16_shade_radial_W;
    }
    else if (*(_QWORD *)(v5 + 24))
    {
      v14 = w16_shade_conic_W;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      v14 = w16_shade_axial_W;
    }
    else
    {
      v14 = w16_shade_custom_W;
    }
    *(_QWORD *)&v17[0] = v14;
    if ((_QWORD)v40)
    {
      *((_QWORD *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 1, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    v15 = *((_QWORD *)&v19 + 1) * v19;
    if ((uint64_t)(*((_QWORD *)&v19 + 1) * v19) <= 960)
    {
      v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 1, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(_BYTE *)(v5 + 1))
        *(_QWORD *)&v39 = &_blt_shade_samples_noise;
      goto LABEL_29;
    }
    v16 = malloc_type_malloc(4 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      v15 = *((_QWORD *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)&v17[0])
    return 0xFFFFFFFFLL;
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  W16_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1]))
    free(v38[1]);
  return 1;
}

void W16_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  float v9;
  int *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unsigned __int16 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int16 *v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  unsigned __int8 *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  int v58;
  int32x2_t v59;
  uint64_t v60;
  int32x2_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t, uint64_t, uint64_t);
  int32x2_t v65;
  unsigned __int16 *v66;
  _BYTE *v67;
  unsigned int v68;
  int v69;
  _BYTE *v70;
  int v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  float *v75;
  float v76;
  int v77;
  float v78;
  int v79;
  unsigned int v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  int32x2_t v84;
  int32x2_t v85;
  uint32x2_t v86;
  int32x2_t v87;
  uint64_t v88;
  float *v89;
  float v90;
  int v91;
  float v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  unsigned __int8 *v98;
  uint64_t v99;
  int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  int v104;
  int v105;
  unsigned __int8 *v106;
  unsigned __int16 *v107;
  unsigned __int16 *v108;
  int v109;
  uint64_t v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  int v114;
  unsigned int v115;
  int v116;
  unsigned int v117;
  int v118;
  int v119;
  unsigned __int8 *v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  int v124;
  int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  int v133;
  unsigned int v134;
  int v135;
  int v136;
  unsigned __int8 *v137;
  int v138;
  int v139;
  unsigned int v140;
  unsigned int v141;
  int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  int v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  int v155;
  int v156;
  unsigned int v157;
  int v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  int v162;
  int v163;
  unsigned int v164;
  int v165;
  int v166;
  unsigned int v167;
  int v168;
  unsigned int v169;
  uint64_t v170;
  int v171;
  int v172;
  unsigned int v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  unsigned int v178;
  unsigned int v179;
  int v180;
  unsigned int v181;
  unsigned int v182;
  int v183;
  unsigned int v184;
  unsigned int v185;
  uint64_t v186;
  int v187;
  int v188;
  unsigned int v189;
  unsigned int v190;
  int v191;
  unsigned int v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  int v196;
  unsigned int v197;
  unsigned int v198;
  int v199;
  unsigned int v200;
  unsigned int v201;
  int v202;
  int v203;
  unsigned __int16 v204;
  unsigned int v205;
  unsigned int v206;
  unsigned int v207;
  unsigned int v208;
  int v209;
  int v210;
  int v211;
  unsigned int v212;
  unsigned int v213;
  unsigned int v214;
  unsigned int v215;
  uint64_t v216;
  int v217;
  int v218;
  int v219;
  unsigned int v220;
  unsigned int v221;
  unsigned int v222;
  int v223;
  unsigned int v224;
  int v225;
  int v226;
  unsigned int v227;
  signed int v228;
  uint64_t v229;
  int v230;
  int v231;
  int v232;
  unsigned int v233;
  unsigned int v234;
  unsigned int v235;
  int v236;
  int v237;
  int v238;
  unsigned int v239;
  unsigned int v240;
  unint64_t v241;
  unsigned int v242;
  unint64_t v243;
  unint64_t v244;
  unint64_t v245;
  int64_t v246;
  unsigned __int16 *v247;
  int v248;
  int v249;
  int v250;
  unsigned int v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  uint64_t v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  int64_t v259;
  unint64_t v260;
  unsigned __int16 *v261;
  unsigned __int8 *v262;
  int v263;
  int v264;
  int v265;
  unsigned int v266;
  unsigned int v267;
  unsigned int v268;
  unsigned int v269;
  unsigned __int16 *v270;
  int v271;
  int v272;
  int v273;
  unsigned int v274;
  unsigned int v275;
  unsigned int v276;
  unsigned int v277;
  unsigned __int16 *v278;
  int v279;
  int v280;
  int v281;
  unsigned int v282;
  unsigned int v283;
  unsigned int v284;
  unsigned int v285;
  unsigned __int16 *v286;
  int v287;
  int v288;
  int v289;
  unsigned int v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  unsigned __int16 *v294;
  int v295;
  int v296;
  int v297;
  unsigned int v298;
  unsigned int v299;
  unsigned int v300;
  unsigned int v301;
  unsigned __int16 *v302;
  int v303;
  int v304;
  int v305;
  unsigned int v306;
  unsigned int v307;
  unsigned int v308;
  unsigned int v309;
  unsigned __int16 *v310;
  int v311;
  int v312;
  int v313;
  unsigned int v314;
  unsigned int v315;
  unsigned int v316;
  unsigned int v317;
  unsigned __int16 *v318;
  int v319;
  int v320;
  int v321;
  unsigned int v322;
  unsigned int v323;
  unsigned int v324;
  unsigned int v325;
  unsigned __int16 *v326;
  int v327;
  int v328;
  int v329;
  unsigned int v330;
  unsigned int v331;
  unint64_t v332;
  unsigned int v333;
  unsigned int v334;
  uint64_t v335;
  uint64_t v336;
  int64_t v337;
  unint64_t v338;
  unint64_t v339;
  unint64_t v340;
  int64_t v341;
  unsigned __int16 *v342;
  int v343;
  int v344;
  int v345;
  unsigned int v346;
  unsigned int v347;
  unsigned int v348;
  unsigned int v349;
  unsigned __int16 *v350;
  int v351;
  int v352;
  int v353;
  unsigned int v354;
  unsigned int v355;
  unsigned int v356;
  unsigned int v357;
  unsigned __int16 *v358;
  int v359;
  unsigned __int8 *v360;
  int v361;
  int v362;
  int v363;
  int v364;
  unsigned int v365;
  unsigned int v366;
  unsigned int v367;
  unsigned int v368;
  unsigned __int16 *v369;
  int v370;
  int v371;
  int v372;
  int v373;
  int v374;
  unsigned int v375;
  unsigned int v376;
  unsigned int v377;
  unsigned int v378;
  unsigned __int16 *v379;
  int v380;
  unsigned int v381;
  unsigned int v382;
  uint64_t v383;
  unsigned __int8 *v384;
  int v385;
  unsigned int v386;
  unsigned __int16 *v387;
  unsigned __int16 *v388;
  unsigned int v389;
  unsigned int v390;
  int v391;
  unsigned __int8 *v392;
  int v393;
  unsigned int v394;
  unsigned int v395;
  int v396;
  unsigned int v397;
  unsigned int v398;
  int v399;
  int v400;
  unsigned int v401;
  unsigned int v402;
  int v403;
  int v404;
  unsigned int v405;
  unsigned int v406;
  int v407;
  unsigned int v408;
  unsigned int v409;
  int v410;
  unsigned int v411;
  int v412;
  int v413;
  unsigned int v414;
  unsigned int v415;
  unsigned int v416;
  unsigned int v417;
  int v418;
  unsigned int v419;
  unsigned int v420;
  int v421;
  unsigned int v422;
  int v423;
  unsigned __int16 *v424;
  unsigned __int8 *v425;
  int v426;
  unsigned int v427;
  unsigned int v428;
  int v429;
  unsigned int v430;
  int v431;
  unsigned int v432;
  unsigned int v433;
  int v434;
  int v435;
  unsigned int v436;
  unsigned int v437;
  int v438;
  uint64_t v439;
  unint64_t v440;
  uint64_t v441;
  uint64_t v442;
  char *v443;
  uint64_t v444;
  uint64_t v445;
  unsigned __int16 *v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  unsigned int v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  int v455;
  int v456;
  uint64_t v457;
  uint64_t v458;
  int *v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;

  v462 = *MEMORY[0x1E0C80C00];
  v451 = *(unsigned int *)(a1 + 4);
  v447 = (int)v451;
  v4 = ((int)v451 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 <= 0x1FFFFFF)
  {
    v8 = *(_QWORD *)(a1 + 40);
    v7 = *(_QWORD *)(a1 + 48);
    v9 = *(float *)(a2 + 184);
    v10 = *(int **)(a1 + 136);
    v457 = *(_QWORD *)(a2 + 96);
    v458 = *(_QWORD *)(a2 + 104);
    v459 = v10;
    v12 = *(int *)(a1 + 24);
    v11 = *(int *)(a1 + 28);
    v13 = *(int *)(a1 + 16);
    v460 = *(int *)(a1 + 20);
    v461 = v7;
    v14 = *(int *)(a1 + 12);
    v456 = *(_DWORD *)(a1 + 8);
    v444 = a1;
    v15 = *(int *)(a2 + 16);
    v16 = (v15 + 6) * v4;
    if (v16 > 65439)
    {
      v20 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
      v18 = v20;
      if (!v20)
        return;
    }
    else
    {
      MEMORY[0x1E0C80A78](a1, a4);
      v18 = (char *)&v439 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v18, v17);
      v20 = 0;
    }
    v450 = a3;
    v21 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
    v22 = v21 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    *(_QWORD *)(a2 + 160) = v22;
    if ((_DWORD)v15)
      v23 = 4 * v4;
    else
      v23 = 0;
    v24 = a2;
    v25 = v22 + v23;
    v26 = v8 + (v12 - 1) * v11;
    v27 = v11 >> 1;
    *(_QWORD *)(v24 + 144) = v21;
    *(_QWORD *)(v24 + 152) = v25;
    v449 = v24;
    if (v461)
    {
      v28 = (unint64_t)*(int *)(v444 + 32) >> 1;
      v29 = (unsigned __int16 *)(v461 + 2 * (v14 + v28 * v13));
      v30 = v447;
      v454 = v28 - v447;
      v31 = v444;
      v32 = 1;
    }
    else
    {
      v29 = 0;
      v454 = 0;
      v32 = 0;
      v31 = v444;
      v30 = v447;
    }
    v455 = (int)(v9 * 65535.9);
    v33 = v26 + 2 * v460;
    v34 = (unsigned __int16 *)(v8 + 2 * (v14 + v27 * v13));
    v453 = v27 - v30;
    v35 = *(int *)(v31 + 104);
    v36 = *(_DWORD *)(v31 + 108);
    v37 = *(unsigned __int8 *)(v31 + 2);
    if (v37 == 6 || v37 == 1)
    {
      v38 = v450;
      v39 = v449;
      v40 = v457;
      v41 = v458;
      if (v459)
      {
        v440 = v27;
        v443 = v20;
        v42 = 0;
        v43 = 0;
        v44 = *(int *)(v31 + 124);
        v45 = (unsigned __int8 *)v459 + v35 + (int)v44 * (uint64_t)v36;
        v452 = v44 - v30;
        v46 = v451;
        v47 = v30;
        goto LABEL_32;
      }
      goto LABEL_627;
    }
    v443 = v20;
    v41 = v458;
    if (!v459)
    {
      v440 = v27;
      v45 = 0;
      v42 = 0;
      v452 = 0;
      v43 = 0;
      v38 = v450;
      v39 = v449;
      v46 = v451;
      v47 = v30;
      v40 = v457;
      goto LABEL_32;
    }
    v441 = v33;
    v442 = v32;
    shape_enum_clip_alloc((uint64_t)v20, v19, v459, 1, 1, 1, v35, v36, v451, v456);
    if (!v48)
    {
LABEL_626:
      v20 = v443;
LABEL_627:
      if (v20)
        free(v20);
      return;
    }
    v460 = v48;
    v440 = v27;
    v49 = 0;
    v50 = (int)((v15 * v4 + 15) & 0xFFFFFFF0);
    if (!(_DWORD)v15)
      v50 = 4 * v4;
    v452 = -v30;
    v45 = (unsigned __int8 *)(v25 + v50 + 16);
    v38 = v450;
    v39 = v449;
    v46 = v451;
    v51 = v30;
    v52 = v461;
    v40 = v457;
LABEL_21:
    v459 = (int *)(v454 + v51);
    while (1)
    {
      v53 = v38;
      while (1)
      {
        v54 = *((_DWORD *)v45 - 4);
        v55 = v54 - v49;
        if (v54 > v49)
          break;
        v43 = v49;
        if (v49 < *((_DWORD *)v45 - 3) + v54)
        {
          v47 = v447;
          v32 = v442;
          v33 = v441;
          v42 = v460;
          v38 = v53;
LABEL_32:
          v58 = v455 ^ 0xFFFF;
          v59 = vdup_n_s32(v455 ^ 0xFFFFu);
          v448 = (v46 - 1) + 1;
          v445 = -v47;
          v441 = v33;
          v446 = (unsigned __int16 *)(v33 - 2);
          v442 = v32;
          v60 = 2 * v32;
          v61 = vdup_n_s32(0x101u);
          v62 = v42;
LABEL_33:
          v63 = v38;
          LODWORD(v459) = v43;
          v460 = v62;
          v64 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v39;
          v457 = v40;
          v458 = v41;
          v64(v39, v40, v41, v46);
          v66 = *(unsigned __int16 **)(v39 + 160);
          v67 = *(_BYTE **)(v39 + 144);
          v68 = *(_DWORD *)(v39 + 8);
          if (v68 == *(_DWORD *)(v39 + 12))
          {
            v38 = v63;
            if (v455 == 0xFFFF)
            {
              v52 = v461;
              v71 = (int)v459;
            }
            else
            {
              v69 = v46;
              v70 = *(_BYTE **)(v39 + 144);
              v52 = v461;
              v71 = (int)v459;
              do
              {
                if (*v70)
                  *(_DWORD *)v66 = ((unsigned __int16)*(_DWORD *)v66
                                  - (((unsigned __int16)*(_DWORD *)v66 * v58
                                    + (((unsigned __int16)*(_DWORD *)v66 * v58) >> 16)
                                    + 1) >> 16)) | ((HIWORD(*(_DWORD *)v66)
                                                   - ((HIWORD(*(_DWORD *)v66) * v58
                                                     + ((HIWORD(*(_DWORD *)v66) * v58) >> 16)
                                                     + 1) >> 16)) << 16);
                ++v70;
                v66 += 2;
                --v69;
              }
              while (v69);
              v66 += 2 * v445;
              v67 += v448 + v445;
            }
          }
          else
          {
            v72 = *(_QWORD *)(v39 + 152);
            v73 = HIWORD(v68) & 0x3F;
            v38 = v63;
            if (v73 == 16)
            {
              v52 = v461;
              v71 = (int)v459;
              v81 = 0;
              if (v455 == 0xFFFF)
              {
                do
                {
                  if (v67[v81])
                    *(_DWORD *)&v66[2 * v81] = *(_DWORD *)(v72 + 4 * v81);
                  ++v81;
                }
                while ((_DWORD)v46 != (_DWORD)v81);
              }
              else
              {
                do
                {
                  if (v67[v81])
                  {
                    v82 = (unsigned __int16)*(_DWORD *)(v72 + 4 * v81);
                    *(_DWORD *)&v66[2 * v81] = (v82 - ((v82 * v58 + ((v82 * v58) >> 16) + 1) >> 16)) | ((HIWORD(*(_DWORD *)(v72 + 4 * v81)) - ((HIWORD(*(_DWORD *)(v72 + 4 * v81)) * v58 + ((HIWORD(*(_DWORD *)(v72 + 4 * v81)) * v58) >> 16) + 1) >> 16)) << 16);
                  }
                  ++v81;
                }
                while ((_DWORD)v46 != (_DWORD)v81);
              }
            }
            else
            {
              v52 = v461;
              v71 = (int)v459;
              if (v73 == 32)
              {
                if (v455 == 0xFFFF)
                {
                  v88 = 0;
                  v89 = (float *)(v72 + 4);
                  do
                  {
                    if (v67[v88])
                    {
                      v90 = *v89;
                      if (*v89 <= 0.0)
                      {
                        v94 = 0;
                      }
                      else
                      {
                        v91 = (int)(float)((float)(v90 * 65535.0) + 0.5);
                        v92 = *(v89 - 1);
                        if (v90 > 1.0)
                        {
                          v91 = 0xFFFF;
                          v90 = 1.0;
                        }
                        v93 = v91;
                        if (v92 <= v90)
                        {
                          if (v92 >= 0.0)
                            v93 = (int)(float)((float)(v92 * 65535.0) + 0.5);
                          else
                            v93 = 0;
                        }
                        v94 = v93 | (v91 << 16);
                      }
                      *(_DWORD *)&v66[2 * v88] = v94;
                    }
                    v89 += 2;
                    ++v88;
                  }
                  while ((_DWORD)v46 != (_DWORD)v88);
                }
                else
                {
                  v74 = 0;
                  v75 = (float *)(v72 + 4);
                  do
                  {
                    if (v67[v74])
                    {
                      v76 = *v75;
                      if (*v75 <= 0.0)
                      {
                        v80 = 0;
                      }
                      else
                      {
                        v77 = (int)(float)((float)(v76 * 65535.0) + 0.5);
                        v78 = *(v75 - 1);
                        if (v76 > 1.0)
                        {
                          v77 = 0xFFFF;
                          v76 = 1.0;
                        }
                        v79 = v77;
                        if (v78 <= v76)
                        {
                          if (v78 >= 0.0)
                            v79 = (int)(float)((float)(v78 * 65535.0) + 0.5);
                          else
                            v79 = 0;
                        }
                        v80 = (v79 - ((v79 * v58 + ((v79 * v58) >> 16) + 1) >> 16)) | ((v77 - ((v77 * v58 + ((v77 * v58) >> 16) + 1) >> 16)) << 16);
                      }
                      *(_DWORD *)&v66[2 * v74] = v80;
                    }
                    v75 += 2;
                    ++v74;
                  }
                  while ((_DWORD)v46 != (_DWORD)v74);
                }
              }
              else if (v455 == 0xFFFF)
              {
                v95 = 0;
                do
                {
                  if (v67[v95])
                    *(_DWORD *)&v66[2 * v95] = *(_DWORD *)(v72 + 4 * v95) & 0xFF000000 | (*(_DWORD *)(v72 + 4 * v95) >> 8) & 0xFFFF0000 | (*(_DWORD *)(v72 + 4 * v95) << 8) | *(_DWORD *)(v72 + 4 * v95);
                  ++v95;
                }
                while ((_DWORD)v46 != (_DWORD)v95);
              }
              else
              {
                v83 = 0;
                do
                {
                  if (v67[v83])
                  {
                    v65.i32[0] = *(_DWORD *)(v72 + 4 * v83);
                    v84.i32[0] = vshr_n_u32((uint32x2_t)v65, 0x18uLL).u32[0];
                    v84.i32[1] = vdup_n_s32(*(_DWORD *)(v72 + 4 * v83)).u8[4];
                    v85 = vmul_s32(v84, v61);
                    v86 = (uint32x2_t)vmul_s32(v85, v59);
                    v65 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v86, v86, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL);
                    v87 = vsub_s32(v85, v65);
                    *(_DWORD *)&v66[2 * v83] = v87.i32[1] | (v87.i32[0] << 16);
                  }
                  ++v83;
                }
                while ((_DWORD)v46 != (_DWORD)v83);
              }
            }
          }
          switch((int)v38)
          {
            case 0:
              v96 = v45 != 0;
              v97 = v46;
              v98 = v45;
              if (v52)
              {
                v99 = v458;
                do
                {
                  v100 = *v67;
                  if (*v67)
                  {
                    if (v45)
                      v100 = ((unsigned __int16)(*v98 * (_WORD)v100
                                                                + ((*v98 * v100) >> 8)
                                                                + 1) >> 8);
                    if (v100)
                    {
                      if (v100 == 255)
                      {
                        LOWORD(v101) = 0;
                        *v34 = 0;
                      }
                      else
                      {
                        v102 = bswap32(*v34) >> 16;
                        v103 = bswap32(*v29) >> 16;
                        v104 = v100 | (v100 << 8);
                        *v34 = bswap32(v102 - ((v104 * v102 + ((v104 * v102) >> 16) + 1) >> 16)) >> 16;
                        v101 = bswap32(v103 - ((v104 * v103 + ((v104 * v103) >> 16) + 1) >> 16)) >> 16;
                      }
                      *v29 = v101;
                    }
                  }
                  ++v67;
                  v98 += v96;
                  ++v34;
                  ++v29;
                  --v97;
                }
                while (v97);
              }
              else
              {
                v99 = v458;
                do
                {
                  v380 = *v67;
                  if (*v67)
                  {
                    if (v45)
                      v380 = ((unsigned __int16)(*v98 * (_WORD)v380
                                                                + ((*v98 * v380) >> 8)
                                                                + 1) >> 8);
                    if (v380)
                    {
                      if (v380 == 255)
                      {
                        LOWORD(v381) = 0;
                      }
                      else
                      {
                        v382 = bswap32(*v34) >> 16;
                        v381 = bswap32(v382 - ((257 * v380 * v382 + ((257 * v380 * v382) >> 16) + 1) >> 16)) >> 16;
                      }
                      *v34 = v381;
                    }
                  }
                  ++v67;
                  v98 += v96;
                  ++v34;
                  --v97;
                }
                while (v97);
              }
              v383 = v452;
              goto LABEL_575;
            case 1:
              v105 = *v67;
              if (v52)
              {
                v106 = v67 + 1;
                v107 = v29 - 1;
                v108 = v34 - 1;
                v109 = v46;
                if (v45)
                {
                  v110 = v457;
                  do
                  {
                    if (v105)
                    {
                      v111 = *v45 * v105 + ((*v45 * v105) >> 8) + 1;
                      if (BYTE1(v111))
                      {
                        if (BYTE1(v111) == 255)
                        {
                          v112 = *(_DWORD *)v66;
                          v113 = *(_DWORD *)v66;
                        }
                        else
                        {
                          v114 = 257 * (v111 >> 8);
                          v115 = (unsigned __int16)v114;
                          v116 = (unsigned __int16)~(_WORD)v114;
                          v117 = (unsigned __int16)*(_DWORD *)v66 * v115 + (bswap32(v108[1]) >> 16) * v116;
                          v113 = HIWORD(*(_DWORD *)v66) * (v116 | v115)
                               + ((HIWORD(*(_DWORD *)v66) * (v116 | v115)) >> 16)
                               + 1;
                          v112 = (v117 + HIWORD(v117) + 1) >> 16;
                        }
                        v108[1] = bswap32(v112) >> 16;
                        v107[1] = bswap32(v113);
                      }
                    }
                    v118 = *v106++;
                    v105 = v118;
                    v66 += 2;
                    ++v45;
                    ++v107;
                    ++v108;
                    --v109;
                  }
                  while (v109);
                  goto LABEL_130;
                }
                v110 = v457;
                do
                {
                  if (v105)
                  {
                    if (v105 == 255)
                    {
                      v405 = *(_DWORD *)v66;
                      v406 = *(_DWORD *)v66;
                    }
                    else
                    {
                      v407 = v105 | (v105 << 8);
                      v408 = bswap32(v108[1]) >> 16;
                      v409 = (unsigned __int16)*(_DWORD *)v66 * v407
                           + v408 * (v407 ^ 0xFFFF)
                           + (((unsigned __int16)*(_DWORD *)v66 * v407 + v408 * (v407 ^ 0xFFFF)) >> 16)
                           + 1;
                      v406 = 0xFFFF * HIWORD(*(_DWORD *)v66)
                           + ((0xFFFF * HIWORD(*(_DWORD *)v66)) >> 16)
                           + 1;
                      v405 = HIWORD(v409);
                    }
                    v108[1] = bswap32(v405) >> 16;
                    v107[1] = bswap32(v406);
                  }
                  v410 = *v106++;
                  v105 = v410;
                  v66 += 2;
                  ++v107;
                  ++v108;
                  --v109;
                }
                while (v109);
                goto LABEL_596;
              }
              if (v45)
              {
                v384 = v67 + 1;
                v385 = v46;
                v110 = v457;
                do
                {
                  if (v105)
                  {
                    v386 = *v45 * v105 + ((*v45 * v105) >> 8) + 1;
                    v387 = *(unsigned __int16 **)(v444 + 40);
                    v388 = v446;
                    if (v446 >= v34)
                      v388 = v34;
                    if (v388 >= v387)
                      v387 = v388;
                    if (BYTE1(v386))
                    {
                      if (BYTE1(v386) == 255)
                      {
                        v389 = *(_DWORD *)v66;
                      }
                      else
                      {
                        v390 = bswap32(*v387) >> 16;
                        v389 = (*v66 * (unsigned __int16)(257 * (v386 >> 8))
                              + v390 * (unsigned __int16)~(257 * (v386 >> 8))
                              + ((*v66 * (unsigned __int16)(257 * (v386 >> 8))
                                + v390 * (unsigned __int16)~(257 * (v386 >> 8))) >> 16)
                              + 1) >> 16;
                      }
                      *v387 = bswap32(v389) >> 16;
                    }
                  }
                  else
                  {
                    v387 = v34;
                  }
                  v391 = *v384++;
                  v105 = v391;
                  v66 += 2;
                  ++v45;
                  v34 = v387 + 1;
                  --v385;
                }
                while (v385);
                goto LABEL_565;
              }
              v424 = *(unsigned __int16 **)(v444 + 40);
              v425 = v67 + 1;
              v426 = v46;
              v110 = v457;
              do
              {
                v387 = v446;
                if (v446 >= v34)
                  v387 = v34;
                if (v387 < v424)
                  v387 = v424;
                if (v105)
                {
                  if (v105 == 255)
                  {
                    v427 = *(_DWORD *)v66;
                  }
                  else
                  {
                    v428 = bswap32(*v387) >> 16;
                    v427 = (*v66 * (v105 | (v105 << 8))
                          + v428 * ((v105 | (v105 << 8)) ^ 0xFFFF)
                          + ((*v66 * (v105 | (v105 << 8))
                            + v428 * ((v105 | (v105 << 8)) ^ 0xFFFF)) >> 16)
                          + 1) >> 16;
                  }
                  *v387 = bswap32(v427) >> 16;
                }
                v429 = *v425++;
                v105 = v429;
                v66 += 2;
                v34 = v387 + 1;
                --v426;
              }
              while (v426);
              goto LABEL_621;
            case 2:
              v119 = *v67;
              if (v52)
              {
                v120 = v67 + 1;
                v107 = v29 - 1;
                v108 = v34 - 1;
                v121 = v46;
                if (v45)
                {
                  v110 = v457;
                  while (1)
                  {
                    if (!v119)
                      goto LABEL_129;
                    v122 = *v45 * v119 + ((*v45 * v119) >> 8) + 1;
                    if (!BYTE1(v122))
                      goto LABEL_129;
                    if (BYTE1(v122) == 255)
                    {
                      v123 = *(_DWORD *)v66;
                      v124 = HIWORD(*(_DWORD *)v66);
                      if (v124)
                      {
                        if (v124 == 0xFFFF)
                        {
                          v108[1] = bswap32(v123) >> 16;
                          LOWORD(v123) = -1;
                        }
                        else
                        {
                          v132 = bswap32(v107[1]) >> 16;
                          v133 = v124 ^ 0xFFFF;
                          v134 = v133 * (bswap32(v108[1]) >> 16);
                          v108[1] = bswap32(v123 + ((v134 + HIWORD(v134) + 1) >> 16)) >> 16;
                          v131 = ((v133 * v132 + ((v133 * v132) >> 16) + 1) >> 16) + HIWORD(v123);
LABEL_127:
                          v123 = bswap32(v131) >> 16;
                        }
                        v107[1] = v123;
                      }
                    }
                    else
                    {
                      v125 = (257 * (v122 >> 8)) ^ 0xFFFF;
                      v126 = (unsigned __int16)*(_DWORD *)v66
                           - (((unsigned __int16)*(_DWORD *)v66 * v125
                             + (((unsigned __int16)*(_DWORD *)v66 * v125) >> 16)
                             + 1) >> 16);
                      v127 = v126 | ((HIWORD(*(_DWORD *)v66)
                                    - ((HIWORD(*(_DWORD *)v66) * v125
                                      + ((HIWORD(*(_DWORD *)v66) * v125) >> 16)
                                      + 1) >> 16)) << 16);
                      if (HIWORD(v127))
                      {
                        v128 = bswap32(v108[1]);
                        v129 = bswap32(v107[1]) >> 16;
                        v130 = HIWORD(v127) ^ 0xFFFF;
                        v108[1] = bswap32(v126+ ((v130 * HIWORD(v128) + ((v130 * HIWORD(v128)) >> 16) + 1) >> 16)) >> 16;
                        v131 = ((v130 * v129 + ((v130 * v129) >> 16) + 1) >> 16) + HIWORD(v127);
                        goto LABEL_127;
                      }
                    }
LABEL_129:
                    v135 = *v120++;
                    v119 = v135;
                    v66 += 2;
                    ++v45;
                    ++v107;
                    ++v108;
                    if (!--v121)
                    {
LABEL_130:
                      v45 += v452;
LABEL_597:
                      v34 = &v108[v453 + 1];
                      v29 = &v107[v454 + 1];
                      goto LABEL_623;
                    }
                  }
                }
                v110 = v457;
                while (1)
                {
                  if (v119)
                  {
                    if (v119 == 255)
                    {
                      v411 = *(_DWORD *)v66;
                      v412 = HIWORD(*(_DWORD *)v66);
                      if (v412)
                      {
                        if (v412 == 0xFFFF)
                        {
                          v108[1] = bswap32(v411) >> 16;
                          LOWORD(v411) = -1;
                        }
                        else
                        {
                          v420 = bswap32(v107[1]) >> 16;
                          v421 = v412 ^ 0xFFFF;
                          v422 = v421 * (bswap32(v108[1]) >> 16);
                          v108[1] = bswap32(v411 + ((v422 + HIWORD(v422) + 1) >> 16)) >> 16;
                          v419 = ((v421 * v420 + ((v421 * v420) >> 16) + 1) >> 16) + HIWORD(v411);
LABEL_593:
                          v411 = bswap32(v419) >> 16;
                        }
                        v107[1] = v411;
                      }
                    }
                    else
                    {
                      v413 = (257 * v119) ^ 0xFFFF;
                      v414 = (unsigned __int16)*(_DWORD *)v66
                           - (((unsigned __int16)*(_DWORD *)v66 * v413
                             + (((unsigned __int16)*(_DWORD *)v66 * v413) >> 16)
                             + 1) >> 16);
                      v415 = v414 | ((HIWORD(*(_DWORD *)v66)
                                    - ((HIWORD(*(_DWORD *)v66) * v413
                                      + ((HIWORD(*(_DWORD *)v66) * v413) >> 16)
                                      + 1) >> 16)) << 16);
                      if (HIWORD(v415))
                      {
                        v416 = bswap32(v108[1]);
                        v417 = bswap32(v107[1]) >> 16;
                        v418 = HIWORD(v415) ^ 0xFFFF;
                        v108[1] = bswap32(v414+ ((v418 * HIWORD(v416) + ((v418 * HIWORD(v416)) >> 16) + 1) >> 16)) >> 16;
                        v419 = ((v418 * v417 + ((v418 * v417) >> 16) + 1) >> 16) + HIWORD(v415);
                        goto LABEL_593;
                      }
                    }
                  }
                  v423 = *v120++;
                  v119 = v423;
                  v66 += 2;
                  ++v107;
                  ++v108;
                  if (!--v121)
                  {
LABEL_596:
                    v45 = 0;
                    goto LABEL_597;
                  }
                }
              }
              v392 = v67 + 1;
              v387 = v34 - 1;
              v393 = v46;
              if (v45)
              {
                v110 = v457;
                while (1)
                {
                  if (!v119)
                    goto LABEL_564;
                  v394 = *v45 * v119 + ((*v45 * v119) >> 8) + 1;
                  if (!BYTE1(v394))
                    goto LABEL_564;
                  if (BYTE1(v394) == 255)
                  {
                    v395 = *(_DWORD *)v66;
                    v396 = HIWORD(*(_DWORD *)v66);
                    if (v396)
                    {
                      if (v396 != 0xFFFF)
                      {
                        v397 = bswap32(v387[1]) >> 16;
                        v398 = v396 ^ 0xFFFF;
                        goto LABEL_562;
                      }
                      goto LABEL_563;
                    }
                  }
                  else
                  {
                    v399 = HIWORD(*(_DWORD *)v66);
                    v400 = (257 * (v394 >> 8)) ^ 0xFFFF;
                    v401 = v399 * v400 + ((v399 * v400) >> 16) + 1;
                    v395 = (unsigned __int16)*(_DWORD *)v66
                         - (((unsigned __int16)*(_DWORD *)v66 * v400
                           + (((unsigned __int16)*(_DWORD *)v66 * v400) >> 16)
                           + 1) >> 16);
                    v402 = v395 | ((v399 - HIWORD(v401)) << 16);
                    if (v402 >= 0x10000)
                    {
                      v397 = bswap32(v387[1]) >> 16;
                      v398 = ~v402 >> 16;
LABEL_562:
                      v395 += (v398 * v397 + ((v398 * v397) >> 16) + 1) >> 16;
LABEL_563:
                      v387[1] = bswap32(v395) >> 16;
                    }
                  }
LABEL_564:
                  v403 = *v392++;
                  v119 = v403;
                  v66 += 2;
                  ++v45;
                  ++v387;
                  if (!--v393)
                  {
LABEL_565:
                    v45 += v452;
LABEL_622:
                    v34 = &v387[v453 + 1];
                    v29 += v454;
LABEL_623:
                    v99 = v458;
LABEL_491:
                    if (v456 == 1)
                      goto LABEL_624;
                    --v456;
                    v62 = 0;
                    v43 = v71 + 1;
                    v40 = *(_QWORD *)(v39 + 128) + v110;
                    v41 = *(_QWORD *)(v39 + 136) + v99;
                    if (v460)
                    {
                      v49 = v43;
                      v51 = v447;
                      goto LABEL_21;
                    }
                    goto LABEL_33;
                  }
                }
              }
              v110 = v457;
              while (1)
              {
                if (v119)
                {
                  if (v119 == 255)
                  {
                    v430 = *(_DWORD *)v66;
                    v431 = HIWORD(*(_DWORD *)v66);
                    if (v431)
                    {
                      if (v431 != 0xFFFF)
                      {
                        v432 = bswap32(v387[1]) >> 16;
                        v433 = v431 ^ 0xFFFF;
                        goto LABEL_618;
                      }
                      goto LABEL_619;
                    }
                  }
                  else
                  {
                    v434 = HIWORD(*(_DWORD *)v66);
                    v435 = (257 * v119) ^ 0xFFFF;
                    v436 = v434 * v435 + ((v434 * v435) >> 16) + 1;
                    v430 = (unsigned __int16)*(_DWORD *)v66
                         - (((unsigned __int16)*(_DWORD *)v66 * v435
                           + (((unsigned __int16)*(_DWORD *)v66 * v435) >> 16)
                           + 1) >> 16);
                    v437 = v430 | ((v434 - HIWORD(v436)) << 16);
                    if (v437 >= 0x10000)
                    {
                      v432 = bswap32(v387[1]) >> 16;
                      v433 = ~v437 >> 16;
LABEL_618:
                      v430 += (v433 * v432 + ((v433 * v432) >> 16) + 1) >> 16;
LABEL_619:
                      v387[1] = bswap32(v430) >> 16;
                    }
                  }
                }
                v438 = *v392++;
                v119 = v438;
                v66 += 2;
                ++v387;
                if (!--v393)
                {
LABEL_621:
                  v45 = 0;
                  goto LABEL_622;
                }
              }
            case 3:
              v136 = v46;
              v137 = v45;
              do
              {
                v138 = *v67;
                if (*v67)
                {
                  if (v45)
                    v138 = ((unsigned __int16)(*v137 * (_WORD)v138
                                                              + ((*v137 * v138) >> 8)
                                                              + 1) >> 8);
                  if (v138)
                  {
                    if (v138 == 255)
                    {
                      v139 = HIWORD(*(_DWORD *)v66);
                      v140 = bswap32(~*v29) >> 16;
                      *v34 = bswap32(*(_DWORD *)v66- (((unsigned __int16)*(_DWORD *)v66 * v140+ (((unsigned __int16)*(_DWORD *)v66 * v140) >> 16)+ 1) >> 16)) >> 16;
                      v141 = v139 - ((v139 * v140 + ((v139 * v140) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      v142 = v138 | (v138 << 8);
                      v143 = bswap32(*v29);
                      v144 = HIWORD(v143) * v142 + ((HIWORD(v143) * v142) >> 16) + 1;
                      v142 ^= 0xFFFFu;
                      v145 = (bswap32(*v34) >> 16) * v142 + HIWORD(v144) * (unsigned __int16)*(_DWORD *)v66;
                      v141 = ((v142 + HIWORD(v144)) * HIWORD(*(_DWORD *)v66)
                            + (((v142 + HIWORD(v144)) * HIWORD(*(_DWORD *)v66)) >> 16)
                            + 1) >> 16;
                      *v34 = bswap32(v145 + HIWORD(v145) + 1);
                    }
                    *v29 = bswap32(v141) >> 16;
                  }
                }
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                --v136;
              }
              while (v136);
              goto LABEL_456;
            case 4:
              v146 = v46;
              v137 = v45;
              do
              {
                v147 = *v67;
                if (*v67)
                {
                  if (v45)
                    v147 = ((unsigned __int16)(*v137 * (_WORD)v147
                                                              + ((*v137 * v147) >> 8)
                                                              + 1) >> 8);
                  if (v147)
                  {
                    if (v147 == 255)
                    {
                      v148 = HIWORD(*(_DWORD *)v66);
                      v149 = bswap32(*v29) >> 16;
                      *v34 = bswap32(*(_DWORD *)v66- (((unsigned __int16)*(_DWORD *)v66 * v149+ (((unsigned __int16)*(_DWORD *)v66 * v149) >> 16)+ 1) >> 16)) >> 16;
                      v150 = v148 - ((v148 * v149 + ((v148 * v149) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      v151 = v147 | (v147 << 8);
                      v152 = bswap32(~*v29);
                      v153 = HIWORD(v152) * v151 + ((HIWORD(v152) * v151) >> 16) + 1;
                      v151 ^= 0xFFFFu;
                      v154 = (bswap32(*v34) >> 16) * v151 + HIWORD(v153) * (unsigned __int16)*(_DWORD *)v66;
                      v150 = ((v151 + HIWORD(v153)) * HIWORD(*(_DWORD *)v66)
                            + (((v151 + HIWORD(v153)) * HIWORD(*(_DWORD *)v66)) >> 16)
                            + 1) >> 16;
                      *v34 = bswap32(v154 + HIWORD(v154) + 1);
                    }
                    *v29 = bswap32(v150) >> 16;
                  }
                }
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                --v146;
              }
              while (v146);
              goto LABEL_456;
            case 5:
              v155 = v46;
              v137 = v45;
              do
              {
                v156 = *v67;
                if (*v67)
                {
                  if (!v45
                    || (v156 = ((unsigned __int16)(*v137 * (_WORD)v156
                                                                  + ((*v137 * v156) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v157 = bswap32(*v29);
                    v158 = (v156 | (v156 << 8)) ^ 0xFFFF;
                    v159 = (unsigned __int16)*(_DWORD *)v66
                         - (((unsigned __int16)*(_DWORD *)v66 * v158
                           + (((unsigned __int16)*(_DWORD *)v66 * v158) >> 16)
                           + 1) >> 16);
                    v160 = (v159 | ((HIWORD(*(_DWORD *)v66)
                                   - ((HIWORD(*(_DWORD *)v66) * v158
                                     + ((HIWORD(*(_DWORD *)v66) * v158) >> 16)
                                     + 1) >> 16)) << 16)) >> 16;
                    v161 = (unsigned __int16)v159 * HIWORD(v157) + (v160 ^ 0xFFFF) * (bswap32(*v34) >> 16);
                    *v34 = bswap32(v161 + HIWORD(v161) + 1);
                    *v29 = bswap32(((v160 ^ 0xFFFF) + HIWORD(v157)) * v160+ ((((v160 ^ 0xFFFF) + HIWORD(v157)) * v160) >> 16)+ 1);
                  }
                }
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                --v155;
              }
              while (v155);
              goto LABEL_456;
            case 6:
              v162 = v46;
              v137 = v45;
              do
              {
                v163 = *v67;
                if (*v67)
                {
                  if (!v45
                    || (v163 = ((unsigned __int16)(*v137 * (_WORD)v163
                                                                  + ((*v137 * v163) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v164 = bswap32(*v29);
                    if (HIWORD(v164) != 0xFFFF)
                    {
                      if ((unsigned __int16)~HIWORD(v164) == 0xFFFF)
                      {
                        v165 = HIWORD(*(_DWORD *)v66);
                        v166 = (v163 | (v163 << 8)) ^ 0xFFFF;
                        *v34 = bswap32(*(_DWORD *)v66- (((unsigned __int16)*(_DWORD *)v66 * v166+ (((unsigned __int16)*(_DWORD *)v66 * v166) >> 16)+ 1) >> 16)) >> 16;
                        v167 = v165 - ((v165 * v166 + ((v165 * v166) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v168 = HIWORD(*(_DWORD *)v66);
                        v169 = (257 * v163 * (unsigned __int16)~HIWORD(v164)
                              + ((257 * v163 * (unsigned __int16)~HIWORD(v164)) >> 16)
                              + 1) >> 16;
                        *v34 = bswap32((bswap32(*v34) >> 16)+ (((unsigned __int16)*(_DWORD *)v66 * v169+ (((unsigned __int16)*(_DWORD *)v66 * v169) >> 16)+ 1) >> 16)) >> 16;
                        v167 = HIWORD(v164) + ((v168 * v169 + ((v168 * v169) >> 16) + 1) >> 16);
                      }
                      *v29 = bswap32(v167) >> 16;
                    }
                  }
                }
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                --v162;
              }
              while (v162);
              goto LABEL_456;
            case 7:
              v170 = v45 != 0;
              v171 = v46;
              v137 = v45;
              if (v52)
              {
                do
                {
                  v172 = *v67;
                  if (*v67)
                  {
                    if (v45)
                      v172 = ((unsigned __int16)(*v137 * (_WORD)v172
                                                                + ((*v137 * v172) >> 8)
                                                                + 1) >> 8);
                    if (v172)
                    {
                      if (v172 == 255)
                      {
                        v173 = bswap32(*v34) >> 16;
                        v174 = bswap32(*v29) >> 16;
                        v175 = ~*(_DWORD *)v66 >> 16;
                        *v34 = bswap32(v173 - ((v175 * v173 + ((v175 * v173) >> 16) + 1) >> 16)) >> 16;
                        v176 = v174 - ((v175 * v174 + ((v175 * v174) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v177 = bswap32(*v29);
                        v178 = ((v172 | (v172 << 8)) ^ 0xFFFF)
                             + ((v66[1] * (v172 | (v172 << 8))
                               + ((v66[1] * (v172 | (v172 << 8))) >> 16)
                               + 1) >> 16);
                        v179 = v178 * (bswap32(*v34) >> 16);
                        v176 = (v178 * HIWORD(v177) + ((v178 * HIWORD(v177)) >> 16) + 1) >> 16;
                        *v34 = bswap32(v179 + HIWORD(v179) + 1);
                      }
                      *v29 = bswap32(v176) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v170;
                  ++v34;
                  ++v29;
                  --v171;
                }
                while (v171);
              }
              else
              {
                do
                {
                  v180 = *v67;
                  if (*v67)
                  {
                    if (v45)
                      v180 = ((unsigned __int16)(*v137 * (_WORD)v180
                                                                + ((*v137 * v180) >> 8)
                                                                + 1) >> 8);
                    if (v180)
                    {
                      if (v180 == 255)
                      {
                        v181 = bswap32(*v34) >> 16;
                        v182 = v181
                             - (((~*(_DWORD *)v66 >> 16) * v181
                               + (((~*(_DWORD *)v66 >> 16) * v181) >> 16)
                               + 1) >> 16);
                      }
                      else
                      {
                        v183 = v180 | (v180 << 8);
                        v184 = bswap32(*v34) >> 16;
                        v185 = v66[1] * v183 + ((v66[1] * v183) >> 16) + 1;
                        v182 = (((v183 ^ 0xFFFF) + HIWORD(v185)) * v184
                              + ((((v183 ^ 0xFFFF) + HIWORD(v185)) * v184) >> 16)
                              + 1) >> 16;
                      }
                      *v34 = bswap32(v182) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v170;
                  ++v34;
                  --v171;
                }
                while (v171);
              }
              goto LABEL_456;
            case 8:
              v186 = v45 != 0;
              v187 = v46;
              v137 = v45;
              if (v52)
              {
                do
                {
                  v188 = *v67;
                  if (*v67)
                  {
                    if (v45)
                      v188 = ((unsigned __int16)(*v137 * (_WORD)v188
                                                                + ((*v137 * v188) >> 8)
                                                                + 1) >> 8);
                    if (v188)
                    {
                      if (v188 == 255)
                      {
                        v189 = bswap32(*v34) >> 16;
                        v190 = bswap32(*v29) >> 16;
                        v191 = HIWORD(*(_DWORD *)v66);
                        *v34 = bswap32(v189 - ((v191 * v189 + ((v191 * v189) >> 16) + 1) >> 16)) >> 16;
                        v192 = v190 - ((v191 * v190 + ((v191 * v190) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v193 = bswap32(*v29);
                        v194 = ((v188 | (v188 << 8)) ^ 0xFFFF)
                             + (((~*(_DWORD *)v66 >> 16) * (v188 | (v188 << 8))
                               + (((~*(_DWORD *)v66 >> 16) * (v188 | (v188 << 8))) >> 16)
                               + 1) >> 16);
                        v195 = v194 * (bswap32(*v34) >> 16);
                        v192 = (v194 * HIWORD(v193) + ((v194 * HIWORD(v193)) >> 16) + 1) >> 16;
                        *v34 = bswap32(v195 + HIWORD(v195) + 1);
                      }
                      *v29 = bswap32(v192) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v186;
                  ++v34;
                  ++v29;
                  --v187;
                }
                while (v187);
              }
              else
              {
                do
                {
                  v196 = *v67;
                  if (*v67)
                  {
                    if (v45)
                      v196 = ((unsigned __int16)(*v137 * (_WORD)v196
                                                                + ((*v137 * v196) >> 8)
                                                                + 1) >> 8);
                    if (v196)
                    {
                      if (v196 == 255)
                      {
                        v197 = bswap32(*v34) >> 16;
                        v198 = v197 - ((v66[1] * v197 + ((v66[1] * v197) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        v199 = v196 | (v196 << 8);
                        v200 = bswap32(*v34) >> 16;
                        v201 = (~*(_DWORD *)v66 >> 16) * v199
                             + (((~*(_DWORD *)v66 >> 16) * v199) >> 16)
                             + 1;
                        v198 = (((v199 ^ 0xFFFF) + HIWORD(v201)) * v200
                              + ((((v199 ^ 0xFFFF) + HIWORD(v201)) * v200) >> 16)
                              + 1) >> 16;
                      }
                      *v34 = bswap32(v198) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v186;
                  ++v34;
                  --v187;
                }
                while (v187);
              }
              goto LABEL_456;
            case 9:
              v202 = v46;
              v137 = v45;
              do
              {
                v203 = *v67;
                if (*v67)
                {
                  if (!v45
                    || (v203 = ((unsigned __int16)(*v137 * (_WORD)v203
                                                                  + ((*v137 * v203) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v204 = ~(v203 | ((_WORD)v203 << 8));
                    v205 = ((unsigned __int16)*(_DWORD *)v66
                          - (((unsigned __int16)*(_DWORD *)v66 * v204
                            + (((unsigned __int16)*(_DWORD *)v66 * v204) >> 16)
                            + 1) >> 16)) | ((HIWORD(*(_DWORD *)v66)
                                           - ((HIWORD(*(_DWORD *)v66) * v204
                                             + ((HIWORD(*(_DWORD *)v66) * v204) >> 16)
                                             + 1) >> 16)) << 16);
                    v206 = bswap32(~*v29) >> 16;
                    v207 = (unsigned __int16)(*(_DWORD *)v66
                                            - (((unsigned __int16)*(_DWORD *)v66 * v204
                                              + (((unsigned __int16)*(_DWORD *)v66 * v204) >> 16)
                                              + 1) >> 16))
                         * v206
                         + (unsigned __int16)(v204 + HIWORD(v205)) * (bswap32(*v34) >> 16);
                    v208 = (v206 + (unsigned __int16)(v204 + HIWORD(v205))) * HIWORD(v205);
                    *v34 = bswap32(v207 + HIWORD(v207) + 1);
                    *v29 = bswap32(v208 + HIWORD(v208) + 1);
                  }
                }
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                --v202;
              }
              while (v202);
              goto LABEL_456;
            case 10:
              v209 = v46;
              v137 = v45;
              do
              {
                v210 = *v67;
                if (*v67)
                {
                  if (!v45
                    || (v210 = ((unsigned __int16)(*v137 * (_WORD)v210
                                                                  + ((*v137 * v210) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v211 = (v210 | (v210 << 8)) ^ 0xFFFF;
                    v212 = (unsigned __int16)*(_DWORD *)v66
                         - (((unsigned __int16)*(_DWORD *)v66 * v211
                           + (((unsigned __int16)*(_DWORD *)v66 * v211) >> 16)
                           + 1) >> 16);
                    v213 = (v212 | ((HIWORD(*(_DWORD *)v66)
                                   - ((HIWORD(*(_DWORD *)v66) * v211
                                     + ((HIWORD(*(_DWORD *)v66) * v211) >> 16)
                                     + 1) >> 16)) << 16)) >> 16;
                    v214 = bswap32(~*v29);
                    v215 = (unsigned __int16)v212 * HIWORD(v214) + (v213 ^ 0xFFFF) * (bswap32(*v34) >> 16);
                    *v34 = bswap32(v215 + HIWORD(v215) + 1);
                    *v29 = bswap32(((v213 ^ 0xFFFF) + HIWORD(v214)) * v213+ ((((v213 ^ 0xFFFF) + HIWORD(v214)) * v213) >> 16)+ 1);
                  }
                }
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                --v209;
              }
              while (v209);
              goto LABEL_456;
            case 11:
              v216 = v45 != 0;
              v217 = v46;
              v137 = v45;
              if (v52)
              {
                do
                {
                  v218 = *v67;
                  if (*v67)
                  {
                    if (!v45
                      || (v218 = ((unsigned __int16)(*v137 * (_WORD)v218
                                                                    + ((*v137 * v218) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      v219 = (v218 | (v218 << 8)) ^ 0xFFFF;
                      v220 = (unsigned __int16)*(_DWORD *)v66
                           - ((v219 * (unsigned __int16)*(_DWORD *)v66
                             + ((v219 * (unsigned __int16)*(_DWORD *)v66) >> 16)
                             + 1) >> 16);
                      v221 = bswap32(*v29);
                      v222 = (v220 | ((HIWORD(*(_DWORD *)v66)
                                     - ((v219 * HIWORD(*(_DWORD *)v66)
                                       + ((v219 * HIWORD(*(_DWORD *)v66)) >> 16)
                                       + 1) >> 16)) << 16)) >> 16;
                      v223 = HIWORD(v221) - ((bswap32(*v34) >> 16) + (unsigned __int16)v220) + v222;
                      v224 = v222 + HIWORD(v221);
                      if (v223 >= 0xFFFF)
                        v223 = 0xFFFF;
                      if (v224 >= 0xFFFF)
                        v224 = 0xFFFF;
                      *v34 = bswap32(v224 - v223) >> 16;
                      *v29 = bswap32(v224) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v216;
                  ++v34;
                  ++v29;
                  --v217;
                }
                while (v217);
              }
              else
              {
                do
                {
                  v225 = *v67;
                  if (*v67)
                  {
                    if (!v45
                      || (v225 = ((unsigned __int16)(*v137 * (_WORD)v225
                                                                    + ((*v137 * v225) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      v226 = (v225 | (v225 << 8)) ^ 0xFFFF;
                      v227 = (unsigned __int16)*(_DWORD *)v66
                           - ((v226 * (unsigned __int16)*(_DWORD *)v66
                             + ((v226 * (unsigned __int16)*(_DWORD *)v66) >> 16)
                             + 1) >> 16);
                      v228 = (bswap32(~*v34) >> 16)
                           - (unsigned __int16)v227
                           + ((v227 | ((HIWORD(*(_DWORD *)v66)
                                      - ((v226 * HIWORD(*(_DWORD *)v66)
                                        + ((v226 * HIWORD(*(_DWORD *)v66)) >> 16)
                                        + 1) >> 16)) << 16)) >> 16);
                      if (v228 >= 0xFFFF)
                        v228 = 0xFFFF;
                      *v34 = bswap32(~v228) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v216;
                  ++v34;
                  --v217;
                }
                while (v217);
              }
              goto LABEL_456;
            case 12:
              v229 = v45 != 0;
              v230 = v46;
              v137 = v45;
              if (v52)
              {
                do
                {
                  v231 = *v67;
                  if (*v67)
                  {
                    if (!v45
                      || (v231 = ((unsigned __int16)(*v137 * (_WORD)v231
                                                                    + ((*v137 * v231) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      v232 = (v231 | (v231 << 8)) ^ 0xFFFF;
                      v233 = (unsigned __int16)*(_DWORD *)v66
                           - ((v232 * (unsigned __int16)*(_DWORD *)v66
                             + ((v232 * (unsigned __int16)*(_DWORD *)v66) >> 16)
                             + 1) >> 16);
                      v234 = (bswap32(*v34) >> 16) + (unsigned __int16)v233;
                      v235 = ((v233 | ((HIWORD(*(_DWORD *)v66)
                                      - ((v232 * HIWORD(*(_DWORD *)v66)
                                        + ((v232 * HIWORD(*(_DWORD *)v66)) >> 16)
                                        + 1) >> 16)) << 16)) >> 16)
                           + (bswap32(*v29) >> 16);
                      if (v234 >= 0xFFFF)
                        v234 = 0xFFFF;
                      if (v235 >= 0xFFFF)
                        v235 = 0xFFFF;
                      *v34 = bswap32(v234) >> 16;
                      *v29 = bswap32(v235) >> 16;
                    }
                  }
                  ++v67;
                  v66 += 2;
                  v137 += v229;
                  ++v34;
                  ++v29;
                  --v230;
                }
                while (v230);
                goto LABEL_456;
              }
              v99 = v458;
              do
              {
                if (*v67
                  && (!v45
                   || ((*v137 * *v67 + ((*v137 * *v67) >> 8) + 1) & 0xFF00) != 0))
                {
                  v404 = bswap32(*v34);
                  *v34 = bswap32((v404 >> 15) & 0xFFFE | ((v404 >> 16) >> 15)) >> 16;
                }
                ++v67;
                v137 += v229;
                ++v34;
                --v230;
              }
              while (v230);
              v383 = v448;
              if (!v45)
                v383 = 0;
              v98 = &v45[v452];
LABEL_575:
              v45 = &v98[v383];
              v34 += v453;
              v29 += v454;
              v110 = v457;
              goto LABEL_491;
            case 13:
              v236 = v46;
              v137 = v45;
              while (1)
              {
                v237 = *v67;
                if (!*v67)
                  goto LABEL_277;
                if (v45)
                {
                  v237 = ((unsigned __int16)(*v137 * (_WORD)v237
                                                            + ((*v137 * v237) >> 8)
                                                            + 1) >> 8);
                  if (!v237)
                    goto LABEL_277;
                }
                v238 = (v237 | (v237 << 8)) ^ 0xFFFF;
                v239 = (unsigned __int16)*(_DWORD *)v66
                     - ((v238 * (unsigned __int16)*(_DWORD *)v66
                       + ((v238 * (unsigned __int16)*(_DWORD *)v66) >> 16)
                       + 1) >> 16);
                v240 = v239 | ((HIWORD(*(_DWORD *)v66)
                              - ((v238 * HIWORD(*(_DWORD *)v66)
                                + ((v238 * HIWORD(*(_DWORD *)v66)) >> 16)
                                + 1) >> 16)) << 16);
                if (v240 < 0x10000)
                  goto LABEL_277;
                v241 = HIWORD(v240);
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_274;
                  v242 = __rev16(*v29);
                }
                else
                {
                  v242 = 0xFFFF;
                }
                v243 = (v242 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v239
                     + ((v241 ^ 0xFFFF) + (unsigned __int16)v239)
                     * (unint64_t)(bswap32(*v34) >> 16);
                if (v243 <= 0xFFFE8000)
                  v244 = v243 + 0x8000;
                else
                  v244 = 4294868992;
                v245 = (v244 + (v244 >> 16)) >> 16;
                if (!v52)
                {
                  LODWORD(v241) = v245;
                  v247 = v34;
                  goto LABEL_276;
                }
                v246 = 0xFFFF * (v242 + v241) - v242 * (unint64_t)v241;
                if (v246 <= 4294868992)
                  v241 = v246 + 0x8000;
                else
                  v241 = 4294868992;
                v240 = ((v241 >> 16) + v241) & 0xFFFF0000 | v245;
                LODWORD(v241) = HIWORD(v240);
LABEL_274:
                *v34 = bswap32(v240) >> 16;
                v247 = v29;
LABEL_276:
                *v247 = bswap32(v241) >> 16;
LABEL_277:
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                if (!--v236)
                  goto LABEL_456;
              }
            case 14:
              v248 = v46;
              v137 = v45;
              while (1)
              {
                v249 = *v67;
                if (!*v67)
                  goto LABEL_299;
                if (v45)
                {
                  v249 = ((unsigned __int16)(*v137 * (_WORD)v249
                                                            + ((*v137 * v249) >> 8)
                                                            + 1) >> 8);
                  if (!v249)
                    goto LABEL_299;
                }
                v250 = (v249 | (v249 << 8)) ^ 0xFFFF;
                v251 = (unsigned __int16)*(_DWORD *)v66
                     - ((v250 * (unsigned __int16)*(_DWORD *)v66
                       + ((v250 * (unsigned __int16)*(_DWORD *)v66) >> 16)
                       + 1) >> 16);
                v252 = v251 | ((HIWORD(*(_DWORD *)v66)
                              - ((v250 * HIWORD(*(_DWORD *)v66)
                                + ((v250 * HIWORD(*(_DWORD *)v66)) >> 16)
                                + 1) >> 16)) << 16);
                if (v252 < 0x10000)
                  goto LABEL_299;
                v253 = HIWORD(v252);
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_296;
                  v254 = __rev16(*v29);
                }
                else
                {
                  v254 = 0xFFFF;
                }
                v255 = bswap32(*v34) >> 16;
                v256 = (v255 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v251 - v255 + (v255 << 16);
                if (v256 <= 0xFFFE8000)
                  v257 = v256 + 0x8000;
                else
                  v257 = 4294868992;
                v258 = (v257 + (v257 >> 16)) >> 16;
                if (!v52)
                {
                  v253 = v258;
                  v261 = v34;
                  goto LABEL_298;
                }
                v259 = 0xFFFF * (v254 + (unint64_t)v253) - v254 * (unint64_t)v253;
                if (v259 <= 4294868992)
                  v260 = v259 + 0x8000;
                else
                  v260 = 4294868992;
                v252 = ((v260 >> 16) + v260) & 0xFFFF0000 | v258;
                v253 = HIWORD(v252);
LABEL_296:
                *v34 = bswap32(v252) >> 16;
                v261 = v29;
LABEL_298:
                *v261 = bswap32(v253) >> 16;
LABEL_299:
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                if (!--v248)
                  goto LABEL_456;
              }
            case 15:
              v262 = v45;
              while (1)
              {
                v263 = *v67;
                if (!*v67)
                  goto LABEL_315;
                if (v45)
                {
                  v263 = ((unsigned __int16)(*v262 * (_WORD)v263
                                                            + ((*v262 * v263) >> 8)
                                                            + 1) >> 8);
                  if (!v263)
                    goto LABEL_315;
                }
                v264 = (unsigned __int16)*(_DWORD *)v66;
                v265 = (v263 | (v263 << 8)) ^ 0xFFFF;
                v266 = v265 * v264 + ((v265 * v264) >> 16) + 1;
                v267 = (v264 - HIWORD(v266)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v265 * HIWORD(*(_DWORD *)v66)
                                                 + ((v265 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v268 = HIWORD(v267);
                if (!HIWORD(v267))
                  goto LABEL_315;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_312;
                  v269 = __rev16(*v29);
                }
                else
                {
                  v269 = 0xFFFF;
                }
                v267 = PDAoverlayPDA_8071(bswap32(*v34) >> 16, v269, (unsigned __int16)(v264 - HIWORD(v266)), v268);
                v52 = v461;
                if (!v461)
                {
                  v268 = v267;
                  v270 = v34;
                  goto LABEL_314;
                }
                v268 = HIWORD(v267);
LABEL_312:
                *v34 = bswap32(v267) >> 16;
                v270 = v29;
LABEL_314:
                *v270 = bswap32(v268) >> 16;
LABEL_315:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 16:
              v262 = v45;
              while (1)
              {
                v271 = *v67;
                if (!*v67)
                  goto LABEL_331;
                if (v45)
                {
                  v271 = ((unsigned __int16)(*v262 * (_WORD)v271
                                                            + ((*v262 * v271) >> 8)
                                                            + 1) >> 8);
                  if (!v271)
                    goto LABEL_331;
                }
                v272 = (unsigned __int16)*(_DWORD *)v66;
                v273 = (v271 | (v271 << 8)) ^ 0xFFFF;
                v274 = v273 * v272 + ((v273 * v272) >> 16) + 1;
                v275 = (v272 - HIWORD(v274)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v273 * HIWORD(*(_DWORD *)v66)
                                                 + ((v273 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v276 = HIWORD(v275);
                if (!HIWORD(v275))
                  goto LABEL_331;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_328;
                  v277 = __rev16(*v29);
                }
                else
                {
                  v277 = 0xFFFF;
                }
                v275 = PDAdarkenPDA_8073(bswap32(*v34) >> 16, v277, (unsigned __int16)(v272 - HIWORD(v274)), v276);
                v52 = v461;
                if (!v461)
                {
                  v276 = v275;
                  v278 = v34;
                  goto LABEL_330;
                }
                v276 = HIWORD(v275);
LABEL_328:
                *v34 = bswap32(v275) >> 16;
                v278 = v29;
LABEL_330:
                *v278 = bswap32(v276) >> 16;
LABEL_331:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 17:
              v262 = v45;
              while (1)
              {
                v279 = *v67;
                if (!*v67)
                  goto LABEL_347;
                if (v45)
                {
                  v279 = ((unsigned __int16)(*v262 * (_WORD)v279
                                                            + ((*v262 * v279) >> 8)
                                                            + 1) >> 8);
                  if (!v279)
                    goto LABEL_347;
                }
                v280 = (unsigned __int16)*(_DWORD *)v66;
                v281 = (v279 | (v279 << 8)) ^ 0xFFFF;
                v282 = v281 * v280 + ((v281 * v280) >> 16) + 1;
                v283 = (v280 - HIWORD(v282)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v281 * HIWORD(*(_DWORD *)v66)
                                                 + ((v281 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v284 = HIWORD(v283);
                if (!HIWORD(v283))
                  goto LABEL_347;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_344;
                  v285 = __rev16(*v29);
                }
                else
                {
                  v285 = 0xFFFF;
                }
                v283 = PDAlightenPDA_8072(bswap32(*v34) >> 16, v285, (unsigned __int16)(v280 - HIWORD(v282)), v284);
                v52 = v461;
                if (!v461)
                {
                  v284 = v283;
                  v286 = v34;
                  goto LABEL_346;
                }
                v284 = HIWORD(v283);
LABEL_344:
                *v34 = bswap32(v283) >> 16;
                v286 = v29;
LABEL_346:
                *v286 = bswap32(v284) >> 16;
LABEL_347:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 18:
              v262 = v45;
              while (1)
              {
                v287 = *v67;
                if (!*v67)
                  goto LABEL_363;
                if (v45)
                {
                  v287 = ((unsigned __int16)(*v262 * (_WORD)v287
                                                            + ((*v262 * v287) >> 8)
                                                            + 1) >> 8);
                  if (!v287)
                    goto LABEL_363;
                }
                v288 = (unsigned __int16)*(_DWORD *)v66;
                v289 = (v287 | (v287 << 8)) ^ 0xFFFF;
                v290 = v289 * v288 + ((v289 * v288) >> 16) + 1;
                v291 = (v288 - HIWORD(v290)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v289 * HIWORD(*(_DWORD *)v66)
                                                 + ((v289 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v292 = HIWORD(v291);
                if (!HIWORD(v291))
                  goto LABEL_363;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_360;
                  v293 = __rev16(*v29);
                }
                else
                {
                  v293 = 0xFFFF;
                }
                v291 = PDAcolordodgePDA_8074(bswap32(*v34) >> 16, v293, (unsigned __int16)(v288 - HIWORD(v290)), v292);
                v52 = v461;
                if (!v461)
                {
                  v292 = v291;
                  v294 = v34;
                  goto LABEL_362;
                }
                v292 = HIWORD(v291);
LABEL_360:
                *v34 = bswap32(v291) >> 16;
                v294 = v29;
LABEL_362:
                *v294 = bswap32(v292) >> 16;
LABEL_363:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 19:
              v262 = v45;
              while (1)
              {
                v295 = *v67;
                if (!*v67)
                  goto LABEL_379;
                if (v45)
                {
                  v295 = ((unsigned __int16)(*v262 * (_WORD)v295
                                                            + ((*v262 * v295) >> 8)
                                                            + 1) >> 8);
                  if (!v295)
                    goto LABEL_379;
                }
                v296 = (unsigned __int16)*(_DWORD *)v66;
                v297 = (v295 | (v295 << 8)) ^ 0xFFFF;
                v298 = v297 * v296 + ((v297 * v296) >> 16) + 1;
                v299 = (v296 - HIWORD(v298)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v297 * HIWORD(*(_DWORD *)v66)
                                                 + ((v297 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v300 = HIWORD(v299);
                if (!HIWORD(v299))
                  goto LABEL_379;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_376;
                  v301 = __rev16(*v29);
                }
                else
                {
                  v301 = 0xFFFF;
                }
                v299 = PDAcolorburnPDA_8075(bswap32(*v34) >> 16, v301, (unsigned __int16)(v296 - HIWORD(v298)), v300);
                v52 = v461;
                if (!v461)
                {
                  v300 = v299;
                  v302 = v34;
                  goto LABEL_378;
                }
                v300 = HIWORD(v299);
LABEL_376:
                *v34 = bswap32(v299) >> 16;
                v302 = v29;
LABEL_378:
                *v302 = bswap32(v300) >> 16;
LABEL_379:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 20:
              v262 = v45;
              while (1)
              {
                v303 = *v67;
                if (!*v67)
                  goto LABEL_395;
                if (v45)
                {
                  v303 = ((unsigned __int16)(*v262 * (_WORD)v303
                                                            + ((*v262 * v303) >> 8)
                                                            + 1) >> 8);
                  if (!v303)
                    goto LABEL_395;
                }
                v304 = (unsigned __int16)*(_DWORD *)v66;
                v305 = (v303 | (v303 << 8)) ^ 0xFFFF;
                v306 = v305 * v304 + ((v305 * v304) >> 16) + 1;
                v307 = (v304 - HIWORD(v306)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v305 * HIWORD(*(_DWORD *)v66)
                                                 + ((v305 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v308 = HIWORD(v307);
                if (!HIWORD(v307))
                  goto LABEL_395;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_392;
                  v309 = __rev16(*v29);
                }
                else
                {
                  v309 = 0xFFFF;
                }
                v307 = PDAsoftlightPDA_8077(bswap32(*v34) >> 16, v309, (unsigned __int16)(v304 - HIWORD(v306)), v308);
                v52 = v461;
                if (!v461)
                {
                  v308 = v307;
                  v310 = v34;
                  goto LABEL_394;
                }
                v308 = HIWORD(v307);
LABEL_392:
                *v34 = bswap32(v307) >> 16;
                v310 = v29;
LABEL_394:
                *v310 = bswap32(v308) >> 16;
LABEL_395:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 21:
              v262 = v45;
              while (1)
              {
                v311 = *v67;
                if (!*v67)
                  goto LABEL_411;
                if (v45)
                {
                  v311 = ((unsigned __int16)(*v262 * (_WORD)v311
                                                            + ((*v262 * v311) >> 8)
                                                            + 1) >> 8);
                  if (!v311)
                    goto LABEL_411;
                }
                v312 = (unsigned __int16)*(_DWORD *)v66;
                v313 = (v311 | (v311 << 8)) ^ 0xFFFF;
                v314 = v313 * v312 + ((v313 * v312) >> 16) + 1;
                v315 = (v312 - HIWORD(v314)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v313 * HIWORD(*(_DWORD *)v66)
                                                 + ((v313 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v316 = HIWORD(v315);
                if (!HIWORD(v315))
                  goto LABEL_411;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_408;
                  v317 = __rev16(*v29);
                }
                else
                {
                  v317 = 0xFFFF;
                }
                v315 = PDAhardlightPDA_8076(bswap32(*v34) >> 16, v317, (unsigned __int16)(v312 - HIWORD(v314)), v316);
                v52 = v461;
                if (!v461)
                {
                  v316 = v315;
                  v318 = v34;
                  goto LABEL_410;
                }
                v316 = HIWORD(v315);
LABEL_408:
                *v34 = bswap32(v315) >> 16;
                v318 = v29;
LABEL_410:
                *v318 = bswap32(v316) >> 16;
LABEL_411:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 22:
              v262 = v45;
              while (1)
              {
                v319 = *v67;
                if (!*v67)
                  goto LABEL_427;
                if (v45)
                {
                  v319 = ((unsigned __int16)(*v262 * (_WORD)v319
                                                            + ((*v262 * v319) >> 8)
                                                            + 1) >> 8);
                  if (!v319)
                    goto LABEL_427;
                }
                v320 = (unsigned __int16)*(_DWORD *)v66;
                v321 = (v319 | (v319 << 8)) ^ 0xFFFF;
                v322 = v321 * v320 + ((v321 * v320) >> 16) + 1;
                v323 = (v320 - HIWORD(v322)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v321 * HIWORD(*(_DWORD *)v66)
                                                 + ((v321 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v324 = HIWORD(v323);
                if (!HIWORD(v323))
                  goto LABEL_427;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_424;
                  v325 = __rev16(*v29);
                }
                else
                {
                  v325 = 0xFFFF;
                }
                v323 = PDAdifferencePDA_8078(bswap32(*v34) >> 16, v325, (unsigned __int16)(v320 - HIWORD(v322)), v324);
                v52 = v461;
                if (!v461)
                {
                  v324 = v323;
                  v326 = v34;
                  goto LABEL_426;
                }
                v324 = HIWORD(v323);
LABEL_424:
                *v34 = bswap32(v323) >> 16;
                v326 = v29;
LABEL_426:
                *v326 = bswap32(v324) >> 16;
LABEL_427:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 23:
              v327 = v46;
              v137 = v45;
              while (1)
              {
                v328 = *v67;
                if (!*v67)
                  goto LABEL_455;
                if (v45)
                {
                  v328 = ((unsigned __int16)(*v137 * (_WORD)v328
                                                            + ((*v137 * v328) >> 8)
                                                            + 1) >> 8);
                  if (!v328)
                    goto LABEL_455;
                }
                v329 = (v328 | (v328 << 8)) ^ 0xFFFF;
                v330 = (unsigned __int16)*(_DWORD *)v66
                     - ((v329 * (unsigned __int16)*(_DWORD *)v66
                       + ((v329 * (unsigned __int16)*(_DWORD *)v66) >> 16)
                       + 1) >> 16);
                v331 = v330 | ((HIWORD(*(_DWORD *)v66)
                              - ((v329 * HIWORD(*(_DWORD *)v66)
                                + ((v329 * HIWORD(*(_DWORD *)v66)) >> 16)
                                + 1) >> 16)) << 16);
                LODWORD(v332) = HIWORD(v331);
                if (!HIWORD(v331))
                  goto LABEL_455;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_452;
                  v333 = __rev16(*v29);
                }
                else
                {
                  v333 = 0xFFFF;
                }
                v334 = bswap32(*v34) >> 16;
                if ((unsigned __int16)v330 >= HIWORD(v331))
                  v335 = v332;
                else
                  v335 = (unsigned __int16)v330;
                if (v334 >= v333)
                  v336 = v333;
                else
                  v336 = v334;
                v337 = 0xFFFF * (v336 + v335) - 2 * v335 * (unint64_t)v336;
                if (v337 <= 4294868992)
                  v338 = v337 + 0x8000;
                else
                  v338 = 4294868992;
                v339 = v338 + (v338 >> 16);
                if (!v52)
                {
                  v332 = v339 >> 16;
                  v342 = v34;
                  goto LABEL_454;
                }
                v340 = v339 >> 16;
                v341 = 0xFFFF * (v333 + (unint64_t)v332)
                     - v333 * (unint64_t)v332;
                if (v341 <= 4294868992)
                  v332 = v341 + 0x8000;
                else
                  v332 = 4294868992;
                v331 = ((v332 >> 16) + v332) & 0xFFFF0000 | v340;
                LODWORD(v332) = HIWORD(v331);
LABEL_452:
                *v34 = bswap32(v331) >> 16;
                v342 = v29;
LABEL_454:
                *v342 = bswap32(v332) >> 16;
LABEL_455:
                ++v67;
                v66 += 2;
                v137 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                if (!--v327)
                {
LABEL_456:
                  v45 = &v137[v452];
                  v34 += v453;
                  v29 += v454;
LABEL_457:
                  v110 = v457;
                  v99 = v458;
                  goto LABEL_491;
                }
              }
            case 24:
              v262 = v45;
              while (1)
              {
                v343 = *v67;
                if (!*v67)
                  goto LABEL_472;
                if (v45)
                {
                  v343 = ((unsigned __int16)(*v262 * (_WORD)v343
                                                            + ((*v262 * v343) >> 8)
                                                            + 1) >> 8);
                  if (!v343)
                    goto LABEL_472;
                }
                v344 = (unsigned __int16)*(_DWORD *)v66;
                v345 = (v343 | (v343 << 8)) ^ 0xFFFF;
                v346 = v345 * v344 + ((v345 * v344) >> 16) + 1;
                v347 = (v344 - HIWORD(v346)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v345 * HIWORD(*(_DWORD *)v66)
                                                 + ((v345 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v348 = HIWORD(v347);
                if (!HIWORD(v347))
                  goto LABEL_472;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_469;
                  v349 = __rev16(*v29);
                }
                else
                {
                  v349 = 0xFFFF;
                }
                v347 = PDAhuePDA_8079(bswap32(*v34) >> 16, v349, (unsigned __int16)(v344 - HIWORD(v346)), v348);
                v52 = v461;
                if (!v461)
                {
                  v348 = v347;
                  v350 = v34;
                  goto LABEL_471;
                }
                v348 = HIWORD(v347);
LABEL_469:
                *v34 = bswap32(v347) >> 16;
                v350 = v29;
LABEL_471:
                *v350 = bswap32(v348) >> 16;
LABEL_472:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                  goto LABEL_489;
              }
            case 25:
              v262 = v45;
              while (1)
              {
                v351 = *v67;
                if (!*v67)
                  goto LABEL_488;
                if (v45)
                {
                  v351 = ((unsigned __int16)(*v262 * (_WORD)v351
                                                            + ((*v262 * v351) >> 8)
                                                            + 1) >> 8);
                  if (!v351)
                    goto LABEL_488;
                }
                v352 = (unsigned __int16)*(_DWORD *)v66;
                v353 = (v351 | (v351 << 8)) ^ 0xFFFF;
                v354 = v353 * v352 + ((v353 * v352) >> 16) + 1;
                v355 = (v352 - HIWORD(v354)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v353 * HIWORD(*(_DWORD *)v66)
                                                 + ((v353 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v356 = HIWORD(v355);
                if (!HIWORD(v355))
                  goto LABEL_488;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_485;
                  v357 = __rev16(*v29);
                }
                else
                {
                  v357 = 0xFFFF;
                }
                v355 = PDAhuePDA_8079(bswap32(*v34) >> 16, v357, (unsigned __int16)(v352 - HIWORD(v354)), v356);
                v52 = v461;
                if (!v461)
                {
                  v356 = v355;
                  v358 = v34;
                  goto LABEL_487;
                }
                v356 = HIWORD(v355);
LABEL_485:
                *v34 = bswap32(v355) >> 16;
                v358 = v29;
LABEL_487:
                *v358 = bswap32(v356) >> 16;
LABEL_488:
                ++v67;
                v66 += 2;
                v262 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                LODWORD(v46) = v46 - 1;
                if (!(_DWORD)v46)
                {
LABEL_489:
                  v45 = &v262[v452];
LABEL_490:
                  v34 += v453;
                  v29 += v454;
                  v38 = v450;
                  v39 = v449;
                  v46 = v451;
                  v110 = v457;
                  v99 = v458;
                  v71 = (int)v459;
                  goto LABEL_491;
                }
              }
            case 26:
              v359 = v46;
              v360 = v45;
              v361 = v359;
              while (1)
              {
                v362 = *v67;
                if (!*v67)
                  goto LABEL_508;
                if (v45)
                {
                  v362 = ((unsigned __int16)(*v360 * (_WORD)v362
                                                            + ((*v360 * v362) >> 8)
                                                            + 1) >> 8);
                  if (!v362)
                    goto LABEL_508;
                }
                v363 = (unsigned __int16)*(_DWORD *)v66;
                v364 = (v362 | (v362 << 8)) ^ 0xFFFF;
                v365 = v364 * v363 + ((v364 * v363) >> 16) + 1;
                v366 = (v363 - HIWORD(v365)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v364 * HIWORD(*(_DWORD *)v66)
                                                 + ((v364 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v367 = HIWORD(v366);
                if (!HIWORD(v366))
                  goto LABEL_508;
                if (v52)
                {
                  if (!*v29)
                    goto LABEL_505;
                  v368 = __rev16(*v29);
                }
                else
                {
                  v368 = 0xFFFF;
                }
                v366 = PDAluminosityPDA_8081((unsigned __int16)(v363 - HIWORD(v365)), v367, bswap32(*v34) >> 16, v368);
                v52 = v461;
                if (!v461)
                {
                  v367 = v366;
                  v369 = v34;
                  goto LABEL_507;
                }
                v367 = HIWORD(v366);
LABEL_505:
                *v34 = bswap32(v366) >> 16;
                v369 = v29;
LABEL_507:
                *v369 = bswap32(v367) >> 16;
LABEL_508:
                ++v67;
                v66 += 2;
                v360 += v45 != 0;
                ++v34;
                v29 = (unsigned __int16 *)((char *)v29 + v60);
                if (!--v361)
                  goto LABEL_525;
              }
            case 27:
              v370 = v46;
              v360 = v45;
              v371 = v370;
              break;
            default:
              goto LABEL_457;
          }
          while (2)
          {
            v372 = *v67;
            if (*v67)
            {
              if (!v45
                || (v372 = ((unsigned __int16)(*v360 * (_WORD)v372
                                                              + ((*v360 * v372) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                v373 = (unsigned __int16)*(_DWORD *)v66;
                v374 = (v372 | (v372 << 8)) ^ 0xFFFF;
                v375 = v374 * v373 + ((v374 * v373) >> 16) + 1;
                v376 = (v373 - HIWORD(v375)) | ((HIWORD(*(_DWORD *)v66)
                                               - ((v374 * HIWORD(*(_DWORD *)v66)
                                                 + ((v374 * HIWORD(*(_DWORD *)v66)) >> 16)
                                                 + 1) >> 16)) << 16);
                v377 = HIWORD(v376);
                if (HIWORD(v376))
                {
                  if (v52)
                  {
                    if (*v29)
                    {
                      v378 = __rev16(*v29);
                      goto LABEL_519;
                    }
LABEL_521:
                    *v34 = bswap32(v376) >> 16;
                    v379 = v29;
                  }
                  else
                  {
                    v378 = 0xFFFF;
LABEL_519:
                    v376 = PDAluminosityPDA_8081(bswap32(*v34) >> 16, v378, (unsigned __int16)(v373 - HIWORD(v375)), v377);
                    v52 = v461;
                    if (v461)
                    {
                      v377 = HIWORD(v376);
                      goto LABEL_521;
                    }
                    v377 = v376;
                    v379 = v34;
                  }
                  *v379 = bswap32(v377) >> 16;
                }
              }
            }
            ++v67;
            v66 += 2;
            v360 += v45 != 0;
            ++v34;
            v29 = (unsigned __int16 *)((char *)v29 + v60);
            if (!--v371)
            {
LABEL_525:
              v45 = &v360[v452];
              goto LABEL_490;
            }
            continue;
          }
        }
        v56 = shape_enum_clip_scan(v460, (_DWORD *)v45 - 4);
        v52 = v461;
        if (!v56)
          goto LABEL_624;
      }
      v456 -= v55;
      if (v456 < 1)
      {
LABEL_624:
        if (v460)
          free((void *)v460);
        goto LABEL_626;
      }
      v38 = v53;
      v40 += *(_QWORD *)(v39 + 128) * v55;
      v41 += *(_QWORD *)(v39 + 136) * v55;
      v34 += v440 * v55;
      v57 = (_QWORD)v459 * v55;
      if (!v52)
        v57 = 0;
      v29 += v57;
      v49 = v54;
    }
  }
}

uint64_t W16_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  _WORD *v6;
  _WORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t result;
  unsigned __int8 *v17;
  int v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned int v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  unsigned __int8 *v46;
  unsigned int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unsigned __int8 *v53;
  int v54;
  unsigned __int8 *v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t *v65;
  unsigned __int8 *v66;
  int v67;
  unsigned int v68;
  unsigned __int8 *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int8 *v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 *v81;
  int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;

  v6 = (_WORD *)*((_QWORD *)a2 + 2);
  v7 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v7)
    v97 = *((_QWORD *)a2 + 5) - a5;
  else
    v97 = 0;
  v8 = *((unsigned __int16 *)a2 + 4);
  v96 = *a2;
  v95 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v9 = *((_QWORD *)a2 + 18);
  v11 = *((_QWORD *)a2 + 9);
  v94 = *((_QWORD *)a2 + 11);
  v12 = *((_QWORD *)a2 + 7) + v94 * a4;
  v13 = *(unsigned __int8 **)(a1 + 32);
  v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v15 = *(_QWORD *)(a1 + 176);
  result = 2 * (v7 != 0);
  if (v15)
  {
    v93 = *((_QWORD *)a2 + 13);
    v92 = *((_QWORD *)a2 + 15);
    v17 = v14 - 4;
    v18 = v8 ^ 0xFFFF;
    v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    v91 = v9 + 16 * a3 + 8;
    do
    {
      if (((v92 - v12) | (v12 - v93)) < 0)
      {
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9)
          v21 = -v10;
        else
          v21 = v10;
        v22 = weights_19497[v20] & 0xF;
      }
      v23 = &v13[(v12 >> v11) * v10];
      if (v96 == 1)
      {
        if (a5 >= 1)
        {
          v24 = (uint64_t *)v91;
          v25 = a5;
          do
          {
            v26 = *v24;
            v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27)
              v28 = &v23[*(v24 - 1)];
            else
              v28 = v17;
            if (v28 < v13)
              v28 = v13;
            v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30)
                v30 = v17;
              if (v30 < v13)
                v30 = v13;
              v31 = *v30;
              if (v22)
              {
                v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v33 < v13)
                  v33 = v13;
                v34 = *v33;
                v35 = &v32[v26 >> 4];
                if (v17 < v35)
                  v35 = v17;
                if (v35 < v13)
                  v35 = v13;
                v36 = BLEND8_19499[v22];
                v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                v31 = v31 - ((v36 & v31) >> v22) + ((v36 & *v35) >> v22);
              }
              v29 = v29
                  - ((BLEND8_19499[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_19499[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37)
                v37 = v17;
              if (v37 < v13)
                v37 = v13;
              v29 = v29 - ((BLEND8_19499[v22] & v29) >> v22) + ((BLEND8_19499[v22] & *v37) >> v22);
            }
            v38 = v29 | (v29 << 8);
            v39 = v38 | 0xFFFF0000;
            v40 = (v38 - ((v38 * v18 + ((v38 * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF)
              v40 = v39;
            v41 = bswap32(v40);
            *v6 = HIWORD(v41);
            if (v7)
              *v7 = v41;
            v24 += 2;
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        v43 = (uint64_t *)v91;
        v42 = a5;
        do
        {
          v44 = *v43;
          v45 = (unint64_t)&v23[*(v43 - 1)];
          if ((unint64_t)v17 >= v45)
            v46 = &v23[*(v43 - 1)];
          else
            v46 = v17;
          if (v46 < v13)
            v46 = v13;
          v47 = *v46;
          if ((v44 & 0xF) != 0)
          {
            v48 = (unsigned __int8 *)(v45 + (v44 >> 4));
            if (v17 < v48)
              v48 = v17;
            if (v48 < v13)
              v48 = v13;
            v49 = *v48;
            if (v22)
            {
              v50 = (unsigned __int8 *)(v45 + v21);
              if (v17 >= v50)
                v51 = v50;
              else
                v51 = v17;
              if (v51 < v13)
                v51 = v13;
              v52 = *v51;
              v53 = &v50[v44 >> 4];
              if (v17 < v53)
                v53 = v17;
              if (v53 < v13)
                v53 = v13;
              v54 = BLEND8_19499[v22];
              v47 = v47 - ((v54 & v47) >> v22) + ((v54 & v52) >> v22);
              v49 = v49 - ((v54 & v49) >> v22) + ((v54 & *v53) >> v22);
            }
            v47 = v47
                - ((BLEND8_19499[*v43 & 0xF] & v47) >> (*v43 & 0xF))
                + ((BLEND8_19499[*v43 & 0xF] & v49) >> (*v43 & 0xF));
          }
          else if (v22)
          {
            v55 = (unsigned __int8 *)(v45 + v21);
            if (v17 < v55)
              v55 = v17;
            if (v55 < v13)
              v55 = v13;
            v47 = v47 - ((BLEND8_19499[v22] & v47) >> v22) + ((BLEND8_19499[v22] & *v55) >> v22);
          }
          v56 = v47 | (v47 << 8);
          v57 = v56 | 0xFFFF0000;
          v58 = (v56 - ((v56 * v18 + ((v56 * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF)
            v59 = v57;
          else
            v59 = v58;
          v60 = HIWORD(v59);
          if (v7)
          {
            if (v60)
            {
              if (v60 == 0xFFFF)
              {
                *v6 = bswap32(v59) >> 16;
                *v7 = -1;
              }
              else
              {
                v62 = bswap32((unsigned __int16)*v6);
                v63 = bswap32((unsigned __int16)*v7);
                *v6 = bswap32(v59 + (((v60 ^ 0xFFFF) * HIWORD(v62) + (((v60 ^ 0xFFFF) * HIWORD(v62)) >> 16) + 1) >> 16)) >> 16;
                *v7 = bswap32((((v60 ^ 0xFFFF) * HIWORD(v63) + (((v60 ^ 0xFFFF) * HIWORD(v63)) >> 16) + 1) >> 16)+ HIWORD(v59)) >> 16;
              }
            }
          }
          else if (v60)
          {
            if (v60 == 0xFFFF)
            {
              v61 = bswap32(v59);
            }
            else
            {
              v64 = bswap32((unsigned __int16)*v6);
              v61 = bswap32(v59 + (((v60 ^ 0xFFFF) * HIWORD(v64) + (((v60 ^ 0xFFFF) * HIWORD(v64)) >> 16) + 1) >> 16));
            }
            *v6 = HIWORD(v61);
          }
          v43 += 2;
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          --v42;
        }
        while (v42);
      }
      v6 += v95;
      v12 += v94;
      v7 += v97;
      --a6;
    }
    while (a6);
  }
  else
  {
    v65 = (uint64_t *)(v9 + 16 * a3);
    v66 = v14 - 4;
    v67 = v8 ^ 0xFFFF;
    v68 = ~(0xFFFF * v67 + ((0xFFFF * v67) >> 16) + 1) & 0xFFFF0000;
    do
    {
      v69 = &v13[(v12 >> v11) * v10];
      if (v96 == 1)
      {
        if (a5 >= 1)
        {
          v70 = v65;
          v71 = a5;
          do
          {
            v72 = *v70;
            v70 += 2;
            v73 = &v69[v72];
            if (v66 < &v69[v72])
              v73 = v66;
            if (v73 < v13)
              v73 = v13;
            v74 = *v73 | (*v73 << 8);
            v75 = v74 | 0xFFFF0000;
            v76 = (v74 - ((v74 * v67 + ((v74 * v67) >> 16) + 1) >> 16)) | v68;
            if (v8 == 0xFFFF)
              v76 = v75;
            v77 = bswap32(v76);
            *v6 = HIWORD(v77);
            if (v7)
              *v7 = v77;
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v71;
          }
          while (v71);
        }
      }
      else
      {
        v78 = v65;
        v79 = a5;
        if (a5 >= 1)
        {
          do
          {
            v80 = *v78;
            v78 += 2;
            v81 = &v69[v80];
            if (v66 < &v69[v80])
              v81 = v66;
            if (v81 < v13)
              v81 = v13;
            v82 = *v81 | (*v81 << 8);
            v83 = v82 | 0xFFFF0000;
            v84 = (v82 - ((v82 * v67 + ((v82 * v67) >> 16) + 1) >> 16)) | v68;
            if (v8 == 0xFFFF)
              v85 = v83;
            else
              v85 = v84;
            v86 = HIWORD(v85);
            if (v7)
            {
              if (v86)
              {
                if (v86 == 0xFFFF)
                {
                  *v6 = bswap32(v85) >> 16;
                  *v7 = -1;
                }
                else
                {
                  v88 = bswap32((unsigned __int16)*v6);
                  v89 = bswap32((unsigned __int16)*v7);
                  *v6 = bswap32(v85 + (((v86 ^ 0xFFFF) * HIWORD(v88) + (((v86 ^ 0xFFFF) * HIWORD(v88)) >> 16) + 1) >> 16)) >> 16;
                  *v7 = bswap32((((v86 ^ 0xFFFF) * HIWORD(v89) + (((v86 ^ 0xFFFF) * HIWORD(v89)) >> 16) + 1) >> 16)+ HIWORD(v85)) >> 16;
                }
              }
            }
            else if (v86)
            {
              if (v86 == 0xFFFF)
              {
                v87 = bswap32(v85);
              }
              else
              {
                v90 = bswap32((unsigned __int16)*v6);
                v87 = bswap32(v85 + (((v86 ^ 0xFFFF) * HIWORD(v90) + (((v86 ^ 0xFFFF) * HIWORD(v90)) >> 16) + 1) >> 16));
              }
              *v6 = HIWORD(v87);
            }
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v79;
          }
          while (v79);
        }
      }
      v6 += v95;
      v12 += v94;
      v7 += v97;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t W16_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  _WORD *v6;
  _WORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t result;
  unsigned __int8 *v17;
  int v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  unsigned __int8 *v30;
  int v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 *v35;
  unsigned int v36;
  unsigned __int8 *v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  unsigned __int8 *v47;
  unsigned int v48;
  unsigned __int8 *v49;
  int v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  int v53;
  unsigned __int8 *v54;
  unsigned int v55;
  unsigned __int8 *v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  uint64_t *v68;
  unsigned __int8 *v69;
  int v70;
  unsigned int v71;
  unsigned __int8 *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned __int8 *v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  unsigned __int8 *v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  int v95;
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;

  v6 = (_WORD *)*((_QWORD *)a2 + 2);
  v7 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v7)
    v102 = *((_QWORD *)a2 + 5) - a5;
  else
    v102 = 0;
  v8 = *((unsigned __int16 *)a2 + 4);
  v101 = *a2;
  v100 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v9 = *((_QWORD *)a2 + 18);
  v11 = *((_QWORD *)a2 + 9);
  v99 = *((_QWORD *)a2 + 11);
  v12 = *((_QWORD *)a2 + 7) + v99 * a4;
  v13 = *(unsigned __int8 **)(a1 + 32);
  v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v15 = *(_QWORD *)(a1 + 176);
  result = 2 * (v7 != 0);
  if (v15)
  {
    v98 = *((_QWORD *)a2 + 13);
    v97 = *((_QWORD *)a2 + 15);
    v17 = v14 - 3;
    v18 = v8 ^ 0xFFFF;
    v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    do
    {
      if (((v97 - v12) | (v12 - v98)) < 0)
      {
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9)
          v21 = -v10;
        else
          v21 = v10;
        v22 = weights_19497[v20] & 0xF;
      }
      v23 = &v13[(v12 >> v11) * v10];
      if (v101 == 1)
      {
        if (a5 >= 1)
        {
          v24 = (uint64_t *)(v9 + 16 * a3 + 8);
          v25 = a5;
          do
          {
            v26 = *v24;
            v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27)
              v28 = &v23[*(v24 - 1)];
            else
              v28 = v17;
            if (v28 < v13)
              v28 = v13;
            v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30)
                v30 = v17;
              if (v30 < v13)
                v30 = v13;
              v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
              if (v22)
              {
                v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v33 < v13)
                  v33 = v13;
                v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
                v35 = &v32[v26 >> 4];
                if (v17 < v35)
                  v35 = v17;
                if (v35 < v13)
                  v35 = v13;
                v36 = BLEND8_19499[v22];
                v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                v31 = v31 - ((v36 & v31) >> v22) + ((((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8)) & v36) >> v22);
              }
              v29 = v29
                  - ((BLEND8_19499[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_19499[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37)
                v37 = v17;
              if (v37 < v13)
                v37 = v13;
              v29 = v29
                  - ((BLEND8_19499[v22] & v29) >> v22)
                  + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & BLEND8_19499[v22]) >> v22);
            }
            v38 = ((v29 >> 23) & 0x1FE) + BYTE1(v29) + (((v29 >> 8) & 0xFF00) >> 6) + (((v29 >> 8) & 0xFF00) >> 8);
            v39 = 32 * v38;
            v38 >>= 6;
            v40 = (unsigned __int16)v38 | (unsigned __int16)v39 | 0xFFFF0000;
            v41 = ((v39 | v38) - (((v39 | v38) * v18 + (((v39 | v38) * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF)
              v41 = v40;
            v42 = bswap32(v41);
            *v6 = HIWORD(v42);
            if (v7)
              *v7 = v42;
            v24 += 2;
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        v44 = (uint64_t *)(v9 + 16 * a3 + 8);
        v43 = a5;
        do
        {
          v45 = *v44;
          v46 = (unint64_t)&v23[*(v44 - 1)];
          if ((unint64_t)v17 >= v46)
            v47 = &v23[*(v44 - 1)];
          else
            v47 = v17;
          if (v47 < v13)
            v47 = v13;
          v48 = (*v47 << 24) | (v47[1] << 16) | (v47[2] << 8);
          if ((v45 & 0xF) != 0)
          {
            v49 = (unsigned __int8 *)(v46 + (v45 >> 4));
            if (v17 < v49)
              v49 = v17;
            if (v49 < v13)
              v49 = v13;
            v50 = (*v49 << 24) | (v49[1] << 16) | (v49[2] << 8);
            if (v22)
            {
              v51 = (unsigned __int8 *)(v46 + v21);
              if (v17 >= v51)
                v52 = v51;
              else
                v52 = v17;
              if (v52 < v13)
                v52 = v13;
              v53 = (*v52 << 24) | (v52[1] << 16) | (v52[2] << 8);
              v54 = &v51[v45 >> 4];
              if (v17 < v54)
                v54 = v17;
              if (v54 < v13)
                v54 = v13;
              v55 = BLEND8_19499[v22];
              v48 = v48 - ((v55 & v48) >> v22) + ((v55 & v53) >> v22);
              v50 = v50 - ((v55 & v50) >> v22) + ((((*v54 << 24) | (v54[1] << 16) | (v54[2] << 8)) & v55) >> v22);
            }
            v48 = v48
                - ((BLEND8_19499[*v44 & 0xF] & v48) >> (*v44 & 0xF))
                + ((BLEND8_19499[*v44 & 0xF] & v50) >> (*v44 & 0xF));
          }
          else if (v22)
          {
            v56 = (unsigned __int8 *)(v46 + v21);
            if (v17 < v56)
              v56 = v17;
            if (v56 < v13)
              v56 = v13;
            v48 = v48
                - ((BLEND8_19499[v22] & v48) >> v22)
                + ((((*v56 << 24) | (v56[1] << 16) | (v56[2] << 8)) & BLEND8_19499[v22]) >> v22);
          }
          v57 = ((v48 >> 23) & 0x1FE) + BYTE1(v48) + (((v48 >> 8) & 0xFF00) >> 6) + (((v48 >> 8) & 0xFF00) >> 8);
          v58 = 32 * v57;
          v57 >>= 6;
          v59 = (unsigned __int16)v57 | (unsigned __int16)v58 | 0xFFFF0000;
          v60 = ((v58 | v57) - (((v58 | v57) * v18 + (((v58 | v57) * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF)
            v61 = v59;
          else
            v61 = v60;
          v62 = HIWORD(v61);
          if (v7)
          {
            if (v62)
            {
              if (v62 == 0xFFFF)
              {
                *v6 = bswap32(v61) >> 16;
                *v7 = -1;
              }
              else
              {
                v64 = bswap32((unsigned __int16)*v6);
                v65 = bswap32((unsigned __int16)*v7) >> 16;
                v66 = v62 ^ 0xFFFF;
                *v6 = bswap32(v61 + ((v66 * HIWORD(v64) + ((v66 * HIWORD(v64)) >> 16) + 1) >> 16)) >> 16;
                *v7 = bswap32(((v66 * v65 + ((v66 * v65) >> 16) + 1) >> 16) + HIWORD(v61)) >> 16;
              }
            }
          }
          else if (v62)
          {
            if (v62 == 0xFFFF)
            {
              v63 = bswap32(v61);
            }
            else
            {
              v67 = bswap32((unsigned __int16)*v6) >> 16;
              v63 = bswap32(v61 + (((v62 ^ 0xFFFF) * v67 + (((v62 ^ 0xFFFF) * v67) >> 16) + 1) >> 16));
            }
            *v6 = HIWORD(v63);
          }
          v44 += 2;
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          --v43;
        }
        while (v43);
      }
      v6 += v100;
      v12 += v99;
      v7 += v102;
      --a6;
    }
    while (a6);
  }
  else
  {
    v68 = (uint64_t *)(v9 + 16 * a3);
    v69 = v14 - 3;
    v70 = v8 ^ 0xFFFF;
    v71 = ~(0xFFFF * v70 + ((0xFFFF * v70) >> 16) + 1) & 0xFFFF0000;
    do
    {
      v72 = &v13[(v12 >> v11) * v10];
      if (v101 == 1)
      {
        if (a5 >= 1)
        {
          v73 = v68;
          v74 = a5;
          do
          {
            v75 = *v73;
            v73 += 2;
            v76 = &v72[v75];
            if (v69 < &v72[v75])
              v76 = v69;
            if (v76 < v13)
              v76 = v13;
            v77 = v76[2] + 2 * *v76 + 4 * v76[1] + v76[1];
            v78 = 32 * v77;
            v77 >>= 6;
            v79 = (unsigned __int16)v77 | (unsigned __int16)v78 | 0xFFFF0000;
            v80 = ((v78 | v77) - (((v78 | v77) * v70 + (((v78 | v77) * v70) >> 16) + 1) >> 16)) | v71;
            if (v8 == 0xFFFF)
              v80 = v79;
            v81 = bswap32(v80);
            *v6 = HIWORD(v81);
            if (v7)
              *v7 = v81;
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v74;
          }
          while (v74);
        }
      }
      else
      {
        v82 = v68;
        v83 = a5;
        if (a5 >= 1)
        {
          do
          {
            v84 = *v82;
            v82 += 2;
            v85 = &v72[v84];
            if (v69 < &v72[v84])
              v85 = v69;
            if (v85 < v13)
              v85 = v13;
            v86 = v85[2] + 2 * *v85 + 4 * v85[1] + v85[1];
            v87 = 32 * v86;
            v86 >>= 6;
            v88 = (unsigned __int16)v86 | (unsigned __int16)v87 | 0xFFFF0000;
            v89 = ((v87 | v86) - (((v87 | v86) * v70 + (((v87 | v86) * v70) >> 16) + 1) >> 16)) | v71;
            if (v8 == 0xFFFF)
              v90 = v88;
            else
              v90 = v89;
            v91 = HIWORD(v90);
            if (v7)
            {
              if (v91)
              {
                if (v91 == 0xFFFF)
                {
                  *v6 = bswap32(v90) >> 16;
                  *v7 = -1;
                }
                else
                {
                  v93 = bswap32((unsigned __int16)*v6);
                  v94 = bswap32((unsigned __int16)*v7) >> 16;
                  v95 = v91 ^ 0xFFFF;
                  *v6 = bswap32(v90 + ((v95 * HIWORD(v93) + ((v95 * HIWORD(v93)) >> 16) + 1) >> 16)) >> 16;
                  *v7 = bswap32(((v95 * v94 + ((v95 * v94) >> 16) + 1) >> 16) + HIWORD(v90)) >> 16;
                }
              }
            }
            else if (v91)
            {
              if (v91 == 0xFFFF)
              {
                v92 = bswap32(v90);
              }
              else
              {
                v96 = bswap32((unsigned __int16)*v6) >> 16;
                v92 = bswap32(v90 + (((v91 ^ 0xFFFF) * v96 + (((v91 ^ 0xFFFF) * v96) >> 16) + 1) >> 16));
              }
              *v6 = HIWORD(v92);
            }
            ++v6;
            v7 = (_WORD *)((char *)v7 + result);
            --v83;
          }
          while (v83);
        }
      }
      v6 += v100;
      v12 += v99;
      v7 += v102;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t W16_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  _WORD *v7;
  _WORD *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  uint64_t v17;
  uint64_t result;
  unsigned int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unsigned int *v30;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  unsigned int *v57;
  unsigned int v58;
  char v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int *v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int *v65;
  int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int *v70;
  int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  unsigned int v82;
  uint64_t *v83;
  unsigned int *v84;
  int v85;
  char *v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int *v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  int v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int *v101;
  unsigned int v102;
  int v103;
  unsigned int v104;
  int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  int v111;
  unsigned int v112;
  uint64_t v113;
  uint64_t v114;
  char v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (_WORD *)*((_QWORD *)a2 + 2);
  v8 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v8)
    v124 = *((_QWORD *)a2 + 5) - a5;
  else
    v124 = 0;
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = a2[1];
  v123 = *a2;
  v122 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v121 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v121 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  v17 = *(_QWORD *)(a1 + 176);
  result = 2 * (v8 != 0);
  if (v17)
  {
    v118 = *((_QWORD *)a2 + 13);
    v116 = ~(-1 << v13);
    v117 = *((_QWORD *)a2 + 15);
    v115 = v13 - 4;
    v19 = (unsigned int *)(v16 - 4);
    v20 = v9 ^ 0xFFFF;
    v114 = a5;
    v113 = v11 + 16 * a3 + 8;
    v119 = *((_QWORD *)a2 + 9);
    v120 = a5;
    while (1)
    {
      if (((v117 - v14) | (v14 - v118)) < 0)
      {
        v23 = 0;
        v22 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)v116) >> v115) & 0xF;
        v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        v23 = weights_19497[v21] & 0xF;
      }
      v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v123 != 1)
        break;
      if (a5 >= 1)
      {
        v25 = (uint64_t *)v113;
        v26 = v114;
        while (1)
        {
          v28 = *(v25 - 1);
          v27 = *v25;
          v29 = &v24[v28];
          if (v19 >= (unsigned int *)&v24[v28])
            v30 = (unsigned int *)&v24[v28];
          else
            v30 = v19;
          if (v30 < v15)
            v30 = v15;
          v31 = bswap32(*v30);
          v32 = v27 & 0xF;
          if ((v27 & 0xF) != 0)
            break;
          if (v23)
          {
            v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22])
              v43 = v19;
            if (v43 < v15)
              v43 = v15;
            v44 = BLEND8_19499[v23];
            v41 = v31 - ((v44 & v31) >> v23);
            v42 = (bswap32(*v43) & v44) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          v45 = __ROL4__(v31, v10);
          v46 = v45 | v6;
          v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          v48 = 32 * v47;
          v47 >>= 6;
          v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v50 = v49;
          v51 = bswap32(v50);
          *v7 = HIWORD(v51);
          if (v8)
            *v8 = v51;
          v25 += 2;
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          if (!--v26)
            goto LABEL_96;
        }
        v33 = (unsigned int *)&v29[v27 >> 4];
        if (v19 < v33)
          v33 = v19;
        if (v33 < v15)
          v33 = v15;
        v34 = bswap32(*v33);
        if (v23)
        {
          v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35)
            v36 = v35;
          else
            v36 = v19;
          if (v36 < v15)
            v36 = v15;
          v37 = bswap32(*v36);
          v38 = (unsigned int *)((char *)v35 + (v27 >> 4));
          if (v19 < v38)
            v38 = v19;
          if (v38 < v15)
            v38 = v15;
          v39 = BLEND8_19499[v23];
          v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          v34 = v34 - ((v39 & v34) >> v23) + ((bswap32(*v38) & v39) >> v23);
        }
        v40 = BLEND8_19499[*v25 & 0xF];
        v41 = v31 - ((v40 & v31) >> v32);
        v42 = (v40 & v34) >> v32;
LABEL_46:
        v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v122;
      a5 = v120;
      v14 += v121;
      v8 += v124;
      --a6;
      LOBYTE(v13) = v119;
      if (!a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_96;
    v53 = (uint64_t *)v113;
    v52 = v114;
    while (1)
    {
      v55 = *(v53 - 1);
      v54 = *v53;
      v56 = &v24[v55];
      if (v19 >= (unsigned int *)&v24[v55])
        v57 = (unsigned int *)&v24[v55];
      else
        v57 = v19;
      if (v57 < v15)
        v57 = v15;
      v58 = bswap32(*v57);
      v59 = v54 & 0xF;
      if ((v54 & 0xF) != 0)
        break;
      if (v23)
      {
        v70 = (unsigned int *)&v56[v22];
        if (v19 < (unsigned int *)&v56[v22])
          v70 = v19;
        if (v70 < v15)
          v70 = v15;
        v71 = BLEND8_19499[v23];
        v68 = v58 - ((v71 & v58) >> v23);
        v69 = (bswap32(*v70) & v71) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      v72 = __ROL4__(v58, v10);
      v73 = v72 | v6;
      v74 = ((v72 >> 23) & 0x1FE) + BYTE1(v72) + (((v72 >> 8) & 0xFF00) >> 6) + (((v72 >> 8) & 0xFF00) >> 8);
      v75 = 32 * v74;
      v74 >>= 6;
      v76 = v74 | (v73 << 24) | (v73 << 16) | v75;
      v77 = ((v75 | v74) - (((v75 | v74) * v20 + (((v75 | v74) * v20) >> 16) + 1) >> 16)) | (((v73 | (v73 << 8))
                                                                                            - (((v73 | (v73 << 8))
                                                                                              * v20
                                                                                              + (((v73 | (v73 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF)
        v77 = v76;
      v78 = HIWORD(v77);
      if (v8)
      {
        if (v78)
        {
          if (v78 == 0xFFFF)
          {
            *v7 = bswap32(v77) >> 16;
            *v8 = -1;
          }
          else
          {
            v80 = bswap32((unsigned __int16)*v8) >> 16;
            v81 = v78 ^ 0xFFFF;
            v82 = v81 * (bswap32((unsigned __int16)*v7) >> 16);
            *v7 = bswap32(v77 + ((v82 + HIWORD(v82) + 1) >> 16)) >> 16;
            *v8 = bswap32(((v81 * v80 + ((v81 * v80) >> 16) + 1) >> 16) + HIWORD(v77)) >> 16;
          }
        }
      }
      else if (v78)
      {
        if (v78 != 0xFFFF)
        {
          v79 = bswap32((unsigned __int16)*v7) >> 16;
          v77 += ((v78 ^ 0xFFFF) * v79 + (((v78 ^ 0xFFFF) * v79) >> 16) + 1) >> 16;
        }
        *v7 = bswap32(v77) >> 16;
      }
      v53 += 2;
      ++v7;
      v8 = (_WORD *)((char *)v8 + result);
      if (!--v52)
        goto LABEL_96;
    }
    v60 = (unsigned int *)&v56[v54 >> 4];
    if (v19 < v60)
      v60 = v19;
    if (v60 < v15)
      v60 = v15;
    v61 = bswap32(*v60);
    if (v23)
    {
      v62 = (unsigned int *)&v56[v22];
      if (v19 >= v62)
        v63 = v62;
      else
        v63 = v19;
      if (v63 < v15)
        v63 = v15;
      v64 = bswap32(*v63);
      v65 = (unsigned int *)((char *)v62 + (v54 >> 4));
      if (v19 < v65)
        v65 = v19;
      if (v65 < v15)
        v65 = v15;
      v66 = BLEND8_19499[v23];
      v58 = v58 - ((v66 & v58) >> v23) + ((v66 & v64) >> v23);
      v61 = v61 - ((v66 & v61) >> v23) + ((bswap32(*v65) & v66) >> v23);
    }
    v67 = BLEND8_19499[*v53 & 0xF];
    v68 = v58 - ((v67 & v58) >> v59);
    v69 = (v67 & v61) >> v59;
LABEL_83:
    v58 = v68 + v69;
    goto LABEL_84;
  }
  v83 = (uint64_t *)(v11 + 16 * a3);
  v84 = (unsigned int *)(v16 - 4);
  v85 = v9 ^ 0xFFFF;
  do
  {
    v86 = (char *)v15 + (v14 >> v13) * v12;
    if (v123 == 1)
    {
      if (a5 >= 1)
      {
        v87 = v83;
        v88 = a5;
        do
        {
          v89 = *v87;
          v87 += 2;
          v90 = (unsigned int *)&v86[v89];
          if (v84 < (unsigned int *)&v86[v89])
            v90 = v84;
          if (v90 < v15)
            v90 = v15;
          v91 = __ROL4__(bswap32(*v90), v10);
          v92 = v91 | v6;
          v93 = ((v91 >> 23) & 0x1FE) + BYTE1(v91) + (((v91 >> 8) & 0xFF00) >> 6) + (((v91 >> 8) & 0xFF00) >> 8);
          v94 = 32 * v93;
          v93 >>= 6;
          v95 = v93 | (v92 << 24) | (v92 << 16) | v94;
          v96 = ((v94 | v93) - (((v94 | v93) * v85 + (((v94 | v93) * v85) >> 16) + 1) >> 16)) | (((v92 | (v92 << 8))
                                                                                                - (((v92 | (v92 << 8)) * v85
                                                                                                  + (((v92 | (v92 << 8)) * v85) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v96 = v95;
          v97 = bswap32(v96);
          *v7 = HIWORD(v97);
          if (v8)
            *v8 = v97;
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v88;
        }
        while (v88);
      }
    }
    else
    {
      v98 = v83;
      v99 = a5;
      if (a5 >= 1)
      {
        do
        {
          v100 = *v98;
          v98 += 2;
          v101 = (unsigned int *)&v86[v100];
          if (v84 < (unsigned int *)&v86[v100])
            v101 = v84;
          if (v101 < v15)
            v101 = v15;
          v102 = __ROL4__(bswap32(*v101), v10);
          v103 = v102 | v6;
          v104 = ((v102 >> 23) & 0x1FE) + BYTE1(v102) + (((v102 >> 8) & 0xFF00) >> 6) + (((v102 >> 8) & 0xFF00) >> 8);
          v105 = 32 * v104;
          v104 >>= 6;
          v106 = v104 | (v103 << 24) | (v103 << 16) | v105;
          v107 = ((v105 | v104) - (((v105 | v104) * v85 + (((v105 | v104) * v85) >> 16) + 1) >> 16)) | (((v103 | (v103 << 8)) - (((v103 | (v103 << 8)) * v85 + (((v103 | (v103 << 8)) * v85) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v107 = v106;
          v108 = HIWORD(v107);
          if (v8)
          {
            if (v108)
            {
              if (v108 == 0xFFFF)
              {
                *v7 = bswap32(v107) >> 16;
                *v8 = -1;
              }
              else
              {
                v110 = bswap32((unsigned __int16)*v8) >> 16;
                v111 = v108 ^ 0xFFFF;
                v112 = v111 * (bswap32((unsigned __int16)*v7) >> 16);
                *v7 = bswap32(v107 + ((v112 + HIWORD(v112) + 1) >> 16)) >> 16;
                *v8 = bswap32(((v111 * v110 + ((v111 * v110) >> 16) + 1) >> 16) + HIWORD(v107)) >> 16;
              }
            }
          }
          else if (v108)
          {
            if (v108 != 0xFFFF)
            {
              v109 = bswap32((unsigned __int16)*v7) >> 16;
              v107 += ((v108 ^ 0xFFFF) * v109 + (((v108 ^ 0xFFFF) * v109) >> 16) + 1) >> 16;
            }
            *v7 = bswap32(v107) >> 16;
          }
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v99;
        }
        while (v99);
      }
    }
    v7 += v122;
    v14 += v121;
    v8 += v124;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t W16_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  _WORD *v7;
  _WORD *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  uint64_t v17;
  uint64_t result;
  unsigned int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unsigned int *v30;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  unsigned int *v57;
  unsigned int v58;
  char v59;
  unsigned int *v60;
  unsigned int v61;
  char *v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int *v65;
  int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int *v70;
  int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  unsigned int v82;
  uint64_t *v83;
  char *v84;
  int v85;
  char *v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int *v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  int v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int *v101;
  unsigned int v102;
  int v103;
  unsigned int v104;
  int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  int v111;
  unsigned int v112;
  uint64_t v113;
  uint64_t v114;
  char v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (_WORD *)*((_QWORD *)a2 + 2);
  v8 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v8)
    v124 = *((_QWORD *)a2 + 5) - a5;
  else
    v124 = 0;
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = a2[1];
  v123 = *a2;
  v122 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v121 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v121 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  v17 = *(_QWORD *)(a1 + 176);
  result = 2 * (v8 != 0);
  if (v17)
  {
    v118 = *((_QWORD *)a2 + 13);
    v116 = ~(-1 << v13);
    v117 = *((_QWORD *)a2 + 15);
    v115 = v13 - 4;
    v19 = (unsigned int *)(v16 - 4);
    v20 = v9 ^ 0xFFFF;
    v114 = a5;
    v113 = v11 + 16 * a3 + 8;
    v119 = *((_QWORD *)a2 + 9);
    v120 = a5;
    while (1)
    {
      if (((v117 - v14) | (v14 - v118)) < 0)
      {
        v23 = 0;
        v22 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)v116) >> v115) & 0xF;
        v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        v23 = weights_19497[v21] & 0xF;
      }
      v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v123 != 1)
        break;
      if (a5 >= 1)
      {
        v25 = (uint64_t *)v113;
        v26 = v114;
        while (1)
        {
          v27 = *(v25 - 1);
          v28 = *v25;
          v29 = &v24[v27];
          if (v19 >= (unsigned int *)&v24[v27])
            v30 = (unsigned int *)&v24[v27];
          else
            v30 = v19;
          if (v30 < v15)
            v30 = v15;
          v31 = *v30;
          v32 = v28 & 0xF;
          if ((v28 & 0xF) != 0)
            break;
          if (v23)
          {
            v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22])
              v43 = v19;
            if (v43 < v15)
              v43 = v15;
            v44 = BLEND8_19499[v23];
            v41 = v31 - ((v44 & v31) >> v23);
            v42 = (v44 & *v43) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          v45 = __ROL4__(v31, v10);
          v46 = v45 | v6;
          v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          v48 = 32 * v47;
          v47 >>= 6;
          v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v50 = v49;
          v51 = bswap32(v50);
          *v7 = HIWORD(v51);
          if (v8)
            *v8 = v51;
          v25 += 2;
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          if (!--v26)
            goto LABEL_96;
        }
        v33 = (unsigned int *)&v29[v28 >> 4];
        if (v19 < v33)
          v33 = v19;
        if (v33 < v15)
          v33 = v15;
        v34 = *v33;
        if (v23)
        {
          v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35)
            v36 = v35;
          else
            v36 = v19;
          if (v36 < v15)
            v36 = v15;
          v37 = *v36;
          v38 = (unsigned int *)((char *)v35 + (v28 >> 4));
          if (v19 < v38)
            v38 = v19;
          if (v38 < v15)
            v38 = v15;
          v39 = BLEND8_19499[v23];
          v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
        }
        v40 = BLEND8_19499[*v25 & 0xF];
        v41 = v31 - ((v40 & v31) >> v32);
        v42 = (v40 & v34) >> v32;
LABEL_46:
        v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v122;
      a5 = v120;
      v14 += v121;
      v8 += v124;
      --a6;
      LOBYTE(v13) = v119;
      if (!a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_96;
    v53 = (uint64_t *)v113;
    v52 = v114;
    while (1)
    {
      v54 = *(v53 - 1);
      v55 = *v53;
      v56 = &v24[v54];
      if (v19 >= (unsigned int *)&v24[v54])
        v57 = (unsigned int *)&v24[v54];
      else
        v57 = v19;
      if (v57 < v15)
        v57 = v15;
      v58 = *v57;
      v59 = v55 & 0xF;
      if ((v55 & 0xF) != 0)
        break;
      if (v23)
      {
        v70 = (unsigned int *)&v56[v22];
        if (v19 < (unsigned int *)&v56[v22])
          v70 = v19;
        if (v70 < v15)
          v70 = v15;
        v71 = BLEND8_19499[v23];
        v68 = v58 - ((v71 & v58) >> v23);
        v69 = (v71 & *v70) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      v72 = __ROL4__(v58, v10);
      v73 = v72 | v6;
      v74 = ((v72 >> 23) & 0x1FE) + BYTE1(v72) + (((v72 >> 8) & 0xFF00) >> 6) + (((v72 >> 8) & 0xFF00) >> 8);
      v75 = 32 * v74;
      v74 >>= 6;
      v76 = v74 | (v73 << 24) | (v73 << 16) | v75;
      v77 = ((v75 | v74) - (((v75 | v74) * v20 + (((v75 | v74) * v20) >> 16) + 1) >> 16)) | (((v73 | (v73 << 8))
                                                                                            - (((v73 | (v73 << 8))
                                                                                              * v20
                                                                                              + (((v73 | (v73 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF)
        v77 = v76;
      v78 = HIWORD(v77);
      if (v8)
      {
        if (v78)
        {
          if (v78 == 0xFFFF)
          {
            *v7 = bswap32(v77) >> 16;
            *v8 = -1;
          }
          else
          {
            v80 = bswap32((unsigned __int16)*v8) >> 16;
            v81 = v78 ^ 0xFFFF;
            v82 = v81 * (bswap32((unsigned __int16)*v7) >> 16);
            *v7 = bswap32(v77 + ((v82 + HIWORD(v82) + 1) >> 16)) >> 16;
            *v8 = bswap32(((v81 * v80 + ((v81 * v80) >> 16) + 1) >> 16) + HIWORD(v77)) >> 16;
          }
        }
      }
      else if (v78)
      {
        if (v78 != 0xFFFF)
        {
          v79 = bswap32((unsigned __int16)*v7) >> 16;
          v77 += ((v78 ^ 0xFFFF) * v79 + (((v78 ^ 0xFFFF) * v79) >> 16) + 1) >> 16;
        }
        *v7 = bswap32(v77) >> 16;
      }
      v53 += 2;
      ++v7;
      v8 = (_WORD *)((char *)v8 + result);
      if (!--v52)
        goto LABEL_96;
    }
    v60 = (unsigned int *)&v56[v55 >> 4];
    if (v19 < v60)
      v60 = v19;
    if (v60 < v15)
      v60 = v15;
    v61 = *v60;
    if (v23)
    {
      v62 = &v56[v22];
      if (v19 >= (unsigned int *)&v56[v22])
        v63 = (unsigned int *)&v56[v22];
      else
        v63 = v19;
      if (v63 < v15)
        v63 = v15;
      v64 = *v63;
      v65 = (unsigned int *)&v62[v55 >> 4];
      if (v19 < v65)
        v65 = v19;
      if (v65 < v15)
        v65 = v15;
      v66 = BLEND8_19499[v23];
      v58 = v58 - ((v66 & v58) >> v23) + ((v66 & v64) >> v23);
      v61 = v61 - ((v66 & v61) >> v23) + ((v66 & *v65) >> v23);
    }
    v67 = BLEND8_19499[*v53 & 0xF];
    v68 = v58 - ((v67 & v58) >> v59);
    v69 = (v67 & v61) >> v59;
LABEL_83:
    v58 = v68 + v69;
    goto LABEL_84;
  }
  v83 = (uint64_t *)(v11 + 16 * a3);
  v84 = v16 - 4;
  v85 = v9 ^ 0xFFFF;
  do
  {
    v86 = (char *)v15 + (v14 >> v13) * v12;
    if (v123 == 1)
    {
      if (a5 >= 1)
      {
        v87 = v83;
        v88 = a5;
        do
        {
          v89 = *v87;
          v87 += 2;
          v90 = (unsigned int *)&v86[v89];
          if (v84 < &v86[v89])
            v90 = (unsigned int *)v84;
          if (v90 < v15)
            v90 = v15;
          v91 = __ROL4__(*v90, v10);
          v92 = v91 | v6;
          v93 = ((v91 >> 23) & 0x1FE) + BYTE1(v91) + (((v91 >> 8) & 0xFF00) >> 6) + (((v91 >> 8) & 0xFF00) >> 8);
          v94 = 32 * v93;
          v93 >>= 6;
          v95 = v93 | (v92 << 24) | (v92 << 16) | v94;
          v96 = ((v94 | v93) - (((v94 | v93) * v85 + (((v94 | v93) * v85) >> 16) + 1) >> 16)) | (((v92 | (v92 << 8))
                                                                                                - (((v92 | (v92 << 8)) * v85
                                                                                                  + (((v92 | (v92 << 8)) * v85) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v96 = v95;
          v97 = bswap32(v96);
          *v7 = HIWORD(v97);
          if (v8)
            *v8 = v97;
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v88;
        }
        while (v88);
      }
    }
    else
    {
      v98 = v83;
      v99 = a5;
      if (a5 >= 1)
      {
        do
        {
          v100 = *v98;
          v98 += 2;
          v101 = (unsigned int *)&v86[v100];
          if (v84 < &v86[v100])
            v101 = (unsigned int *)v84;
          if (v101 < v15)
            v101 = v15;
          v102 = __ROL4__(*v101, v10);
          v103 = v102 | v6;
          v104 = ((v102 >> 23) & 0x1FE) + BYTE1(v102) + (((v102 >> 8) & 0xFF00) >> 6) + (((v102 >> 8) & 0xFF00) >> 8);
          v105 = 32 * v104;
          v104 >>= 6;
          v106 = v104 | (v103 << 24) | (v103 << 16) | v105;
          v107 = ((v105 | v104) - (((v105 | v104) * v85 + (((v105 | v104) * v85) >> 16) + 1) >> 16)) | (((v103 | (v103 << 8)) - (((v103 | (v103 << 8)) * v85 + (((v103 | (v103 << 8)) * v85) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF)
            v107 = v106;
          v108 = HIWORD(v107);
          if (v8)
          {
            if (v108)
            {
              if (v108 == 0xFFFF)
              {
                *v7 = bswap32(v107) >> 16;
                *v8 = -1;
              }
              else
              {
                v110 = bswap32((unsigned __int16)*v8) >> 16;
                v111 = v108 ^ 0xFFFF;
                v112 = v111 * (bswap32((unsigned __int16)*v7) >> 16);
                *v7 = bswap32(v107 + ((v112 + HIWORD(v112) + 1) >> 16)) >> 16;
                *v8 = bswap32(((v111 * v110 + ((v111 * v110) >> 16) + 1) >> 16) + HIWORD(v107)) >> 16;
              }
            }
          }
          else if (v108)
          {
            if (v108 != 0xFFFF)
            {
              v109 = bswap32((unsigned __int16)*v7) >> 16;
              v107 += ((v108 ^ 0xFFFF) * v109 + (((v108 ^ 0xFFFF) * v109) >> 16) + 1) >> 16;
            }
            *v7 = bswap32(v107) >> 16;
          }
          ++v7;
          v8 = (_WORD *)((char *)v8 + result);
          --v99;
        }
        while (v99);
      }
    }
    v7 += v122;
    v14 += v121;
    v8 += v124;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t W16_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  char *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int8x16_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned __int16 *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned int v41;
  int16x4_t *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  unsigned int *v62;
  uint64_t v63;
  int16x4_t *v64;
  unsigned __int16 *v65;
  char v66;
  int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  unsigned int *v73;
  uint64_t v74;
  int16x4_t *v75;
  unsigned __int16 *v76;
  char v77;
  int v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  int v92;
  int v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  uint64_t v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  int v106;
  uint64_t v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  int v113;
  int v114;
  uint64_t v115;
  int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  int v129;
  int v130;
  uint64_t v131;
  int v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  int v137;
  int v138;
  unsigned int v139;
  unsigned int v140;
  uint64_t v141;
  int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned __int16 v146;
  uint64_t v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int v151;
  int v152;
  uint64_t v153;
  int v154;
  unsigned int v155;
  unsigned int v156;
  unsigned int v157;
  signed int v158;
  unsigned int v159;
  uint64_t v160;
  int v161;
  unsigned int v162;
  unsigned int v163;
  unsigned int v164;
  unsigned int v165;
  uint64_t v166;
  int v167;
  unint64_t v168;
  unint64_t v169;
  unsigned int v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  int64_t v174;
  int16x4_t *v175;
  uint64_t v176;
  int v177;
  unint64_t v178;
  unint64_t v179;
  unsigned int v180;
  uint64_t v181;
  unint64_t v182;
  unint64_t v183;
  int64_t v184;
  int16x4_t *v185;
  uint64_t v186;
  int v187;
  unsigned int v188;
  unsigned int v189;
  int16x4_t *v190;
  uint64_t v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  int16x4_t *v195;
  uint64_t v196;
  int v197;
  unsigned int v198;
  unsigned int v199;
  int16x4_t *v200;
  uint64_t v201;
  int v202;
  unsigned int v203;
  unsigned int v204;
  int16x4_t *v205;
  uint64_t v206;
  int v207;
  unsigned int v208;
  unsigned int v209;
  int16x4_t *v210;
  uint64_t v211;
  int v212;
  unsigned int v213;
  unsigned int v214;
  int16x4_t *v215;
  uint64_t v216;
  int v217;
  unsigned int v218;
  unsigned int v219;
  int16x4_t *v220;
  uint64_t v221;
  int v222;
  unsigned int v223;
  unsigned int v224;
  int16x4_t *v225;
  uint64_t v226;
  int v227;
  unint64_t v228;
  unint64_t v229;
  unsigned int v230;
  uint64_t v231;
  uint64_t v232;
  int64_t v233;
  unint64_t v234;
  unint64_t v235;
  int64_t v236;
  int16x4_t *v237;
  uint64_t v238;
  int v239;
  unsigned int v240;
  unsigned int v241;
  int16x4_t *v242;
  uint64_t v243;
  int v244;
  unsigned int v245;
  unsigned int v246;
  int16x4_t *v247;
  uint64_t v248;
  int v249;
  unsigned int v250;
  unsigned int v251;
  int16x4_t *v252;
  uint64_t v253;
  int v254;
  unsigned int v255;
  unsigned int v256;
  int16x4_t *v257;
  int v258;
  char v259;
  unsigned int *v260;
  int16x4_t *v261;
  int v262;
  int v263;
  unsigned int v264;
  unsigned int v265;
  int v266;
  char v267;
  unsigned int *v268;
  int16x4_t *v269;
  int v270;
  int v271;
  unsigned int v272;
  unsigned int v273;
  int v274;
  unsigned int v275;
  signed int v276;
  uint64_t v277;
  int v278;
  uint64_t v279;
  unint64_t v280;
  int v281;
  unsigned int v282;
  unsigned int v283;
  int v284;
  unsigned int v285;
  unsigned int v286;
  unsigned int v287;
  unsigned int v288;
  unsigned int v289;
  int v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  int v294;
  unsigned int v295;
  unsigned int v296;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  int v300;
  unsigned int v301;
  int v302;
  unsigned int v303;
  unsigned int v304;
  unsigned int v305;
  int v306;
  uint64_t v307;
  unint64_t v308;
  int v309;
  unint64_t v310;
  unsigned int v311;
  int v312;
  unsigned int v313;
  unsigned int v314;
  unsigned int v315;
  unsigned int v316;
  unsigned int v317;
  unsigned int v318;
  unsigned int v319;
  unsigned int v320;
  unsigned int v321;
  unsigned int v322;
  unsigned int v323;
  unsigned int v324;
  unsigned int v325;
  unsigned int v326;
  unsigned int v327;
  int v328;
  unsigned int v329;
  unsigned int v330;
  unsigned int v331;
  int v332;
  unsigned int v333;
  unsigned int v334;
  unsigned int v335;
  int v336;
  unsigned int v337;
  unsigned int v338;
  int v339;
  uint64_t v340;
  unint64_t v341;
  uint64_t v342;
  unsigned int v343;
  int16x4_t v344;
  unsigned int v345;
  uint64_t v346;
  unsigned int v347;
  unsigned int v348;
  unsigned int v349;
  unsigned int v350;
  unsigned int v351;
  unsigned int v352;
  unsigned int v353;
  unsigned int v354;
  unsigned int v355;
  uint64_t v356;
  int v357;
  int v358;
  unint64_t v359;
  unsigned int v360;
  unsigned int v361;
  unsigned int v362;
  unsigned int v363;
  unsigned int v364;
  unsigned int v365;
  unsigned int v366;
  unsigned int v367;
  unsigned int v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  int v372;
  unint64_t v373;
  uint64_t v374;
  uint64_t v375;
  unint64_t v376;
  int v377;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned int **)(a1 + 96);
  v5 = bswap32(**(_DWORD **)(a1 + 88));
  if (v4)
    v7 = bswap32(*v4) << 16;
  else
    v7 = -65536;
  v8 = *(_DWORD *)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 136);
  v373 = *(int *)(a1 + 28);
  v10 = v7 | v5;
  v375 = *(_QWORD *)(a1 + 40);
  v377 = *(_DWORD *)(a1 + 4);
  pthread_mutex_lock(&W16_cacheColorLock);
  v11 = W16_cacheColor;
  if (!W16_cacheColor || *(_DWORD *)(W16_cacheColor + 16) != v10)
  {
    v14 = 0;
    while (1)
    {
      if (!v11)
        goto LABEL_12;
      v15 = v11;
      v16 = v14;
      if (*(_DWORD *)(v11 + 16) == v10)
        break;
      v11 = *(_QWORD *)v11;
      v14 = (_QWORD *)v15;
      if (!*(_QWORD *)v15)
      {
        if (W16_cacheColorCount > 6)
        {
          *v16 = 0;
        }
        else
        {
LABEL_12:
          v17 = (char *)W16_cacheColorBase;
          if (W16_cacheColorBase)
          {
            v18 = W16_cacheColorCount;
          }
          else
          {
            v17 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            v18 = 0;
            W16_cacheColorBase = (uint64_t)v17;
          }
          v15 = (uint64_t)&v17[24 * v18];
          *(_QWORD *)(v15 + 8) = &v17[1024 * (unint64_t)v18 + 168];
          W16_cacheColorCount = v18 + 1;
        }
        v19 = 0;
        *(_QWORD *)v15 = W16_cacheColor;
        W16_cacheColor = v15;
        *(_DWORD *)(v15 + 16) = v10;
        v21 = *(_QWORD *)(v15 + 8);
        v13 = v15 + 8;
        v20 = v21;
        v22 = vdupq_n_s32((unsigned __int16)v5);
        v23 = vdupq_n_s32(HIWORD(v10));
        v24 = (int32x4_t)xmmword_185004DC0;
        v25 = vdupq_n_s32(0x101u);
        v26.i64[0] = 0xFFFF0000FFFFLL;
        v26.i64[1] = 0xFFFF0000FFFFLL;
        v27.i64[0] = 0x400000004;
        v27.i64[1] = 0x400000004;
        do
        {
          v28 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v24, v25), v26);
          v29 = (int8x16_t)vmulq_s32(v28, v22);
          v30 = (int8x16_t)vmulq_s32(v28, v23);
          *(int8x16_t *)(v20 + v19) = vorrq_s8((int8x16_t)vshlq_n_s32(vsubq_s32(v23, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x10uLL), (int32x4_t)vmvnq_s8(v30)), 0x10uLL)), 0x10uLL), (int8x16_t)vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL), (int32x4_t)vmvnq_s8(v29)),
                                                                  0x10uLL)));
          v24 = vaddq_s32(v24, v27);
          v19 += 16;
        }
        while (v19 != 1024);
        result = pthread_mutex_unlock(&W16_cacheColorLock);
        goto LABEL_23;
      }
    }
    if (v14)
    {
      *v14 = *(_QWORD *)v11;
      *(_QWORD *)v11 = W16_cacheColor;
      W16_cacheColor = v11;
    }
  }
  result = pthread_mutex_unlock(&W16_cacheColorLock);
  v13 = v11 + 8;
LABEL_23:
  v31 = v377;
  v32 = *(_QWORD *)v13;
  v33 = *(_DWORD *)(*(_QWORD *)v13 + 1020);
  v35 = *(int *)(a1 + 12);
  v34 = *(int *)(a1 + 16);
  if (v3)
  {
    v36 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v37 = (unsigned __int16 *)(v3 + 2 * (v35 + v36 * v34));
    v38 = 1;
    if (!v9)
      return result;
  }
  else
  {
    v37 = 0;
    v36 = 0;
    v38 = 0;
    if (!v9)
      return result;
  }
  v39 = v36 - v377;
  if (v3)
    v40 = v36 - v377;
  else
    v40 = v36;
  v41 = HIWORD(v33);
  v42 = (int16x4_t *)(v375 + 2 * (v35 + (v373 >> 1) * v34));
  v43 = *(int *)(a1 + 124);
  v44 = v9 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v43;
  v45 = v43 - v377;
  v46 = (v373 >> 1) - v377;
  v374 = v45;
  v376 = v46;
  v47 = v40;
  switch(a2)
  {
    case 0:
      if (v3)
      {
        v48 = 2 * v38;
        do
        {
          v49 = v377;
          do
          {
            v50 = *(unsigned __int8 *)v44;
            if (*(_BYTE *)v44)
            {
              if (v50 == 255)
              {
                LOWORD(v51) = 0;
                v42->i16[0] = 0;
              }
              else
              {
                v52 = bswap32(v42->u16[0]) >> 16;
                v53 = bswap32(*v37) >> 16;
                v54 = (v50 ^ 0xFF | ((v50 ^ 0xFF) << 8)) ^ 0xFFFF;
                v42->i16[0] = bswap32(v52 - ((v54 * v52 + ((v54 * v52) >> 16) + 1) >> 16)) >> 16;
                v51 = bswap32(v53 - ((v54 * v53 + ((v54 * v53) >> 16) + 1) >> 16)) >> 16;
              }
              *v37 = v51;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            v37 = (unsigned __int16 *)((char *)v37 + v48);
            --v49;
          }
          while (v49);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          v37 += v40;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v55 = v377;
          do
          {
            v56 = *(unsigned __int8 *)v44;
            if (*(_BYTE *)v44)
            {
              if (v56 == 255)
              {
                LOWORD(v57) = 0;
              }
              else
              {
                v58 = bswap32(v42->u16[0]) >> 16;
                v59 = ((v56 ^ 0xFF | ((v56 ^ 0xFF) << 8)) ^ 0xFFFF) * v58;
                v57 = bswap32(v58 - ((v59 + HIWORD(v59) + 1) >> 16)) >> 16;
              }
              v42->i16[0] = v57;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            --v55;
          }
          while (v55);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          --v8;
        }
        while (v8);
      }
      return result;
    case 1:
      v60 = v44 & 3;
      if (!v3)
      {
        v258 = -1 << (8 * v60);
        if ((v44 & 3) != 0)
          v259 = v44 & 0xFC;
        else
          v259 = v44;
        if ((v44 & 3) != 0)
        {
          v260 = (unsigned int *)(v44 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v258 = -1;
          v260 = (unsigned int *)v44;
        }
        if ((v44 & 3) != 0)
          v261 = (int16x4_t *)((char *)v42 - 2 * (v44 & 3));
        else
          v261 = v42;
        if ((v44 & 3) != 0)
          v262 = v60 + v377;
        else
          v262 = v377;
        if ((((_BYTE)v262 + v259) & 3) != 0)
        {
          v263 = 4 - (((_BYTE)v262 + v259) & 3);
          v60 += v263;
          v264 = 0xFFFFFFFF >> (8 * v263);
          if (v262 >= 4)
            v265 = v264;
          else
            v265 = 0;
          if (v262 >= 4)
            v264 = -1;
          v258 &= v264;
        }
        else
        {
          v265 = 0;
        }
        v340 = v45 - v60;
        v341 = v46 - v60;
        v342 = (v262 >> 2);
        v343 = bswap32(v33) >> 16;
        v344 = vdup_n_s16(v343);
        while (1)
        {
          v345 = *v260 & v258;
          v346 = v342;
          v347 = v265;
          if (!v345)
            goto LABEL_583;
LABEL_565:
          if (v345 == -1)
          {
            *v261 = v344;
            goto LABEL_583;
          }
          while (1)
          {
            if ((_BYTE)v345)
            {
              LOWORD(v348) = v343;
              if (v345 != 255)
              {
                v349 = (bswap32(v261->u16[0]) >> 16) * ((v345 | (v345 << 8)) ^ 0xFFFF);
                v348 = bswap32(*(_DWORD *)(v32 + 4 * v345) + ((v349 + HIWORD(v349) + 1) >> 16)) >> 16;
              }
              v261->i16[0] = v348;
            }
            if (BYTE1(v345))
            {
              LOWORD(v350) = v343;
              if (BYTE1(v345) != 255)
              {
                v351 = bswap32(v261->u16[1]) >> 16;
                v350 = bswap32(*(_DWORD *)(v32 + 4 * BYTE1(v345))+ ((v351 * ((BYTE1(v345) | (BYTE1(v345) << 8)) ^ 0xFFFF)+ ((v351 * ((BYTE1(v345) | (BYTE1(v345) << 8)) ^ 0xFFFF)) >> 16)+ 1) >> 16)) >> 16;
              }
              v261->i16[1] = v350;
            }
            if (BYTE2(v345))
            {
              LOWORD(v352) = v343;
              if (BYTE2(v345) != 255)
              {
                v353 = bswap32(v261->u16[2]) >> 16;
                v352 = bswap32(*(_DWORD *)(v32 + 4 * BYTE2(v345))+ ((v353 * ((BYTE2(v345) | (BYTE2(v345) << 8)) ^ 0xFFFF)+ ((v353 * ((BYTE2(v345) | (BYTE2(v345) << 8)) ^ 0xFFFF)) >> 16)+ 1) >> 16)) >> 16;
              }
              v261->i16[2] = v352;
            }
            v354 = HIBYTE(v345);
            if (v354 == 255)
            {
              v261->i16[3] = v343;
            }
            else if (v354)
            {
              v355 = bswap32(v261->u16[3]) >> 16;
              v261->i16[3] = bswap32(*(_DWORD *)(v32 + 4 * v354)+ ((((v354 | (v354 << 8)) ^ 0xFFFF) * v355+ ((((v354 | (v354 << 8)) ^ 0xFFFF) * v355) >> 16)+ 1) >> 16)) >> 16;
            }
LABEL_583:
            while (1)
            {
              result = v346;
              ++v261;
              v346 = (v346 - 1);
              ++v260;
              if ((int)result < 2)
                break;
              v345 = *v260;
              if (*v260)
                goto LABEL_565;
            }
            if (!v347)
              break;
            v347 = 0;
            v345 = *v260 & v265;
          }
          v260 = (unsigned int *)((char *)v260 + v340);
          v261 = (int16x4_t *)((char *)v261 + 2 * v341);
          if (!--v8)
            return result;
        }
      }
      v61 = -1 << (8 * v60);
      v62 = (unsigned int *)(v44 & 0xFFFFFFFFFFFFFFFCLL);
      v63 = 2 * (v44 & 3);
      v64 = (int16x4_t *)((char *)v42 - v63);
      v65 = &v37[v63 / 0xFFFFFFFFFFFFFFFELL];
      if ((v44 & 3) != 0)
        v66 = v44 & 0xFC;
      else
        v66 = v44;
      if ((v44 & 3) != 0)
      {
        v67 = v60 + v377;
      }
      else
      {
        v61 = -1;
        v62 = (unsigned int *)v44;
        v65 = v37;
        v64 = v42;
        v67 = v377;
      }
      if ((((_BYTE)v67 + v66) & 3) != 0)
      {
        v68 = 4 - (((_BYTE)v67 + v66) & 3);
        v60 += v68;
        v69 = 0xFFFFFFFF >> (8 * v68);
        if (v67 >= 4)
          v70 = v69;
        else
          v70 = 0;
        if (v67 >= 4)
          v69 = -1;
        v61 &= v69;
      }
      else
      {
        v70 = 0;
      }
      v279 = v45 - v60;
      v280 = v46 - v60;
      v281 = v67 >> 2;
      v282 = bswap32(v33);
      result = v39 - v60;
      do
      {
        v283 = *v62 & v61;
        v284 = v281;
        v285 = v70;
        if (!v283)
          goto LABEL_534;
LABEL_513:
        if (v283 == -1)
        {
          v64->i16[0] = HIWORD(v282);
          *v65 = v282;
          v64->i16[1] = HIWORD(v282);
          v65[1] = v282;
          v64->i16[2] = HIWORD(v282);
          v65[2] = v282;
LABEL_531:
          v64->i16[3] = HIWORD(v282);
          v65[3] = v282;
          goto LABEL_534;
        }
        while (1)
        {
          if ((_BYTE)v283)
          {
            if (v283 == 255)
            {
              v64->i16[0] = HIWORD(v282);
              LOWORD(v286) = v282;
            }
            else
            {
              v287 = *(_DWORD *)(v32 + 4 * v283);
              v288 = bswap32(v64->u16[0]);
              v289 = bswap32(*v65) >> 16;
              v290 = (v283 | (v283 << 8)) ^ 0xFFFF;
              v64->i16[0] = bswap32(v287 + ((HIWORD(v288) * v290 + ((HIWORD(v288) * v290) >> 16) + 1) >> 16)) >> 16;
              v286 = bswap32(((v289 * v290 + ((v289 * v290) >> 16) + 1) >> 16) + HIWORD(v287)) >> 16;
            }
            *v65 = v286;
          }
          if (BYTE1(v283))
          {
            if (BYTE1(v283) == 255)
            {
              v64->i16[1] = HIWORD(v282);
              LOWORD(v291) = v282;
            }
            else
            {
              v292 = *(_DWORD *)(v32 + 4 * BYTE1(v283));
              v293 = bswap32(v65[1]) >> 16;
              v294 = (BYTE1(v283) | (BYTE1(v283) << 8)) ^ 0xFFFF;
              v295 = (bswap32(v64->u16[1]) >> 16) * v294;
              v64->i16[1] = bswap32(v292 + ((v295 + HIWORD(v295) + 1) >> 16)) >> 16;
              v291 = bswap32(((v293 * v294 + ((v293 * v294) >> 16) + 1) >> 16) + HIWORD(v292)) >> 16;
            }
            v65[1] = v291;
          }
          if (BYTE2(v283))
          {
            if (BYTE2(v283) == 255)
            {
              v64->i16[2] = HIWORD(v282);
              LOWORD(v296) = v282;
            }
            else
            {
              v297 = *(_DWORD *)(v32 + 4 * BYTE2(v283));
              v298 = bswap32(v64->u16[2]);
              v299 = bswap32(v65[2]) >> 16;
              v300 = (BYTE2(v283) | (BYTE2(v283) << 8)) ^ 0xFFFF;
              v64->i16[2] = bswap32(v297 + ((HIWORD(v298) * v300 + ((HIWORD(v298) * v300) >> 16) + 1) >> 16)) >> 16;
              v296 = bswap32(((v299 * v300 + ((v299 * v300) >> 16) + 1) >> 16) + HIWORD(v297)) >> 16;
            }
            v65[2] = v296;
          }
          v301 = HIBYTE(v283);
          if (v301 == 255)
            goto LABEL_531;
          if (v301)
          {
            v302 = v301 | (v301 << 8);
            v303 = *(_DWORD *)(v32 + 4 * v301);
            v304 = bswap32(v65[3]) >> 16;
            v302 ^= 0xFFFFu;
            v305 = v302 * (bswap32(v64->u16[3]) >> 16);
            v64->i16[3] = bswap32(v303 + ((v305 + HIWORD(v305) + 1) >> 16)) >> 16;
            v65[3] = bswap32(((v302 * v304 + ((v302 * v304) >> 16) + 1) >> 16) + HIWORD(v303)) >> 16;
          }
LABEL_534:
          while (1)
          {
            v306 = v284;
            ++v64;
            v65 += 4;
            --v284;
            ++v62;
            if (v306 < 2)
              break;
            v283 = *v62;
            if (*v62)
              goto LABEL_513;
          }
          if (!v285)
            break;
          v285 = 0;
          v283 = *v62 & v70;
        }
        v62 = (unsigned int *)((char *)v62 + v279);
        v64 = (int16x4_t *)((char *)v64 + 2 * v280);
        v65 += result;
        --v8;
      }
      while (v8);
      return result;
    case 2:
      v71 = v44 & 3;
      if (v3)
      {
        v72 = -1 << (8 * v71);
        v73 = (unsigned int *)(v44 & 0xFFFFFFFFFFFFFFFCLL);
        v74 = 2 * (v44 & 3);
        v75 = (int16x4_t *)((char *)v42 - v74);
        v76 = &v37[v74 / 0xFFFFFFFFFFFFFFFELL];
        if ((v44 & 3) != 0)
          v77 = v44 & 0xFC;
        else
          v77 = v44;
        if ((v44 & 3) != 0)
        {
          v78 = v71 + v377;
        }
        else
        {
          v72 = -1;
          v73 = (unsigned int *)v44;
          v76 = v37;
          v75 = v42;
          v78 = v377;
        }
        if ((((_BYTE)v78 + v77) & 3) != 0)
        {
          v79 = 4 - (((_BYTE)v78 + v77) & 3);
          v71 += v79;
          v80 = 0xFFFFFFFF >> (8 * v79);
          if (v78 >= 4)
            v81 = v80;
          else
            v81 = 0;
          if (v78 >= 4)
            v80 = -1;
          v72 &= v80;
        }
        else
        {
          v81 = 0;
        }
        v307 = v45 - v71;
        v308 = v46 - v71;
        v309 = v78 >> 2;
        result = (unsigned __int16)~HIWORD(v33);
        v310 = v39 - v71;
        while (1)
        {
          v311 = *v73 & v72;
          v312 = v309;
          v313 = v81;
          if (!v311)
            goto LABEL_555;
LABEL_544:
          if (v311 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v311)
            {
              v326 = *(_DWORD *)(v32 + 4 * v311);
              v327 = bswap32(*v76) >> 16;
              v328 = HIWORD(v326) ^ 0xFFFF;
              v329 = v328 * (bswap32(v75->u16[0]) >> 16);
              v75->i16[0] = bswap32(v326 + ((v329 + HIWORD(v329) + 1) >> 16)) >> 16;
              *v76 = bswap32(((v328 * v327 + ((v328 * v327) >> 16) + 1) >> 16) + HIWORD(v326)) >> 16;
            }
            if ((v311 & 0xFF00) != 0)
            {
              v330 = *(_DWORD *)(v32 + 4 * BYTE1(v311));
              v331 = bswap32(v76[1]) >> 16;
              v332 = HIWORD(v330) ^ 0xFFFF;
              v333 = v332 * (bswap32(v75->u16[1]) >> 16);
              v75->i16[1] = bswap32(v330 + ((v333 + HIWORD(v333) + 1) >> 16)) >> 16;
              v76[1] = bswap32(((v332 * v331 + ((v332 * v331) >> 16) + 1) >> 16) + HIWORD(v330)) >> 16;
            }
            if ((v311 & 0xFF0000) != 0)
            {
              v334 = *(_DWORD *)(v32 + 4 * BYTE2(v311));
              v335 = bswap32(v76[2]) >> 16;
              v336 = HIWORD(v334) ^ 0xFFFF;
              v337 = v336 * (bswap32(v75->u16[2]) >> 16);
              v75->i16[2] = bswap32(v334 + ((v337 + HIWORD(v337) + 1) >> 16)) >> 16;
              v76[2] = bswap32(((v336 * v335 + ((v336 * v335) >> 16) + 1) >> 16) + HIWORD(v334)) >> 16;
            }
            v338 = HIBYTE(v311);
            if (v338)
            {
              v324 = *(_DWORD *)(v32 + 4 * v338);
              v325 = HIWORD(v324);
              v322 = bswap32(v75->u16[3]) >> 16;
              v323 = bswap32(v76[3]) >> 16;
              v320 = HIWORD(v324) ^ 0xFFFF;
              v321 = v320;
              goto LABEL_554;
            }
LABEL_555:
            while (1)
            {
              v339 = v312;
              ++v75;
              v76 += 4;
              --v312;
              ++v73;
              if (v339 < 2)
                break;
              v311 = *v73;
              if (*v73)
                goto LABEL_544;
            }
            if (!v313)
              break;
            v313 = 0;
            v311 = *v73 & v81;
          }
          v73 = (unsigned int *)((char *)v73 + v307);
          v75 = (int16x4_t *)((char *)v75 + 2 * v308);
          v76 += v310;
          if (!--v8)
            return result;
        }
        v314 = bswap32(v75->u16[0]);
        v315 = bswap32(*v76);
        v75->i16[0] = bswap32(v33+ ((HIWORD(v314) * (_DWORD)result + ((HIWORD(v314) * result) >> 16) + 1) >> 16)) >> 16;
        *v76 = bswap32(((HIWORD(v315) * (_DWORD)result + ((HIWORD(v315) * result) >> 16) + 1) >> 16)+ HIWORD(v33)) >> 16;
        v316 = bswap32(v75->u16[1]);
        v317 = bswap32(v76[1]);
        v75->i16[1] = bswap32(v33+ ((HIWORD(v316) * (_DWORD)result + ((HIWORD(v316) * result) >> 16) + 1) >> 16)) >> 16;
        v76[1] = bswap32(((HIWORD(v317) * (_DWORD)result + ((HIWORD(v317) * result) >> 16) + 1) >> 16)+ HIWORD(v33)) >> 16;
        v318 = bswap32(v75->u16[2]);
        v319 = bswap32(v76[2]);
        v75->i16[2] = bswap32(v33+ ((HIWORD(v318) * (_DWORD)result + ((HIWORD(v318) * result) >> 16) + 1) >> 16)) >> 16;
        v76[2] = bswap32(((HIWORD(v319) * (_DWORD)result + ((HIWORD(v319) * result) >> 16) + 1) >> 16)+ HIWORD(v33)) >> 16;
        v320 = bswap32(v75->u16[3]) >> 16;
        v321 = bswap32(v76[3]) >> 16;
        v322 = (unsigned __int16)~HIWORD(v33);
        v323 = v322;
        v324 = v33;
        v325 = HIWORD(v33);
LABEL_554:
        v75->i16[3] = bswap32(v324 + ((v320 * v322 + ((v320 * v322) >> 16) + 1) >> 16)) >> 16;
        v76[3] = bswap32(v325 + ((v321 * v323 + ((v321 * v323) >> 16) + 1) >> 16)) >> 16;
        goto LABEL_555;
      }
      v266 = -1 << (8 * v71);
      if ((v44 & 3) != 0)
        v267 = v44 & 0xFC;
      else
        v267 = v44;
      if ((v44 & 3) != 0)
      {
        v268 = (unsigned int *)(v44 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        v266 = -1;
        v268 = (unsigned int *)v44;
      }
      if ((v44 & 3) != 0)
        v269 = (int16x4_t *)((char *)v42 - 2 * (v44 & 3));
      else
        v269 = v42;
      if ((v44 & 3) != 0)
        v270 = v71 + v377;
      else
        v270 = v377;
      if ((((_BYTE)v270 + v267) & 3) != 0)
      {
        v271 = 4 - (((_BYTE)v270 + v267) & 3);
        v71 += v271;
        v272 = 0xFFFFFFFF >> (8 * v271);
        if (v270 >= 4)
          v273 = -1;
        else
          v273 = 0xFFFFFFFF >> (8 * v271);
        v266 &= v273;
        if (v270 < 4)
          v272 = 0;
      }
      else
      {
        v272 = 0;
      }
      v356 = v45 - v71;
      v357 = v270 >> 2;
      v358 = (unsigned __int16)~HIWORD(v33);
      v359 = v46 - v71;
      while (1)
      {
        v360 = *v268 & v266;
        v361 = v272;
        LODWORD(result) = v357;
        if (!v360)
          goto LABEL_604;
LABEL_593:
        if (v360 == -1)
          break;
        while (1)
        {
          if ((_BYTE)v360)
          {
            v368 = bswap32(v269->u16[0]);
            v269->i16[0] = bswap32(*(_DWORD *)(v32 + 4 * v360)+ (((~*(_DWORD *)(v32 + 4 * v360) >> 16) * HIWORD(v368)+ (((~*(_DWORD *)(v32 + 4 * v360) >> 16) * HIWORD(v368)) >> 16)+ 1) >> 16)) >> 16;
          }
          if ((v360 & 0xFF00) != 0)
          {
            v369 = bswap32(v269->u16[1]);
            v269->i16[1] = bswap32(*(_DWORD *)(v32 + 4 * BYTE1(v360))+ (((~*(_DWORD *)(v32 + 4 * BYTE1(v360)) >> 16) * HIWORD(v369)+ (((~*(_DWORD *)(v32 + 4 * BYTE1(v360)) >> 16) * HIWORD(v369)) >> 16)+ 1) >> 16)) >> 16;
          }
          if ((v360 & 0xFF0000) != 0)
          {
            v370 = bswap32(v269->u16[2]);
            v269->i16[2] = bswap32(*(_DWORD *)(v32 + 4 * BYTE2(v360))+ (((~*(_DWORD *)(v32 + 4 * BYTE2(v360)) >> 16) * HIWORD(v370)+ (((~*(_DWORD *)(v32 + 4 * BYTE2(v360)) >> 16) * HIWORD(v370)) >> 16)+ 1) >> 16)) >> 16;
          }
          v371 = HIBYTE(v360);
          if (v371)
          {
            v367 = *(_DWORD *)(v32 + 4 * v371);
            v366 = bswap32(v269->u16[3]) >> 16;
            v365 = ~v367 >> 16;
            goto LABEL_603;
          }
LABEL_604:
          while (1)
          {
            v372 = result;
            ++v269;
            result = (result - 1);
            ++v268;
            if (v372 < 2)
              break;
            v360 = *v268;
            if (*v268)
              goto LABEL_593;
          }
          if (!v361)
            break;
          v361 = 0;
          v360 = *v268 & v272;
        }
        v268 = (unsigned int *)((char *)v268 + v356);
        v269 = (int16x4_t *)((char *)v269 + 2 * v359);
        if (!--v8)
          return result;
      }
      v362 = bswap32(v269->u16[0]);
      v269->i16[0] = bswap32(v33 + ((HIWORD(v362) * v358 + ((HIWORD(v362) * v358) >> 16) + 1) >> 16)) >> 16;
      v363 = bswap32(v269->u16[1]);
      v269->i16[1] = bswap32(v33 + ((HIWORD(v363) * v358 + ((HIWORD(v363) * v358) >> 16) + 1) >> 16)) >> 16;
      v364 = bswap32(v269->u16[2]);
      v269->i16[2] = bswap32(v33 + ((HIWORD(v364) * v358 + ((HIWORD(v364) * v358) >> 16) + 1) >> 16)) >> 16;
      v365 = bswap32(v269->u16[3]) >> 16;
      v366 = (unsigned __int16)~HIWORD(v33);
      v367 = v33;
LABEL_603:
      v269->i16[3] = bswap32(v367 + ((v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16)) >> 16;
      goto LABEL_604;
    case 3:
      v82 = 2 * v38;
      do
      {
        v83 = v377;
        do
        {
          v84 = *(unsigned __int8 *)v44;
          if (*(_BYTE *)v44)
          {
            if (v84 == 255)
            {
              v85 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v37);
              v42->i16[0] = bswap32(v85) >> 16;
              v86 = HIWORD(v85);
            }
            else
            {
              v87 = v84 | (v84 << 8);
              v88 = bswap32(*v37) >> 16;
              v89 = *(_DWORD *)(v32 + 4 * ((v88 * v87 + ((v88 * v87) >> 16) + 1) >> 24));
              v87 ^= 0xFFFFu;
              v90 = (bswap32(v42->u16[0]) >> 16) * v87;
              v42->i16[0] = bswap32(v89 + ((v90 + HIWORD(v90) + 1) >> 16)) >> 16;
              v86 = ((v88 * v87 + ((v88 * v87) >> 16) + 1) >> 16) + HIWORD(v89);
            }
            *v37 = bswap32(v86) >> 16;
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v82);
          --v83;
        }
        while (v83);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        --v8;
      }
      while (v8);
      return result;
    case 4:
      v91 = 2 * v38;
      do
      {
        v92 = v377;
        do
        {
          v93 = *(unsigned __int8 *)v44;
          if (*(_BYTE *)v44)
          {
            if (v93 == 255)
            {
              v94 = *(_DWORD *)(v32 + 4 * ~*(_BYTE *)v37);
              v42->i16[0] = bswap32(v94) >> 16;
              v95 = HIWORD(v94);
            }
            else
            {
              v96 = v93 | (v93 << 8);
              v97 = bswap32(*v37) >> 16;
              v98 = *(_DWORD *)(v32 + 4 * (((v97 ^ 0xFFFF) * v96 + (((v97 ^ 0xFFFF) * v96) >> 16) + 1) >> 24));
              v96 ^= 0xFFFFu;
              v99 = (bswap32(v42->u16[0]) >> 16) * v96;
              v42->i16[0] = bswap32(v98 + ((v99 + HIWORD(v99) + 1) >> 16)) >> 16;
              v95 = ((v97 * v96 + ((v97 * v96) >> 16) + 1) >> 16) + HIWORD(v98);
            }
            *v37 = bswap32(v95) >> 16;
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v91);
          --v92;
        }
        while (v92);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        --v8;
      }
      while (v8);
      return result;
    case 5:
      v100 = 2 * v38;
      do
      {
        v101 = v377;
        do
        {
          if (*(_BYTE *)v44)
          {
            v102 = bswap32(*v37);
            v103 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
            v104 = bswap32(v42->u16[0]);
            v105 = HIWORD(v103) ^ 0xFFFF;
            v42->i16[0] = bswap32((unsigned __int16)v103 * HIWORD(v102)+ v105 * HIWORD(v104)+ (((unsigned __int16)v103 * HIWORD(v102) + v105 * HIWORD(v104)) >> 16)+ 1);
            *v37 = bswap32((v105 + HIWORD(v102)) * HIWORD(v103)+ (((v105 + HIWORD(v102)) * HIWORD(v103)) >> 16)+ 1);
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v100);
          --v101;
        }
        while (v101);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        --v8;
      }
      while (v8);
      return result;
    case 6:
      do
      {
        v106 = v377;
        do
        {
          v107 = *(unsigned __int8 *)v44;
          if (*(_BYTE *)v44)
          {
            v108 = bswap32(*v37);
            if (HIWORD(v108) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v108) == 0xFFFF)
              {
                v109 = *(_DWORD *)(v32 + 4 * v107);
                v42->i16[0] = bswap32(v109) >> 16;
                v110 = HIWORD(v109);
              }
              else
              {
                v111 = HIWORD(v108);
                v112 = *(_DWORD *)(v32 + 4 * v107);
                v113 = (unsigned __int16)~HIWORD(v108);
                v42->i16[0] = bswap32((bswap32(v42->u16[0]) >> 16)+ (((unsigned __int16)v112 * v113+ (((unsigned __int16)v112 * v113) >> 16)+ 1) >> 16)) >> 16;
                v110 = v111 + ((HIWORD(v112) * v113 + ((HIWORD(v112) * v113) >> 16) + 1) >> 16);
              }
              *v37 = bswap32(v110) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 += v38;
          --v106;
        }
        while (v106);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        --v8;
      }
      while (v8);
      return result;
    case 7:
      v114 = v41 ^ 0xFFFF;
      if (v3)
      {
        v115 = 2 * v38;
        do
        {
          v116 = v377;
          do
          {
            v117 = *(unsigned __int8 *)v44;
            if (*(_BYTE *)v44)
            {
              if (v117 == 255)
              {
                v118 = bswap32(v42->u16[0]) >> 16;
                v119 = bswap32(*v37) >> 16;
                v120 = v114 * v118;
                v121 = v114 * v119;
              }
              else
              {
                v122 = v117 | (v117 << 8);
                v118 = bswap32(v42->u16[0]) >> 16;
                v119 = bswap32(*v37) >> 16;
                v123 = (unsigned __int16)(v122 - ((v41 * v122 + ((v41 * v122) >> 16) + 1) >> 16));
                v120 = v118 * v123;
                v121 = v119 * v123;
              }
              v42->i16[0] = bswap32(v118 - ((v120 + HIWORD(v120) + 1) >> 16)) >> 16;
              *v37 = bswap32(v119 - ((v121 + HIWORD(v121) + 1) >> 16)) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            v37 = (unsigned __int16 *)((char *)v37 + v115);
            --v116;
          }
          while (v116);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          v37 += v40;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v124 = v377;
          do
          {
            v125 = *(unsigned __int8 *)v44;
            if (*(_BYTE *)v44)
            {
              if (v125 == 255)
              {
                v126 = bswap32(v42->u16[0]) >> 16;
                v127 = v41 ^ 0xFFFF;
                v128 = v126;
              }
              else
              {
                v129 = v125 | (v125 << 8);
                v127 = bswap32(v42->u16[0]) >> 16;
                v126 = v129 - ((v41 * v129 + ((v41 * v129) >> 16) + 1) >> 16);
                v128 = v127;
              }
              v42->i16[0] = bswap32(v128- ((v127 * (unsigned __int16)v126 + ((v127 * (unsigned __int16)v126) >> 16) + 1) >> 16)) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            --v124;
          }
          while (v124);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          --v8;
        }
        while (v8);
      }
      return result;
    case 8:
      v130 = 257 * v41;
      if (v3)
      {
        v131 = 2 * v38;
        do
        {
          v132 = v377;
          do
          {
            v133 = *(unsigned __int8 *)v44;
            if (*(_BYTE *)v44)
            {
              v134 = bswap32(v42->u16[0]) >> 16;
              v135 = bswap32(*v37) >> 16;
              if (v133 == 255)
                v136 = v41;
              else
                v136 = (v130 * v133 + ((v130 * v133) >> 16) + 1) >> 16;
              v42->i16[0] = bswap32(v134 - ((v136 * v134 + ((v136 * v134) >> 16) + 1) >> 16)) >> 16;
              *v37 = bswap32(v135 - ((v136 * v135 + ((v136 * v135) >> 16) + 1) >> 16)) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            v37 = (unsigned __int16 *)((char *)v37 + v131);
            --v132;
          }
          while (v132);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          v37 += v40;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v137 = v377;
          do
          {
            v138 = *(unsigned __int8 *)v44;
            if (*(_BYTE *)v44)
            {
              v139 = bswap32(v42->u16[0]) >> 16;
              if (v138 == 255)
                v140 = v41;
              else
                v140 = (v130 * v138 + ((v130 * v138) >> 16) + 1) >> 16;
              v42->i16[0] = bswap32(v139 - ((v140 * v139 + ((v140 * v139) >> 16) + 1) >> 16)) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            --v137;
          }
          while (v137);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          --v8;
        }
        while (v8);
      }
      return result;
    case 9:
      v141 = 2 * v38;
      do
      {
        v142 = v377;
        do
        {
          if (*(_BYTE *)v44)
          {
            v143 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
            v144 = bswap32(~*v37) >> 16;
            v145 = bswap32(v42->u16[0]) >> 16;
            v146 = ~(*(unsigned __int8 *)v44 | (*(unsigned __int8 *)v44 << 8)) + HIWORD(v143);
            v42->i16[0] = bswap32((unsigned __int16)v143 * v144+ v146 * v145+ (((unsigned __int16)v143 * v144 + v146 * v145) >> 16)+ 1);
            *v37 = bswap32((v144 + v146) * HIWORD(v143) + (((v144 + v146) * HIWORD(v143)) >> 16) + 1);
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v141);
          --v142;
        }
        while (v142);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        --v8;
      }
      while (v8);
      return result;
    case 10:
      v147 = 2 * v38;
      do
      {
        v148 = v377;
        do
        {
          if (*(_BYTE *)v44)
          {
            v149 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
            v150 = bswap32(~*v37);
            v151 = bswap32(v42->u16[0]);
            v152 = HIWORD(v149) ^ 0xFFFF;
            v42->i16[0] = bswap32((unsigned __int16)v149 * HIWORD(v150)+ v152 * HIWORD(v151)+ (((unsigned __int16)v149 * HIWORD(v150) + v152 * HIWORD(v151)) >> 16)+ 1);
            *v37 = bswap32((v152 + HIWORD(v150)) * HIWORD(v149)+ (((v152 + HIWORD(v150)) * HIWORD(v149)) >> 16)+ 1);
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v147);
          --v148;
        }
        while (v148);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        --v8;
      }
      while (v8);
      return result;
    case 11:
      if (v3)
      {
        v153 = 2 * v38;
        do
        {
          v154 = v377;
          do
          {
            if (*(_BYTE *)v44)
            {
              v155 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
              v156 = bswap32(*v37);
              v157 = HIWORD(v155);
              v158 = HIWORD(v155) - ((bswap32(v42->u16[0]) >> 16) + (unsigned __int16)v155) + HIWORD(v156);
              v159 = v157 + HIWORD(v156);
              if (v158 >= 0xFFFF)
                v158 = 0xFFFF;
              if (v159 >= 0xFFFF)
                v159 = 0xFFFF;
              v42->i16[0] = bswap32(v159 - v158) >> 16;
              *v37 = bswap32(v159) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            v37 = (unsigned __int16 *)((char *)v37 + v153);
            --v154;
          }
          while (v154);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          v37 += v40;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v274 = v377;
          do
          {
            if (*(_BYTE *)v44)
            {
              v275 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
              v276 = HIWORD(v275) - (unsigned __int16)v275 + (bswap32(~v42->u16[0]) >> 16);
              if (v276 >= 0xFFFF)
                v276 = 0xFFFF;
              v42->i16[0] = bswap32(~v276) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            --v274;
          }
          while (v274);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          --v8;
        }
        while (v8);
      }
      return result;
    case 12:
      if (v3)
      {
        v160 = 2 * v38;
        do
        {
          v161 = v377;
          do
          {
            if (*(_BYTE *)v44)
            {
              v162 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
              v163 = HIWORD(v162);
              v164 = (bswap32(v42->u16[0]) >> 16) + (unsigned __int16)v162;
              v165 = v163 + (bswap32(*v37) >> 16);
              if (v164 >= 0xFFFF)
                v164 = 0xFFFF;
              if (v165 >= 0xFFFF)
                v165 = 0xFFFF;
              v42->i16[0] = bswap32(v164) >> 16;
              *v37 = bswap32(v165) >> 16;
            }
            ++v44;
            v42 = (int16x4_t *)((char *)v42 + 2);
            v37 = (unsigned __int16 *)((char *)v37 + v160);
            --v161;
          }
          while (v161);
          v44 += v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          v37 += v40;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v277 = 0;
          do
          {
            if (*(_BYTE *)(v44 + v277))
            {
              v278 = bswap32(v42->u16[0]);
              v42->i16[0] = bswap32((v278 >> 15) & 0xFFFE | ((v278 >> 16) >> 15)) >> 16;
            }
            v42 = (int16x4_t *)((char *)v42 + 2);
            ++v277;
          }
          while (v377 != (_DWORD)v277);
          v44 += (v377 - 1) + 1 + v45;
          v42 = (int16x4_t *)((char *)v42 + 2 * v46);
          --v8;
        }
        while (v8);
      }
      return result;
    case 13:
      v166 = 2 * v38;
      while (1)
      {
        v167 = v377;
        do
        {
          if (*(_BYTE *)v44)
          {
            v168 = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            if (v168 >= 0x10000)
            {
              v169 = v168 >> 16;
              if (v3)
              {
                if (*v37)
                {
                  v170 = __rev16(*v37);
                  goto LABEL_202;
                }
LABEL_210:
                v42->i16[0] = bswap32(v168) >> 16;
                v175 = (int16x4_t *)v37;
              }
              else
              {
                v170 = 0xFFFF;
LABEL_202:
                v171 = (v170 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v168
                     + ((v169 ^ 0xFFFF) + (unsigned __int16)v168)
                     * (unint64_t)(bswap32(v42->u16[0]) >> 16);
                if (v171 <= 0xFFFE8000)
                  v172 = v171 + 0x8000;
                else
                  v172 = 4294868992;
                v173 = v172 + (v172 >> 16);
                if (v3)
                {
                  v168 = v173 >> 16;
                  v174 = 0xFFFF * (v170 + v169) - v170 * (unint64_t)v169;
                  if (v174 <= 4294868992)
                    v169 = v174 + 0x8000;
                  else
                    v169 = 4294868992;
                  LODWORD(v168) = ((v169 >> 16) + v169) & 0xFFFF0000 | v168;
                  LODWORD(v169) = WORD1(v168);
                  goto LABEL_210;
                }
                v169 = v173 >> 16;
                v175 = v42;
              }
              v175->i16[0] = bswap32(v169) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v166);
          --v167;
        }
        while (v167);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        if (!--v8)
          return result;
      }
    case 14:
      v176 = 2 * v38;
      while (1)
      {
        v177 = v377;
        do
        {
          if (*(_BYTE *)v44)
          {
            v178 = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            if (v178 >= 0x10000)
            {
              v179 = v178 >> 16;
              if (v3)
              {
                if (*v37)
                {
                  v180 = __rev16(*v37);
                  goto LABEL_224;
                }
LABEL_232:
                v42->i16[0] = bswap32(v178) >> 16;
                v185 = (int16x4_t *)v37;
              }
              else
              {
                v180 = 0xFFFF;
LABEL_224:
                v181 = bswap32(v42->u16[0]) >> 16;
                v182 = (v181 ^ 0xFFFF)
                     * (unint64_t)(unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44)
                     - v181
                     + (v181 << 16);
                if (v182 <= 0xFFFE8000)
                  v183 = v182 + 0x8000;
                else
                  v183 = 4294868992;
                v178 = (v183 + (v183 >> 16)) >> 16;
                if (v3)
                {
                  v184 = 0xFFFF * (v179 + v180) - v179 * (unint64_t)v180;
                  if (v184 <= 4294868992)
                    v179 = v184 + 0x8000;
                  else
                    v179 = 4294868992;
                  LODWORD(v178) = ((v179 >> 16) + v179) & 0xFFFF0000 | v178;
                  LODWORD(v179) = WORD1(v178);
                  goto LABEL_232;
                }
                LODWORD(v179) = v178;
                v185 = v42;
              }
              v185->i16[0] = bswap32(v179) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v176);
          --v177;
        }
        while (v177);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        if (!--v8)
          return result;
      }
    case 15:
      v186 = 2 * v38;
      while (1)
      {
        v187 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v188 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v189 = __rev16(*v37);
                  goto LABEL_246;
                }
LABEL_248:
                v42->i16[0] = bswap32(result) >> 16;
                v190 = (int16x4_t *)v37;
              }
              else
              {
                v189 = 0xFFFF;
LABEL_246:
                result = PDAoverlayPDA_8071(bswap32(v42->u16[0]) >> 16, v189, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v188);
                if (v3)
                {
                  v188 = WORD1(result);
                  goto LABEL_248;
                }
                v188 = result;
                v190 = v42;
              }
              v190->i16[0] = bswap32(v188) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v186);
          --v187;
        }
        while (v187);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 16:
      v191 = 2 * v38;
      while (1)
      {
        v192 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v193 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v194 = __rev16(*v37);
                  goto LABEL_262;
                }
LABEL_264:
                v42->i16[0] = bswap32(result) >> 16;
                v195 = (int16x4_t *)v37;
              }
              else
              {
                v194 = 0xFFFF;
LABEL_262:
                result = PDAdarkenPDA_8073(bswap32(v42->u16[0]) >> 16, v194, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v193);
                if (v3)
                {
                  v193 = WORD1(result);
                  goto LABEL_264;
                }
                v193 = result;
                v195 = v42;
              }
              v195->i16[0] = bswap32(v193) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v191);
          --v192;
        }
        while (v192);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 17:
      v196 = 2 * v38;
      while (1)
      {
        v197 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v198 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v199 = __rev16(*v37);
                  goto LABEL_278;
                }
LABEL_280:
                v42->i16[0] = bswap32(result) >> 16;
                v200 = (int16x4_t *)v37;
              }
              else
              {
                v199 = 0xFFFF;
LABEL_278:
                result = PDAlightenPDA_8072(bswap32(v42->u16[0]) >> 16, v199, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v198);
                if (v3)
                {
                  v198 = WORD1(result);
                  goto LABEL_280;
                }
                v198 = result;
                v200 = v42;
              }
              v200->i16[0] = bswap32(v198) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v196);
          --v197;
        }
        while (v197);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 18:
      v201 = 2 * v38;
      while (1)
      {
        v202 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v203 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v204 = __rev16(*v37);
                  goto LABEL_294;
                }
LABEL_296:
                v42->i16[0] = bswap32(result) >> 16;
                v205 = (int16x4_t *)v37;
              }
              else
              {
                v204 = 0xFFFF;
LABEL_294:
                result = PDAcolordodgePDA_8074(bswap32(v42->u16[0]) >> 16, v204, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v203);
                if (v3)
                {
                  v203 = WORD1(result);
                  goto LABEL_296;
                }
                v203 = result;
                v205 = v42;
              }
              v205->i16[0] = bswap32(v203) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v201);
          --v202;
        }
        while (v202);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 19:
      v206 = 2 * v38;
      while (1)
      {
        v207 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v208 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v209 = __rev16(*v37);
                  goto LABEL_310;
                }
LABEL_312:
                v42->i16[0] = bswap32(result) >> 16;
                v210 = (int16x4_t *)v37;
              }
              else
              {
                v209 = 0xFFFF;
LABEL_310:
                result = PDAcolorburnPDA_8075(bswap32(v42->u16[0]) >> 16, v209, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v208);
                if (v3)
                {
                  v208 = WORD1(result);
                  goto LABEL_312;
                }
                v208 = result;
                v210 = v42;
              }
              v210->i16[0] = bswap32(v208) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v206);
          --v207;
        }
        while (v207);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 20:
      v211 = 2 * v38;
      while (1)
      {
        v212 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v213 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v214 = __rev16(*v37);
                  goto LABEL_326;
                }
LABEL_328:
                v42->i16[0] = bswap32(result) >> 16;
                v215 = (int16x4_t *)v37;
              }
              else
              {
                v214 = 0xFFFF;
LABEL_326:
                result = PDAsoftlightPDA_8077(bswap32(v42->u16[0]) >> 16, v214, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v213);
                if (v3)
                {
                  v213 = WORD1(result);
                  goto LABEL_328;
                }
                v213 = result;
                v215 = v42;
              }
              v215->i16[0] = bswap32(v213) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v211);
          --v212;
        }
        while (v212);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 21:
      v216 = 2 * v38;
      while (1)
      {
        v217 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v218 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v219 = __rev16(*v37);
                  goto LABEL_342;
                }
LABEL_344:
                v42->i16[0] = bswap32(result) >> 16;
                v220 = (int16x4_t *)v37;
              }
              else
              {
                v219 = 0xFFFF;
LABEL_342:
                result = PDAhardlightPDA_8076(bswap32(v42->u16[0]) >> 16, v219, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v218);
                if (v3)
                {
                  v218 = WORD1(result);
                  goto LABEL_344;
                }
                v218 = result;
                v220 = v42;
              }
              v220->i16[0] = bswap32(v218) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v216);
          --v217;
        }
        while (v217);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 22:
      v221 = 2 * v38;
      while (1)
      {
        v222 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v223 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v224 = __rev16(*v37);
                  goto LABEL_358;
                }
LABEL_360:
                v42->i16[0] = bswap32(result) >> 16;
                v225 = (int16x4_t *)v37;
              }
              else
              {
                v224 = 0xFFFF;
LABEL_358:
                result = PDAdifferencePDA_8078(bswap32(v42->u16[0]) >> 16, v224, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v223);
                if (v3)
                {
                  v223 = WORD1(result);
                  goto LABEL_360;
                }
                v223 = result;
                v225 = v42;
              }
              v225->i16[0] = bswap32(v223) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v221);
          --v222;
        }
        while (v222);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 23:
      v226 = 2 * v38;
      while (1)
      {
        v227 = v377;
        do
        {
          if (*(_BYTE *)v44)
          {
            v228 = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v229 = v228 >> 16;
            if (HIWORD(*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44)))
            {
              if (v3)
              {
                if (*v37)
                {
                  v230 = __rev16(*v37);
                  goto LABEL_374;
                }
LABEL_388:
                v42->i16[0] = bswap32(v228) >> 16;
                v237 = (int16x4_t *)v37;
              }
              else
              {
                v230 = 0xFFFF;
LABEL_374:
                LODWORD(v231) = bswap32(v42->u16[0]) >> 16;
                if ((unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44) >= v229)
                  v232 = v229;
                else
                  v232 = (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44);
                if (v231 >= v230)
                  v231 = v230;
                else
                  v231 = v231;
                v233 = 0xFFFF * (v231 + v232) - 2 * v232 * (unint64_t)v231;
                if (v233 <= 4294868992)
                  v234 = v233 + 0x8000;
                else
                  v234 = 4294868992;
                v235 = v234 + (v234 >> 16);
                if (v3)
                {
                  v228 = v235 >> 16;
                  v236 = 0xFFFF * (v229 + v230) - v229 * (unint64_t)v230;
                  if (v236 <= 4294868992)
                    v229 = v236 + 0x8000;
                  else
                    v229 = 4294868992;
                  LODWORD(v228) = ((v229 >> 16) + v229) & 0xFFFF0000 | v228;
                  LODWORD(v229) = WORD1(v228);
                  goto LABEL_388;
                }
                v229 = v235 >> 16;
                v237 = v42;
              }
              v237->i16[0] = bswap32(v229) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v226);
          --v227;
        }
        while (v227);
        v44 += v45;
        v42 = (int16x4_t *)((char *)v42 + 2 * v46);
        v37 += v40;
        if (!--v8)
          return result;
      }
    case 24:
      v238 = 2 * v38;
      while (1)
      {
        v239 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v240 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v241 = __rev16(*v37);
                  goto LABEL_402;
                }
LABEL_404:
                v42->i16[0] = bswap32(result) >> 16;
                v242 = (int16x4_t *)v37;
              }
              else
              {
                v241 = 0xFFFF;
LABEL_402:
                result = PDAhuePDA_8079(bswap32(v42->u16[0]) >> 16, v241, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v240);
                if (v3)
                {
                  v240 = WORD1(result);
                  goto LABEL_404;
                }
                v240 = result;
                v242 = v42;
              }
              v242->i16[0] = bswap32(v240) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v238);
          --v239;
        }
        while (v239);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 25:
      v243 = 2 * v38;
      while (1)
      {
        v244 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v245 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v246 = __rev16(*v37);
                  goto LABEL_418;
                }
LABEL_420:
                v42->i16[0] = bswap32(result) >> 16;
                v247 = (int16x4_t *)v37;
              }
              else
              {
                v246 = 0xFFFF;
LABEL_418:
                result = PDAhuePDA_8079(bswap32(v42->u16[0]) >> 16, v246, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v245);
                if (v3)
                {
                  v245 = WORD1(result);
                  goto LABEL_420;
                }
                v245 = result;
                v247 = v42;
              }
              v247->i16[0] = bswap32(v245) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v243);
          --v244;
        }
        while (v244);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 26:
      v248 = 2 * v38;
      while (1)
      {
        v249 = v31;
        do
        {
          if (*(_BYTE *)v44)
          {
            result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
            v250 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  v251 = __rev16(*v37);
                  goto LABEL_434;
                }
LABEL_436:
                v42->i16[0] = bswap32(result) >> 16;
                v252 = (int16x4_t *)v37;
              }
              else
              {
                v251 = 0xFFFF;
LABEL_434:
                result = PDAluminosityPDA_8081((unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v250, bswap32(v42->u16[0]) >> 16, v251);
                if (v3)
                {
                  v250 = WORD1(result);
                  goto LABEL_436;
                }
                v250 = result;
                v252 = v42;
              }
              v252->i16[0] = bswap32(v250) >> 16;
            }
          }
          ++v44;
          v42 = (int16x4_t *)((char *)v42 + 2);
          v37 = (unsigned __int16 *)((char *)v37 + v248);
          --v249;
        }
        while (v249);
        v44 += v374;
        v31 = v377;
        v42 = (int16x4_t *)((char *)v42 + 2 * v376);
        v37 += v47;
        if (!--v8)
          return result;
      }
    case 27:
      v253 = 2 * v38;
      break;
    default:
      return result;
  }
  do
  {
    v254 = v31;
    do
    {
      if (*(_BYTE *)v44)
      {
        result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v44);
        v255 = WORD1(result);
        if (WORD1(result))
        {
          if (v3)
          {
            if (*v37)
            {
              v256 = __rev16(*v37);
              goto LABEL_450;
            }
LABEL_452:
            v42->i16[0] = bswap32(result) >> 16;
            v257 = (int16x4_t *)v37;
          }
          else
          {
            v256 = 0xFFFF;
LABEL_450:
            result = PDAluminosityPDA_8081(bswap32(v42->u16[0]) >> 16, v256, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v44), v255);
            if (v3)
            {
              v255 = WORD1(result);
              goto LABEL_452;
            }
            v255 = result;
            v257 = v42;
          }
          v257->i16[0] = bswap32(v255) >> 16;
        }
      }
      ++v44;
      v42 = (int16x4_t *)((char *)v42 + 2);
      v37 = (unsigned __int16 *)((char *)v37 + v253);
      --v254;
    }
    while (v254);
    v44 += v374;
    v31 = v377;
    v42 = (int16x4_t *)((char *)v42 + 2 * v376);
    v37 += v47;
    --v8;
  }
  while (v8);
  return result;
}

unint64_t W16_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int16 *v44;
  int v45;
  int v46;
  unsigned __int16 v47;
  unsigned int v48;
  unsigned int v49;
  char *v50;
  unsigned __int16 *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned __int16 *v60;
  uint64_t v61;
  int v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned __int16 *v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned __int16 *v88;
  uint64_t v89;
  int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  int v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  char *v101;
  unsigned __int16 *v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unsigned __int16 *v112;
  uint64_t v113;
  int v114;
  int v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  char *v125;
  unsigned __int16 *v126;
  char *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  unsigned __int16 *v136;
  uint64_t v137;
  int v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  char *v146;
  unsigned __int16 *v147;
  char *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  unsigned __int16 *v157;
  int v158;
  int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  unsigned int v163;
  int v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  char *v168;
  unsigned __int16 *v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unsigned __int16 *v179;
  uint64_t v180;
  int v181;
  int v182;
  unsigned int v183;
  unsigned int v184;
  unsigned int v185;
  unsigned int v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v190;
  char *v191;
  unsigned __int16 *v192;
  char *v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unsigned __int16 *v201;
  uint64_t v202;
  int v203;
  int v204;
  unsigned int v205;
  unsigned int v206;
  unsigned int v207;
  unsigned int v208;
  char *v209;
  unsigned __int16 *v210;
  char *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  unsigned __int16 *v219;
  int v220;
  unsigned int v221;
  unsigned int v222;
  unsigned __int16 v223;
  int v224;
  unsigned int v225;
  unsigned int v226;
  unsigned int v227;
  unsigned int v228;
  unsigned int v229;
  unsigned __int16 *v230;
  uint64_t v231;
  char *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  unsigned __int16 *v241;
  uint64_t v242;
  int v243;
  unsigned int v244;
  unsigned int v245;
  int v246;
  unsigned int v247;
  unsigned int v248;
  unsigned int v249;
  unsigned int v250;
  char *v251;
  unsigned __int16 *v252;
  char *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  unsigned __int16 *v262;
  uint64_t v263;
  int v264;
  unsigned int v265;
  unsigned int v266;
  int v267;
  unsigned int v268;
  unsigned int v269;
  unsigned int v270;
  int v271;
  unsigned int v272;
  unsigned __int16 *v273;
  uint64_t v274;
  char *v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unsigned __int16 *v282;
  uint64_t v283;
  int v284;
  unsigned int v285;
  unsigned int v286;
  int v287;
  unsigned int v288;
  unsigned int v289;
  unsigned int v290;
  unsigned int v291;
  unsigned __int16 *v292;
  uint64_t v293;
  char *v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  unsigned __int16 *v305;
  int v306;
  unsigned int v307;
  unsigned int v308;
  int v309;
  unsigned int v310;
  unsigned int v311;
  unint64_t v312;
  unsigned int v313;
  unint64_t v314;
  unint64_t v315;
  unint64_t v316;
  unint64_t v317;
  int64_t v318;
  char *v319;
  unsigned __int16 *v320;
  uint64_t v321;
  char *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unsigned __int16 *v331;
  int v332;
  unsigned int v333;
  unsigned int v334;
  int v335;
  unsigned int v336;
  unsigned int v337;
  unsigned int v338;
  unsigned int v339;
  uint64_t v340;
  unint64_t v341;
  unint64_t v342;
  unint64_t v343;
  int64_t v344;
  unint64_t v345;
  char *v346;
  unsigned __int16 *v347;
  uint64_t v348;
  char *v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  unsigned __int16 *v357;
  uint64_t v358;
  unsigned int v359;
  unsigned int v360;
  int v361;
  unsigned int v362;
  unsigned int v363;
  unsigned int v364;
  char *v365;
  char *v366;
  uint64_t v367;
  char *v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  unsigned __int16 *v375;
  uint64_t v376;
  unsigned int v377;
  unsigned int v378;
  int v379;
  unsigned int v380;
  unsigned int v381;
  unsigned int v382;
  char *v383;
  char *v384;
  uint64_t v385;
  char *v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  unsigned __int16 *v393;
  uint64_t v394;
  unsigned int v395;
  unsigned int v396;
  int v397;
  unsigned int v398;
  unsigned int v399;
  unsigned int v400;
  char *v401;
  char *v402;
  uint64_t v403;
  char *v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  unsigned __int16 *v411;
  uint64_t v412;
  unsigned int v413;
  unsigned int v414;
  int v415;
  unsigned int v416;
  unsigned int v417;
  unsigned int v418;
  char *v419;
  char *v420;
  uint64_t v421;
  char *v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  unsigned __int16 *v429;
  uint64_t v430;
  unsigned int v431;
  unsigned int v432;
  int v433;
  unsigned int v434;
  unsigned int v435;
  unsigned int v436;
  char *v437;
  char *v438;
  uint64_t v439;
  char *v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  unsigned __int16 *v447;
  uint64_t v448;
  unsigned int v449;
  unsigned int v450;
  int v451;
  unsigned int v452;
  unsigned int v453;
  unsigned int v454;
  char *v455;
  char *v456;
  uint64_t v457;
  char *v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  unsigned __int16 *v465;
  uint64_t v466;
  unsigned int v467;
  unsigned int v468;
  int v469;
  unsigned int v470;
  unsigned int v471;
  unsigned int v472;
  char *v473;
  char *v474;
  uint64_t v475;
  char *v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  unsigned __int16 *v483;
  uint64_t v484;
  unsigned int v485;
  unsigned int v486;
  int v487;
  unsigned int v488;
  unsigned int v489;
  unsigned int v490;
  char *v491;
  char *v492;
  uint64_t v493;
  char *v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  unsigned __int16 *v504;
  int v505;
  unsigned int v506;
  unsigned int v507;
  int v508;
  unsigned int v509;
  unsigned int v510;
  unint64_t v511;
  unsigned int v512;
  unsigned int v513;
  uint64_t v514;
  uint64_t v515;
  int64_t v516;
  unint64_t v517;
  unint64_t v518;
  unint64_t v519;
  int64_t v520;
  char *v521;
  unsigned __int16 *v522;
  uint64_t v523;
  char *v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  unsigned __int16 *v532;
  uint64_t v533;
  unsigned int v534;
  unsigned int v535;
  int v536;
  unsigned int v537;
  unsigned int v538;
  unsigned int v539;
  char *v540;
  char *v541;
  uint64_t v542;
  char *v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  uint64_t v549;
  unsigned __int16 *v550;
  uint64_t v551;
  unsigned int v552;
  unsigned int v553;
  int v554;
  unsigned int v555;
  unsigned int v556;
  unsigned int v557;
  char *v558;
  char *v559;
  uint64_t v560;
  char *v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  unsigned __int16 *v568;
  uint64_t v569;
  unsigned int v570;
  unsigned int v571;
  int v572;
  unsigned int v573;
  unsigned int v574;
  unsigned int v575;
  char *v576;
  char *v577;
  uint64_t v578;
  char *v579;
  uint64_t v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  unsigned __int16 *v586;
  uint64_t v587;
  unsigned int v588;
  unsigned int v589;
  int v590;
  unsigned int v591;
  unsigned int v592;
  unsigned int v593;
  char *v594;
  char *v595;
  uint64_t v596;
  char *v597;
  uint64_t v598;
  uint64_t v599;
  int v600;
  int v601;
  unsigned int v602;
  unsigned int v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  int v608;
  int v609;
  __int16 v610;
  int v611;
  unsigned int v612;
  unsigned int v613;
  char *v614;
  uint64_t v615;
  char *v616;
  char *v617;
  uint64_t v618;
  char *v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  unsigned __int16 *v625;
  int v626;
  int v627;
  unsigned int v628;
  unsigned int v629;
  unsigned int v630;
  unsigned int v631;
  int v632;
  unsigned int v633;
  unsigned int v634;
  unsigned int v635;
  unsigned int v636;
  unsigned int v637;
  unsigned int v638;
  char *v639;
  unsigned __int16 *v640;
  char *v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  unsigned __int16 *v649;
  int v650;
  int v651;
  unsigned int v652;
  unsigned int v653;
  unsigned int v654;
  int v655;
  unsigned int v656;
  unsigned int v657;
  char *v658;
  unsigned __int16 *v659;
  uint64_t v660;
  char *v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  unsigned __int16 *v668;
  int v669;
  int v670;
  unsigned int v671;
  unsigned int v672;
  char *v673;
  unsigned __int16 *v674;
  uint64_t v675;
  char *v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  unsigned __int16 *v683;
  int v684;
  unsigned int v685;
  unsigned int v686;
  int v687;
  unsigned int v688;
  signed int v689;
  char *v690;
  unsigned __int16 *v691;
  char *v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  int v696;
  _BYTE *v697;
  int v698;
  uint64_t v699;
  uint64_t v700;
  int v701;
  int v702;
  __int16 v703;
  int v704;
  unsigned int v705;
  unsigned int v706;
  char *v707;
  uint64_t v708;
  char *v709;
  uint64_t v710;
  char *v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  uint64_t v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  int v749;
  int v750;
  int v751;
  int v752;
  int v753;
  int v754;
  int v755;
  int v756;
  int v757;
  int v758;
  int v759;
  int v760;
  int v761;
  unint64_t v762;
  unint64_t v763;
  unint64_t v764;
  uint64_t v765;
  unint64_t v766;
  unint64_t v767;
  char *v768;
  unsigned __int16 *v769;
  unint64_t v770;
  unint64_t v771;
  unint64_t v772;
  unint64_t v773;
  unint64_t v774;
  unint64_t v775;
  unint64_t v776;
  unint64_t v777;
  unint64_t v778;
  unint64_t v779;
  unint64_t v780;
  unint64_t v781;
  int v782;
  int v783;

  v2 = *(_QWORD *)(result + 48);
  v3 = *(_QWORD *)(result + 136);
  v5 = *(int *)(result + 12);
  v4 = *(int *)(result + 16);
  if (v2)
  {
    v6 = (unint64_t)*(int *)(result + 32) >> 1;
    v7 = (char *)(v2 + 2 * (v5 + v6 * v4));
    v8 = -1;
    if (!v3)
      return result;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return result;
  }
  v10 = *(_DWORD *)(result + 4);
  v9 = *(_DWORD *)(result + 8);
  v12 = *(_QWORD *)(result + 88);
  v11 = *(_QWORD *)(result + 96);
  v13 = (unint64_t)*(int *)(result + 28) >> 1;
  v14 = (char *)(*(_QWORD *)(result + 40) + 2 * (v5 + v13 * v4));
  v15 = *(int *)(result + 124);
  v16 = (_BYTE *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(result + 56);
  v18 = *(int *)(result + 60);
  v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    v21 = *(_DWORD *)(result + 64);
    v22 = *(_DWORD *)(result + 68);
    v767 = v19 >> 1;
    v769 = *(unsigned __int16 **)(result + 96);
    if (v11)
    {
      v766 = (unint64_t)*(int *)(result + 80) >> 1;
      v20 = 1;
    }
    else
    {
      v766 = 0;
      v20 = 0;
    }
    v26 = v12 + 2 * v767 * v22;
    v8 &= 1u;
    v25 = 1;
    v768 = *(char **)(result + 88);
    v23 = v768;
    goto LABEL_19;
  }
  v767 = v19 >> 1;
  if (v11)
  {
    v766 = (unint64_t)*(int *)(result + 80) >> 1;
    v769 = (unsigned __int16 *)(v11 + 2 * (v17 + v766 * v18));
    v20 = -1;
  }
  else
  {
    v769 = 0;
    v766 = 0;
    v20 = 0;
  }
  v23 = (char *)(v12 + 2 * (v17 + v767 * v18));
  if (v767 == v13 && v14 - v23 >= 1)
  {
    if (v10 >= (uint64_t)((unint64_t)(v14 - v23) >> 1))
    {
      v14 += 2 * v10 - 2;
      v23 += 2 * v10 - 2;
      v16 += v10 - 1;
      v7 += 2 * (v8 & (v10 - 1));
      v25 = -1;
      v767 = (unint64_t)*(int *)(result + 28) >> 1;
      v769 += v20 & (v10 - 1);
      goto LABEL_16;
    }
    v24 = v9 - 1;
    if (v14 <= &v23[2 * v13 * v24 - 2 + 2 * v10])
    {
      v14 += 2 * v13 * v24;
      v16 += v15 * v24;
      v15 = -v15;
      v7 += 2 * v6 * v24;
      v6 = -(uint64_t)v6;
      v8 &= 1u;
      v769 += v766 * v24;
      v766 = -(uint64_t)v766;
      v767 = -(uint64_t)v13;
      v20 &= 1u;
      v25 = 1;
      v23 += 2 * v13 * v24;
      v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  v25 = 1;
LABEL_16:
  v26 = 0;
  v768 = 0;
  v12 = -1;
  v22 = v766;
  v21 = v767;
LABEL_19:
  v27 = v25 * v10;
  v763 = v26;
  if (v26)
  {
    v28 = (int)v18 % v22;
    v29 = &v23[2 * v767 * v28];
    result = (int)v17 % v21;
    v23 = &v29[2 * result];
    v12 = (unint64_t)&v29[2 * v21];
    v30 = v766 * v28;
    v31 = (uint64_t)v769;
    v32 = (uint64_t)&v769[v30 + result];
    if ((v20 & 1) != 0)
      v31 = v32;
    v768 = &v29[2 * result];
    v769 = (unsigned __int16 *)v31;
  }
  else
  {
    v767 -= v27;
    v766 -= v20 * v10;
  }
  v765 = v15 - v27;
  v764 = v13 - v27;
  v762 = v6 - v8 * v10;
  v749 = v10;
  v782 = v8;
  v783 = v20;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          v33 = v10;
          do
          {
            v34 = *v16;
            if (*v16)
            {
              if (v34 == 255)
              {
                LOWORD(v35) = 0;
                *(_WORD *)v14 = 0;
              }
              else
              {
                v36 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v37 = bswap32(*(unsigned __int16 *)v7) >> 16;
                v38 = v34 | (v34 << 8);
                *(_WORD *)v14 = bswap32(v36 - ((v38 * v36 + ((v38 * v36) >> 16) + 1) >> 16)) >> 16;
                v35 = bswap32(v37 - ((v38 * v37 + ((v38 * v37) >> 16) + 1) >> 16)) >> 16;
              }
              *(_WORD *)v7 = v35;
            }
            v16 += v25;
            v7 += 2 * v8;
            v14 += 2 * v25;
            --v33;
          }
          while (v33);
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v600 = v10;
          do
          {
            v601 = *v16;
            if (*v16)
            {
              if (v601 == 255)
              {
                LOWORD(v602) = 0;
              }
              else
              {
                v603 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v602 = bswap32(v603 - ((257 * v601 * v603 + ((257 * v601 * v603) >> 16) + 1) >> 16)) >> 16;
              }
              *(_WORD *)v14 = v602;
            }
            v16 += v25;
            v14 += 2 * v25;
            --v600;
          }
          while (v600);
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 1:
      if (v8)
      {
        v39 = v25;
        if (v20)
        {
          v40 = -(uint64_t)v21;
          v41 = v22;
          v42 = -(uint64_t)(v767 * v22);
          v43 = -(uint64_t)(v766 * v41);
          v44 = v769;
          do
          {
            v45 = v10;
            do
            {
              v46 = *v16;
              if (*v16)
              {
                if (v46 == 255)
                {
                  *(_WORD *)v14 = *(_WORD *)v23;
                  v47 = *v44;
                }
                else
                {
                  v48 = bswap32(*v44);
                  v49 = (bswap32(*(unsigned __int16 *)v23) >> 16) * (v46 | (v46 << 8))
                      + (bswap32(*(unsigned __int16 *)v14) >> 16) * ((v46 | (v46 << 8)) ^ 0xFFFF);
                  *(_WORD *)v14 = bswap32(v49 + HIWORD(v49) + 1);
                  v47 = bswap32(0xFFFF * HIWORD(v48) + ((0xFFFF * HIWORD(v48)) >> 16) + 1);
                }
                *(_WORD *)v7 = v47;
              }
              v16 += v39;
              v50 = &v23[2 * v39];
              v51 = &v44[v20];
              if ((unint64_t)v50 >= v12)
                result = v40;
              else
                result = 0;
              v44 = &v51[result];
              v23 = &v50[2 * result];
              v7 += 2 * v8;
              v14 += 2 * v39;
              --v45;
            }
            while (v45);
            if (v763)
            {
              result = v767;
              v52 = &v768[2 * v767];
              if ((unint64_t)v52 >= v763)
                v53 = v43;
              else
                v53 = 0;
              v54 = (uint64_t)&v769[v766 + v53];
              if ((unint64_t)v52 >= v763)
                v55 = v42;
              else
                v55 = 0;
              v23 = &v52[2 * v55];
              v12 += 2 * v55 + 2 * v767;
              v768 = v23;
              v769 += v766 + v53;
              v44 = (unsigned __int16 *)v54;
            }
            else
            {
              v23 += 2 * v767;
              v44 += v766;
            }
            v16 += v765;
            v14 += 2 * v764;
            v7 += 2 * v762;
            --v9;
          }
          while (v9);
        }
        else
        {
          v699 = -(uint64_t)v21;
          v700 = -(uint64_t)(v767 * v22);
          do
          {
            v701 = v10;
            do
            {
              v702 = *v16;
              if (*v16)
              {
                if (v702 == 255)
                {
                  v703 = *(_WORD *)v23;
                }
                else
                {
                  v704 = v702 | (v702 << 8);
                  v705 = bswap32(*(unsigned __int16 *)v14) >> 16;
                  v706 = (bswap32(*(unsigned __int16 *)v23) >> 16) * v704;
                  v703 = bswap32(v706 + v705 * (v704 ^ 0xFFFF) + ((v706 + v705 * (v704 ^ 0xFFFF)) >> 16) + 1);
                }
                *(_WORD *)v14 = v703;
                *(_WORD *)v7 = -1;
              }
              v16 += v39;
              v707 = &v23[2 * v39];
              if ((unint64_t)v707 >= v12)
                v708 = v699;
              else
                v708 = 0;
              v23 = &v707[2 * v708];
              v7 += 2 * v8;
              v14 += 2 * v39;
              --v701;
            }
            while (v701);
            v16 += v765;
            v14 += 2 * v764;
            v7 += 2 * v762;
            result = (unint64_t)v768;
            v709 = &v768[2 * v767];
            if ((unint64_t)v709 >= v763)
              v710 = v700;
            else
              v710 = 0;
            v711 = &v709[2 * v710];
            v712 = v12 + 2 * v710 + 2 * v767;
            if (v763)
            {
              v12 = v712;
              result = (unint64_t)v711;
            }
            v768 = (char *)result;
            if (v763)
              v23 = v711;
            else
              v23 += 2 * v767;
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        v604 = v25;
        v605 = -(uint64_t)v21;
        v606 = -(uint64_t)(v767 * v22);
        v607 = 2 * v25;
        do
        {
          v608 = v10;
          do
          {
            v609 = *v16;
            if (*v16)
            {
              if (v609 == 255)
              {
                v610 = *(_WORD *)v23;
              }
              else
              {
                v611 = v609 | (v609 << 8);
                v612 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v613 = (bswap32(*(unsigned __int16 *)v23) >> 16) * v611;
                v610 = bswap32(v613 + v612 * (v611 ^ 0xFFFF) + ((v613 + v612 * (v611 ^ 0xFFFF)) >> 16) + 1);
              }
              *(_WORD *)v14 = v610;
            }
            v16 += v604;
            v614 = &v23[2 * v604];
            if ((unint64_t)v614 >= v12)
              v615 = v605;
            else
              v615 = 0;
            v23 = &v614[2 * v615];
            v14 += v607;
            --v608;
          }
          while (v608);
          v16 += v765;
          v14 += 2 * v764;
          v616 = v768;
          v617 = &v768[2 * v767];
          if ((unint64_t)v617 >= v763)
            v618 = v606;
          else
            v618 = 0;
          v619 = &v617[2 * v618];
          v620 = v12 + 2 * v618 + 2 * v767;
          if (v763)
          {
            v12 = v620;
            v616 = v619;
          }
          v768 = v616;
          if (v763)
            v23 = v619;
          else
            v23 += 2 * v767;
          --v9;
        }
        while (v9);
      }
      return result;
    case 2:
      v56 = v25;
      if (v8)
      {
        v57 = v22;
        v58 = -(uint64_t)(v767 * v22);
        v59 = -(uint64_t)(v766 * v57);
        v60 = v769;
        v61 = -(uint64_t)v21;
        while (1)
        {
          v62 = v10;
          do
          {
            v63 = *v16;
            if (!*v16)
              goto LABEL_74;
            if (v63 != 255)
            {
              v66 = bswap32(*(unsigned __int16 *)v23) >> 16;
              v67 = bswap32(*v60);
              v68 = (v63 | (v63 << 8)) ^ 0xFFFF;
              v69 = v66 - ((v68 * v66 + ((v68 * v66) >> 16) + 1) >> 16);
              v70 = v69 | ((HIWORD(v67) - ((v68 * HIWORD(v67) + ((v68 * HIWORD(v67)) >> 16) + 1) >> 16)) << 16);
              if (!HIWORD(v70))
                goto LABEL_74;
              v71 = bswap32(*(unsigned __int16 *)v14);
              v72 = bswap32(*(unsigned __int16 *)v7) >> 16;
              v73 = HIWORD(v70) ^ 0xFFFF;
              *(_WORD *)v14 = bswap32(v69 + ((v73 * HIWORD(v71) + ((v73 * HIWORD(v71)) >> 16) + 1) >> 16)) >> 16;
              v74 = ((v73 * v72 + ((v73 * v72) >> 16) + 1) >> 16) + HIWORD(v70);
              goto LABEL_72;
            }
            v64 = *v60;
            v65 = __rev16(v64);
            if (!v65)
              goto LABEL_74;
            if (v65 != 0xFFFF)
            {
              v75 = bswap32(*(unsigned __int16 *)v14);
              v76 = bswap32(*(unsigned __int16 *)v7);
              *(_WORD *)v14 = bswap32((bswap32(*(unsigned __int16 *)v23) >> 16)+ ((HIWORD(v75) * (v65 ^ 0xFFFF) + ((HIWORD(v75) * (v65 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
              v74 = v65 + ((HIWORD(v76) * (v65 ^ 0xFFFF) + ((HIWORD(v76) * (v65 ^ 0xFFFF)) >> 16) + 1) >> 16);
LABEL_72:
              v64 = bswap32(v74) >> 16;
              goto LABEL_73;
            }
            *(_WORD *)v14 = *(_WORD *)v23;
LABEL_73:
            *(_WORD *)v7 = v64;
LABEL_74:
            v16 += v25;
            result = (unint64_t)&v23[2 * v25];
            v77 = &v60[v20];
            if (result >= v12)
              v78 = v61;
            else
              v78 = 0;
            v60 = &v77[v78];
            v23 = (char *)(result + 2 * v78);
            v7 += 2 * v8;
            v14 += 2 * v25;
            --v62;
          }
          while (v62);
          if (v763)
          {
            v79 = &v768[2 * v767];
            if ((unint64_t)v79 >= v763)
              v80 = v59;
            else
              v80 = 0;
            v81 = (uint64_t)&v769[v766 + v80];
            if ((unint64_t)v79 >= v763)
              v82 = v58;
            else
              v82 = 0;
            result = v12 + 2 * v82;
            v23 = &v79[2 * v82];
            v12 = result + 2 * v767;
            v768 = v23;
            v769 = (unsigned __int16 *)v81;
            v60 = (unsigned __int16 *)v81;
          }
          else
          {
            v23 += 2 * v767;
            v60 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          if (!--v9)
            return result;
        }
      }
      v621 = -(uint64_t)v21;
      v622 = v22;
      v623 = -(uint64_t)(v767 * v22);
      v624 = -(uint64_t)(v766 * v622);
      v625 = v769;
LABEL_827:
      v626 = v10;
      while (1)
      {
        v627 = *v16;
        if (*v16)
        {
          if (v627 == 255)
          {
            v628 = bswap32(*v625) >> 16;
            if (v628)
            {
              if (v628 == 0xFFFF)
              {
                LOWORD(v629) = *(_WORD *)v23;
              }
              else
              {
                v638 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v637 = (bswap32(*(unsigned __int16 *)v23) >> 16)
                     + ((v638 * (v628 ^ 0xFFFF) + ((v638 * (v628 ^ 0xFFFF)) >> 16) + 1) >> 16);
LABEL_836:
                v629 = bswap32(v637) >> 16;
              }
              *(_WORD *)v14 = v629;
            }
          }
          else
          {
            v630 = bswap32(*(unsigned __int16 *)v23);
            v631 = bswap32(*v625) >> 16;
            v632 = (v627 | (v627 << 8)) ^ 0xFFFF;
            v633 = v632 * v631 + ((v632 * v631) >> 16) + 1;
            v634 = HIWORD(v630) - ((v632 * HIWORD(v630) + ((v632 * HIWORD(v630)) >> 16) + 1) >> 16);
            v635 = v634 | ((v631 - HIWORD(v633)) << 16);
            if (v635 >= 0x10000)
            {
              v636 = bswap32(*(unsigned __int16 *)v14) >> 16;
              v637 = v634 + (((~v635 >> 16) * v636 + (((~v635 >> 16) * v636) >> 16) + 1) >> 16);
              goto LABEL_836;
            }
          }
        }
        v16 += v56;
        v639 = &v23[2 * v56];
        v640 = &v625[v20];
        if ((unint64_t)v639 >= v12)
          result = v621;
        else
          result = 0;
        v625 = &v640[result];
        v23 = &v639[2 * result];
        v14 += 2 * v56;
        if (!--v626)
        {
          if (v763)
          {
            result = v767;
            v641 = &v768[2 * v767];
            if ((unint64_t)v641 >= v763)
              v642 = v624;
            else
              v642 = 0;
            v643 = (uint64_t)&v769[v766 + v642];
            if ((unint64_t)v641 >= v763)
              v644 = v623;
            else
              v644 = 0;
            v23 = &v641[2 * v644];
            v12 += 2 * v644 + 2 * v767;
            v768 = v23;
            v769 += v766 + v642;
            v625 = (unsigned __int16 *)v643;
          }
          else
          {
            v23 += 2 * v767;
            v625 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          if (!--v9)
            return result;
          goto LABEL_827;
        }
      }
    case 3:
      v83 = v25;
      v84 = v22;
      v85 = -(uint64_t)(v767 * v22);
      v86 = -(uint64_t)(v766 * v84);
      v87 = 2 * v25;
      v88 = v769;
      v89 = -(uint64_t)v21;
      do
      {
        v90 = v10;
        do
        {
          v91 = *v16;
          if (*v16)
          {
            if (v91 == 255)
            {
              if (v20)
                v92 = bswap32(*v88) >> 16;
              else
                v92 = 0xFFFF;
              v94 = bswap32(*(unsigned __int16 *)v23) >> 16;
              v95 = bswap32(~*(unsigned __int16 *)v7) >> 16;
              *(_WORD *)v14 = bswap32(v94 - ((v95 * v94 + ((v95 * v94) >> 16) + 1) >> 16)) >> 16;
              v96 = v92 - ((v95 * v92 + ((v95 * v92) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20)
                v93 = bswap32(*v88) >> 16;
              else
                v93 = 0xFFFF;
              v97 = v91 | (v91 << 8);
              v98 = bswap32(*(unsigned __int16 *)v7);
              v99 = HIWORD(v98) * v97 + ((HIWORD(v98) * v97) >> 16) + 1;
              v97 ^= 0xFFFFu;
              v100 = HIWORD(v99) * (bswap32(*(unsigned __int16 *)v23) >> 16)
                   + (bswap32(*(unsigned __int16 *)v14) >> 16) * v97;
              v96 = ((v97 + HIWORD(v99)) * v93 + (((v97 + HIWORD(v99)) * v93) >> 16) + 1) >> 16;
              *(_WORD *)v14 = bswap32(v100 + HIWORD(v100) + 1);
            }
            *(_WORD *)v7 = bswap32(v96) >> 16;
          }
          v16 += v83;
          v101 = &v23[2 * v83];
          v102 = &v88[v20];
          if ((unint64_t)v101 >= v12)
            result = v89;
          else
            result = 0;
          v88 = &v102[result];
          v23 = &v101[2 * result];
          v7 += 2 * v8;
          v14 += v87;
          --v90;
        }
        while (v90);
        if (v763)
        {
          result = v767;
          v103 = &v768[2 * v767];
          if ((unint64_t)v103 >= v763)
            v104 = v86;
          else
            v104 = 0;
          v105 = (uint64_t)&v769[v766 + v104];
          if ((unint64_t)v103 >= v763)
            v106 = v85;
          else
            v106 = 0;
          v23 = &v103[2 * v106];
          v12 += 2 * v106 + 2 * v767;
          v768 = v23;
          v769 += v766 + v104;
          v88 = (unsigned __int16 *)v105;
        }
        else
        {
          v23 += 2 * v767;
          v88 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 4:
      v107 = v25;
      v108 = v22;
      v109 = -(uint64_t)(v767 * v22);
      v110 = -(uint64_t)(v766 * v108);
      v111 = 2 * v25;
      v112 = v769;
      v113 = -(uint64_t)v21;
      do
      {
        v114 = v10;
        do
        {
          v115 = *v16;
          if (*v16)
          {
            if (v115 == 255)
            {
              if (v20)
                v116 = bswap32(*v112) >> 16;
              else
                v116 = 0xFFFF;
              v118 = bswap32(*(unsigned __int16 *)v23) >> 16;
              v119 = bswap32(*(unsigned __int16 *)v7) >> 16;
              *(_WORD *)v14 = bswap32(v118 - ((v119 * v118 + ((v119 * v118) >> 16) + 1) >> 16)) >> 16;
              v120 = v116 - ((v119 * v116 + ((v119 * v116) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20)
                v117 = bswap32(*v112) >> 16;
              else
                v117 = 0xFFFF;
              v121 = v115 | (v115 << 8);
              v122 = bswap32(~*(unsigned __int16 *)v7);
              v123 = HIWORD(v122) * v121 + ((HIWORD(v122) * v121) >> 16) + 1;
              v121 ^= 0xFFFFu;
              v124 = HIWORD(v123) * (bswap32(*(unsigned __int16 *)v23) >> 16)
                   + (bswap32(*(unsigned __int16 *)v14) >> 16) * v121;
              v120 = ((v121 + HIWORD(v123)) * v117 + (((v121 + HIWORD(v123)) * v117) >> 16) + 1) >> 16;
              *(_WORD *)v14 = bswap32(v124 + HIWORD(v124) + 1);
            }
            *(_WORD *)v7 = bswap32(v120) >> 16;
          }
          v16 += v107;
          v125 = &v23[2 * v107];
          v126 = &v112[v20];
          if ((unint64_t)v125 >= v12)
            result = v113;
          else
            result = 0;
          v112 = &v126[result];
          v23 = &v125[2 * result];
          v7 += 2 * v8;
          v14 += v111;
          --v114;
        }
        while (v114);
        if (v763)
        {
          result = v767;
          v127 = &v768[2 * v767];
          if ((unint64_t)v127 >= v763)
            v128 = v110;
          else
            v128 = 0;
          v129 = (uint64_t)&v769[v766 + v128];
          if ((unint64_t)v127 >= v763)
            v130 = v109;
          else
            v130 = 0;
          v23 = &v127[2 * v130];
          v12 += 2 * v130 + 2 * v767;
          v768 = v23;
          v769 += v766 + v128;
          v112 = (unsigned __int16 *)v129;
        }
        else
        {
          v23 += 2 * v767;
          v112 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 5:
      v131 = v25;
      v132 = v22;
      v133 = -(uint64_t)(v767 * v22);
      v134 = -(uint64_t)(v766 * v132);
      v135 = 2 * v25;
      v136 = v769;
      v137 = -(uint64_t)v21;
      do
      {
        v138 = v10;
        do
        {
          if (*v16)
          {
            v139 = bswap32(*(unsigned __int16 *)v7);
            v140 = bswap32(*(unsigned __int16 *)v23);
            v141 = bswap32(*v136);
            v142 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v143 = HIWORD(v140) - ((v142 * HIWORD(v140) + ((v142 * HIWORD(v140)) >> 16) + 1) >> 16);
            v144 = (v143 | ((HIWORD(v141)
                           - ((v142 * HIWORD(v141) + ((v142 * HIWORD(v141)) >> 16) + 1) >> 16)) << 16)) >> 16;
            v145 = (unsigned __int16)v143 * HIWORD(v139) + (v144 ^ 0xFFFF) * (bswap32(*(unsigned __int16 *)v14) >> 16);
            *(_WORD *)v14 = bswap32(v145 + HIWORD(v145) + 1);
            *(_WORD *)v7 = bswap32(((v144 ^ 0xFFFF) + HIWORD(v139)) * v144+ ((((v144 ^ 0xFFFF) + HIWORD(v139)) * v144) >> 16)+ 1);
          }
          v16 += v131;
          v146 = &v23[2 * v131];
          v147 = &v136[v20];
          if ((unint64_t)v146 >= v12)
            result = v137;
          else
            result = 0;
          v136 = &v147[result];
          v23 = &v146[2 * result];
          v7 += 2 * v8;
          v14 += v135;
          --v138;
        }
        while (v138);
        if (v763)
        {
          result = v767;
          v148 = &v768[2 * v767];
          if ((unint64_t)v148 >= v763)
            v149 = v134;
          else
            v149 = 0;
          v150 = (uint64_t)&v769[v766 + v149];
          if ((unint64_t)v148 >= v763)
            v151 = v133;
          else
            v151 = 0;
          v23 = &v148[2 * v151];
          v12 += 2 * v151 + 2 * v767;
          v768 = v23;
          v769 += v766 + v149;
          v136 = (unsigned __int16 *)v150;
        }
        else
        {
          v23 += 2 * v767;
          v136 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 6:
      v152 = v20;
      v153 = -(uint64_t)v21;
      v154 = v22;
      v155 = -(uint64_t)(v767 * v22);
      v156 = -(uint64_t)(v766 * v154);
      v157 = v769;
      do
      {
        v158 = v10;
        do
        {
          v159 = *v16;
          if (*v16)
          {
            v160 = bswap32(*(unsigned __int16 *)v7);
            if (HIWORD(v160) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v160) == 0xFFFF)
              {
                if (v20)
                  v161 = bswap32(*v157) >> 16;
                else
                  v161 = 0xFFFF;
                v163 = bswap32(*(unsigned __int16 *)v23) >> 16;
                v164 = (v159 | (v159 << 8)) ^ 0xFFFF;
                *(_WORD *)v14 = bswap32(v163 - ((v164 * v163 + ((v164 * v163) >> 16) + 1) >> 16)) >> 16;
                v165 = v161 - ((v164 * v161 + ((v164 * v161) >> 16) + 1) >> 16);
              }
              else
              {
                if (v20)
                  v162 = bswap32(*v157) >> 16;
                else
                  v162 = 0xFFFF;
                v166 = bswap32(*(unsigned __int16 *)v23);
                v167 = (257 * v159 * (unsigned __int16)~HIWORD(v160)
                      + ((257 * v159 * (unsigned __int16)~HIWORD(v160)) >> 16)
                      + 1) >> 16;
                *(_WORD *)v14 = bswap32((bswap32(*(unsigned __int16 *)v14) >> 16)+ ((v167 * HIWORD(v166) + ((v167 * HIWORD(v166)) >> 16) + 1) >> 16)) >> 16;
                v165 = HIWORD(v160) + ((v167 * v162 + ((v167 * v162) >> 16) + 1) >> 16);
                v20 = v783;
              }
              *(_WORD *)v7 = bswap32(v165) >> 16;
            }
          }
          v16 += v25;
          v168 = &v23[2 * v25];
          v169 = &v157[v152];
          if ((unint64_t)v168 >= v12)
            v170 = v153;
          else
            v170 = 0;
          v157 = &v169[v170];
          v23 = &v168[2 * v170];
          v7 += 2 * v8;
          v14 += 2 * v25;
          --v158;
        }
        while (v158);
        if (v763)
        {
          v171 = &v768[2 * v767];
          if ((unint64_t)v171 >= v763)
            v172 = v156;
          else
            v172 = 0;
          v173 = (uint64_t)&v769[v766 + v172];
          if ((unint64_t)v171 >= v763)
            v174 = v155;
          else
            v174 = 0;
          v23 = &v171[2 * v174];
          v12 += 2 * v174 + 2 * v767;
          v768 = v23;
          v769 += v766 + v172;
          v157 = (unsigned __int16 *)v173;
        }
        else
        {
          v23 += 2 * v767;
          v157 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        result = v6 - v8 * v10;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 7:
      v175 = v25;
      if (v8)
      {
        v176 = v22;
        v177 = -(uint64_t)(v767 * v22);
        v178 = -(uint64_t)(v766 * v176);
        v179 = v769;
        v180 = -(uint64_t)v21;
        do
        {
          v181 = v10;
          do
          {
            v182 = *v16;
            if (*v16)
            {
              if (v182 == 255)
              {
                v183 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v184 = bswap32(*(unsigned __int16 *)v7) >> 16;
                v185 = bswap32(~*v179) >> 16;
                *(_WORD *)v14 = bswap32(v183 - ((v185 * v183 + ((v185 * v183) >> 16) + 1) >> 16)) >> 16;
                v186 = v184 - ((v185 * v184 + ((v185 * v184) >> 16) + 1) >> 16);
              }
              else
              {
                v187 = bswap32(*(unsigned __int16 *)v7);
                v188 = bswap32(*v179);
                v189 = ((v182 | (v182 << 8)) ^ 0xFFFF)
                     + ((HIWORD(v188) * (v182 | (v182 << 8))
                       + ((HIWORD(v188) * (v182 | (v182 << 8))) >> 16)
                       + 1) >> 16);
                v190 = v189 * (bswap32(*(unsigned __int16 *)v14) >> 16);
                v186 = (v189 * HIWORD(v187) + ((v189 * HIWORD(v187)) >> 16) + 1) >> 16;
                *(_WORD *)v14 = bswap32(v190 + HIWORD(v190) + 1);
              }
              *(_WORD *)v7 = bswap32(v186) >> 16;
            }
            v16 += v175;
            v191 = &v23[2 * v175];
            v192 = &v179[v20];
            if ((unint64_t)v191 >= v12)
              result = v180;
            else
              result = 0;
            v179 = &v192[result];
            v23 = &v191[2 * result];
            v7 += 2 * v8;
            v14 += 2 * v175;
            --v181;
          }
          while (v181);
          if (v763)
          {
            result = v767;
            v193 = &v768[2 * v767];
            if ((unint64_t)v193 >= v763)
              v194 = v178;
            else
              v194 = 0;
            v195 = (uint64_t)&v769[v766 + v194];
            if ((unint64_t)v193 >= v763)
              v196 = v177;
            else
              v196 = 0;
            v23 = &v193[2 * v196];
            v12 += 2 * v196 + 2 * v767;
            v768 = v23;
            v769 += v766 + v194;
            v179 = (unsigned __int16 *)v195;
          }
          else
          {
            v23 += 2 * v767;
            v179 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        v645 = -(uint64_t)v21;
        v646 = v22;
        v647 = -(uint64_t)(v767 * v22);
        v648 = -(uint64_t)(v766 * v646);
        v649 = v769;
        do
        {
          v650 = v10;
          do
          {
            v651 = *v16;
            if (*v16)
            {
              if (v651 == 255)
              {
                v652 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v653 = bswap32(~*v649);
                v654 = v652 - ((HIWORD(v653) * v652 + ((HIWORD(v653) * v652) >> 16) + 1) >> 16);
              }
              else
              {
                v655 = v651 | (v651 << 8);
                v656 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v657 = bswap32(*v649);
                result = HIWORD(v657) * v655 + ((HIWORD(v657) * v655) >> 16) + 1;
                v654 = (((v655 ^ 0xFFFF) + WORD1(result)) * v656 + ((((v655 ^ 0xFFFF) + WORD1(result)) * v656) >> 16) + 1) >> 16;
              }
              *(_WORD *)v14 = bswap32(v654) >> 16;
            }
            v16 += v175;
            v658 = &v23[2 * v175];
            v659 = &v649[v20];
            if ((unint64_t)v658 >= v12)
              v660 = v645;
            else
              v660 = 0;
            v649 = &v659[v660];
            v23 = &v658[2 * v660];
            v14 += 2 * v175;
            --v650;
          }
          while (v650);
          if (v763)
          {
            v661 = &v768[2 * v767];
            if ((unint64_t)v661 >= v763)
              v662 = v648;
            else
              v662 = 0;
            result = (unint64_t)&v769[v766 + v662];
            if ((unint64_t)v661 >= v763)
              v663 = v647;
            else
              v663 = 0;
            v23 = &v661[2 * v663];
            v12 += 2 * v663 + 2 * v767;
            v768 = v23;
            v769 += v766 + v662;
            v649 = (unsigned __int16 *)result;
          }
          else
          {
            v23 += 2 * v767;
            v649 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 8:
      v197 = v25;
      if (v8)
      {
        v198 = v22;
        v199 = -(uint64_t)(v767 * v22);
        v200 = -(uint64_t)(v766 * v198);
        v201 = v769;
        v202 = -(uint64_t)v21;
        do
        {
          v203 = v10;
          do
          {
            v204 = *v16;
            if (*v16)
            {
              v205 = bswap32(*(unsigned __int16 *)v14) >> 16;
              v206 = bswap32(*(unsigned __int16 *)v7) >> 16;
              if (v204 == 255)
              {
                v207 = bswap32(*v201);
              }
              else
              {
                v208 = bswap32(*v201) >> 16;
                v207 = 257 * v204 * v208 + ((257 * v204 * v208) >> 16) + 1;
              }
              *(_WORD *)v14 = bswap32(v205 - ((HIWORD(v207) * v205 + ((HIWORD(v207) * v205) >> 16) + 1) >> 16)) >> 16;
              *(_WORD *)v7 = bswap32(v206 - ((HIWORD(v207) * v206 + ((HIWORD(v207) * v206) >> 16) + 1) >> 16)) >> 16;
            }
            v16 += v197;
            v209 = &v23[2 * v197];
            v210 = &v201[v20];
            if ((unint64_t)v209 >= v12)
              result = v202;
            else
              result = 0;
            v201 = &v210[result];
            v23 = &v209[2 * result];
            v7 += 2 * v8;
            v14 += 2 * v197;
            --v203;
          }
          while (v203);
          if (v763)
          {
            result = v767;
            v211 = &v768[2 * v767];
            if ((unint64_t)v211 >= v763)
              v212 = v200;
            else
              v212 = 0;
            v213 = (uint64_t)&v769[v766 + v212];
            if ((unint64_t)v211 >= v763)
              v214 = v199;
            else
              v214 = 0;
            v23 = &v211[2 * v214];
            v12 += 2 * v214 + 2 * v767;
            v768 = v23;
            v769 += v766 + v212;
            v201 = (unsigned __int16 *)v213;
          }
          else
          {
            v23 += 2 * v767;
            v201 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        v664 = -(uint64_t)v21;
        v665 = v22;
        v666 = -(uint64_t)(v767 * v22);
        v667 = -(uint64_t)(v766 * v665);
        v668 = v769;
        do
        {
          v669 = v10;
          do
          {
            v670 = *v16;
            if (*v16)
            {
              v671 = bswap32(*(unsigned __int16 *)v14) >> 16;
              if (v670 == 255)
              {
                v672 = bswap32(*v668);
              }
              else
              {
                result = bswap32(*v668) >> 16;
                v672 = 257 * v670 * result + ((257 * v670 * result) >> 16) + 1;
              }
              *(_WORD *)v14 = bswap32(v671 - ((HIWORD(v672) * v671 + ((HIWORD(v672) * v671) >> 16) + 1) >> 16)) >> 16;
            }
            v16 += v197;
            v673 = &v23[2 * v197];
            v674 = &v668[v20];
            if ((unint64_t)v673 >= v12)
              v675 = v664;
            else
              v675 = 0;
            v668 = &v674[v675];
            v23 = &v673[2 * v675];
            v14 += 2 * v197;
            --v669;
          }
          while (v669);
          if (v763)
          {
            v676 = &v768[2 * v767];
            if ((unint64_t)v676 >= v763)
              v677 = v667;
            else
              v677 = 0;
            result = (unint64_t)&v769[v766 + v677];
            if ((unint64_t)v676 >= v763)
              v678 = v666;
            else
              v678 = 0;
            v23 = &v676[2 * v678];
            v12 += 2 * v678 + 2 * v767;
            v768 = v23;
            v769 += v766 + v677;
            v668 = (unsigned __int16 *)result;
          }
          else
          {
            v23 += 2 * v767;
            v668 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 9:
      v215 = -(uint64_t)v21;
      v216 = v22;
      v217 = -(uint64_t)(v767 * v22);
      v218 = -(uint64_t)(v766 * v216);
      v219 = v769;
      do
      {
        v220 = v10;
        do
        {
          if (*v16)
          {
            v221 = bswap32(*(unsigned __int16 *)v23);
            v222 = bswap32(*v219);
            v223 = ~(*v16 | (*v16 << 8));
            v224 = v223;
            v225 = HIWORD(v221) - ((HIWORD(v221) * v224 + ((HIWORD(v221) * v224) >> 16) + 1) >> 16);
            v226 = v225 | ((HIWORD(v222)
                          - ((HIWORD(v222) * v224 + ((HIWORD(v222) * v224) >> 16) + 1) >> 16)) << 16);
            v227 = bswap32(~*(unsigned __int16 *)v7) >> 16;
            v228 = (unsigned __int16)v225 * v227
                 + (unsigned __int16)(v223 + HIWORD(v226)) * (bswap32(*(unsigned __int16 *)v14) >> 16);
            v229 = (v227 + (unsigned __int16)(v223 + HIWORD(v226))) * HIWORD(v226);
            *(_WORD *)v14 = bswap32(v228 + HIWORD(v228) + 1);
            *(_WORD *)v7 = bswap32(v229 + HIWORD(v229) + 1);
          }
          v16 += v25;
          result = (unint64_t)&v23[2 * v25];
          v230 = &v219[v20];
          if (result >= v12)
            v231 = v215;
          else
            v231 = 0;
          v219 = &v230[v231];
          v23 = (char *)(result + 2 * v231);
          v7 += 2 * v8;
          v14 += 2 * v25;
          --v220;
        }
        while (v220);
        if (v763)
        {
          v232 = &v768[2 * v767];
          if ((unint64_t)v232 >= v763)
            v233 = v218;
          else
            v233 = 0;
          v234 = (uint64_t)&v769[v766 + v233];
          if ((unint64_t)v232 >= v763)
            v235 = v217;
          else
            v235 = 0;
          result = v12 + 2 * v235;
          v23 = &v232[2 * v235];
          v12 = result + 2 * v767;
          v768 = v23;
          v769 = (unsigned __int16 *)v234;
          v219 = (unsigned __int16 *)v234;
        }
        else
        {
          v23 += 2 * v767;
          v219 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 10:
      v236 = v25;
      v237 = v22;
      v238 = -(uint64_t)(v767 * v22);
      v239 = -(uint64_t)(v766 * v237);
      v240 = 2 * v25;
      v241 = v769;
      v242 = -(uint64_t)v21;
      do
      {
        v243 = v10;
        do
        {
          if (*v16)
          {
            v244 = bswap32(*(unsigned __int16 *)v23);
            v245 = bswap32(*v241);
            v246 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v247 = HIWORD(v244) - ((v246 * HIWORD(v244) + ((v246 * HIWORD(v244)) >> 16) + 1) >> 16);
            v248 = (v247 | ((HIWORD(v245)
                           - ((v246 * HIWORD(v245) + ((v246 * HIWORD(v245)) >> 16) + 1) >> 16)) << 16)) >> 16;
            v249 = bswap32(~*(unsigned __int16 *)v7);
            v250 = (unsigned __int16)v247 * HIWORD(v249) + (v248 ^ 0xFFFF) * (bswap32(*(unsigned __int16 *)v14) >> 16);
            *(_WORD *)v14 = bswap32(v250 + HIWORD(v250) + 1);
            *(_WORD *)v7 = bswap32(((v248 ^ 0xFFFF) + HIWORD(v249)) * v248+ ((((v248 ^ 0xFFFF) + HIWORD(v249)) * v248) >> 16)+ 1);
          }
          v16 += v236;
          v251 = &v23[2 * v236];
          v252 = &v241[v20];
          if ((unint64_t)v251 >= v12)
            result = v242;
          else
            result = 0;
          v241 = &v252[result];
          v23 = &v251[2 * result];
          v7 += 2 * v8;
          v14 += v240;
          --v243;
        }
        while (v243);
        if (v763)
        {
          result = v767;
          v253 = &v768[2 * v767];
          if ((unint64_t)v253 >= v763)
            v254 = v239;
          else
            v254 = 0;
          v255 = (uint64_t)&v769[v766 + v254];
          if ((unint64_t)v253 >= v763)
            v256 = v238;
          else
            v256 = 0;
          v23 = &v253[2 * v256];
          v12 += 2 * v256 + 2 * v767;
          v768 = v23;
          v769 += v766 + v254;
          v241 = (unsigned __int16 *)v255;
        }
        else
        {
          v23 += 2 * v767;
          v241 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 11:
      v257 = v25;
      if (v8)
      {
        v258 = v22;
        v259 = -(uint64_t)(v767 * v22);
        v260 = -(uint64_t)(v766 * v258);
        v261 = 2 * v8;
        v262 = v769;
        v263 = -(uint64_t)v21;
        do
        {
          v264 = v10;
          do
          {
            if (*v16)
            {
              if (v20)
                v265 = bswap32(*v262) >> 16;
              else
                v265 = 0xFFFF;
              v266 = bswap32(*(unsigned __int16 *)v23);
              v267 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v268 = HIWORD(v266) - ((v267 * HIWORD(v266) + ((v267 * HIWORD(v266)) >> 16) + 1) >> 16);
              v269 = bswap32(*(unsigned __int16 *)v7);
              v270 = (v268 | ((v265 - ((v265 * v267 + ((v265 * v267) >> 16) + 1) >> 16)) << 16)) >> 16;
              v271 = HIWORD(v269) - ((bswap32(*(unsigned __int16 *)v14) >> 16) + (unsigned __int16)v268) + v270;
              v272 = v270 + HIWORD(v269);
              if (v271 >= 0xFFFF)
                v271 = 0xFFFF;
              if (v272 >= 0xFFFF)
                v272 = 0xFFFF;
              *(_WORD *)v14 = bswap32(v272 - v271) >> 16;
              *(_WORD *)v7 = bswap32(v272) >> 16;
            }
            v16 += v25;
            result = (unint64_t)&v23[2 * v25];
            v273 = &v262[v20];
            if (result >= v12)
              v274 = v263;
            else
              v274 = 0;
            v262 = &v273[v274];
            v23 = (char *)(result + 2 * v274);
            v7 += v261;
            v14 += 2 * v25;
            --v264;
          }
          while (v264);
          if (v763)
          {
            v275 = &v768[2 * v767];
            if ((unint64_t)v275 >= v763)
              v276 = v260;
            else
              v276 = 0;
            v277 = (uint64_t)&v769[v766 + v276];
            if ((unint64_t)v275 >= v763)
              v278 = v259;
            else
              v278 = 0;
            result = v12 + 2 * v278;
            v23 = &v275[2 * v278];
            v12 = result + 2 * v767;
            v768 = v23;
            v769 = (unsigned __int16 *)v277;
            v262 = (unsigned __int16 *)v277;
          }
          else
          {
            v23 += 2 * v767;
            v262 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        v679 = -(uint64_t)v21;
        v680 = v22;
        v681 = -(uint64_t)(v767 * v22);
        v682 = -(uint64_t)(v766 * v680);
        v683 = v769;
        do
        {
          v684 = v10;
          do
          {
            if (*v16)
            {
              if (v20)
                v685 = bswap32(*v683) >> 16;
              else
                v685 = 0xFFFF;
              v686 = bswap32(*(unsigned __int16 *)v23);
              v687 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v688 = HIWORD(v686) - ((v687 * HIWORD(v686) + ((v687 * HIWORD(v686)) >> 16) + 1) >> 16);
              v689 = (bswap32(~*(unsigned __int16 *)v14) >> 16)
                   - (unsigned __int16)v688
                   + ((v688 | ((v685 - ((v685 * v687 + ((v685 * v687) >> 16) + 1) >> 16)) << 16)) >> 16);
              if (v689 >= 0xFFFF)
                v689 = 0xFFFF;
              *(_WORD *)v14 = bswap32(~v689) >> 16;
            }
            v16 += v257;
            v690 = &v23[2 * v257];
            v691 = &v683[v20];
            if ((unint64_t)v690 >= v12)
              result = v679;
            else
              result = 0;
            v683 = &v691[result];
            v23 = &v690[2 * result];
            v14 += 2 * v257;
            --v684;
          }
          while (v684);
          if (v763)
          {
            result = v767;
            v692 = &v768[2 * v767];
            if ((unint64_t)v692 >= v763)
              v693 = v682;
            else
              v693 = 0;
            v694 = (uint64_t)&v769[v766 + v693];
            if ((unint64_t)v692 >= v763)
              v695 = v681;
            else
              v695 = 0;
            v23 = &v692[2 * v695];
            v12 += 2 * v695 + 2 * v767;
            v768 = v23;
            v769 += v766 + v693;
            v683 = (unsigned __int16 *)v694;
          }
          else
          {
            v23 += 2 * v767;
            v683 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 12:
      if (v8)
      {
        v279 = v22;
        v280 = -(uint64_t)(v767 * v22);
        v281 = -(uint64_t)(v766 * v279);
        v282 = v769;
        v283 = -(uint64_t)v21;
        do
        {
          v284 = v10;
          do
          {
            if (*v16)
            {
              if (v20)
                v285 = bswap32(*v282) >> 16;
              else
                v285 = 0xFFFF;
              v286 = bswap32(*(unsigned __int16 *)v23);
              v287 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v288 = HIWORD(v286) - ((v287 * HIWORD(v286) + ((v287 * HIWORD(v286)) >> 16) + 1) >> 16);
              v289 = v288 | ((v285 - ((v285 * v287 + ((v285 * v287) >> 16) + 1) >> 16)) << 16);
              v290 = (bswap32(*(unsigned __int16 *)v14) >> 16) + (unsigned __int16)v288;
              v291 = HIWORD(v289) + (bswap32(*(unsigned __int16 *)v7) >> 16);
              if (v290 >= 0xFFFF)
                v290 = 0xFFFF;
              if (v291 >= 0xFFFF)
                v291 = 0xFFFF;
              *(_WORD *)v14 = bswap32(v290) >> 16;
              *(_WORD *)v7 = bswap32(v291) >> 16;
            }
            v16 += v25;
            result = (unint64_t)&v23[2 * v25];
            v292 = &v282[v20];
            if (result >= v12)
              v293 = v283;
            else
              v293 = 0;
            v282 = &v292[v293];
            v23 = (char *)(result + 2 * v293);
            v7 += 2 * v8;
            v14 += 2 * v25;
            --v284;
          }
          while (v284);
          if (v763)
          {
            v294 = &v768[2 * v767];
            if ((unint64_t)v294 >= v763)
              v295 = v281;
            else
              v295 = 0;
            v296 = (uint64_t)&v769[v766 + v295];
            if ((unint64_t)v294 >= v763)
              v297 = v280;
            else
              v297 = 0;
            result = v12 + 2 * v297;
            v23 = &v294[2 * v297];
            v12 = result + 2 * v767;
            v768 = v23;
            v769 = (unsigned __int16 *)v296;
            v282 = (unsigned __int16 *)v296;
          }
          else
          {
            v23 += 2 * v767;
            v282 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v696 = v10;
          v697 = v16;
          do
          {
            if (*v697)
            {
              v698 = bswap32(*(unsigned __int16 *)v14);
              *(_WORD *)v14 = bswap32((v698 >> 15) & 0xFFFE | ((v698 >> 16) >> 15)) >> 16;
            }
            v697 += v25;
            v14 += 2 * v25;
            --v696;
          }
          while (v696);
          v16 += v25 + v25 * (unint64_t)(v10 - 1) + v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 13:
      v298 = v25;
      v299 = v22;
      v300 = -(uint64_t)v21;
      v301 = -(uint64_t)(v767 * v22);
      v302 = -(uint64_t)(v766 * v299);
      v303 = 2 * v8;
      v304 = 2 * v25;
      v305 = v769;
      while (1)
      {
        v306 = v10;
        do
        {
          if (*v16)
          {
            v307 = v20 ? bswap32(*v305) >> 16 : 0xFFFF;
            v308 = bswap32(*(unsigned __int16 *)v23);
            v309 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v310 = HIWORD(v308) - ((v309 * HIWORD(v308) + ((v309 * HIWORD(v308)) >> 16) + 1) >> 16);
            v311 = v310 | ((v307 - ((v307 * v309 + ((v307 * v309) >> 16) + 1) >> 16)) << 16);
            if (v311 >= 0x10000)
            {
              v312 = HIWORD(v311);
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v313 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_342;
                }
LABEL_350:
                *(_WORD *)v14 = bswap32(v311) >> 16;
                v319 = v7;
              }
              else
              {
                v313 = 0xFFFF;
LABEL_342:
                v314 = (v313 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v310
                     + ((v312 ^ 0xFFFF) + (unsigned __int16)v310)
                     * (unint64_t)(bswap32(*(unsigned __int16 *)v14) >> 16);
                if (v314 <= 0xFFFE8000)
                  v315 = v314 + 0x8000;
                else
                  v315 = 4294868992;
                v316 = v315 + (v315 >> 16);
                v8 = v782;
                if (v782)
                {
                  v317 = v316 >> 16;
                  v318 = 0xFFFF * (v313 + v312) - v313 * (unint64_t)v312;
                  if (v318 <= 4294868992)
                    v312 = v318 + 0x8000;
                  else
                    v312 = 4294868992;
                  v311 = ((v312 >> 16) + v312) & 0xFFFF0000 | v317;
                  LODWORD(v312) = HIWORD(v311);
                  goto LABEL_350;
                }
                v312 = v316 >> 16;
                v319 = v14;
              }
              *(_WORD *)v319 = bswap32(v312) >> 16;
            }
          }
          v16 += v298;
          v14 += v304;
          result = (unint64_t)&v23[2 * v298];
          v320 = &v305[v20];
          if (result >= v12)
            v321 = v300;
          else
            v321 = 0;
          v305 = &v320[v321];
          v23 = (char *)(result + 2 * v321);
          v7 += v303;
          --v306;
        }
        while (v306);
        if (v763)
        {
          v322 = &v768[2 * v767];
          if ((unint64_t)v322 >= v763)
            v323 = v302;
          else
            v323 = 0;
          v324 = (uint64_t)&v769[v766 + v323];
          if ((unint64_t)v322 >= v763)
            v325 = v301;
          else
            v325 = 0;
          result = v12 + 2 * v325;
          v23 = &v322[2 * v325];
          v12 = result + 2 * v767;
          v768 = v23;
          v769 = (unsigned __int16 *)v324;
          v305 = (unsigned __int16 *)v324;
        }
        else
        {
          v23 += 2 * v767;
          v305 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        if (!--v9)
          return result;
      }
    case 14:
      v326 = v25;
      v327 = v22;
      v328 = -(uint64_t)v21;
      v329 = -(uint64_t)(v767 * v22);
      v330 = 2 * v25;
      v331 = v769;
      while (1)
      {
        v332 = v10;
        do
        {
          if (*v16)
          {
            v333 = v20 ? bswap32(*v331) >> 16 : 0xFFFF;
            v334 = bswap32(*(unsigned __int16 *)v23);
            v335 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v336 = HIWORD(v334) - ((v335 * HIWORD(v334) + ((v335 * HIWORD(v334)) >> 16) + 1) >> 16);
            v337 = v336 | ((v333 - ((v333 * v335 + ((v333 * v335) >> 16) + 1) >> 16)) << 16);
            if (v337 >= 0x10000)
            {
              v338 = HIWORD(v337);
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v339 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_379;
                }
LABEL_387:
                *(_WORD *)v14 = bswap32(v337) >> 16;
                v346 = v7;
              }
              else
              {
                v339 = 0xFFFF;
LABEL_379:
                v340 = bswap32(*(unsigned __int16 *)v14) >> 16;
                v341 = (v340 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v336 - v340 + (v340 << 16);
                if (v341 <= 0xFFFE8000)
                  v342 = v341 + 0x8000;
                else
                  v342 = 4294868992;
                v343 = (v342 + (v342 >> 16)) >> 16;
                if (v8)
                {
                  v344 = 0xFFFF * (v339 + (unint64_t)v338) - v339 * (unint64_t)v338;
                  if (v344 <= 4294868992)
                    v345 = v344 + 0x8000;
                  else
                    v345 = 4294868992;
                  v337 = ((v345 >> 16) + v345) & 0xFFFF0000 | v343;
                  v338 = HIWORD(v337);
                  goto LABEL_387;
                }
                v338 = v343;
                v346 = v14;
              }
              *(_WORD *)v346 = bswap32(v338) >> 16;
            }
          }
          v16 += v326;
          v14 += v330;
          result = (unint64_t)&v23[2 * v326];
          v347 = &v331[v20];
          if (result >= v12)
            v348 = v328;
          else
            v348 = 0;
          v331 = &v347[v348];
          v23 = (char *)(result + 2 * v348);
          v7 += 2 * v8;
          --v332;
        }
        while (v332);
        if (v763)
        {
          v349 = &v768[2 * v767];
          if ((unint64_t)v349 >= v763)
            v350 = -(uint64_t)(v766 * v327);
          else
            v350 = 0;
          v351 = (uint64_t)&v769[v766 + v350];
          if ((unint64_t)v349 >= v763)
            v352 = v329;
          else
            v352 = 0;
          result = v12 + 2 * v352;
          v23 = &v349[2 * v352];
          v12 = result + 2 * v767;
          v768 = v23;
          v769 = (unsigned __int16 *)v351;
          v331 = (unsigned __int16 *)v351;
        }
        else
        {
          v23 += 2 * v767;
          v331 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        if (!--v9)
          return result;
      }
    case 15:
      v353 = v25;
      v354 = v20;
      v725 = -(uint64_t)(v767 * v22);
      v737 = v20;
      v713 = -(uint64_t)(v766 * v22);
      v355 = 2 * v8;
      v356 = 2 * v25;
      v357 = v769;
      v358 = -(uint64_t)v21;
      while (1)
      {
        v750 = v9;
        v770 = v12;
        do
        {
          if (*v16)
          {
            v359 = v20 ? bswap32(*v357) >> 16 : 0xFFFF;
            v360 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v361 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v362 = v361 * v360 + ((v361 * v360) >> 16) + 1;
            result = (v360 - HIWORD(v362)) | ((v359 - ((v359 * v361 + ((v359 * v361) >> 16) + 1) >> 16)) << 16);
            v363 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v364 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_416;
                }
LABEL_418:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v365 = v7;
              }
              else
              {
                v364 = 0xFFFF;
LABEL_416:
                result = PDAoverlayPDA_8071(bswap32(*(unsigned __int16 *)v14) >> 16, v364, (unsigned __int16)(v360 - HIWORD(v362)), v363);
                v8 = v782;
                if (v782)
                {
                  v363 = WORD1(result);
                  v12 = v770;
                  v20 = v783;
                  v354 = v737;
                  goto LABEL_418;
                }
                v363 = result;
                v365 = v14;
                v12 = v770;
                v20 = v783;
                v354 = v737;
              }
              *(_WORD *)v365 = bswap32(v363) >> 16;
            }
          }
          v16 += v353;
          v14 += v356;
          v366 = &v23[2 * v353];
          if ((unint64_t)v366 >= v12)
            v367 = v358;
          else
            v367 = 0;
          v357 += v354 + v367;
          v23 = &v366[2 * v367];
          v7 += v355;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v368 = &v768[2 * v767];
          v369 = v713;
          if ((unint64_t)v368 < v763)
            v369 = 0;
          v357 = &v769[v766 + v369];
          v370 = v725;
          if ((unint64_t)v368 < v763)
            v370 = 0;
          v23 = &v368[2 * v370];
          v12 += 2 * v370 + 2 * v767;
          v768 = v23;
          v769 += v766 + v369;
        }
        else
        {
          v23 += 2 * v767;
          v357 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v750 - 1;
        if (v750 == 1)
          return result;
      }
    case 16:
      v371 = v25;
      v372 = v20;
      v726 = -(uint64_t)(v767 * v22);
      v738 = v20;
      v714 = -(uint64_t)(v766 * v22);
      v373 = 2 * v8;
      v374 = 2 * v25;
      v375 = v769;
      v376 = -(uint64_t)v21;
      while (1)
      {
        v751 = v9;
        v771 = v12;
        do
        {
          if (*v16)
          {
            v377 = v20 ? bswap32(*v375) >> 16 : 0xFFFF;
            v378 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v379 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v380 = v379 * v378 + ((v379 * v378) >> 16) + 1;
            result = (v378 - HIWORD(v380)) | ((v377 - ((v377 * v379 + ((v377 * v379) >> 16) + 1) >> 16)) << 16);
            v381 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v382 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_445;
                }
LABEL_447:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v383 = v7;
              }
              else
              {
                v382 = 0xFFFF;
LABEL_445:
                result = PDAdarkenPDA_8073(bswap32(*(unsigned __int16 *)v14) >> 16, v382, (unsigned __int16)(v378 - HIWORD(v380)), v381);
                v8 = v782;
                if (v782)
                {
                  v381 = WORD1(result);
                  v12 = v771;
                  v20 = v783;
                  v372 = v738;
                  goto LABEL_447;
                }
                v381 = result;
                v383 = v14;
                v12 = v771;
                v20 = v783;
                v372 = v738;
              }
              *(_WORD *)v383 = bswap32(v381) >> 16;
            }
          }
          v16 += v371;
          v14 += v374;
          v384 = &v23[2 * v371];
          if ((unint64_t)v384 >= v12)
            v385 = v376;
          else
            v385 = 0;
          v375 += v372 + v385;
          v23 = &v384[2 * v385];
          v7 += v373;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v386 = &v768[2 * v767];
          v387 = v714;
          if ((unint64_t)v386 < v763)
            v387 = 0;
          v375 = &v769[v766 + v387];
          v388 = v726;
          if ((unint64_t)v386 < v763)
            v388 = 0;
          v23 = &v386[2 * v388];
          v12 += 2 * v388 + 2 * v767;
          v768 = v23;
          v769 += v766 + v387;
        }
        else
        {
          v23 += 2 * v767;
          v375 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v751 - 1;
        if (v751 == 1)
          return result;
      }
    case 17:
      v389 = v25;
      v390 = v20;
      v727 = -(uint64_t)(v767 * v22);
      v739 = v20;
      v715 = -(uint64_t)(v766 * v22);
      v391 = 2 * v8;
      v392 = 2 * v25;
      v393 = v769;
      v394 = -(uint64_t)v21;
      while (1)
      {
        v752 = v9;
        v772 = v12;
        do
        {
          if (*v16)
          {
            v395 = v20 ? bswap32(*v393) >> 16 : 0xFFFF;
            v396 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v397 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v398 = v397 * v396 + ((v397 * v396) >> 16) + 1;
            result = (v396 - HIWORD(v398)) | ((v395 - ((v395 * v397 + ((v395 * v397) >> 16) + 1) >> 16)) << 16);
            v399 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v400 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_474;
                }
LABEL_476:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v401 = v7;
              }
              else
              {
                v400 = 0xFFFF;
LABEL_474:
                result = PDAlightenPDA_8072(bswap32(*(unsigned __int16 *)v14) >> 16, v400, (unsigned __int16)(v396 - HIWORD(v398)), v399);
                v8 = v782;
                if (v782)
                {
                  v399 = WORD1(result);
                  v12 = v772;
                  v20 = v783;
                  v390 = v739;
                  goto LABEL_476;
                }
                v399 = result;
                v401 = v14;
                v12 = v772;
                v20 = v783;
                v390 = v739;
              }
              *(_WORD *)v401 = bswap32(v399) >> 16;
            }
          }
          v16 += v389;
          v14 += v392;
          v402 = &v23[2 * v389];
          if ((unint64_t)v402 >= v12)
            v403 = v394;
          else
            v403 = 0;
          v393 += v390 + v403;
          v23 = &v402[2 * v403];
          v7 += v391;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v404 = &v768[2 * v767];
          v405 = v715;
          if ((unint64_t)v404 < v763)
            v405 = 0;
          v393 = &v769[v766 + v405];
          v406 = v727;
          if ((unint64_t)v404 < v763)
            v406 = 0;
          v23 = &v404[2 * v406];
          v12 += 2 * v406 + 2 * v767;
          v768 = v23;
          v769 += v766 + v405;
        }
        else
        {
          v23 += 2 * v767;
          v393 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v752 - 1;
        if (v752 == 1)
          return result;
      }
    case 18:
      v407 = v25;
      v408 = v20;
      v728 = -(uint64_t)(v767 * v22);
      v740 = v20;
      v716 = -(uint64_t)(v766 * v22);
      v409 = 2 * v8;
      v410 = 2 * v25;
      v411 = v769;
      v412 = -(uint64_t)v21;
      while (1)
      {
        v753 = v9;
        v773 = v12;
        do
        {
          if (*v16)
          {
            v413 = v20 ? bswap32(*v411) >> 16 : 0xFFFF;
            v414 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v415 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v416 = v415 * v414 + ((v415 * v414) >> 16) + 1;
            result = (v414 - HIWORD(v416)) | ((v413 - ((v413 * v415 + ((v413 * v415) >> 16) + 1) >> 16)) << 16);
            v417 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v418 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_503;
                }
LABEL_505:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v419 = v7;
              }
              else
              {
                v418 = 0xFFFF;
LABEL_503:
                result = PDAcolordodgePDA_8074(bswap32(*(unsigned __int16 *)v14) >> 16, v418, (unsigned __int16)(v414 - HIWORD(v416)), v417);
                v8 = v782;
                if (v782)
                {
                  v417 = WORD1(result);
                  v12 = v773;
                  v20 = v783;
                  v408 = v740;
                  goto LABEL_505;
                }
                v417 = result;
                v419 = v14;
                v12 = v773;
                v20 = v783;
                v408 = v740;
              }
              *(_WORD *)v419 = bswap32(v417) >> 16;
            }
          }
          v16 += v407;
          v14 += v410;
          v420 = &v23[2 * v407];
          if ((unint64_t)v420 >= v12)
            v421 = v412;
          else
            v421 = 0;
          v411 += v408 + v421;
          v23 = &v420[2 * v421];
          v7 += v409;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v422 = &v768[2 * v767];
          v423 = v716;
          if ((unint64_t)v422 < v763)
            v423 = 0;
          v411 = &v769[v766 + v423];
          v424 = v728;
          if ((unint64_t)v422 < v763)
            v424 = 0;
          v23 = &v422[2 * v424];
          v12 += 2 * v424 + 2 * v767;
          v768 = v23;
          v769 += v766 + v423;
        }
        else
        {
          v23 += 2 * v767;
          v411 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v753 - 1;
        if (v753 == 1)
          return result;
      }
    case 19:
      v425 = v25;
      v426 = v20;
      v729 = -(uint64_t)(v767 * v22);
      v741 = v20;
      v717 = -(uint64_t)(v766 * v22);
      v427 = 2 * v8;
      v428 = 2 * v25;
      v429 = v769;
      v430 = -(uint64_t)v21;
      while (1)
      {
        v754 = v9;
        v774 = v12;
        do
        {
          if (*v16)
          {
            v431 = v20 ? bswap32(*v429) >> 16 : 0xFFFF;
            v432 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v433 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v434 = v433 * v432 + ((v433 * v432) >> 16) + 1;
            result = (v432 - HIWORD(v434)) | ((v431 - ((v431 * v433 + ((v431 * v433) >> 16) + 1) >> 16)) << 16);
            v435 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v436 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_532;
                }
LABEL_534:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v437 = v7;
              }
              else
              {
                v436 = 0xFFFF;
LABEL_532:
                result = PDAcolorburnPDA_8075(bswap32(*(unsigned __int16 *)v14) >> 16, v436, (unsigned __int16)(v432 - HIWORD(v434)), v435);
                v8 = v782;
                if (v782)
                {
                  v435 = WORD1(result);
                  v12 = v774;
                  v20 = v783;
                  v426 = v741;
                  goto LABEL_534;
                }
                v435 = result;
                v437 = v14;
                v12 = v774;
                v20 = v783;
                v426 = v741;
              }
              *(_WORD *)v437 = bswap32(v435) >> 16;
            }
          }
          v16 += v425;
          v14 += v428;
          v438 = &v23[2 * v425];
          if ((unint64_t)v438 >= v12)
            v439 = v430;
          else
            v439 = 0;
          v429 += v426 + v439;
          v23 = &v438[2 * v439];
          v7 += v427;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v440 = &v768[2 * v767];
          v441 = v717;
          if ((unint64_t)v440 < v763)
            v441 = 0;
          v429 = &v769[v766 + v441];
          v442 = v729;
          if ((unint64_t)v440 < v763)
            v442 = 0;
          v23 = &v440[2 * v442];
          v12 += 2 * v442 + 2 * v767;
          v768 = v23;
          v769 += v766 + v441;
        }
        else
        {
          v23 += 2 * v767;
          v429 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v754 - 1;
        if (v754 == 1)
          return result;
      }
    case 20:
      v443 = v25;
      v444 = v20;
      v730 = -(uint64_t)(v767 * v22);
      v742 = v20;
      v718 = -(uint64_t)(v766 * v22);
      v445 = 2 * v8;
      v446 = 2 * v25;
      v447 = v769;
      v448 = -(uint64_t)v21;
      while (1)
      {
        v755 = v9;
        v775 = v12;
        do
        {
          if (*v16)
          {
            v449 = v20 ? bswap32(*v447) >> 16 : 0xFFFF;
            v450 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v451 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v452 = v451 * v450 + ((v451 * v450) >> 16) + 1;
            result = (v450 - HIWORD(v452)) | ((v449 - ((v449 * v451 + ((v449 * v451) >> 16) + 1) >> 16)) << 16);
            v453 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v454 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_561;
                }
LABEL_563:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v455 = v7;
              }
              else
              {
                v454 = 0xFFFF;
LABEL_561:
                result = PDAsoftlightPDA_8077(bswap32(*(unsigned __int16 *)v14) >> 16, v454, (unsigned __int16)(v450 - HIWORD(v452)), v453);
                v8 = v782;
                if (v782)
                {
                  v453 = WORD1(result);
                  v12 = v775;
                  v20 = v783;
                  v444 = v742;
                  goto LABEL_563;
                }
                v453 = result;
                v455 = v14;
                v12 = v775;
                v20 = v783;
                v444 = v742;
              }
              *(_WORD *)v455 = bswap32(v453) >> 16;
            }
          }
          v16 += v443;
          v14 += v446;
          v456 = &v23[2 * v443];
          if ((unint64_t)v456 >= v12)
            v457 = v448;
          else
            v457 = 0;
          v447 += v444 + v457;
          v23 = &v456[2 * v457];
          v7 += v445;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v458 = &v768[2 * v767];
          v459 = v718;
          if ((unint64_t)v458 < v763)
            v459 = 0;
          v447 = &v769[v766 + v459];
          v460 = v730;
          if ((unint64_t)v458 < v763)
            v460 = 0;
          v23 = &v458[2 * v460];
          v12 += 2 * v460 + 2 * v767;
          v768 = v23;
          v769 += v766 + v459;
        }
        else
        {
          v23 += 2 * v767;
          v447 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v755 - 1;
        if (v755 == 1)
          return result;
      }
    case 21:
      v461 = v25;
      v462 = v20;
      v731 = -(uint64_t)(v767 * v22);
      v743 = v20;
      v719 = -(uint64_t)(v766 * v22);
      v463 = 2 * v8;
      v464 = 2 * v25;
      v465 = v769;
      v466 = -(uint64_t)v21;
      while (1)
      {
        v756 = v9;
        v776 = v12;
        do
        {
          if (*v16)
          {
            v467 = v20 ? bswap32(*v465) >> 16 : 0xFFFF;
            v468 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v469 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v470 = v469 * v468 + ((v469 * v468) >> 16) + 1;
            result = (v468 - HIWORD(v470)) | ((v467 - ((v467 * v469 + ((v467 * v469) >> 16) + 1) >> 16)) << 16);
            v471 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v472 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_590;
                }
LABEL_592:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v473 = v7;
              }
              else
              {
                v472 = 0xFFFF;
LABEL_590:
                result = PDAhardlightPDA_8076(bswap32(*(unsigned __int16 *)v14) >> 16, v472, (unsigned __int16)(v468 - HIWORD(v470)), v471);
                v8 = v782;
                if (v782)
                {
                  v471 = WORD1(result);
                  v12 = v776;
                  v20 = v783;
                  v462 = v743;
                  goto LABEL_592;
                }
                v471 = result;
                v473 = v14;
                v12 = v776;
                v20 = v783;
                v462 = v743;
              }
              *(_WORD *)v473 = bswap32(v471) >> 16;
            }
          }
          v16 += v461;
          v14 += v464;
          v474 = &v23[2 * v461];
          if ((unint64_t)v474 >= v12)
            v475 = v466;
          else
            v475 = 0;
          v465 += v462 + v475;
          v23 = &v474[2 * v475];
          v7 += v463;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v476 = &v768[2 * v767];
          v477 = v719;
          if ((unint64_t)v476 < v763)
            v477 = 0;
          v465 = &v769[v766 + v477];
          v478 = v731;
          if ((unint64_t)v476 < v763)
            v478 = 0;
          v23 = &v476[2 * v478];
          v12 += 2 * v478 + 2 * v767;
          v768 = v23;
          v769 += v766 + v477;
        }
        else
        {
          v23 += 2 * v767;
          v465 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v756 - 1;
        if (v756 == 1)
          return result;
      }
    case 22:
      v479 = v25;
      v480 = v20;
      v732 = -(uint64_t)(v767 * v22);
      v744 = v20;
      v720 = -(uint64_t)(v766 * v22);
      v481 = 2 * v8;
      v482 = 2 * v25;
      v483 = v769;
      v484 = -(uint64_t)v21;
      while (1)
      {
        v757 = v9;
        v777 = v12;
        do
        {
          if (*v16)
          {
            v485 = v20 ? bswap32(*v483) >> 16 : 0xFFFF;
            v486 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v487 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v488 = v487 * v486 + ((v487 * v486) >> 16) + 1;
            result = (v486 - HIWORD(v488)) | ((v485 - ((v485 * v487 + ((v485 * v487) >> 16) + 1) >> 16)) << 16);
            v489 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v490 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_619;
                }
LABEL_621:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v491 = v7;
              }
              else
              {
                v490 = 0xFFFF;
LABEL_619:
                result = PDAdifferencePDA_8078(bswap32(*(unsigned __int16 *)v14) >> 16, v490, (unsigned __int16)(v486 - HIWORD(v488)), v489);
                v8 = v782;
                if (v782)
                {
                  v489 = WORD1(result);
                  v12 = v777;
                  v20 = v783;
                  v480 = v744;
                  goto LABEL_621;
                }
                v489 = result;
                v491 = v14;
                v12 = v777;
                v20 = v783;
                v480 = v744;
              }
              *(_WORD *)v491 = bswap32(v489) >> 16;
            }
          }
          v16 += v479;
          v14 += v482;
          v492 = &v23[2 * v479];
          if ((unint64_t)v492 >= v12)
            v493 = v484;
          else
            v493 = 0;
          v483 += v480 + v493;
          v23 = &v492[2 * v493];
          v7 += v481;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v494 = &v768[2 * v767];
          v495 = v720;
          if ((unint64_t)v494 < v763)
            v495 = 0;
          v483 = &v769[v766 + v495];
          v496 = v732;
          if ((unint64_t)v494 < v763)
            v496 = 0;
          v23 = &v494[2 * v496];
          v12 += 2 * v496 + 2 * v767;
          v768 = v23;
          v769 += v766 + v495;
        }
        else
        {
          v23 += 2 * v767;
          v483 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v757 - 1;
        if (v757 == 1)
          return result;
      }
    case 23:
      v497 = v25;
      v498 = v22;
      v499 = -(uint64_t)v21;
      v500 = -(uint64_t)(v767 * v22);
      v501 = -(uint64_t)(v766 * v498);
      v502 = 2 * v8;
      v503 = 2 * v25;
      v504 = v769;
      while (1)
      {
        v505 = v10;
        do
        {
          if (*v16)
          {
            v506 = v20 ? bswap32(*v504) >> 16 : 0xFFFF;
            v507 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v508 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v509 = v507 - ((v508 * v507 + ((v508 * v507) >> 16) + 1) >> 16);
            v510 = v509 | ((v506 - ((v506 * v508 + ((v506 * v508) >> 16) + 1) >> 16)) << 16);
            LODWORD(v511) = HIWORD(v510);
            if (HIWORD(v510))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v512 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_648;
                }
LABEL_662:
                *(_WORD *)v14 = bswap32(v510) >> 16;
                v521 = v7;
              }
              else
              {
                v512 = 0xFFFF;
LABEL_648:
                v513 = bswap32(*(unsigned __int16 *)v14) >> 16;
                if ((unsigned __int16)v509 >= HIWORD(v510))
                  v514 = v511;
                else
                  v514 = (unsigned __int16)v509;
                if (v513 >= v512)
                  v515 = v512;
                else
                  v515 = v513;
                v516 = 0xFFFF * (v515 + v514) - 2 * v514 * (unint64_t)v515;
                if (v516 <= 4294868992)
                  v517 = v516 + 0x8000;
                else
                  v517 = 4294868992;
                v518 = v517 + (v517 >> 16);
                v8 = v782;
                if (v782)
                {
                  v519 = v518 >> 16;
                  v520 = 0xFFFF * (v512 + (unint64_t)v511)
                       - v512 * (unint64_t)v511;
                  if (v520 <= 4294868992)
                    v511 = v520 + 0x8000;
                  else
                    v511 = 4294868992;
                  v510 = ((v511 >> 16) + v511) & 0xFFFF0000 | v519;
                  LODWORD(v511) = HIWORD(v510);
                  goto LABEL_662;
                }
                v511 = v518 >> 16;
                v521 = v14;
              }
              *(_WORD *)v521 = bswap32(v511) >> 16;
            }
          }
          v16 += v497;
          v14 += v503;
          result = (unint64_t)&v23[2 * v497];
          v522 = &v504[v20];
          if (result >= v12)
            v523 = v499;
          else
            v523 = 0;
          v504 = &v522[v523];
          v23 = (char *)(result + 2 * v523);
          v7 += v502;
          --v505;
        }
        while (v505);
        if (v763)
        {
          v524 = &v768[2 * v767];
          if ((unint64_t)v524 >= v763)
            v525 = v501;
          else
            v525 = 0;
          v526 = (uint64_t)&v769[v766 + v525];
          if ((unint64_t)v524 >= v763)
            v527 = v500;
          else
            v527 = 0;
          result = v12 + 2 * v527;
          v23 = &v524[2 * v527];
          v12 = result + 2 * v767;
          v768 = v23;
          v769 = (unsigned __int16 *)v526;
          v504 = (unsigned __int16 *)v526;
        }
        else
        {
          v23 += 2 * v767;
          v504 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        if (!--v9)
          return result;
      }
    case 24:
      v528 = v25;
      v529 = v20;
      v733 = -(uint64_t)(v767 * v22);
      v745 = v20;
      v721 = -(uint64_t)(v766 * v22);
      v530 = 2 * v8;
      v531 = 2 * v25;
      v532 = v769;
      v533 = -(uint64_t)v21;
      while (1)
      {
        v758 = v9;
        v778 = v12;
        do
        {
          if (*v16)
          {
            v534 = v20 ? bswap32(*v532) >> 16 : 0xFFFF;
            v535 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v536 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v537 = v536 * v535 + ((v536 * v535) >> 16) + 1;
            result = (v535 - HIWORD(v537)) | ((v534 - ((v534 * v536 + ((v534 * v536) >> 16) + 1) >> 16)) << 16);
            v538 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v539 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_691;
                }
LABEL_693:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v540 = v7;
              }
              else
              {
                v539 = 0xFFFF;
LABEL_691:
                result = PDAhuePDA_8079(bswap32(*(unsigned __int16 *)v14) >> 16, v539, (unsigned __int16)(v535 - HIWORD(v537)), v538);
                v8 = v782;
                if (v782)
                {
                  v538 = WORD1(result);
                  v12 = v778;
                  v20 = v783;
                  v529 = v745;
                  goto LABEL_693;
                }
                v538 = result;
                v540 = v14;
                v12 = v778;
                v20 = v783;
                v529 = v745;
              }
              *(_WORD *)v540 = bswap32(v538) >> 16;
            }
          }
          v16 += v528;
          v14 += v531;
          v541 = &v23[2 * v528];
          if ((unint64_t)v541 >= v12)
            v542 = v533;
          else
            v542 = 0;
          v532 += v529 + v542;
          v23 = &v541[2 * v542];
          v7 += v530;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v543 = &v768[2 * v767];
          v544 = v721;
          if ((unint64_t)v543 < v763)
            v544 = 0;
          v532 = &v769[v766 + v544];
          v545 = v733;
          if ((unint64_t)v543 < v763)
            v545 = 0;
          v23 = &v543[2 * v545];
          v12 += 2 * v545 + 2 * v767;
          v768 = v23;
          v769 += v766 + v544;
        }
        else
        {
          v23 += 2 * v767;
          v532 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v758 - 1;
        if (v758 == 1)
          return result;
      }
    case 25:
      v546 = v25;
      v547 = v20;
      v734 = -(uint64_t)(v767 * v22);
      v746 = v20;
      v722 = -(uint64_t)(v766 * v22);
      v548 = 2 * v8;
      v549 = 2 * v25;
      v550 = v769;
      v551 = -(uint64_t)v21;
      while (1)
      {
        v759 = v9;
        v779 = v12;
        do
        {
          if (*v16)
          {
            v552 = v20 ? bswap32(*v550) >> 16 : 0xFFFF;
            v553 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v554 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v555 = v554 * v553 + ((v554 * v553) >> 16) + 1;
            result = (v553 - HIWORD(v555)) | ((v552 - ((v552 * v554 + ((v552 * v554) >> 16) + 1) >> 16)) << 16);
            v556 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v557 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_720;
                }
LABEL_722:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v558 = v7;
              }
              else
              {
                v557 = 0xFFFF;
LABEL_720:
                result = PDAhuePDA_8079(bswap32(*(unsigned __int16 *)v14) >> 16, v557, (unsigned __int16)(v553 - HIWORD(v555)), v556);
                v8 = v782;
                if (v782)
                {
                  v556 = WORD1(result);
                  v12 = v779;
                  v20 = v783;
                  v547 = v746;
                  goto LABEL_722;
                }
                v556 = result;
                v558 = v14;
                v12 = v779;
                v20 = v783;
                v547 = v746;
              }
              *(_WORD *)v558 = bswap32(v556) >> 16;
            }
          }
          v16 += v546;
          v14 += v549;
          v559 = &v23[2 * v546];
          if ((unint64_t)v559 >= v12)
            v560 = v551;
          else
            v560 = 0;
          v550 += v547 + v560;
          v23 = &v559[2 * v560];
          v7 += v548;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v561 = &v768[2 * v767];
          v562 = v722;
          if ((unint64_t)v561 < v763)
            v562 = 0;
          v550 = &v769[v766 + v562];
          v563 = v734;
          if ((unint64_t)v561 < v763)
            v563 = 0;
          v23 = &v561[2 * v563];
          v12 += 2 * v563 + 2 * v767;
          v768 = v23;
          v769 += v766 + v562;
        }
        else
        {
          v23 += 2 * v767;
          v550 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v759 - 1;
        if (v759 == 1)
          return result;
      }
    case 26:
      v564 = v25;
      v565 = v20;
      v735 = -(uint64_t)(v767 * v22);
      v747 = v20;
      v723 = -(uint64_t)(v766 * v22);
      v566 = 2 * v8;
      v567 = 2 * v25;
      v568 = v769;
      v569 = -(uint64_t)v21;
      while (1)
      {
        v760 = v9;
        v780 = v12;
        do
        {
          if (*v16)
          {
            v570 = v20 ? bswap32(*v568) >> 16 : 0xFFFF;
            v571 = bswap32(*(unsigned __int16 *)v23) >> 16;
            v572 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v573 = v572 * v571 + ((v572 * v571) >> 16) + 1;
            result = (v571 - HIWORD(v573)) | ((v570 - ((v570 * v572 + ((v570 * v572) >> 16) + 1) >> 16)) << 16);
            v574 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  v575 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_749;
                }
LABEL_751:
                *(_WORD *)v14 = bswap32(result) >> 16;
                v576 = v7;
              }
              else
              {
                v575 = 0xFFFF;
LABEL_749:
                result = PDAluminosityPDA_8081((unsigned __int16)(v571 - HIWORD(v573)), v574, bswap32(*(unsigned __int16 *)v14) >> 16, v575);
                v8 = v782;
                if (v782)
                {
                  v574 = WORD1(result);
                  v12 = v780;
                  v20 = v783;
                  v565 = v747;
                  goto LABEL_751;
                }
                v574 = result;
                v576 = v14;
                v12 = v780;
                v20 = v783;
                v565 = v747;
              }
              *(_WORD *)v576 = bswap32(v574) >> 16;
            }
          }
          v16 += v564;
          v14 += v567;
          v577 = &v23[2 * v564];
          if ((unint64_t)v577 >= v12)
            v578 = v569;
          else
            v578 = 0;
          v568 += v565 + v578;
          v23 = &v577[2 * v578];
          v7 += v566;
          --v10;
        }
        while (v10);
        if (v763)
        {
          v579 = &v768[2 * v767];
          v580 = v723;
          if ((unint64_t)v579 < v763)
            v580 = 0;
          v568 = &v769[v766 + v580];
          v581 = v735;
          if ((unint64_t)v579 < v763)
            v581 = 0;
          v23 = &v579[2 * v581];
          v12 += 2 * v581 + 2 * v767;
          v768 = v23;
          v769 += v766 + v580;
        }
        else
        {
          v23 += 2 * v767;
          v568 += v766;
        }
        v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        v9 = v760 - 1;
        if (v760 == 1)
          return result;
      }
    case 27:
      v582 = v25;
      v583 = v20;
      v736 = -(uint64_t)(v767 * v22);
      v748 = v20;
      v724 = -(uint64_t)(v766 * v22);
      v584 = 2 * v8;
      v585 = 2 * v25;
      v586 = v769;
      v587 = -(uint64_t)v21;
      break;
    default:
      return result;
  }
  do
  {
    v761 = v9;
    v781 = v12;
    do
    {
      if (*v16)
      {
        v588 = v20 ? bswap32(*v586) >> 16 : 0xFFFF;
        v589 = bswap32(*(unsigned __int16 *)v23) >> 16;
        v590 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        v591 = v590 * v589 + ((v590 * v589) >> 16) + 1;
        result = (v589 - HIWORD(v591)) | ((v588 - ((v588 * v590 + ((v588 * v590) >> 16) + 1) >> 16)) << 16);
        v592 = WORD1(result);
        if (WORD1(result))
        {
          if (v8)
          {
            if (!*(_WORD *)v7)
              goto LABEL_780;
            v593 = __rev16(*(unsigned __int16 *)v7);
          }
          else
          {
            v593 = 0xFFFF;
          }
          result = PDAluminosityPDA_8081(bswap32(*(unsigned __int16 *)v14) >> 16, v593, (unsigned __int16)(v589 - HIWORD(v591)), v592);
          v8 = v782;
          if (!v782)
          {
            v592 = result;
            v594 = v14;
            v12 = v781;
            v20 = v783;
            v583 = v748;
            goto LABEL_782;
          }
          v592 = WORD1(result);
          v12 = v781;
          v20 = v783;
          v583 = v748;
LABEL_780:
          *(_WORD *)v14 = bswap32(result) >> 16;
          v594 = v7;
LABEL_782:
          *(_WORD *)v594 = bswap32(v592) >> 16;
        }
      }
      v16 += v582;
      v14 += v585;
      v595 = &v23[2 * v582];
      if ((unint64_t)v595 >= v12)
        v596 = v587;
      else
        v596 = 0;
      v586 += v583 + v596;
      v23 = &v595[2 * v596];
      v7 += v584;
      --v10;
    }
    while (v10);
    if (v763)
    {
      v597 = &v768[2 * v767];
      v598 = v724;
      if ((unint64_t)v597 < v763)
        v598 = 0;
      v586 = &v769[v766 + v598];
      v599 = v736;
      if ((unint64_t)v597 < v763)
        v599 = 0;
      v23 = &v597[2 * v599];
      v12 += 2 * v599 + 2 * v767;
      v768 = v23;
      v769 += v766 + v598;
    }
    else
    {
      v23 += 2 * v767;
      v586 += v766;
    }
    v10 = v749;
    v16 += v765;
    v14 += 2 * v764;
    v7 += 2 * v762;
    v9 = v761 - 1;
  }
  while (v761 != 1);
  return result;
}

uint64_t CGImageTextureDataGetTypeID()
{
  if (_block_invoke_once_8092 != -1)
    dispatch_once(&_block_invoke_once_8092, &__block_literal_global_23_8093);
  return CGImageTextureDataGetTypeID_texture_data_type_id;
}

BOOL CGImageTextureDataIsCompressed(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 136) != 0;
  return result;
}

uint64_t CGImageTextureDataGetNumberOfFaces(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 128);
  return result;
}

uint64_t CGImageTextureDataGetDataWithBlock(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t (*v7)(_QWORD, uint64_t, uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t);
  char v8;
  double v9;
  double v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (result)
  {
    if (a5)
    {
      v6 = result;
      v7 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(result + 40);
      if (v7)
      {
        v8 = a2;
        v9 = *(double *)(result + 72);
        v10 = *(double *)(result + 80);
        v11 = *(_QWORD *)(result + 88);
        v16 = 0;
        v17 = 0;
        v15 = 0;
        v12 = v7(*(_QWORD *)(result + 24), a2, a3, &v17, &v16, &v15, a4);
        if (v12)
        {
          v13 = v12;
          ERROR_CGDataProvider_BufferIsNotReadable();
          if (v15)
          {
            ERROR_CGDataProvider_BufferIsNotBigEnough();
            v14 = v15;
          }
          else
          {
            v14 = 0;
          }
          (*(void (**)(uint64_t, unint64_t, unint64_t, unint64_t, uint64_t, uint64_t))(a5 + 16))(a5, (unint64_t)v9 >> v8, (unint64_t)v10 >> v8, v11 >> v8, v13 + v16, v14);
        }
        return (*(uint64_t (**)(_QWORD))(v6 + 48))(*(_QWORD *)(v6 + 24));
      }
    }
  }
  return result;
}

uint64_t CGImageTextureDataCopyProperties()
{
  return 0;
}

void CGImageTextureDataSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  unint64_t *v5;
  _DWORD *v6;

  if (a1 && a2 && a3)
  {
    v5 = (unint64_t *)(a1 + 64);
    if (!*(_QWORD *)(a1 + 64))
    {
      v6 = CGPropertiesCreate();
      while (!__ldxr(v5))
      {
        if (!__stxr((unint64_t)v6, v5))
          goto LABEL_11;
      }
      __clrex();
      CGPropertiesRelease((uint64_t)v6);
    }
LABEL_11:
    CGPropertiesSetProperty(*v5, a2, a3);
  }
}

const void *CGImageTextureDataGetProperty(uint64_t a1, const void *a2)
{
  uint64_t v2;

  if (a1 && a2 && (v2 = *(_QWORD *)(a1 + 64)) != 0)
    return CGPropertiesGetProperty(v2, a2);
  else
    return 0;
}

uint64_t CGImageIOSurfaceSetCreate(uint64_t a1, CFTypeRef cf, uint64_t a3, _DWORD *a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10)
{
  uint64_t Instance;
  CFTypeID v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  CGRect v30;
  CGRect v31;
  CGRect v32;

  Instance = 0;
  if (a1 && cf)
  {
    v21 = CFGetTypeID(cf);
    if (v21 != CFArrayGetTypeID() || a4 && *a4)
      return 0;
    Instance = 0;
    if (a5 <= 0.0 || a6 <= 0.0)
      return Instance;
    if (a5 != (double)(unint64_t)a5)
      return 0;
    if (a6 != (double)(unint64_t)a6)
      return 0;
    v30.origin.x = a7;
    v30.origin.y = a8;
    v30.size.width = a9;
    v30.size.height = a10;
    v32 = CGRectIntegral(v30);
    v31.origin.x = a7;
    v31.origin.y = a8;
    v31.size.width = a9;
    v31.size.height = a10;
    if (!CGRectEqualToRect(v31, v32))
      return 0;
    if (_block_invoke_once_8120 != -1)
      dispatch_once(&_block_invoke_once_8120, &__block_literal_global_4_8121);
    Instance = CGTypeCreateInstance(CGImageIOSurfaceSetGetTypeID_iosurfaceset_type_id, 120, v22, v23, v24, v25, v26, v27);
    if (Instance)
    {
      CFRetain((CFTypeRef)a1);
      *(_QWORD *)(Instance + 16) = a1;
      *(double *)(Instance + 24) = a5;
      *(double *)(Instance + 32) = a6;
      *(CGFloat *)(Instance + 40) = a7;
      *(CGFloat *)(Instance + 48) = a8;
      *(CGFloat *)(Instance + 56) = a9;
      *(CGFloat *)(Instance + 64) = a10;
      *(_DWORD *)(Instance + 72) = *(_DWORD *)(a1 + 32);
      *(_QWORD *)(Instance + 80) = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(Instance + 88) = CGImageProviderGetColorSpace((_QWORD *)a1);
      *(_QWORD *)(Instance + 96) = 0;
      *(_QWORD *)(Instance + 104) = a3;
      v28 = (_OWORD *)(Instance + 112);
      if (a4)
      {
        *v28 = *(_OWORD *)a4;
      }
      else
      {
        *(_QWORD *)v28 = 0;
        *(_QWORD *)(Instance + 120) = 0;
      }
      *(_QWORD *)(Instance + 128) = CFArrayCreateCopy(0, (CFArrayRef)cf);
    }
  }
  return Instance;
}

void image_iosurfaceset_finalize(uint64_t a1)
{
  void (*v2)(_QWORD);
  const void *v3;

  v2 = *(void (**)(_QWORD))(a1 + 120);
  if (v2)
    v2(*(_QWORD *)(a1 + 104));
  v3 = *(const void **)(a1 + 16);
  if (v3)
    CFRelease(v3);
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 88));
  CGPropertiesRelease(*(_QWORD *)(a1 + 96));
}

uint64_t CGImageIOSurfaceSetGetTypeID()
{
  if (_block_invoke_once_8120 != -1)
    dispatch_once(&_block_invoke_once_8120, &__block_literal_global_4_8121);
  return CGImageIOSurfaceSetGetTypeID_iosurfaceset_type_id;
}

CFTypeRef CGImageIOSurfaceSetRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGImageIOSurfaceSetRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGImageIOSurfaceSetGetComponentType(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 72);
  return result;
}

uint64_t CGImageIOSurfaceSetGetColorSpace(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 88);
  return result;
}

uint64_t CGImageIOSurfaceSetGetPixelSize(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

CGFloat CGImageIOSurfaceSetGetSize(uint64_t a1)
{
  const CGSize *v1;

  v1 = (const CGSize *)(a1 + 24);
  if (!a1)
    v1 = &CGSizeZero;
  return v1->width;
}

CGFloat CGImageIOSurfaceSetGetRect(uint64_t a1)
{
  const CGRect *v1;

  v1 = &CGRectZero;
  if (a1)
    v1 = (const CGRect *)(a1 + 40);
  return v1->origin.x;
}

CFIndex CGImageIOSurfaceSetGetCount(CFIndex result)
{
  if (result)
    return CFArrayGetCount(*(CFArrayRef *)(result + 128));
  return result;
}

const void *CGImageSurfaceSetGetIOSurface(uint64_t a1, unint64_t a2)
{
  unint64_t Count;

  if (!a1)
    return 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 128));
  if ((Count & 0x8000000000000000) != 0 || Count <= a2)
    return 0;
  else
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 128), a2);
}

void CGImageIOSurfaceSetSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  unint64_t *v5;
  _DWORD *v6;

  if (a1 && a2 && a3)
  {
    v5 = (unint64_t *)(a1 + 96);
    if (!*(_QWORD *)(a1 + 96))
    {
      v6 = CGPropertiesCreate();
      while (!__ldxr(v5))
      {
        if (!__stxr((unint64_t)v6, v5))
          goto LABEL_11;
      }
      __clrex();
      CGPropertiesRelease((uint64_t)v6);
    }
LABEL_11:
    CGPropertiesSetProperty(*v5, a2, a3);
  }
}

const void *CGImageIOSurfaceSetGetProperty(uint64_t a1, const void *a2)
{
  uint64_t v2;

  if (a1 && a2 && (v2 = *(_QWORD *)(a1 + 96)) != 0)
    return CGPropertiesGetProperty(v2, a2);
  else
    return 0;
}

void CGGlyphLockRelease(CFTypeRef **a1)
{
  CFTypeRef *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      CGGlyphBuilderUnlockBitmaps(v2);
      CGGlyphBuilderRelease(*a1);
    }
    free(a1);
  }
}

unint64_t *scan(_QWORD **a1)
{
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  __int128 v22;
  int v23;

  v2 = (unint64_t *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  v9 = v2;
  if (!v2)
    return v9;
  v22 = 0uLL;
  v2[1] = 0;
  v2[2] = 0;
  *v2 = 0;
  while (1)
  {
    v10 = type4_lexer_scan(a1, (uint64_t)&v22, v3, v4, v5, v6, v7, v8);
    if (v10 == 123)
    {
      v11 = scan(a1);
      if (!v11)
        goto LABEL_25;
      LODWORD(v22) = 259;
      *((_QWORD *)&v22 + 1) = v11;
      goto LABEL_9;
    }
    if (v10 == 125)
      break;
    if (v10 == -1)
    {
      pdf_error("EOF encountered before end of Type4 function.");
LABEL_25:
      type4_program_release(v9);
      return 0;
    }
LABEL_9:
    v12 = *v9;
    if (*v9 == v9[1])
    {
      v13 = 2 * v12 + 24;
      v9[1] = v13;
      v14 = malloc_type_realloc((void *)v9[2], 16 * v13, 0x10A204033A3C712uLL);
      v9[2] = (unint64_t)v14;
      v12 = *v9;
    }
    else
    {
      v14 = (_OWORD *)v9[2];
    }
    *v9 = v12 + 1;
    v14[v12] = v22;
  }
  v23 = 0;
  v15 = *v9;
  while (v15)
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = v9[2];
    do
    {
      v19 = 0;
      v20 = v18 + 16 * v15++;
      *(_OWORD *)v20 = *(_OWORD *)(v18 + 16 * v16);
      while (*(uint64_t (**)())(v20 + 8) != *(uint64_t (**)())((char *)&type4_program_peephole_peepholers
                                                                                  + v19)
           || !(*(unsigned int (**)(unint64_t, unint64_t, int *))((char *)&type4_program_peephole_peepholers
                                                                                         + v19
                                                                                         + 8))(v20, v15, &v23))
      {
        v19 += 16;
        if (v19 == 288)
          goto LABEL_22;
      }
      v15 += v23;
      v17 = 1;
LABEL_22:
      ++v16;
    }
    while (v16 < *v9);
    *v9 = v15;
    if ((v17 & 1) == 0)
      return v9;
  }
  *v9 = 0;
  return v9;
}

void type4_program_release(unint64_t *a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = 0;
      v4 = 0;
      do
      {
        v5 = a1[2];
        if (*(_DWORD *)(v5 + v3) == 259)
        {
          type4_program_release(*(_QWORD *)(v5 + v3 + 8));
          v2 = *a1;
        }
        ++v4;
        v3 += 16;
      }
      while (v4 < v2);
    }
    free((void *)a1[2]);
    free(a1);
  }
}

uint64_t type4_program_execute(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t result;

  if (!*a1)
    return 1;
  v4 = 0;
  for (i = a1[2]; *(_DWORD *)i == 260; i += 16)
  {
    if (((*(uint64_t (**)(uint64_t *))(i + 8))(a2) & 1) == 0)
      return 0;
LABEL_8:
    if ((unint64_t)++v4 >= *a1)
      return 1;
  }
  v6 = *a2;
  if (*a2 != 200)
  {
    *a2 = v6 + 1;
    *(_OWORD *)&a2[2 * v6 + 2] = *(_OWORD *)i;
    goto LABEL_8;
  }
  result = 0;
  *((_DWORD *)a2 + 804) = 3;
  return result;
}

uint64_t get_program_string_length(uint64_t *a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *a1;
  if (!*a1)
    return 3;
  v2 = (_QWORD *)(a1[2] + 8);
  v3 = 2;
  do
  {
    switch(*((_DWORD *)v2 - 2))
    {
      case 0x100:
        v4 = v3 + 5;
        break;
      case 0x101:
      case 0x102:
        v4 = v3 + 16;
        break;
      case 0x103:
        v4 = get_program_string_length(*v2) + v3;
        break;
      case 0x104:
        v4 = v3 + 8;
        break;
      default:
        v4 = v3;
        break;
    }
    v3 = v4 + 1;
    v2 += 2;
    --v1;
  }
  while (v1);
  return v4 + 2;
}

uint64_t print_program(char *a1, unint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char *v7;
  char *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;

  strcpy(a1, "{ ");
  if (*a2)
  {
    v4 = 0;
    v5 = 2;
    do
    {
      v6 = a2[2];
      switch(*(_DWORD *)(v6 + 16 * v4))
      {
        case 0x100:
          v7 = &a1[v5];
          goto LABEL_17;
        case 0x101:
          v8 = &a1[v5];
          goto LABEL_21;
        case 0x102:
          v8 = &a1[v5];
          v9 = *(double *)(v6 + 16 * v4 + 8);
          v10 = fabs(v9);
          if (v10 == INFINITY)
            goto LABEL_21;
          if (v9 < -2147483650.0 || v9 > 2147483650.0)
            goto LABEL_18;
          v11 = ceil(v9 + -0.5);
          v12 = floor(v9 + 0.5);
          if (v9 >= 0.0)
            v11 = v12;
          if (vabdd_f64(v9, v11) < 0.000001)
          {
LABEL_21:
            v16 = sprintf(v8, "%d");
          }
          else
          {
LABEL_18:
            if (v10 >= 1.0)
            {
              if (v10 <= 10000000.0)
                v16 = sprintf(v8, "%0.7g");
              else
                v16 = sprintf(v8, "%0.0f");
            }
            else if (v10 >= 0.000001)
            {
              if (v10 >= 0.0001)
                v16 = sprintf(v8, "%0.06g");
              else
                v16 = sprintf(v8, "%0.06f");
            }
            else
            {
              *(_WORD *)v8 = 48;
              v16 = 1;
            }
          }
          goto LABEL_22;
        case 0x103:
          v5 += print_program(&a1[v5], *(_QWORD *)(v6 + 16 * v4 + 8));
          break;
        case 0x104:
          v13 = 0;
          v7 = &a1[v5];
          v14 = *(_QWORD *)(v6 + 16 * v4 + 8);
          v15 = &qword_1E162D738;
          do
          {
            if (*v15 == v14)
              break;
            ++v13;
            v15 += 2;
          }
          while (v13 != 48);
LABEL_17:
          v16 = sprintf(v7, "%s");
LABEL_22:
          v5 += v16;
          break;
        default:
          break;
      }
      *(_WORD *)&a1[v5++] = 32;
      ++v4;
    }
    while (v4 < *a2);
  }
  else
  {
    v5 = 2;
  }
  *(_WORD *)&a1[v5] = 125;
  return v5 + 1;
}

void startIndent(__CFString *a1, int *a2)
{
  int v4;
  int v5;

  CFStringAppend(a1, CFSTR("\n"));
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      do
      {
        --v4;
        CFStringAppend(a1, CFSTR("\t"));
      }
      while (v4);
      v5 = *a2 + 1;
    }
    else
    {
      v5 = 1;
    }
    *a2 = v5;
  }
}

void startTagWithAttributes(__CFString *a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t i;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;

  CFStringAppend(a1, CFSTR("<"));
  CFStringAppend(a1, a2);
  v17 = &a10;
  for (i = a9; i; i = *v16)
  {
    v14 = v17;
    v18 = v17 + 1;
    v15 = *v14;
    if (!v15)
      break;
    CFStringAppendFormat(a1, 0, CFSTR(" %@=\"%@\""), i, v15);
    v16 = v18;
    v17 = v18 + 1;
  }
  if (a3)
    CFStringAppend(a1, CFSTR("/"));
  CFStringAppend(a1, CFSTR(">"));
}

void startTag(__CFString *a1, const __CFString *a2, int a3)
{
  CFStringAppend(a1, CFSTR("<"));
  CFStringAppend(a1, a2);
  if (a3)
    CFStringAppend(a1, CFSTR("/"));
  CFStringAppend(a1, CFSTR(">"));
}

CFMutableStringRef CGPDFCopyStringEscapingElementMarkup(__CFString *theString)
{
  CFMutableStringRef MutableCopy;
  CFRange v3;
  CFRange v4;
  CFRange v5;

  MutableCopy = theString;
  if (!theString)
    return MutableCopy;
  if (CFStringFind(theString, CFSTR("&"), 0).location != -1
    || CFStringFind(MutableCopy, CFSTR("<"), 0).location != -1
    || CFStringFind(MutableCopy, CFSTR(">"), 0).location != -1)
  {
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MutableCopy);
    v3.length = CFStringGetLength(MutableCopy);
    v3.location = 0;
    CFStringFindAndReplace(MutableCopy, CFSTR("&"), CFSTR("&amp;"), v3, 0);
    v4.length = CFStringGetLength(MutableCopy);
    v4.location = 0;
    CFStringFindAndReplace(MutableCopy, CFSTR("<"), CFSTR("&lt;"), v4, 0);
    v5.length = CFStringGetLength(MutableCopy);
    v5.location = 0;
    CFStringFindAndReplace(MutableCopy, CFSTR(">"), CFSTR("&gt;"), v5, 0);
    return MutableCopy;
  }
  return (CFMutableStringRef)CFRetain(MutableCopy);
}

void endIndent(__CFString *a1, int *a2)
{
  int v4;
  int v5;

  CFStringAppend(a1, CFSTR("\n"));
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = v4 - 1;
      *a2 = v4 - 1;
      if (v4 != 1)
      {
        do
        {
          --v5;
          CFStringAppend(a1, CFSTR("\t"));
        }
        while (v5);
      }
    }
  }
}

uint64_t mapNoneToHTML()
{
  return 1;
}

uint64_t mapWordToHTML(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t WordRangeIncludingWhitespace;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  _BOOL4 v19;
  BOOL v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t Range;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  double *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  uint64_t v58;
  double *v59;
  BOOL v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  __CFString *StringForRanges;
  __CFString *v68;
  uint64_t v69;
  __CFString *CSS;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _DWORD *v76;
  uint64_t v77;
  const __CFString *v78;
  const __CFString *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  char v84;
  uint64_t v85;
  __CFString *theString;
  uint64_t *v87;
  uint64_t v88;
  _QWORD *v89;
  unint64_t v90;

  WordRangeIncludingWhitespace = getWordRangeIncludingWhitespace(a1, a2, a3);
  v8 = v7;
  v9 = a3[1];
  if (v9)
  {
    if (*(_BYTE *)(v9 + 40))
      CPIndexSetNormalize(a3[1]);
    v10 = *(_QWORD *)(v9 + 16);
  }
  else
  {
    v10 = 0;
  }
  v11 = a3[3];
  v12 = a3[4];
  v13 = v11 + v12;
  v14 = v12 <= 0;
  if (v12 <= 0)
    v15 = v11 + v12;
  else
    v15 = a3[3];
  if (!v14)
    v11 = v13;
  v16 = WordRangeIncludingWhitespace + v8;
  v17 = v8 <= 0;
  if (v8 <= 0)
    v18 = WordRangeIncludingWhitespace + v8;
  else
    v18 = WordRangeIncludingWhitespace;
  if (!v17)
    WordRangeIncludingWhitespace = v16;
  v19 = WordRangeIncludingWhitespace <= v15;
  v20 = v11 <= v18;
  if (v11 <= v18)
    v21 = -1;
  else
    v21 = v19;
  if (v20)
  {
    do
    {
      v22 = a3[2] + 1;
      if (v22 >= v10)
        return 0;
      v23 = a3[1];
      a3[2] = v22;
      Range = CPIndexSetGetRange(v23, v22);
      a3[3] = Range;
      a3[4] = v25;
      v26 = Range + v25;
      if (v25 <= 0)
        v27 = Range;
      else
        v27 = Range + v25;
    }
    while (v27 <= v18);
    if (v25 > 0)
      v26 = Range;
    v21 = WordRangeIncludingWhitespace <= v26;
  }
  if (v21)
    return 1;
  v29 = a3[2];
  v30 = getWordRangeIncludingWhitespace(a1, a2, a3);
  v32 = v31;
  v33 = a3[1];
  if (v33)
  {
    if (*(_BYTE *)(v33 + 40))
      CPIndexSetNormalize(a3[1]);
    v34 = *(_QWORD *)(v33 + 16);
  }
  else
  {
    v34 = 0;
  }
  v35 = a3[2];
  v36 = v35 + 1;
  if (v35 + 1 < v34)
  {
    if (v32 <= 0)
      v37 = v30 + v32;
    else
      v37 = v30;
    if (v32 > 0)
      v30 += v32;
    do
    {
      v38 = CPIndexSetGetRange(a3[1], v36);
      v40 = v38 + v39;
      if (v39 <= 0)
        v41 = v38 + v39;
      else
        v41 = v38;
      if (v39 <= 0)
        v40 = v38;
      if (v40 > v37 && v30 <= v41)
        break;
      if (v40 > v37 && v30 > v41)
      {
        a3[2] = v36;
        a3[3] = v38;
        a3[4] = v39;
      }
      ++v36;
    }
    while (v34 != v36);
    v35 = a3[2];
  }
  v44 = v35 - v29;
  if ((unint64_t)(v35 - v29) > 0x7FFFFFFFFFFFFFFELL)
    return 0;
  result = getWordRangeIncludingWhitespace(a1, a2, a3);
  if (!v45)
    return 1;
  v46 = result;
  v47 = v45;
  LODWORD(result) = 0;
  if (a1 || !a2)
  {
LABEL_66:
    v85 = v29;
    v88 = a2;
    v50 = 0;
    v90 = v44 + 1;
    v51 = *a3;
    v83 = result;
    if (*a3 && (v46 & 0x8000000000000000) == 0)
    {
      if (*(_QWORD *)(v51 + 48) > v46 && (v52 = *(_QWORD *)(v51 + 24)) != 0)
        v50 = *(double **)(v52 + 24 * v46 + 8);
      else
        v50 = 0;
    }
    v89 = malloc_type_malloc(16 * v90, 0x1000040451B5BE8uLL);
    theString = (__CFString *)a3[7];
    if (v47 >= 1)
    {
      v84 = 0;
      v53 = v46 + v47;
      v87 = &v89[2 * v44];
      v54 = v46;
      while (1)
      {
        v55 = v46;
        if (++v46 >= v53
          || ((v56 = *a3) != 0 ? (v57 = v55 < -1) : (v57 = 1),
              v57 || *(_QWORD *)(v56 + 48) <= v46 || (v58 = *(_QWORD *)(v56 + 24)) == 0))
        {
          v59 = 0;
        }
        else
        {
          v59 = *(double **)(v58 + 24 * v46 + 8);
        }
        v60 = !v59 || v59 == v50;
        if (!v60 || v46 == v53)
          break;
        v59 = v50;
LABEL_114:
        v50 = v59;
        if (v46 >= v53)
          goto LABEL_115;
      }
      if (v90 >= 2)
      {
        v61 = v89 + 1;
        v62 = v85;
        do
        {
          v63 = CPIndexSetGetRange(a3[1], v62);
          *(v61 - 1) = CPRangeIntersection(v54, v46 - v54, v63, v64);
          *v61 = v65;
          ++v62;
          v61 += 2;
        }
        while (v35 != v62);
      }
      *v87 = CPRangeIntersection(v54, v46 - v54, a3[3], a3[4]);
      v87[1] = v66;
      StringForRanges = CGPDFLayoutCreateStringForRanges(*a3, (uint64_t)v89, v90);
      v68 = StringForRanges;
      if (v50 && StringForRanges && CFStringGetLength(StringForRanges) >= 1)
      {
        v69 = a3[5];
        if (v69)
        {
          if ((v84 & 1) == 0 && (CGPDFTextStyleEqualToPDFTextStyle((uint64_t)v50, v69) & 1) != 0)
          {
            v84 = 0;
            goto LABEL_101;
          }
          CFStringAppendFormat(theString, 0, CFSTR("</%@>"), CFSTR("span"));
        }
        a3[5] = (uint64_t)v50;
        CSS = CGPDFTextStyleCreateCSS(v50);
        startTagWithAttributes(theString, CFSTR("span"), 0, v71, v72, v73, v74, v75, (uint64_t)CFSTR("style"), (uint64_t)CSS);
        CFRelease(CSS);
        v84 = 1;
      }
LABEL_101:
      if (CGPDFNodeIsInlineContainer(v88) && (v76 = *(_DWORD **)(v88 + 64)) != 0)
      {
        v77 = 1;
        while (kCGPDFNodeTypeOrder[v77] != *v76)
        {
          if (++v77 == 12)
          {
            LODWORD(v77) = 0;
            break;
          }
        }
        ((void (*)(_QWORD))htmlFuncArray[v77])(0);
        if (!v68)
          goto LABEL_113;
      }
      else
      {
        if (!v68)
        {
LABEL_113:
          v54 = v46;
          goto LABEL_114;
        }
        v78 = CGPDFCopyStringEscapingElementMarkup(v68);
        if (v78)
        {
          v79 = v78;
          CFStringAppend(theString, v78);
          CFRelease(v79);
        }
      }
      CFRelease(v68);
      goto LABEL_113;
    }
LABEL_115:
    if (v83)
      CFStringAppend(theString, CFSTR("&nbsp;"));
    free(v89);
    return 1;
  }
  v48 = a2;
  while (1)
  {
    if (*(_DWORD *)v48 == 1537)
    {
      v49 = *(_DWORD **)(v48 + 104);
      if (v49)
      {
        if (*v49 == 1)
          break;
      }
    }
    v48 = *(_QWORD *)(v48 + 8);
    if (!v48)
      goto LABEL_65;
  }
  if (!v49[1]
    || (v80 = *(_QWORD *)(a2 + 8)) != 0
    && ((v81 = *(_QWORD *)(v80 + 8)) == 0
     || (*(_BYTE *)(v81 + 1) & 2) == 0
     || !*(_DWORD *)(v81 + 44)
     || v80 != **(_QWORD **)(v81 + 56)))
  {
LABEL_65:
    LODWORD(result) = 0;
    goto LABEL_66;
  }
  if (!CGPDFListCanGenerateItemMarker(a2))
  {
    LODWORD(result) = 1;
    goto LABEL_66;
  }
  v82 = a2;
  result = 1;
  while (*(_DWORD *)v82 != 1537)
  {
    v82 = *(_QWORD *)(v82 + 8);
    if (!v82)
      return result;
  }
  result = 1;
  if (*(double *)(v82 + 112) != 0.0)
    goto LABEL_66;
  return result;
}

uint64_t mapImageToHTML(uint64_t a1, __n64 *a2, uint64_t a3)
{
  int OverlappingRange;
  uint64_t v6;
  __n64 v8;
  __n64 v9;
  __n64 v10;
  __n64 v11;
  CGFloat v12;
  CGFloat width;
  CGFloat height;
  double PageRotation;
  __double2 v16;
  CFStringRef ImageName;
  CFStringRef v18;
  const __CFAllocator *v19;
  CFStringRef v20;
  CFStringRef v21;
  __CFString *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __CFArray *v28;
  CGAffineTransform v29;
  CGRect v30;
  CGRect v31;

  OverlappingRange = findOverlappingRange((uint64_t)a2, (uint64_t *)a3);
  if (OverlappingRange > 0)
    return 1;
  if (OverlappingRange < 0)
    return 0;
  if ((CGPDFNodeIsUsedGraphic((uint64_t)a2) & 1) != 0)
    return 1;
  v11.n64_u64[0] = CGPDFNodeGetBounds(a2).n64_u64[0];
  v6 = 1;
  if (v11.n64_f64[0] != INFINITY)
  {
    v12 = v8.n64_f64[0];
    if (v8.n64_f64[0] != INFINITY)
    {
      width = v9.n64_f64[0];
      height = v10.n64_f64[0];
      PageRotation = CGPDFNodeGetPageRotation((uint64_t)a2);
      if (PageRotation != 0.0)
      {
        v16 = __sincos_stret(PageRotation);
        v29.a = v16.__cosval;
        v29.b = v16.__sinval;
        v29.c = -v16.__sinval;
        v29.d = v16.__cosval;
        v29.tx = 0.0;
        v29.ty = 0.0;
        v30.origin.x = v11.n64_f64[0];
        v30.origin.y = v12;
        v30.size.width = width;
        v30.size.height = height;
        v31 = CGRectApplyAffineTransform(v30, &v29);
        width = v31.size.width;
        height = v31.size.height;
      }
      ImageName = CGPDFNodeCreateImageName((uint64_t)a2);
      if (ImageName)
      {
        v18 = ImageName;
        v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%f"), *(_QWORD *)&width);
        v21 = CFStringCreateWithFormat(v19, 0, CFSTR("%f"), *(_QWORD *)&height);
        v22 = *(__CFString **)(a3 + 56);
        startIndent(v22, (int *)(a3 + 64));
        v6 = 1;
        startTagWithAttributes(v22, CFSTR("img"), 1, v23, v24, v25, v26, v27, (uint64_t)CFSTR("src"), (uint64_t)v18);
        --*(_DWORD *)(a3 + 64);
        CFRelease(v21);
        CFRelease(v20);
        CFRelease(v18);
        v28 = *(__CFArray **)(a3 + 80);
        if (v28)
          CFArrayAppendValue(v28, a2);
      }
    }
  }
  return v6;
}

uint64_t mapTextLineToHTML(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  int OverlappingRange;
  __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  __CFString *Mutable;
  const __CFString *v11;
  CFIndex Length;
  CFIndex v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t Range;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  CFMutableStringRef v34;
  CFIndex v35;
  _DWORD *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  _BOOL4 v40;
  double *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  BOOL v45;
  uint64_t v46;
  __CFString *CSS;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  uint64_t v56;
  double *v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  int CharacterAtIndex;
  uint64_t NodeContainingTextRange;
  uint64_t v65;
  __CFString *v66;
  char *v67;
  const __CFString *v68;
  __CFString *theString;
  char v70;
  unint64_t v71;
  uint64_t TextRange;
  uint64_t v73;
  __CFString *v74;
  double *v75;
  UniChar chars;
  int v77;
  int *v78;
  CFRange v79;

  v4 = a2;
  OverlappingRange = findOverlappingRange(a2, a3);
  if (OverlappingRange > 0)
    return 1;
  if (OverlappingRange < 0)
    return 0;
  v6 = (__CFString *)a3[7];
  if (*(_BYTE *)(*a3 + 72))
  {
    TextRange = CGPDFNodeGetTextRange(v4);
    if (v7)
    {
      v8 = v7;
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      if (Mutable)
      {
        v11 = Mutable;
        v78 = 0;
        v77 = 0;
        CPTextServicesAppendTextLine(Mutable, (_QWORD *)*a3, TextRange, v8, &v78, &v77);
        Length = CFStringGetLength(v11);
        if (Length >= v77)
          v13 = v77;
        else
          v13 = Length;
        if (v13 >= 1)
        {
          v68 = v11;
          v66 = v6;
          v14 = a3[2];
          v15 = CGPDFNodeGetTextRange(v4);
          v17 = v16;
          v18 = a3[1];
          if (v18)
          {
            if (*(_BYTE *)(v18 + 40))
              CPIndexSetNormalize(a3[1]);
            v19 = *(_QWORD *)(v18 + 16);
          }
          else
          {
            v19 = 0;
          }
          v20 = a3[2];
          v21 = v20 + 1;
          if (v20 + 1 < v19)
          {
            v22 = v15 + v17;
            v23 = v17 <= 0;
            if (v17 <= 0)
              v24 = v15 + v17;
            else
              v24 = v15;
            if (!v23)
              v15 = v22;
            do
            {
              Range = CPIndexSetGetRange(a3[1], v21);
              v27 = Range + v26;
              if (v26 <= 0)
                v28 = Range + v26;
              else
                v28 = Range;
              if (v26 <= 0)
                v27 = Range;
              if (v27 > v24 && v15 <= v28)
                break;
              if (v27 > v24 && v15 > v28)
              {
                a3[2] = v21;
                a3[3] = Range;
                a3[4] = v26;
              }
              ++v21;
            }
            while (v19 != v21);
            v20 = a3[2];
          }
          v71 = v20 - v14;
          v31 = v20 - v14 + 1;
          v67 = (char *)malloc_type_malloc(16 * v31, 0x1000040451B5BE8uLL);
          if (v31 >= 2)
          {
            v32 = v67 + 8;
            do
            {
              *(v32 - 1) = CPIndexSetGetRange(a3[1], v14);
              *v32 = v33;
              ++v14;
              v32 += 2;
            }
            while (v20 != v14);
          }
          *(_OWORD *)&v67[16 * v71] = *(_OWORD *)(a3 + 3);
          theString = (__CFString *)a3[7];
          v34 = CFStringCreateMutable(v9, v13);
          v35 = 0;
          v74 = v34;
          v75 = 0;
          v70 = 0;
          v36 = 0;
          if (v31 <= 1)
            v37 = 1;
          else
            v37 = v31;
          v38 = (uint64_t)v34;
          v73 = v37;
          v39 = v71;
          while (1)
          {
            if (v35 < v13)
            {
              v41 = 0;
              v40 = 0;
              v42 = TextRange + v78[v35];
              v43 = *a3;
              if (*a3 && (v42 & 0x8000000000000000) == 0)
              {
                if (*(_QWORD *)(v43 + 48) > v42 && (v44 = *(_QWORD *)(v43 + 24)) != 0)
                {
                  v41 = *(double **)(v44 + 24 * v42 + 8);
                  v40 = v41 != 0;
                  v45 = v41 == v75 || v41 == 0;
                  if (!v45)
                  {
                    v40 = 1;
                    if (!v38)
                      goto LABEL_58;
LABEL_57:
                    v38 = CFStringGetLength((CFStringRef)v38);
                    if (v38 <= 0 && !v36)
                      goto LABEL_79;
LABEL_58:
                    if (!v75)
                      goto LABEL_69;
                    v46 = a3[5];
                    if (v46)
                    {
                      if ((CGPDFTextStyleEqualToPDFTextStyle((uint64_t)v75, v46) & 1) != 0)
                      {
                        if ((v70 & 1) == 0)
                        {
                          v70 = 0;
                          goto LABEL_69;
                        }
                      }
                      else
                      {
                        CFStringAppendFormat(theString, 0, CFSTR("</%@>"), CFSTR("span"));
                      }
                    }
                    a3[5] = (uint64_t)v75;
                    CSS = CGPDFTextStyleCreateCSS(v75);
                    startTagWithAttributes(theString, CFSTR("span"), 0, v48, v49, v50, v51, v52, (uint64_t)CFSTR("style"), (uint64_t)CSS);
                    v53 = CSS;
                    v39 = v71;
                    CFRelease(v53);
                    v70 = 1;
LABEL_69:
                    if (v38 >= 1)
                    {
                      v54 = CGPDFCopyStringEscapingElementMarkup(v74);
                      if (v54)
                      {
                        v55 = v54;
                        CFStringAppend(theString, v54);
                        CFRelease(v55);
                      }
                      v79.location = 0;
                      v79.length = v38;
                      CFStringDelete(v74, v79);
                      v39 = v71;
                    }
                    if (v36)
                    {
                      v56 = 1;
                      v38 = (uint64_t)v74;
                      while (kCGPDFNodeTypeOrder[v56] != *v36)
                      {
                        if (++v56 == 12)
                        {
                          LODWORD(v56) = 0;
                          break;
                        }
                      }
                      ((void (*)(_QWORD, _DWORD *, uint64_t *))htmlFuncArray[v56])(0, v36, a3);
                    }
                    else
                    {
LABEL_79:
                      v38 = (uint64_t)v74;
                    }
                    v57 = v75;
                    if (v40)
                      v57 = v41;
                    v75 = v57;
                    goto LABEL_83;
                  }
                }
                else
                {
                  v40 = 0;
                  v41 = 0;
                }
              }
            }
            else
            {
              v40 = 0;
              v41 = 0;
              v42 = -1;
            }
            if (v35 == v13 || v36)
            {
              if (v38)
                goto LABEL_57;
              goto LABEL_58;
            }
LABEL_83:
            v36 = 0;
            if (v39 <= 0x7FFFFFFFFFFFFFFELL)
            {
              v59 = v67 + 8;
              v58 = v73;
              if (v35 < v13)
              {
                while (1)
                {
                  v60 = *(v59 - 1);
                  if (v60 <= v42 && v42 < *v59 + v60)
                    break;
                  v59 += 2;
                  if (!--v58)
                  {
                    v36 = 0;
                    goto LABEL_98;
                  }
                }
                chars = 0;
                CharacterAtIndex = CFStringGetCharacterAtIndex(v68, v35);
                chars = CharacterAtIndex;
                if (CharacterAtIndex == 65532)
                {
                  NodeContainingTextRange = CGPDFNodeGetNodeContainingTextRange(v4, v42, 1);
                  if (CGPDFNodeIsInlineContainer(NodeContainingTextRange))
                  {
                    v70 = 0;
                    v36 = *(_DWORD **)(NodeContainingTextRange + 64);
                  }
                  else
                  {
                    v36 = 0;
                    v70 = 0;
                  }
                }
                else
                {
                  if (v38)
                    CFStringAppendCharacters((CFMutableStringRef)v38, &chars, 1);
                  v36 = 0;
                }
              }
            }
LABEL_98:
            v45 = v35++ == v13;
            if (v45)
            {
              if (v38)
                CFRelease((CFTypeRef)v38);
              free(v67);
              v6 = v66;
              v11 = v68;
              break;
            }
          }
        }
        free(v78);
        CFRelease(v11);
        if (!v4)
          goto LABEL_120;
        goto LABEL_105;
      }
    }
  }
  else
  {
    CGPDFNodeMapByType(v4, (uint64_t)htmlFuncArray);
  }
  if (v4)
  {
LABEL_105:
    v65 = v4;
    while (*(_DWORD *)v65 != 514)
    {
      v65 = *(_QWORD *)(v65 + 8);
      if (!v65)
        goto LABEL_120;
    }
    if (*(_BYTE *)(v65 + 104))
    {
      while (*(_DWORD *)v4 != 1537)
      {
        v4 = *(_QWORD *)(v4 + 8);
        if (!v4)
          goto LABEL_119;
      }
      if (*(double *)(v4 + 112) != 0.0)
        goto LABEL_120;
LABEL_119:
      startTag(v6, CFSTR("br"), 1);
    }
  }
LABEL_120:
  CFStringAppend(v6, CFSTR("\n"));
  return 1;
}

uint64_t mapParagraphToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange;
  __CFString *v6;
  const __CFString *v7;
  uint64_t v8;

  OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  mapListToHTML(OverlappingRange, a2, (uint64_t *)a3);
  if (OverlappingRange <= 0)
  {
    if (OverlappingRange < 0)
      return 0;
    v6 = *(__CFString **)(a3 + 56);
    startIndent(v6, (int *)(a3 + 64));
    v7 = CFSTR("p");
    if (a2)
    {
      v8 = a2;
      while (*(_DWORD *)v8 != 1537)
      {
        v8 = *(_QWORD *)(v8 + 8);
        if (!v8)
          goto LABEL_11;
      }
      if (*(double *)(v8 + 112) != 0.0)
        v7 = CFSTR("pre");
    }
LABEL_11:
    startTag(v6, v7, 0);
    CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    if (*(_QWORD *)(a3 + 40))
    {
      CFStringAppendFormat(v6, 0, CFSTR("</%@>"), CFSTR("span"));
      *(_QWORD *)(a3 + 40) = 0;
    }
    CFStringAppendFormat(v6, 0, CFSTR("</%@>"), v7);
    --*(_DWORD *)(a3 + 64);
  }
  return 1;
}

uint64_t mapColumnToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange;
  __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  if (OverlappingRange > 0)
    return 1;
  if ((OverlappingRange & 0x80000000) == 0)
  {
    v6 = *(__CFString **)(a3 + 56);
    startIndent(v6, (int *)(a3 + 64));
    startTagWithAttributes(v6, CFSTR("div"), 0, v7, v8, v9, v10, v11, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("column"));
    CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    mapListToHTML(-1, 0, (uint64_t *)a3);
    endIndent(v6, (int *)(a3 + 64));
    CFStringAppendFormat(v6, 0, CFSTR("</%@>"), CFSTR("div"));
    return 1;
  }
  return 0;
}

uint64_t mapLayoutAreaToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange;
  __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  if (OverlappingRange > 0)
    return 1;
  if ((OverlappingRange & 0x80000000) == 0)
  {
    v6 = *(__CFString **)(a3 + 56);
    startIndent(v6, (int *)(a3 + 64));
    startTagWithAttributes(v6, CFSTR("div"), 0, v7, v8, v9, v10, v11, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("layoutArea"));
    CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    endIndent(v6, (int *)(a3 + 64));
    CFStringAppendFormat(v6, 0, CFSTR("</%@>"), CFSTR("div"));
    return 1;
  }
  return 0;
}

uint64_t mapSectionToHTML(int a1, uint64_t a2, uint64_t a3)
{
  int *v5;
  int v6;
  int OverlappingRange;
  __CFString *v8;
  const __CFAllocator *v9;
  __CFString *Mutable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t BackgroundColor;
  uint64_t v20;
  unint64_t v21;
  uint64_t TableCellRowSpan;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  __CFString *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __CFString *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFString *v44;
  __CFString *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v52;
  _BOOL4 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _BOOL4 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  __CFString *v65;
  const __CFAllocator *v66;
  __CFString *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  __CFString *v77;
  const __CFString *v78;
  uint64_t i;
  double TableCellBorderBounds;
  double v81;
  double v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t TableCellBorderColor;
  CFStringRef v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  CFStringRef v95;
  __CFString *v97;
  __CFString *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  __CFString *v104;
  __CFString *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __CFString *v111;
  const __CFString *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _DWORD *v119;
  uint64_t v120;
  double v121;
  double *v122;
  CFStringRef v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t TableCellColumnSpan;
  uint64_t v130;
  _BOOL4 v131;
  uint64_t v132;
  void *v133;
  double *v134;

  if (!a2)
  {
    if (*(_QWORD *)(a3 + 72))
    {
LABEL_20:
      v21 = 0;
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if ((*(_BYTE *)(a2 + 1) & 4) != 0)
  {
    v5 = *(int **)(a2 + 104);
    if (v5)
    {
      v6 = *v5;
      if (v6 == 3)
      {
        OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
        if (OverlappingRange <= 0)
        {
          if ((OverlappingRange & 0x80000000) == 0)
          {
            v8 = *(__CFString **)(a3 + 56);
            v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
            CFStringAppend(Mutable, CFSTR("border-collapse: collapse"));
            if (*(_QWORD *)(a3 + 72) == a2)
            {
              BackgroundColor = CGPDFNodeGetBackgroundColor(a2);
            }
            else
            {
              v17 = a2;
              while (1)
              {
                if (*(_DWORD *)v17 == 1538)
                {
                  v18 = *(_QWORD *)(v17 + 104);
                  if (v18)
                  {
                    if (*(_DWORD *)v18 == 3)
                      break;
                  }
                }
                v17 = *(_QWORD *)(v17 + 8);
                if (!v17)
                {
                  BackgroundColor = 0;
                  goto LABEL_120;
                }
              }
              BackgroundColor = *(_QWORD *)(v18 + 48);
            }
LABEL_120:
            v111 = CGPDFCreateColorValueCSS(BackgroundColor, 1, v11, v12, v13, v14, v15, v16);
            if (v111)
            {
              v112 = v111;
              CFStringAppend(Mutable, CFSTR("; background-color: "));
              CFStringAppend(Mutable, v112);
              CFRelease(v112);
            }
            startIndent(v8, (int *)(a3 + 64));
            startTagWithAttributes(v8, CFSTR("table"), 0, v113, v114, v115, v116, v117, (uint64_t)CFSTR("style"), (uint64_t)Mutable);
            CFRelease(Mutable);
            v118 = a2;
            while (1)
            {
              if (*(_DWORD *)v118 == 1538)
              {
                v119 = *(_DWORD **)(v118 + 104);
                if (v119)
                {
                  if (*v119 == 3)
                    break;
                }
              }
              v118 = *(_QWORD *)(v118 + 8);
              if (!v118)
                goto LABEL_127;
            }
            v120 = v119[4];
            if (v120 >= 2)
            {
              v134 = (double *)malloc_type_calloc((v120 + 1), 8uLL, 0x100004000313F17uLL);
              if (CGPDFNodeGetTableColumnDividerPositions(a2, v134))
              {
                v121 = 100.0 / (v134[v120] - *v134);
                v122 = v134 + 1;
                do
                {
                  v123 = CFStringCreateWithFormat(v9, 0, CFSTR("width: %f%%"), v121 * (*v122 - *(v122 - 1)));
                  startTagWithAttributes(v8, CFSTR("col"), 1, v124, v125, v126, v127, v128, (uint64_t)CFSTR("style"), (uint64_t)v123);
                  CFRelease(v123);
                  ++v122;
                  --v120;
                }
                while (v120);
              }
              free(v134);
            }
LABEL_127:
            CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
            endIndent(v8, (int *)(a3 + 64));
            CFStringAppendFormat(v8, 0, CFSTR("</%@>"), CFSTR("table"));
            return 1;
          }
          return 0;
        }
        return 1;
      }
      if (*(_QWORD *)(a3 + 72) != a2)
      {
        if (v6 == 2)
        {
          TableCellRowSpan = CGPDFNodeGetTableCellRowSpan(a2);
          v25 = v24;
          TableCellColumnSpan = CGPDFNodeGetTableCellColumnSpan(a2);
          v130 = v26;
          v27 = *(_QWORD *)(a2 + 8);
          if (v27 && (*(_BYTE *)(v27 + 1) & 2) != 0)
            v28 = *(_DWORD *)(v27 + 44);
          else
            v28 = 0;
          v52 = a1 + 1;
          if (a1)
          {
            if (TableCellRowSpan != 0x7FFFFFFFFFFFFFFFLL || v25)
            {
              if (v27 && (*(_BYTE *)(v27 + 1) & 2) != 0 && *(_DWORD *)(v27 + 44) > (a1 - 1))
                v54 = *(_QWORD *)(*(_QWORD *)(v27 + 56) + 8 * (a1 - 1));
              else
                v54 = 0;
              v55 = CGPDFNodeGetTableCellRowSpan(v54);
              v53 = (v55 != 0x7FFFFFFFFFFFFFFFLL || v56 != 0) && v55 < TableCellRowSpan;
            }
            else
            {
              v53 = 0;
            }
          }
          else
          {
            v53 = 1;
          }
          if (v52 >= v28)
          {
            v59 = 1;
          }
          else
          {
            if (TableCellRowSpan == 0x7FFFFFFFFFFFFFFFLL && !v25)
            {
              v131 = 0;
              goto LABEL_83;
            }
            if (v27 && (*(_BYTE *)(v27 + 1) & 2) != 0 && *(_DWORD *)(v27 + 44) > v52)
              v60 = *(_QWORD *)(*(_QWORD *)(v27 + 56) + 8 * v52);
            else
              v60 = 0;
            v61 = CGPDFNodeGetTableCellRowSpan(v60);
            v59 = (v61 != 0x7FFFFFFFFFFFFFFFLL || v62 != 0) && TableCellRowSpan < v61;
          }
          v131 = v59;
LABEL_83:
          v132 = TableCellRowSpan;
          v65 = *(__CFString **)(a3 + 56);
          if (v53)
          {
            startIndent(*(__CFString **)(a3 + 56), (int *)(a3 + 64));
            startTag(v65, CFSTR("tr"), 0);
          }
          v66 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v67 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
          CFStringAppend(v67, CFSTR("border-style: solid"));
          v74 = a2;
          while (1)
          {
            if (*(_DWORD *)v74 == 1538)
            {
              v75 = *(_QWORD *)(v74 + 104);
              if (v75)
              {
                if (*(_DWORD *)v75 == 2)
                  break;
              }
            }
            v74 = *(_QWORD *)(v74 + 8);
            if (!v74)
            {
              v76 = 0;
              goto LABEL_92;
            }
          }
          v76 = *(_QWORD *)(v75 + 48);
LABEL_92:
          v133 = v25;
          v77 = CGPDFCreateColorValueCSS(v76, 1, v68, v69, v70, v71, v72, v73);
          if (v77)
          {
            v78 = v77;
            CFStringAppend(v67, CFSTR("; background-color: "));
            CFStringAppend(v67, v78);
            CFRelease(v78);
          }
          for (i = 0; i != 4; ++i)
          {
            TableCellBorderBounds = CGPDFNodeGetTableCellBorderBounds(a2, i);
            v82 = v81;
            v84 = v83;
            v86 = v85;
            TableCellBorderColor = CGPDFNodeGetTableCellBorderColor(a2, i);
            v88 = CFStringCreateWithFormat(v66, 0, CFSTR("border-%s-"), kCGPDFNodeSideCSSMap[i]);
            v95 = v88;
            if (TableCellBorderBounds != INFINITY && v82 != INFINITY)
            {
              switch((int)i)
              {
                case 0:
                case 2:
                  v84 = v86;
                  break;
                case 1:
                case 3:
                  break;
                default:
                  v84 = 0;
                  break;
              }
              CFStringAppendFormat(v67, 0, CFSTR("; %@width: %fpt"), v88, v84);
            }
            if (TableCellBorderColor)
            {
              v97 = CGPDFCreateColorValueCSS(TableCellBorderColor, 1, v89, v90, v91, v92, v93, v94);
              if (v97)
              {
                v98 = v97;
                CFStringAppendFormat(v67, 0, CFSTR("; %@color: %@"), v95, v97);
                CFRelease(v98);
              }
            }
            CFRelease(v95);
          }
          startIndent(v65, (int *)(a3 + 64));
          if (v132 == 0x7FFFFFFFFFFFFFFFLL && !v133
            || TableCellColumnSpan == 0x7FFFFFFFFFFFFFFFLL && !v130
            || v133 == (void *)1 && v130 == 1)
          {
            startTagWithAttributes(v65, CFSTR("td"), 0, v99, v100, v101, v102, v103, (uint64_t)CFSTR("style"), (uint64_t)v67);
          }
          else
          {
            v104 = CFStringCreateMutable(v66, 0);
            CFStringAppendFormat(v104, 0, CFSTR("%i"), v133);
            v105 = CFStringCreateMutable(v66, 0);
            CFStringAppendFormat(v105, 0, CFSTR("%i"), v130);
            startTagWithAttributes(v65, CFSTR("td"), 0, v106, v107, v108, v109, v110, (uint64_t)CFSTR("rowspan"), (uint64_t)v104);
            CFRelease(v105);
            CFRelease(v104);
          }
          CFRelease(v67);
          if (!findOverlappingRange(a2, (uint64_t *)a3))
            CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
          endIndent(v65, (int *)(a3 + 64));
          CFStringAppendFormat(v65, 0, CFSTR("</%@>"), CFSTR("td"));
          if (v131)
          {
            endIndent(v65, (int *)(a3 + 64));
            CFStringAppendFormat(v65, 0, CFSTR("</%@>"), CFSTR("tr"));
          }
          return 1;
        }
        goto LABEL_15;
      }
LABEL_27:
      v21 = CGPDFNodeGetBackgroundColor(a2);
      goto LABEL_28;
    }
  }
  if (*(_QWORD *)(a3 + 72) == a2)
    goto LABEL_27;
LABEL_15:
  v20 = a2;
  while (*(_DWORD *)v20 != 1538)
  {
    v20 = *(_QWORD *)(v20 + 8);
    if (!v20)
      goto LABEL_20;
  }
  v21 = *(_QWORD *)(v20 + 112);
LABEL_28:
  v29 = findOverlappingRange(a2, (uint64_t *)a3);
  if (v29 <= 0)
  {
    if (v29 < 0)
      return 0;
    v30 = *(__CFString **)(a3 + 56);
    if (a2 && (v31 = *(_QWORD *)(a2 + 8)) != 0 && (*(_BYTE *)(v31 + 1) & 2) != 0 && *(_DWORD *)(v31 + 44) == 1 && !v21)
    {
      CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    }
    else
    {
      startIndent(*(__CFString **)(a3 + 56), (int *)(a3 + 64));
      v38 = CGPDFCreateColorValueCSS(v21, 0, v32, v33, v34, v35, v36, v37);
      if (v38)
      {
        v44 = v38;
        v45 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
        CFStringAppend(v45, CFSTR("background-color: "));
        CFStringAppend(v45, v44);
        CFRelease(v44);
        startTagWithAttributes(v30, CFSTR("div"), 0, v46, v47, v48, v49, v50, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("section"));
        CFRelease(v45);
      }
      else
      {
        startTagWithAttributes(v30, CFSTR("div"), 0, v39, v40, v41, v42, v43, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("section"));
      }
      CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
      endIndent(v30, (int *)(a3 + 64));
      CFStringAppendFormat(v30, 0, CFSTR("</%@>"), CFSTR("div"));
    }
  }
  return 1;
}

uint64_t mapPageToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange;
  __CFString *v6;
  uint64_t v7;
  CFStringRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v17;
  uint64_t v18;

  OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  if (OverlappingRange <= 0)
  {
    if (OverlappingRange < 0)
      return 0;
    v6 = *(__CFString **)(a3 + 56);
    v7 = *(_QWORD *)a3;
    if (*(_QWORD *)a3)
    {
      v7 = *(_QWORD *)(v7 + 16);
      if (v7)
        v7 = *(unsigned int *)(*(_QWORD *)(v7 + 40) + 8);
    }
    v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Page %u"), v7);
    startIndent(v6, (int *)(a3 + 64));
    startTagWithAttributes(v6, CFSTR("div"), 0, v9, v10, v11, v12, v13, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("page"));
    CFRelease(v8);
    v14 = *(int **)(a3 + 72);
    if (v14 == (int *)a2)
    {
      CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    }
    else
    {
      if (v14)
        v15 = *v14;
      else
        v15 = 0;
      v17 = 1;
      while (kCGPDFNodeTypeOrder[v17] != v15)
      {
        if (++v17 == 12)
        {
          v18 = 0;
          goto LABEL_17;
        }
      }
      v18 = v17;
LABEL_17:
      ((void (*)(_QWORD))htmlFuncArray[v18])(0);
    }
    endIndent(v6, (int *)(a3 + 64));
    CFStringAppendFormat(v6, 0, CFSTR("</%@>"), CFSTR("div"));
  }
  return 1;
}

uint64_t findOverlappingRange(uint64_t a1, uint64_t *a2)
{
  uint64_t TextRange;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  _BOOL4 v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t Range;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  TextRange = CGPDFNodeGetTextRange(a1);
  v5 = v4;
  v6 = a2[1];
  if (v6)
  {
    if (*(_BYTE *)(v6 + 40))
      CPIndexSetNormalize(a2[1]);
    v6 = *(_QWORD *)(v6 + 16);
  }
  v7 = a2[3];
  v8 = a2[4];
  v9 = v7 + v8;
  v10 = v8 <= 0;
  if (v8 <= 0)
    v11 = v7 + v8;
  else
    v11 = a2[3];
  if (!v10)
    v7 = v9;
  v12 = TextRange + v5;
  v13 = v5 <= 0;
  if (v5 <= 0)
    v14 = TextRange + v5;
  else
    v14 = TextRange;
  if (!v13)
    TextRange = v12;
  v15 = TextRange <= v11;
  if (v7 <= v14)
    result = 0xFFFFFFFFLL;
  else
    result = v15;
  if (v7 <= v14)
  {
    do
    {
      v17 = a2[2] + 1;
      if (v17 >= v6)
        return 0xFFFFFFFFLL;
      v18 = a2[1];
      a2[2] = v17;
      Range = CPIndexSetGetRange(v18, v17);
      a2[3] = Range;
      a2[4] = v20;
      v21 = Range + v20;
      if (v20 <= 0)
        v22 = Range;
      else
        v22 = Range + v20;
    }
    while (v22 <= v14);
    if (v20 > 0)
      v21 = Range;
    return TextRange <= v21;
  }
  return result;
}

__CFString *CGPDFCreateColorValueCSS(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  CGColorSpaceRef ColorSpace;
  int v11;
  float64x2_t *Components;
  float64x2_t v13;
  double v14;
  double v15;
  double v16;
  float64_t v22;
  __CFString *Mutable;
  double v25;
  float64_t v26;

  if (!a1)
    return 0;
  v8 = a2;
  if ((a1 & 0x8000000000000000) != 0)
  {
    ColorSpace = CGTaggedColorGetColorSpace(a1, a2, a3, a4, a5, a6, a7, a8);
    if (ColorSpace)
      goto LABEL_4;
LABEL_9:
    CGColorGetComponents((CGColorRef)a1);
    return 0;
  }
  ColorSpace = *(CGColorSpaceRef *)(a1 + 24);
  if (!ColorSpace)
    goto LABEL_9;
LABEL_4:
  v11 = *(_DWORD *)(*((_QWORD *)ColorSpace + 3) + 24);
  Components = (float64x2_t *)CGColorGetComponents((CGColorRef)a1);
  if (v11)
  {
    if (v11 == 2)
    {
      v16 = 1.0 - Components[1].f64[1];
      __asm { FMOV            V4.2D, #1.0 }
      v13 = vmulq_f64(vmulq_n_f64(vsubq_f64(_Q4, *Components), v16), (float64x2_t)vdupq_n_s64(0x4059000000000000uLL));
      v14 = v16 * (1.0 - Components[1].f64[0]);
    }
    else
    {
      if (v11 != 1)
        return 0;
      v13 = vmulq_f64(*Components, (float64x2_t)vdupq_n_s64(0x4059000000000000uLL));
      v14 = Components[1].f64[0];
    }
    v15 = v14 * 100.0;
  }
  else
  {
    v15 = Components->f64[0] * 100.0;
    v13 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v15, 0);
  }
  v22 = v13.f64[1];
  if ((v8 & 1) != 0 || v13.f64[0] != 0.0 || v13.f64[1] != 0.0 || v15 != 0.0)
  {
    v25 = v15;
    v26 = v13.f64[0];
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    CFStringAppendFormat(Mutable, 0, CFSTR("rgb(%f%%, %f%%, %f%%)"), *(_QWORD *)&v26, *(_QWORD *)&v22, *(_QWORD *)&v25);
    return Mutable;
  }
  return 0;
}

void mapListToHTML(int a1, uint64_t a2, uint64_t *a3)
{
  __CFString *v4;
  uint64_t v5;
  uint64_t *v6;
  int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int ItemParagraphCount;
  uint64_t *v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  const __CFString *v16;
  _QWORD *v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  int v27;
  const __CFString *v28;
  const __CFAllocator *v29;
  __CFString *Mutable;
  _BOOL4 ItemMarker;
  uint64_t v32;
  _DWORD *v33;
  const __CFString *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  CFStringRef v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t TextRange;
  uint64_t v57;
  double *v58;
  uint64_t v59;
  __CFString *CSS;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t ItemMarkerRange;
  uint64_t v67;
  uint64_t v68;
  int CharacterUnicode;

  v5 = a3[6];
  v4 = (__CFString *)a3[7];
  v6 = a3 + 6;
  if (v5)
  {
    v7 = (int *)(a3 + 8);
    while (1)
    {
      v8 = *(_DWORD *)(v5 + 8);
      v9 = *(_DWORD *)(v5 + 12) + 1;
      *(_DWORD *)(v5 + 12) = v9;
      v10 = *(_QWORD *)v5;
      ItemParagraphCount = CGPDFNodeGetItemParagraphCount(*(_QWORD *)v5, v8);
      if (a1 < 0 || v9 >= ItemParagraphCount)
        break;
LABEL_5:
      v12 = (uint64_t *)(v5 + 24);
LABEL_25:
      v5 = *v12;
      if (!*v12)
        goto LABEL_33;
    }
    if (*(_BYTE *)(v5 + 17))
    {
      endIndent(v4, v7);
      CFStringAppendFormat(v4, 0, CFSTR("</%@>"), CFSTR("li"));
      *(_BYTE *)(v5 + 17) = 0;
      v8 = *(_DWORD *)(v5 + 8);
      v10 = *(_QWORD *)v5;
    }
    else if (*(_BYTE *)(v5 + 16))
    {
      *(_BYTE *)(v5 + 18) = 1;
    }
    *(_QWORD *)(v5 + 8) = v8 + 1;
    if (v10)
    {
      v13 = v10;
      while (1)
      {
        if (*(_DWORD *)v13 == 1537)
        {
          v14 = *(_DWORD **)(v13 + 104);
          if (v14)
          {
            if (*v14 == 1)
              break;
          }
        }
        v13 = *(_QWORD *)(v13 + 8);
        if (!v13)
          goto LABEL_16;
      }
      if ((a1 & 0x80000000) == 0 && v8 + 1 < v14[5])
        goto LABEL_5;
LABEL_16:
      if (!*(_BYTE *)(v5 + 16))
        goto LABEL_24;
      while (1)
      {
        if (*(_DWORD *)v10 == 1537)
        {
          v15 = *(_DWORD **)(v10 + 104);
          if (v15)
          {
            if (*v15 == 1)
              break;
          }
        }
        v10 = *(_QWORD *)(v10 + 8);
        if (!v10)
        {
          v16 = CFSTR("ol");
          goto LABEL_23;
        }
      }
      if (v15[1] == 257)
        v16 = CFSTR("ul");
      else
        v16 = CFSTR("ol");
    }
    else
    {
      v16 = CFSTR("ol");
      if (!*(_BYTE *)(v5 + 16))
      {
LABEL_24:
        *v6 = *(_QWORD *)(v5 + 24);
        free((void *)v5);
        v12 = v6;
        goto LABEL_25;
      }
    }
LABEL_23:
    endIndent(v4, v7);
    CFStringAppendFormat(v4, 0, CFSTR("</%@>"), v16);
    goto LABEL_24;
  }
LABEL_33:
  if ((a1 & 0x80000000) == 0)
  {
    v17 = (_QWORD *)*v6;
    if (!a2)
      goto LABEL_53;
    if ((*(_BYTE *)(a2 + 1) & 4) == 0)
      goto LABEL_53;
    v18 = *(_DWORD **)(a2 + 104);
    if (!v18 || *v18 != 1)
      goto LABEL_53;
    if (!v17)
      goto LABEL_47;
    v19 = a2;
    while (1)
    {
      if (*(_DWORD *)v19 == 1537)
      {
        v20 = *(_QWORD *)(v19 + 104);
        if (v20)
        {
          if (*(_DWORD *)v20 == 1)
            break;
        }
      }
      v19 = *(_QWORD *)(v19 + 8);
      if (!v19)
        goto LABEL_46;
    }
    v19 = *(_QWORD *)(v20 + 8);
LABEL_46:
    if (*v17 != v19)
    {
LABEL_47:
      v21 = malloc_type_calloc(1uLL, 0x20uLL, 0x102004069DB6F06uLL);
      v22 = v21;
      *v6 = (uint64_t)v21;
      v21[3] = v17;
      v23 = a2;
      while (1)
      {
        if (*(_DWORD *)v23 == 1537)
        {
          v24 = *(_QWORD *)(v23 + 104);
          if (v24)
          {
            if (*(_DWORD *)v24 == 1)
              break;
          }
        }
        v23 = *(_QWORD *)(v23 + 8);
        if (!v23)
          goto LABEL_84;
      }
      v23 = *(_QWORD *)(v24 + 8);
LABEL_84:
      *v21 = v23;
      if (a1)
        return;
    }
    else
    {
LABEL_53:
      v22 = (_QWORD *)*v6;
      if (a1)
        return;
    }
    if (v22 && !*((_BYTE *)v22 + 17))
    {
      if (!*((_BYTE *)v22 + 16))
      {
        startIndent(v4, (int *)a3 + 16);
        if (a2)
        {
          v25 = a2;
          while (1)
          {
            if (*(_DWORD *)v25 == 1537)
            {
              v26 = *(_DWORD **)(v25 + 104);
              if (v26)
              {
                if (*v26 == 1)
                  break;
              }
            }
            v25 = *(_QWORD *)(v25 + 8);
            if (!v25)
              goto LABEL_63;
          }
          v27 = v26[1];
        }
        else
        {
LABEL_63:
          v27 = 0;
        }
        if (v27 == 257)
          v28 = CFSTR("ul");
        else
          v28 = CFSTR("ol");
        v29 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
        ItemMarker = CGPDFListCanGenerateItemMarker(a2);
        if (a2 && ItemMarker)
        {
          v32 = a2;
          while (1)
          {
            if (*(_DWORD *)v32 == 1537)
            {
              v33 = *(_DWORD **)(v32 + 104);
              if (v33)
              {
                if (*v33 == 1)
                  break;
              }
            }
            v32 = *(_QWORD *)(v32 + 8);
            if (!v32)
              goto LABEL_74;
          }
          v34 = CFSTR("decimal");
          switch(v33[1])
          {
            case 0x201:
              break;
            case 0x202:
              v34 = CFSTR("decimal-leading-zero");
              break;
            case 0x203:
              v34 = CFSTR("lower-roman");
              break;
            case 0x204:
              v34 = CFSTR("upper-roman");
              break;
            case 0x205:
              v34 = CFSTR("lower-latin");
              break;
            case 0x206:
              v34 = CFSTR("upper-latin");
              break;
            case 0x207:
              v34 = CFSTR("lower-greek");
              break;
            default:
              if (CFSTR("decimal") != 257)
                goto LABEL_74;
              ItemMarkerRange = CGPDFNodeGetItemMarkerRange(a2);
              v67 = a2;
              while (*(_DWORD *)v67 != 517)
              {
                v67 = *(_QWORD *)(v67 + 8);
                if (!v67)
                {
                  v68 = 0;
                  goto LABEL_131;
                }
              }
              v68 = *(_QWORD *)(v67 + 104);
LABEL_131:
              CharacterUnicode = CGPDFLayoutGetCharacterUnicode(v68, ItemMarkerRange);
              v34 = CFSTR("disc");
              if (CharacterUnicode == 9632)
                v34 = CFSTR("square");
              if (CharacterUnicode == 9702)
                v34 = CFSTR("circle");
              break;
          }
        }
        else
        {
LABEL_74:
          v34 = CFSTR("none");
        }
        CFStringAppendFormat(Mutable, 0, CFSTR("list-style-type: %@"), v34);
        if (a2)
        {
          v40 = a2;
          while (1)
          {
            if (*(_DWORD *)v40 == 1537)
            {
              v41 = *(_DWORD **)(v40 + 104);
              if (v41)
              {
                if (*v41 == 1)
                  break;
              }
            }
            v40 = *(_QWORD *)(v40 + 8);
            if (!v40)
              goto LABEL_88;
          }
          v40 = v41[4];
        }
        else
        {
          v40 = 0;
        }
LABEL_88:
        if ((_DWORD)v40 == 1 || v27 == 257)
        {
          startTagWithAttributes(v4, v28, 0, v35, v36, v37, v38, v39, (uint64_t)CFSTR("style"), (uint64_t)Mutable);
        }
        else
        {
          v42 = CFStringCreateWithFormat(v29, 0, CFSTR("%i"), v40);
          startTagWithAttributes(v4, v28, 0, v43, v44, v45, v46, v47, (uint64_t)CFSTR("start"), (uint64_t)v42);
          CFRelease(v42);
        }
        CFRelease(Mutable);
        *((_BYTE *)v22 + 16) = 1;
      }
      startIndent(v4, (int *)a3 + 16);
      if (!CGPDFListCanGenerateItemMarker(a2))
        goto LABEL_115;
      if (!a2)
        goto LABEL_107;
      v53 = a2;
      while (*(_DWORD *)v53 != 1537)
      {
        v53 = *(_QWORD *)(v53 + 8);
        if (!v53)
          goto LABEL_101;
      }
      if (*(double *)(v53 + 112) != 0.0)
      {
        startTagWithAttributes(v4, CFSTR("li"), 0, v48, v49, v50, v51, v52, (uint64_t)CFSTR("style"), (uint64_t)CFSTR("list-style-type: none"));
        goto LABEL_116;
      }
LABEL_101:
      if ((*(_BYTE *)(a2 + 1) & 2) != 0
        && *(_DWORD *)(a2 + 44)
        && (v54 = **(_QWORD **)(a2 + 56)) != 0
        && (*(_BYTE *)(v54 + 1) & 2) != 0
        && *(_DWORD *)(v54 + 44))
      {
        v55 = **(_QWORD **)(v54 + 56);
      }
      else
      {
LABEL_107:
        v55 = 0;
      }
      TextRange = CGPDFNodeGetTextRange(v55);
      if (v57)
      {
        v58 = 0;
        v59 = *a3;
        if (*a3 && (TextRange & 0x8000000000000000) == 0)
        {
          if (*(_QWORD *)(v59 + 48) <= TextRange)
          {
            v58 = 0;
          }
          else
          {
            v58 = *(double **)(v59 + 24);
            if (v58)
              v58 = *(double **)&v58[3 * TextRange + 1];
          }
        }
        CSS = CGPDFTextStyleCreateCSS(v58);
        startTagWithAttributes(v4, CFSTR("li"), 0, v61, v62, v63, v64, v65, (uint64_t)CFSTR("style"), (uint64_t)CSS);
        CFRelease(CSS);
      }
      else
      {
LABEL_115:
        startTag(v4, CFSTR("li"), 0);
      }
LABEL_116:
      *((_BYTE *)v22 + 17) = 1;
    }
  }
}

BOOL CGPDFListCanGenerateItemMarker(_BOOL8 result)
{
  uint64_t v1;
  uint64_t v2;
  _DWORD *v3;
  int v4;
  uint64_t ItemMarkerRange;
  uint64_t v6;
  uint64_t v7;
  uint64_t ItemMarkerSuffixRange;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (result)
  {
    v1 = result;
    v2 = result;
    while (1)
    {
      if (*(_DWORD *)v2 == 1537)
      {
        v3 = *(_DWORD **)(v2 + 104);
        if (v3)
        {
          if (*v3 == 1)
            break;
        }
      }
      v2 = *(_QWORD *)(v2 + 8);
      if (!v2)
        return 0;
    }
    result = 0;
    v4 = v3[1];
    if (v4)
    {
      if (v4 != 520)
      {
        if (v4 != 257)
        {
          CGPDFNodeGetItemMarkerPrefixRange(v1);
          if (v7 <= 0)
          {
            ItemMarkerSuffixRange = CGPDFNodeGetItemMarkerSuffixRange(v1);
            if (v9 == 1)
            {
              v10 = ItemMarkerSuffixRange;
              while (*(_DWORD *)v1 != 517)
              {
                result = 0;
                v1 = *(_QWORD *)(v1 + 8);
                if (!v1)
                  return result;
              }
              result = 0;
              v17 = *(_QWORD *)(v1 + 104);
              if (!v17 || v10 < 0)
                return result;
              if (*(_QWORD *)(v17 + 48) > v10)
              {
                v18 = *(_QWORD *)(v17 + 24);
                if (v18)
                {
                  v19 = *(_QWORD *)(v18 + 24 * v10);
                  if (v19)
                    return *(unsigned __int16 *)(v19 + 8) == 46;
                }
              }
            }
          }
          return 0;
        }
        ItemMarkerRange = CGPDFNodeGetItemMarkerRange(v1);
        if (v6 != 1)
          return 0;
        while (*(_DWORD *)v1 != 517)
        {
          v1 = *(_QWORD *)(v1 + 8);
          if (!v1)
            return 0;
        }
        v11 = *(_QWORD *)(v1 + 104);
        if (!v11)
          return 0;
        if (ItemMarkerRange < 0)
          return 0;
        if (*(_QWORD *)(v11 + 48) <= ItemMarkerRange)
          return 0;
        v12 = *(_QWORD *)(v11 + 24);
        if (!v12)
          return 0;
        v13 = *(_QWORD *)(v12 + 24 * ItemMarkerRange);
        if (!v13)
          return 0;
        v14 = *(unsigned __int16 *)(v13 + 8);
        v15 = v14 == 8226 || v14 == 9632;
        return v15 || v14 == 9702;
      }
    }
  }
  return result;
}

__CFString *CGPDFTextStyleCreateCSS(double *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  const __CFString *v13;
  const __CFString *v14;
  CFIndex Length;
  CFIndex location;
  CFIndex v17;
  CFIndex v18;
  CFRange v19;
  const __CFString *v20;
  const __CFString *v21;
  __CFString *MutableCopy;
  CFRange v23;
  uint64_t v24;
  CFIndex v25;
  CFStringCompareFlags v26;
  const __CFString *v27;
  CFRange v28;
  uint64_t v29;
  CFIndex v30;
  CFStringCompareFlags v31;
  const __CFString *v32;
  int v33;
  const __CFString *v34;
  unint64_t v35;
  __CFString *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const __CFString *v43;
  unint64_t v44;
  __CFString *v45;
  const __CFString *v46;
  CFRange v48;
  CFRange v49;
  CFRange v50;
  CFRange v51;
  CFRange v52;
  CFRange v53;
  CFRange v54;
  CFRange v55;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v4 = Mutable;
  if (a1)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("font-size: %fpt"), *((_QWORD *)a1 + 2));
    v11 = *((_QWORD *)a1 + 1);
    if (!v11)
      goto LABEL_47;
    v12 = *(const char **)(v11 + 32);
    if (!v12)
      goto LABEL_47;
    v13 = CFStringCreateWithCString(v2, v12, 0x8000100u);
    if (!v13)
      goto LABEL_47;
    v14 = v13;
    Length = CFStringGetLength(v13);
    if (Length)
    {
      location = Length;
      if (Length >= 8 && CFStringGetCharacterAtIndex(v14, 6) == 43)
      {
        v17 = 0;
        v18 = 7;
        while (CFStringGetCharacterAtIndex(v14, v17) - 91 > 0xFFFFFFE5)
        {
          if (++v17 == 6)
            goto LABEL_13;
        }
      }
      v18 = 0;
LABEL_13:
      v19 = CFStringFind(v14, CFSTR("-"), 4uLL);
      if (v19.length == 1 && v19.location == CFStringFind(v14, CFSTR("-"), 0).location)
        location = v19.location;
      v48.length = location - v18;
      v48.location = v18;
      v20 = CFStringCreateWithSubstring(v2, v14, v48);
    }
    else
    {
      v20 = CFStringCreateMutable(v2, 0);
    }
    v21 = v20;
    if (v20)
    {
      if (CFStringFind(v20, CFSTR("&"), 0).location == -1
        && CFStringFind(v21, CFSTR("<"), 0).location == -1
        && CFStringFind(v21, CFSTR(">"), 0).location == -1
        && CFStringFind(v21, CFSTR("\""), 0).location == -1
        && CFStringFind(v21, CFSTR("'"), 0).location == -1)
      {
        MutableCopy = (__CFString *)CFRetain(v21);
      }
      else
      {
        MutableCopy = CFStringCreateMutableCopy(v2, 0, v21);
        v51.length = CFStringGetLength(MutableCopy);
        v51.location = 0;
        CFStringFindAndReplace(MutableCopy, CFSTR("&"), CFSTR("&amp;"), v51, 0);
        v52.length = CFStringGetLength(MutableCopy);
        v52.location = 0;
        CFStringFindAndReplace(MutableCopy, CFSTR("<"), CFSTR("&lt;"), v52, 0);
        v53.length = CFStringGetLength(MutableCopy);
        v53.location = 0;
        CFStringFindAndReplace(MutableCopy, CFSTR(">"), CFSTR("&gt;"), v53, 0);
        v54.length = CFStringGetLength(MutableCopy);
        v54.location = 0;
        CFStringFindAndReplace(MutableCopy, CFSTR("\""), CFSTR("&quot;"), v54, 0);
        v55.length = CFStringGetLength(MutableCopy);
        v55.location = 0;
        CFStringFindAndReplace(MutableCopy, CFSTR("'"), CFSTR("&apos;"), v55, 0);
      }
      CFRelease(v21);
      if (MutableCopy)
      {
        CFStringAppendFormat(v4, 0, CFSTR("; font-family: '%@'"), MutableCopy);
        CFRelease(MutableCopy);
      }
    }
    v23 = CFStringFind(v14, CFSTR("-"), 4uLL);
    if (v23.length == 1 && v23.location == CFStringFind(v14, CFSTR("-"), 0).location)
    {
      v24 = 0;
      v25 = CFStringGetLength(v14) - (v23.location + 1);
      while (1)
      {
        v26 = (*((_BYTE *)&kCGPDFFontWeightCSSMap + 8 * v24 + 12) & 1) == 0;
        v27 = CFStringCreateWithCString(v2, (&kCGPDFFontWeightCSSMap)[v24], 0x8000100u);
        v49.location = v23.location + 1;
        v49.length = v25;
        LODWORD(v26) = CFStringFindWithOptions(v14, v27, v49, v26, 0);
        CFRelease(v27);
        if ((_DWORD)v26)
          break;
        v24 += 2;
        if (v24 == 42)
          goto LABEL_35;
      }
      if (LODWORD((&kCGPDFFontWeightCSSMap)[v24 + 1]) != 400)
        CFStringAppendFormat(v4, 0, CFSTR("; font-weight: %u"), LODWORD((&kCGPDFFontWeightCSSMap)[v24 + 1]));
    }
LABEL_35:
    v28 = CFStringFind(v14, CFSTR("-"), 4uLL);
    if (v28.length == 1 && v28.location == CFStringFind(v14, CFSTR("-"), 0).location)
    {
      v29 = 0;
      v30 = CFStringGetLength(v14) - (v28.location + 1);
      while (1)
      {
        v31 = (*((_BYTE *)&kCGPDFFontStyleCSSMap + 8 * v29 + 12) & 1) == 0;
        v32 = CFStringCreateWithCString(v2, (&kCGPDFFontStyleCSSMap)[v29], 0x8000100u);
        v50.location = v28.location + 1;
        v50.length = v30;
        LODWORD(v31) = CFStringFindWithOptions(v14, v32, v50, v31, 0);
        CFRelease(v32);
        if ((_DWORD)v31)
          break;
        v29 += 2;
        if (v29 == 18)
          goto LABEL_46;
      }
      v33 = (int)(&kCGPDFFontStyleCSSMap)[v29 + 1];
      if (v33 == 1)
      {
        v34 = CFSTR("; font-style: italic");
        goto LABEL_45;
      }
      if (v33 == 2)
      {
        v34 = CFSTR("; font-style: oblique");
LABEL_45:
        CFStringAppend(v4, v34);
      }
    }
LABEL_46:
    CFRelease(v14);
LABEL_47:
    v35 = *((_QWORD *)a1 + 3);
    goto LABEL_48;
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("font-size: %fpt"), 0);
  v35 = 0;
LABEL_48:
  v36 = CGPDFCreateColorValueCSS(v35, 0, v5, v6, v7, v8, v9, v10);
  if (v36)
  {
    v43 = v36;
    CFStringAppend(v4, CFSTR("; color: "));
    CFStringAppend(v4, v43);
    CFRelease(v43);
  }
  if (a1)
    v44 = *((_QWORD *)a1 + 4);
  else
    v44 = 0;
  v45 = CGPDFCreateColorValueCSS(v44, 1, v37, v38, v39, v40, v41, v42);
  if (v45)
  {
    v46 = v45;
    CFStringAppend(v4, CFSTR("; background-color: "));
    CFStringAppend(v4, v46);
    CFRelease(v46);
  }
  if (a1 && a1[6] != 0.0)
    CFStringAppendFormat(v4, 0, CFSTR("; vertical-align: %fpt"), *((_QWORD *)a1 + 6));
  return v4;
}

uint64_t getWordRangeIncludingWhitespace(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t TextRange;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFString *StringForRanges;
  CFMutableStringRef MutableCopy;
  uint64_t v18;
  uint64_t v19;

  TextRange = CGPDFNodeGetTextRange(a2);
  v8 = v7;
  v18 = TextRange;
  v19 = v7;
  if (a2)
  {
    v9 = *(_QWORD *)(a2 + 8);
    if (v9)
    {
      v10 = v9;
      while (*(_DWORD *)v10 != 1537)
      {
        v10 = *(_QWORD *)(v10 + 8);
        if (!v10)
          goto LABEL_17;
      }
      if (*(double *)(v10 + 112) != 0.0)
      {
        if (a1)
        {
          if ((*(_BYTE *)(v9 + 1) & 2) != 0 && *(_DWORD *)(v9 + 44) > (a1 - 1))
            v11 = *(_QWORD *)(*(_QWORD *)(v9 + 56) + 8 * (a1 - 1));
          else
            v11 = 0;
          v12 = CGPDFNodeGetTextRange(v11);
          v14 = v13 + v12 + 1;
        }
        else
        {
          v14 = CGPDFNodeGetTextRange(v9);
        }
        if (TextRange > v14)
        {
          v18 = v14;
          v19 = TextRange - v14 + v8;
          TextRange = v14;
        }
      }
LABEL_17:
      if ((*(_BYTE *)(v9 + 1) & 2) != 0 && (a1 + 1) < *(_DWORD *)(v9 + 44))
      {
        StringForRanges = CGPDFLayoutCreateStringForRanges(*a3, (uint64_t)&v18, 1);
        MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, StringForRanges);
        CFStringTrimWhitespace(MutableCopy);
        CFStringGetLength(MutableCopy);
        CFRelease(MutableCopy);
        CFRelease(StringForRanges);
        return v18;
      }
    }
  }
  return TextRange;
}

uint64_t computeATRRecord(uint64_t result, int *a2, int a3, int a4)
{
  float32x2_t *v4;
  int v5;
  float64x2_t v6;
  int v7;
  double v8;
  float v9;
  float v10;
  float32x2_t *v11;
  float v12;
  float v13;
  float64x2_t v14;
  float32x2_t v15;
  _DWORD *v16;
  float v17;
  __int32 *v18;
  __int32 v19;
  float v20;
  int v21;

  v4 = (float32x2_t *)*((_QWORD *)a2 + 1);
  v5 = *a2;
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 64) = 0;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  v6 = 0uLL;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  if (a4 >= 1)
  {
    v7 = 0;
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    v11 = &v4[a3];
    v12 = 0.0;
    v13 = 0.0;
    v14 = 0uLL;
    while (1)
    {
      v15 = *v11;
      if (!v7)
      {
        *(_DWORD *)(result + 56) = v15.i32[0];
        *(float32x2_t *)(result + 64) = v15;
        v18 = (__int32 *)(result + 60);
        v19 = v15.i32[1];
        v20 = v15.f32[1];
        v12 = v15.f32[1];
        v10 = v15.f32[0];
        v9 = v15.f32[0];
LABEL_12:
        *v18 = v19;
        v13 = v20;
        goto LABEL_13;
      }
      if (v15.f32[0] >= v9)
      {
        v16 = (_DWORD *)(result + 64);
        LODWORD(v17) = *(float32x2_t *)v11->f32;
        if (v15.f32[0] <= v10)
          goto LABEL_9;
      }
      else
      {
        v16 = (_DWORD *)(result + 56);
        v17 = v10;
        LODWORD(v9) = *(float32x2_t *)v11->f32;
      }
      *v16 = v15.i32[0];
      v10 = v17;
LABEL_9:
      v19 = v15.i32[1];
      if (v15.f32[1] < v12)
      {
        v18 = (__int32 *)(result + 60);
        v20 = v13;
        v12 = v15.f32[1];
        goto LABEL_12;
      }
      v18 = (__int32 *)(result + 68);
      v20 = v15.f32[1];
      if (v15.f32[1] > v13)
        goto LABEL_12;
LABEL_13:
      v6 = vaddq_f64(v6, vcvtq_f64_f32(v15));
      v14 = vaddq_f64(v14, vcvtq_f64_f32(vmul_f32(v15, v15)));
      v8 = v8 + vmul_lane_f32(v15, v15, 1).f32[0];
      v21 = a3 + 1;
      ++v11;
      if (a3 + 1 < v5)
        ++a3;
      else
        a3 = 0;
      if (v21 >= v5)
        v11 = v4;
      if (a4 == ++v7)
      {
        *(float64x2_t *)(result + 16) = v6;
        *(float64x2_t *)(result + 32) = v14;
        *(double *)(result + 48) = v8;
        return result;
      }
    }
  }
  return result;
}

uint64_t ATRLinearRegression(uint64_t a1, BOOL *a2, float *a3, float *a4)
{
  double v4;
  double v5;
  double v6;
  double v7;
  float v8;
  double v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v19;

  v4 = (float)(1.0 / (float)*(int *)(a1 + 12));
  v6 = *(double *)(a1 + 16);
  v5 = *(double *)(a1 + 24);
  v7 = v5 * v4;
  v8 = v5 * v4;
  v9 = v6 * v4;
  v10 = *(float *)(a1 + 64) - *(float *)(a1 + 56);
  v11 = v9;
  v12 = *(float *)(a1 + 68) - *(float *)(a1 + 60);
  if (v10 <= v12)
  {
    v17 = *(double *)(a1 + 40) - v7 * v5;
    if (v17 != 0.0)
    {
      v19 = *(double *)(a1 + 48) - v9 * v5;
      v15 = v19 / v17;
      v16 = v11 - (float)(v15 * v8);
      goto LABEL_7;
    }
    return 0;
  }
  v13 = *(double *)(a1 + 32) - v9 * v6;
  if (v13 == 0.0)
    return 0;
  v14 = *(double *)(a1 + 48) + -v9 * v5;
  v15 = v14 / v13;
  v16 = v8 - (float)(v15 * v11);
LABEL_7:
  *a2 = v10 > v12;
  *a3 = v16;
  *a4 = v15;
  return 1;
}

float ATRMaxDistanceFromLine(_DWORD *a1, int a2, float a3, float a4)
{
  int v4;
  uint64_t v5;
  float v6;
  int v7;
  float v8;
  float *v9;
  float *v10;
  float v11;

  v4 = a1[3];
  if (v4 < 1)
    return 0.0;
  v6 = 1.0 / sqrtf((float)(a4 * a4) + 1.0);
  v7 = a1[2];
  v8 = 0.0;
  do
  {
    v5 = *(_QWORD *)(*(_QWORD *)a1 + 8);
    v9 = (float *)(v5 + 8 * v7);
    if (a2)
      v10 = (float *)(v5 + 8 * v7);
    else
      v10 = v9 + 1;
    if (a2)
      ++v9;
    v11 = v6 * vabds_f32(*v9, a3 + (float)(a4 * *v10));
    if (v11 > v8)
      v8 = v11;
    if (v7 + 1 == **(_DWORD **)a1)
      v7 = 0;
    else
      ++v7;
    --v4;
  }
  while (v4);
  return v8;
}

void ATRAngleOfLine(float a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  double v7;
  float v8;

  v7 = atan(a1);
  if (!a6)
    v7 = 1.57079633 - v7;
  v8 = v7;
  __sincos_stret(v8);
}

uint64_t styleWithHighlight(uint64_t a1, void *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  _OWORD *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  id v15;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v4 = objc_msgSend(a2, "style");
  v5 = *(_QWORD **)(a1 + 160);
  if (v4 && CPPDFStyleEqual(v4, *(_QWORD *)(a1 + 160), 49151))
  {
    *(_QWORD *)(a1 + 160) = objc_msgSend(a2, "highlightedStyle");
  }
  else
  {
    v6 = v5[13];
    v7 = objc_msgSend(a2, "color", *v5, v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v5[7], v5[8], v5[9], v5[10], v5[11]);
    v8 = malloc_type_malloc(0x70uLL, 0x10A00408C90C9C2uLL);
    v9 = v8;
    if (v8)
    {
      v8[2] = v19;
      v8[3] = v20;
      v8[4] = v21;
      v8[5] = v22;
      *v8 = v17;
      v8[1] = v18;
      *((_QWORD *)v8 + 12) = v7;
      *((_QWORD *)v8 + 13) = v6;
      *((_QWORD *)v8 + 13) = v5[13];
      v5[13] = v8;
      v10 = *(const void **)v8;
      if (*(_QWORD *)v9)
        CFRetain(v10);
      v11 = (const void *)*((_QWORD *)v9 + 1);
      if (v11)
        CFRetain(v11);
      v12 = (const void *)*((_QWORD *)v9 + 2);
      if (v12)
        CFRetain(v12);
      v13 = (const void *)*((_QWORD *)v9 + 3);
      if (v13)
        CFRetain(v13);
      v14 = (const void *)*((_QWORD *)v9 + 12);
      if (v14)
        CFRetain(v14);
      v15 = *((id *)v9 + 8);
    }
    *(_QWORD *)(a1 + 160) = v9;
    objc_msgSend(a2, "setStyle:", v5);
    objc_msgSend(a2, "setHighlightedStyle:", *(_QWORD *)(a1 + 160));
  }
  return 1;
}

BOOL canBeHighlighted(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96) == 0;
}

double *CPPolygonBounds(double *result)
{
  uint64_t v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;

  v1 = 0;
  v2 = *result;
  v3 = result[1];
  v4 = v3;
  v5 = *result;
  do
  {
    v7 = result[v1 + 2];
    v6 = result[v1 + 3];
    if (v7 > v2)
      v8 = result[v1 + 2];
    else
      v8 = v2;
    if (v7 >= v5)
      v2 = v8;
    else
      v5 = result[v1 + 2];
    if (v6 >= v4)
    {
      if (v6 > v3)
        v3 = result[v1 + 3];
    }
    else
    {
      v4 = result[v1 + 3];
    }
    v1 += 2;
  }
  while (v1 != 6);
  return result;
}

BOOL CPPointIsInsidePolygonWithBounds(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  _BOOL8 result;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  unint64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v24;
  double v25;
  double v26;
  unint64_t v27;
  double v28;
  CGPoint v29;
  CGRect v30;
  CGRect v31;

  if (a4 == INFINITY || a5 == INFINITY)
    return 0;
  v30.origin.x = a4;
  v30.origin.y = a5;
  v30.size.width = a6;
  v30.size.height = a7;
  v31 = CGRectInset(v30, -0.00000011920929, -0.00000011920929);
  v29.x = a2;
  v29.y = a3;
  result = CGRectContainsPoint(v31, v29);
  if (result)
  {
    v12 = 0;
    v13 = *(double *)(a1 + 48) - a2;
    v14 = *(double *)(a1 + 56) - a3;
    v15 = 0.0;
    v16 = 1.0;
    *(double *)&v17 = -1.57079633;
    v18 = -1.0;
    v28 = a2;
    while (1)
    {
      v19 = *(double *)(a1 + v12) - a2;
      v20 = *(double *)(a1 + v12 + 8) - a3;
      v21 = sqrt(v14 * v14 + v13 * v13);
      v22 = sqrt(v20 * v20 + v19 * v19);
      if (v21 < 0.00000011920929 || v22 < 0.00000011920929)
        break;
      v24 = (v13 * v20 - v14 * v19) / v21 / v22;
      v25 = 1.57079633;
      if (v24 < v16)
      {
        v25 = *(double *)&v17;
        if (v24 > v18)
        {
          v26 = a3;
          v27 = v17;
          v25 = asin(v24);
          v18 = -1.0;
          v17 = v27;
          a3 = v26;
          a2 = v28;
          v16 = 1.0;
        }
      }
      if (v14 * v20 + v13 * v19 < 0.0)
      {
        if (fabs(v25) < 0.00000011920929)
          return 1;
        v25 = dbl_185004DD0[v25 > 0.0] - v25;
      }
      v15 = v15 + v25;
      v12 += 16;
      v14 = v20;
      v13 = v19;
      if (v12 == 64)
        return fabs(v15) >= 3.14159265;
    }
    return 1;
  }
  return result;
}

uint64_t CPUprightRectilinearShapeWithVerticesContainingRect(double *a1, unsigned int a2, double a3, CGFloat a4, double a5, CGFloat a6)
{
  double width;
  double x;
  double v12;
  double y;
  double v14;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  char v21;
  char v22;
  char v23;
  char v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  unsigned int v32;
  double v33;
  double v34;
  double *v35;
  double v36;
  double v37;
  BOOL v38;
  BOOL v39;
  double v40;
  int v41;
  _BOOL4 v42;
  _BOOL4 v43;
  BOOL v44;
  char v45;
  double v46;
  double v47;
  BOOL v48;
  BOOL v49;
  int v50;
  _BOOL4 v51;
  _BOOL4 v52;
  BOOL v53;
  char v54;
  double v55;
  int v56;
  _BOOL4 v57;
  _BOOL4 v58;
  BOOL v59;
  char v60;
  int v61;
  _BOOL4 v62;
  _BOOL4 v63;
  BOOL v64;
  char v65;
  int v66;
  unsigned int v67;
  CGRect v68;
  CGRect v69;
  CGRect v70;
  CGRect v71;

  if (!a2)
    return 0;
  width = a5;
  x = a3;
  if (a5 < 0.0 || a6 < 0.0)
  {
    v68 = CGRectStandardize(*(CGRect *)&a3);
    y = v68.origin.y;
    v68.origin.x = x;
    v68.origin.y = a4;
    v68.size.width = width;
    v68.size.height = a6;
    *(_QWORD *)&v14 = (unint64_t)CGRectStandardize(v68);
    v69.origin.x = x;
    v69.origin.y = a4;
    v69.size.width = width;
    v69.size.height = a6;
    v70 = CGRectStandardize(v69);
    v12 = v70.origin.y + v70.size.height;
    v70.origin.x = x;
    v70.origin.y = a4;
    v70.size.width = width;
    v70.size.height = a6;
    v71 = CGRectStandardize(v70);
    x = v71.origin.x;
    width = v71.size.width;
  }
  else
  {
    v12 = a4 + a6;
    y = a4;
    v14 = a3;
  }
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = x + width;
  v26 = *a1;
  v27 = a1[1];
  if (y <= v12)
    v28 = y;
  else
    v28 = v12;
  if (y <= v12)
    v29 = v12;
  else
    v29 = y;
  if (v14 <= v25)
    v30 = v14;
  else
    v30 = x + width;
  if (v14 <= v25)
    v31 = x + width;
  else
    v31 = v14;
  v32 = a2;
  do
  {
    v33 = v26;
    v34 = v27;
    if (v16 + 1 < a2)
      ++v16;
    else
      v16 = 0;
    v35 = &a1[2 * v16];
    v26 = *v35;
    v27 = v35[1];
    if (vabdd_f64(v33, *v35) <= vabdd_f64(v34, v27))
    {
      if (v34 <= v27)
        v46 = v34;
      else
        v46 = v35[1];
      if (v34 <= v27)
        v47 = v35[1];
      else
        v47 = v34;
      v48 = v46 > v28 || v28 > v47;
      if (!v48 || (v28 <= v46 ? (v49 = v46 > v29) : (v49 = 1), !v49))
      {
        if (v33 <= v14)
        {
          if (v27 - v34 >= 0.0)
            v61 = 0;
          else
            v61 = -1;
          if (v27 - v34 > 0.0)
            v61 = 1;
          v62 = v20 == 2;
          v63 = v61 == v18;
          v64 = !v62 || !v63;
          if (v62 && v63)
            v65 = 0;
          else
            v65 = v61;
          v23 += v65;
          if (v64)
            v18 = v61;
          v20 = 2;
        }
        else
        {
          if (v33 < v25)
            return 0;
          if (v34 - v27 >= 0.0)
            v50 = 0;
          else
            v50 = -1;
          if (v34 - v27 > 0.0)
            v50 = 1;
          v51 = v20 == 4;
          v52 = v50 == v18;
          v53 = !v51 || !v52;
          if (v51 && v52)
            v54 = 0;
          else
            v54 = v50;
          v21 += v54;
          if (v53)
            v18 = v50;
          v20 = 4;
        }
      }
    }
    else
    {
      if (v33 <= v26)
        v36 = v33;
      else
        v36 = *v35;
      if (v33 <= v26)
        v37 = *v35;
      else
        v37 = v33;
      v38 = v36 > v30 || v30 > v37;
      if (!v38 || (v30 <= v36 ? (v39 = v36 > v31) : (v39 = 1), !v39))
      {
        if (v34 <= y)
        {
          v55 = v33 - v26;
          if (v55 >= 0.0)
            v56 = 0;
          else
            v56 = -1;
          if (v55 > 0.0)
            v56 = 1;
          v57 = v20 == 1;
          v58 = v56 == v18;
          v59 = !v57 || !v58;
          if (v57 && v58)
            v60 = 0;
          else
            v60 = v56;
          v24 += v60;
          if (v59)
            v18 = v56;
          v20 = 1;
        }
        else
        {
          if (v34 < v12)
            return 0;
          v40 = v26 - v33;
          if (v40 >= 0.0)
            v41 = 0;
          else
            v41 = -1;
          if (v40 > 0.0)
            v41 = 1;
          v42 = v20 == 3;
          v43 = v41 == v18;
          v44 = !v42 || !v43;
          if (v42 && v43)
            v45 = 0;
          else
            v45 = v41;
          v22 += v45;
          if (v44)
            v18 = v41;
          v20 = 3;
        }
      }
    }
    if (v19 == 0 && v20 != 0)
    {
      v19 = v20;
      v17 = v18;
    }
    --v32;
  }
  while (v32);
  if (v19 == v20 && v17 == v18)
  {
    switch(v20)
    {
      case 1:
        v24 -= v18;
        break;
      case 2:
        v23 -= v18;
        break;
      case 3:
        v22 -= v18;
        break;
      case 4:
        v21 -= v18;
        break;
      default:
        break;
    }
  }
  v66 = v23 & 1;
  v67 = v21 & 1;
  if ((v22 & 1) == 0)
    v67 = 0;
  if (!v66)
    v67 = 0;
  if ((v24 & 1) != 0)
    return v67;
  else
    return 0;
}

double CGIntervalIntersection(double a1, double a2, double a3, double a4)
{
  double v5;
  double v6;
  double result;
  BOOL v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  BOOL v15;

  v5 = fabs(a1);
  v6 = fabs(a3);
  result = INFINITY;
  v8 = v5 == INFINITY || v6 == INFINITY;
  if (!v8)
  {
    v9 = -a2;
    if (a2 >= 0.0)
    {
      v9 = a2;
      a2 = -0.0;
    }
    v10 = a1 + a2;
    v11 = -a4;
    if (a4 >= 0.0)
    {
      v11 = a4;
      a4 = -0.0;
    }
    v12 = a3 + a4;
    if (v10 < v12)
      v13 = v12;
    else
      v13 = v10;
    v14 = v9 + v10;
    if (v14 > v11 + v12)
      v14 = v11 + v12;
    v8 = v13 == v14;
    v15 = v13 < v14;
    result = INFINITY;
    if (v15 || v8)
      return v13;
  }
  return result;
}

double CGIntervalExclusion(uint64_t a1, double result, double a3, double a4, double a5)
{
  double v5;
  double v6;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  BOOL v14;

  v5 = a3;
  *(_OWORD *)a1 = CGIntervalNull;
  v6 = fabs(a4);
  if (fabs(result) != INFINITY && v6 != INFINITY)
  {
    v8 = -a3;
    if (v5 >= 0.0)
    {
      v8 = v5;
      v5 = -0.0;
    }
    result = result + v5;
    v9 = -a5;
    if (a5 >= 0.0)
    {
      v9 = a5;
      a5 = -0.0;
    }
    v10 = a4 + a5;
    if (v10 <= result)
    {
      v13 = v9 + v10;
      if (v13 > result)
      {
        v14 = v13 < v8 + result;
        result = INFINITY;
        if (v14)
          return v13;
      }
    }
    else
    {
      v11 = v8 + result;
      if (v10 < v8 + result)
      {
        v12 = v9 + v10;
        if (v9 + v10 < v11)
        {
          *(double *)a1 = v12;
          *(double *)(a1 + 8) = v11 - v12;
        }
      }
    }
  }
  return result;
}

uint64_t CGPDFGetUnicharsForGlyphName(char *__s, int a2, _WORD *a3)
{
  size_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *i;
  char *v13;
  char *v14;
  _WORD *v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;

  if (!__s)
    goto LABEL_20;
  if (!strchr(__s, 46) && !strchr(__s, 95))
  {
    v17 = component_to_unichars(__s, a2, a3);
    if (v17)
      return v17;
    goto LABEL_20;
  }
  v6 = strlen(__s);
  if (!v6)
    goto LABEL_20;
  v7 = (char *)malloc_type_malloc(v6 + 1, 0xD2128C92uLL);
  if (!v7)
    goto LABEL_20;
  v8 = v7;
  v9 = strcpy(v7, __s);
  v10 = strchr(v9, 46);
  if (v10)
    *v10 = 0;
  v11 = 0;
  for (i = v8; ; i = v14)
  {
    v13 = strchr(i, 95);
    if (!v13)
      break;
    *v13 = 0;
    v14 = v13 + 1;
    if (a3)
      v15 = &a3[v11];
    else
      v15 = 0;
    v11 += component_to_unichars(i, a2, v15);
  }
  v16 = a3 ? &a3[v11] : 0;
  v17 = component_to_unichars(i, a2, v16) + v11;
  free(v8);
  if (!v17)
  {
LABEL_20:
    v18 = CGPDFGetUnicharGuessForGlyphName(__s, a3);
    v17 = v18;
    if (a3 && !v18)
      pdf_log("%s: no mapping.\n", __s);
  }
  return v17;
}

uint64_t component_to_unichars(const char *a1, int a2, _WORD *a3)
{
  size_t v6;
  _WORD *v7;
  int v8;
  unsigned __int16 *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int16 *v15;
  uint64_t v16;
  _WORD *v17;
  __int16 v18;
  unsigned int v19;
  size_t v20;
  char *v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  __darwin_ct_rune_t v35;
  int v36;
  uint64_t v37;
  int v38;
  char v39;
  uint64_t v40;

  v6 = strlen(a1);
  if (a2)
  {
    v7 = bsearch(a1, &ZapfDingbats, 0xC9uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))unicode_entry_compare);
    if (v7)
    {
      if (a3)
      {
        LOWORD(v8) = v7[4];
LABEL_8:
        *a3 = v8;
      }
      return 1;
    }
  }
  v9 = (unsigned __int16 *)bsearch(a1, &AGL, 0x1104uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))unicode_entry_compare);
  if (v9)
  {
    v8 = v9[4];
    if (v8 != 0xFFFF)
    {
      if (a3)
        goto LABEL_8;
      return 1;
    }
    v11 = (char *)bsearch(a1, &AGLExtended, 0x51uLL, 0x18uLL, (int (__cdecl *)(const void *, const void *))unicode_entry_compare);
    if (!v11)
      _CGHandleAssert("agl_to_unichars", 82, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Text/Unicode/CGPDFUnicodeTable.c", "extended_entry != NULL", "extended entry missing", v12, v13, v14, v39);
    v10 = *((_QWORD *)v11 + 1);
    if (a3)
    {
      if (!v10)
        goto LABEL_16;
      v15 = (__int16 *)(v11 + 16);
      v16 = *((_QWORD *)v11 + 1);
      v17 = a3;
      do
      {
        v18 = *v15++;
        *v17++ = v18;
        --v16;
      }
      while (v16);
    }
    if (v10)
      return v10;
  }
LABEL_16:
  if (v6 < 4)
    return 0;
  if (strncmp(a1, "uni", 3uLL) || (((_BYTE)v6 + 1) & 3) != 0)
  {
    if (v6 - 5 <= 2 && *a1 == 117)
    {
      v19 = 0;
      v20 = v6 - 1;
      v21 = (char *)(a1 + 1);
      v22 = MEMORY[0x1E0C80978];
      do
      {
        v23 = *v21++;
        v24 = v23;
        if (v23 < 0)
        {
          if (!__maskrune_l(v24, 0x10000uLL, 0) || __maskrune_l(v24, 0x1000uLL, 0))
            return 0;
          v26 = __maskrune_l(v24, 0x400uLL, 0);
        }
        else
        {
          v25 = *(_DWORD *)(v22 + 4 * v24 + 60);
          if ((v25 & 0x11000) != 0x10000)
            return 0;
          v26 = v25 & 0x400;
        }
        if (v26)
          v27 = -48;
        else
          v27 = -55;
        v19 = v27 + 16 * v19 + v24;
        --v20;
      }
      while (v20);
      if (HIWORD(v19))
        v28 = 1;
      else
        v28 = (v19 & 0xFFFFF800) == 55296;
      if (!v28)
      {
        if (a3)
          *a3 = v19;
        return 1;
      }
      if (!((v19 - 0x10000) >> 20))
      {
        if (a3)
        {
          *a3 = (v19 >> 10) - 10304;
          a3[1] = v19 & 0x3FF | 0xDC00;
        }
        return 2;
      }
    }
    return 0;
  }
  v10 = 0;
  v30 = a1 + 3;
  v31 = 3;
  v32 = MEMORY[0x1E0C80978];
  do
  {
    v40 = v31;
    v33 = 0;
    v34 = 0;
    do
    {
      v35 = v30[v33];
      if (v30[v33] < 0)
      {
        if (!__maskrune_l(v30[v33], 0x10000uLL, 0) || __maskrune_l(v35, 0x1000uLL, 0))
          return v10;
        v37 = __maskrune_l(v35, 0x400uLL, 0);
      }
      else
      {
        v36 = *(_DWORD *)(v32 + 4 * v30[v33] + 60);
        if ((v36 & 0x11000) != 0x10000)
          return v10;
        v37 = v36 & 0x400;
      }
      if (v37)
        v38 = -48;
      else
        v38 = -55;
      v34 = v38 + 16 * v34 + v35;
      ++v33;
    }
    while (v33 != 4);
    if (v34 >> 11 == 27)
      break;
    if (a3)
      *a3++ = v34;
    ++v10;
    v31 = v40 + 4;
    v30 += 4;
  }
  while (v40 + 4 < v6);
  return v10;
}

uint64_t unicode_entry_compare(const char *a1, const char **a2)
{
  return strcmp(a1, *a2);
}

uint64_t FilterStream::setPos(FilterStream *this)
{
  return error(-1, "Internal: called setPos() on FilterStream");
}

void CGPDFSourceStream::~CGPDFSourceStream(CGPDFSourceStream *this)
{
  *(_QWORD *)this = &off_1E1627FF8;
}

{
  *(_QWORD *)this = &off_1E1627FF8;
  JUMPOUT(0x186DC23C4);
}

uint64_t CGPDFSourceStream::reset(CGPDFSourceStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = CGPDFSourceRewind(*((_QWORD *)this + 2), a2, a3, a4, a5, a6, a7, a8);
  *((_QWORD *)this + 3) = (char *)this + 40;
  *((_QWORD *)this + 4) = (char *)this + 40;
  *((_QWORD *)this + 517) = 0;
  return result;
}

uint64_t CGPDFSourceStream::getChar(CGPDFSourceStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;

  v9 = (unsigned __int8 *)*((_QWORD *)this + 3);
  v10 = *((_QWORD *)this + 4);
  if ((unint64_t)v9 >= v10)
  {
    v11 = (char *)this + 40;
    *((_QWORD *)this + 517) += v10 - ((_QWORD)this + 40);
    *((_QWORD *)this + 3) = (char *)this + 40;
    *((_QWORD *)this + 4) = (char *)this + 40;
    v12 = CGPDFSourceRead(*((_QWORD *)this + 2), (uint64_t)this + 40, 0x1000uLL, a4, a5, a6, a7, a8);
    *((_QWORD *)this + 4) = &v11[v12];
    v9 = (unsigned __int8 *)*((_QWORD *)this + 3);
    if (v9 >= (unsigned __int8 *)&v11[v12])
      return 0xFFFFFFFFLL;
  }
  *((_QWORD *)this + 3) = v9 + 1;
  return *v9;
}

uint64_t CGPDFSourceStream::getPos(CGPDFSourceStream *this)
{
  return (*((_DWORD *)this + 1034) - (_DWORD)this + *((_DWORD *)this + 6) - 40);
}

uint64_t CGPDFSourceStream::isBinary(CGPDFSourceStream *this)
{
  return 1;
}

uint64_t CGPDFSourceStream::lookChar(CGPDFSourceStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v8;
  unint64_t v9;
  char *v11;
  uint64_t v12;

  v8 = (unsigned __int8 *)*((_QWORD *)this + 3);
  v9 = *((_QWORD *)this + 4);
  if ((unint64_t)v8 >= v9
    && (v11 = (char *)this + 40,
        *((_QWORD *)this + 517) += v9 - ((_QWORD)this + 40),
        *((_QWORD *)this + 3) = (char *)this + 40,
        *((_QWORD *)this + 4) = (char *)this + 40,
        v12 = CGPDFSourceRead(*((_QWORD *)this + 2), (uint64_t)this + 40, 0x1000uLL, a4, a5, a6, a7, a8),
        *((_QWORD *)this + 4) = &v11[v12],
        v8 = (unsigned __int8 *)*((_QWORD *)this + 3),
        v8 >= (unsigned __int8 *)&v11[v12]))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return *v8;
  }
}

uint64_t CGPDFSourceStream::getStart(CGPDFSourceStream *this)
{
  return 0;
}

void unmap_file(int a1, void *a2, size_t a3)
{
  char v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = (char)a2;
  if (munmap(a2, a3) < 0)
  {
    v4 = __error();
    strerror(*v4);
    CGPostError((uint64_t)"Failed to unmap data (%p; 0x%lx): %s.\n", v5, v6, v7, v8, v9, v10, v11, v3);
  }
}

void free_data_9192(int a1, void *a2)
{
  free(a2);
}

ssize_t file_provider_get_bytes_at_position(int a1, void *a2, off_t a3, size_t __nbyte)
{
  ssize_t v4;

  v4 = pread(a1, a2, __nbyte, a3);
  return v4 & ~(v4 >> 63);
}

_QWORD *PDFXRefTableCreate2(unint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  v4 = (_QWORD *)operator new();
  *v4 = 0;
  v4[1] = a2;
  v4[2] = 0;
  v4[3] = 0;
  v4[4] = 0;
  if (a1)
  {
    if (a1 >> 60)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v5 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGPoint>>(a1);
    v7 = &v5[16 * v6];
    bzero(v5, 16 * a1);
    v8 = &v5[16 * a1];
    v4[2] = v5;
    v4[3] = v8;
    v4[4] = v7;
    if (!a2)
    {
      if (v8 < v7)
      {
        v9 = v8 + 16;
        *(_QWORD *)v8 = 0;
        *((_QWORD *)v8 + 1) = 0;
LABEL_22:
        v4[3] = v9;
        return v4;
      }
LABEL_8:
      v10 = (v8 - v5) >> 4;
      v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 60)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      if ((v7 - v5) >> 3 > v11)
        v11 = (v7 - v5) >> 3;
      if ((unint64_t)(v7 - v5) >= 0x7FFFFFFFFFFFFFF0)
        v12 = 0xFFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
        v12 = (unint64_t)std::__allocate_at_least[abi:se180100]<std::allocator<CGPoint>>(v12);
      else
        v13 = 0;
      v14 = (_QWORD *)(v12 + 16 * v10);
      v9 = v14 + 2;
      *v14 = 0;
      v14[1] = 0;
      if (v8 != v5)
      {
        do
        {
          *((_OWORD *)v14 - 1) = *((_OWORD *)v8 - 1);
          v14 -= 2;
          v8 -= 16;
        }
        while (v8 != v5);
        v5 = (char *)v4[2];
      }
      v4[2] = v14;
      v4[3] = v9;
      v4[4] = v12 + 16 * v13;
      if (v5)
        operator delete(v5);
      goto LABEL_22;
    }
  }
  else if (!a2)
  {
    v5 = 0;
    v7 = 0;
    v8 = 0;
    goto LABEL_8;
  }
  return v4;
}

void sub_184C75FF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DC23C4](v1, 0x1020C404A1ECDA0);
  _Unwind_Resume(a1);
}

uint64_t PDFXRefTableRelease(uint64_t result)
{
  uint64_t v1;
  void *v2;

  if (result)
  {
    v1 = result;
    v2 = *(void **)(result + 16);
    if (v2)
    {
      *(_QWORD *)(v1 + 24) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x186DC23C4);
  }
  return result;
}

_BYTE *PDFXRefTableEmit(_BYTE *result, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;

  if (result)
  {
    v10 = result;
    CGDataConsumerPrintf((_BYTE *)a2, "xref\n", (uint64_t)a3, a4, a5, a6, a7, a8, v26);
    result = CGDataConsumerPrintf((_BYTE *)a2, "%lu %zu\n", v11, v12, v13, v14, v15, v16, v10[1]);
    if (a3)
    {
      if (a2)
        v23 = *(_QWORD *)(a2 + 48);
      else
        v23 = 0;
      *a3 = v23;
    }
    v24 = (uint64_t *)v10[2];
    if (!v10[1])
    {
      result = CGDataConsumerPrintf((_BYTE *)a2, "%010u 65535 f \n", v17, v18, v19, v20, v21, v22, 0);
      v24 += 2;
    }
    for (;
          (unint64_t)v24 < v10[3];
          result = CGDataConsumerPrintf((_BYTE *)a2, "%010llu 00000 n \n", v17, v18, v19, v20, v21, v22, v25))
    {
      v25 = *v24;
      v24 += 2;
    }
  }
  return result;
}

uint64_t PDFXRefTableAddObject(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;

  if (!a1)
    return 0;
  v3 = a1[2];
  v2 = (_QWORD *)a1[3];
  v4 = ((uint64_t)v2 - v3) >> 4;
  v5 = a1[4];
  if ((unint64_t)v2 >= v5)
  {
    v7 = v4 + 1;
    if ((unint64_t)(v4 + 1) >> 60)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v8 = v5 - v3;
    if (v8 >> 3 > v7)
      v7 = v8 >> 3;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v9 = 0xFFFFFFFFFFFFFFFLL;
    else
      v9 = v7;
    v10 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGPoint>>(v9);
    v11 = &v10[16 * v4];
    v13 = &v10[16 * v12];
    v6 = v11 + 16;
    *(_QWORD *)v11 = 0;
    *((_QWORD *)v11 + 1) = 0;
    v15 = (char *)a1[2];
    v14 = (char *)a1[3];
    if (v14 != v15)
    {
      do
      {
        *((_OWORD *)v11 - 1) = *((_OWORD *)v14 - 1);
        v11 -= 16;
        v14 -= 16;
      }
      while (v14 != v15);
      v14 = (char *)a1[2];
    }
    a1[2] = v11;
    a1[3] = v6;
    a1[4] = v13;
    if (v14)
      operator delete(v14);
  }
  else
  {
    v6 = v2 + 2;
    *v2 = 0;
    v2[1] = 0;
  }
  a1[3] = v6;
  return v4;
}

BOOL CGPointEqualToPoint(CGPoint point1, CGPoint point2)
{
  return point1.y == point2.y && point1.x == point2.x;
}

BOOL CGRectIsIntegral(double a1, double a2, double a3, double a4)
{
  if (a1 == INFINITY || a2 == INFINITY)
    return 1;
  if (a1 == (double)(int)a1 && a2 == (double)(int)a2 && a3 == (double)(int)a3)
    return a4 == (double)(int)a4;
  return 0;
}

__int128 *rips_f_super()
{
  return &_rips_class;
}

uint64_t rips_f_size()
{
  return 152;
}

void rips_f_release(_DWORD *a1)
{
  int v1;
  uint64_t v3;
  const void *v4;

  v1 = a1[2] - 1;
  a1[2] = v1;
  if (!v1)
  {
    v3 = *((_QWORD *)a1 + 18);
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
    v4 = (const void *)*((_QWORD *)a1 + 10);
    if (v4)
      CFRelease(v4);
    free(a1);
  }
}

_QWORD *rips_f_Create(uint64_t a1, uint64_t a2, double *a3, double a4)
{
  uint64_t v4;
  size_t v9;
  _QWORD *v10;
  _QWORD *v11;
  double v12;
  uint64_t v13;
  double v14;
  int v15;
  int v16;
  int v17;
  int v18;
  double width;
  double height;
  double v21;
  double v22;
  int v23;
  char v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  double v28;
  double v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  CGRect v34;

  if (a2)
    v4 = a2 + 32;
  else
    v4 = 0;
  if (!a2)
    return 0;
  v9 = (*(uint64_t (**)(void))(a1 + 8))();
  v10 = malloc_type_calloc(1uLL, v9, 0x12FE9D4BuLL);
  v11 = v10;
  if (v10)
  {
    *v10 = a1;
    v10[1] = 0xF100000001;
    v10[18] = 0;
    if (a3)
      v12 = sqrt(fabs(*a3 * a3[3] - a3[1] * a3[2]));
    else
      v12 = 1.0;
    v13 = *(_QWORD *)(a2 + 24);
    if (v13 && (v13 < 1 || !*(_QWORD *)(v13 + 32)))
    {
      CFRetain((CFTypeRef)v13);
      v11[10] = v13;
    }
    v14 = v12 * *(double *)(v4 + 24);
    v11[11] = *(_QWORD *)(v4 + 16);
    *((double *)v11 + 12) = v14;
    v11[13] = *(_QWORD *)(v4 + 32);
    v15 = *(_DWORD *)(v4 + 8);
    *((_DWORD *)v11 + 28) = v15;
    if (v15 == 1)
    {
      v16 = *((_DWORD *)v11 + 3);
    }
    else
    {
      if (v15 != 2)
      {
        v17 = *((_DWORD *)v11 + 3) | 0x400;
        goto LABEL_20;
      }
      v16 = *((_DWORD *)v11 + 3) | 0x300;
    }
    v17 = v16 | 0x600;
LABEL_20:
    *((_DWORD *)v11 + 3) = v17;
    v18 = *(_DWORD *)(v4 + 72);
    *((_DWORD *)v11 + 33) = v18;
    if (v18 < 0)
    {
      v24 = 0;
      *((_DWORD *)v11 + 31) = 0;
      *((_DWORD *)v11 + 32) = 0;
    }
    else
    {
      v34 = CGRectStandardize(*(CGRect *)(v4 + 40));
      if (a4 <= 1.0)
      {
        width = v34.size.width;
      }
      else
      {
        v34.origin.x = v34.origin.x * a4;
        v34.origin.y = v34.origin.y * a4;
        width = v34.size.width * a4;
      }
      if (a4 > 1.0)
        height = v34.size.height * a4;
      else
        height = v34.size.height;
      v21 = v34.origin.x + width;
      v22 = v34.origin.x + 0.0;
      if (v34.origin.x + 0.0 <= 1073741820.0)
      {
        v25 = vcvtmd_s64_f64(v22);
        if (v22 >= -1073741820.0)
          v23 = v25;
        else
          v23 = -1073741823;
      }
      else
      {
        v23 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 29) = v23;
      if (v21 <= 1073741820.0)
      {
        v27 = vcvtpd_s64_f64(v21);
        if (v21 >= -1073741820.0)
          v26 = v27;
        else
          v26 = -1073741823;
      }
      else
      {
        v26 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 31) = v26 - v23;
      v28 = v34.origin.y + height;
      v29 = v34.origin.y + 0.0;
      if (v29 <= 1073741820.0)
      {
        v31 = vcvtmd_s64_f64(v29);
        if (v29 >= -1073741820.0)
          v30 = v31;
        else
          v30 = -1073741823;
      }
      else
      {
        v30 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 30) = v30;
      if (v28 <= 1073741820.0)
      {
        if (v28 >= -1073741820.0)
          v32 = vcvtpd_s64_f64(v28);
        else
          v32 = -1073741823;
      }
      else
      {
        v32 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 32) = v32 - v30;
      v24 = 1;
    }
    *((_BYTE *)v11 + 136) = v24;
  }
  return v11;
}

uint64_t rips_f_Growth(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  int v3;

  v2 = vcvtmd_s64_f64(*(double *)(a1 + 96) + 0.5);
  *a2 = ~v2;
  a2[1] = ~v2;
  v3 = 2 * v2 + 2;
  a2[2] = v3;
  a2[3] = v3;
  return 1;
}

CGColorSpaceRef rips_f_ColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;

  v8 = *(_QWORD *)(a1 + 80);
  if (!v8)
    return (CGColorSpaceRef)rips_f_cs;
  if ((v8 & 0x8000000000000000) != 0)
    return CGTaggedColorGetColorSpace(v8, a2, a3, a4, a5, a6, a7, a8);
  return *(CGColorSpaceRef *)(v8 + 24);
}

uint64_t (**rips_f_BltShape(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8))()
{
  int *v9;
  int *v10;

  v9 = (int *)(a3 + 12);
  if (!a3)
    v9 = (int *)(a2 + 12);
  if (a4)
    v9 = a4;
  if (a5)
    v10 = (int *)(a5 + 12);
  else
    v10 = v9;
  return rips_f_DrawRing(a1, a2, a3, a4, v10, a5, 0, 0, 0, a6, a7, a8);
}

uint64_t (**rips_f_BltGlyph(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10))()
{
  int *v10;
  int *v11;

  v10 = a5;
  v11 = (int *)(a3 + 12);
  if (!a3)
    v11 = (int *)(a2 + 12);
  if (a4)
    v11 = a4;
  if (!a5)
    a5 = v11;
  return rips_f_DrawRing(a1, a2, a3, a4, a5, 0, v10, 0, 0, a6, a7, a10);
}

uint64_t (**rips_f_BltImage(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8))()
{
  uint64_t v8;
  int *v9;

  v8 = (uint64_t)a5;
  v9 = (int *)(a3 + 12);
  if (!a3)
    v9 = (int *)(a2 + 12);
  if (a4)
    v9 = a4;
  if (!a5)
    a5 = v9;
  return rips_f_DrawRing(a1, a2, a3, a4, a5, 0, 0, v8, 0, a6, a7, a8);
}

uint64_t (**rips_f_BltShade(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8))()
{
  int *v8;

  v8 = (int *)(a3 + 12);
  if (!a3)
    v8 = (int *)(a2 + 12);
  if (a4)
    v8 = a4;
  if (a5)
    v8 = (int *)a5;
  return rips_f_DrawRing(a1, a2, a3, a4, v8, 0, 0, 0, a5, a6, a7, a8);
}

uint64_t (**rips_f_DrawRing(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10, _DWORD *a11, uint64_t a12))()
{
  __int128 v12;
  __int128 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int *v21;
  int8x16_t v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  int v29;
  char *v30;
  uint64_t (**v31)();
  unsigned __int8 v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  double v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  float *v46;
  char *v47;
  unint64_t v48;
  _QWORD *Cache;
  __n128 v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  double *v60;
  double *v61;
  size_t v62;
  uint64_t v63;
  uint64_t v64;
  CGColorSpaceRef ColorSpace;
  uint64_t v66;
  double *Components;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  float v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  _BOOL4 v90;
  int v91;
  int v92;
  int v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  double v102;
  double *v103;
  double *v104;
  uint64_t v105;
  char v106;
  char v107;
  uint64_t v109;
  uint64_t v110;
  double *v111;
  uint64_t *v112;
  char *v113;
  int *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _DWORD *v119;
  uint64_t v120;
  _DWORD *v121;
  uint64_t v122;
  int v123;
  int64x2_t v124;
  int64x2_t v125;
  __int128 v126;
  _OWORD v127[3];
  __int128 v128;
  uint64_t v129;
  float v130[258];
  uint64_t v131;

  v131 = *MEMORY[0x1E0C80C00];
  v124 = 0uLL;
  v12 = *(_OWORD *)(a12 + 48);
  v127[2] = *(_OWORD *)(a12 + 32);
  v128 = v12;
  v129 = *(_QWORD *)(a12 + 64);
  v13 = *(_OWORD *)(a12 + 16);
  v127[0] = *(_OWORD *)a12;
  v127[1] = v13;
  v14 = vcvtmd_s64_f64(*(double *)(a1 + 96) + 0.5);
  if (v14 < 1)
    return 0;
  v15 = a8;
  v16 = a6;
  v17 = a4;
  v121 = a11;
  v122 = a10;
  v118 = a9;
  v119 = a7;
  v125 = 0uLL;
  v120 = a6;
  if (!a4 || a4 == a5)
  {
    v125 = *(int64x2_t *)a5;
    if (!v125.i32[2] || !v125.i32[3])
      goto LABEL_37;
  }
  else if (!CGSBoundsIntersection(a4, a5, &v125))
  {
    goto LABEL_37;
  }
  if (*(_BYTE *)(a1 + 136))
  {
    if (a3)
    {
      if (!CGSBoundsIntersection((int *)(a3 + 12), v125.i32, &v124))
        goto LABEL_37;
    }
    else
    {
      v124 = v125;
    }
    v22.i64[0] = 0xFFFFFFFF00000000;
    v22.i64[1] = 0xFFFFFFFF00000000;
    v124 = vaddq_s64((int64x2_t)vbslq_s8(v22, (int8x16_t)v124, (int8x16_t)vaddq_s64(v124, (int64x2_t)xmmword_185004DE0)), (int64x2_t)xmmword_185004DF0);
  }
  else
  {
    *(_OWORD *)v130 = 0uLL;
    v21 = (int *)(a2 + 12);
    if (a3)
    {
      if ((CGSBoundsIntersection(v21, (int *)(a3 + 12), v130) & 1) == 0)
        goto LABEL_37;
    }
    else
    {
      *(_OWORD *)v130 = *(_OWORD *)v21;
      if (!LODWORD(v130[2]) || !LODWORD(v130[3]))
        goto LABEL_37;
    }
    v125.i64[0] = (v125.i32[0] + ~v14) | ((unint64_t)(v125.i32[1] + ~v14) << 32);
    v125.i64[1] = (v125.i32[2] - 2 * ~v14) | ((unint64_t)(v125.i32[3] - 2 * ~v14) << 32);
    LODWORD(v130[0]) += ~v14;
    LODWORD(v130[1]) += ~v14;
    LODWORD(v130[2]) -= 2 * ~v14;
    LODWORD(v130[3]) -= 2 * ~v14;
    if (!CGSBoundsIntersection(v125.i32, (int *)v130, &v124))
    {
LABEL_37:
      v27 = *(char **)(a1 + 144);
      *(_QWORD *)(a1 + 144) = 0;
      goto LABEL_38;
    }
  }
  v23 = v15;
  v24 = *(uint64_t **)(a1 + 144);
  if (v24)
  {
    v124.i64[0] = CGSBoundsUnion(v124.i64[0], v124.i64[1], *(uint64_t *)((char *)v24 + 12), *(uint64_t *)((char *)v24 + 20));
    v124.i64[1] = v25;
    v26 = RIPLayerCreateWithLayer((uint64_t)RIPLayer_ripl_class, v124.i64, v24, *(unsigned int *)(a2 + 52));
    if (v26)
    {
      v27 = v26;
      v28 = *(_QWORD *)(a1 + 144);
      if (v28)
        (*(void (**)(uint64_t))(*(_QWORD *)v28 + 24))(v28);
      *(_QWORD *)(a1 + 144) = 0;
      goto LABEL_23;
    }
    return 0;
  }
  v27 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v124, 0, 0, *(unsigned int *)(a2 + 52), a6, (uint64_t)a7, a8);
  if (!v27)
    return 0;
LABEL_23:
  v117 = a3;
  if (v119)
    v29 = 2;
  else
    v29 = 1;
  LODWORD(v127[0]) = v29;
  *(_QWORD *)&v128 = 0x3FF0000000000000;
  v30 = (char *)v122;
  if (v122)
  {
    v31 = *(uint64_t (***)())v122;
    if (*(_QWORD *)v122)
    {
      v30 = (char *)v122;
      while (v31 != RIPLayer_ripl_class)
      {
        if (*v31)
        {
          v31 = (uint64_t (**)())(*v31)();
          if (v31)
            continue;
        }
        goto LABEL_32;
      }
      if (*(_DWORD *)(v122 + 64))
      {
        v30 = RIPLayerConvertLayer((uint64_t)RIPLayer_ripl_class, *(_DWORD *)(v122 + 28) & 8, v122, *(unsigned int *)(a2 + 52));
        if (!v30)
          goto LABEL_178;
      }
    }
  }
LABEL_32:
  if (v120)
  {
    v32 = RIPLayerBltShape((int *)v27, 0, 0, v120, (uint64_t)v30, v121, (uint64_t)v127, a8);
LABEL_172:
    v107 = v32;
    goto LABEL_173;
  }
  if (v119)
  {
    v32 = RIPLayerBltGlyph(v27, 0, 0, v119, (uint64_t)v30, v121, 0, (uint64_t)v127);
    goto LABEL_172;
  }
  if (v23)
  {
    v32 = RIPLayerBltImage((uint64_t)v27, 0, 0, v23, (uint64_t)v127, a6, (uint64_t)a7, a8);
    goto LABEL_172;
  }
  if (v118)
  {
    v32 = RIPLayerBltShade((uint64_t)v27, 0, 0, v118, (uint64_t)v30, (uint64_t)v127, (uint64_t)a7, a8);
    goto LABEL_172;
  }
  v107 = 1;
LABEL_173:
  if (v30 != (char *)v122 && v30)
    (*(void (**)(char *))(*(_QWORD *)v30 + 24))(v30);
  if ((v107 & 1) == 0)
    goto LABEL_178;
  a3 = v117;
  v15 = v23;
  v16 = v120;
LABEL_38:
  if (*(_DWORD *)(a1 + 112) == 2 && (*(_BYTE *)(a1 + 13) & 0x10) == 0)
  {
    if (v16)
    {
      v33 = (uint64_t)RIPLayerBltShape((int *)a2, a3, v17, v16, v122, v121, a12, a8);
      goto LABEL_55;
    }
    if (v119)
    {
      v33 = (uint64_t)RIPLayerBltGlyph((_DWORD *)a2, a3, v17, v119, v122, v121, 0, a12);
      goto LABEL_55;
    }
    if (v15)
    {
      v33 = RIPLayerBltImage(a2, a3, (uint64_t)v17, v15, a12, a6, (uint64_t)a7, a8);
      goto LABEL_55;
    }
    if (v118)
    {
      v33 = (uint64_t)RIPLayerBltShade(a2, a3, (uint64_t)v17, v118, v122, a12, (uint64_t)a7, a8);
LABEL_55:
      v34 = v33;
      if (!v27)
        goto LABEL_59;
      goto LABEL_58;
    }
  }
  v34 = 1;
  if (v27)
  {
LABEL_58:
    v124 = *(int64x2_t *)(v27 + 12);
    v124.i32[0] -= v14;
    v124.i32[1] -= v14;
    v124.i32[2] += 2 * v14;
    v124.i32[3] += 2 * v14;
  }
LABEL_59:
  if (!*(_BYTE *)(a1 + 136)
    || (v35 = *(_DWORD *)(a1 + 132), v36 = __OFSUB__(v35, 1), --v35, *(_DWORD *)(a1 + 132) = v35, (v35 < 0) ^ v36))
  {
    if (v27)
      v37 = v34;
    else
      v37 = 0;
    if (v37 != 1)
    {
      if (!v27)
        goto LABEL_117;
      goto LABEL_116;
    }
    if (*(_DWORD *)(a1 + 124)
      && *(_DWORD *)(a1 + 128)
      && !CGSBoundsIntersection(v124.i32, (int *)(a1 + 116), &v124))
    {
      v34 = 1;
LABEL_116:
      (*(void (**)(char *))(*(_QWORD *)v27 + 24))(v27);
      goto LABEL_117;
    }
    if (rips_f_DrawRing_onceToken != -1)
      dispatch_once(&rips_f_DrawRing_onceToken, &__block_literal_global_2_9283);
    if (rips_f_DrawRing_debug_focus_ring_masks)
      RIPLayerSaveTGA((uint64_t)v27, "/tmp/original_mask");
    v123 = 0;
    if (!get_integer_property("CGFocusRingStyle", (const void *(*)(const char *))copy_local_domain_value, &v123)|| v123 == 1)
    {
      v47 = rips_f_BlurRingRoundedDilation((uint64_t)v27, v14, *(double *)(a1 + 104));
      goto LABEL_81;
    }
    if (!v123)
    {
      v115 = v15;
      v116 = a2;
      v117 = a3;
      v41 = *(double *)(a1 + 104);
      v126 = *(_OWORD *)(v27 + 12);
      v42 = *((_DWORD *)v27 + 5);
      v43 = *((_DWORD *)v27 + 6);
      v44 = *((unsigned int *)v27 + 12);
      v45 = *((_QWORD *)v27 + 7);
      if (v44 < 0x401)
        v46 = v130;
      else
        v46 = (float *)malloc_type_malloc(*((unsigned int *)v27 + 12), 0x195C97C4uLL);
      if (v43)
      {
        v80 = 0;
        v81 = vcvtmd_s64_f64(v41 * 255.0);
        v82 = v45 + v44;
        while (!v42)
        {
LABEL_155:
          v45 += v44;
          ++v80;
          v82 += v44;
          if (v80 == v43)
            goto LABEL_156;
        }
        v83 = 0;
        while (1)
        {
          v84 = *(unsigned __int8 *)(v45 + v83);
          if (v81 > v84)
            break;
          LOBYTE(v87) = 0;
LABEL_154:
          *(_BYTE *)(v45 + v83) = v87;
          *((_BYTE *)v46 + v83++) = v84;
          if (v42 == (_DWORD)v83)
            goto LABEL_155;
        }
        if (v80)
        {
          v85 = *((unsigned __int8 *)v46 + v83);
          if ((_DWORD)v83)
          {
LABEL_134:
            v86 = *((unsigned __int8 *)v46 + v83 - 1);
LABEL_138:
            if (v83 >= v42 - 1)
              v88 = 0;
            else
              v88 = *(unsigned __int8 *)(v45 + v83 + 1);
            if (v80 >= v43 - 1)
              v89 = 0;
            else
              v89 = *(unsigned __int8 *)(v82 + v83);
            v90 = v81 <= v89;
            v91 = v81 <= v88 || v90;
            if (v81 > v86)
              v92 = v91;
            else
              v92 = 1;
            if (v81 > v85)
              v93 = v92;
            else
              v93 = 1;
            v87 = v93 << 31 >> 31;
            goto LABEL_154;
          }
        }
        else
        {
          v85 = 0;
          if ((_DWORD)v83)
            goto LABEL_134;
        }
        v86 = 0;
        goto LABEL_138;
      }
LABEL_156:
      if (v46 != v130)
        free(v46);
      *(_QWORD *)&v126 = (v126 - v14) | ((unint64_t)(DWORD1(v126) - v14) << 32);
      *((_QWORD *)&v126 + 1) = (DWORD2(v126) + 2 * v14) | ((unint64_t)(HIDWORD(v126) + 2 * v14) << 32);
      v94 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v126, 0, 0, *((unsigned int *)v27 + 13), v38, v39, v40);
      a2 = v116;
      a3 = v117;
      v15 = v115;
      v47 = v94;
      if (!v94)
      {
LABEL_81:
        if (v47)
        {
          v114 = v17;
          if (rips_f_DrawRing_debug_focus_ring_masks)
            RIPLayerSaveTGA((uint64_t)v47, "/tmp/focus_ring_mask");
          v113 = v47;
          v48 = *(_QWORD *)(a1 + 80);
          if (!v48)
          {
            if (default_focus_ring_color_predicate != -1)
              dispatch_once(&default_focus_ring_color_predicate, &__block_literal_global_9_9287);
            v48 = default_focus_ring_color_focus_ring_color;
          }
          Cache = CGColorTransformGetCache(*(_QWORD **)(a12 + 16));
          v117 = a3;
          v115 = v15;
          if (Cache)
          {
            v51 = Cache[2];
            if (v51)
            {
              v52 = *(_QWORD *)(*(_QWORD *)(v51 + 24) + 40);
              if (v52 >> 61)
              {
                v112 = &v110;
                MEMORY[0x1E0C80A78](Cache, v50);
                v60 = (double *)&v109;
                v61 = 0;
LABEL_100:
                v64 = *(_QWORD *)(a12 + 16);
                v116 = a2;
                v111 = v60;
                if (v48)
                {
                  if ((v48 & 0x8000000000000000) != 0)
                    ColorSpace = CGTaggedColorGetColorSpace(v48, v53, v54, v55, v56, v57, v58, v59);
                  else
                    ColorSpace = *(CGColorSpaceRef *)(v48 + 24);
                }
                else
                {
                  ColorSpace = 0;
                }
                v66 = *(unsigned int *)(a12 + 8);
                Components = (double *)CGColorGetComponents((CGColorRef)v48);
                if ((CGColorTransformConvertColorComponents(v64, ColorSpace, v66, Components, v61) & 1) != 0)
                {
                  RIPColorCreateWithColor(*(_DWORD *)(a12 + 24), v61, v52, 1.0);
                  v75 = v74;
                }
                else
                {
                  v75 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
                  *v75 = &ripc_class;
                  v75[1] = 0;
                  v75[2] = 0;
                  v75[3] = 0;
                  *((_DWORD *)v75 + 39) = 1065353216;
                }
                v15 = v115;
                a2 = v116;
                if (v61 != v111)
                  free(v61);
                LODWORD(v127[0]) = 2;
                v76 = *(double *)(a1 + 88);
                *(double *)&v128 = v76;
                if ((*(_BYTE *)(a1 + 13) & 0x10) != 0)
                  RIPLayerDefine(a2, (__n128 *)&v124, v68, v69, v70, v71, v72, v73);
                a3 = v117;
                if (*(_BYTE *)(a1 + 136))
                  v77 = 0;
                else
                  v77 = v117;
                v78 = (uint64_t)v113;
                v34 = (uint64_t)RIPLayerBltShape((int *)a2, v77, v124.i32, (uint64_t)v113, (uint64_t)v75, 0, (uint64_t)v127, v73);
                free(v75);
                (*(void (**)(uint64_t))(*(_QWORD *)v78 + 24))(v78);
                v17 = v114;
                goto LABEL_116;
              }
              Cache = (_QWORD *)(8 * v52);
            }
            else
            {
              v52 = 0;
              Cache = 0;
            }
          }
          else
          {
            v52 = 0;
          }
          v112 = &v110;
          v62 = MEMORY[0x1E0C80A78](Cache, v50);
          v60 = (double *)((char *)&v110 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0));
          if (v52 <= 0x1FFFFFFFFFFFFFFELL)
            v61 = (double *)((char *)&v110 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0));
          else
            v61 = 0;
          if (v52 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022)
            v61 = (double *)malloc_type_malloc(v62, 0xE05F0D52uLL);
          goto LABEL_100;
        }
        goto LABEL_178;
      }
      if (v14 >= 5)
      {
        v101 = (v14 + 1);
        v102 = 1.0;
        v103 = (double *)malloc_type_malloc(8 * (int)v101, 0x100004000313F17uLL);
        v104 = v103;
        *v103 = 1.0;
        v105 = 1;
        do
        {
          v102 = v102 - 1.0 / (double)(int)v101;
          v103[v105++] = v102;
        }
        while (v101 != v105);
        v106 = RIPLayerSymmetricConvolve((uint64_t)v47, (uint64_t)v27, v103, v14);
        free(v104);
        v15 = v115;
        a2 = v116;
        if ((v106 & 1) == 0)
          goto LABEL_161;
      }
      else if ((RIPLayerSymmetricConvolve((uint64_t)v94, (uint64_t)v27, (double *)*(&off_1E165A4F8 + v14), v14) & 1) == 0)
      {
LABEL_161:
        (*(void (**)(char *))(*(_QWORD *)v47 + 24))(v47);
        v47 = 0;
LABEL_166:
        a3 = v117;
        goto LABEL_81;
      }
      v130[0] = 0.0;
      v130[1] = (float)v14 + 1.0;
      RIPLayerResample((uint64_t)v47, v130, v95, v96, v97, v98, v99, v100);
      goto LABEL_166;
    }
LABEL_178:
    (*(void (**)(char *))(*(_QWORD *)v27 + 24))(v27);
    return 0;
  }
  *(_QWORD *)(a1 + 144) = v27;
LABEL_117:
  if (*(_DWORD *)(a1 + 112) == 1 && (*(_BYTE *)(a1 + 13) & 0x10) == 0)
  {
    if (v120)
      return (uint64_t (**)())RIPLayerBltShape((int *)a2, a3, v17, v120, v122, v121, a12, a8);
    if (v119)
      return RIPLayerBltGlyph((_DWORD *)a2, a3, v17, v119, v122, v121, 0, a12);
    if (v15)
      return (uint64_t (**)())RIPLayerBltImage(a2, a3, (uint64_t)v17, v15, a12, a6, (uint64_t)a7, a8);
    if (v118)
      return (uint64_t (**)())RIPLayerBltShade(a2, a3, (uint64_t)v17, v118, v122, a12, (uint64_t)a7, a8);
  }
  return (uint64_t (**)())v34;
}

char *rips_f_BlurRingRoundedDilation(uint64_t a1, int a2, double a3)
{
  unsigned int v3;
  unsigned int v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  char *v18;
  char *v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  char v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  _BYTE *v33;
  unint64_t v34;
  int8x16_t *v35;
  uint64_t v36;
  unint64_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t *v41;
  unint64_t i;
  unint64_t v43;
  _BYTE *v44;
  int v45;
  size_t v46;
  vImagePixelCount v47;
  char *v48;
  void *v49;
  size_t v50;
  int v51;
  char *v52;
  char *v53;
  size_t v54;
  void *v55;
  CGColorSpace *DeviceGray;
  CGContext *v57;
  const CGPath *v58;
  int integer_property;
  int v60;
  vImagePixelCount v61;
  vImagePixelCount v62;
  size_t v63;
  int v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __int128 v72;
  vImage_Buffer dest;
  vImage_Buffer src;
  int v75;
  CGRect v76;
  CGRect v77;

  v72 = *(_OWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a1 + 24);
  if (!v3)
    return 0;
  v6 = 0;
  v7 = *(_DWORD *)(a1 + 20);
  v8 = *(_QWORD *)(a1 + 56);
  v9 = vcvtmd_s64_f64(a3 * 255.0);
  v10 = *(unsigned int *)(a1 + 48);
  v11 = v8 + v10;
  v12 = 1;
  while (!v7)
  {
LABEL_20:
    v8 += v10;
    ++v6;
    v11 += v10;
    v12 = v6 < v3;
    if (v6 == v3)
      return 0;
  }
  v13 = 0;
  while (1)
  {
    v14 = *(unsigned __int8 *)(v8 + v13);
    if (v13 < v7 - 1)
      v14 = *(unsigned __int8 *)(v8 + v13 + 1);
    v15 = *(unsigned __int8 *)(v8 + v13);
    if (v6 < v3 - 1)
      v15 = *(unsigned __int8 *)(v11 + v13);
    if (v9 <= *(unsigned __int8 *)(v8 + v13))
      break;
    if (v9 <= v14 || v9 <= v15)
      goto LABEL_22;
LABEL_19:
    if (v7 == (_DWORD)++v13)
      goto LABEL_20;
  }
  if (v9 <= v14 && v9 <= v15)
    goto LABEL_19;
LABEL_22:
  if (!v12)
    return 0;
  *(_QWORD *)&v72 = (v72 - a2) | ((unint64_t)(DWORD1(v72) - a2) << 32);
  *((_QWORD *)&v72 + 1) = (DWORD2(v72) + 2 * a2) | ((unint64_t)(HIDWORD(v72) + 2 * a2) << 32);
  v18 = RIPLayerCreateWithLayer((uint64_t)RIPLayer_ripl_class, (uint64_t *)&v72, (uint64_t *)a1, *(unsigned int *)(a1 + 52));
  v19 = v18;
  if (!v18)
    return v19;
  v20 = *((_DWORD *)v18 + 12);
  if (!v20)
    return 0;
  bzero(*((void **)v18 + 7), (*((_DWORD *)v18 + 6) * v20));
  v21 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v21)
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = *(unsigned int *)(a1 + 20);
    v26 = *(_DWORD *)(a1 + 48);
    v27 = (uint8x16_t)vdupq_n_s8(v9);
    do
    {
      v28 = *(_QWORD *)(a1 + 56);
      v29 = v28 + (v26 * v24);
      v30 = -(int)v29 & 0xF;
      if (v25 >= v30)
        v31 = v30;
      else
        v31 = v25;
      if ((_DWORD)v31)
      {
        v32 = (v23 - (_BYTE)v28) & 0xF;
        if (v25 < v32)
          v32 = v25;
        v33 = (_BYTE *)(v28 + v22);
        v34 = v32;
        do
        {
          if (v9 > *v33)
            *v33 = 0;
          ++v33;
          --v34;
        }
        while (v34);
      }
      else
      {
        v31 = 0;
        LODWORD(v32) = 0;
      }
      v35 = (int8x16_t *)(v29 + v31);
      v36 = v32;
      v37 = v32 + 64;
      if (v37 <= v25)
      {
        do
        {
          LODWORD(v32) = v37;
          v38 = vbicq_s8(v35[1], (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v35[1]));
          v39 = vbicq_s8(v35[2], (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v35[2]));
          v40 = vbicq_s8(v35[3], (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v35[3]));
          *v35 = vbicq_s8(*v35, (int8x16_t)vcgtq_u8(v27, *(uint8x16_t *)v35));
          v35[1] = v38;
          v41 = v35 + 4;
          v35[2] = v39;
          v35[3] = v40;
          v36 = v37;
          v37 = v37 + 64;
          v35 += 4;
        }
        while (v37 <= v25);
        v35 = v41;
      }
      for (i = v36 + 16; i <= v25; i = i + 16)
      {
        LODWORD(v32) = i;
        *v35 = vbicq_s8(*v35, (int8x16_t)vcgtq_u8(v27, *(uint8x16_t *)v35));
        ++v35;
      }
      if (v32 < v25)
      {
        v43 = v25 - v32;
        v44 = (_BYTE *)(v28 + v22 + (unint64_t)v32);
        do
        {
          if (v9 > *v44)
            *v44 = 0;
          ++v44;
          --v43;
        }
        while (v43);
      }
      ++v24;
      v23 -= v26;
      v22 += v26;
    }
    while (v24 != v21);
  }
  v45 = 2 * a2;
  v47 = *((int *)v19 + 5);
  v46 = *((int *)v19 + 6);
  v48 = (char *)malloc_type_calloc(v46, *((unsigned int *)v19 + 12), 0x879E1AEFuLL);
  v49 = v48;
  v50 = *((unsigned int *)v19 + 12);
  if (*(int *)(a1 + 24) > 0)
  {
    v51 = 0;
    v52 = &v48[(v50 * a2) + a2];
    v53 = *(char **)(a1 + 56);
    do
    {
      memcpy(v52, v53, *(int *)(a1 + 20));
      v53 += *(unsigned int *)(a1 + 48);
      v50 = *((unsigned int *)v19 + 12);
      v52 += v50;
      ++v51;
    }
    while (v51 < *(_DWORD *)(a1 + 24));
  }
  src.data = v49;
  src.height = v46;
  src.width = v47;
  src.rowBytes = v50;
  dest = src;
  dest.data = (void *)*((_QWORD *)v19 + 7);
  v54 = v45 | 1u;
  v55 = malloc_type_malloc((v54 * v54), 0xEAE60C46uLL);
  DeviceGray = CGColorSpaceCreateDeviceGray();
  v57 = CGBitmapContextCreateWithData(v55, v54, v54, 8uLL, v54, DeviceGray, 0, 0, 0);
  CGColorSpaceRelease(DeviceGray);
  v76.origin.x = 0.0;
  v76.origin.y = 0.0;
  v76.size.width = (double)(int)v54;
  v76.size.height = (double)(int)v54;
  v58 = CGPathCreateWithEllipseInRect(v76, 0);
  CGContextSetGrayFillColor(v57, 1.0, 1.0);
  v77.origin.x = 0.0;
  v77.origin.y = 0.0;
  v77.size.width = (double)(int)v54;
  v77.size.height = (double)(int)v54;
  CGContextFillRect(v57, v77);
  CGContextSetGrayFillColor(v57, 0.0, 1.0);
  CGContextAddPath(v57, v58);
  if (v58)
    CFRelease(v58);
  CGContextDrawPath(v57, kCGPathFill);
  if (v57)
    CFRelease(v57);
  vImageDilate_Planar8(&src, &dest, 0, 0, (const unsigned __int8 *)v55, v54, v54, 0x18u);
  free(v55);
  free(v49);
  v75 = 0;
  integer_property = get_integer_property("CGFocusRingShrinkMask", (const void *(*)(const char *))copy_local_domain_value, &v75);
  v60 = v75;
  if (!integer_property)
    v60 = 1;
  if (v60 >= 1)
  {
    v62 = *(int *)(a1 + 20);
    v61 = *(int *)(a1 + 24);
    src.data = *(void **)(a1 + 56);
    src.height = v61;
    v63 = *(unsigned int *)(a1 + 48);
    src.width = v62;
    src.rowBytes = v63;
    dest = src;
    vImageMin_Planar8(&src, &dest, 0, 0, 0, (2 * v60) | 1u, (2 * v60) | 1u, 0x18u);
  }
  v64 = *(_DWORD *)(a1 + 24);
  if (v64 >= 1)
  {
    v65 = 0;
    v66 = *((_DWORD *)v19 + 12);
    v67 = *((_QWORD *)v19 + 7)
        + (*(_DWORD *)(a1 + 16) - *((_DWORD *)v19 + 4)) * v66
        - *((int *)v19 + 3)
        + *(int *)(a1 + 12);
    v68 = *(_QWORD *)(a1 + 56);
    LODWORD(v69) = *(_DWORD *)(a1 + 20);
    do
    {
      if ((int)v69 >= 1)
      {
        v70 = 0;
        do
        {
          *(_BYTE *)(v67 + v70) = (*(_BYTE *)(v67 + v70) - *(_BYTE *)(v68 + v70)) & ~((*(unsigned __int8 *)(v67 + v70) - *(unsigned __int8 *)(v68 + v70)) >> 31);
          ++v70;
          v69 = *(int *)(a1 + 20);
        }
        while (v70 < v69);
        v66 = *((_DWORD *)v19 + 12);
        v64 = *(_DWORD *)(a1 + 24);
      }
      v68 += *(unsigned int *)(a1 + 48);
      v67 += v66;
      ++v65;
    }
    while (v65 < v64);
  }
  return v19;
}

void __default_focus_ring_color_block_invoke()
{
  CGColorSpace *DeviceGray;
  __int128 v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  DeviceGray = CGColorSpaceCreateDeviceGray();
  v1 = xmmword_184F7DAD8;
  default_focus_ring_color_focus_ring_color = (uint64_t)CGColorCreate(DeviceGray, (const CGFloat *)&v1);
  CGColorSpaceRelease(DeviceGray);
}

CGContextRef CGPDFContextCreate(CGDataConsumerRef consumer, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  uint64_t v3;
  uint64_t v4;
  const __CFBoolean *Value;
  const __CFBoolean *v9;
  CFTypeID v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFNumber *v15;
  _BOOL4 v16;
  const void *v17;
  const __CFString *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CGContext *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int valuePtr;

  if (CGPDFContextCreate_once != -1)
    dispatch_once_f(&CGPDFContextCreate_once, 0, (dispatch_function_t)load_pdf_context_creator);
  if (!creator_9485)
    return 0;
  if (auxiliaryInfo)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(auxiliaryInfo, CFSTR("CGPDFContextCreatePDFA"));
    if (Value)
    {
      v9 = Value;
      v10 = CFGetTypeID(Value);
      if (v10 == CFBooleanGetTypeID())
        CFBooleanGetValue(v9);
    }
    v11 = (const __CFString *)CFDictionaryGetValue(auxiliaryInfo, CFSTR("kCGPDFContextOwnerPassword"));
    v12 = v11;
    if (v11 && !is_valid_password(v11))
      return 0;
    v13 = (const __CFString *)CFDictionaryGetValue(auxiliaryInfo, CFSTR("kCGPDFContextUserPassword"));
    v14 = v13;
    if (v13)
    {
      if (!is_valid_password(v13))
        return 0;
    }
    v15 = (const __CFNumber *)CFDictionaryGetValue(auxiliaryInfo, CFSTR("kCGPDFContextEncryptionKeyLength"));
    valuePtr = 0;
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
      v16 = 1;
    }
    else
    {
      v16 = ((unint64_t)v12 | (unint64_t)v14) != 0;
      valuePtr = 128;
    }
    v17 = CFDictionaryGetValue(auxiliaryInfo, CFSTR("kCGPDFContextEncryptionCipher"));
    if (valuePtr > 128)
      return 0;
    if (v17)
    {
      if (CFEqual(v17, CFSTR("kCGPDFContextEncryptionCipherAESv3")))
        return 0;
    }
    else if (v16)
    {
      if (valuePtr == 128)
        v18 = CFSTR("kCGPDFContextEncryptionCipherAESv2");
      else
        v18 = CFSTR("kCGPDFContextEncryptionCipherRC4");
      auxiliaryInfo = CFDictionaryCreateMutableCopy(0, 0, auxiliaryInfo);
      CFDictionarySetValue(auxiliaryInfo, CFSTR("kCGPDFContextEncryptionCipher"), v18);
    }
  }
  v19 = CGContextCreateWithDelegateAndInfo(0, 1, 0, 0, 0, 0, v3, v4);
  v27 = (CGContext *)v19;
  if (!v19)
  {
    CGPostError((uint64_t)"%s: failed to create PDF context.", v20, v21, v22, v23, v24, v25, v26, (char)"CGPDFContextCreate");
    return v27;
  }
  *(int64x2_t *)(*(_QWORD *)(v19 + 112) + 8) = vdupq_n_s64(0x4062000000000000uLL);
  v28 = creator_9485(consumer, mediaBox, auxiliaryInfo);
  *((_QWORD *)v27 + 5) = v28;
  if (!v28)
  {
    CGPostError((uint64_t)"%s: failed to create PDF context delegate.", v29, v30, v31, v32, v33, v34, v35, (char)"CGPDFContextCreate");
    CFRelease(v27);
    return 0;
  }
  return v27;
}

void load_pdf_context_creator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  const char **i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v9 = 0;
  for (i = (const char **)&links; strcmp("__CGPDFContextDelegateCreate", *i); i += 2)
  {
    if (++v9 == 7)
    {
      CGPostError((uint64_t)"Failed to load PDF context.", v11, v12, v13, v14, v15, v16, v17, a9);
      return;
    }
  }
  creator_9485 = (&links)[2 * v9 + 1];
}

uint64_t is_valid_password(const __CFString *a1)
{
  CFTypeID v2;
  CFIndex Length;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char usedBufLen;
  CFRange v13;

  v2 = CFGetTypeID(a1);
  if (v2 != CFStringGetTypeID())
    return 0;
  Length = CFStringGetLength(a1);
  if (Length)
  {
    v13.location = 0;
    v13.length = Length;
    if (CFStringGetBytes(a1, v13, 0x600u, 0, 0, 0, Length, 0) < Length)
    {
      CGPostError((uint64_t)"Specified password cannot be converted to ASCII.", v4, v5, v6, v7, v8, v9, v10, usedBufLen);
      return 0;
    }
  }
  return 1;
}

CGContextRef CGPDFContextCreateWithURL(CFURLRef url, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  CGDataConsumer *v5;
  CGContext *v6;

  v5 = CGDataConsumerCreateWithURL(url);
  v6 = CGPDFContextCreate(v5, mediaBox, auxiliaryInfo);
  if (v5)
    CFRelease(v5);
  return v6;
}

CGContextRef CGPDFContextCreateWithFilename(char *cStr, const CGRect *a2, const __CFDictionary *a3)
{
  const __CFString *v5;
  const __CFString *v6;
  const __CFURL *v7;
  CGDataConsumer *v8;
  CGContextRef v9;

  v5 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = CFURLCreateWithFileSystemPath(0, v5, kCFURLPOSIXPathStyle, 0);
  CFRelease(v6);
  if (!v7)
    return 0;
  v8 = CGDataConsumerCreateWithURL(v7);
  v9 = CGPDFContextCreate(v8, a2, a3);
  if (v8)
    CFRelease(v8);
  CFRelease(v7);
  return v9;
}

void CGPDFContextClose(CGContextRef context)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
    CGContextDelegateFinalize(*((_QWORD *)context + 5));
  else
    handle_invalid_context((char)"CGPDFContextClose", (uint64_t)context, v1, v2, v3, v4, v5, v6);
}

void CGPDFContextBeginPage(CGContextRef context, CFDictionaryRef pageInfo)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  uint64_t v10;
  void (*v11)(void);

  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    v9 = *((_DWORD *)context + 22);
    *((_DWORD *)context + 22) = v9 + 1;
    if (v9)
    {
      CGPostError((uint64_t)"%s: Don't nest calls to this function -- the results will not be what you expect.", (uint64_t)pageInfo, v2, v3, v4, v5, v6, v7, (char)"CGPDFContextBeginPage");
    }
    else
    {
      CGContextResetTopGState(context, (uint64_t)pageInfo, v2, v3, v4, v5, v6, v7);
      v10 = *((_QWORD *)context + 5);
      if (v10)
      {
        v11 = *(void (**)(void))(v10 + 152);
        if (v11)
          v11();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextBeginPage", (uint64_t)context, v2, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextEndPage(CGContextRef context)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  void (*v10)(void);

  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    v8 = *((_DWORD *)context + 22) - 1;
    *((_DWORD *)context + 22) = v8;
    if (v8)
    {
      CGPostError((uint64_t)"%s: Don't nest calls to this function -- the results will not be what you expect.", v1, v2, v3, v4, v5, v6, v7, (char)"CGPDFContextEndPage");
    }
    else
    {
      v9 = *((_QWORD *)context + 5);
      if (v9)
      {
        v10 = *(void (**)(void))(v9 + 160);
        if (v10)
          v10();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextEndPage", (uint64_t)context, v2, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextSetURLForRect(CGContextRef context, CFURLRef url, CGRect rect)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double height;
  double width;
  double y;
  double x;
  const CFDictionaryKeyCallBacks *v15;
  const CFDictionaryValueCallBacks *v16;
  __CFDictionary *Mutable;
  __CFDictionary *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double *v27;
  __CFArray *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CGContextRef v35;

  if (!context)
  {
    v35 = 0;
LABEL_11:
    handle_invalid_context((char)"CGPDFContextSetURLForRect", (uint64_t)v35, v3, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)context + 4) != 1129601108)
  {
    v35 = context;
    goto LABEL_11;
  }
  if (*((_DWORD *)context + 6) == 1)
  {
    height = rect.size.height;
    width = rect.size.width;
    y = rect.origin.y;
    x = rect.origin.x;
    v15 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v16 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v18 = CFDictionaryCreateMutable(0, 0, v15, v16);
    CFDictionarySetValue(v18, CFSTR("/Type"), CFSTR("/Action"));
    CFDictionarySetValue(v18, CFSTR("/S"), CFSTR("/URI"));
    CFDictionarySetValue(v18, CFSTR("/URI"), url);
    CFDictionarySetValue(Mutable, CFSTR("/A"), v18);
    CFDictionarySetValue(Mutable, CFSTR("/Type"), CFSTR("/Annot"));
    CFDictionarySetValue(Mutable, CFSTR("/Subtype"), CFSTR("/Link"));
    if (v18)
      CFRelease(v18);
    v27 = CGContainerCreateWithRect(x, y, width, height, v19, v20, v21, v22, v23, v24, v25, v26);
    CFDictionarySetValue(Mutable, CFSTR("/Rect"), v27);
    CFRelease(v27);
    v28 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    CGCFArrayAppendInteger(v28, 0);
    CGCFArrayAppendInteger(v28, 0);
    CGCFArrayAppendInteger(v28, 0);
    CFDictionarySetValue(Mutable, CFSTR("/Border"), v28);
    if (v28)
      CFRelease(v28);
    CGPDFContextAddAnnotation((uint64_t)context, Mutable, v29, v30, v31, v32, v33, v34);
    CFRelease(Mutable);
  }
}

void CGPDFContextAddAnnotation(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  __CFDictionary *MutableCopy;
  uint64_t v14;
  void (*v15)(void);
  uint64_t v16;
  void *value;

  if (!a1)
  {
    v16 = 0;
LABEL_20:
    handle_invalid_context((char)"CGPDFContextAddAnnotation", v16, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v16 = a1;
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("Subtype"), (const void **)&value)
      && (v10 = CFGetTypeID(value), v10 == CFStringGetTypeID())
      && CFStringCompare((CFStringRef)value, CFSTR("Screen"), 0)
      && CFDictionaryGetValueIfPresent(theDict, CFSTR("P"), (const void **)&value)
      && (v11 = CFGetTypeID(value), v11 == CFDictionaryGetTypeID())
      && CFDictionaryGetValueIfPresent((CFDictionaryRef)value, CFSTR("Type"), (const void **)&value)
      && (v12 = CFGetTypeID(value), v12 == CFStringGetTypeID())
      && CFStringCompare((CFStringRef)value, CFSTR("Page"), 0) == kCFCompareEqualTo)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
      CFDictionaryRemoveValue(MutableCopy, CFSTR("P"));
    }
    else
    {
      MutableCopy = (__CFDictionary *)CFRetain(theDict);
    }
    v14 = *(_QWORD *)(a1 + 40);
    if (v14)
    {
      v15 = *(void (**)(void))(v14 + 168);
      if (v15)
        v15();
    }
    CFRelease(MutableCopy);
  }
}

void CGPDFContextAddDestinationAtPoint(CGContextRef context, CFStringRef name, CGPoint point)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double y;
  double x;
  __CFDictionary *Mutable;
  uint64_t v14;
  void (*v15)(void);
  CGContextRef v16;

  if (!context)
  {
    v16 = 0;
LABEL_11:
    handle_invalid_context((char)"CGPDFContextAddDestinationAtPoint", (uint64_t)v16, v3, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)context + 4) != 1129601108)
  {
    v16 = context;
    goto LABEL_11;
  }
  if (*((_DWORD *)context + 6) == 1)
  {
    y = point.y;
    x = point.x;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("Label"), name);
    CGCFDictionarySetPoint(Mutable, CFSTR("Point"), x, y);
    v14 = *((_QWORD *)context + 5);
    if (v14)
    {
      v15 = *(void (**)(void))(v14 + 168);
      if (v15)
        v15();
    }
    if (Mutable)
      CFRelease(Mutable);
  }
}

void CGPDFContextSetDestinationForRect(CGContextRef context, CFStringRef name, CGRect rect)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double height;
  double width;
  double y;
  double x;
  __CFDictionary *Mutable;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double *v24;
  __CFString *v25;
  __CFArray *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CGContextRef v33;

  if (!context)
  {
    v33 = 0;
LABEL_9:
    handle_invalid_context((char)"CGPDFContextSetDestinationForRect", (uint64_t)v33, v3, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)context + 4) != 1129601108)
  {
    v33 = context;
    goto LABEL_9;
  }
  if (*((_DWORD *)context + 6) == 1)
  {
    height = rect.size.height;
    width = rect.size.width;
    y = rect.origin.y;
    x = rect.origin.x;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("/Type"), CFSTR("/Annot"));
    CFDictionarySetValue(Mutable, CFSTR("/Subtype"), CFSTR("/Link"));
    v24 = CGContainerCreateWithRect(x, y, width, height, v16, v17, v18, v19, v20, v21, v22, v23);
    CFDictionarySetValue(Mutable, CFSTR("/Rect"), v24);
    CFRelease(v24);
    v25 = CFStringCreateMutable(0, 0);
    CFStringAppend(v25, CFSTR("/>"));
    CFStringAppend(v25, name);
    CFDictionarySetValue(Mutable, CFSTR("/Dest"), v25);
    CFRelease(v25);
    v26 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    CGCFArrayAppendInteger(v26, 0);
    CGCFArrayAppendInteger(v26, 0);
    CGCFArrayAppendInteger(v26, 0);
    CFDictionarySetValue(Mutable, CFSTR("/Border"), v26);
    if (v26)
      CFRelease(v26);
    CGPDFContextAddAnnotation((uint64_t)context, Mutable, v27, v28, v29, v30, v31, v32);
    CFRelease(Mutable);
  }
}

void CGPDFContextAddCatalogEntry(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  __CFDictionary *Mutable;
  uint64_t v15;
  void (*v16)(void);

  if (!a1)
  {
    v13 = 0;
LABEL_14:
    handle_invalid_context((char)"CGPDFContextAddCatalogEntry", v13, (uint64_t)a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v13 = a1;
    goto LABEL_14;
  }
  if (*(_DWORD *)(a1 + 24) == 1 && a2 != 0 && a3 != 0)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("Key"), a2);
    CFDictionarySetValue(Mutable, CFSTR("Value"), a3);
    v15 = *(_QWORD *)(a1 + 40);
    if (v15)
    {
      v16 = *(void (**)(void))(v15 + 168);
      if (v16)
        v16();
    }
    if (Mutable)
      CFRelease(Mutable);
  }
}

void CGPDFContextAddDocumentMetadata(CGContextRef context, CFDataRef metadata)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *Mutable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    if (metadata)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("/Type"), CFSTR("/Metadata"));
      CFDictionarySetValue(Mutable, CFSTR("/Subtype"), CFSTR("/XML"));
      CFDictionarySetValue(Mutable, CFSTR("/%Stream"), metadata);
      CGPDFContextAddCatalogEntry((uint64_t)context, CFSTR("/Metadata"), Mutable, v11, v12, v13, v14, v15);
      CFRelease(Mutable);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextAddDocumentMetadata", (uint64_t)context, v2, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextSetParentTree(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  uint64_t v12;
  void (*v13)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = Mutable;
    if (a2)
      CFDictionarySetValue(Mutable, CFSTR("ParentTree"), a2);
    v12 = *(_QWORD *)(a1 + 40);
    if (v12)
    {
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
    }
    if (v11)
      CFRelease(v11);
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetParentTree", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetIDTree(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  uint64_t v12;
  void (*v13)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = Mutable;
    if (a2)
      CFDictionarySetValue(Mutable, CFSTR("IDTree"), a2);
    v12 = *(_QWORD *)(a1 + 40);
    if (v12)
    {
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
    }
    if (v11)
      CFRelease(v11);
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetIDTree", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetPageTagStructureTree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetPageTagStructureTree", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextAddPDFXInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextAddPDFXInfo", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetOutputIntent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetOutputIntent", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetShouldDeflate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  const void **v12;
  uint64_t v13;
  void (*v14)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = Mutable;
    v12 = (const void **)MEMORY[0x1E0C9AE50];
    if (!a2)
      v12 = (const void **)MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(Mutable, CFSTR("ShouldDeflate"), *v12);
    v13 = *(_QWORD *)(a1 + 40);
    if (v13)
    {
      v14 = *(void (**)(void))(v13 + 168);
      if (v14)
        v14();
    }
    if (v11)
      CFRelease(v11);
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetShouldDeflate", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextBeginDrawingHiddenText(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextBeginDrawingHiddenText", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextEndDrawingHiddenText(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextEndDrawingHiddenText", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetImageTag(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Mutable;
  uint64_t v12;
  void (*v13)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    if (a2 && a3)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("Image"), a2);
      CFDictionarySetValue(Mutable, CFSTR("Tag"), a3);
      v12 = *(_QWORD *)(a1 + 40);
      if (v12)
      {
        v13 = *(void (**)(void))(v12 + 168);
        if (v13)
          v13();
      }
      if (Mutable)
        CFRelease(Mutable);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetImageTag", a1, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetOutline(CGContextRef context, CFDictionaryRef outline)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFDictionary *v16;
  CGContextRef v17;

  if (!outline)
  {
    if (context)
    {
      if (*((_DWORD *)context + 4) == 1129601108)
        return;
      v17 = context;
    }
    else
    {
      v17 = 0;
    }
    handle_invalid_context((char)"CGPDFContextAddCatalogEntry", (uint64_t)v17, v2, v3, v4, v5, v6, v7);
    return;
  }
  if (!CFDictionaryContainsKey(outline, CFSTR("Title")))
  {
    v10 = convertOutlineTree(outline);
    if (v10)
    {
      v16 = v10;
      CGPDFContextAddCatalogEntry((uint64_t)context, CFSTR("/Outlines"), v10, v11, v12, v13, v14, v15);
      CFRelease(v16);
    }
  }
}

__CFDictionary *convertOutlineTree(const __CFDictionary *a1)
{
  __CFDictionary *Mutable;
  const void *Value;
  const void *v4;
  CFTypeID v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  int v8;
  int v9;
  CFArrayRef v10;
  CFTypeRef v11;
  CFTypeID v12;
  const __CFString *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  CFIndex Count;
  __n128 v17;
  CFIndex v18;
  unint64_t v19;
  char *v20;
  size_t v21;
  CFIndex v22;
  uint64_t v23;
  const void *ValueAtIndex;
  uint64_t v25;
  __CFDictionary *v26;
  char *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  const void **v31;
  void *v32;
  CFNumberRef v33;
  CFNumberRef v35;
  const __CFNumber *v36;
  double v37;
  double v38;
  void *values;
  const __CFString *v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  __int128 valuePtr;
  double v46[3];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Value = CFDictionaryGetValue(a1, CFSTR("Title"));
  if (!Value)
    goto LABEL_15;
  CFDictionarySetValue(Mutable, CFSTR("/Title"), Value);
  v4 = CFDictionaryGetValue(a1, CFSTR("Destination"));
  v5 = CFGetTypeID(v4);
  if (v5 == CFNumberGetTypeID())
  {
    v6 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("DestinationRect"));
    valuePtr = 0u;
    *(_OWORD *)v46 = 0u;
    if (v6 && (v7 = v6, get_point_from_dict(v6, (double *)&valuePtr), v8) && (get_size_from_dict(v7, v46), v9))
    {
      if (fabs(v46[0]) <= 2.22044605e-16 || fabs(v46[1]) <= 2.22044605e-16)
      {
        values = (void *)CFStringCreateWithFormat(0, 0, CFSTR("/#%@"), v4);
        v40 = CFSTR("/XYZ");
        v41 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
        v35 = CFNumberCreate(0, kCFNumberCGFloatType, (char *)&valuePtr + 8);
        v36 = (const __CFNumber *)*MEMORY[0x1E0C9B0D0];
        v42 = v35;
        v43 = v36;
        v10 = CFArrayCreate(0, (const void **)&values, 5, MEMORY[0x1E0C9B378]);
        CFRelease(values);
        CFRelease(v41);
        v11 = v42;
      }
      else
      {
        v37 = v46[1] + *((double *)&valuePtr + 1);
        v38 = v46[0] + *(double *)&valuePtr;
        values = (void *)CFStringCreateWithFormat(0, 0, CFSTR("/#%@"), v4);
        v40 = CFSTR("/FitR");
        v41 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
        v42 = CFNumberCreate(0, kCFNumberCGFloatType, (char *)&valuePtr + 8);
        v43 = CFNumberCreate(0, kCFNumberCGFloatType, &v38);
        v44 = CFNumberCreate(0, kCFNumberCGFloatType, &v37);
        v10 = CFArrayCreate(0, (const void **)&values, 6, MEMORY[0x1E0C9B378]);
        CFRelease(values);
        CFRelease(v41);
        CFRelease(v42);
        CFRelease(v43);
        v11 = v44;
      }
    }
    else
    {
      values = (void *)CFStringCreateWithFormat(0, 0, CFSTR("/#%@"), v4);
      v40 = CFSTR("/XYZ");
      v41 = (CFNumberRef)*MEMORY[0x1E0C9B0D0];
      v42 = v41;
      v43 = v41;
      v10 = CFArrayCreate(0, (const void **)&values, 5, MEMORY[0x1E0C9B378]);
      v11 = values;
    }
    CFRelease(v11);
    v13 = CFSTR("/Dest");
    goto LABEL_14;
  }
  v12 = CFGetTypeID(v4);
  if (v12 != CFURLGetTypeID())
  {
    CFRelease(Mutable);
    return 0;
  }
  values = CFSTR("/S");
  v40 = CFSTR("/URI");
  *(_QWORD *)&valuePtr = CFSTR("/URI");
  *((_QWORD *)&valuePtr + 1) = CFURLGetString((CFURLRef)v4);
  v10 = CFDictionaryCreate(0, (const void **)&values, (const void **)&valuePtr, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v13 = CFSTR("/A");
LABEL_14:
  CFDictionarySetValue(Mutable, v13, v10);
  CFRelease(v10);
LABEL_15:
  v14 = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("Children"));
  if (v14)
  {
    v15 = v14;
    Count = CFArrayGetCount(v14);
    v18 = Count;
    values = (void *)Count;
    if (Count < 1)
    {
      v23 = Count;
      if (Value)
        goto LABEL_30;
    }
    else
    {
      v19 = 8 * Count;
      MEMORY[0x1E0C80A78](Count, v17);
      v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
      if (v19 >= 0x200)
        v21 = 512;
      else
        v21 = 8 * v18;
      bzero((char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0), v21);
      bzero((char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0), 8 * v18);
      v22 = 0;
      v23 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v15, v22);
        v25 = convertOutlineTree(ValueAtIndex);
        if (v25)
          *(_QWORD *)&v20[8 * v23++] = v25;
        ++v22;
      }
      while (v18 != v22);
      values = (void *)v23;
      v26 = *(__CFDictionary **)v20;
      CFDictionarySetValue(Mutable, CFSTR("/First"), *(const void **)v20);
      v27 = &v20[8 * v23];
      v28 = (void *)*((_QWORD *)v27 - 1);
      CFDictionarySetValue(Mutable, CFSTR("/Last"), v28);
      if (v23 > 1)
      {
        v29 = (void *)*((_QWORD *)v20 + 1);
        CFDictionarySetValue(v26, CFSTR("/Next"), v29);
        CFDictionarySetValue((CFMutableDictionaryRef)v28, CFSTR("/Prev"), *((const void **)v27 - 2));
        v30 = v23 - 2;
        if (v23 != 2)
        {
          v31 = (const void **)(v20 + 16);
          do
          {
            v32 = (void *)*v31;
            CFDictionarySetValue((CFMutableDictionaryRef)v29, CFSTR("/Next"), *v31);
            CFDictionarySetValue((CFMutableDictionaryRef)v29, CFSTR("/Prev"), *(v31 - 2));
            ++v31;
            v29 = v32;
            --v30;
          }
          while (v30);
        }
      }
      if (Value)
        goto LABEL_30;
    }
    values = (void *)-v23;
LABEL_30:
    v33 = CFNumberCreate(0, kCFNumberSInt64Type, &values);
    CFDictionarySetValue(Mutable, CFSTR("/Count"), v33);
    CFRelease(v33);
  }
  return Mutable;
}

const char *__cdecl CGPDFTagTypeGetName(CGPDFTagType tagType)
{
  const char *result;
  __int32 v2;

  if (tagType <= 399)
  {
    v2 = tagType - 100;
    result = "/Document";
    switch(v2)
    {
      case 0:
        return result;
      case 1:
        result = "/Part";
        break;
      case 2:
        result = "/Art";
        break;
      case 3:
        result = "/Sect";
        break;
      case 4:
        result = "/Div";
        break;
      case 5:
        result = "/BlockQuote";
        break;
      case 6:
        result = "/Caption";
        break;
      case 7:
        result = "/TOC";
        break;
      case 8:
        result = "/TOCI";
        break;
      case 9:
        result = "/Index";
        break;
      case 10:
        result = "/NonStruct";
        break;
      case 11:
        result = "/Private";
        break;
      default:
        switch("/Document")
        {
          case 0xC8u:
            result = "/P";
            break;
          case 0xC9u:
            result = "/H";
            break;
          case 0xCAu:
            result = "/H1";
            break;
          case 0xCBu:
            result = "/H2";
            break;
          case 0xCCu:
            result = "/H3";
            break;
          case 0xCDu:
            result = "/H4";
            break;
          case 0xCEu:
            result = "/H5";
            break;
          case 0xCFu:
            result = "/H6";
            break;
          default:
            switch("/Document")
            {
              case 0x12Cu:
                result = "/L";
                break;
              case 0x12Du:
                result = "/LI";
                break;
              case 0x12Eu:
                result = "/Lbl";
                break;
              case 0x12Fu:
                result = "/LBody";
                break;
              default:
                return 0;
            }
            break;
        }
        break;
    }
  }
  else if (tagType > 599)
  {
    if (tagType > 699)
    {
      if (tagType > CGPDFTagTypeFormula)
      {
        if (tagType == CGPDFTagTypeForm)
        {
          return "/Form";
        }
        else if (tagType == 800)
        {
          return "/OBJR";
        }
        else
        {
          return 0;
        }
      }
      else if (tagType == CGPDFTagTypeFigure)
      {
        return "/Figure";
      }
      else
      {
        return "/Formula";
      }
    }
    else
    {
      switch(tagType)
      {
        case CGPDFTagTypeRuby:
          result = "/Ruby";
          break;
        case CGPDFTagTypeRubyBaseText:
          result = "/RB";
          break;
        case CGPDFTagTypeRubyAnnotationText:
          result = "/RT";
          break;
        case CGPDFTagTypeRubyPunctuation:
          result = "/RP";
          break;
        case CGPDFTagTypeWarichu:
          result = "/Warichu";
          break;
        case CGPDFTagTypeWarichuText:
          result = "/WT";
          break;
        case CGPDFTagTypeWarichuPunctiation:
          result = "/WP";
          break;
        default:
          return 0;
      }
    }
  }
  else
  {
    switch(tagType)
    {
      case CGPDFTagTypeSpan:
        result = "/Span";
        break;
      case CGPDFTagTypeQuote:
        result = "/Quote";
        break;
      case CGPDFTagTypeNote:
        result = "/Note";
        break;
      case CGPDFTagTypeReference:
        result = "/Reference";
        break;
      case CGPDFTagTypeBibliography:
        result = "/BibEntry";
        break;
      case CGPDFTagTypeCode:
        result = "/Code";
        break;
      case CGPDFTagTypeLink:
        result = "/Link";
        break;
      case CGPDFTagTypeAnnotation:
        result = "/Annot";
        break;
      default:
        switch(tagType)
        {
          case CGPDFTagTypeTable:
            result = "/Table";
            break;
          case CGPDFTagTypeTableRow:
            result = "/TR";
            break;
          case CGPDFTagTypeTableHeaderCell:
            result = "/TH";
            break;
          case CGPDFTagTypeTableDataCell:
            result = "/TD";
            break;
          case CGPDFTagTypeTableHeader:
            result = "/THead";
            break;
          case CGPDFTagTypeTableBody:
            result = "/TBody";
            break;
          case CGPDFTagTypeTableFooter:
            result = "/TFoot";
            break;
          default:
            return 0;
        }
        break;
    }
  }
  return result;
}

void CGPDFContextBeginTag(CGContextRef context, CGPDFTagType tagType, CFDictionaryRef tagProperties)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *Mutable;
  uint64_t v12;
  void (*v13)(void);

  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CGCFDictionarySetInteger(Mutable, CFSTR("TagType"), tagType);
    if (tagProperties)
      CFDictionarySetValue(Mutable, CFSTR("TagProperties"), tagProperties);
    v12 = *((_QWORD *)context + 5);
    if (v12)
    {
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
    }
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextBeginTag", (uint64_t)context, (uint64_t)tagProperties, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextEndTag(CGContextRef context)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(void);

  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    v7 = *((_QWORD *)context + 5);
    if (v7)
    {
      v8 = *(void (**)(void))(v7 + 168);
      if (v8)
        v8();
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextEndTag", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  }
}

void CGPDFContextSetRedactionPath(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  uint64_t v12;
  void (*v13)(void);

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v11 = Mutable;
    if (a2)
      CFDictionarySetValue(Mutable, CFSTR("RedactionPath"), a2);
    v12 = *(_QWORD *)(a1 + 40);
    if (v12)
    {
      v13 = *(void (**)(void))(v12 + 168);
      if (v13)
        v13();
    }
    if (v11)
      CFRelease(v11);
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetRedactionPath", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextBeginAccessibilitySpan(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);
  uint64_t v10;

  if (!a1)
  {
    v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGPDFContextBeginAccessibilitySpan", v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v10 = a1;
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
}

void CGPDFContextEndAccessibilitySpan(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void (*v9)(void);
  uint64_t v10;

  if (!a1)
  {
    v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGPDFContextEndAccessibilitySpan", v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v10 = a1;
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (v8)
    {
      v9 = *(void (**)(void))(v8 + 168);
      if (v9)
        v9();
    }
  }
}

const __CFString *CGPDFContextIsValidPassword(const __CFString *result)
{
  const __CFString *v1;
  uint64_t Length;
  CFRange v3;

  if (result)
  {
    v1 = result;
    Length = CFStringGetLength(result);
    if (Length <= 32)
    {
      v3.location = 0;
      v3.length = Length;
      return (const __CFString *)(CFStringGetBytes(v1, v3, 0x600u, 0, 0, 0, 0, 0) == Length);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void Type1::~Type1(Type1 *this)
{
  SimpleFont::~SimpleFont(this);
  JUMPOUT(0x186DC23C4);
}

uint64_t Type1::get_format(Type1 *this)
{
  return 2;
}

_QWORD *Type1::create_subset(uint64_t a1, int a2)
{
  _QWORD *v4;
  void *v6[2];
  char v7;
  void *__p[2];
  char v9;

  v4 = (_QWORD *)operator new();
  std::string::basic_string[abi:se180100]<0>((char **)v6, "Ty");
  PDFFont::get_next_subset_name((uint64_t)__p, *(_QWORD *)(a1 + 8), (uint64_t)v6);
  FontSubset::FontSubset((uint64_t)v4, a1, (__int128 *)__p, a2);
  *v4 = &off_1E1627E58;
  if (v9 < 0)
    operator delete(__p[0]);
  if (v7 < 0)
    operator delete(v6[0]);
  return v4;
}

void sub_184C79BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  if (a20 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  MEMORY[0x186DC23C4](v20, 0x10F3C4094E7248ELL);
  _Unwind_Resume(a1);
}

void sub_184C79D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184C79DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184C79EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184C7A0F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184C7A244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__9668(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__9669(uint64_t a1)
{

}

CGShadingRef CGShadingCreateAxial(CGColorSpaceRef space, CGPoint start, CGPoint end, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  uint64_t v6;
  _BOOL8 v7;
  double *v8;

  v7 = extendEnd;
  if (function)
    v8 = (double *)*((_QWORD *)function + 5);
  else
    v8 = 0;
  return (CGShadingRef)CGShadingCreateAxialInternal(space, 0, 0, v8, function, extendStart, v7, v6, start.x, start.y, end.x, end.y);
}

BOOL shading_equal(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16);
}

uint64_t shading_hash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

CGShadingRef CGShadingCreateRadial(CGColorSpaceRef space, CGPoint start, CGFloat startRadius, CGPoint end, CGFloat endRadius, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  uint64_t v8;
  _BOOL8 v9;
  double *v10;

  v9 = extendEnd;
  if (function)
    v10 = (double *)*((_QWORD *)function + 5);
  else
    v10 = 0;
  return (CGShadingRef)CGShadingCreateRadialInternal(space, 0, 0, v10, function, extendStart, v9, v8, start.x, start.y, startRadius, end.x, end.y, endRadius);
}

uint64_t CGShadingCreateConic(_QWORD *a1, _QWORD *a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v12;
  uint64_t v13;
  double *v18;
  uint64_t Empty;
  double v20;

  if (!a2 || !a1)
    return 0;
  v12 = *(_QWORD *)(a1[3] + 40);
  v13 = a2[6];
  if (v13 != v12 && v13 != v12 + 1)
    return 0;
  v18 = (double *)a2[5];
  Empty = CGShadingCreateEmpty(3, a1, 0, 0, a8, a9, a10, a11);
  *(double *)(Empty + 120) = a3;
  *(double *)(Empty + 128) = a4;
  *(double *)(Empty + 136) = a5;
  CFRetain(a2);
  *(_QWORD *)(Empty + 160) = a2;
  if (v18)
  {
    *(double *)(Empty + 144) = *v18;
    v20 = v18[1];
  }
  else
  {
    *(_QWORD *)(Empty + 144) = 0;
    v20 = 1.0;
  }
  *(double *)(Empty + 152) = v20;
  return Empty;
}

uint64_t CGShadingCreateCustom(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t Empty;
  uint64_t v11;
  uint64_t v12;
  uint64_t v15;
  __int128 v16;
  __int128 v17;

  Empty = 0;
  if (a1 && a6)
  {
    v11 = *(_QWORD *)(a1[3] + 40);
    v12 = a6[6];
    if (v12 == v11 || v12 == v11 + 1)
    {
      Empty = CGShadingCreateEmpty(4, a1, a2, a3, (uint64_t)a5, (uint64_t)a6, a7, a8);
      CFRetain(a6);
      v15 = 0;
      *(_QWORD *)(Empty + 152) = a6;
      v17 = a5[1];
      v16 = a5[2];
      *(_OWORD *)(Empty + 160) = *a5;
      *(_OWORD *)(Empty + 176) = v17;
      *(_OWORD *)(Empty + 192) = v16;
      do
      {
        *(_QWORD *)(Empty + v15 + 120) = *(_QWORD *)(a4 + v15);
        v15 += 8;
      }
      while (v15 != 32);
    }
    else
    {
      return 0;
    }
  }
  return Empty;
}

CGShadingRef CGShadingRetain(CGShadingRef shading)
{
  if (shading)
    CFRetain(shading);
  return shading;
}

void CGShadingRelease(CGShadingRef shading)
{
  if (shading)
    CFRelease(shading);
}

uint64_t CGShadingGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t CGShadingGetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t CGShadingGetColorSpace(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t CGShadingGetBackground(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

CGFloat CGShadingGetBounds(uint64_t a1)
{
  const CGRect *v1;

  v1 = &CGRectInfinite;
  if (*(_BYTE *)(a1 + 40))
    v1 = (const CGRect *)(a1 + 48);
  return v1->origin.x;
}

uint64_t CGShadingGetDescriptor(uint64_t result)
{
  if (result)
  {
    if ((*(_DWORD *)(result + 20) - 1) >= 4)
      return 0;
    else
      result += 120;
  }
  return result;
}

unint64_t CGShadingSetAssociate(unint64_t result, unint64_t a2)
{
  unint64_t *v2;

  if (result)
  {
    v2 = (unint64_t *)(result + 88);
    while (!__ldxr(v2))
    {
      if (!__stxr(a2, v2))
        return *v2;
    }
    __clrex();
    return *v2;
  }
  return result;
}

uint64_t CGShadingGetAssociate(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 88);
  return result;
}

CFTypeID CGShadingGetTypeID(void)
{
  if (_block_invoke_once_9690 != -1)
    dispatch_once(&_block_invoke_once_9690, &__block_literal_global_4_9691);
  return CGShadingGetTypeID_shading_type_id;
}

uint64_t CGShadingDelegateDrawShading(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGShadingDrawInContextDelegate(a4, a1, a2, a3, a5, a6, a7, a8);
  return 1;
}

void CGShadingDrawInContextDelegate(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;

  if (a1 && *(_QWORD *)(a1 + 104))
  {
    v9 = (const void *)CGContextCreateWithDelegateAndInfo(a2, 0, a3, a4, 0, 0, a7, a8);
    (*(void (**)(_QWORD, const void *))(a1 + 104))(*(_QWORD *)(a1 + 80), v9);
    if (v9)
      CFRelease(v9);
  }
}

double cmap_yyensure_buffer_stack(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  double result;
  _QWORD *v8;

  v2 = (void *)a1[5];
  if (v2)
  {
    v3 = a1[4];
    if (a1[3] >= (unint64_t)(v3 - 1))
    {
      v4 = v3 + 8;
      v5 = (char *)malloc_type_realloc(v2, 8 * (v3 + 8), 0xF93AD230uLL);
      a1[5] = v5;
      if (v5)
      {
        v6 = &v5[8 * a1[4]];
        result = 0.0;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *(_OWORD *)v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        a1[4] = v4;
        return result;
      }
LABEL_8:
      fatal_scanner_error();
    }
  }
  else
  {
    v8 = malloc_type_malloc(8uLL, 0x8B871889uLL);
    a1[5] = v8;
    if (!v8)
      goto LABEL_8;
    *v8 = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 3) = xmmword_185004A00;
  }
  return result;
}

uint64_t cmap_yy_create_buffer(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void *v6;

  v4 = malloc_type_malloc(0x48uLL, 0x8B871889uLL);
  if (!v4
    || (v5 = (uint64_t)v4,
        v4[3] = 0x4000,
        v6 = malloc_type_malloc(0x4002uLL, 0x8B871889uLL),
        (*(_QWORD *)(v5 + 8) = v6) == 0))
  {
    fatal_scanner_error();
  }
  *(_DWORD *)(v5 + 40) = 1;
  cmap_yy_init_buffer(v5, a1, a2);
  return v5;
}

void fatal_scanner_error()
{
  abort();
}

uint64_t yy_get_previous_state(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(unsigned int *)(a1 + 84);
  v2 = *(_BYTE **)(a1 + 136);
  v3 = *(_BYTE **)(a1 + 72);
  if (v2 < v3)
  {
    do
    {
      if (*v2)
        v4 = yy_ec[*v2];
      else
        v4 = 2u;
      if (yy_accept[(int)v1])
      {
        *(_DWORD *)(a1 + 112) = v1;
        *(_QWORD *)(a1 + 120) = v2;
      }
      v5 = (int)v1;
      v6 = yy_base[(int)v1] + v4;
      if ((_DWORD)v1 != (__int16)yy_chk[v6])
      {
        do
        {
          v5 = yy_def[v5];
          if (v5 >= 253)
            v4 = yy_meta[v4];
          v6 = yy_base[v5] + v4;
        }
        while (yy_chk[v6] != (unsigned __int16)v5);
      }
      v1 = yy_nxt[v6];
      ++v2;
    }
    while (v2 != v3);
  }
  return v1;
}

int *cmap_yy_init_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  int *result;

  v6 = *__error();
  if (a1)
  {
    *(_QWORD *)(a1 + 32) = 0;
    **(_BYTE **)(a1 + 8) = 0;
    *(_BYTE *)(*(_QWORD *)(a1 + 8) + 1) = 0;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 64) = 0;
    v7 = *(_QWORD *)(a3 + 40);
    if (v7)
      v8 = *(_QWORD *)(v7 + 8 * *(_QWORD *)(a3 + 24));
    else
      v8 = 0;
    if (v8 == a1)
    {
      v9 = *(_QWORD *)(a3 + 24);
      v10 = *(_QWORD *)(v7 + 8 * v9);
      *(_QWORD *)(a3 + 56) = *(_QWORD *)(v10 + 32);
      v11 = *(_BYTE **)(v10 + 16);
      *(_QWORD *)(a3 + 72) = v11;
      *(_QWORD *)(a3 + 136) = v11;
      *(_QWORD *)(a3 + 8) = **(_QWORD **)(v7 + 8 * v9);
      *(_BYTE *)(a3 + 48) = *v11;
      *(_QWORD *)a1 = a2;
      *(_DWORD *)(a1 + 60) = 1;
      goto LABEL_10;
    }
  }
  else
  {
    v7 = *(_QWORD *)(a3 + 40);
  }
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 1;
  if (v7)
LABEL_10:
    v7 = *(_QWORD *)(v7 + 8 * *(_QWORD *)(a3 + 24));
  if (v7 != a1)
    *(_QWORD *)(a1 + 52) = 1;
  *(_DWORD *)(a1 + 44) = 0;
  result = __error();
  *result = v6;
  return result;
}

void cmap_yy_delete_buffer(void **a1, uint64_t a2)
{
  uint64_t v3;
  void **v4;

  v3 = *(_QWORD *)(a2 + 40);
  if (v3)
    v4 = *(void ***)(v3 + 8 * *(_QWORD *)(a2 + 24));
  else
    v4 = 0;
  if (v4 == a1)
    *(_QWORD *)(v3 + 8 * *(_QWORD *)(a2 + 24)) = 0;
  if (*((_DWORD *)a1 + 10))
    free(a1[1]);
  free(a1);
}

void CGPDFSecurityManagerRelease(uint64_t a1)
{
  void *v2;
  void *v3;

  if (a1)
  {
    v2 = *(void **)(a1 + 32);
    if (v2)
      free(v2);
    v3 = *(void **)(a1 + 40);
    if (v3)
      free(v3);
    free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

char *CGPDFSecurityManagerCreateCryptFilter(uint64_t a1, char *__s1)
{
  char *v2;
  _BOOL4 Dictionary;
  char *v5;
  int v6;
  CGPDFInteger v7;
  char *v8;
  CGPDFDictionaryRef value;
  CGPDFInteger v11;
  char *v12;
  char *__s1a;

  v2 = __s1;
  if (!__s1)
    return v2;
  if (!strcmp(__s1, "Identity"))
  {
    v2 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v2)
    {
      *(_QWORD *)v2 = a1;
      v2[12] = 1;
      *((_DWORD *)v2 + 2) = 0;
      *((_QWORD *)v2 + 2) = 0;
    }
    return v2;
  }
  value = 0;
  Dictionary = CGPDFDictionaryGetDictionary(*(CGPDFDictionaryRef *)(a1 + 24), v2, &value);
  v2 = 0;
  if (!Dictionary)
    return v2;
  v2 = (char *)value;
  if (!value)
    return v2;
  v12 = 0;
  __s1a = 0;
  v11 = 0;
  if (CGPDFDictionaryGetName(value, "CFM", (const char **)&__s1a))
  {
    v5 = __s1a;
  }
  else
  {
    v5 = "None";
    __s1a = "None";
  }
  if (!strcmp(v5, "V2"))
  {
    v6 = 1;
  }
  else if (!strcmp(v5, "AESV2"))
  {
    v6 = 2;
  }
  else
  {
    if (strcmp(v5, "AESV3"))
    {
      return 0;
    }
    v6 = 3;
  }
  if (CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v2, "Length", &v11))
  {
    v7 = v11;
    if ((unint64_t)(v11 - 5) > 0x1B)
      goto LABEL_22;
    v7 = 8 * v11;
  }
  else
  {
    v7 = 128;
  }
  v11 = v7;
LABEL_22:
  if ((unint64_t)(v7 - 40) > 0xD8 || (v7 & 7) != 0)
  {
    return 0;
  }
  if (CGPDFDictionaryGetName((CGPDFDictionaryRef)v2, "AuthEvent", (const char **)&v12))
  {
    v8 = v12;
  }
  else
  {
    v8 = "DocOpen";
    v12 = "DocOpen";
  }
  if (strcmp(v8, "DocOpen"))
  {
    return 0;
  }
  v2 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2)
  {
    *(_QWORD *)v2 = a1;
    *((_DWORD *)v2 + 2) = v6;
    v2[12] = 0;
    *((_QWORD *)v2 + 2) = v11 / 8;
  }
  return v2;
}

BOOL CGPDFSecurityManagerUnlock(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v3;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  __int16 v13;
  BOOL v14;
  int v15;
  int v16;
  __int16 v17;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3 || !a2 && a3)
    return 0;
  pthread_mutex_lock(&lock);
  if (CGPDFSecurityHandlerAuthenticateUserPassword(v3, a2, a3))
  {
    *(_WORD *)(v3 + 184) = 1;
    if ((*(_DWORD *)v3 - 3) >= 4)
    {
      if (*(_DWORD *)v3 != 2)
      {
        LOWORD(v15) = 0;
LABEL_32:
        v15 = (unsigned __int16)v15;
        goto LABEL_33;
      }
      v16 = *(_DWORD *)(v3 + 16);
      if ((v16 & 0x10) != 0)
        v12 = (v16 << 29 >> 31) & 7 | 0x38;
      else
        v12 = (v16 << 29 >> 31) & 7;
      if ((v16 & 8) != 0)
      {
        LOWORD(v12) = v12 | 0xC40;
        v17 = 960;
      }
      else
      {
        v17 = 832;
      }
      v13 = v12 | v17;
      v14 = (*(_DWORD *)(v3 + 16) & 0x20) == 0;
    }
    else
    {
      v7 = *(_DWORD *)(v3 + 16);
      if ((v7 & 0x800) != 0)
        v8 = 7;
      else
        v8 = 3;
      v9 = v8 & ((int)(v7 << 29) >> 31);
      if ((v7 & 0x10) != 0)
        v9 |= 0x28u;
      v10 = v9 | (v7 >> 5) & 0x10;
      if ((v7 & 8) != 0)
      {
        v10 |= 0x840u;
        v11 = 960;
      }
      else
      {
        v11 = 832;
      }
      v12 = v10 | v11 & ((int)(v7 << 26) >> 31);
      if ((v7 & 0x100) != 0)
        LOWORD(v12) = v12 | 0x240;
      v13 = v12 | 0x440;
      v14 = (*(_DWORD *)(v3 + 16) & 0x408) == 0;
    }
    if (v14)
      LOWORD(v15) = v12;
    else
      LOWORD(v15) = v13;
    goto LABEL_32;
  }
  if (CGPDFSecurityHandlerAuthenticateOwnerPassword(v3, a2, a3))
  {
    *(_WORD *)(v3 + 184) = 257;
    v15 = 4095;
LABEL_33:
    *(_DWORD *)(v3 + 188) = v15;
    goto LABEL_34;
  }
  *(_WORD *)(v3 + 184) = 0;
  *(_DWORD *)(v3 + 188) = 0;
LABEL_34:
  pthread_mutex_unlock(&lock);
  return *(_BYTE *)(v3 + 184) != 0;
}

BOOL CGPDFSecurityManagerGetDecryptionKey(uint64_t a1, void *a2, _QWORD *a3)
{
  uint64_t v3;
  _BOOL8 v6;

  if (!a1)
    return 0;
  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
    return 0;
  pthread_mutex_lock(&lock);
  v6 = *(_BYTE *)(v3 + 184) != 0;
  if (*(_BYTE *)(v3 + 184))
  {
    if (a2)
      memcpy(a2, (const void *)(v3 + 192), *(_QWORD *)(v3 + 8));
    *a3 = *(_QWORD *)(v3 + 8);
  }
  pthread_mutex_unlock(&lock);
  return v6;
}

_QWORD *CGPDFSecurityManagerCreateDecryptor(uint64_t a1, uint64_t a2, char *__s1, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v7;
  unint64_t v8;
  char *CryptFilter;
  char *v10;
  _QWORD *Decryptor;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 && *(_BYTE *)(v4 + 184))
  {
    if (a2)
    {
      v7 = *(_QWORD *)(a2 + 24);
      v8 = *(_QWORD *)(a2 + 32);
      if (__s1)
      {
LABEL_5:
        CryptFilter = CGPDFSecurityManagerCreateCryptFilter(a1, __s1);
        if (CryptFilter)
        {
          v10 = CryptFilter;
          Decryptor = CGPDFCryptFilterCreateDecryptor(CryptFilter, v7, v8, a4);
          free(v10);
          return Decryptor;
        }
        return 0;
      }
    }
    else
    {
      LODWORD(v7) = 0;
      v8 = 0;
      if (__s1)
        goto LABEL_5;
    }
    return CGPDFCryptFilterCreateDecryptor(*(_QWORD **)(a1 + 32), v7, v8, a4);
  }
  return 0;
}

char *cg_function_type2_create(CGPDFDictionary *a1)
{
  char *result;
  _QWORD *v3;
  const CGFloat *v4;
  CGPDFReal *v5;
  _QWORD *v6;
  CGPDFReal *v7;
  _QWORD *v8;
  CGPDFReal *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;

  result = (char *)malloc_type_calloc(1uLL, 0x40uLL, 0x108004052750FCFuLL);
  if (result)
  {
    v3 = result;
    v4 = (const CGFloat *)(result + 8);
    if (!CGPDFDictionaryGetNumbers(a1, "Domain", (uint64_t)(result + 8), (CGPDFArray *)2))
    {
      goto LABEL_21;
    }
    v11 = 0;
    v12 = 0;
    *v3 = 1;
    v5 = pdf_dictionary_copy_numbers(a1, "C0", &v12);
    v3[5] = v5;
    if (!v5)
    {
      v12 = 1;
      v6 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
      v3[5] = v6;
      if (!v6)
        goto LABEL_21;
      *v6 = 0;
    }
    if (v12)
    {
      v3[3] = v12;
      v7 = pdf_dictionary_copy_numbers(a1, "C1", &v12);
      v3[6] = v7;
      if (v7)
        goto LABEL_10;
      v12 = 1;
      v8 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
      v3[6] = v8;
      if (v8)
      {
        *v8 = 0x3FF0000000000000;
LABEL_10:
        if (v12 == v3[3])
        {
          if (CGPDFDictionaryGetNumber(a1, "N", (CGPDFReal *)&v11))
          {
            v3[7] = v11;
            v9 = pdf_dictionary_copy_numbers(a1, "Range", &v12);
            v3[4] = v9;
            v10 = v3[3];
            if (v9 && v12 != 2 * v10)
            {
            }
            else
            {
              result = (char *)CGFunctionCreate(v3, *v3, v4, v10, v9, &type2_callbacks);
              if (result)
                return result;
              pdf_error("unable to create Type 2 function.", v11);
            }
          }
          else
          {
          }
        }
        else
        {
        }
      }
    }
    else
    {
    }
LABEL_21:
    type2_release((void **)v3);
    return 0;
  }
  return result;
}

void type2_release(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1[5]);
    free(a1[6]);
    free(a1);
  }
}

void type2_evaluate(uint64_t a1, long double *a2, double *a3)
{
  long double v5;
  double v6;
  double v7;
  uint64_t v8;
  double *v9;
  double *v10;
  double v11;
  double v12;
  double v13;

  if (a1)
  {
    v5 = *(double *)(a1 + 56);
    v6 = *a2;
    v7 = pow(*a2, v5);
    if (v5 == 1.0)
      v7 = v6;
    v8 = *(_QWORD *)(a1 + 24);
    if (v8)
    {
      v9 = *(double **)(a1 + 40);
      v10 = *(double **)(a1 + 48);
      do
      {
        v11 = *v9++;
        v12 = v11;
        v13 = *v10++;
        *a3++ = v12 + v7 * (v13 - v12);
        --v8;
      }
      while (v8);
    }
  }
}

uint64_t CGFontDefaultAllowsFontSmoothing()
{
  if (once != -1)
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  return allows_font_smoothing;
}

uint64_t CGFontDefaultGetAntialiasingStyle()
{
  if (once != -1)
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  return default_antialiasing_style;
}

uint64_t CGFontDefaultGetSmoothingStyle()
{
  if (once != -1)
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  return default_smoothing_style;
}

double CGFontDefaultGetSmoothingContrast()
{
  if (once != -1)
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  return 2.0;
}

double CGFontGetDilationParameters(double a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int16 v10;
  double v12;
  double v13;
  double v14;

  v10 = a4;
  if (CGFontGetDilationParameters_once != -1)
    dispatch_once_f(&CGFontGetDilationParameters_once, 0, (dispatch_function_t)get_glyph_debugging_defaults);
  if ((v10 & 2) == 0)
  {
    v12 = 0.00798599981;
    switch(((v10 & 0xD80u) - 128) >> 7)
    {
      case 0u:
        goto LABEL_13;
      case 1u:
        v12 = 0.0100429999;
        goto LABEL_13;
      case 2u:
        goto LABEL_9;
      case 7u:
      case 8u:
        goto LABEL_8;
      default:
        goto LABEL_19;
    }
  }
  v12 = 0.0;
  switch(((v10 & 0x70u) - 16) >> 4)
  {
    case 0u:
      break;
    case 1u:
      v12 = 0.00798599981;
      break;
    case 2u:
LABEL_9:
      v12 = 0.0120999999;
      break;
    case 3u:
      v12 = 0.0169399995;
      break;
    case 4u:
      v12 = 0.00124999997;
      break;
    case 5u:
      v12 = 0.104999997;
      break;
    case 6u:
LABEL_8:
      v12 = a1 * 0.300000012;
      break;
    default:
LABEL_19:
      abort();
  }
LABEL_13:
  v13 = v12 * sqrt(fabs(a3[1] * a3[2] + *a3 * a3[3]));
  if (v13 <= 0.300000012)
    v14 = v13;
  else
    v14 = 0.300000012;
  if (default_glyph_debugging)
    CGPostError((uint64_t)"%s Effective dilation parameters are: dilation width = %f dilation height = %f", (uint64_t)a3, a4, a5, a6, a7, a8, a9, (char)"CGFontGetDilationParameters");
  return v14;
}

const void *get_glyph_debugging_defaults()
{
  get_BOOLean_property("CGFontDebugGlyphBitmaps", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&default_glyph_bitmap_debugging);
  return get_BOOLean_property("CGFontDebugGlyphs", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&default_glyph_debugging);
}

uint64_t __cmyk_to_rgb_info_block_invoke()
{
  CGColorSpaceRef v0;
  CGColorSpaceRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CGColorSpaceRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;

  v0 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericCMYK"));
  v1 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceSRGB"));
  cmyk_to_rgb_info_cmyk_to_rgb_standard = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  v6 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceExtendedSRGB"));
  result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v7, 0, v8, v9, v10, (uint64_t)v6);
  cmyk_to_rgb_info_cmyk_to_rgb_extended = result;
  return result;
}

uint64_t __cmyk_to_gray_info_block_invoke()
{
  CGColorSpaceRef v0;
  CGColorSpaceRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v0 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericCMYK"));
  v1 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericGrayGamma2_2"));
  result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  cmyk_to_gray_info_cmyk_to_gray = result;
  return result;
}

uint64_t __rgb_to_cmyk_info_block_invoke()
{
  CGColorSpaceRef v0;
  CGColorSpaceRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v0 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceSRGB"));
  v1 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericCMYK"));
  result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  rgb_to_cmyk_info_rgb_to_cmyk = result;
  return result;
}

uint64_t __rgb_to_gray_info_block_invoke()
{
  CGColorSpaceRef v0;
  CGColorSpaceRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CGColorSpaceRef v6;
  CGColorSpaceRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  v0 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceLinearSRGB"));
  v1 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceLinearGray"));
  rgb_to_gray_info_rgb_to_gray_standard = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  v6 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceExtendedLinearGray"));
  v7 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceExtendedLinearSRGB"));
  result = CGColorConversionInfoCreateFromListInternal(0, 0, v7, v8, 0, v9, v10, v11, (uint64_t)v6);
  rgb_to_gray_info_rgb_to_gray_extended = result;
  return result;
}

uint64_t __gray_to_cmyk_info_block_invoke()
{
  CGColorSpaceRef v0;
  CGColorSpaceRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v0 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericGrayGamma2_2"));
  v1 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericCMYK"));
  result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  gray_to_cmyk_info_gray_to_cmyk = result;
  return result;
}

uint64_t __gray_to_rgb_info_block_invoke()
{
  CGColorSpaceRef v0;
  CGColorSpaceRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CGColorSpaceRef v6;
  CGColorSpaceRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  v0 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceLinearGray"));
  v1 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceLinearSRGB"));
  gray_to_rgb_info_gray_to_rgb_standard = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  v6 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceExtendedLinearGray"));
  v7 = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceExtendedLinearSRGB"));
  result = CGColorConversionInfoCreateFromListInternal(0, 0, v6, v8, 0, v9, v10, v11, (uint64_t)v7);
  gray_to_rgb_info_gray_to_rgb_extended = result;
  return result;
}

uint64_t rle_filter_rewind(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_BYTE *)(a1 + 8) = 0;
  return CGPDFSourceRewind(*(_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t rle_filter_refill(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  result = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  while (result + 128 < a3 && !*(_BYTE *)(a1 + 8))
  {
    v11 = CGPDFSourceGetc(*(_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
    if (v11 == -1)
      goto LABEL_17;
    v12 = v11;
    if (v11 <= 127)
    {
      v13 = (v11 + 1);
      while (1)
      {
        v14 = CGPDFSourceGetc(*(_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
        if (v14 == -1)
          break;
        v16 = *(_QWORD *)(a1 + 16);
        v15 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 16) = v16 + 1;
        *(_BYTE *)(v15 + v16) = v14;
        if (!--v13)
          goto LABEL_16;
      }
LABEL_17:
      pdf_error("RunLengthDecode: encountered unexpected EOF.");
LABEL_18:
      *(_BYTE *)(a1 + 8) = 1;
      return *(_QWORD *)(a1 + 16);
    }
    if (v11 == 128)
      goto LABEL_18;
    v17 = CGPDFSourceGetc(*(_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
    if (v17 == -1)
      goto LABEL_17;
    LODWORD(v18) = 257 - v12;
    if ((257 - v12) <= 1)
      v18 = 1;
    else
      v18 = v18;
    do
    {
      v20 = *(_QWORD *)(a1 + 16);
      v19 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 16) = v20 + 1;
      *(_BYTE *)(v19 + v20) = v17;
      --v18;
    }
    while (v18);
LABEL_16:
    result = *(_QWORD *)(a1 + 16);
  }
  return result;
}

void rle_filter_finalize(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

_QWORD *PDFImageSetCreate(uint64_t a1)
{
  _QWORD *v2;

  v2 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *v2 = a1;
  v2[1] = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &image_key_callbacks, &image_callbacks);
  v2[2] = 0;
  *((_DWORD *)v2 + 8) = 0;
  return v2;
}

unsigned int *image_retain(uint64_t a1, unsigned int *a2)
{
  unsigned int *result;
  unsigned int v3;

  result = a2;
  if (a2)
  {
    do
      v3 = __ldxr(a2);
    while (__stxr(v3 + 1, a2));
  }
  return result;
}

void image_release(uint64_t a1, uint64_t a2)
{
  PDFImageRelease(a2);
}

_DWORD *image_key_retain(uint64_t a1, uint64_t a2)
{
  _DWORD *v3;
  _DWORD *v4;
  const void *v5;

  v3 = malloc_type_malloc(0x18uLL, 0x10200406E52F545uLL);
  v4 = v3;
  if (v3)
  {
    *(_QWORD *)v3 = *(_QWORD *)a2;
    v3[2] = *(_DWORD *)(a2 + 8);
    v5 = *(const void **)(a2 + 16);
    if (v5)
      CFRetain(v5);
    *((_QWORD *)v4 + 2) = v5;
  }
  return v4;
}

void image_key_release(int a1, _QWORD *a2)
{
  const void *v3;

  v3 = (const void *)a2[2];
  if (v3)
    CFRelease(v3);
  free(a2);
}

BOOL image_key_equal(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  if (*(_QWORD *)a1 != *(_QWORD *)a2)
    return 0;
  result = CGColorEqualToColor(*(CGColorRef *)(a1 + 16), *(CGColorRef *)(a2 + 16));
  if (result)
    return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t image_key_hash(uint64_t a1)
{
  return *(_QWORD *)a1 ^ ((uint64_t)*(int *)(a1 + 8) << 24);
}

void PDFImageSetRelease(uint64_t a1)
{
  const void *v2;

  if (a1)
  {
    CFRelease(*(CFTypeRef *)(a1 + 8));
    CGOrderedSetRelease(*(const void ***)(a1 + 16));
    v2 = *(const void **)(a1 + 24);
    if (v2)
      CFRelease(v2);
    free((void *)a1);
  }
}

const void *add_image(uint64_t a1, uint64_t a2, const void *a3, int a4, unsigned int a5)
{
  const void *Value;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  const void *v14;
  int v15;
  char v16;
  const __CFDictionary *v17;
  const void *v18;
  const void *v19;
  const void **v20;
  _QWORD key[3];

  Value = 0;
  if (a1 && a2)
  {
    if (add_image_predicate != -1)
      dispatch_once(&add_image_predicate, &__block_literal_global_9838);
    key[0] = add_image_f(a2);
    key[1] = a5;
    key[2] = a3;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), key);
    if (!Value)
    {
      if (a4)
      {
        v11 = *(_QWORD *)a1;
        v12 = *(_DWORD *)(a1 + 32) + 1;
        *(_DWORD *)(a1 + 32) = v12;
        v13 = (_QWORD *)a2;
        v14 = a3;
        v15 = a5;
        v16 = 1;
      }
      else
      {
        v17 = *(const __CFDictionary **)(a1 + 24);
        if (v17)
        {
          v18 = CFDictionaryGetValue(v17, (const void *)*(unsigned int *)(a2 + 24));
          if (v18)
          {
            v19 = v18;
            v11 = *(_QWORD *)a1;
            v12 = *(_DWORD *)(a1 + 32) + 1;
            *(_DWORD *)(a1 + 32) = v12;
            v13 = 0;
            v14 = 0;
            v15 = 0;
            v16 = 0;
LABEL_13:
            Value = create_image(v11, v13, v14, v15, v16, v19, v12);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), key, Value);
            v20 = *(const void ***)(a1 + 16);
            if (!v20)
            {
              v20 = CGOrderedSetCreate();
              *(_QWORD *)(a1 + 16) = v20;
            }
            CGOrderedSetAddValue((CFSetRef *)v20, Value);
            PDFImageRelease((uint64_t)Value);
            return Value;
          }
        }
        v11 = *(_QWORD *)a1;
        v12 = *(_DWORD *)(a1 + 32) + 1;
        *(_DWORD *)(a1 + 32) = v12;
        v13 = (_QWORD *)a2;
        v14 = 0;
        v15 = a5;
        v16 = 0;
      }
      v19 = 0;
      goto LABEL_13;
    }
  }
  return Value;
}

void *__add_image_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (CGLibraryLoadImageIODYLD_once != -1)
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_4_19707);
  if (!CGLibraryLoadImageIODYLD_handle)
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageGetHash");
  result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageGetHash");
  if (!result)
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageGetHash");
  add_image_f = result;
  return result;
}

uint64_t PDFImageSetEmitDefinitions(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  const __CFArray *v3;
  CFRange v4;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 16);
    if (v2)
    {
      do
      {
        *(_QWORD *)(v1 + 16) = 0;
        v3 = *(const __CFArray **)(v2 + 8);
        v4.length = CFArrayGetCount(v3);
        v4.location = 0;
        CFArrayApplyFunction(v3, v4, (CFArrayApplierFunction)emit_image_definition, 0);
        CGOrderedSetRelease((const void **)v2);
        v2 = *(_QWORD *)(v1 + 16);
      }
      while (v2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void emit_image_definition(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *EPSRep;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CGDataProvider *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t Bytes;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t NumberOfComponents;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unsigned int PixelComponentType;
  uint64_t v162;
  _QWORD *Mask;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  int v169;
  int v170;
  _BOOL4 v171;
  const CGFloat *Components;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  int v196;
  int v197;
  vImagePixelCount v198;
  CGDataProvider *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  unint64_t v207;
  unint64_t v208;
  CGColorRenderingIntent RenderingIntent;
  uint64_t v210;
  CGDataProvider *v211;
  uint64_t (*v212)(_QWORD);
  uint64_t v213;
  unsigned int v214;
  int v215;
  CGColorSpace *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  int v231;
  int v232;
  vImagePixelCount v233;
  CGDataProvider *v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  unint64_t v242;
  CGColorRenderingIntent v243;
  CGDataProvider *v244;
  CGColorRenderingIntent v245;
  CGDataProvider *v246;
  uint64_t (*v247)(_QWORD);
  int v248;
  int v249;
  _QWORD *v250;
  uint64_t *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  int v259;
  vImagePixelCount v260;
  CGDataProvider *v261;
  vImagePixelCount v262;
  unint64_t v263;
  char *v264;
  CGColorSpaceRef ColorSpace;
  unint64_t v266;
  char *image_stream;
  unint64_t v268;
  uint64_t (*v269)(_QWORD);
  uint64_t v270;
  CGColorSpaceRef v271;
  uint64_t *Matte;
  CGDataProvider *v273;
  CGColorRenderingIntent v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unint64_t v282;
  uint64_t (*v283)(_QWORD);
  uint64_t v284;
  uint64_t (*v285)(_QWORD);
  uint64_t v286;
  CGColorSpaceRef v287;
  unint64_t v288;
  const __CFAllocator *v289;
  CFMutableDataRef Mutable;
  CFMutableDataRef v291;
  CFMutableDataRef v292;
  __CFData *v293;
  unint64_t v294;
  char *v295;
  unint64_t v296;
  BOOL v297;
  unint64_t v298;
  uint64_t v299;
  _BOOL4 v300;
  char **v301;
  uint64_t ChunksAtPosition;
  unint64_t v303;
  unint64_t v304;
  unint64_t v305;
  uint64_t *v306;
  unint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  vImageConverter *v318;
  uint64_t v319;
  uint64_t v320;
  unint64_t v321;
  unsigned __int8 *v322;
  _BYTE *v323;
  char v324;
  unint64_t v325;
  unsigned int v326;
  unint64_t v327;
  unint64_t v328;
  unint64_t v329;
  unint64_t v330;
  _BYTE *v331;
  unsigned __int8 *v332;
  uint64_t i;
  unsigned int v334;
  int v335;
  BOOL v336;
  unint64_t v337;
  unsigned int v338;
  unsigned int v339;
  int v340;
  int v341;
  unint64_t v342;
  unint64_t v343;
  unsigned int v344;
  unint64_t v345;
  uint64_t v346;
  int v347;
  uint64_t v348;
  unsigned int v349;
  uint64_t v350;
  int v351;
  uint64_t v352;
  CGDataProvider *v353;
  CGColorSpace *CopyWithStandardRange;
  char *v355;
  size_t v356;
  size_t v357;
  size_t v358;
  size_t v359;
  int CGImageBitmapInfo;
  CGImageRef v361;
  CGDataProvider *v362;
  CGColorSpace *DeviceGray;
  size_t v364;
  size_t v365;
  size_t v366;
  int v367;
  CGImageRef v368;
  uint64_t *v369;
  uint64_t *v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  const void *v377;
  const void *v378;
  char v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  char v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  CGFloat *decode;
  CGFloat *decodec;
  CGFloat *decoded;
  CGFloat *decodee;
  CGFloat *decodef;
  CGFloat *decodeg;
  CGFloat *decodeh;
  CGFloat *decodea;
  CGFloat *decodei;
  CGFloat *decodej;
  CGFloat *decodek;
  CGFloat *decodel;
  CGFloat *decodem;
  CGFloat *decodeb;
  uint64_t v401;
  CGImage *image;
  unint64_t v403;
  CGColorRenderingIntent intent;
  uint64_t v405;
  BOOL v406[8];
  BOOL shouldInterpolate;
  CFIndex length;
  CFIndex lengtha;
  _OWORD __dst[22];
  _BYTE __src[344];
  _DWORD v412[78];

  v8 = a1;
  v9 = *(_QWORD *)(a1 + 48);
  if (!v9)
    goto LABEL_19;
  EPSRep = CGImageGetEPSRep(*(_QWORD **)(a1 + 48));
  if (EPSRep)
  {
    v11 = EPSRep;
    v12 = *(_QWORD *)(v8 + 8);
    v13 = PDFXRefTableAddObject(*(_QWORD **)(v12 + 464));
    v14 = PDFStreamCreateWithObjectNumber(v12, v13);
    v21 = v14;
    if (v14)
    {
      v22 = v14[1];
      v23 = v22;
    }
    else
    {
      v23 = 0;
      v22 = MEMORY[8];
    }
    *(_QWORD *)(v8 + 56) = v23;
    PDFDocumentBeginObject(*v14, v22, v15, v16, v17, v18, v19, v20);
    PDFDocumentPrintf(*v21, (uint64_t)"<<", v24, v25, v26, v27, v28, v29, (uint64_t)decode);
    PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Type /AAPL:EPSData", v30, v31, v32, v33, v34, v35, (uint64_t)decodec);
    PDFStreamBeginData((CGDataConsumerRef)v21);
    v36 = (CGDataProvider *)v11[1];
    v37 = (char *)malloc_type_malloc(0x5000uLL, 0x7E6E6EDBuLL);
    v43 = CGAccessSessionCreate(v36);
    while (1)
    {
      Bytes = CGAccessSessionGetBytes(v43, v37, 0x5000uLL, v38, v39, v40, v41, v42);
      if (!Bytes)
        break;
      CGDataConsumerPutBytes(v21[3], (uint64_t)v37, Bytes);
    }
    CGAccessSessionRelease(v43);
    free(v37);
    PDFStreamEndData(v21);
    PDFStreamEnd((CFDataRef *)v21);
    PDFStreamRelease((uint64_t)v21);
    v9 = v11[2];
    if (!v9)
      goto LABEL_19;
  }
  v45 = *(_DWORD *)(v9 + 36);
  if ((v45 & 0x2000000) != 0)
  {
    if (*(_QWORD *)(v9 + 56) < 2uLL)
    {
      v105 = *(_QWORD *)(v8 + 16);
      PDFDocumentBeginObject(*(_QWORD *)v105, *(_QWORD *)(v105 + 8), a3, a4, a5, a6, a7, a8);
      PDFDocumentPrintf(*(_QWORD *)v105, (uint64_t)"<<", v106, v107, v108, v109, v110, v111, (uint64_t)decode);
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Type /XObject", v112, v113, v114, v115, v116, v117, (uint64_t)decodei);
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Subtype /Image", v118, v119, v120, v121, v122, v123, (uint64_t)decodej);
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Width %z", v124, v125, v126, v127, v128, v129, *(_QWORD *)(v9 + 40));
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Height %z", v130, v131, v132, v133, v134, v135, *(_QWORD *)(v9 + 48));
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/ImageMask true", v136, v137, v138, v139, v140, v141, (uint64_t)decodek);
      emit_interpolation(v8, v142, v143, v144, v145, v146, v147, v148, (uint64_t)decodel);
      v149 = (uint64_t *)CGImageGetDecode((CGImageRef)v9);
      emit_decode(v8, v149, 2, v150, v151, v152, v153, v154, (uint64_t)decodem);
      if (*(_QWORD *)(v8 + 104) != -1)
        PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/StructParent %d", v155, v156, v157, v158, v159, v160, *(_QWORD *)(v8 + 104));
      if (*(_BYTE *)(v8 + 73))
        goto LABEL_47;
      if (*(_BYTE *)(v8 + 74))
      {
LABEL_89:
        emit_jpeg2000_data(v8, v9, v155, v156, v157, v158, v159, v160);
        goto LABEL_90;
      }
LABEL_46:
      PDFImageEmitData(v8, (CGImage *)v9);
LABEL_90:
      PDFStreamEnd(*(CFDataRef **)(v8 + 16));
      goto LABEL_202;
    }
    pdf_error("unsupported image mask: bits/component > 1.");
LABEL_19:
    emit_empty_image(v8, a2, a3, a4, a5, a6, a7, a8);
    goto LABEL_202;
  }
  if (*(_BYTE *)(v8 + 72))
  {
    v46 = *(_QWORD *)(v8 + 16);
    PDFDocumentBeginObject(*(_QWORD *)v46, *(_QWORD *)(v46 + 8), a3, a4, a5, a6, a7, a8);
    PDFDocumentPrintf(*(_QWORD *)v46, (uint64_t)"<<", v47, v48, v49, v50, v51, v52, (uint64_t)decode);
    PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Type /XObject", v53, v54, v55, v56, v57, v58, (uint64_t)decoded);
    PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Subtype /Image", v59, v60, v61, v62, v63, v64, (uint64_t)decodee);
    PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Width %z", v65, v66, v67, v68, v69, v70, *(_QWORD *)(v9 + 40));
    PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Height %z", v71, v72, v73, v74, v75, v76, *(_QWORD *)(v9 + 48));
    PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/ColorSpace /DeviceGray", v77, v78, v79, v80, v81, v82, (uint64_t)decodef);
    emit_interpolation(v8, v83, v84, v85, v86, v87, v88, v89, (uint64_t)decodeg);
    v90 = (uint64_t *)CGImageGetDecode((CGImageRef)v9);
    emit_decode(v8, v90, 2, v91, v92, v93, v94, v95, (uint64_t)decodeh);
    if (*(_QWORD *)(v8 + 104) != -1)
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/StructParent %d", v97, v98, v99, v100, v101, v102, *(_QWORD *)(v8 + 104));
    v103 = *(_QWORD *)(v8 + 64);
    if (v103)
    {
      if (v103 < 0)
      {
        NumberOfComponents = CGTaggedColorGetNumberOfComponents(v103, v96, v97, v98, v99, v100, v101, v102);
        v103 = *(_QWORD *)(v8 + 64);
      }
      else
      {
        NumberOfComponents = *(_QWORD *)(v103 + 56);
      }
      Components = CGColorGetComponents((CGColorRef)v103);
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/Matte [", v173, v174, v175, v176, v177, v178, (uint64_t)decodea);
      v185 = NumberOfComponents - 1;
      if (NumberOfComponents != 1)
      {
        do
        {
          v186 = *(_QWORD *)Components++;
          PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"%f", v179, v180, v181, v182, v183, v184, v186);
          --v185;
        }
        while (v185);
      }
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"]", v179, v180, v181, v182, v183, v184, (uint64_t)decodeb);
    }
    if (*(_BYTE *)(v8 + 73))
    {
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/BitsPerComponent %z", v97, v98, v99, v100, v101, v102, *(_QWORD *)(v9 + 56));
LABEL_47:
      emit_jpeg_data(v8);
      goto LABEL_90;
    }
    if (*(_BYTE *)(v8 + 74))
    {
      PDFDocumentPrintf(*(_QWORD *)(v8 + 8), (uint64_t)"/BitsPerComponent %z", v97, v98, v99, v100, v101, v102, *(_QWORD *)(v9 + 56));
      goto LABEL_89;
    }
    goto LABEL_46;
  }
  if (*(_BYTE *)(v8 + 74) || (v45 & 0x4000000) == 0)
  {
    v187 = v8;
    v188 = (uint64_t *)v9;
LABEL_201:
    emit_image(v187, v188, a3, a4, a5, a6, a7, a8);
    goto LABEL_202;
  }
  PixelComponentType = CGImageGetPixelComponentType(v9);
  if (PixelComponentType == 3 || !PixelComponentType)
    PixelComponentType = CGImageGetUpscaledComponentType((CGImage *)v9);
  if ((unint64_t)PixelComponentType - 6 >= 0xFFFFFFFFFFFFFFFCLL)
    v162 = 2;
  else
    v162 = PixelComponentType;
  image = (CGImage *)v9;
  if (!*(_QWORD *)(v9 + 176))
  {
    memset(__src, 0, 304);
    CGBitmapPixelInfoInitializeWithImage(__src, __src, (CGColorSpace *)v9);
    if ((unint64_t)(v162 - 6) >= 0xFFFFFFFFFFFFFFFDLL)
      _CGHandleAssert("stream_create_from_image_without_softmask", 284, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "preblended ? CGPixelComponentLessThanOrEqual(pixel_component_type, kCGPixelComponent8BitInteger) : CGPixelComponentLessThanOrEqual(pixel_component_type, kCGPixelComponent16BitInteger)", "preblended %d", v193, v194, v195, 0);
    *(_DWORD *)__src = v162;
    *(_QWORD *)&__src[8] = CGPixelComponentGetBitsPerComponent(v162, v189, v190, v191, v192, v193, v194, v195);
    if ((_DWORD)v162 == 2)
      v196 = 12288;
    else
      v196 = 0;
    if ((*(_DWORD *)(v9 + 36) & 0xC000000) != 0)
      v197 = 3;
    else
      v197 = 0;
    *(_DWORD *)&__src[28] = v196;
    *(_DWORD *)&__src[24] = v197;
    v198 = *(_QWORD *)(v9 + 40);
    v199 = *(CGDataProvider **)(v9 + 48);
    memcpy(__dst, __src, 0x130uLL);
    v207 = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v200, v201, v202, v203, v204, v205, v206) * v198 + 7) >> 3;
    v208 = (*(_QWORD *)&__src[8] * v198 + 7) >> 3;
    RenderingIntent = CGImageGetRenderingIntent((CGImageRef)v9);
    memcpy(__dst, __src, 0x130uLL);
    v210 = CGDataProviderCreateForDestinationWithImage(0, __dst, v198, v199, (_QWORD *)v9, RenderingIntent, 0);
    v211 = (CGDataProvider *)v210;
    if (v210 && (v212 = *(uint64_t (**)(_QWORD))(v210 + 168)) != 0)
      v213 = v212(*(_QWORD *)(v210 + 24));
    else
      v213 = 0;
    ColorSpace = CGImageGetColorSpace((CGImageRef)v9);
    if (*(_DWORD *)&__src[24])
      v266 = v208;
    else
      v266 = 0;
    memcpy(__dst, __src, 0x130uLL);
    image_stream = create_image_stream(ColorSpace, (uint64_t)__dst, 0, v198, (uint64_t)v199, v207, v266, v207, v266, v213, 0, v211, 0, 0);
    goto LABEL_115;
  }
  Mask = CGImageGetMask((_QWORD *)v9);
  if (!Mask)
    _CGHandleAssert("stream_create_from_image_with_softmask", 449, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "mask != NULL", "mask missing", v164, v165, v166, (char)decode);
  v167 = (uint64_t)Mask;
  v168 = CGImageGetPixelComponentType(v9);
  v169 = CGImageGetPixelComponentType(v9);
  v170 = CGImageGetPixelComponentType(v167);
  v171 = *(_QWORD *)(v9 + 40) != *(_QWORD *)(v167 + 40) || *(_QWORD *)(v9 + 48) != *(_QWORD *)(v167 + 48);
  v214 = *(_DWORD *)(v9 + 36);
  if ((v214 & 0x4000000) == 0)
  {
    v215 = (v214 >> 27) & 1;
    if (v168 != (_DWORD)v162)
      v215 = 1;
    if (((v215 | v171) & 1) == 0 && v169 == v170)
    {
      v216 = (CGColorSpace *)CGImageGetMask((_QWORD *)v9);
      memset(__src, 0, 304);
      CGBitmapPixelInfoInitializeWithImage(__src, __src, (CGColorSpace *)v9);
      memset(__dst, 0, 304);
      CGBitmapPixelInfoInitializeWithImage(__dst, __dst, v216);
      if ((unint64_t)CGImageGetPixelComponentType(v9) - 6 >= 0xFFFFFFFFFFFFFFFDLL)
      {
        v379 = CGImageGetPixelComponentType(v9);
        _CGHandleAssert("stream_create_from_image_and_softmask_providers", 329, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "CGPixelComponentLessThanOrEqual(CGImageGetPixelComponentType(image), kCGPixelComponent16BitInteger)", "type %d", v380, v381, v382, v379);
      }
      if ((unint64_t)CGImageGetPixelComponentType((uint64_t)v216) - 6 >= 0xFFFFFFFFFFFFFFFDLL)
      {
        v383 = CGImageGetPixelComponentType((uint64_t)v216);
        _CGHandleAssert("stream_create_from_image_and_softmask_providers", 330, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "CGPixelComponentLessThanOrEqual(CGImageGetPixelComponentType(smask), kCGPixelComponent16BitInteger)", "mask %d", v384, v385, v386, v383);
      }
      *(_DWORD *)__src = v162;
      *(_QWORD *)&__src[8] = CGPixelComponentGetBitsPerComponent(v162, v217, v218, v219, v220, v221, v222, v223);
      if (CGImageGetPixelComponentType(v9) == 2)
        v231 = 12288;
      else
        v231 = 0;
      *(_DWORD *)&__src[28] = v231;
      if (*(_DWORD *)&__src[24])
        _CGHandleAssert("stream_create_from_image_and_softmask_providers", 340, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "image_info.alpha_info == kCGImageAlphaNone", "alpha %d", v228, v229, v230, __src[24]);
      LODWORD(__dst[0]) = v162;
      *(_QWORD *)&__src[8] = CGPixelComponentGetBitsPerComponent(v162, v224, v225, v226, v227, v228, v229, v230);
      if (CGImageGetPixelComponentType((uint64_t)v216) == 2)
        v232 = 12288;
      else
        v232 = 0;
      HIDWORD(__dst[1]) = v232;
      v233 = *(_QWORD *)(v9 + 40);
      v234 = *(CGDataProvider **)(v9 + 48);
      memcpy(v412, __src, 0x130uLL);
      length = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v412, v235, v236, v237, v238, v239, v240, v241) * v233 + 7) >> 3;
      v242 = *(_QWORD *)&__src[8] * v233 + 7;
      v243 = CGImageGetRenderingIntent((CGImageRef)v9);
      memcpy(v412, __src, 0x130uLL);
      v244 = (CGDataProvider *)CGDataProviderCreateForDestinationWithImage(0, v412, v233, v234, (_QWORD *)v9, v243, 0);
      v245 = CGImageGetRenderingIntent(v216);
      memcpy(v412, __dst, 0x130uLL);
      v246 = (CGDataProvider *)CGDataProviderCreateForDestinationWithImage(0, v412, v233, v234, v216, v245, 0);
      if (v244 && (v247 = (uint64_t (*)(_QWORD))*((_QWORD *)v244 + 21)) != 0)
        v405 = v247(*((_QWORD *)v244 + 3));
      else
        v405 = 0;
      v268 = v242 >> 3;
      if (v246 && (v269 = (uint64_t (*)(_QWORD))*((_QWORD *)v246 + 21)) != 0)
        v270 = v269(*((_QWORD *)v246 + 3));
      else
        v270 = 0;
      v271 = CGImageGetColorSpace(image);
      Matte = CGImageGetMatte(image);
      memcpy(v412, __src, 0x130uLL);
      v264 = create_image_stream(v271, (uint64_t)v412, 0, v233, (uint64_t)v234, length, v268, length, v268, v405, v270, v244, v246, Matte);
      CGDataProviderRelease(v244);
      v273 = v246;
      goto LABEL_116;
    }
  }
  if ((unint64_t)(v162 - 3) >= 3)
    v248 = v162;
  else
    v248 = 2;
  if ((unint64_t)(v162 - 6) < 0xFFFFFFFFFFFFFFFBLL)
    v249 = 1;
  else
    v249 = v248;
  v250 = CGImageGetMask((_QWORD *)v9);
  v251 = CGImageGetMatte((_QWORD *)v9);
  memset(__src, 0, 304);
  CGBitmapPixelInfoInitializeWithImage(__src, __src, (CGColorSpace *)v9);
  *(_DWORD *)&__src[24] = 3;
  *(_DWORD *)__src = v249;
  *(_QWORD *)&__src[8] = CGPixelComponentGetBitsPerComponent(v249, v252, v253, v254, v255, v256, v257, v258);
  if (v249 == 2)
    v259 = 12288;
  else
    v259 = 0;
  *(_DWORD *)&__src[28] = v259;
  v260 = *(_QWORD *)(v9 + 40);
  v261 = *(CGDataProvider **)(v9 + 48);
  if (!v250)
  {
LABEL_106:
    v274 = CGImageGetRenderingIntent((CGImageRef)v9);
    memcpy(__dst, __src, 0x130uLL);
    v211 = (CGDataProvider *)CGDataProviderCreateWithSoftMaskAndMatte(0, __dst, v260, v261, (CGImage *)v9, v274);
    memcpy(__dst, __src, 0x130uLL);
    v282 = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v275, v276, v277, v278, v279, v280, v281) * v260 + 7) >> 3;
    if (v211)
    {
      v283 = (uint64_t (*)(_QWORD))*((_QWORD *)v211 + 21);
      if (v283)
        v284 = v283(*((_QWORD *)v211 + 3));
      else
        v284 = 0;
      v285 = (uint64_t (*)(_QWORD))*((_QWORD *)v211 + 22);
      if (v285)
      {
        v286 = v285(*((_QWORD *)v211 + 3));
LABEL_114:
        v287 = CGImageGetColorSpace(image);
        memcpy(__dst, __src, 0x130uLL);
        image_stream = create_image_stream(v287, (uint64_t)__dst, 1, v260, (uint64_t)v261, v282, v282, v282, v282, v284, v286, v211, 0, v251);
LABEL_115:
        v264 = image_stream;
        v273 = v211;
LABEL_116:
        CGDataProviderRelease(v273);
        goto LABEL_117;
      }
    }
    else
    {
      v284 = 0;
    }
    v286 = 0;
    goto LABEL_114;
  }
  v262 = v250[5];
  if (v262 - 0x4000000 >= 0xFFFFFFFFFC000001)
  {
    v263 = v250[6];
    if (v263 - 0x4000000 >= 0xFFFFFFFFFC000001)
    {
      if (v262 > v260)
        v260 = v250[5];
      if (v263 > (unint64_t)v261)
        v261 = (CGDataProvider *)v250[6];
      goto LABEL_106;
    }
  }
  v264 = 0;
LABEL_117:
  if (!v264)
    goto LABEL_200;
  v288 = (unint64_t)(*((_QWORD *)v264 + 2) * *((_QWORD *)v264 + 3) * *((_QWORD *)v264 + 39) + 7) >> 3;
  v289 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v288 * *((_QWORD *)v264 + 40));
  if (!Mutable)
    goto LABEL_200;
  v291 = Mutable;
  if (!*((_QWORD *)v264 + 42))
  {
    v401 = v8;
    lengtha = 0;
    v293 = 0;
    goto LABEL_123;
  }
  lengtha = (unint64_t)(*((_QWORD *)v264 + 39) * *((_QWORD *)v264 + 2) + 7) >> 3;
  v292 = CFDataCreateMutable(v289, lengtha * *((_QWORD *)v264 + 40));
  if (!v292)
  {
    CFRelease(v291);
LABEL_200:
    v187 = v8;
    v188 = 0;
    goto LABEL_201;
  }
  v293 = v292;
  v401 = v8;
LABEL_123:
  v294 = 0;
  v295 = v264 + 8;
  while (1)
  {
    v296 = *((_QWORD *)v264 + 40);
    v297 = v296 > v294;
    v298 = v296 - v294;
    if (!v297)
      break;
    if (v298 >= *((_QWORD *)v264 + 43))
      v299 = *((_QWORD *)v264 + 43);
    else
      v299 = v298;
    if (v264[521])
    {
      v300 = *((_QWORD *)v264 + 67) == 0;
      v301 = (char **)(v264 + 384);
      if (*((_QWORD *)v264 + 67))
        v301 = (char **)(v264 + 368);
    }
    else
    {
      v300 = 0;
      v301 = (char **)(v264 + 368);
    }
    ChunksAtPosition = CGAccessSessionGetChunksAtPosition(*((uint64_t **)v264 + 84), *((_QWORD *)v264 + 44) * v294, *((_QWORD *)v264 + 41), *((_QWORD *)v264 + 44) - *((_QWORD *)v264 + 41), v299, *v301, 0, a8);
    v303 = *((_QWORD *)v264 + 41);
    v304 = ChunksAtPosition + v303 - 1;
    if (v303 <= 1)
      v305 = 1;
    else
      v305 = *((_QWORD *)v264 + 41);
    v306 = (uint64_t *)*((_QWORD *)v264 + 85);
    v307 = v304 / v305;
    if (v306)
    {
      v308 = v299;
      v309 = v304;
      v310 = CGAccessSessionGetChunksAtPosition(v306, *((_QWORD *)v264 + 45) * v294, *((_QWORD *)v264 + 42), *((_QWORD *)v264 + 45) - *((_QWORD *)v264 + 42), v308, *((char **)v264 + 47), 0, v304);
      v304 = v309;
      v313 = (unint64_t)(v310 + *((_QWORD *)v264 + 42) - 1) / *((_QWORD *)v264 + 42);
      if (v313 != v307)
        _CGHandleAssert("CGImageStreamRead", 576, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "smask_rows_read == rows_read", "%zu %zu", v311, v312, v309, v313);
    }
    *(_QWORD *)v406 = v294;
    v295 = v264 + 8;
    if (!v300)
      goto LABEL_182;
    v314 = *((_QWORD *)v264 + 48);
    v315 = *((_QWORD *)v264 + 39);
    v403 = v304;
    memcpy(&__src[40], v264 + 696, 0x130uLL);
    v316 = *((_QWORD *)v264 + 41);
    v317 = *((_QWORD *)v264 + 46);
    memcpy((char *)&__dst[2] + 8, v264 + 1000, 0x130uLL);
    v318 = (vImageConverter *)*((_QWORD *)v264 + 86);
    *(_QWORD *)__src = v314;
    *(_QWORD *)&__src[8] = v315;
    *(_QWORD *)&__src[16] = v307;
    *(_QWORD *)&__src[24] = v316;
    *(_QWORD *)&__src[32] = 0;
    *(_QWORD *)&__dst[0] = v317;
    *((_QWORD *)&__dst[0] + 1) = v315;
    v295 = v264 + 8;
    *(_QWORD *)&__dst[1] = v307;
    *((_QWORD *)&__dst[1] + 1) = v316;
    *(_QWORD *)&__dst[2] = 0;
    vImageConverterConvert(v318, (uint64_t)__src, (uint64_t)__dst, 0);
    v304 = v403;
    if (v305 > v403)
      goto LABEL_182;
    v319 = 0;
    v320 = *((_QWORD *)v264 + 89);
    v321 = *((_QWORD *)v264 + 88);
    v323 = (_BYTE *)*((_QWORD *)v264 + 47);
    v322 = (unsigned __int8 *)*((_QWORD *)v264 + 48);
    v324 = v321 - 24;
    do
    {
      v325 = *((_QWORD *)v264 + 39);
      if (!v325)
        goto LABEL_181;
      v326 = 0;
      v327 = 0;
      v328 = 0;
      LODWORD(v329) = 0;
      v330 = 0;
      v331 = v323;
      v332 = v322;
      do
      {
        if (v320)
        {
          for (i = 0; i != v320; ++i)
          {
            if (v321 < 0x19)
            {
              v337 = v321;
            }
            else
            {
              if (v329 > 0x17)
              {
                v335 = v329;
              }
              else
              {
                do
                {
                  v334 = *v332++;
                  v330 = v334 | (v330 << 8);
                  v335 = v329 + 8;
                  v336 = v329 >= 0x10;
                  LODWORD(v329) = v329 + 8;
                }
                while (!v336);
              }
              LODWORD(v329) = v335 - 24;
              v337 = v321 - 24;
            }
            if (v337 > v329)
            {
              do
              {
                v338 = *v332++;
                v330 = v338 | (v330 << 8);
                v329 = (v329 + 8);
              }
              while (v337 > v329);
            }
            LODWORD(v329) = v329 - v337;
          }
        }
        if (v321 <= 0x18)
        {
          v341 = 0;
          v342 = v329;
          v343 = v321;
        }
        else
        {
          if (v329 > 0x17)
          {
            v340 = v329;
          }
          else
          {
            do
            {
              v339 = *v332++;
              v330 = v339 | (v330 << 8);
              v340 = v329 + 8;
              v336 = v329 >= 0x10;
              LODWORD(v329) = v329 + 8;
            }
            while (!v336);
          }
          v342 = (v340 - 24);
          v341 = ((v330 >> (v340 - 24)) & 0xFFFFFF) << v324;
          LODWORD(v329) = v342;
          v343 = v321 - 24;
        }
        if (v343 > v342)
        {
          do
          {
            v344 = *v332++;
            v330 = v344 | (v330 << 8);
            v329 = (v329 + 8);
          }
          while (v343 > v329);
        }
        LODWORD(v329) = v329 - v343;
        v345 = (v330 >> v329) & ~(-1 << v343) | v341;
        if (v321 < 0x19)
        {
          v347 = v321;
          if (v326 < 8)
            goto LABEL_175;
        }
        else
        {
          v346 = v326 - 8;
          if (v326 >= 8)
          {
            do
            {
              *v331++ = v328 >> v346;
              v346 -= 8;
              v326 -= 8;
            }
            while (v326 > 7);
          }
          v326 |= 0x18u;
          v328 = (v345 >> v324) & 0xFFFFFF | (v328 << 24);
          v347 = v321 - 24;
        }
        v348 = v326 - 8;
        do
        {
          v326 -= 8;
          *v331++ = v328 >> v348;
          v348 -= 8;
        }
        while (v326 > 7);
        v325 = *((_QWORD *)v264 + 39);
LABEL_175:
        v328 = (v328 << v347) | v345 & ~(-1 << v347);
        v326 += v347;
        ++v327;
      }
      while (v327 < v325);
      if (v331 && v326)
      {
        do
        {
          v349 = v326;
          v350 = v326 - 8;
          if (v326 >= 8)
          {
            do
            {
              *v331++ = v328 >> v350;
              v350 -= 8;
              v349 -= 8;
            }
            while (v349 > 7);
          }
          v351 = -v326 & 7;
          v328 <<= v351;
          v326 = v349 + v351;
        }
        while (v326);
      }
LABEL_181:
      v322 += *((_QWORD *)v264 + 41);
      v323 += *((_QWORD *)v264 + 42);
      ++v319;
    }
    while (v319 != v307);
LABEL_182:
    if (v305 > v304)
      break;
    v352 = 0;
    do
    {
      CFDataAppendBytes(v291, (const UInt8 *)(*((_QWORD *)v264 + 46) + *((_QWORD *)v264 + 41) * v352), v288);
      if (v293)
        CFDataAppendBytes(v293, (const UInt8 *)(*((_QWORD *)v264 + 47) + *((_QWORD *)v264 + 42) * v352), lengtha);
      ++v352;
    }
    while (v307 != v352);
    v294 = v307 + *(_QWORD *)v406;
  }
  v353 = CGDataProviderCreateWithCFData(v291);
  CFRelease(v291);
  shouldInterpolate = CGImageGetShouldInterpolate(image);
  intent = CGImageGetRenderingIntent(image);
  CopyWithStandardRange = CGColorSpaceCreateCopyWithStandardRange(*(CGColorSpaceRef *)v264);
  v355 = v295;
  v357 = *((_QWORD *)v264 + 39);
  v356 = *((_QWORD *)v264 + 40);
  v358 = *((_QWORD *)v264 + 2);
  v359 = *((_QWORD *)v264 + 3) * v358;
  memcpy(__src, v355, 0x130uLL);
  CGImageBitmapInfo = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__src);
  v361 = CGImageCreate(v357, v356, v358, v359, v288, CopyWithStandardRange, CGImageBitmapInfo & 0xFFFFFFE0, v353, *((const CGFloat **)v264 + 6), shouldInterpolate, intent);
  CGDataProviderRelease(v353);
  CGColorSpaceRelease(CopyWithStandardRange);
  if (v293)
  {
    v362 = CGDataProviderCreateWithCFData(v293);
    CFRelease(v293);
    DeviceGray = CGColorSpaceCreateDeviceGray();
    v364 = *((_QWORD *)v264 + 39);
    v365 = *((_QWORD *)v264 + 40);
    v366 = *((_QWORD *)v264 + 2);
    memcpy(__src, v355, 0x130uLL);
    v367 = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__src);
    v368 = CGImageCreate(v364, v365, v366, v366, lengtha, DeviceGray, v367 & 0xFFFFFFE0, v362, 0, 0, kCGRenderingIntentDefault);
    CGColorSpaceRelease(DeviceGray);
    CGDataProviderRelease(v362);
    if (v264[520])
      v369 = (uint64_t *)(v264 + 392);
    else
      v369 = 0;
    v370 = (uint64_t *)CGImageCreateWithMaskAndMatte((uint64_t)v361, (uint64_t)v368, v369);
    v8 = v401;
    if (v361)
      CFRelease(v361);
    if (v368)
      CFRelease(v368);
  }
  else
  {
    v370 = (uint64_t *)v361;
    v8 = v401;
  }
  CGImageStreamRelease(v264);
  emit_image(v8, v370, v371, v372, v373, v374, v375, v376);
  if (v370)
    CFRelease(v370);
LABEL_202:
  v377 = *(const void **)(v8 + 48);
  if (v377)
    CFRelease(v377);
  *(_QWORD *)(v8 + 48) = 0;
  v378 = *(const void **)(v8 + 80);
  if (v378)
  {
    CFRelease(v378);
    *(_QWORD *)(v8 + 80) = 0;
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(v8 + 88));
  *(_QWORD *)(v8 + 88) = 0;
}

char *CGContextCopyTopGState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return CGGStateCreateCopy(*(_QWORD *)(a1 + 96));
  handle_invalid_context((char)"CGContextCopyTopGState", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextReplaceTopGState(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  char *Copy;
  char **v15;
  CGContextRef v16;

  if (!c)
  {
    v16 = 0;
LABEL_9:
    handle_invalid_context((char)"CGContextReplaceTopGState", (uint64_t)v16, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v16 = c;
    goto LABEL_9;
  }
  if (a2)
  {
    v10 = (uint64_t *)*((_QWORD *)c + 13);
    v11 = (uint64_t *)v10[1];
    if (v11 != v10)
    {
      v13 = *v11;
      v12 = (_QWORD *)v11[1];
      *(_QWORD *)(v13 + 8) = v12;
      *v12 = v13;
      *v11 = (uint64_t)v11;
      v11[1] = (uint64_t)v11;
      CGGStateRelease((uint64_t)v11);
    }
    Copy = CGGStateCreateCopy(a2);
    v15 = (char **)v10[1];
    v10[1] = (uint64_t)Copy;
    *(_QWORD *)Copy = v10;
    *v15 = Copy;
    *((_QWORD *)Copy + 1) = v15;
    *((_QWORD *)c + 12) = v10[1];
  }
  else
  {
    CGContextResetTopGState(c, 0, a3, a4, a5, a6, a7, a8);
  }
}

void CGContextResetTopGState(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGContextRef v9;

  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      *(CGAffineTransform *)(*((_QWORD *)c + 12) + 24) = CGAffineTransformIdentity;
      CGContextResetClip(c);
      CGGStateReset(*((_QWORD *)c + 12));
      return;
    }
    v9 = c;
  }
  else
  {
    v9 = 0;
  }
  handle_invalid_context((char)"CGContextResetTopGState", (uint64_t)v9, a3, a4, a5, a6, a7, a8);
}

void CGContextResetCTM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    *(CGAffineTransform *)(*(_QWORD *)(a1 + 96) + 24) = CGAffineTransformIdentity;
  else
    handle_invalid_context((char)"CGContextResetCTM", a1, a3, a4, a5, a6, a7, a8);
}

double CGContextGetLineWidth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 8);
  handle_invalid_context((char)"CGContextGetLineWidth", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetLineCap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 2);
  handle_invalid_context((char)"CGContextGetLineCap", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetLineJoin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 3);
  handle_invalid_context((char)"CGContextGetLineJoin", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

double CGContextGetMiterLimit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 16);
  handle_invalid_context((char)"CGContextGetMiterLimit", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetLineDashCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 32);
    if (v8)
      return *(_QWORD *)(v8 + 16);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetLineDashCount", a1, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

double CGContextGetLineDashPattern(uint64_t a1, double *a2, double *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double result)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  double *v12;
  double v13;

  if (!a1)
  {
    v10 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextGetLineDashPattern", v10, (uint64_t)a3, a4, a5, a6, a7, a8);
    return result;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v10 = a1;
    goto LABEL_7;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 32);
  if (a2)
  {
    if (v9)
      result = *(double *)(v9 + 8);
    else
      result = 0.0;
    *a2 = result;
  }
  if (v9)
    v11 = *(_QWORD *)(v9 + 16);
  else
    v11 = 0;
  if (v9)
    v12 = (double *)(v9 + 24);
  else
    v12 = 0;
  if (v11 >= a4)
    v11 = a4;
  for (; v11; --v11)
  {
    v13 = *v12++;
    result = v13;
    *a3++ = v13;
  }
  return result;
}

uint64_t CGContextGetRenderingIntent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return ((int)(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 120) + 4) << 12) >> 28);
  handle_invalid_context((char)"CGContextGetRenderingIntent", a1, a3, a4, a5, a6, a7, a8);
  return 2;
}

float CGContextGetEDRTargetHeadroom(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 120) + 48);
  handle_invalid_context((char)"CGContextGetEDRTargetHeadroom", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextSetEDRTargetHeadroom(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;

  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextSetEDRTargetHeadroom", a1, a4, a5, a6, a7, a8, a9);
    return 0;
  }
  if (a2 < 1.0 && a2 != 0.0)
    return 0;
  v10 = *(_QWORD *)(a1 + 96);
  if (*(float *)(*(_QWORD *)(v10 + 120) + 48) != a2)
  {
    maybeCopyRenderingState(*(_QWORD *)(a1 + 96));
    *(float *)(*(_QWORD *)(v10 + 120) + 48) = a2;
  }
  return 1;
}

BOOL CGContextGetStrokeAdjust(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 1) != 0;
  handle_invalid_context((char)"CGContextGetStrokeAdjust", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetStrokeAdjust(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  uint64_t v9;

  v8 = a2;
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    v9 = *(_QWORD *)(a1 + 96);
    if (*(unsigned __int8 *)(*(_QWORD *)(v9 + 128) + 1) != a2)
    {
      maybe_copy_stroke_state(*(_QWORD *)(a1 + 96));
      *(_BYTE *)(*(_QWORD *)(v9 + 128) + 1) = v8;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetStrokeAdjust", a1, a3, a4, a5, a6, a7, a8);
  }
}

unint64_t CGContextGetFillColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    result = CGGStateGetFillColor(*(_QWORD *)(a1 + 96));
    if (result)
    {
      if ((result & 0x8000000000000000) != 0)
        return (unint64_t)CGTaggedColorGetColorSpace(result, v9, v10, v11, v12, v13, v14, v15);
      else
        return *(_QWORD *)(result + 24);
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextGetFillColorSpace", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  return result;
}

unint64_t CGContextGetStrokeColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    result = CGGStateGetStrokeColor(*(_QWORD *)(a1 + 96));
    if (result)
    {
      if ((result & 0x8000000000000000) != 0)
        return (unint64_t)CGTaggedColorGetColorSpace(result, v9, v10, v11, v12, v13, v14, v15);
      else
        return *(_QWORD *)(result + 24);
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextGetStrokeColorSpace", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  return result;
}

void CGContextGetFillColor(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FillColor;
  const CGFloat *Components;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const CGFloat *v18;
  uint64_t NumberOfComponents;
  uint64_t v20;

  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextGetFillColor", a1, a3, a4, a5, a6, a7, a8);
    return;
  }
  FillColor = CGGStateGetFillColor(*(_QWORD *)(a1 + 96));
  Components = CGColorGetComponents((CGColorRef)FillColor);
  if (!FillColor)
    return;
  v18 = Components;
  if (FillColor < 0)
  {
    NumberOfComponents = CGTaggedColorGetNumberOfComponents(FillColor, v11, v12, v13, v14, v15, v16, v17);
    if (!NumberOfComponents)
      return;
  }
  else
  {
    NumberOfComponents = *(_QWORD *)(FillColor + 56);
    if (!NumberOfComponents)
      return;
  }
  do
  {
    v20 = *(_QWORD *)v18++;
    *a2++ = v20;
    --NumberOfComponents;
  }
  while (NumberOfComponents);
}

void CGContextGetStrokeColor(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t StrokeColor;
  const CGFloat *Components;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const CGFloat *v18;
  uint64_t NumberOfComponents;
  uint64_t v20;

  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextGetStrokeColor", a1, a3, a4, a5, a6, a7, a8);
    return;
  }
  StrokeColor = CGGStateGetStrokeColor(*(_QWORD *)(a1 + 96));
  Components = CGColorGetComponents((CGColorRef)StrokeColor);
  if (!StrokeColor)
    return;
  v18 = Components;
  if (StrokeColor < 0)
  {
    NumberOfComponents = CGTaggedColorGetNumberOfComponents(StrokeColor, v11, v12, v13, v14, v15, v16, v17);
    if (!NumberOfComponents)
      return;
  }
  else
  {
    NumberOfComponents = *(_QWORD *)(StrokeColor + 56);
    if (!NumberOfComponents)
      return;
  }
  do
  {
    v20 = *(_QWORD *)v18++;
    *a2++ = v20;
    --NumberOfComponents;
  }
  while (NumberOfComponents);
}

void CGContextSetFillPattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t FillColor;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  CGColorSpace *ColorSpace;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CGColor *v28;
  CGContextRef v29;

  if (!c)
  {
    v29 = 0;
LABEL_14:
    handle_invalid_context((char)"CGContextSetFillPattern", (uint64_t)v29, (uint64_t)components, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v29 = c;
    goto LABEL_14;
  }
  if (!pattern || !components)
  {
    CGPostError((uint64_t)"%s: pattern and components may not be NULL.", (uint64_t)pattern, (uint64_t)components, v3, v4, v5, v6, v7, (char)"CGContextSetFillPattern");
    return;
  }
  FillColor = CGGStateGetFillColor(*((_QWORD *)c + 12));
  if (!FillColor)
    goto LABEL_17;
  v19 = FillColor;
  if ((FillColor & 0x8000000000000000) != 0)
  {
    ColorSpace = CGTaggedColorGetColorSpace(FillColor, v12, v13, v14, v15, v16, v17, v18);
    if (ColorSpace)
      goto LABEL_8;
LABEL_17:
    CGPostError((uint64_t)"%s: no color space specified for fill pattern.", v12, v13, v14, v15, v16, v17, v18, (char)"CGContextSetFillPattern");
    return;
  }
  ColorSpace = *(CGColorSpace **)(FillColor + 24);
  if (!ColorSpace)
    goto LABEL_17;
LABEL_8:
  if (CGColorSpaceGetType(ColorSpace) == 9)
  {
    if ((CGColorEqualToColorComponents(v19, (uint64_t)ColorSpace, (uint64_t)pattern, components, v24, v25, v26, v27) & 1) == 0)
    {
      v28 = CGColorCreateWithPattern(ColorSpace, pattern, components);
      CGContextSetFillColorWithColor(c, v28);
      if (v28)
        CFRelease(v28);
    }
  }
  else
  {
    CGPostError((uint64_t)"%s: pattern specified with non-pattern color space.", v21, v22, v23, v24, v25, v26, v27, (char)"CGContextSetFillPattern");
  }
}

uint64_t CGContextGetFillPattern(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t FillColor;
  const CGFloat *Components;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const CGFloat *v18;
  uint64_t NumberOfComponents;
  uint64_t v21;

  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextGetFillPattern", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  FillColor = CGGStateGetFillColor(*(_QWORD *)(a1 + 96));
  Components = CGColorGetComponents((CGColorRef)FillColor);
  if (!FillColor)
    return 0;
  v18 = Components;
  if (FillColor < 0)
  {
    NumberOfComponents = CGTaggedColorGetNumberOfComponents(FillColor, v11, v12, v13, v14, v15, v16, v17);
    if (!NumberOfComponents)
      goto LABEL_11;
  }
  else
  {
    NumberOfComponents = *(_QWORD *)(FillColor + 56);
    if (!NumberOfComponents)
      goto LABEL_11;
  }
  do
  {
    v21 = *(_QWORD *)v18++;
    *a2++ = v21;
    --NumberOfComponents;
  }
  while (NumberOfComponents);
LABEL_11:
  if (FillColor < 1)
    return 0;
  return *(_QWORD *)(FillColor + 32);
}

void CGContextSetStrokePattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t StrokeColor;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  CGColorSpace *ColorSpace;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CGColor *v28;
  CGContextRef v29;

  if (!c)
  {
    v29 = 0;
LABEL_14:
    handle_invalid_context((char)"CGContextSetStrokePattern", (uint64_t)v29, (uint64_t)components, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v29 = c;
    goto LABEL_14;
  }
  if (!pattern || !components)
  {
    CGPostError((uint64_t)"%s: pattern and components may not be NULL.", (uint64_t)pattern, (uint64_t)components, v3, v4, v5, v6, v7, (char)"CGContextSetStrokePattern");
    return;
  }
  StrokeColor = CGGStateGetStrokeColor(*((_QWORD *)c + 12));
  if (!StrokeColor)
    goto LABEL_17;
  v19 = StrokeColor;
  if ((StrokeColor & 0x8000000000000000) != 0)
  {
    ColorSpace = CGTaggedColorGetColorSpace(StrokeColor, v12, v13, v14, v15, v16, v17, v18);
    if (ColorSpace)
      goto LABEL_8;
LABEL_17:
    CGPostError((uint64_t)"%s: no color space specified for stroke pattern.", v12, v13, v14, v15, v16, v17, v18, (char)"CGContextSetStrokePattern");
    return;
  }
  ColorSpace = *(CGColorSpace **)(StrokeColor + 24);
  if (!ColorSpace)
    goto LABEL_17;
LABEL_8:
  if (CGColorSpaceGetType(ColorSpace) == 9)
  {
    if ((CGColorEqualToColorComponents(v19, (uint64_t)ColorSpace, (uint64_t)pattern, components, v24, v25, v26, v27) & 1) == 0)
    {
      v28 = CGColorCreateWithPattern(ColorSpace, pattern, components);
      CGContextSetStrokeColorWithColor(c, v28);
      if (v28)
        CFRelease(v28);
    }
  }
  else
  {
    CGPostError((uint64_t)"%s: pattern specified with non-pattern color space.", v21, v22, v23, v24, v25, v26, v27, (char)"CGContextSetStrokePattern");
  }
}

uint64_t CGContextGetStrokePattern(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t StrokeColor;
  const CGFloat *Components;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const CGFloat *v18;
  uint64_t NumberOfComponents;
  uint64_t v21;

  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextGetStrokePattern", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  StrokeColor = CGGStateGetStrokeColor(*(_QWORD *)(a1 + 96));
  Components = CGColorGetComponents((CGColorRef)StrokeColor);
  if (!StrokeColor)
    return 0;
  v18 = Components;
  if (StrokeColor < 0)
  {
    NumberOfComponents = CGTaggedColorGetNumberOfComponents(StrokeColor, v11, v12, v13, v14, v15, v16, v17);
    if (!NumberOfComponents)
      goto LABEL_11;
  }
  else
  {
    NumberOfComponents = *(_QWORD *)(StrokeColor + 56);
    if (!NumberOfComponents)
      goto LABEL_11;
  }
  do
  {
    v21 = *(_QWORD *)v18++;
    *a2++ = v21;
    --NumberOfComponents;
  }
  while (NumberOfComponents);
LABEL_11:
  if (StrokeColor < 1)
    return 0;
  return *(_QWORD *)(StrokeColor + 32);
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CGColorSpace *DeviceGray;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CGContextRef v16;
  char v17;
  CGFloat v18[3];

  v18[2] = *(CGFloat *)MEMORY[0x1E0C80C00];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v18[0] = gray;
      v18[1] = alpha;
      DeviceGray = CGColorSpaceCreateDeviceGray();
      set_fill_color_with_components((uint64_t *)c, DeviceGray, v18, v11, v12, v13, v14, v15, v17);
      CGColorSpaceRelease(DeviceGray);
      return;
    }
    v16 = c;
  }
  else
  {
    v16 = 0;
  }
  handle_invalid_context((char)"CGContextSetGrayFillColor", (uint64_t)v16, v3, v4, v5, v6, v7, v8);
}

void CGContextSetGrayStrokeColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CGColorSpace *DeviceGray;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CGContextRef v16;
  char v17;
  CGFloat v18[3];

  v18[2] = *(CGFloat *)MEMORY[0x1E0C80C00];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v18[0] = gray;
      v18[1] = alpha;
      DeviceGray = CGColorSpaceCreateDeviceGray();
      set_stroke_color_with_components((uint64_t *)c, DeviceGray, v18, v11, v12, v13, v14, v15, v17);
      CGColorSpaceRelease(DeviceGray);
      return;
    }
    v16 = c;
  }
  else
  {
    v16 = 0;
  }
  handle_invalid_context((char)"CGContextSetGrayStrokeColor", (uint64_t)v16, v3, v4, v5, v6, v7, v8);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CGColorSpace *DeviceRGB;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CGContextRef v18;
  char v19;
  CGFloat v20[5];

  v20[4] = *(CGFloat *)MEMORY[0x1E0C80C00];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v20[0] = red;
      v20[1] = green;
      v20[2] = blue;
      v20[3] = alpha;
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      set_stroke_color_with_components((uint64_t *)c, DeviceRGB, v20, v13, v14, v15, v16, v17, v19);
      CGColorSpaceRelease(DeviceRGB);
      return;
    }
    v18 = c;
  }
  else
  {
    v18 = 0;
  }
  handle_invalid_context((char)"CGContextSetRGBStrokeColor", (uint64_t)v18, v5, v6, v7, v8, v9, v10);
}

void CGContextSetCMYKFillColor(CGContextRef c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGColorSpace *DeviceCMYK;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CGContextRef v19;
  CGFloat v20[6];

  v20[5] = *(CGFloat *)MEMORY[0x1E0C80C00];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      LOBYTE(v20[0]) = LOBYTE(cyan);
      v20[1] = magenta;
      v20[2] = yellow;
      v20[3] = black;
      v20[4] = alpha;
      DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
      set_fill_color_with_components((uint64_t *)c, DeviceCMYK, v20, v14, v15, v16, v17, v18, SLOBYTE(v20[0]));
      CGColorSpaceRelease(DeviceCMYK);
      return;
    }
    v19 = c;
  }
  else
  {
    v19 = 0;
  }
  handle_invalid_context((char)"CGContextSetCMYKFillColor", (uint64_t)v19, v6, v7, v8, v9, v10, v11);
}

void CGContextSetCMYKStrokeColor(CGContextRef c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGColorSpace *DeviceCMYK;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CGContextRef v19;
  CGFloat v20[6];

  v20[5] = *(CGFloat *)MEMORY[0x1E0C80C00];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      LOBYTE(v20[0]) = LOBYTE(cyan);
      v20[1] = magenta;
      v20[2] = yellow;
      v20[3] = black;
      v20[4] = alpha;
      DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
      set_stroke_color_with_components((uint64_t *)c, DeviceCMYK, v20, v14, v15, v16, v17, v18, SLOBYTE(v20[0]));
      CGColorSpaceRelease(DeviceCMYK);
      return;
    }
    v19 = c;
  }
  else
  {
    v19 = 0;
  }
  handle_invalid_context((char)"CGContextSetCMYKStrokeColor", (uint64_t)v19, v6, v7, v8, v9, v10, v11);
}

uint64_t CGContextGetFont(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 8);
  handle_invalid_context((char)"CGContextGetFont", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

double CGContextGetFontSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 16);
  handle_invalid_context((char)"CGContextGetFontSize", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

double CGContextGetCharacterSpacing(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 24);
  handle_invalid_context((char)"CGContextGetCharacterSpacing", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetTextDrawingMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 1);
  handle_invalid_context((char)"CGContextGetTextDrawingMode", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

double CGContextGetTextGreekingThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 32);
  handle_invalid_context((char)"CGContextGetTextGreekingThreshold", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

void CGContextSetTextGreekingThreshold(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    v10 = *(_QWORD *)(a1 + 96);
    if (*(double *)(*(_QWORD *)(v10 + 136) + 32) != a2)
    {
      maybe_copy_text_state(*(_QWORD *)(a1 + 96));
      *(double *)(*(_QWORD *)(v10 + 136) + 32) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetTextGreekingThreshold", a1, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t CGContextGetShouldAntialiasFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return (**(unsigned __int16 **)(*(_QWORD *)(a1 + 96) + 136) >> 2) & 1;
  handle_invalid_context((char)"CGContextGetShouldAntialiasFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

uint64_t CGContextGetShouldSmoothFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return (**(unsigned __int16 **)(*(_QWORD *)(a1 + 96) + 136) >> 3) & 1;
  handle_invalid_context((char)"CGContextGetShouldSmoothFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

uint64_t CGContextGetShouldSubpixelPositionFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return (**(unsigned __int16 **)(*(_QWORD *)(a1 + 96) + 136) >> 4) & 1;
  handle_invalid_context((char)"CGContextGetShouldSubpixelPositionFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

uint64_t CGContextGetShouldSubpixelQuantizeFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return (**(unsigned __int16 **)(*(_QWORD *)(a1 + 96) + 136) >> 5) & 1;
  handle_invalid_context((char)"CGContextGetShouldSubpixelQuantizeFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

uint64_t CGContextGetShouldUsePlatformNativeGlyphs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return (**(unsigned __int16 **)(*(_QWORD *)(a1 + 96) + 136) >> 6) & 1;
  handle_invalid_context((char)"CGContextGetShouldUsePlatformNativeGlyphs", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

void CGContextSetShouldUsePlatformNativeGlyphs(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetShouldUsePlatformNativeGlyphs(*(_QWORD *)(a1 + 96), a2);
      return;
    }
    v8 = a1;
  }
  else
  {
    v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldUsePlatformNativeGlyphs", v8, a3, a4, a5, a6, a7, a8);
}

uint64_t CGContextGetFontAntialiasingStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 48);
  handle_invalid_context((char)"CGContextGetFontAntialiasingStyle", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontAntialiasingStyle(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    HIDWORD(v10) = a2;
    LODWORD(v10) = a2;
    v9 = v10 >> 7;
    if (v9 <= 9 && ((1 << v9) & 0x30F) != 0)
    {
      v11 = *(_QWORD *)(a1 + 96);
      if (*(_DWORD *)(*(_QWORD *)(v11 + 136) + 48) != a2)
      {
        maybe_copy_text_state(*(_QWORD *)(a1 + 96));
        *(_DWORD *)(*(_QWORD *)(v11 + 136) + 48) = a2;
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontAntialiasingStyle", a1, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t CGContextGetFontSmoothingStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 52);
  handle_invalid_context((char)"CGContextGetFontSmoothingStyle", a1, a3, a4, a5, a6, a7, a8);
  return 48;
}

void CGContextSetFontSmoothingStyle(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  uint64_t v10;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    HIDWORD(v9) = a2;
    LODWORD(v9) = a2 - 16;
    if ((v9 >> 4) <= 6)
    {
      v10 = *(_QWORD *)(a1 + 96);
      if (*(_DWORD *)(*(_QWORD *)(v10 + 136) + 52) != a2)
      {
        maybe_copy_text_state(*(_QWORD *)(a1 + 96));
        *(_DWORD *)(*(_QWORD *)(v10 + 136) + 52) = a2;
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontSmoothingStyle", a1, a3, a4, a5, a6, a7, a8);
  }
}

double CGContextGetFontSmoothingContrast(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 40);
  handle_invalid_context((char)"CGContextGetFontSmoothingContrast", a1, a3, a4, a5, a6, a7, a8);
  return 1.0;
}

void CGContextSetFontSmoothingContrast(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    v10 = *(_QWORD *)(a1 + 96);
    if (*(double *)(*(_QWORD *)(v10 + 136) + 40) != a2)
    {
      maybe_copy_text_state(*(_QWORD *)(a1 + 96));
      *(double *)(*(_QWORD *)(v10 + 136) + 40) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontSmoothingContrast", a1, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t CGContextGetFontSmoothingBackgroundColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 64);
  handle_invalid_context((char)"CGContextGetFontSmoothingBackgroundColor", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontSmoothingBackgroundColor(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetFontSmoothingBackgroundColor(*(_QWORD *)(a1 + 96), a2);
      return;
    }
    v8 = a1;
  }
  else
  {
    v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetFontSmoothingBackgroundColor", v8, a3, a4, a5, a6, a7, a8);
}

double CGContextGetDeviceClipBoundingBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return get_device_clip_bounding_box(a1);
  handle_invalid_context((char)"CGContextGetDeviceClipBoundingBox", a1, a3, a4, a5, a6, a7, a8);
  return INFINITY;
}

double CGContextGetFlatness(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 8);
  handle_invalid_context((char)"CGContextGetFlatness", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetFillOverprint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 24);
  handle_invalid_context((char)"CGContextGetFillOverprint", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetStrokeOverprint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 25);
  handle_invalid_context((char)"CGContextGetStrokeOverprint", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetOverprintMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 28);
  handle_invalid_context((char)"CGContextGetOverprintMode", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetBlackGeneration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 32);
  handle_invalid_context((char)"CGContextGetBlackGeneration", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetUndercolorRemoval(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 40);
  handle_invalid_context((char)"CGContextGetUndercolorRemoval", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetTransferFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
    handle_invalid_context((char)"CGContextGetTransferFunctions", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetTransferFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
    handle_invalid_context((char)"CGContextSetTransferFunctions", a1, a3, a4, a5, a6, a7, a8);
}

double CGContextGetSmoothness(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 144) + 16);
  handle_invalid_context((char)"CGContextGetSmoothness", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetImageRenderingIntent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  int v9;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 120) + 4);
    if (((v8 >> 20) & 0xF) != 0)
      v9 = v8 << 8;
    else
      v9 = v8 << 12;
    return (v9 >> 28);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetImageRenderingIntent", a1, a3, a4, a5, a6, a7, a8);
    return 3;
  }
}

double CGContextGetLineWidthThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 128) + 24);
  handle_invalid_context((char)"CGContextGetLineWidthThreshold", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

void CGContextSetLineWidthThreshold(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;

  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    v10 = *(_QWORD *)(a1 + 96);
    if (*(double *)(*(_QWORD *)(v10 + 128) + 24) != a2)
    {
      maybe_copy_stroke_state(*(_QWORD *)(a1 + 96));
      *(double *)(*(_QWORD *)(v10 + 128) + 24) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetLineWidthThreshold", a1, a4, a5, a6, a7, a8, a9);
  }
}

double CGContextGetAdjustedLineWidth(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  CGAffineTransform v10;

  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    v8 = *((_QWORD *)c + 12);
    CGContextGetUserSpaceToDeviceSpaceTransform(&v10, c);
    return CGGStateGetAdjustedLineWidth(v8, &v10.a);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetAdjustedLineWidth", (uint64_t)c, a3, a4, a5, a6, a7, a8);
    return 0.0;
  }
}

double CGContextGetPatternPhase(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 120) + 24);
  handle_invalid_context((char)"CGContextGetPatternPhase", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetAlphaIsShape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return (*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 120) + 7) >> 1) & 1;
  handle_invalid_context((char)"CGContextGetAlphaIsShape", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontDilation(uint64_t a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    CGGStateSetFontDilation(*(_QWORD *)(a1 + 96), a2, a3);
  else
    handle_invalid_context((char)"CGContextSetFontDilation", a1, a5, a6, a7, a8, a9, a10);
}

double CGContextGetFontDilation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 72);
  handle_invalid_context((char)"CGContextGetFontDilation", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetFontSubpixelQuantizationLevel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 136) + 88);
  handle_invalid_context((char)"CGContextGetFontSubpixelQuantizationLevel", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontSubpixelQuantizationLevel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (!a1)
  {
    v14 = 0;
LABEL_16:
    handle_invalid_context((char)"CGContextSetFontSubpixelQuantizationLevel", v14, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v14 = a1;
    goto LABEL_16;
  }
  v8 = *(_QWORD *)(a1 + 96);
  v9 = HIDWORD(a2);
  v10 = a2 & ~((int)a2 >> 31);
  if (SHIDWORD(a2) >= 128)
    LODWORD(v9) = 128;
  if (v10 >= 0x80)
    v11 = 128;
  else
    v11 = v10;
  if (a2 >= 0)
    v12 = v9;
  else
    v12 = 0;
  if (*(_QWORD *)(*(_QWORD *)(v8 + 136) + 88) != (v11 | (v12 << 32)))
  {
    maybe_copy_text_state(v8);
    v13 = *(_QWORD *)(v8 + 136);
    *(_DWORD *)(v13 + 88) = v11;
    *(_DWORD *)(v13 + 92) = v12;
  }
}

void CGEnterLockdownModeForPDF()
{
  sInLockdownModeForPDF = 1;
}

void __read_entitlements_block_invoke()
{
  __SecTask *v0;
  __SecTask *v1;
  const __CFBoolean *v2;
  const __CFBoolean *v3;
  CFTypeID v4;
  const __CFBoolean *v5;
  const __CFBoolean *v6;
  CFTypeID v7;

  v0 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (v0)
  {
    v1 = v0;
    v2 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v0, CFSTR("com.apple.coregraphics.disablepdf"), 0);
    if (v2)
    {
      v3 = v2;
      v4 = CFGetTypeID(v2);
      if (v4 == CFBooleanGetTypeID())
        sHasLockdownModeForPDFEntitlement = CFBooleanGetValue(v3) != 0;
      else
        pdf_error("Invalid value for entitlement: %s. Must be CFBooleanRef", "com.apple.coregraphics.disablepdf");
    }
    v5 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v1, CFSTR("com.apple.coregraphics.disableinmemoryfonts"), 0);
    if (v5)
    {
      v6 = v5;
      v7 = CFGetTypeID(v5);
      if (v7 == CFBooleanGetTypeID())
        sHasLockdownModeForFontsEntitlement = CFBooleanGetValue(v6) != 0;
      else
        pdf_error("Invalid value for entitlement: %s. Must be CFBooleanRef", "com.apple.coregraphics.disableinmemoryfonts");
    }
    CFRelease(v1);
  }
}

void CGEnterLockdownModeForFonts()
{
  sInLockdownModeForFonts = 1;
}

BOOL CGIsInLockdownModeForFonts()
{
  if ((sInLockdownModeForFonts & 1) != 0)
    return 1;
  if (read_entitlements_once != -1)
    dispatch_once(&read_entitlements_once, &__block_literal_global_10334);
  return sHasLockdownModeForFontsEntitlement != 0;
}

void PDFAnnotationSetRelease(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;
  const void *v4;

  if (a1)
  {
    do
    {
      v2 = __ldxr(a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, a1));
    if (!v3)
    {
      v4 = (const void *)*((_QWORD *)a1 + 4);
      if (v4)
        CFRelease(v4);
      free(a1);
    }
  }
}

_QWORD *CGPDFTextStringFinalize(uint64_t a1)
{
  _QWORD *result;

  for (result = *(_QWORD **)(a1 + 24); result; result = *(_QWORD **)(a1 + 24))
  {
    *(_QWORD *)(a1 + 24) = *result;
    text_block_release(result);
  }
  return result;
}

void text_block_release(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  v2 = (const void *)a1[3];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[4];
  if (v3)
    CFRelease(v3);
  free(a1);
}

CFTypeRef CGPDFTextStringRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGPDFTextStringRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGPDFTextStringGetLength(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

_QWORD *CGPDFTextStringGetCharacterAtIndex(uint64_t a1, unint64_t a2)
{
  _QWORD *result;

  result = find_block(a1, a2);
  if (result)
    return (_QWORD *)WORD1(result[4 * (a2 - result[1]) + 14]);
  return result;
}

_QWORD *find_block(uint64_t a1, unint64_t a2)
{
  _QWORD *result;

  result = *(_QWORD **)(a1 + 40);
  if (result && result[1] <= a2 || (result = *(_QWORD **)(a1 + 24)) != 0)
  {
    while (result[2] + result[1] <= a2)
    {
      result = (_QWORD *)*result;
      if (!result)
        return result;
    }
    *(_QWORD *)(a1 + 40) = result;
  }
  return result;
}

_QWORD *CGPDFTextStringGetGlyphAtIndex(uint64_t a1, unint64_t a2)
{
  _QWORD *result;

  result = find_block(a1, a2);
  if (result)
    return (_QWORD *)LOWORD(result[4 * (a2 - result[1]) + 14]);
  return result;
}

CGFloat CGPDFTextStringGetPositionForIndex(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *block;
  unint64_t v6;
  const CGPoint *v7;

  block = find_block(a1, a2);
  if (block)
  {
    v6 = a2 - block[1];
    if (a3)
    {
      *a3 = block[4 * v6 + 13];
      a3[1] = 0;
    }
    v7 = (const CGPoint *)&block[4 * v6 + 11];
  }
  else
  {
    if (a3)
    {
      *a3 = 0;
      a3[1] = 0;
    }
    v7 = &CGPointZero;
  }
  return v7->x;
}

double CGPDFTextStringGetBBoxForIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _QWORD *block;
  uint64_t v6;
  const CGAffineTransform *v7;
  __int128 v8;
  double result;
  CGAffineTransform v10;
  CGRect v11;

  block = find_block(a1, a2);
  if (block)
  {
    if (a3)
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    v6 = block[3];
  }
  else
  {
    v6 = 0;
    if (a3)
    {
      *(_QWORD *)a3 = a2;
      *(_QWORD *)(a3 + 8) = 0;
    }
  }
  v7 = (const CGAffineTransform *)(v6 + 56);
  if (!v6)
    v7 = &CGAffineTransformIdentity;
  v8 = *(_OWORD *)&v7->c;
  *(_OWORD *)&v10.a = *(_OWORD *)&v7->a;
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tx = *(_OWORD *)&v7->tx;
  v11.origin.x = CGPDFFontGetFontBBox(v6);
  *(_QWORD *)&result = (unint64_t)CGRectApplyAffineTransform(v11, &v10);
  return result;
}

uint64_t CGPDFTextStringGetFontForIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _QWORD *block;
  uint64_t result;

  block = find_block(a1, a2);
  if (block)
  {
    if (a3)
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    return block[3];
  }
  else
  {
    result = 0;
    if (a3)
    {
      *(_QWORD *)a3 = a2;
      *(_QWORD *)(a3 + 8) = 0;
    }
  }
  return result;
}

__n128 CGPDFTextStringGetTransformForIndex@<Q0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  _QWORD *block;
  const CGAffineTransform *v8;
  __int128 v9;
  __n128 result;

  block = find_block(a1, a2);
  if (block)
  {
    if (a3)
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    v8 = (const CGAffineTransform *)(block + 5);
  }
  else
  {
    if (a3)
    {
      *(_QWORD *)a3 = a2;
      *(_QWORD *)(a3 + 8) = 0;
    }
    v8 = &CGAffineTransformIdentity;
  }
  v9 = *(_OWORD *)&v8->c;
  *(_OWORD *)a4 = *(_OWORD *)&v8->a;
  *(_OWORD *)(a4 + 16) = v9;
  result = *(__n128 *)&v8->tx;
  *(__n128 *)(a4 + 32) = result;
  return result;
}

uint64_t CGPDFTextStringGetColorForIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _QWORD *block;
  uint64_t result;

  block = find_block(a1, a2);
  if (block)
  {
    if (a3)
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    return block[4];
  }
  else
  {
    result = 0;
    if (a3)
    {
      *(_QWORD *)a3 = a2;
      *(_QWORD *)(a3 + 8) = 0;
    }
  }
  return result;
}

_QWORD *CGPDFTextStringAppendTextLayout(_QWORD *result, uint64_t a2, _QWORD *a3, __n128 a4)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  _QWORD v21[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;

  if (result && a2 && a3)
  {
    v21[0] = a2;
    v21[1] = result;
    if (*((_BYTE *)result + 16))
      return CGPDFTextLayoutDrawGlyphs(a3, (void (*)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, char *, char *, _QWORD, uint64_t))draw_glyphs, (uint64_t)v21, a4);
    v5 = (_QWORD *)*a3;
    if (*a3)
    {
      v6 = 0;
      do
      {
        v7 = v5;
        v5 = (_QWORD *)*v5;
        *v7 = v6;
        v6 = v7;
      }
      while (v5);
      *a3 = v7;
      while (1)
      {
        v8 = v7[1];
        v9 = *(void **)(v8 + 40);
        v10 = (__int128 *)(v8 + 64);
        v11 = *(_QWORD *)(v8 + 128);
        v12 = *(_QWORD *)(v8 + 136);
        v13 = *(_QWORD *)(v8 + 8);
        if (!*(_BYTE *)(v8 + 17))
          break;
        v14 = *(_QWORD *)(v8 + 120);
        if (!v14)
        {
          v20 = *(_OWORD *)(v8 + 80);
          v22 = *v10;
          v23 = v20;
          v24 = *(_OWORD *)(v8 + 96);
          v18 = v11;
          v19 = v12;
          v16 = 0;
          goto LABEL_16;
        }
        v15 = *(_OWORD *)(v8 + 80);
        v22 = *v10;
        v23 = v15;
        v24 = *(_OWORD *)(v8 + 96);
        append_cid_text((uint64_t)v21, v9, (double *)&v22, 0, v14, v11, v12, v13);
LABEL_17:
        v7 = (_QWORD *)*v7;
        if (!v7)
          return text_layout_reset(a3);
      }
      v16 = *(_QWORD *)(v8 + 112);
      v17 = *(_OWORD *)(v8 + 80);
      v22 = *v10;
      v23 = v17;
      v24 = *(_OWORD *)(v8 + 96);
      v18 = v11;
      v19 = v12;
LABEL_16:
      append_standard_text((uint64_t)v21, v9, (double *)&v22, 0, v18, v19, v16, v13);
      goto LABEL_17;
    }
    *a3 = 0;
    return text_layout_reset(a3);
  }
  return result;
}

void draw_glyphs(uint64_t a1, void *a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int128 v9;
  _OWORD v10[3];

  v9 = a3[1];
  v10[0] = *a3;
  v10[1] = v9;
  v10[2] = a3[2];
  if (a7)
    append_cid_text(a1, a2, (double *)v10, a6, a7, a4, a5, a9);
  else
    append_standard_text(a1, a2, (double *)v10, a6, a4, a5, a8, a9);
}

_WORD *append_standard_text(uint64_t a1, void *a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16;
  double *v17;
  _WORD *result;
  uint64_t v19;
  const CGAffineTransform *v20;
  double b;
  double c;
  double d;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  CGFloat v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _WORD *v38;
  uint64_t v39;
  __int16 v40;
  __int16 v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  double *v45;
  __int16 v46;
  double *v47;
  double **v48;
  double **v49;
  uint64_t v50;
  uint64_t v51;

  v16 = *(_QWORD *)(a1 + 8);
  v17 = (double *)malloc_type_calloc(1uLL, 32 * a8 + 88, 0x33BCE901uLL);
  result = (_WORD *)__CFSetLastAllocationEventName();
  if (v17)
  {
    v51 = 0;
    v19 = *(_QWORD *)(v16 + 48);
    *v17 = 0.0;
    *((_QWORD *)v17 + 1) = v19;
    *((_QWORD *)v17 + 2) = a8;
    if (a2)
      CFRetain(a2);
    *((_QWORD *)v17 + 3) = a2;
    *((_QWORD *)v17 + 4) = copy_color();
    v20 = *(const CGAffineTransform **)a1;
    if (*(_QWORD *)a1)
      v20 = *(const CGAffineTransform **)&v20->a;
    v50 = v16;
    if (!v20)
      v20 = &CGAffineTransformIdentity;
    b = v20->b;
    c = v20->c;
    d = v20->d;
    v24 = a3[1];
    v25 = a3[2];
    v26 = a3[3];
    v27 = a3[4];
    v28 = a3[5];
    v29 = v24 * c + *a3 * v20->a;
    v30 = v24 * d + *a3 * b;
    v31 = v26 * c + v25 * v20->a;
    v32 = v26 * d + v25 * b;
    v33 = v20->tx + c * v28 + v27 * v20->a;
    v34 = d * v28 + v27 * b + v20->ty;
    v17[5] = v29;
    v17[6] = v30;
    v17[7] = v31;
    v17[8] = v32;
    v17[9] = v33;
    v17[10] = v34;
    result = CGPDFFontGetEncoding((unint64_t *)a2);
    if (a8)
    {
      v35 = (uint64_t)result;
      v36 = 0;
      v37 = 0;
      while (1)
      {
        result = (_WORD *)CGPDFEncodingGetUnicodesForIndex(v35, *(unsigned __int8 *)(a7 + v37), &v51);
        v38 = result;
        v39 = v51 - 1;
        if (v51 == 1)
        {
          v41 = *result;
          goto LABEL_25;
        }
        if (!v51)
        {
          WORD1(v17[4 * v36 + 14]) = 0;
          if (a4)
            goto LABEL_26;
          goto LABEL_13;
        }
        v42 = v39 + *((_QWORD *)v17 + 2);
        *((_QWORD *)v17 + 2) = v42;
        if (v42 > 0x7FFFFFFFFFFFFFDLL)
          break;
        result = malloc_type_realloc(v17, 32 * v42 + 88, 0x61043DE6uLL);
        v17 = (double *)result;
        v39 = v51 - 1;
        if (v51 != 1)
          goto LABEL_18;
LABEL_24:
        v41 = v38[v39];
LABEL_25:
        WORD1(v17[4 * v36 + 14]) = v41;
        if (a4)
        {
LABEL_26:
          v40 = *(_WORD *)(a4 + 2 * v37);
          goto LABEL_27;
        }
LABEL_13:
        v40 = 0;
LABEL_27:
        v47 = &v17[4 * v36];
        *((_WORD *)v47 + 56) = v40;
        *(_OWORD *)(v47 + 11) = *(_OWORD *)(a5 + 16 * v37);
        v47[13] = *(double *)(a6 + 8 * v37);
        ++v36;
        if (++v37 == a8)
          goto LABEL_28;
      }
      v17 = 0;
LABEL_18:
      v43 = 0;
      v44 = 4 * v36;
      do
      {
        v45 = &v17[v44];
        WORD1(v17[v44 + 14]) = v38[v43];
        if (a4)
          v46 = *(_WORD *)(a4 + 2 * v37);
        else
          v46 = 0;
        *((_WORD *)v45 + 56) = v46;
        *(_OWORD *)(v45 + 11) = *(_OWORD *)(a5 + 16 * v37);
        v45[13] = 0.0;
        ++v43;
        v44 += 4;
      }
      while (v39 != v43);
      v36 += v43;
      goto LABEL_24;
    }
LABEL_28:
    v48 = (double **)(v50 + 32);
    if (*(_QWORD *)(v50 + 24))
    {
      v49 = (double **)*v48;
    }
    else
    {
      v49 = (double **)(v50 + 32);
      v48 = (double **)(v50 + 24);
    }
    *v49 = v17;
    *v48 = v17;
    *(_QWORD *)(v50 + 48) += *((_QWORD *)v17 + 2);
  }
  return result;
}

void append_cid_text(uint64_t a1, void *a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  double *v15;
  uint64_t v16;
  const CGAffineTransform *v17;
  double b;
  double c;
  double d;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  CGFloat v30;
  double v31;
  uint64_t ROSUnicodeCMap;
  __n128 v33;
  uint64_t (*v34)(_QWORD);
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char *v39;
  __int16 *v40;
  uint64_t v41;
  uint64_t i;
  uint64_t v43;
  uint64_t (*v44)(_QWORD, uint64_t, __int16 *);
  uint64_t v45;
  uint64_t v46;
  __int16 v47;
  __int16 v48;
  unint64_t v49;
  _WORD *v50;
  __int16 *v51;
  uint64_t v52;
  __int16 v53;
  __int16 v54;
  double *v55;
  uint64_t v56;
  double **v57;
  double **v58;
  _QWORD v59[2];
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;

  v61 = a7;
  v62 = a5;
  v63 = *MEMORY[0x1E0C80C00];
  v14 = *(_QWORD *)(a1 + 8);
  v15 = (double *)malloc_type_calloc(1uLL, 32 * a8 + 88, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v15)
  {
    v16 = *(_QWORD *)(v14 + 48);
    *v15 = 0.0;
    *((_QWORD *)v15 + 1) = v16;
    *((_QWORD *)v15 + 2) = a8;
    if (a2)
      CFRetain(a2);
    *((_QWORD *)v15 + 3) = a2;
    *((_QWORD *)v15 + 4) = copy_color();
    v17 = *(const CGAffineTransform **)a1;
    if (*(_QWORD *)a1)
      v17 = *(const CGAffineTransform **)&v17->a;
    if (!v17)
      v17 = &CGAffineTransformIdentity;
    b = v17->b;
    c = v17->c;
    d = v17->d;
    v21 = a3[1];
    v22 = a3[2];
    v23 = a3[3];
    v24 = a3[4];
    v25 = a3[5];
    v26 = v21 * c + *a3 * v17->a;
    v27 = v21 * d + *a3 * b;
    v28 = v23 * c + v22 * v17->a;
    v29 = v23 * d + v22 * b;
    v30 = v17->tx + c * v25 + v24 * v17->a;
    v31 = d * v25 + v24 * b + v17->ty;
    v15[5] = v26;
    v15[6] = v27;
    v15[7] = v28;
    v15[8] = v29;
    v15[9] = v30;
    v15[10] = v31;
    ROSUnicodeCMap = CGPDFFontGetToUnicodeCMap((uint64_t)a2);
    if (ROSUnicodeCMap || (ROSUnicodeCMap = (uint64_t)CGPDFFontGetROSUnicodeCMap((char *)a2)) != 0)
    {
      if (cmap_vtable && (v34 = *(uint64_t (**)(_QWORD))(cmap_vtable + 56)) != 0)
        v35 = v34(*(_QWORD *)(ROSUnicodeCMap + 16));
      else
        v35 = 0;
      MEMORY[0x1E0C80A78](v35, v33);
      v39 = (char *)v59 - v38;
      if (v37 <= 0x7FFFFFFFFFFFFFFELL)
        v40 = (__int16 *)((char *)v59 - v38);
      else
        v40 = 0;
      if (v37 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000022)
        v40 = (__int16 *)malloc_type_malloc(2 * v36, 0x77887A56uLL);
      if (v40)
      {
        v59[0] = v39;
        v59[1] = v59;
        v60 = v14;
        if (a8)
        {
          v41 = 0;
          for (i = 0; i != a8; ++i)
          {
            v43 = *(unsigned __int16 *)(v62 + 2 * i);
            if (cmap_vtable)
            {
              v44 = *(uint64_t (**)(_QWORD, uint64_t, __int16 *))(cmap_vtable + 64);
              if (v44)
              {
                v45 = v44(*(_QWORD *)(ROSUnicodeCMap + 16), v43, v40);
                if (v45)
                  goto LABEL_28;
                LODWORD(v43) = *(unsigned __int16 *)(v62 + 2 * i);
              }
            }
            v45 = CGPDFGetUnicharGuessForCID(v43, v40);
LABEL_28:
            v46 = v45 - 1;
            if (v45 == 1)
            {
              v48 = *v40;
            }
            else
            {
              if (!v45)
              {
                WORD1(v15[4 * v41 + 14]) = 0;
                if (a4)
                  goto LABEL_43;
                goto LABEL_31;
              }
              v49 = *((_QWORD *)v15 + 2) + v46;
              *((_QWORD *)v15 + 2) = v49;
              if (v49 <= 0x7FFFFFFFFFFFFFDLL)
                v15 = (double *)malloc_type_realloc(v15, 32 * v49 + 88, 0x61043DE6uLL);
              else
                v15 = 0;
              v50 = (_WORD *)&v15[4 * v41 + 14] + 1;
              v41 = v45 + v41 - 1;
              v51 = v40;
              v52 = v45 - 1;
              do
              {
                v53 = *v51++;
                *v50 = v53;
                if (a4)
                  v54 = *(_WORD *)(a4 + 2 * i);
                else
                  v54 = 0;
                *(v50 - 1) = v54;
                *(_OWORD *)(v50 - 13) = *(_OWORD *)(a6 + 16 * i);
                *(_QWORD *)(v50 - 5) = 0;
                v50 += 16;
                --v52;
              }
              while (v52);
              v48 = v40[v46];
            }
            WORD1(v15[4 * v41 + 14]) = v48;
            if (a4)
            {
LABEL_43:
              v47 = *(_WORD *)(a4 + 2 * i);
              goto LABEL_44;
            }
LABEL_31:
            v47 = 0;
LABEL_44:
            v55 = &v15[4 * v41];
            *((_WORD *)v55 + 56) = v47;
            *(_OWORD *)(v55 + 11) = *(_OWORD *)(a6 + 16 * i);
            v55[13] = *(double *)(v61 + 8 * i);
            ++v41;
          }
        }
        if (v40 != (__int16 *)v59[0])
          free(v40);
        v56 = v60;
        v57 = (double **)(v60 + 32);
        if (*(_QWORD *)(v60 + 24))
        {
          v58 = (double **)*v57;
        }
        else
        {
          v58 = (double **)(v60 + 32);
          v57 = (double **)(v60 + 24);
        }
        *v58 = v15;
        *v57 = v15;
        *(_QWORD *)(v56 + 48) += *((_QWORD *)v15 + 2);
      }
      else
      {
        text_block_release(v15);
      }
    }
    else
    {
      text_block_release(v15);
    }
  }
}

const void *copy_color()
{
  const void *v0;
  CGColorSpace *DeviceRGB;

  v0 = (const void *)copy_color_color;
  if (copy_color_color
    || (DeviceRGB = CGColorSpaceCreateDeviceRGB(),
        copy_color_color = (uint64_t)CGColorCreate(DeviceRGB, copy_color_components),
        CGColorSpaceRelease(DeviceRGB),
        (v0 = (const void *)copy_color_color) != 0))
  {
    CFRetain(v0);
  }
  return v0;
}

void std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__destroy_vector::operator()[abi:se180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 24;
        std::__destroy_at[abi:se180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:se180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(uint64_t a1)
{
  const void *v1;

  if (a1)
  {
    v1 = *(const void **)(a1 + 16);
    if (v1)
      CFRelease(v1);
  }
  else
  {
    __break(1u);
  }
}

void StructureElement::~StructureElement(StructureElement *this)
{
  StructureElement **v2;
  StructureElement **v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  CFTypeRef *v7;
  CFTypeRef *v8;
  const void *v9;
  const void *v10;
  const void **v11;
  const void **v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  v2 = (StructureElement **)*((_QWORD *)this + 14);
  v3 = (StructureElement **)*((_QWORD *)this + 15);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
      {
        StructureElement::~StructureElement(*v2);
        MEMORY[0x186DC23C4]();
      }
      ++v2;
    }
    while (v2 != v3);
    v2 = (StructureElement **)*((_QWORD *)this + 14);
  }
  *((_QWORD *)this + 15) = v2;
  v4 = (uint64_t *)*((_QWORD *)this + 17);
  v5 = (uint64_t *)*((_QWORD *)this + 18);
  if (v4 != v5)
  {
    do
    {
      v6 = *v4++;
      CGPDFNodeRelease(v6);
    }
    while (v4 != v5);
    v4 = (uint64_t *)*((_QWORD *)this + 17);
  }
  *((_QWORD *)this + 18) = v4;
  v7 = (CFTypeRef *)*((_QWORD *)this + 22);
  v8 = (CFTypeRef *)*((_QWORD *)this + 23);
  if (v7 != v8)
  {
    do
      CFRelease(*v7++);
    while (v7 != v8);
    v7 = (CFTypeRef *)*((_QWORD *)this + 22);
  }
  *((_QWORD *)this + 23) = v7;
  v9 = (const void *)*((_QWORD *)this + 20);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 21);
  if (v10)
    CFRelease(v10);
  v11 = (const void **)*((_QWORD *)this + 25);
  if (v11)
  {
    v12 = (const void **)*((_QWORD *)this + 26);
    v13 = (void *)*((_QWORD *)this + 25);
    if (v12 != v11)
    {
      do
        std::__destroy_at[abi:se180100]<applesauce::CF::ObjectRef<CGPDFTaggedNode *>,0>(--v12);
      while (v12 != v11);
      v13 = (void *)*((_QWORD *)this + 25);
    }
    *((_QWORD *)this + 26) = v11;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 22);
  if (v14)
  {
    *((_QWORD *)this + 23) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 17);
  if (v15)
  {
    *((_QWORD *)this + 18) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 14);
  if (v16)
  {
    *((_QWORD *)this + 15) = v16;
    operator delete(v16);
  }
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

void std::__destroy_at[abi:se180100]<applesauce::CF::ObjectRef<CGPDFTaggedNode *>,0>(const void **a1)
{
  const void *v1;

  if (a1)
  {
    v1 = *a1;
    if (v1)
      CFRelease(v1);
  }
  else
  {
    __break(1u);
  }
}

void TaggedParser::AddPage(TaggedParser *this, CGPDFPage *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CGPDFContentStream *v11;
  CGPDFOperatorTable *v12;
  uint64_t i;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  int RotationAngle;
  const CGRect *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CGFloat v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CGPDFScanner *v33;
  std::mutex *v34;
  uint64_t v35;
  CGPDFDictionary *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  CGPDFObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  CGPDFObjectRef v53;
  CGPDFObject *j;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  int v62;
  uint64_t v63;
  CGPDFArray *v64;
  uint64_t v65;
  size_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  _QWORD *v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  int64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t *v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  _QWORD *v100;
  uint64_t v101;
  BOOL v102;
  _QWORD *v103;
  uint64_t v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;
  size_t NumberOfPages;
  unint64_t v109;
  uint64_t v110;
  _QWORD *v111;
  const char *v112;
  _QWORD *v113;
  _QWORD *v114;
  unint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  const char *v124;
  int v125;
  std::mutex *v126;
  unint64_t v127[3];
  __int128 info;
  __int128 v129;
  CGFloat v130;
  CGPDFOperatorTable *v131;
  TaggedParser *v132;
  int v133;
  CFTypeRef CGDisplayList;
  CFTypeRef cf;
  CGPDFObjectRef v136;
  CGFloat v137;
  CFTypeRef *v138;
  CGFloat v139;
  CFTypeRef v140;
  uint64_t v141;
  CGPDFDictionary *v142;
  CGPDFObjectRef v143;
  CGPDFDictionaryRef value[2];
  CGRect BoxRect;

  if (a2)
    v4 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8);
  else
    v4 = 0;
  v5 = v4 - 1;
  v6 = *(_QWORD *)this;
  v7 = *(_QWORD *)(*(_QWORD *)this + 248);
  v8 = (v4 - 1) >> 6;
  v9 = 1 << (v4 - 1);
  v10 = *(_QWORD *)(v7 + 8 * v8);
  if ((v9 & v10) == 0)
  {
    *(_QWORD *)(v7 + 8 * v8) = v10 | v9;
    if (*(_QWORD *)v6)
    {
      v11 = (CGPDFContentStream *)CGPDFContentStreamCreate(*((_QWORD *)a2 + 5));
      v12 = CGPDFOperatorTableCreate();
      if (v12)
      {
        for (i = 0; i != 66; i += 2)
          CGPDFOperatorTableSetCallback(v12, (&off_1E1631C60)[i], (CGPDFOperatorCallback)(&off_1E1631C60)[i + 1]);
      }
      *(_QWORD *)&info = a2;
      v131 = v12;
      v132 = this;
      v133 = 0;
      BoxRect = CGPDFPageGetBoxRect(a2, kCGPDFCropBox);
      x = BoxRect.origin.x;
      y = BoxRect.origin.y;
      width = BoxRect.size.width;
      height = BoxRect.size.height;
      *((_QWORD *)&info + 1) = *(_QWORD *)&BoxRect.origin.x;
      *(CGFloat *)&v129 = BoxRect.origin.y;
      *((_QWORD *)&v129 + 1) = *(_QWORD *)&BoxRect.size.width;
      v130 = BoxRect.size.height;
      RotationAngle = CGPDFPageGetRotationAngle(a2);
      if (RotationAngle == 270 || RotationAngle == 90)
      {
        *((CGFloat *)&v129 + 1) = height;
        v130 = width;
        v25 = width;
      }
      else
      {
        v25 = height;
        height = width;
      }
      v136 = *(CGPDFObjectRef *)&x;
      v137 = y;
      v138 = *(CFTypeRef **)&height;
      v139 = v25;
      CGDisplayList = (CFTypeRef)CG::DisplayList::createCGDisplayList(0, (const __CFDictionary *)&v136, v19, v20, v21, v22, v23, v24);
      cf = (CFTypeRef)CGDisplayListContextCreate(CGDisplayList, v26, v27, v28, v29, v30, v31, v32);
      v33 = CGPDFScannerCreate(v11, v12, &info);
      CGPDFScannerScan(v33);
      if (v33)
        CFRelease(v33);
      if (v12)
        CFRelease(v12);
      if (v11)
        CFRelease(v11);
      if (cf)
        CFRelease(cf);
      if (CGDisplayList)
        CFRelease(CGDisplayList);
      v6 = *(_QWORD *)this;
    }
    v34 = (std::mutex *)(v6 + 32);
    std::mutex::lock((std::mutex *)(v6 + 32));
    v35 = *(_QWORD *)this;
    v36 = **(CGPDFDictionary ***)this;
    v37 = *(_QWORD *)(*(_QWORD *)this + 24);
    if (!v36)
    {
      if (!v37)
      {
        v57 = operator new();
        do
          v58 = __ldaxr(&gStructureElementCount);
        while (__stlxr(v58 + 1, &gStructureElementCount));
        *(_QWORD *)v57 = v58;
        *(_QWORD *)(v57 + 16) = 0;
        *(_QWORD *)(v57 + 24) = 0;
        *(_QWORD *)(v57 + 48) = 0;
        *(_QWORD *)(v57 + 56) = 0;
        *(_QWORD *)(v57 + 40) = 0;
        *(_BYTE *)(v57 + 64) = 0;
        *(_QWORD *)(v57 + 72) = -1;
        *(_QWORD *)(v57 + 80) = -1;
        *(_OWORD *)(v57 + 88) = 0u;
        *(_OWORD *)(v57 + 104) = 0u;
        *(_OWORD *)(v57 + 120) = 0u;
        *(_OWORD *)(v57 + 136) = 0u;
        *(_OWORD *)(v57 + 152) = 0u;
        *(_OWORD *)(v57 + 168) = 0u;
        *(_OWORD *)(v57 + 184) = 0u;
        *(_OWORD *)(v57 + 200) = 0u;
        *(_QWORD *)(v57 + 216) = 0;
        *(int64x2_t *)(v57 + 224) = vdupq_n_s64(0x7FF0000000000000uLL);
        *(_QWORD *)(v57 + 240) = 0;
        *(_QWORD *)(v57 + 248) = 0;
        *(_BYTE *)(v57 + 256) = 0;
        *(CGRect *)(v57 + 264) = CGRectNull;
        *(_QWORD *)(*(_QWORD *)this + 24) = v57;
        *(_DWORD *)(v57 + 32) = 100;
        *(_BYTE *)(v57 + 31) = 8;
        *(_QWORD *)(v57 + 8) = 0x746E656D75636F44;
      }
      goto LABEL_129;
    }
    v126 = v34;
    if (v37)
    {
      v39 = v35 + 200;
      v38 = *(_QWORD *)(v35 + 200);
      v40 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v39 + 8) - v38) >> 3);
      if (v40 <= v5)
        goto LABEL_159;
      v41 = (uint64_t *)(v38 + 24 * v5);
      v136 = 0;
      v137 = 0.0;
      v138 = 0;
      v42 = *v41;
      v43 = v41[1];
      *(_QWORD *)&info = &v136;
      BYTE8(info) = 0;
      if (v43 != v42)
      {
        v44 = 0xAAAAAAAAAAAAAAABLL * ((v43 - v42) >> 3);
        if (v44 >= 0xAAAAAAAAAAAAAABLL)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        *(double *)&v45 = COERCE_DOUBLE(std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v44));
        v136 = v45;
        v137 = *(double *)&v45;
        v138 = (CFTypeRef *)((char *)v45 + 24 * v46);
        do
        {
          if (*(double *)&v45 == 0.0)
            goto LABEL_159;
          *(_OWORD *)v45 = *(_OWORD *)v42;
          v47 = *(_QWORD *)(v42 + 16);
          if (v47)
            CFRetain(*(CFTypeRef *)(v42 + 16));
          *((_QWORD *)v45 + 2) = v47;
          v45 = (CGPDFObject *)((char *)v45 + 24);
          v42 += 24;
        }
        while (v42 != v43);
        v137 = *(double *)&v45;
        v38 = *(_QWORD *)(*(_QWORD *)this + 200);
        v40 = 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 208) - v38) >> 3);
      }
      if (v40 <= v5)
        goto LABEL_159;
      v48 = v38 + 24 * v5;
      v51 = *(_QWORD *)(v48 + 8);
      v49 = (_QWORD *)(v48 + 8);
      v50 = v51;
      v52 = *(_QWORD *)(v38 + 24 * v5);
      while (v50 != v52)
      {
        v50 -= 24;
        std::__destroy_at[abi:se180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(v50);
      }
      *v49 = v52;
      v53 = v136;
      for (j = *(CGPDFObject **)&v137; v53 != j; v53 = (CGPDFObjectRef)((char *)v53 + 24))
      {
        info = 0u;
        v129 = 0u;
        LODWORD(v130) = 1065353216;
        v143 = 0;
        value[0] = 0;
        v142 = 0;
        v127[0] = (unint64_t)value;
        v127[1] = (unint64_t)&v143;
        v127[2] = (unint64_t)&v142;
        std::__memberwise_copy_assign[abi:se180100]<std::tuple<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *> &>,std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0ul,1ul,2ul>((uint64_t)v127, v53);
        v55 = *((_QWORD *)value[0] + 14);
        if ((unint64_t)v143 >= (*((_QWORD *)value[0] + 15) - v55) >> 3)
          goto LABEL_159;
        if (!*(_QWORD *)(v55 + 8 * (_QWORD)v143))
          TaggedParser::BuildStructureElementFromDictionary(this, (uint64_t)value[0], v142, v4, (float *)&info, v143);
        if (v142)
          CFRelease(v142);
        std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table((uint64_t)&info);
      }
      v56 = *(_QWORD *)(*(_QWORD *)this + 200);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 208) - v56) >> 3) <= v5)
        goto LABEL_159;
      if (*(_QWORD *)(v56 + 24 * v5 + 8) != *(_QWORD *)(v56 + 24 * v5))
        __assert_rtn("AddPage", "TaggedParser.mm", 799, "_private->objectsToSearch[pageIndex].size() == 0");
      *(_QWORD *)&info = &v136;
      std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__destroy_vector::operator()[abi:se180100]((void ***)&info);
LABEL_78:
      CGPDFPageCopyPageLayoutWithCTLD((uint64_t)a2, 1);
      v71 = v70;
      v136 = (CGPDFObjectRef)v70;
      if (a2)
        v72 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8);
      else
        v72 = 0;
      v73 = *(_QWORD *)(*(_QWORD *)this + 128);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 136) - v73) >> 3) > v72 - 1)
      {
        *(_QWORD *)&info = v73 + 24 * (v72 - 1);
        *((_QWORD *)&info + 1) = v72;
        *(_QWORD *)&v129 = v70 + 2;
        *((_QWORD *)&v129 + 1) = a2;
        v74 = (char *)v70[36];
        v75 = (char *)v70[37];
        if (v74 != v75 && (unint64_t)(v75 - v74) <= v70[13] - v70[12])
        {
          v76 = (_QWORD *)v70[6];
          if ((_QWORD *)v70[7] == v76)
          {
            v78 = 0;
            v77 = -1;
          }
          else
          {
            v77 = v76[1] + *v76;
            v78 = 1;
          }
          v79 = 0;
          v80 = 0;
          v81 = 0;
          v82 = 0;
          v83 = *(_QWORD *)v74;
          while (1)
          {
            v84 = v71[9];
            if (v79 >= (v71[10] - v84) >> 1)
              break;
            v85 = *(_QWORD *)&v74[8 * v82];
            v86 = *(unsigned __int16 *)(v84 + 2 * v79);
            if (v86 == 32 || v83 != v85 || v82 == v77)
            {
              if (v81 >= 1)
                TaggedParser::addWords(CGPDFPage *)::$_0::operator()((uint64_t)&info, v83, v80, v81);
              v81 = v86 != 32;
              if (v86 == 32)
                v80 = v82 + 1;
              else
                v80 = v82;
              if (v82 == v77)
              {
                v89 = v71[6];
                if (v78 >= 0x8E38E38E38E38E39 * ((v71[7] - v89) >> 3))
                {
                  v77 = -1;
                }
                else
                {
                  v77 = *(_QWORD *)(v89 + 72 * v78 + 8) + *(_QWORD *)(v89 + 72 * v78);
                  ++v78;
                }
              }
            }
            else
            {
              ++v81;
            }
            v90 = v71[12];
            if (v82 >= (v71[13] - v90) >> 3)
              goto LABEL_159;
            v79 += *(_QWORD *)(v90 + 8 * v82++);
            v74 = (char *)v71[36];
            v83 = v85;
            if (v82 >= (uint64_t)(v71[37] - (_QWORD)v74) >> 3)
              goto LABEL_110;
          }
          LODWORD(v85) = v83;
LABEL_110:
          v34 = v126;
          if (v81 >= 1)
            TaggedParser::addWords(CGPDFPage *)::$_0::operator()((uint64_t)&info, v85, v80, v81);
        }
        CFRelease(v71);
        if (a2)
        {
          v91 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8) - 1;
          v92 = *(_QWORD *)this;
          v93 = *(_QWORD *)(*(_QWORD *)this + 224);
          if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(*(_QWORD *)this + 232) - v93) >> 3) > v91)
          {
            v95 = v92 + 128;
            v94 = *(_QWORD *)(v92 + 128);
            if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v95 + 8) - v94) >> 3) > v91)
            {
              v96 = *(uint64_t **)(v93 + 40 * v91 + 16);
              if (v96)
              {
                v97 = (_QWORD *)(v94 + 24 * v91 + 8);
                do
                {
                  v98 = (_QWORD *)*v97;
                  if (*v97)
                  {
                    v99 = v96[2];
                    v100 = v97;
                    do
                    {
                      v101 = v98[4];
                      v102 = v101 < v99;
                      if (v101 >= v99)
                        v103 = v98;
                      else
                        v103 = v98 + 1;
                      if (!v102)
                        v100 = v98;
                      v98 = (_QWORD *)*v103;
                    }
                    while (*v103);
                    if (v100 != v97 && v99 >= v100[4])
                    {
                      v104 = v100[5];
                      v105 = *(_OWORD *)(v96 + 3);
                      v106 = *(_OWORD *)(v96 + 5);
                      *(_BYTE *)(v104 + 256) = *((_BYTE *)v96 + 56);
                      *(_OWORD *)(v104 + 224) = v105;
                      *(_OWORD *)(v104 + 240) = v106;
                    }
                  }
                  v96 = (uint64_t *)*v96;
                }
                while (v96);
              }
LABEL_129:
              std::mutex::unlock(v34);
              return;
            }
          }
        }
      }
LABEL_159:
      __break(1u);
      goto LABEL_160;
    }
    v127[0] = v4;
    if (!TaggedParser::ValidatePageNumber(this, v36, v127))
    {
      v60 = 0;
LABEL_77:
      *(_QWORD *)(*(_QWORD *)this + 24) = v60;
      goto LABEL_78;
    }
    value[0] = 0;
    if (CGPDFDictionaryGetDictionary(v36, "RoleMap", value))
      CGPDFDictionaryApplyFunction(value[0], (CGPDFDictionaryApplierFunction)RoleMapCallback, (void *)(*(_QWORD *)this + 152));
    v59 = operator new();
    v60 = v59;
    do
      v61 = __ldaxr(&gStructureElementCount);
    while (__stlxr(v61 + 1, &gStructureElementCount));
    *(_QWORD *)v59 = v61;
    *(_QWORD *)(v59 + 8) = 0;
    *(_QWORD *)(v59 + 16) = 0;
    *(_QWORD *)(v59 + 24) = 0;
    *(_DWORD *)(v59 + 32) = 0;
    *(_QWORD *)(v59 + 48) = 0;
    *(_QWORD *)(v59 + 56) = 0;
    *(_QWORD *)(v59 + 40) = 0;
    *(_BYTE *)(v59 + 64) = 0;
    *(_QWORD *)(v59 + 72) = -1;
    *(_QWORD *)(v59 + 80) = -1;
    *(_OWORD *)(v59 + 88) = 0u;
    *(_OWORD *)(v59 + 104) = 0u;
    *(_OWORD *)(v59 + 120) = 0u;
    *(_OWORD *)(v59 + 136) = 0u;
    *(_OWORD *)(v59 + 152) = 0u;
    *(_OWORD *)(v59 + 168) = 0u;
    *(_OWORD *)(v59 + 184) = 0u;
    *(_OWORD *)(v59 + 200) = 0u;
    *(_QWORD *)(v59 + 216) = 0;
    *(int64x2_t *)(v59 + 224) = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_QWORD *)(v59 + 240) = 0;
    *(_QWORD *)(v59 + 248) = 0;
    *(_BYTE *)(v59 + 256) = 0;
    *(CGRect *)(v59 + 264) = CGRectNull;
    info = 0u;
    v129 = 0u;
    LODWORD(v130) = 1065353216;
    v143 = 0;
    if (CGPDFDictionaryGetObject(v36, "K", &v143))
    {
      if (!v143)
        goto LABEL_64;
      v62 = *((_DWORD *)v143 + 2);
      if (v62 != 7)
      {
        if (v62 == 8)
        {
          TaggedParser::BuildStructureElement(this, (uint64_t *)v60, (unint64_t)v143, v127[0], (float *)&info);
          goto LABEL_73;
        }
LABEL_64:
        v63 = *(_QWORD *)this;
        if (*(_BYTE *)(*(_QWORD *)this + 96))
        {
          printf("Hit tagged parsing error: \"%s\"\n", "Failed to retrieve dictionary or array of dictionaries for root structure element");
          v63 = *(_QWORD *)this;
        }
        *(_BYTE *)(v63 + 97) = 1;
        StructureElement::~StructureElement((StructureElement *)v60);
        MEMORY[0x186DC23C4]();
        v60 = 0;
        goto LABEL_76;
      }
      v64 = (CGPDFArray *)*((_QWORD *)v143 + 4);
      if (v64)
      {
        v65 = *((_QWORD *)v64 + 2);
        if (v65)
        {
          v66 = 0;
          v67 = v127[0];
          do
          {
            v136 = 0;
            if (CGPDFArrayGetObject(v64, v66, &v136))
              TaggedParser::BuildStructureElement(this, (uint64_t *)v60, (unint64_t)v136, v67, (float *)&info);
            ++v66;
          }
          while (v65 != v66);
        }
      }
    }
LABEL_73:
    v69 = *(char **)(v60 + 112);
    v68 = *(char **)(v60 + 120);
    if (v68 - v69 != 8 || *(_QWORD *)(v60 + 80) != -1)
    {
      *(_DWORD *)(v60 + 32) = 100;
LABEL_76:
      std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table((uint64_t)&info);
      goto LABEL_77;
    }
    if (v69 == v68)
      goto LABEL_159;
    v107 = *(_QWORD *)v69;
    if (!*(_QWORD *)v69)
    {
      NumberOfPages = CGPDFDocumentGetNumberOfPages(*(CGPDFDocumentRef *)(*(_QWORD *)this + 16));
      if (!NumberOfPages)
      {
LABEL_160:
        v112 = "pageIndex < pageCount";
        v116 = 1337;
LABEL_154:
        __assert_rtn("CreateStructureRoot", "TaggedParser.mm", v116, v112);
      }
      v109 = 0;
      v110 = *(_QWORD *)(*(_QWORD *)this + 200);
      v111 = (_QWORD *)(v110 + 8);
      v112 = "_private->objectsToSearch[pageIndex].size() == 0";
      while (1)
      {
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 208) - v110) >> 3) == v109)
          goto LABEL_159;
        v113 = (_QWORD *)*(v111 - 1);
        v114 = (_QWORD *)*v111;
        v115 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v111 - (_QWORD)v113) >> 3);
        if (v115 == 1)
          break;
        if (v115)
        {
          v116 = 1334;
          goto LABEL_154;
        }
        ++v109;
        v111 += 3;
        if (NumberOfPages == v109)
        {
          v116 = 1337;
          v112 = "pageIndex < pageCount";
          goto LABEL_154;
        }
      }
      v141 = 0;
      v142 = 0;
      v140 = 0;
      if (v113 == v114)
        goto LABEL_159;
      v136 = (CGPDFObjectRef)&v142;
      v137 = COERCE_DOUBLE(&v141);
      v138 = &v140;
      std::__memberwise_copy_assign[abi:se180100]<std::tuple<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *> &>,std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0ul,1ul,2ul>((uint64_t)&v136, v113);
      if (v142 == (CGPDFDictionary *)v60)
      {
        v117 = *(_QWORD *)(*(_QWORD *)this + 200);
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 208) - v117) >> 3) <= v109)
          goto LABEL_159;
        v118 = 24 * v109;
        v119 = v117 + 24 * v109;
        v122 = *(_QWORD *)(v119 + 8);
        v120 = (_QWORD *)(v119 + 8);
        v121 = v122;
        v123 = *(_QWORD *)(v117 + v118);
        while (v121 != v123)
        {
          v121 -= 24;
          std::__destroy_at[abi:se180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(v121);
        }
        *v120 = v123;
        TaggedParser::BuildStructureElementFromDictionary(this, (uint64_t)v142, (CGPDFDictionary *)v140, v127[0], (float *)&info, v141);
        v69 = *(char **)(v60 + 112);
        v68 = *(char **)(v60 + 120);
        if (v69 == v68)
          goto LABEL_159;
        v107 = *(_QWORD *)v69;
        if (*(_QWORD *)v69)
        {
          if (v140)
          {
            CFRelease(v140);
            v69 = *(char **)(v60 + 112);
            v68 = *(char **)(v60 + 120);
          }
          goto LABEL_150;
        }
        v124 = "newRoot != nullptr";
        v125 = 1352;
      }
      else
      {
        v124 = "root == rootNode";
        v125 = 1344;
      }
      __assert_rtn("CreateStructureRoot", "TaggedParser.mm", v125, v124);
    }
LABEL_150:
    if (v69 == v68)
      goto LABEL_159;
    *(_QWORD *)(v60 + 120) = v68 - 8;
    *(_QWORD *)(v107 + 104) = 0;
    StructureElement::~StructureElement((StructureElement *)v60);
    MEMORY[0x186DC23C4]();
    v60 = v107;
    goto LABEL_76;
  }
}

void sub_184C80B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table((uint64_t)&a15);
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

void std::__memberwise_copy_assign[abi:se180100]<std::tuple<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *> &>,std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0ul,1ul,2ul>(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  const void **v3;
  const void *v4;
  const void *v5;

  v2 = a2[1];
  **(_QWORD **)a1 = *a2;
  v3 = *(const void ***)(a1 + 16);
  **(_QWORD **)(a1 + 8) = v2;
  v4 = *v3;
  v5 = (const void *)a2[2];
  *v3 = v5;
  if (v5)
    CFRetain(v5);
  if (v4)
    CFRelease(v4);
}

uint64_t TaggedParser::BuildStructureElementFromDictionary(TaggedParser *a1, uint64_t a2, CGPDFDictionary *a3, unint64_t a4, float *a5, unsigned int a6)
{
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  void **v14;
  __int128 v15;
  uint64_t v16;
  CGPDFString *v17;
  CGPDFStringRef i;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  char v22;
  _QWORD *v23;
  CGPDFStringRef v24;
  CGPDFStringRef *v25;
  CGPDFStringRef *v26;
  uint64_t v27;
  uint64_t *v28;
  std::string *v29;
  uint64_t v30;
  int v31;
  CGPDFStringRef v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  uint64_t v44;
  char *v45;
  uint64_t *v46;
  char *v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unsigned int v56;
  BOOL v57;
  char v58;
  uint64_t **v59;
  char v60;
  char *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t result;
  unint64_t v65;
  std::string v67;
  char *__s;
  CGPDFInteger value;
  CGPDFStringRef v70[2];
  uint64_t v71;
  uint64_t v72;

  v11 = operator new();
  v12 = v11;
  do
    v13 = __ldaxr(&gStructureElementCount);
  while (__stlxr(v13 + 1, &gStructureElementCount));
  *(_QWORD *)v11 = v13;
  *(_QWORD *)(v11 + 8) = 0;
  v14 = (void **)(v11 + 8);
  *(_QWORD *)(v11 + 40) = 0;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_DWORD *)(v11 + 32) = 0;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_BYTE *)(v11 + 64) = 0;
  *(_OWORD *)(v11 + 88) = 0u;
  *(_QWORD *)(v11 + 72) = -1;
  *(_QWORD *)(v11 + 80) = -1;
  *(_OWORD *)(v11 + 104) = 0u;
  *(_OWORD *)(v11 + 120) = 0u;
  *(_OWORD *)(v11 + 136) = 0u;
  *(_OWORD *)(v11 + 152) = 0u;
  *(_OWORD *)(v11 + 168) = 0u;
  *(_OWORD *)(v11 + 184) = 0u;
  *(_OWORD *)(v11 + 200) = 0u;
  *(_QWORD *)(v11 + 216) = 0;
  *(int64x2_t *)(v11 + 224) = vdupq_n_s64(0x7FF0000000000000uLL);
  *(_OWORD *)(v11 + 240) = 0u;
  *(_BYTE *)(v11 + 256) = 0;
  *(CGRect *)(v11 + 264) = CGRectNull;
  *(_QWORD *)(v11 + 104) = a2;
  std::string::operator=((std::string *)(v11 + 8), (const std::string *)(a2 + 8));
  v15 = 0uLL;
  *(_DWORD *)(v12 + 32) = *(_DWORD *)(a2 + 32);
  if (a3)
    v15 = *((_OWORD *)a3 + 2);
  *(_OWORD *)(v12 + 88) = v15;
  value = 0;
  if (CGPDFDictionaryGetInteger(a3, "MCID", &value))
  {
    v16 = *(_QWORD *)(*(_QWORD *)a1 + 128);
    if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 136) - v16) >> 3) <= a4 - 1)
      goto LABEL_110;
    v17 = (CGPDFString *)(value | (a4 << 32));
    v70[0] = v17;
    std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v16 + 24 * (a4 - 1)), (uint64_t)v17, (uint64_t **)v70)[5] = (uint64_t *)v12;
    *(_QWORD *)(v12 + 80) = v17;
  }
  __s = 0;
  if (CGPDFDictionaryGetName(a3, "S", (const char **)&__s))
  {
    std::string::basic_string[abi:se180100]<0>((char **)v70, __s);
    if (*(char *)(v12 + 31) < 0)
      operator delete(*v14);
    *(_OWORD *)v14 = *(_OWORD *)v70;
    *(_QWORD *)(v12 + 24) = v71;
    if (*(char *)(v12 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v67, *(const std::string::value_type **)(v12 + 8), *(_QWORD *)(v12 + 16));
    }
    else
    {
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)v14;
      v67.__r_.__value_.__r.__words[2] = *(_QWORD *)(v12 + 24);
    }
    v65 = a4;
    if (TaggedParser::MapNodeNameToNodeType(std::string)::onceToken != -1)
      dispatch_once(&TaggedParser::MapNodeNameToNodeType(std::string)::onceToken, &__block_literal_global_10404);
    v70[1] = 0;
    v71 = 0;
    v70[0] = (CGPDFStringRef)&v70[1];
    while (1)
    {
      v19 = TaggedParser::MapNodeNameToNodeType(std::string)::roleNames + 8;
      v20 = *(_QWORD **)(TaggedParser::MapNodeNameToNodeType(std::string)::roleNames + 8);
      if (!v20)
        goto LABEL_31;
      v21 = TaggedParser::MapNodeNameToNodeType(std::string)::roleNames + 8;
      do
      {
        v22 = std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)(v20 + 4), &v67);
        if (v22 >= 0)
          v23 = v20;
        else
          v23 = v20 + 1;
        if (v22 >= 0)
          v21 = (uint64_t)v20;
        v20 = (_QWORD *)*v23;
      }
      while (*v23);
      if (v21 == v19
        || (std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)&v67, (_QWORD *)(v21 + 32)) & 0x80) != 0)
      {
LABEL_31:
        v21 = v19;
      }
      if (TaggedParser::MapNodeNameToNodeType(std::string)::roleNames + 8 != v21)
        break;
      if (!std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>(*(_QWORD **)(*(_QWORD *)a1 + 160), &v67))
      {
LABEL_52:
        v31 = 0;
        goto LABEL_53;
      }
      v24 = v70[1];
      v25 = &v70[1];
      v26 = &v70[1];
      if (!v70[1])
        goto LABEL_43;
      v25 = &v70[1];
      while (1)
      {
        while (1)
        {
          v26 = (CGPDFStringRef *)v24;
          v27 = (uint64_t)v24 + 32;
          if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)&v67, (_QWORD *)v24 + 4) & 0x80) == 0)break;
          v24 = *v26;
          v25 = v26;
          if (!*v26)
            goto LABEL_43;
        }
        if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>(v27, &v67) & 0x80) == 0)
          break;
        v25 = v26 + 1;
        v24 = v26[1];
        if (!v24)
          goto LABEL_43;
      }
      if (!*v25)
      {
LABEL_43:
        v28 = (uint64_t *)operator new(0x38uLL);
        v29 = (std::string *)(v28 + 4);
        if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(v29, v67.__r_.__value_.__l.__data_, v67.__r_.__value_.__l.__size_);
        }
        else
        {
          *(_OWORD *)&v29->__r_.__value_.__l.__data_ = *(_OWORD *)&v67.__r_.__value_.__l.__data_;
          v28[6] = v67.__r_.__value_.__r.__words[2];
        }
        *v28 = 0;
        v28[1] = 0;
        v28[2] = (uint64_t)v26;
        *v25 = (CGPDFStringRef)v28;
        if (*(_QWORD *)v70[0])
        {
          v70[0] = *(CGPDFStringRef *)v70[0];
          v28 = (uint64_t *)*v25;
        }
        std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>((uint64_t *)v70[1], v28);
        ++v71;
      }
      v30 = *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(*(_QWORD *)a1 + 152, &v72, &v67);
      if (!v30)
        std::__throw_out_of_range[abi:se180100]("map::at:  key not found");
      std::string::operator=(&v67, (const std::string *)(v30 + 56));
      for (i = v70[1]; i; i = *(CGPDFStringRef *)i)
      {
        if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)&v67, (_QWORD *)i + 4) & 0x80) == 0)
        {
          if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)i + 32, &v67) & 0x80) == 0)
            goto LABEL_52;
          i = (CGPDFStringRef)((char *)i + 8);
        }
      }
    }
    v31 = *(_DWORD *)(v21 + 56);
LABEL_53:
    std::__tree<std::__value_type<std::string,CGDisplayListEntryType>,std::__map_value_compare<std::string,std::__value_type<std::string,CGDisplayListEntryType>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CGDisplayListEntryType>>>::destroy((char *)v70[1]);
    *(_DWORD *)(v12 + 32) = v31;
    a4 = v65;
    if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v67.__r_.__value_.__l.__data_);
  }
  v70[0] = 0;
  if (CGPDFDictionaryGetString(a3, "ID", v70))
  {
    v32 = v70[0];
    if (!v70[0])
      goto LABEL_110;
    if (*((_QWORD *)v70[0] + 3))
      decrypt_string((uint64_t)v70[0]);
    std::string::__assign_external((std::string *)(v12 + 40), (const std::string::value_type *)v32 + 80);
  }
  TaggedParser::LoadTextProperty(v12, a3, CFSTR("Alt"));
  TaggedParser::LoadTextProperty(v12, a3, CFSTR("ActualText"));
  TaggedParser::LoadTextProperty(v12, a3, CFSTR("T"));
  TaggedParser::LoadTextProperty(v12, a3, CFSTR("Lang"));
  if ((a6 & 0x80000000) == 0)
  {
    v33 = *(_QWORD *)(a2 + 112);
    if (a6 < (unint64_t)((*(_QWORD *)(a2 + 120) - v33) >> 3))
    {
      v34 = a4;
      *(_QWORD *)(v33 + 8 * a6) = v12;
      goto LABEL_80;
    }
    goto LABEL_110;
  }
  v36 = *(uint64_t **)(a2 + 120);
  v35 = *(_QWORD *)(a2 + 128);
  if ((unint64_t)v36 >= v35)
  {
    v38 = *(_QWORD *)(a2 + 112);
    v39 = ((uint64_t)v36 - v38) >> 3;
    if ((unint64_t)(v39 + 1) >> 61)
      goto LABEL_111;
    v40 = v35 - v38;
    v41 = v40 >> 2;
    if (v40 >> 2 <= (unint64_t)(v39 + 1))
      v41 = v39 + 1;
    if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8)
      v42 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v42 = v41;
    if (v42)
    {
      v43 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v42);
      if (v43)
      {
        v45 = &v43[8 * v44];
        v46 = (uint64_t *)&v43[8 * v39];
        *v46 = v12;
        v37 = v46 + 1;
        v48 = *(char **)(a2 + 112);
        v47 = *(char **)(a2 + 120);
        if (v47 != v48)
        {
          do
          {
            v49 = *((_QWORD *)v47 - 1);
            v47 -= 8;
            *--v46 = v49;
          }
          while (v47 != v48);
          v47 = *(char **)(a2 + 112);
        }
        *(_QWORD *)(a2 + 112) = v46;
        *(_QWORD *)(a2 + 120) = v37;
        *(_QWORD *)(a2 + 128) = v45;
        if (v47)
          operator delete(v47);
        goto LABEL_79;
      }
    }
LABEL_110:
    __break(1u);
LABEL_111:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  if (!v36)
    goto LABEL_110;
  *v36 = v12;
  v37 = v36 + 1;
LABEL_79:
  v34 = a4;
  *(_QWORD *)(a2 + 120) = v37;
LABEL_80:
  v50 = *(_QWORD *)a1;
  v51 = *(_QWORD *)(v12 + 88);
  v52 = *(unsigned __int16 *)(v12 + 96);
  v54 = *(_QWORD *)a1 + 184;
  v53 = *(_QWORD *)v54;
  if (*(_QWORD *)v54)
  {
    while (1)
    {
      while (1)
      {
        v54 = v53;
        v55 = *(_QWORD *)(v53 + 32);
        if (v51 == v55)
          break;
        if (v51 >= v55)
        {
          if (v55 >= v51)
            v60 = 1;
          else
            v60 = -1;
          if ((v60 & 0x80) == 0)
            goto LABEL_104;
          goto LABEL_97;
        }
LABEL_91:
        v53 = *(_QWORD *)v54;
        v59 = (uint64_t **)v54;
        if (!*(_QWORD *)v54)
          goto LABEL_100;
      }
      v56 = *(unsigned __int16 *)(v54 + 40);
      if (v52 < v56)
        goto LABEL_91;
      v57 = v56 == v52;
      if (v56 >= v52)
        v58 = 1;
      else
        v58 = -1;
      if (v57)
        v58 = 0;
      if ((v58 & 0x80) == 0)
        goto LABEL_104;
LABEL_97:
      v59 = (uint64_t **)(v54 + 8);
      v53 = *(_QWORD *)(v54 + 8);
      if (!v53)
        goto LABEL_100;
    }
  }
  v59 = (uint64_t **)(*(_QWORD *)a1 + 184);
LABEL_100:
  v61 = (char *)operator new(0x38uLL);
  *((_QWORD *)v61 + 4) = v51;
  *((_WORD *)v61 + 20) = v52;
  *(_DWORD *)(v61 + 42) = *(_DWORD *)(v12 + 98);
  *((_WORD *)v61 + 23) = *(_WORD *)(v12 + 102);
  *((_QWORD *)v61 + 6) = v12;
  *(_QWORD *)v61 = 0;
  *((_QWORD *)v61 + 1) = 0;
  *((_QWORD *)v61 + 2) = v54;
  *v59 = (uint64_t *)v61;
  v62 = **(_QWORD **)(v50 + 176);
  if (v62)
  {
    *(_QWORD *)(v50 + 176) = v62;
    v63 = *v59;
  }
  else
  {
    v63 = (uint64_t *)v61;
  }
  std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v50 + 184), v63);
  ++*(_QWORD *)(v50 + 192);
LABEL_104:
  v70[0] = 0;
  if (!CGPDFDictionaryGetObject(a3, "K", v70))
    return 1;
  result = TaggedParser::BuildStructureElement(a1, (uint64_t *)v12, (unint64_t)v70[0], v34, a5);
  if ((_DWORD)result)
    return 1;
  return result;
}

void sub_184C812C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char *a23)
{
  void *v23;

  operator delete(v23);
  std::__tree<std::__value_type<std::string,CGDisplayListEntryType>,std::__map_value_compare<std::string,std::__value_type<std::string,CGDisplayListEntryType>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CGDisplayListEntryType>>>::destroy(a23);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

const void **applesauce::CF::ObjectRef<CGPDFDictionary *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void TaggedParser::addWords(CGPDFPage *)::$_0::operator()(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4)
{
  _QWORD *v4;
  int64_t v8;
  uint64_t v9;
  int64_t v10;
  BOOL v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t *v28;
  uint64_t v29;
  int64x2_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  _QWORD *v41;

  v4 = *(_QWORD **)(*(_QWORD *)a1 + 8);
  if (v4)
  {
    v8 = a2 | ((unint64_t)*(_QWORD *)(a1 + 8) << 32);
    v9 = *(_QWORD *)a1 + 8;
    do
    {
      v10 = v4[4];
      v11 = v10 < v8;
      if (v10 >= v8)
        v12 = v4;
      else
        v12 = v4 + 1;
      if (!v11)
        v9 = (uint64_t)v4;
      v4 = (_QWORD *)*v12;
    }
    while (*v12);
    if (v9 != *(_QWORD *)a1 + 8 && v8 >= *(_QWORD *)(v9 + 32))
    {
      v13 = *(_QWORD **)(v9 + 40);
      v14 = CGPDFTaggedNodeCreate(*(_QWORD *)(a1 + 24));
      v15 = v14;
      v16 = (uint64_t *)v13[26];
      v17 = v13[27];
      if ((unint64_t)v16 >= v17)
      {
        v18 = v13[25];
        v19 = ((uint64_t)v16 - v18) >> 3;
        if ((unint64_t)(v19 + 1) >> 61)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v20 = v17 - v18;
        v21 = v20 >> 2;
        if (v20 >> 2 <= (unint64_t)(v19 + 1))
          v21 = v19 + 1;
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
          v22 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v22 = v21;
        v41 = v13 + 27;
        if (v22)
        {
          v23 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v22);
          if (v23)
          {
            v16 = (uint64_t *)&v23[8 * v19];
            *v16 = v15;
            v25 = v16 + 1;
            v27 = (_QWORD *)v13[25];
            v26 = (_QWORD *)v13[26];
            if (v26 == v27)
            {
              v30 = vdupq_n_s64((unint64_t)v26);
              v28 = v16;
            }
            else
            {
              v28 = v16;
              do
              {
                v29 = *--v26;
                *--v28 = v29;
                *v26 = 0;
              }
              while (v26 != v27);
              v30 = *(int64x2_t *)(v13 + 25);
            }
            v13[25] = v28;
            v13[26] = v25;
            v39 = v30;
            v31 = v13[27];
            v13[27] = &v23[8 * v24];
            v40 = v31;
            v38 = v30.i64[0];
            std::__split_buffer<applesauce::CF::ObjectRef<CGPDFTaggedNode *>>::~__split_buffer((uint64_t)&v38);
            v13[26] = v25;
            v15 = *v16;
            if (!*v16)
              goto LABEL_30;
LABEL_29:
            *(_BYTE *)(v15 + 112) = 0;
LABEL_30:
            CGPDFTaggedNodeSetType((CFStringRef)v15, 1);
            v32 = *v16;
            if (*v16)
            {
              *(_QWORD *)(v32 + 160) = *(_QWORD *)(a1 + 8);
              PageLayout::GetBoundsForRangeWithinLine(*(_QWORD **)(a1 + 16), a3, a4, 0, 0);
              *(_BYTE *)(v32 + 48) = 1;
              *(_QWORD *)(v32 + 56) = v33;
              *(_QWORD *)(v32 + 64) = v34;
              *(_QWORD *)(v32 + 72) = v35;
              *(_QWORD *)(v32 + 80) = v36;
            }
            else
            {
              PageLayout::GetBoundsForRangeWithinLine(*(_QWORD **)(a1 + 16), a3, a4, 0, 0);
            }
            v37 = *v16;
            if (*v16)
            {
              *(_BYTE *)(v37 + 168) = 1;
              *(_QWORD *)(v37 + 176) = a3;
              *(_QWORD *)(v37 + 184) = a4;
              *(_BYTE *)(v37 + 192) = 0;
            }
            return;
          }
        }
      }
      else if (v16)
      {
        *v16 = v14;
        v13[26] = v16 + 1;
        if (!v14)
          goto LABEL_30;
        goto LABEL_29;
      }
      __break(1u);
    }
  }
}

void sub_184C8153C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  applesauce::CF::ObjectRef<CGPDFTaggedNode *>::~ObjectRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<applesauce::CF::ObjectRef<CGPDFTaggedNode *>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:se180100]<applesauce::CF::ObjectRef<CGPDFTaggedNode *>,0>((const void **)(i - 8));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

const void **applesauce::CF::ObjectRef<CGPDFTaggedNode *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TaggedParser::BuildStructureElement(TaggedParser *a1, uint64_t *a2, unint64_t a3, unint64_t a4, float *a5)
{
  unint64_t v5;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *i;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *j;
  unint64_t v22;
  _QWORD *v23;
  float v24;
  float v25;
  _BOOL8 v26;
  unint64_t v27;
  unint64_t v28;
  int8x8_t prime;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  uint8x8_t v35;
  unint64_t v36;
  uint8x8_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  CGPDFObject *v46;
  uint64_t result;
  uint64_t v48;
  const char *v49;
  CGPDFArray *v50;
  size_t v51;
  size_t v52;
  CGPDFDictionary *v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  _QWORD *v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  size_t v61;
  int v62;
  int v63;
  _BOOL4 v64;
  _BOOL4 v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  CGPDFDictionary *v79;
  size_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  CFTypeRef cf;
  unint64_t v88;
  CGPDFObjectRef value;
  unint64_t v90;
  uint64_t *v91;

  v90 = a4;
  v91 = a2;
  v11 = 0x9DDFEA08EB382D69 * (((8 * a3) + 8) ^ HIDWORD(a3));
  v12 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v11 >> 47) ^ v11);
  v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
  v14 = *((_QWORD *)a5 + 1);
  if (v14)
  {
    v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    if (v15.u32[0] > 1uLL)
    {
      v16 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      if (v13 >= v14)
        v16 = v13 % v14;
    }
    else
    {
      v16 = v13 & (v14 - 1);
    }
    v17 = *(_QWORD **)(*(_QWORD *)a5 + 8 * v16);
    if (v17)
    {
      for (i = (_QWORD *)*v17; i; i = (_QWORD *)*i)
      {
        v19 = i[1];
        if (v19 == v13)
        {
          if (i[2] == a3)
          {
            v54 = *(_QWORD *)a1;
            if (*(_BYTE *)(*(_QWORD *)a1 + 96))
            {
              printf("Hit tagged parsing error: \"%s\"\n", "Cycles detected in marked structure element graph");
              v54 = *(_QWORD *)a1;
            }
            result = 0;
            *(_BYTE *)(v54 + 97) = 1;
            return result;
          }
        }
        else
        {
          if (v15.u32[0] > 1uLL)
          {
            if (v19 >= v14)
              v19 %= v14;
          }
          else
          {
            v19 &= v14 - 1;
          }
          if (v19 != v16)
            break;
        }
      }
    }
    if (v15.u32[0] > 1uLL)
    {
      v5 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      if (v13 >= v14)
        v5 = v13 % v14;
    }
    else
    {
      v5 = v13 & (v14 - 1);
    }
    v20 = *(_QWORD **)(*(_QWORD *)a5 + 8 * v5);
    if (v20)
    {
      for (j = (_QWORD *)*v20; j; j = (_QWORD *)*j)
      {
        v22 = j[1];
        if (v22 == v13)
        {
          if (j[2] == a3)
            goto LABEL_89;
        }
        else
        {
          if (v15.u32[0] > 1uLL)
          {
            if (v22 >= v14)
              v22 %= v14;
          }
          else
          {
            v22 &= v14 - 1;
          }
          if (v22 != v5)
            break;
        }
      }
    }
  }
  v23 = operator new(0x18uLL);
  *v23 = 0;
  v23[1] = v13;
  v23[2] = a3;
  v24 = (float)(unint64_t)(*((_QWORD *)a5 + 3) + 1);
  v25 = a5[8];
  if (!v14 || (float)(v25 * (float)v14) < v24)
  {
    v26 = 1;
    if (v14 >= 3)
      v26 = (v14 & (v14 - 1)) != 0;
    v27 = v26 | (2 * v14);
    v28 = vcvtps_u32_f32(v24 / v25);
    if (v27 <= v28)
      prime = (int8x8_t)v28;
    else
      prime = (int8x8_t)v27;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v14 = *((_QWORD *)a5 + 1);
    }
    if (*(_QWORD *)&prime > v14)
      goto LABEL_45;
    if (*(_QWORD *)&prime < v14)
    {
      v36 = vcvtps_u32_f32((float)*((unint64_t *)a5 + 3) / a5[8]);
      if (v14 < 3 || (v37 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        v36 = std::__next_prime(v36);
      }
      else
      {
        v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2)
          v36 = v38;
      }
      if (*(_QWORD *)&prime <= v36)
        prime = (int8x8_t)v36;
      if (*(_QWORD *)&prime >= v14)
      {
        v14 = *((_QWORD *)a5 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_45:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:se180100]();
          v30 = operator new(8 * *(_QWORD *)&prime);
          v31 = *(_QWORD **)a5;
          *(_QWORD *)a5 = v30;
          if (v31)
            operator delete(v31);
          v32 = 0;
          *((int8x8_t *)a5 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a5 + 8 * v32++) = 0;
          while (*(_QWORD *)&prime != v32);
          v33 = (_QWORD *)*((_QWORD *)a5 + 2);
          if (v33)
          {
            v34 = v33[1];
            v35 = (uint8x8_t)vcnt_s8(prime);
            v35.i16[0] = vaddlv_u8(v35);
            if (v35.u32[0] > 1uLL)
            {
              if (v34 >= *(_QWORD *)&prime)
                v34 %= *(_QWORD *)&prime;
            }
            else
            {
              v34 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a5 + 8 * v34) = a5 + 4;
            v39 = (_QWORD *)*v33;
            if (*v33)
            {
              do
              {
                v40 = v39[1];
                if (v35.u32[0] > 1uLL)
                {
                  if (v40 >= *(_QWORD *)&prime)
                    v40 %= *(_QWORD *)&prime;
                }
                else
                {
                  v40 &= *(_QWORD *)&prime - 1;
                }
                if (v40 != v34)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a5 + 8 * v40))
                  {
                    *(_QWORD *)(*(_QWORD *)a5 + 8 * v40) = v33;
                    goto LABEL_70;
                  }
                  *v33 = *v39;
                  *v39 = **(_QWORD **)(*(_QWORD *)a5 + 8 * v40);
                  **(_QWORD **)(*(_QWORD *)a5 + 8 * v40) = v39;
                  v39 = v33;
                }
                v40 = v34;
LABEL_70:
                v33 = v39;
                v39 = (_QWORD *)*v39;
                v34 = v40;
              }
              while (v39);
            }
          }
          v14 = (unint64_t)prime;
          goto LABEL_74;
        }
        v55 = *(_QWORD **)a5;
        *(_QWORD *)a5 = 0;
        if (v55)
          operator delete(v55);
        v14 = 0;
        *((_QWORD *)a5 + 1) = 0;
      }
    }
LABEL_74:
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14)
        v5 = v13 % v14;
      else
        v5 = v13;
    }
    else
    {
      v5 = (v14 - 1) & v13;
    }
  }
  v41 = *(_QWORD **)a5;
  v42 = *(_QWORD **)(*(_QWORD *)a5 + 8 * v5);
  if (v42)
  {
    *v23 = *v42;
LABEL_87:
    *v42 = v23;
    goto LABEL_88;
  }
  *v23 = *((_QWORD *)a5 + 2);
  *((_QWORD *)a5 + 2) = v23;
  v41[v5] = a5 + 4;
  if (*v23)
  {
    v43 = *(_QWORD *)(*v23 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v43 >= v14)
        v43 %= v14;
    }
    else
    {
      v43 &= v14 - 1;
    }
    v42 = (_QWORD *)(*(_QWORD *)a5 + 8 * v43);
    goto LABEL_87;
  }
LABEL_88:
  ++*((_QWORD *)a5 + 3);
LABEL_89:
  if (a3)
  {
    v44 = a4 - 1;
    switch(*(_DWORD *)(a3 + 8))
    {
      case 3:
      case 0xC:
        v45 = *(_QWORD *)(*(_QWORD *)a1 + 128);
        if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 136) - v45) >> 3) <= v44)
          goto LABEL_178;
        v46 = (CGPDFObject *)(*(unsigned int *)(a3 + 32) | (a4 << 32));
        value = v46;
        std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v45 + 24 * v44), (uint64_t)v46, (uint64_t **)&value)[5] = a2;
        a2[10] = (uint64_t)v46;
        return 1;
      case 7:
        v50 = *(CGPDFArray **)(a3 + 32);
        if (!v50)
          return 1;
        v51 = *((_QWORD *)v50 + 2);
        if (!v51)
          return 1;
        v52 = v51 - 1;
        if (v51 == 1)
        {
          value = 0;
          if (!CGPDFArrayGetObject(v50, 0, &value))
            return 1;
          result = TaggedParser::BuildStructureElement(a1, a2);
          if ((_DWORD)result)
            return 1;
          return result;
        }
        v61 = 0;
        while (1)
        {
          value = 0;
          if (!CGPDFArrayGetObject(v50, v61, &value) || !value)
            break;
          v62 = *((_DWORD *)value + 2);
          if (v61)
            v63 = 8;
          else
            v63 = 3;
          v64 = v62 == v63;
          if (v62 == 12)
            v65 = v61 == 0;
          else
            v65 = v64;
          if (++v61 >= v51 || !v65)
            goto LABEL_157;
        }
        v65 = 0;
LABEL_157:
        v80 = 0;
        v86 = a4 << 32;
        while (1)
        {
          value = 0;
          if (CGPDFArrayGetObject(v50, v80, &value))
          {
            if (!value)
              goto LABEL_175;
            v81 = *((_DWORD *)value + 2);
            if (v81 != 12)
            {
              if (v81 == 8)
              {
                if ((TaggedParser::BuildStructureElement(a1, a2) & 1) == 0)
                  return 0;
                goto LABEL_169;
              }
              if (v81 != 3)
              {
LABEL_175:
                v48 = *(_QWORD *)a1;
                if (!*(_BYTE *)(*(_QWORD *)a1 + 96))
                  goto LABEL_97;
                v49 = "Found a non-integer and non-dictionary object in /K array";
                goto LABEL_96;
              }
            }
            v82 = *((_QWORD *)value + 4);
            if (v65)
            {
              v83 = *(_QWORD *)(*(_QWORD *)a1 + 128);
              if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 136) - v83) >> 3) <= v44)
                goto LABEL_178;
              v88 = *((_QWORD *)value + 4) | v86;
              v84 = v88;
              std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v83 + 24 * v44), v82 | v86, (uint64_t **)&v88)[5] = a2;
              a2[10] = v84;
            }
            else
            {
              TaggedParser::CreateStructureElement((uint64_t)a1, (uint64_t)a2, a4, v82);
            }
          }
LABEL_169:
          if (*(_BYTE *)(*(_QWORD *)a1 + 97))
            v85 = 1;
          else
            v85 = v52 == v80;
          ++v80;
          result = 1;
          if (v85)
            return result;
        }
      case 8:
        v53 = *(CGPDFDictionary **)(a3 + 32);
        value = 0;
        if (CGPDFDictionaryGetName(v53, "Type", (const char **)&value) && !strcmp((const char *)value, "OBJR"))
        {
          v88 = a4;
          TaggedParser::ValidatePageNumber(a1, v53, &v88);
          cf = 0;
          if (CGPDFDictionaryGetDictionary(v53, "Obj", (CGPDFDictionaryRef *)&cf))
            TaggedParser::BuildObjectElement((char **)a2, (StructureElement *)v88, (CGPDFDictionaryRef)cf, v79);
          return 1;
        }
        if (TaggedParser::ValidatePageNumber(a1, v53, &v90))
          return (TaggedParser::BuildStructureElementFromDictionary(a1, a2, v53, v90, a5, 0xFFFFFFFFLL) & 1) != 0;
        v56 = a2[14];
        v57 = (_QWORD *)a2[15];
        v58 = ((uint64_t)v57 - v56) >> 3;
        v88 = v58;
        v59 = a2[16];
        if ((unint64_t)v57 >= v59)
        {
          if ((v58 + 1) >> 61)
            goto LABEL_179;
          v66 = v59 - v56;
          v67 = v66 >> 2;
          if (v66 >> 2 <= v58 + 1)
            v67 = v58 + 1;
          if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8)
            v68 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v68 = v67;
          if (v68)
          {
            v69 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v68);
            if (v69)
            {
              v71 = &v69[8 * v70];
              v72 = &v69[8 * v58];
              *(_QWORD *)v72 = 0;
              v60 = v72 + 8;
              v74 = (char *)a2[14];
              v73 = (char *)a2[15];
              if (v73 != v74)
              {
                do
                {
                  v75 = *((_QWORD *)v73 - 1);
                  v73 -= 8;
                  *((_QWORD *)v72 - 1) = v75;
                  v72 -= 8;
                }
                while (v73 != v74);
                v73 = (char *)a2[14];
              }
              a2[14] = (uint64_t)v72;
              a2[15] = (uint64_t)v60;
              a2[16] = (uint64_t)v71;
              if (v73)
                operator delete(v73);
LABEL_149:
              a2[15] = (uint64_t)v60;
              v76 = v90 - 1;
              v77 = *(_QWORD *)a1;
              v78 = *(_QWORD *)(*(_QWORD *)a1 + 200);
              if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v77 + 208) - v78) >> 3) > v90 - 1)
              {
                if (v53)
                  CFRetain(v53);
                cf = v53;
                std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::emplace_back<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *>>((char **)(v78 + 24 * v76), &v91, (uint64_t *)&v88, &cf);
                if (cf)
                  CFRelease(cf);
                return 1;
              }
            }
          }
        }
        else if (v57)
        {
          *v57 = 0;
          v60 = v57 + 1;
          goto LABEL_149;
        }
LABEL_178:
        __break(1u);
LABEL_179:
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      default:
        break;
    }
  }
  v48 = *(_QWORD *)a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 96))
  {
    v49 = "Malformed marked content structure";
LABEL_96:
    printf("Hit tagged parsing error: \"%s\"\n", v49);
    v48 = *(_QWORD *)a1;
  }
LABEL_97:
  result = 1;
  *(_BYTE *)(v48 + 97) = 1;
  return result;
}

void sub_184C81EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  applesauce::CF::ObjectRef<CGPDFDictionary *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void TaggedParser::CreateStructureElement(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t *v28;

  v8 = operator new();
  v9 = v8;
  do
    v10 = __ldaxr(&gStructureElementCount);
  while (__stlxr(v10 + 1, &gStructureElementCount));
  *(_QWORD *)v8 = v10;
  *(_QWORD *)(v8 + 16) = 0;
  *(_QWORD *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 32) = 0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 56) = 0;
  *(_QWORD *)(v8 + 40) = 0;
  *(_BYTE *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 72) = -1;
  *(_QWORD *)(v8 + 80) = -1;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_OWORD *)(v8 + 200) = 0u;
  *(_QWORD *)(v8 + 216) = 0;
  *(int64x2_t *)(v8 + 224) = vdupq_n_s64(0x7FF0000000000000uLL);
  *(_QWORD *)(v8 + 240) = 0;
  *(_QWORD *)(v8 + 248) = 0;
  *(_BYTE *)(v8 + 256) = 0;
  *(CGRect *)(v8 + 264) = CGRectNull;
  *(_QWORD *)(v8 + 104) = a2;
  std::string::operator=((std::string *)(v8 + 8), (const std::string *)(a2 + 8));
  *(_DWORD *)(v9 + 32) = *(_DWORD *)(a2 + 32);
  v11 = *(_QWORD *)(*(_QWORD *)a1 + 128);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)a1 + 136) - v11) >> 3) <= a3 - 1)
    goto LABEL_21;
  v12 = (uint64_t *)(a4 | ((unint64_t)a3 << 32));
  v28 = v12;
  std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v11 + 24 * (a3 - 1)), (uint64_t)v12, &v28)[5] = (uint64_t *)v9;
  *(_QWORD *)(v9 + 80) = v12;
  v14 = *(uint64_t **)(a2 + 120);
  v13 = *(_QWORD *)(a2 + 128);
  if ((unint64_t)v14 < v13)
  {
    if (v14)
    {
      *v14 = v9;
      v15 = v14 + 1;
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  v16 = *(_QWORD *)(a2 + 112);
  v17 = ((uint64_t)v14 - v16) >> 3;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_22;
  v18 = v13 - v16;
  v19 = v18 >> 2;
  if (v18 >> 2 <= (unint64_t)(v17 + 1))
    v19 = v17 + 1;
  v20 = (unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v19;
  if (!v20
    || (v21 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v20)) == 0)
  {
LABEL_21:
    __break(1u);
LABEL_22:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v23 = &v21[8 * v22];
  v24 = (uint64_t *)&v21[8 * v17];
  *v24 = v9;
  v15 = v24 + 1;
  v26 = *(char **)(a2 + 112);
  v25 = *(char **)(a2 + 120);
  if (v25 != v26)
  {
    do
    {
      v27 = *((_QWORD *)v25 - 1);
      v25 -= 8;
      *--v24 = v27;
    }
    while (v25 != v26);
    v25 = *(char **)(a2 + 112);
  }
  *(_QWORD *)(a2 + 112) = v24;
  *(_QWORD *)(a2 + 120) = v15;
  *(_QWORD *)(a2 + 128) = v23;
  if (v25)
    operator delete(v25);
LABEL_20:
  *(_QWORD *)(a2 + 120) = v15;
}

BOOL TaggedParser::ValidatePageNumber(TaggedParser *this, CGPDFDictionary *a2, unint64_t *a3)
{
  void *UnresolvedObject;
  unint64_t PageNumberForPageReference;
  int v7;
  int v8;

  UnresolvedObject = CGPDFDictionaryGetUnresolvedObject((uint64_t)a2, "Pg");
  if (!UnresolvedObject)
    return 1;
  if (*((_DWORD *)UnresolvedObject + 2) != 10)
    return 1;
  PageNumberForPageReference = CGPDFDocumentGetPageNumberForPageReference(*(_QWORD *)(*(_QWORD *)this + 16), *((_QWORD *)UnresolvedObject + 2), *((_QWORD *)UnresolvedObject + 3));
  if (PageNumberForPageReference == -1)
    return 1;
  v7 = *(_DWORD *)a3;
  *a3 = PageNumberForPageReference;
  v8 = v7 - PageNumberForPageReference;
  if (v8 < 0)
    v8 = -v8;
  return v8 < 2;
}

void TaggedParser::BuildObjectElement(char **this, StructureElement *a2, CGPDFDictionaryRef dict, CGPDFDictionary *a4)
{
  __CFString *v7;
  CGPDFAnnotation *v8;
  __CFString *v9;
  CFMutableStringRef v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFAllocator *v13;
  CFMutableStringRef MutableCopy;
  CFURLRef v15;
  CFURLRef v16;
  __CFDictionary *Mutable;
  CFDictionaryRef DictionaryRepresentation;
  CGPDFStringRef string;
  char *v20;
  CGPDFDictionaryRef dicta;
  char *__s1;
  CGRect v23;
  char *value;

  if (this)
  {
    if (dict)
    {
      value = 0;
      if (CGPDFDictionaryGetName(dict, "Type", (const char **)&value))
      {
        if (value)
        {
          if (!strcmp(value, "Annot"))
          {
            memset(&v23, 0, sizeof(v23));
            if (CGPDFDictionaryGetRect(dict, "Rect", &v23.origin.x))
            {
              __s1 = 0;
              if (CGPDFDictionaryGetName(dict, "Subtype", (const char **)&__s1))
              {
                if (__s1)
                {
                  if (strcmp(__s1, "Link"))
                  {
                    v7 = (__CFString *)CGPDFAnnotationCreateWithCGPDFDictionary((uint64_t)dict);
                    if (!v7)
                      return;
                    v9 = v7;
                    TaggedParser::CreateStructureElement((TaggedParser *)this, a2, v7, v8);
                    v10 = v9;
                    goto LABEL_12;
                  }
                  dicta = 0;
                  if (CGPDFDictionaryGetDictionary(dict, "A", &dicta))
                  {
                    if (dicta)
                    {
                      v20 = 0;
                      if (CGPDFDictionaryGetName(dicta, "S", (const char **)&v20))
                      {
                        if (v20)
                        {
                          if (!strcmp(v20, "URI"))
                          {
                            string = 0;
                            if (CGPDFDictionaryGetString(dicta, "URI", &string))
                            {
                              if (string)
                              {
                                v11 = CGPDFStringCopyTextString(string);
                                if (v11)
                                {
                                  v12 = v11;
                                  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                                  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v11);
                                  CFRelease(v12);
                                  CFStringTrimWhitespace(MutableCopy);
                                  if (CFStringGetLength(MutableCopy) >= 1)
                                  {
                                    v15 = CFURLCreateWithString(v13, MutableCopy, 0);
                                    if (v15)
                                    {
                                      v16 = v15;
                                      Mutable = CFDictionaryCreateMutable(v13, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                                      DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v23);
                                      CFDictionarySetValue(Mutable, CFSTR("Rect"), DictionaryRepresentation);
                                      CFRelease(DictionaryRepresentation);
                                      CFDictionarySetValue(Mutable, CFSTR("URI"), v16);
                                      CFRelease(v16);
                                      std::vector<__CFDictionary const*>::push_back[abi:se180100](this + 22, (uint64_t)Mutable);
                                    }
                                  }
                                  v10 = MutableCopy;
LABEL_12:
                                  CFRelease(v10);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::emplace_back<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *>>(char **a1, _QWORD *a2, uint64_t *a3, _QWORD *a4)
{
  char *v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;

  v8 = a1[1];
  v9 = (unint64_t)a1[2];
  if ((unint64_t)v8 < v9)
  {
    if (v8)
    {
      v10 = *a3;
      *(_QWORD *)v8 = *a2;
      *((_QWORD *)v8 + 1) = v10;
      *((_QWORD *)v8 + 2) = *a4;
      *a4 = 0;
      v11 = v8 + 24;
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  v12 = 0xAAAAAAAAAAAAAAABLL * ((v8 - *a1) >> 3);
  v13 = v12 + 1;
  if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_22;
  v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (_QWORD)*a1) >> 3);
  if (2 * v14 > v13)
    v13 = 2 * v14;
  if (v14 >= 0x555555555555555)
    v15 = 0xAAAAAAAAAAAAAAALL;
  else
    v15 = v13;
  if (!v15
    || (v16 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v15)) == 0)
  {
LABEL_21:
    __break(1u);
LABEL_22:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v18 = &v16[24 * v17];
  v19 = &v16[24 * v12];
  v20 = *a3;
  *(_QWORD *)v19 = *a2;
  *((_QWORD *)v19 + 1) = v20;
  *((_QWORD *)v19 + 2) = *a4;
  *a4 = 0;
  v11 = v19 + 24;
  v21 = *a1;
  v22 = a1[1];
  if (v22 == *a1)
  {
    *a1 = v19;
    a1[1] = v11;
    a1[2] = v18;
  }
  else
  {
    do
    {
      v23 = *(_OWORD *)(v22 - 24);
      v22 -= 24;
      *(_OWORD *)(v19 - 24) = v23;
      v19 -= 24;
      *((_QWORD *)v19 + 2) = *((_QWORD *)v22 + 2);
      *((_QWORD *)v22 + 2) = 0;
    }
    while (v22 != v21);
    v22 = *a1;
    v24 = (uint64_t)a1[1];
    *a1 = v19;
    a1[1] = v11;
    a1[2] = v18;
    while ((char *)v24 != v22)
    {
      v24 -= 24;
      std::__destroy_at[abi:se180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(v24);
    }
  }
  if (v22)
    operator delete(v22);
LABEL_20:
  a1[1] = v11;
}

void std::vector<__CFDictionary const*>::push_back[abi:se180100](char **a1, uint64_t a2)
{
  unint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 < v4)
  {
    if (v5)
    {
      *(_QWORD *)v5 = a2;
      v6 = v5 + 8;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v7 = *a1;
  v8 = (v5 - *a1) >> 3;
  v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 61)
    goto LABEL_19;
  v10 = v4 - (_QWORD)v7;
  if (v10 >> 2 > v9)
    v9 = v10 >> 2;
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
    v11 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v11 = v9;
  if (!v11)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  if (v11 >> 61)
    std::__throw_bad_array_new_length[abi:se180100]();
  v12 = (char *)operator new(8 * v11);
  v13 = &v12[8 * v8];
  *(_QWORD *)v13 = a2;
  v6 = v13 + 8;
  if (v5 != v7)
  {
    do
    {
      v14 = *((_QWORD *)v5 - 1);
      v5 -= 8;
      *((_QWORD *)v13 - 1) = v14;
      v13 -= 8;
    }
    while (v5 != v7);
    v5 = v7;
  }
  *a1 = v13;
  a1[1] = v6;
  a1[2] = &v12[8 * v11];
  if (v5)
    operator delete(v5);
LABEL_17:
  a1[1] = v6;
}

void TaggedParser::CreateStructureElement(TaggedParser *this, StructureElement *a2, _QWORD *a3, CGPDFAnnotation *a4)
{
  int Type;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _OWORD *v12;
  char *v13;
  uint64_t v14;
  __int128 v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;

  Type = CGPDFAnnotationGetType((uint64_t)a3);
  if (Type != 8)
  {
    v8 = Type;
    v9 = operator new();
    v10 = v9;
    do
      v11 = __ldaxr(&gStructureElementCount);
    while (__stlxr(v11 + 1, &gStructureElementCount));
    *(_QWORD *)v9 = v11;
    *(_QWORD *)(v9 + 8) = 0;
    v12 = (_OWORD *)(v9 + 8);
    *(_QWORD *)(v9 + 16) = 0;
    *(_QWORD *)(v9 + 24) = 0;
    *(_DWORD *)(v9 + 32) = 0;
    *(_QWORD *)(v9 + 48) = 0;
    *(_QWORD *)(v9 + 56) = 0;
    *(_QWORD *)(v9 + 40) = 0;
    *(_BYTE *)(v9 + 64) = 0;
    *(_QWORD *)(v9 + 72) = -1;
    *(_QWORD *)(v9 + 80) = -1;
    *(_OWORD *)(v9 + 88) = 0u;
    *(_OWORD *)(v9 + 104) = 0u;
    *(_OWORD *)(v9 + 120) = 0u;
    *(_OWORD *)(v9 + 136) = 0u;
    *(_OWORD *)(v9 + 152) = 0u;
    *(_OWORD *)(v9 + 168) = 0u;
    *(_OWORD *)(v9 + 184) = 0u;
    *(_OWORD *)(v9 + 200) = 0u;
    *(_QWORD *)(v9 + 216) = 0;
    *(int64x2_t *)(v9 + 224) = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_QWORD *)(v9 + 240) = 0;
    *(_QWORD *)(v9 + 248) = 0;
    *(_BYTE *)(v9 + 256) = 0;
    *(CGRect *)(v9 + 264) = CGRectNull;
    *(_QWORD *)(v9 + 104) = this;
    if (v8 == 25)
      v13 = "OBJR";
    else
      v13 = "Annot";
    std::string::basic_string[abi:se180100]<0>((char **)&v31, v13);
    *v12 = v31;
    *(_QWORD *)(v10 + 24) = v32;
    *(_DWORD *)(v10 + 32) = 800;
    *(_QWORD *)v10 = ((_QWORD)a2 << 32) | 0xFFFFFFFFLL;
    v14 = a3[2];
    if (v14)
      v15 = *(_OWORD *)(v14 + 32);
    else
      v15 = 0uLL;
    *(_OWORD *)(v10 + 88) = v15;
    *(_QWORD *)(v10 + 168) = CFRetain(a3);
    v17 = (uint64_t *)*((_QWORD *)this + 15);
    v16 = *((_QWORD *)this + 16);
    if ((unint64_t)v17 >= v16)
    {
      v19 = *((_QWORD *)this + 14);
      v20 = ((uint64_t)v17 - v19) >> 3;
      if ((unint64_t)(v20 + 1) >> 61)
        goto LABEL_29;
      v21 = v16 - v19;
      v22 = v21 >> 2;
      if (v21 >> 2 <= (unint64_t)(v20 + 1))
        v22 = v20 + 1;
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
        v23 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v23 = v22;
      if (v23)
      {
        v24 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v23);
        if (v24)
        {
          v26 = &v24[8 * v25];
          v27 = (uint64_t *)&v24[8 * v20];
          *v27 = v10;
          v18 = v27 + 1;
          v29 = (char *)*((_QWORD *)this + 14);
          v28 = (char *)*((_QWORD *)this + 15);
          if (v28 != v29)
          {
            do
            {
              v30 = *((_QWORD *)v28 - 1);
              v28 -= 8;
              *--v27 = v30;
            }
            while (v28 != v29);
            v28 = (char *)*((_QWORD *)this + 14);
          }
          *((_QWORD *)this + 14) = v27;
          *((_QWORD *)this + 15) = v18;
          *((_QWORD *)this + 16) = v26;
          if (v28)
            operator delete(v28);
          goto LABEL_26;
        }
      }
    }
    else if (v17)
    {
      *v17 = v10;
      v18 = v17 + 1;
LABEL_26:
      *((_QWORD *)this + 15) = v18;
      return;
    }
    __break(1u);
LABEL_29:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

void TaggedParser::LoadTextProperty(uint64_t a1, CGPDFDictionary *a2, CFStringRef theString)
{
  const char *CStringPtr;
  CFStringRef v7;
  CFStringRef v8;
  CGPDFStringRef value;

  value = 0;
  CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  if (CStringPtr && CGPDFDictionaryGetString(a2, CStringPtr, &value))
  {
    if (!*(_QWORD *)(a1 + 160))
      *(_QWORD *)(a1 + 160) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v7 = CGPDFStringCopyTextString(value);
    if (v7)
    {
      v8 = v7;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 160), theString, v7);
      CFRelease(v8);
    }
  }
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

uint64_t std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;

  if (a1)
  {
    v3 = a1;
    v4 = 1;
    do
    {
      if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)a2, v3 + 4) & 0x80) == 0)
      {
        if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)(v3 + 4), a2) & 0x80) == 0)
          return v4;
        ++v3;
      }
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  return 0;
}

_QWORD *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  uint64_t v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (uint64_t)(v4 + 4);
        if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)a3, v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0)
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>(uint64_t result, _QWORD *a2)
{
  size_t v2;
  size_t v4;
  size_t v5;
  int v6;

  if (*(char *)(result + 23) < 0)
  {
    v2 = *(_QWORD *)(result + 8);
    if ((v2 & 0x8000000000000000) != 0)
      goto LABEL_23;
    result = *(_QWORD *)result;
    if (v2 && result == 0)
      goto LABEL_23;
  }
  else
  {
    v2 = *(unsigned __int8 *)(result + 23);
  }
  if ((*((char *)a2 + 23) & 0x80000000) == 0)
  {
    v4 = *((unsigned __int8 *)a2 + 23);
    goto LABEL_13;
  }
  v4 = a2[1];
  if ((v4 & 0x8000000000000000) != 0 || (a2 = (_QWORD *)*a2, v4) && !a2)
  {
LABEL_23:
    __break(1u);
    return result;
  }
LABEL_13:
  if (v4 >= v2)
    v5 = v2;
  else
    v5 = v4;
  v6 = memcmp((const void *)result, a2, v5);
  if (v6)
  {
    if ((v6 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (v2 == v4)
      return 0;
    if (v2 >= v4)
      return 1;
  }
  return 255;
}

void ___ZN12TaggedParser21MapNodeNameToNodeTypeENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke()
{
  uint64_t v0;
  char *v1;
  uint64_t v2;
  char **v3;
  char **v4;
  char *v5;
  char *v6;
  BOOL v7;
  char v8;
  char **v9;
  char **v10;
  uint64_t v11;
  char *v12;
  std::string *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16[3];
  int v17;
  char *v18;
  int v19;
  char *v20;
  int v21;
  char *v22;
  int v23;
  char *v24;
  int v25;
  char *v26;
  int v27;
  char *v28;
  int v29;
  char *v30;
  int v31;
  char *v32;
  int v33;
  char *v34;
  int v35;
  char *v36;
  int v37;
  char *v38;
  int v39;
  char *v40;
  int v41;
  char *v42;
  int v43;
  char *v44;
  int v45;
  char *v46;
  int v47;
  char *v48;
  int v49;
  char *v50;
  int v51;
  char *v52;
  int v53;
  char *v54;
  int v55;
  char *v56;
  int v57;
  char *v58;
  int v59;
  char *v60;
  int v61;
  char *v62;
  int v63;
  char *v64;
  int v65;
  char *v66;
  int v67;
  char *v68;
  int v69;
  char *v70;
  int v71;
  char *v72;
  int v73;
  char *v74;
  int v75;
  char *v76;
  int v77;
  char *v78;
  int v79;
  char *v80;
  int v81;
  char *v82;
  int v83;
  char *v84;
  int v85;
  char *v86;
  int v87;
  char *v88;
  int v89;
  char *v90;
  int v91;
  char *v92;
  int v93;
  char *v94;
  int v95;
  char *v96;
  int v97;
  char *v98;
  int v99;
  char *v100;
  int v101;
  char *v102;
  int v103;
  char *v104;
  int v105;
  char *v106;
  int v107;
  char *v108;
  int v109;
  char *v110;
  int v111;
  char *v112;
  int v113;
  char *v114;
  int v115;
  char *v116;
  int v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v0 = operator new();
  std::string::basic_string[abi:se180100]<0>(v16, "Unknown");
  v17 = 0;
  std::string::basic_string[abi:se180100]<0>(&v18, "Document");
  v19 = 100;
  std::string::basic_string[abi:se180100]<0>(&v20, "Part");
  v21 = 101;
  std::string::basic_string[abi:se180100]<0>(&v22, "Art");
  v23 = 102;
  std::string::basic_string[abi:se180100]<0>(&v24, "Sect");
  v25 = 103;
  std::string::basic_string[abi:se180100]<0>(&v26, "Div");
  v27 = 104;
  std::string::basic_string[abi:se180100]<0>(&v28, "BlockQuote");
  v29 = 105;
  std::string::basic_string[abi:se180100]<0>(&v30, "Caption");
  v31 = 106;
  std::string::basic_string[abi:se180100]<0>(&v32, "TOC");
  v33 = 107;
  std::string::basic_string[abi:se180100]<0>(&v34, "TOCI");
  v35 = 108;
  std::string::basic_string[abi:se180100]<0>(&v36, "Index");
  v37 = 109;
  std::string::basic_string[abi:se180100]<0>(&v38, "NonStruct");
  v39 = 110;
  std::string::basic_string[abi:se180100]<0>(&v40, "Private");
  v41 = 111;
  std::string::basic_string[abi:se180100]<0>(&v42, "P");
  v43 = 200;
  std::string::basic_string[abi:se180100]<0>(&v44, "H");
  v45 = 201;
  std::string::basic_string[abi:se180100]<0>(&v46, "H1");
  v47 = 202;
  std::string::basic_string[abi:se180100]<0>(&v48, "H2");
  v49 = 203;
  std::string::basic_string[abi:se180100]<0>(&v50, "H3");
  v51 = 204;
  std::string::basic_string[abi:se180100]<0>(&v52, "H4");
  v53 = 205;
  std::string::basic_string[abi:se180100]<0>(&v54, "H5");
  v55 = 206;
  std::string::basic_string[abi:se180100]<0>(&v56, "H6");
  v57 = 207;
  std::string::basic_string[abi:se180100]<0>(&v58, "L");
  v59 = 300;
  std::string::basic_string[abi:se180100]<0>(&v60, "LI");
  v61 = 301;
  std::string::basic_string[abi:se180100]<0>(&v62, "Lbl");
  v63 = 302;
  std::string::basic_string[abi:se180100]<0>(&v64, "LBody");
  v65 = 303;
  std::string::basic_string[abi:se180100]<0>(&v66, "Table");
  v67 = 400;
  std::string::basic_string[abi:se180100]<0>(&v68, "TR");
  v69 = 401;
  std::string::basic_string[abi:se180100]<0>(&v70, "TH");
  v71 = 402;
  std::string::basic_string[abi:se180100]<0>(&v72, "TD");
  v73 = 403;
  std::string::basic_string[abi:se180100]<0>(&v74, "THead");
  v75 = 404;
  std::string::basic_string[abi:se180100]<0>(&v76, "TBody");
  v77 = 405;
  std::string::basic_string[abi:se180100]<0>(&v78, "TFoot");
  v79 = 406;
  std::string::basic_string[abi:se180100]<0>(&v80, "Span");
  v81 = 500;
  std::string::basic_string[abi:se180100]<0>(&v82, "Quote");
  v83 = 501;
  std::string::basic_string[abi:se180100]<0>(&v84, "Note");
  v85 = 502;
  std::string::basic_string[abi:se180100]<0>(&v86, "Reference");
  v87 = 503;
  std::string::basic_string[abi:se180100]<0>(&v88, "BibEntry");
  v89 = 504;
  std::string::basic_string[abi:se180100]<0>(&v90, "Code");
  v91 = 505;
  std::string::basic_string[abi:se180100]<0>(&v92, "Link");
  v93 = 506;
  std::string::basic_string[abi:se180100]<0>(&v94, "Annot");
  v95 = 507;
  std::string::basic_string[abi:se180100]<0>(&v96, "Ruby");
  v97 = 600;
  std::string::basic_string[abi:se180100]<0>(&v98, "RB");
  v99 = 601;
  std::string::basic_string[abi:se180100]<0>(&v100, "RT");
  v101 = 602;
  std::string::basic_string[abi:se180100]<0>(&v102, "RP");
  v103 = 603;
  std::string::basic_string[abi:se180100]<0>(&v104, "Warichu");
  v105 = 604;
  std::string::basic_string[abi:se180100]<0>(&v106, "WT");
  v107 = 605;
  std::string::basic_string[abi:se180100]<0>(&v108, "WP");
  v109 = 606;
  std::string::basic_string[abi:se180100]<0>(&v110, "Figure");
  v111 = 700;
  std::string::basic_string[abi:se180100]<0>(&v112, "Formula");
  v113 = 701;
  std::string::basic_string[abi:se180100]<0>(&v114, "Form");
  v115 = 702;
  std::string::basic_string[abi:se180100]<0>(&v116, "OBJR");
  v1 = 0;
  v2 = 0;
  v117 = 800;
  *(_QWORD *)(v0 + 8) = 0;
  v3 = (char **)(v0 + 8);
  *(_QWORD *)(v0 + 16) = 0;
  *(_QWORD *)v0 = v0 + 8;
  while (1)
  {
    v4 = &v16[4 * v2];
    if (*(char ***)v0 == v3)
    {
      v6 = (char *)(v0 + 8);
    }
    else
    {
      v5 = (char *)(v0 + 8);
      if (v1)
      {
        do
        {
          v6 = v1;
          v1 = (char *)*((_QWORD *)v1 + 1);
        }
        while (v1);
      }
      else
      {
        do
        {
          v6 = (char *)*((_QWORD *)v5 + 2);
          v7 = *(_QWORD *)v6 == (_QWORD)v5;
          v5 = v6;
        }
        while (v7);
      }
      v8 = std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)(v6 + 32), &v16[4 * v2]);
      v1 = *v3;
      if ((v8 & 0x80) == 0)
      {
        v9 = (char **)(v0 + 8);
        v10 = (char **)(v0 + 8);
        if (v1)
        {
          v10 = (char **)(v0 + 8);
          do
          {
            while (1)
            {
              v9 = (char **)v1;
              v11 = (uint64_t)(v1 + 32);
              if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>((uint64_t)&v16[4 * v2], (_QWORD *)v1 + 4) & 0x80) == 0)break;
              v1 = *v9;
              v10 = v9;
              if (!*v9)
                goto LABEL_20;
            }
            if ((std::operator<=>[abi:se180100]<char,std::char_traits<char>,std::allocator<char>>(v11, &v16[4 * v2]) & 0x80) == 0)
              goto LABEL_19;
            v10 = v9 + 1;
            v1 = v9[1];
          }
          while (v1);
        }
LABEL_20:
        v12 = (char *)operator new(0x40uLL);
        v13 = (std::string *)(v12 + 32);
        if (*((char *)v4 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v13, *v4, (std::string::size_type)v4[1]);
        }
        else
        {
          *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)v4;
          *((_QWORD *)v12 + 6) = v4[2];
        }
        *((_DWORD *)v12 + 14) = v16[4 * v2 + 3];
        *(_QWORD *)v12 = 0;
        *((_QWORD *)v12 + 1) = 0;
        *((_QWORD *)v12 + 2) = v9;
        *v10 = v12;
        v14 = **(_QWORD **)v0;
        if (v14)
        {
          *(_QWORD *)v0 = v14;
          v12 = *v10;
        }
        std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v0 + 8), (uint64_t *)v12);
        ++*(_QWORD *)(v0 + 16);
        goto LABEL_26;
      }
    }
    v9 = (char **)(v0 + 8);
    v10 = (char **)(v0 + 8);
    if (!v1)
      goto LABEL_20;
    v10 = (char **)(v6 + 8);
    v9 = (char **)v6;
LABEL_19:
    if (!*v10)
      goto LABEL_20;
LABEL_26:
    if (++v2 == 51)
      break;
    v1 = *v3;
  }
  TaggedParser::MapNodeNameToNodeType(std::string)::roleNames = v0;
  v15 = 204;
  do
  {
    if (*((char *)&v16[v15 - 1] - 1) < 0)
      operator delete(v16[v15 - 4]);
    v15 -= 4;
  }
  while (v15 * 8);
}

void sub_184C8343C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  uint64_t v10;
  void **v11;

  while (1)
  {
    if (*((char *)v11 - 9) < 0)
      operator delete(*(v11 - 4));
    v11 -= 4;
    if (v11 == (void **)&a10)
    {
      MEMORY[0x186DC23C4](v10, 0x1020C4062D53EE8);
      _Unwind_Resume(a1);
    }
  }
}

void RoleMapCallback(char *__s, CGPDFObject *a2, uint64_t **a3)
{
  char *v4;
  void **v5;
  char *v6;
  uint64_t **v7;
  std::string *v8;
  void **v9;
  __int128 v10;
  uint64_t v11;
  void *__p[2];
  uint64_t v13;
  _QWORD v14[2];
  char v15;
  uint64_t v16;

  if (a2 && *((_DWORD *)a2 + 2) == 5)
  {
    v4 = (char *)*((_QWORD *)a2 + 4);
    std::string::basic_string[abi:se180100]<0>((char **)__p, __s);
    if (!std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>(a3[1], __p))
    {
      std::string::basic_string[abi:se180100]<0>((char **)&v10, v4);
      v5 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a3, &v16, __p);
      v6 = (char *)*v5;
      if (!*v5)
      {
        v7 = (uint64_t **)v5;
        v6 = (char *)operator new(0x50uLL);
        v14[0] = v6;
        v14[1] = a3 + 1;
        v15 = 0;
        v8 = (std::string *)(v6 + 32);
        if (SHIBYTE(v13) < 0)
        {
          std::string::__init_copy_ctor_external(v8, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
        }
        else
        {
          *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
          *((_QWORD *)v6 + 6) = v13;
        }
        *((_QWORD *)v6 + 7) = 0;
        *((_QWORD *)v6 + 8) = 0;
        *((_QWORD *)v6 + 9) = 0;
        v15 = 1;
        std::__tree<unsigned long>::__insert_node_at(a3, v16, v7, (uint64_t *)v6);
        v14[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:se180100]((uint64_t)v14);
      }
      v9 = (void **)(v6 + 56);
      if (v6[79] < 0)
        operator delete(*v9);
      *(_OWORD *)v9 = v10;
      *((_QWORD *)v6 + 9) = v11;
    }
    if (SHIBYTE(v13) < 0)
      operator delete(__p[0]);
  }
}

void sub_184C836C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:se180100]((uint64_t)&a21);
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(a1);
}

void TaggedParser::BeginMarkedContentSequence(TaggedParser *this, CGPDFPage *a2, CGPDFDictionaryRef dict, CGPDFDictionary *a4)
{
  _BOOL4 v7;
  _BOOL4 Integer;
  _BOOL4 v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char **v13;
  unint64_t v14;
  int v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char **v20;
  unint64_t v21;
  char **v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  unint64_t v32;
  int v33;
  const char *v34;
  BOOL v35;
  _BOOL4 v36;
  char **v37;
  CGPDFInteger v38;
  char *value;

  if (!a2)
    puts("Critical error: null page");
  if (!*(_BYTE *)(*(_QWORD *)this + 97))
  {
    value = 0;
    v7 = CGPDFDictionaryGetName(dict, "Type", (const char **)&value) && strcmp(value, "OCMD") == 0;
    v38 = -1;
    Integer = CGPDFDictionaryGetInteger(dict, "MCID", &v38);
    v9 = v38 >= 0 && Integer;
    if (a2)
      v10 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8);
    else
      v10 = 0;
    v11 = v10 - 1;
    v12 = *(_QWORD *)(*(_QWORD *)this + 104);
    if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 112) - v12) >> 3) > v11)
    {
      v13 = (char **)(v12 + 24 * v11);
      if (v9)
      {
        if (a2)
          v14 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8) << 32;
        else
          v14 = 0;
        v17 = v38 | v14;
        v16 = *(char **)(v12 + 24 * v11 + 8);
        v15 = 1;
      }
      else
      {
        if (v7)
          v15 = 2;
        else
          v15 = 0;
        v16 = *(char **)(v12 + 24 * v11 + 8);
        if (v16 == *v13)
          v17 = -1;
        else
          v17 = *((_QWORD *)v16 - 1);
      }
      v18 = v12 + 24 * v11;
      v21 = *(_QWORD *)(v18 + 16);
      v20 = (char **)(v18 + 16);
      v19 = v21;
      v22 = v20 - 1;
      if ((unint64_t)v16 >= v21)
      {
        v35 = v9;
        v36 = v7;
        v37 = v13;
        v24 = *v13;
        v25 = (v16 - v24) >> 4;
        v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 60)
          goto LABEL_56;
        v27 = v19 - (_QWORD)v24;
        if (v27 >> 3 > v26)
          v26 = v27 >> 3;
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0)
          v28 = 0xFFFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
        {
          if (v28 >> 60)
            std::__throw_bad_array_new_length[abi:se180100]();
          v29 = (char *)operator new(16 * v28);
          v30 = &v29[16 * v28];
          v31 = &v29[16 * v25];
          *(_DWORD *)v31 = v15;
          *((_QWORD *)v31 + 1) = v17;
          v23 = v31 + 16;
          if (v16 == v24)
          {
            LOBYTE(v9) = v35;
            v7 = v36;
          }
          else
          {
            LOBYTE(v9) = v35;
            v7 = v36;
            do
            {
              *((_OWORD *)v31 - 1) = *((_OWORD *)v16 - 1);
              v31 -= 16;
              v16 -= 16;
            }
            while (v16 != v24);
            v16 = v24;
          }
          v13 = v37;
          *v37 = v31;
          *v22 = v23;
          *v20 = v30;
          if (v16)
            operator delete(v16);
          goto LABEL_43;
        }
      }
      else if (v16)
      {
        *(_DWORD *)v16 = v15;
        *((_QWORD *)v16 + 1) = v17;
        v23 = v16 + 16;
LABEL_43:
        *v22 = v23;
        if (*(_BYTE *)(*(_QWORD *)this + 96))
        {
          v32 = (unint64_t)(v23 - *v13) >> 4;
          if ((int)v32 >= 2)
          {
            v33 = v32 - 1;
            do
            {
              printf("    ");
              --v33;
            }
            while (v33);
          }
          v34 = "marked";
          if (v7)
            v34 = "optional";
          printf("Pushed %s content sequence.", v34);
          if (v9)
          {
            printf(" Page number %d, MCID: %d.");
          }
          else if (v7)
          {
            printf(" Optional content.");
          }
          printf(" Current depth: %d.\n", v32);
        }
        return;
      }
    }
    __break(1u);
LABEL_56:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
}

void TaggedParser::BeginMarkedContentSequence(TaggedParser *this, CGPDFPage *a2, const char *a3, const char *a4)
{
  uint64_t v5;
  CGPDFDictionary *v7;
  CGPDFDictionary *v9;
  const char *v10;
  CGPDFDictionaryRef v11;
  CGPDFDictionaryRef dict;
  CGPDFDictionaryRef value;

  if (!a2)
  {
    puts("Critical error: null page");
    v5 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 97))
      return;
    goto LABEL_9;
  }
  v5 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 97))
    return;
  v7 = *(CGPDFDictionary **)(*((_QWORD *)a2 + 5) + 16);
  if (!v7)
  {
LABEL_9:
    if (!*(_BYTE *)(v5 + 96))
      return;
    v10 = "Missing dictionary that backs a given page";
    goto LABEL_17;
  }
  value = 0;
  if (!CGPDFDictionaryGetDictionary(v7, "Resources", &value))
  {
    if (!*(_BYTE *)(*(_QWORD *)this + 96))
      return;
    v10 = "Missing \"Resources\" dictionary from page dictionary";
    goto LABEL_17;
  }
  dict = 0;
  if (!CGPDFDictionaryGetDictionary(value, "Properties", &dict))
  {
    if (!*(_BYTE *)(*(_QWORD *)this + 96))
      return;
    v10 = "Missing \"Properties\" dictionary from page resources dictionary";
    goto LABEL_17;
  }
  v11 = 0;
  if (CGPDFDictionaryGetDictionary(dict, a3, &v11))
  {
    TaggedParser::BeginMarkedContentSequence(this, a2, v11, v9);
    return;
  }
  if (*(_BYTE *)(*(_QWORD *)this + 96))
  {
    v10 = "Missing given property name's dictionary from page resources's properties dictionary";
LABEL_17:
    printf("Hit tagged parsing error: \"%s\"\n", v10);
  }
}

uint64_t TaggedParser::EndMarkedContentSequence(uint64_t this, CGPDFPage *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;

  if (!*(_BYTE *)(this + 97))
  {
    if (!a2
      || (v2 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8) - 1,
          v3 = *(_QWORD *)(this + 104),
          0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(this + 112) - v3) >> 3) <= v2))
    {
LABEL_15:
      __break(1u);
      return this;
    }
    v4 = (uint64_t *)(v3 + 24 * v2);
    v6 = v4 + 1;
    v5 = v4[1];
    v7 = *v4;
    v8 = v5 - *v4;
    if (v5 != *v4)
    {
      if (*(_BYTE *)(this + 96))
      {
        v9 = (v8 >> 4) - 1;
        if ((int)(v8 >> 4) >= 2)
        {
          v10 = (v8 >> 4) - 1;
          do
          {
            printf("    ");
            --v10;
          }
          while (v10);
        }
        this = printf("Popped content sequence. Was depth: %d\n", v9);
        v7 = *v4;
        v5 = *v6;
      }
      if (v7 != v5)
      {
        *v6 = v5 - 16;
        return this;
      }
      goto LABEL_15;
    }
    if (*(_BYTE *)(this + 96))
      return printf("Hit tagged parsing error: \"%s\"\n", "Attempted to pop a marked content sequence from an empty stack");
  }
  return this;
}

uint64_t TaggedParser::GetCurrentMCID(uint64_t this, CGPDFPage *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *v6;

  if (a2
    && (v2 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8) - 1,
        v3 = *(_QWORD *)(*(_QWORD *)this + 104),
        0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(*(_QWORD *)this + 112) - v3) >> 3) > v2))
  {
    v4 = &kCGPDFNodeIDNone;
    if (!*(_BYTE *)(*(_QWORD *)this + 97))
    {
      v6 = (_QWORD *)(v3 + 24 * v2);
      v5 = v6[1];
      if (v5 != *v6)
        v4 = (uint64_t *)(v5 - 8);
    }
    return *v4;
  }
  else
  {
    __break(1u);
  }
  return this;
}

void TaggedParser::AddGraphicBounds(TaggedParser *this, CGPDFPage *a2, CGRect a3, char a4)
{
  unint64_t v4;
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  unint64_t CurrentMCID;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  float *v15;
  unint64_t v16;
  uint8x8_t v17;
  uint64_t **v18;
  uint64_t *i;
  unint64_t v20;
  CGFloat *v21;
  float v22;
  float v23;
  _BOOL8 v24;
  unint64_t v25;
  unint64_t v26;
  int8x8_t prime;
  void *v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  uint8x8_t v33;
  unint64_t v34;
  uint8x8_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  _QWORD *v39;
  CGFloat **v40;
  unint64_t v41;
  _QWORD *v42;
  CGRect v43;

  if (!*(_BYTE *)(*(_QWORD *)this + 97))
  {
    height = a3.size.height;
    width = a3.size.width;
    y = a3.origin.y;
    x = a3.origin.x;
    CurrentMCID = TaggedParser::GetCurrentMCID((uint64_t)this, a2);
    if (CurrentMCID != -1)
    {
      v12 = CurrentMCID;
      v13 = HIDWORD(CurrentMCID) - 1;
      v14 = *(_QWORD *)(*(_QWORD *)this + 224);
      if (0xCCCCCCCCCCCCCCCDLL * ((*(_QWORD *)(*(_QWORD *)this + 232) - v14) >> 3) <= v13)
      {
        __break(1u);
        return;
      }
      v15 = (float *)(v14 + 40 * v13);
      v16 = *((_QWORD *)v15 + 1);
      if (v16)
      {
        v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
        v17.i16[0] = vaddlv_u8(v17);
        if (v17.u32[0] > 1uLL)
        {
          v4 = CurrentMCID;
          if (CurrentMCID >= v16)
            v4 = CurrentMCID % v16;
        }
        else
        {
          v4 = (v16 - 1) & CurrentMCID;
        }
        v18 = *(uint64_t ***)(*(_QWORD *)v15 + 8 * v4);
        if (v18)
        {
          for (i = *v18; i; i = (uint64_t *)*i)
          {
            v20 = i[1];
            if (v20 == CurrentMCID)
            {
              if (i[2] == CurrentMCID)
              {
                v43.origin.x = x;
                v43.origin.y = y;
                v43.size.width = width;
                v43.size.height = height;
                *(CGRect *)(i + 3) = CGRectUnion(*(CGRect *)(i + 3), v43);
                return;
              }
            }
            else
            {
              if (v17.u32[0] > 1uLL)
              {
                if (v20 >= v16)
                  v20 %= v16;
              }
              else
              {
                v20 &= v16 - 1;
              }
              if (v20 != v4)
                break;
            }
          }
        }
      }
      v21 = (CGFloat *)operator new(0x40uLL);
      *v21 = 0.0;
      *((_QWORD *)v21 + 1) = v12;
      *((_QWORD *)v21 + 2) = v12;
      v21[3] = x;
      v21[4] = y;
      v21[5] = width;
      v21[6] = height;
      *((_BYTE *)v21 + 56) = a4;
      v22 = (float)(unint64_t)(*((_QWORD *)v15 + 3) + 1);
      v23 = v15[8];
      if (v16 && (float)(v23 * (float)v16) >= v22)
      {
LABEL_67:
        v39 = *(_QWORD **)v15;
        v40 = *(CGFloat ***)(*(_QWORD *)v15 + 8 * v4);
        if (v40)
        {
          *(_QWORD *)v21 = *v40;
        }
        else
        {
          *v21 = *((CGFloat *)v15 + 2);
          *((_QWORD *)v15 + 2) = v21;
          v39[v4] = v15 + 4;
          if (!*(_QWORD *)v21)
          {
LABEL_76:
            ++*((_QWORD *)v15 + 3);
            return;
          }
          v41 = *(_QWORD *)(*(_QWORD *)v21 + 8);
          if ((v16 & (v16 - 1)) != 0)
          {
            if (v41 >= v16)
              v41 %= v16;
          }
          else
          {
            v41 &= v16 - 1;
          }
          v40 = (CGFloat **)(*(_QWORD *)v15 + 8 * v41);
        }
        *v40 = v21;
        goto LABEL_76;
      }
      v24 = 1;
      if (v16 >= 3)
        v24 = (v16 & (v16 - 1)) != 0;
      v25 = v24 | (2 * v16);
      v26 = vcvtps_u32_f32(v22 / v23);
      if (v25 <= v26)
        prime = (int8x8_t)v26;
      else
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime == 1)
      {
        prime = (int8x8_t)2;
      }
      else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
      {
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      }
      v16 = *((_QWORD *)v15 + 1);
      if (*(_QWORD *)&prime > v16)
        goto LABEL_33;
      if (*(_QWORD *)&prime < v16)
      {
        v34 = vcvtps_u32_f32((float)*((unint64_t *)v15 + 3) / v15[8]);
        if (v16 < 3 || (v35 = (uint8x8_t)vcnt_s8((int8x8_t)v16), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
        {
          v34 = std::__next_prime(v34);
        }
        else
        {
          v36 = 1 << -(char)__clz(v34 - 1);
          if (v34 >= 2)
            v34 = v36;
        }
        if (*(_QWORD *)&prime <= v34)
          prime = (int8x8_t)v34;
        if (*(_QWORD *)&prime >= v16)
        {
          v16 = *((_QWORD *)v15 + 1);
        }
        else
        {
          if (prime)
          {
LABEL_33:
            if (*(_QWORD *)&prime >> 61)
              std::__throw_bad_array_new_length[abi:se180100]();
            v28 = operator new(8 * *(_QWORD *)&prime);
            v29 = *(_QWORD **)v15;
            *(_QWORD *)v15 = v28;
            if (v29)
              operator delete(v29);
            v30 = 0;
            *((int8x8_t *)v15 + 1) = prime;
            do
              *(_QWORD *)(*(_QWORD *)v15 + 8 * v30++) = 0;
            while (*(_QWORD *)&prime != v30);
            v31 = (_QWORD *)*((_QWORD *)v15 + 2);
            if (v31)
            {
              v32 = v31[1];
              v33 = (uint8x8_t)vcnt_s8(prime);
              v33.i16[0] = vaddlv_u8(v33);
              if (v33.u32[0] > 1uLL)
              {
                if (v32 >= *(_QWORD *)&prime)
                  v32 %= *(_QWORD *)&prime;
              }
              else
              {
                v32 &= *(_QWORD *)&prime - 1;
              }
              *(_QWORD *)(*(_QWORD *)v15 + 8 * v32) = v15 + 4;
              v37 = (_QWORD *)*v31;
              if (*v31)
              {
                do
                {
                  v38 = v37[1];
                  if (v33.u32[0] > 1uLL)
                  {
                    if (v38 >= *(_QWORD *)&prime)
                      v38 %= *(_QWORD *)&prime;
                  }
                  else
                  {
                    v38 &= *(_QWORD *)&prime - 1;
                  }
                  if (v38 != v32)
                  {
                    if (!*(_QWORD *)(*(_QWORD *)v15 + 8 * v38))
                    {
                      *(_QWORD *)(*(_QWORD *)v15 + 8 * v38) = v31;
                      goto LABEL_58;
                    }
                    *v31 = *v37;
                    *v37 = **(_QWORD **)(*(_QWORD *)v15 + 8 * v38);
                    **(_QWORD **)(*(_QWORD *)v15 + 8 * v38) = v37;
                    v37 = v31;
                  }
                  v38 = v32;
LABEL_58:
                  v31 = v37;
                  v37 = (_QWORD *)*v37;
                  v32 = v38;
                }
                while (v37);
              }
            }
            v16 = (unint64_t)prime;
            goto LABEL_62;
          }
          v42 = *(_QWORD **)v15;
          *(_QWORD *)v15 = 0;
          if (v42)
            operator delete(v42);
          v16 = 0;
          *((_QWORD *)v15 + 1) = 0;
        }
      }
LABEL_62:
      if ((v16 & (v16 - 1)) != 0)
      {
        if (v12 >= v16)
          v4 = v12 % v16;
        else
          v4 = v12;
      }
      else
      {
        v4 = (v16 - 1) & v12;
      }
      goto LABEL_67;
    }
  }
}

void sub_184C84128(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CreateCGPDFTaggedNodeFromStructureElement(uint64_t result, CGPDFPage *a2)
{
  uint64_t v3;
  uint64_t v4;
  const __CFAllocator *v5;
  const char *v6;
  CFStringRef v7;
  CFStringRef v8;
  const void *v9;
  const __CFDictionary *v10;
  const void *Value;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void **v21;
  const void **v22;
  const CFArrayCallBacks *v23;
  const void *v24;
  __CFArray *Mutable;
  const StructureElement **v26;
  const StructureElement **v27;
  _QWORD *CGPDFTaggedNodeFromStructureElement;
  _QWORD *v29;
  unint64_t v30;
  unint64_t v31;
  __n64 **v32;
  __n64 **v33;
  __n64 *v34;
  __n64 *v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n64 v43;
  double v44;
  CGFloat v45;
  double v46;
  CGFloat v47;
  double v48;
  CGFloat v49;
  double Rotation;
  __double2 v51;
  _QWORD **v52;
  _QWORD **v53;
  _QWORD *v54;
  double Bounds;
  int v59;
  uint64_t v60;
  CGFloat Rect;
  double v62;
  CGFloat y;
  double v64;
  CGFloat width;
  double v66;
  CGFloat height;
  int RotationAngle;
  __double2 v69;
  double v70;
  double v71;
  _BOOL4 v72;
  __int128 v73;
  unint64_t v74;
  uint64_t v75;
  CGAffineTransform v76;
  CGAffineTransform v77;
  CGRect v78;
  CGRect v79;
  CGRect v80;
  CGRect v81;
  CGRect v82;

  if (!result)
    return result;
  v3 = result;
  if (!IsStructureElementForPage(result, a2))
    return 0;
  v4 = CGPDFTaggedNodeCreate((uint64_t)a2);
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = (const char *)(v3 + 8);
  if (*(char *)(v3 + 31) < 0)
    v6 = *(const char **)v6;
  v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, 0x8000100u);
  if (v7)
  {
    v8 = v7;
    if (v4)
    {
      v9 = *(const void **)(v4 + 24);
      if (v9)
        CFRelease(v9);
      *(_QWORD *)(v4 + 24) = v8;
      CFRetain(v8);
    }
    CFRelease(v8);
  }
  CGPDFTaggedNodeSetType((CFStringRef)v4, *(_DWORD *)(v3 + 32));
  if (*(_BYTE *)(v3 + 64))
  {
    if (!v4)
      goto LABEL_17;
    *(_BYTE *)(v4 + 112) = 0;
  }
  else if (!v4)
  {
    goto LABEL_17;
  }
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(v3 + 88);
LABEL_17:
  v10 = *(const __CFDictionary **)(v3 + 160);
  if (v10)
  {
    Value = CFDictionaryGetValue(v10, CFSTR("Alt"));
    if (Value && v4)
    {
      v12 = Value;
      v13 = *(const void **)(v4 + 120);
      if (v13)
        CFRelease(v13);
      *(_QWORD *)(v4 + 120) = v12;
      CFRetain(v12);
    }
    v14 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 160), CFSTR("ActualText"));
    if (v14 && v4)
    {
      v15 = v14;
      v16 = *(const void **)(v4 + 128);
      if (v16)
        CFRelease(v16);
      *(_QWORD *)(v4 + 128) = v15;
      CFRetain(v15);
    }
    v17 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 160), CFSTR("T"));
    if (v17 && v4)
    {
      v18 = v17;
      v19 = *(const void **)(v4 + 136);
      if (v19)
        CFRelease(v19);
      *(_QWORD *)(v4 + 136) = v18;
      CFRetain(v18);
    }
    v20 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 160), CFSTR("Lang"));
    if (v20)
      CGPDFTaggedNodeSetLanguageText((_QWORD *)v4, v20);
  }
  else
  {
    v20 = 0;
  }
  v21 = *(const void ***)(v3 + 176);
  v22 = *(const void ***)(v3 + 184);
  if (v21 != v22)
  {
    v23 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    do
    {
      if (v4)
      {
        v24 = *v21;
        if (*v21)
        {
          Mutable = *(__CFArray **)(v4 + 152);
          if (!Mutable)
          {
            Mutable = CFArrayCreateMutable(v5, 0, v23);
            *(_QWORD *)(v4 + 152) = Mutable;
          }
          CFArrayAppendValue(Mutable, v24);
        }
      }
      ++v21;
    }
    while (v21 != v22);
  }
  v26 = *(const StructureElement ***)(v3 + 112);
  v27 = *(const StructureElement ***)(v3 + 120);
  while (v26 != v27)
  {
    CGPDFTaggedNodeFromStructureElement = (_QWORD *)CreateCGPDFTaggedNodeFromStructureElement(*v26, a2);
    if (CGPDFTaggedNodeFromStructureElement)
    {
      v29 = CGPDFTaggedNodeFromStructureElement;
      if (v20)
      {
        if (!CGPDFTaggedNodeFromStructureElement[18])
          CGPDFTaggedNodeSetLanguageText(CGPDFTaggedNodeFromStructureElement, v20);
      }
      CGPDFTaggedNodeAddTaggedNode(v4, v29);
      CFRelease(v29);
    }
    ++v26;
  }
  v30 = *(_QWORD *)(v3 + 80);
  if (v30 == -1)
    v31 = 0;
  else
    v31 = HIDWORD(v30);
  if (v4)
    *(_QWORD *)(v4 + 160) = v31;
  v74 = v31;
  v32 = *(__n64 ***)(v3 + 136);
  v33 = *(__n64 ***)(v3 + 144);
  if (v32 != v33)
  {
    while (1)
    {
      v34 = *v32;
      if (!*v32)
        goto LABEL_86;
      v35 = *v32;
      while (v35->n64_u32[0] != 517)
      {
        v35 = (__n64 *)v35[1].n64_u64[0];
        if (!v35)
          goto LABEL_86;
      }
      if (!v35[13].n64_u64[0])
        goto LABEL_86;
      v36 = v34->n64_u32[0];
      if (v34->n64_u32[0] == 1)
        break;
      if ((v36 - 257) < 2)
      {
        v37 = 0;
        v75 = 0;
        v38 = 700;
        goto LABEL_78;
      }
      if (v36 == 259)
      {
        v39 = v34[13].n64_i64[0];
        if (v39)
        {
          v40 = *(_QWORD *)(v39 + 16);
          if (v40)
          {
            v37 = *(_QWORD *)(v40 + 40);
            v75 = *(_QWORD *)(v40 + 32);
          }
          else
          {
            v75 = 0;
            v37 = 0;
          }
          if (CGPDFAnnotationGetType(v39) == 25)
            v38 = 702;
          else
            v38 = 507;
        }
        else
        {
          v37 = 0;
          v75 = 0;
          v38 = 0;
        }
        v36 = 259;
        goto LABEL_78;
      }
LABEL_86:
      if (++v32 == v33)
        goto LABEL_87;
    }
    v37 = 0;
    v75 = 0;
    v38 = 1;
LABEL_78:
    v41 = CGPDFTaggedNodeCreate(0);
    CGPDFTaggedNodeSetType((CFStringRef)v41, v38);
    if (v41)
    {
      v42 = *(_QWORD *)(v41 + 104);
      if (v42)
        CGPDFNodeRelease(v42);
      *(_QWORD *)(v41 + 104) = v34;
      ++v34[5].n64_u32[0];
      *(_QWORD *)(v41 + 160) = v74;
    }
    v43.n64_u64[0] = CGPDFNodeGetBounds(v34).n64_u64[0];
    v45 = v44;
    v47 = v46;
    v49 = v48;
    Rotation = CGPDFNodeGetRotation((uint64_t)v34);
    v51 = __sincos_stret(Rotation);
    v77.tx = 0.0;
    v77.ty = 0.0;
    v77.a = v51.__cosval;
    v77.b = v51.__sinval;
    v77.c = -v51.__sinval;
    v77.d = v51.__cosval;
    if (v41)
    {
      v78.origin.x = v43.n64_f64[0];
      v78.origin.y = v45;
      v78.size.width = v47;
      v78.size.height = v49;
      v79 = CGRectApplyAffineTransform(v78, &v77);
      *(_BYTE *)(v41 + 48) = 1;
      *(CGRect *)(v41 + 56) = v79;
      if (v36 == 257)
        *(_BYTE *)(v41 + 113) = 1;
      *(_QWORD *)(v41 + 32) = v75;
      *(_QWORD *)(v41 + 40) = v37;
      CGPDFTaggedNodeAddTaggedNode(v4, (_QWORD *)v41);
      CFRelease((CFTypeRef)v41);
    }
    goto LABEL_86;
  }
LABEL_87:
  v52 = *(_QWORD ***)(v3 + 200);
  v53 = *(_QWORD ***)(v3 + 208);
  while (v52 != v53)
  {
    v54 = *v52++;
    CGPDFTaggedNodeAddTaggedNode(v4, v54);
  }
  if (v4 && *(_DWORD *)(v4 + 16) == 700)
  {
    Bounds = CGPDFTaggedNodeGetBounds(v4);
    v59 = 1;
    goto LABEL_93;
  }
  if (*(_QWORD *)(v3 + 112) == *(_QWORD *)(v3 + 120) && *(_QWORD *)(v3 + 200) == *(_QWORD *)(v3 + 208))
  {
    Bounds = CGPDFTaggedNodeGetBounds(v4);
    if (v4)
    {
      v59 = 0;
LABEL_93:
      v80 = CGRectUnion(*(CGRect *)&Bounds, *(CGRect *)(v3 + 224));
      *(_BYTE *)(v4 + 48) = 1;
      *(CGRect *)(v4 + 56) = v80;
      if (v59)
        *(_BYTE *)(v4 + 113) = *(_BYTE *)(v3 + 256);
    }
  }
  v60 = *(_QWORD *)(v3 + 168);
  if (v60)
  {
    Rect = CGPDFAnnotationGetRect(v60);
    y = v62;
    width = v64;
    height = v66;
    RotationAngle = CGPDFPageGetRotationAngle(a2);
    if (RotationAngle)
    {
      v69 = __sincos_stret((double)RotationAngle * -3.14159265 / 180.0);
      v76.tx = 0.0;
      v76.ty = 0.0;
      v76.a = v69.__cosval;
      v76.b = v69.__sinval;
      v76.c = -v69.__sinval;
      v76.d = v69.__cosval;
      v81.origin.x = Rect;
      v81.origin.y = y;
      v81.size.width = width;
      v81.size.height = height;
      v82 = CGRectApplyAffineTransform(v81, &v76);
      Rect = v82.origin.x;
      y = v82.origin.y;
      width = v82.size.width;
      height = v82.size.height;
    }
    if (v4)
    {
      *(_BYTE *)(v4 + 48) = 1;
      *(CGFloat *)(v4 + 56) = Rect;
      *(CGFloat *)(v4 + 64) = y;
      *(CGFloat *)(v4 + 72) = width;
      *(CGFloat *)(v4 + 80) = height;
    }
  }
  v70 = *(double *)(v3 + 264);
  v71 = *(double *)(v3 + 272);
  v72 = v70 == INFINITY;
  if (v71 == INFINITY)
    v72 = 1;
  if (v72)
    result = v4;
  else
    result = 0;
  if (!v72 && v4)
  {
    *(_BYTE *)(v4 + 48) = 1;
    v73 = *(_OWORD *)(v3 + 280);
    *(double *)(v4 + 56) = v70;
    *(double *)(v4 + 64) = v71;
    *(_OWORD *)(v4 + 72) = v73;
    return v4;
  }
  return result;
}

const void **applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t TaggedParser::CreateStructureElement(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  uint64_t v21;

  if (a2)
    v3 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8) - 1;
  else
    v3 = -1;
  v4 = operator new();
  v5 = v4;
  do
    v6 = __ldaxr(&gStructureElementCount);
  while (__stlxr(v6 + 1, &gStructureElementCount));
  *(_QWORD *)v4 = v6;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  *(_QWORD *)(v4 + 56) = 0;
  *(_QWORD *)(v4 + 40) = 0;
  *(_BYTE *)(v4 + 64) = 0;
  *(_QWORD *)(v4 + 72) = -1;
  *(_QWORD *)(v4 + 80) = -1;
  *(_OWORD *)(v4 + 88) = 0u;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_OWORD *)(v4 + 136) = 0u;
  *(_OWORD *)(v4 + 152) = 0u;
  *(_OWORD *)(v4 + 168) = 0u;
  *(_OWORD *)(v4 + 184) = 0u;
  *(_OWORD *)(v4 + 200) = 0u;
  *(_QWORD *)(v4 + 216) = 0;
  *(int64x2_t *)(v4 + 224) = vdupq_n_s64(0x7FF0000000000000uLL);
  *(_QWORD *)(v4 + 240) = 0;
  *(_QWORD *)(v4 + 248) = 0;
  *(_BYTE *)(v4 + 256) = 0;
  *(CGRect *)(v4 + 264) = CGRectNull;
  *(_QWORD *)(v4 + 104) = a1;
  std::string::operator=((std::string *)(v4 + 8), (const std::string *)(a1 + 8));
  *(_DWORD *)(v5 + 32) = *(_DWORD *)(a1 + 32);
  *(_BYTE *)(v5 + 64) = 1;
  *(_QWORD *)(v5 + 72) = v3;
  v8 = *(uint64_t **)(a1 + 120);
  v7 = *(_QWORD *)(a1 + 128);
  if ((unint64_t)v8 < v7)
  {
    if (v8)
    {
      *v8 = v5;
      v9 = v8 + 1;
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  v10 = *(_QWORD *)(a1 + 112);
  v11 = ((uint64_t)v8 - v10) >> 3;
  if ((unint64_t)(v11 + 1) >> 61)
    goto LABEL_24;
  v12 = v7 - v10;
  v13 = v12 >> 2;
  if (v12 >> 2 <= (unint64_t)(v11 + 1))
    v13 = v11 + 1;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
    v14 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v14 = v13;
  if (!v14
    || (v15 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v14)) == 0)
  {
LABEL_23:
    __break(1u);
LABEL_24:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v17 = &v15[8 * v16];
  v18 = (uint64_t *)&v15[8 * v11];
  *v18 = v5;
  v9 = v18 + 1;
  v20 = *(char **)(a1 + 112);
  v19 = *(char **)(a1 + 120);
  if (v19 != v20)
  {
    do
    {
      v21 = *((_QWORD *)v19 - 1);
      v19 -= 8;
      *--v18 = v21;
    }
    while (v19 != v20);
    v19 = *(char **)(a1 + 112);
  }
  *(_QWORD *)(a1 + 112) = v18;
  *(_QWORD *)(a1 + 120) = v9;
  *(_QWORD *)(a1 + 128) = v17;
  if (v19)
    operator delete(v19);
LABEL_22:
  *(_QWORD *)(a1 + 120) = v9;
  return v5;
}

void TaggedParser::BuildStructureElementFromGroupRegion(TaggedParser *this, StructureElement *a2, PDFCRGroupRegion *a3, CGPDFPage *a4, NSMutableSet *a5, PageLayout *a6)
{
  PDFCRGroupRegion *v10;
  NSMutableSet *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  PDFCRGroupRegion *v16;
  unint64_t v17;
  uint64_t v18;
  StructureElement *v19;
  TaggedParser *v20;
  uint64_t StructureElement;
  void *v22;
  void *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  void *v28;
  void *v29;
  double v30;
  double v31;
  double v32;
  double v33;
  TaggedParser *v34;
  StructureElement *v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  void *v39;
  TaggedParser *v40;
  id v41;
  _QWORD *v42;
  CGPDFAnnotation *v43;
  uint64_t v44;
  _OWORD *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t *v63;
  _QWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  int64x2_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t *v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t *v83;
  _QWORD *v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  uint64_t v92;
  uint64_t *v93;
  _QWORD *v94;
  _QWORD *v95;
  uint64_t v96;
  int64x2_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  PDFCRGroupRegion *v104;
  id v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  id v109;
  uint64_t v110;
  _OWORD *v111;
  uint64_t *__p;
  void *__pa;
  NSMutableSet *v114;
  _QWORD *v115;
  id obj;
  id obja;
  StructureElement *v118;
  StructureElement *v119;
  uint64_t *v121;
  uint64_t *v122;
  void *v123;
  char *v124;
  _OWORD v125[2];
  __int128 v126;
  __int128 v127;
  uint64_t v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  void *v137;
  int64x2_t v138;
  uint64_t v139;
  uint64_t v140;
  _BYTE v141[128];
  _BYTE v142[128];
  uint64_t v143;
  CGRect BoxRect;

  v143 = *MEMORY[0x1E0C80C00];
  v10 = a3;
  v11 = a5;
  v104 = v10;
  v114 = v11;
  -[NSMutableSet member:](v11, "member:", v10);
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  if (v12)
  {
    v13 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 96))
    {
      printf("Hit tagged parsing error: \"%s\"\n", "Cycles detected in marked structure element graph");
      v13 = *(_QWORD *)this;
    }
    *(_BYTE *)(v13 + 97) = 1;
  }
  else
  {
    -[NSMutableSet addObject:](v11, "addObject:", v10);
    v135 = 0u;
    v136 = 0u;
    v133 = 0u;
    v134 = 0u;
    -[PDFCRGroupRegion children](v10, "children");
    obj = (id)objc_claimAutoreleasedReturnValue();
    v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v133, v142, 16);
    if (v14)
    {
      v118 = *(StructureElement **)v134;
      do
      {
        for (i = 0; i != v14; ++i)
        {
          if (*(StructureElement **)v134 != v118)
            objc_enumerationMutation(obj);
          v16 = *(PDFCRGroupRegion **)(*((_QWORD *)&v133 + 1) + 8 * i);
          if (-[PDFCRGroupRegion type](v16, "type") == 6)
          {
            *((_DWORD *)a2 + 8) = 400;
            v17 = -[PDFCRGroupRegion rowIndex](v16, "rowIndex");
            while (1)
            {
              v18 = *((_QWORD *)a2 + 14);
              if (v17 < (*((_QWORD *)a2 + 15) - v18) >> 3)
                break;
              *(_DWORD *)(TaggedParser::CreateStructureElement((uint64_t)a2, (uint64_t)a4) + 32) = 401;
            }
            v20 = this;
            StructureElement = TaggedParser::CreateStructureElement(*(_QWORD *)(v18 + 8 * v17), (uint64_t)a4);
            *(_DWORD *)(StructureElement + 32) = 403;
            -[PDFCRGroupRegion boundingQuad](v16, "boundingQuad");
            v22 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v22, "denormalizedQuad");
            v23 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v23, "bottomLeft");
            v25 = v24;
            v27 = v26;

            -[PDFCRGroupRegion boundingQuad](v16, "boundingQuad");
            v28 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v28, "denormalizedQuad");
            v29 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v29, "topRight");
            v31 = v30;
            v33 = v32;

            BoxRect = CGPDFPageGetBoxRect(a4, kCGPDFCropBox);
            *(double *)(StructureElement + 264) = v25;
            *(double *)(StructureElement + 272) = BoxRect.size.height - v27;
            *(double *)(StructureElement + 280) = v31 - v25;
            *(double *)(StructureElement + 288) = v27 - v33;
            v34 = v20;
            v35 = (StructureElement *)StructureElement;
            this = v20;
            v11 = v114;
            TaggedParser::BuildStructureElementFromGroupRegion(v34, v35, v16, a4, v114, a6);
          }
          else
          {
            v19 = (StructureElement *)TaggedParser::CreateStructureElement((uint64_t)a2, (uint64_t)a4);
            TaggedParser::BuildStructureElementFromGroupRegion(this, v19, v16, a4, v11, a6);
          }
        }
        v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v133, v142, 16);
      }
      while (v14);
    }

    if (a4)
      v119 = *(StructureElement **)(*((_QWORD *)a4 + 5) + 8);
    else
      v119 = 0;
    v131 = 0u;
    v132 = 0u;
    v129 = 0u;
    v130 = 0u;
    -[PDFCRGroupRegion subregions](v10, "subregions");
    v105 = (id)objc_claimAutoreleasedReturnValue();
    v36 = objc_msgSend(v105, "countByEnumeratingWithState:objects:count:", &v129, v141, 16);
    if (v36)
    {
      v115 = 0;
      v106 = *(_QWORD *)v130;
      do
      {
        v110 = 0;
        v108 = v36;
        do
        {
          if (*(_QWORD *)v130 != v106)
            objc_enumerationMutation(v105);
          v109 = *(id *)(*((_QWORD *)&v129 + 1) + 8 * v110);
          switch(objc_msgSend(v109, "type"))
          {
            case 1u:
              v37 = (uint64_t)v115;
              if (!v115)
              {
                v37 = TaggedParser::CreateStructureElement((uint64_t)a2, (uint64_t)a4);
                *(_DWORD *)(v37 + 32) = 200;
              }
              v38 = v109;
              v39 = v38;
              if (v38)
              {
                objc_msgSend(v38, "textLine");
              }
              else
              {
                v128 = 0;
                v126 = 0u;
                v127 = 0u;
                memset(v125, 0, sizeof(v125));
              }
              PageLayout::getWordsInLine((PageLayout *)&v137, (const TextLine *)a6, (unint64_t *)v125);
              v115 = (_QWORD *)v37;
              __pa = v39;
              if (v39)
              {
                objc_msgSend(v39, "textLine");
                v75 = *(_QWORD *)&v125[0];
              }
              else
              {
                v75 = 0;
              }
              v76 = (uint64_t *)v138.i64[0];
              obja = v137;
              if (v137 == (void *)v138.i64[0])
                goto LABEL_94;
              v77 = (uint64_t *)v137;
              do
              {
                v78 = *v77;
                v79 = v77[1];
                v80 = CGPDFTaggedNodeCreate((uint64_t)a4);
                v81 = v80;
                v121 = (uint64_t *)v80;
                v83 = (uint64_t *)v115[26];
                v82 = v115[27];
                if ((unint64_t)v83 >= v82)
                {
                  v86 = v115[25];
                  v87 = ((uint64_t)v83 - v86) >> 3;
                  if ((unint64_t)(v87 + 1) >> 61)
                    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                  v88 = v82 - v86;
                  v89 = v88 >> 2;
                  if (v88 >> 2 <= (unint64_t)(v87 + 1))
                    v89 = v87 + 1;
                  if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8)
                    v90 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v90 = v89;
                  *(_QWORD *)&v126 = v115 + 27;
                  if (!v90)
                    goto LABEL_103;
                  v91 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v90);
                  if (!v91)
                    goto LABEL_103;
                  v93 = (uint64_t *)&v91[8 * v87];
                  *v93 = v81;
                  v84 = v93 + 1;
                  v121 = 0;
                  v95 = (_QWORD *)v115[25];
                  v94 = (_QWORD *)v115[26];
                  if (v94 == v95)
                  {
                    v97 = vdupq_n_s64((unint64_t)v94);
                    v85 = v115;
                  }
                  else
                  {
                    do
                    {
                      v96 = *--v94;
                      *--v93 = v96;
                      *v94 = 0;
                    }
                    while (v94 != v95);
                    v85 = v115;
                    v97 = *(int64x2_t *)(v115 + 25);
                  }
                  v85[25] = v93;
                  v85[26] = v84;
                  *(int64x2_t *)((char *)v125 + 8) = v97;
                  v98 = v85[27];
                  v85[27] = &v91[8 * v92];
                  *((_QWORD *)&v125[1] + 1) = v98;
                  *(_QWORD *)&v125[0] = v97.i64[0];
                  std::__split_buffer<applesauce::CF::ObjectRef<CGPDFTaggedNode *>>::~__split_buffer((uint64_t)v125);
                }
                else
                {
                  if (!v83)
                    goto LABEL_103;
                  *v83 = v80;
                  v84 = v83 + 1;
                  v121 = 0;
                  v85 = v115;
                }
                v85[26] = v84;
                v99 = *(v84 - 1);
                if (v99)
                {
                  CFRetain((CFTypeRef)v99);
                  v123 = (void *)v99;
                  *(_BYTE *)(v99 + 112) = 0;
                }
                else
                {
                  v123 = 0;
                }
                CGPDFTaggedNodeSetType((CFStringRef)v99, 1);
                if (v99)
                {
                  *(_QWORD *)(v99 + 160) = v119;
                  PageLayout::GetBoundsForRangeWithinLine(a6, v78 + v75, v79, 0, 0);
                  *(_BYTE *)(v99 + 48) = 1;
                  *(_QWORD *)(v99 + 56) = v100;
                  *(_QWORD *)(v99 + 64) = v101;
                  *(_QWORD *)(v99 + 72) = v102;
                  *(_QWORD *)(v99 + 80) = v103;
                  *(_BYTE *)(v99 + 168) = 1;
                  *(_QWORD *)(v99 + 176) = v78 + v75;
                  *(_QWORD *)(v99 + 184) = v79;
                  *(_BYTE *)(v99 + 192) = 0;
                  CFRelease((CFTypeRef)v99);
                }
                else
                {
                  PageLayout::GetBoundsForRangeWithinLine(a6, v78 + v75, v79, 0, 0);
                }
                v77 += 2;
              }
              while (v77 != v76);
LABEL_94:
              if (obja)
                operator delete(obja);

              v36 = v108;
              goto LABEL_97;
            case 2u:
              v40 = (TaggedParser *)TaggedParser::CreateStructureElement((uint64_t)a2, (uint64_t)a4);
              v41 = v109;
              v42 = (_QWORD *)objc_msgSend(v41, "annotation");
              TaggedParser::CreateStructureElement(v40, v119, v42, v43);

              v115 = 0;
              goto LABEL_97;
            case 3u:
              v115 = 0;
              *(_DWORD *)(TaggedParser::CreateStructureElement((uint64_t)a2, (uint64_t)a4) + 32) = 702;
              goto LABEL_97;
            case 4u:
              *((_DWORD *)a2 + 8) = 300;
              v44 = TaggedParser::CreateStructureElement((uint64_t)a2, (uint64_t)a4);
              *(_DWORD *)(v44 + 32) = 301;
              if (!v109)
                goto LABEL_97;
              objc_msgSend(v109, "textLines");
              v45 = v123;
              v107 = v124;
              if (v123 == v124)
                goto LABEL_63;
              break;
            default:
              goto LABEL_97;
          }
          do
          {
            v125[1] = v45[1];
            v126 = v45[2];
            v127 = v45[3];
            v128 = *((_QWORD *)v45 + 8);
            v111 = v45;
            v125[0] = *v45;
            PageLayout::getWordsInLine((PageLayout *)&v121, (const TextLine *)a6, (unint64_t *)v125);
            v46 = v122;
            __p = v121;
            if (v121 != v122)
            {
              v47 = *(_QWORD *)&v125[0];
              v48 = v121;
              do
              {
                v50 = *v48;
                v49 = v48[1];
                v51 = CGPDFTaggedNodeCreate((uint64_t)a4);
                v52 = v51;
                v54 = *(uint64_t **)(v44 + 208);
                v53 = *(_QWORD *)(v44 + 216);
                if ((unint64_t)v54 >= v53)
                {
                  v56 = *(_QWORD *)(v44 + 200);
                  v57 = ((uint64_t)v54 - v56) >> 3;
                  if ((unint64_t)(v57 + 1) >> 61)
                    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                  v58 = v53 - v56;
                  v59 = v58 >> 2;
                  if (v58 >> 2 <= (unint64_t)(v57 + 1))
                    v59 = v57 + 1;
                  if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8)
                    v60 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v60 = v59;
                  v140 = v44 + 216;
                  if (!v60
                    || (v61 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v60)) == 0)
                  {
LABEL_103:
                    __break(1u);
                  }
                  v63 = (uint64_t *)&v61[8 * v57];
                  *v63 = v52;
                  v55 = v63 + 1;
                  v65 = *(_QWORD **)(v44 + 200);
                  v64 = *(_QWORD **)(v44 + 208);
                  if (v64 == v65)
                  {
                    v67 = vdupq_n_s64((unint64_t)v64);
                  }
                  else
                  {
                    do
                    {
                      v66 = *--v64;
                      *--v63 = v66;
                      *v64 = 0;
                    }
                    while (v64 != v65);
                    v67 = *(int64x2_t *)(v44 + 200);
                  }
                  *(_QWORD *)(v44 + 200) = v63;
                  *(_QWORD *)(v44 + 208) = v55;
                  v138 = v67;
                  v68 = *(_QWORD *)(v44 + 216);
                  *(_QWORD *)(v44 + 216) = &v61[8 * v62];
                  v139 = v68;
                  v137 = (void *)v67.i64[0];
                  std::__split_buffer<applesauce::CF::ObjectRef<CGPDFTaggedNode *>>::~__split_buffer((uint64_t)&v137);
                }
                else
                {
                  if (!v54)
                    goto LABEL_103;
                  *v54 = v51;
                  v55 = v54 + 1;
                }
                *(_QWORD *)(v44 + 208) = v55;
                v69 = *(v55 - 1);
                if (v69)
                {
                  CFRetain((CFTypeRef)*(v55 - 1));
                  *(_BYTE *)(v69 + 112) = 0;
                }
                CGPDFTaggedNodeSetType((CFStringRef)v69, 1);
                v70 = v50 + v47;
                if (v69)
                {
                  *(_QWORD *)(v69 + 160) = v119;
                  PageLayout::GetBoundsForRangeWithinLine(a6, v70, v49, 0, 0);
                  *(_BYTE *)(v69 + 48) = 1;
                  *(_QWORD *)(v69 + 56) = v71;
                  *(_QWORD *)(v69 + 64) = v72;
                  *(_QWORD *)(v69 + 72) = v73;
                  *(_QWORD *)(v69 + 80) = v74;
                  *(_BYTE *)(v69 + 168) = 1;
                  *(_QWORD *)(v69 + 176) = v70;
                  *(_QWORD *)(v69 + 184) = v49;
                  *(_BYTE *)(v69 + 192) = 0;
                  CFRelease((CFTypeRef)v69);
                }
                else
                {
                  PageLayout::GetBoundsForRangeWithinLine(a6, v70, v49, 0, 0);
                }
                v48 += 2;
              }
              while (v48 != v46);
            }
            if (__p)
              operator delete(__p);
            v45 = (_OWORD *)((char *)v111 + 72);
            v36 = v108;
          }
          while ((char *)v111 + 72 != v107);
          v45 = v123;
LABEL_63:
          if (v45)
          {
            v124 = (char *)v45;
            operator delete(v45);
          }
LABEL_97:

          ++v110;
        }
        while (v110 != v36);
        v36 = objc_msgSend(v105, "countByEnumeratingWithState:objects:count:", &v129, v141, 16);
      }
      while (v36);
    }

    v11 = v114;
  }

}

void sub_184C85190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{

  _Unwind_Resume(a1);
}

BOOL IsStructureElementForPage(uint64_t a1, CGPDFPage *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  const StructureElement **v7;
  const StructureElement **v8;

  if (a2)
    v3 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8);
  else
    v3 = 0;
  v4 = *(_QWORD *)(a1 + 80);
  if (v4 == -1)
  {
    if (*(_BYTE *)(a1 + 64))
      v5 = *(_QWORD *)(a1 + 72) + 1;
    else
      v5 = -1;
  }
  else
  {
    v5 = HIDWORD(v4);
  }
  if (v5 == v3)
    return 1;
  if (*(_QWORD *)(a1 + 168))
    return *(unsigned int *)(a1 + 4) == v3;
  if (v4 == -1)
  {
    v7 = *(const StructureElement ***)(a1 + 112);
    v8 = *(const StructureElement ***)(a1 + 120);
    if (v7 != v8)
    {
      while (!*v7 || (IsStructureElementForPage(*v7, a2) & 1) == 0)
      {
        result = 0;
        if (++v7 == v8)
          return result;
      }
      return 1;
    }
  }
  return 0;
}

void RemovePageNodesFromStructureElement(StructureElement *a1, CGPDFPage *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;

  if (a1)
  {
    v4 = *((_QWORD *)a1 + 10);
    if (v4 == -1 || ((v5 = HIDWORD(v4), !a2) ? (v6 = 0) : (v6 = *(_QWORD *)(*((_QWORD *)a2 + 5) + 8)), v5 == v6))
    {
      while (1)
      {
        v8 = *((_QWORD *)a1 + 18);
        if (*((_QWORD *)a1 + 17) == v8)
          break;
        v7 = *(_QWORD *)(v8 - 8);
        *((_QWORD *)a1 + 18) = v8 - 8;
        CGPDFNodeRelease(v7);
      }
      v10 = *((_QWORD *)a1 + 14);
      for (i = *((_QWORD *)a1 + 15); v10 != i; *((_QWORD *)a1 + 15) = i)
      {
        RemovePageNodesFromStructureElement(*(StructureElement **)(i - 8), a2);
        v10 = *((_QWORD *)a1 + 14);
        v11 = *((_QWORD *)a1 + 15);
        if (v10 == v11)
        {
          __break(1u);
          return;
        }
        i = v11 - 8;
      }
    }
  }
}

__CFDictionary *BuildStructureTree(unint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  unint64_t v6;
  const __CFAllocator *v7;
  __CFDictionary *Mutable;
  char *v9;
  const void *v10;
  const StructureElement **v11;
  const StructureElement **v12;
  void *Value;
  uint64_t valuePtr;

  valuePtr = -1;
  v6 = *(_QWORD *)(a3 + 80);
  if (v6 != -1)
  {
    if (a1 != HIDWORD(v6))
      return 0;
    valuePtr = *(_QWORD *)(a3 + 80);
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CGCFDictionarySetNumber(Mutable, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &valuePtr);
  CGCFDictionarySetNumber(Mutable, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, (void *)a3);
  CGCFDictionarySetNumber(Mutable, CFSTR("TagNodeObjectRefID"), kCFNumberSInt64Type, (void *)(a3 + 88));
  CGCFDictionarySetInteger(Mutable, CFSTR("TagNodeType"), *(_DWORD *)(a3 + 32));
  v9 = (char *)(a3 + 40);
  if ((*(char *)(a3 + 63) & 0x80000000) == 0)
  {
    if (!*(_BYTE *)(a3 + 63))
      goto LABEL_11;
    goto LABEL_10;
  }
  if (*(_QWORD *)(a3 + 48))
  {
    v9 = *(char **)v9;
LABEL_10:
    CGCFDictionarySetCString(Mutable, CFSTR("ID"), v9);
  }
LABEL_11:
  v10 = *(const void **)(a3 + 160);
  if (v10)
    CFDictionarySetValue(Mutable, CFSTR("TagNodeProperties"), v10);
  v12 = *(const StructureElement ***)(a3 + 112);
  v11 = *(const StructureElement ***)(a3 + 120);
  while (v12 != v11)
  {
    if (*v12)
      BuildStructureTree(a1, Mutable, *v12);
    ++v12;
  }
  if (a2)
  {
    Value = (void *)CFDictionaryGetValue(a2, CFSTR("TagNodeChildren"));
    if (!Value)
    {
      Value = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
      CFDictionarySetValue(a2, CFSTR("TagNodeChildren"), Value);
      CFRelease(Value);
    }
    CFArrayAppendValue((CFMutableArrayRef)Value, Mutable);
    CFRelease(Mutable);
  }
  return Mutable;
}

void sub_184C857C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_184C85DC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_184C85ED0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_184C85F7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_184C8619C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_184C86328(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

char *__assign_helper_atomic_property_(char *result, uint64_t a2)
{
  if (result != (char *)a2)
    return std::vector<PageLayout::TextLine>::__assign_with_size[abi:se180100]<PageLayout::TextLine*,PageLayout::TextLine*>(result, *(char **)a2, *(_QWORD *)(a2 + 8), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
  return result;
}

char *std::vector<PageLayout::TextLine>::__assign_with_size[abi:se180100]<PageLayout::TextLine*,PageLayout::TextLine*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void **v13;
  char *v14;
  _BYTE *v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (0x8E38E38E38E38E39 * ((v8 - *(_QWORD *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x38E38E38E38E38ELL)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v10 = 0x8E38E38E38E38E39 * (v8 >> 3);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0x1C71C71C71C71C7)
      v12 = 0x38E38E38E38E38ELL;
    else
      v12 = v11;
    result = std::vector<PageLayout::TextLine>::__vallocate[abi:se180100](v7, v12);
    v14 = (char *)v7[1];
    v13 = (void **)(v7 + 1);
    v9 = v14;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v13 = (void **)(result + 8);
  v15 = (_BYTE *)*((_QWORD *)result + 1);
  if (0x8E38E38E38E38E39 * ((v15 - v9) >> 3) >= a4)
    goto LABEL_16;
  v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v15 - v9);
    v9 = (char *)*v13;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v13 = &v9[v17];
  return result;
}

char *std::vector<PageLayout::TextLine>::__vallocate[abi:se180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x38E38E38E38E38FLL)
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  result = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

_QWORD *__copy_helper_atomic_property_(_QWORD *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<PageLayout::TextLine>::__init_with_size[abi:se180100]<PageLayout::TextLine*,PageLayout::TextLine*>(a1, *(const void **)a2, *(_QWORD *)(a2 + 8), 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
}

_QWORD *std::vector<PageLayout::TextLine>::__init_with_size[abi:se180100]<PageLayout::TextLine*,PageLayout::TextLine*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<PageLayout::TextLine>::__vallocate[abi:se180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184C86610(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_184C8670C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_184C86804(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void PageLayout::splitLines(_QWORD *a1, int a2, uint64_t **a3, double a4, double a5, __n128 a6, double a7, double a8, double a9, __n128 a10)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t i;
  unint64_t v24;
  unint64_t v25;
  double *v26;
  double width;
  double *v28;
  double *v29;
  unint64_t v30;
  unint64_t v31;
  double *v32;
  double *v33;
  double v34;
  _BOOL4 v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double x;
  double v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  double v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  _BOOL4 v53;
  double v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  char *v60;
  _BYTE *v61;
  char *v62;
  char *v63;
  uint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  size_t v68;
  char *v69;
  __n128 *v70;
  __n128 v71;
  __n128 v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  char *v76;
  uint64_t v77;
  char *v78;
  unint64_t v79;
  char *v80;
  char *v81;
  int64_t v82;
  uint64_t v83;
  uint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  char *v88;
  __int128 v89;
  __int128 v90;
  char *v91;
  _BYTE *v92;
  uint64_t v93;
  void *v94;
  uint64_t **v95;
  uint64_t *v96;
  uint64_t **v97;
  unint64_t v98;
  uint64_t *v99;
  unint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t **v103;
  uint64_t *v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  uint64_t v117;
  __n128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  __n128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  CGRect v127;
  CGRect v128;
  CGRect v129;
  CGRect v130;
  CGRect v131;
  CGRect v132;
  CGRect v133;
  CGRect v134;
  CGRect v135;

  v10 = a1[5] - a1[4];
  if (v10)
  {
    v11 = 0;
    if (a2)
      v12 = 1;
    else
      v12 = 2;
    v103 = a3 + 1;
    v106 = 0x8E38E38E38E38E39 * (v10 >> 3);
    v107 = v12;
    do
    {
      v13 = a1[4];
      if (0x8E38E38E38E38E39 * ((a1[5] - v13) >> 3) <= v11)
        goto LABEL_107;
      while (1)
      {
        v109 = v13;
        v110 = v11;
        v108 = (uint64_t *)(v13 + 72 * v11);
        v14 = v108[1];
        if (v14 < 2)
          break;
        v15 = 0;
        v16 = a1[10] + 8 * *v108;
        v17 = 8 * v14;
        v18 = (int *)v16;
        do
        {
          v19 = *v18;
          v18 += 2;
          v15 += v19;
          v17 -= 8;
        }
        while (v17);
        if (v14 > v15)
          break;
        v117 = a1[13] + 32 * *v108;
        v20 = v15;
        v21 = v13 + 72 * v110;
        v122 = a1[7] + 2 * *(_QWORD *)(v21 + 16);
        v113 = v15;
        v105 = (uint64_t *)(v21 + 16);
        v22 = 0;
        for (i = 0; i != v107; v22 += *(_QWORD *)(v16 + 8 * i++))
          ;
        if (v107 >= v14 - v107 || v22 >= v20)
          break;
        v24 = v107;
        if (v107 <= v14)
          v25 = v108[1];
        else
          v25 = v107;
        v111 = v25;
        while (1)
        {
          if (*(_WORD *)(v122 + 2 * v22) != 32)
            goto LABEL_42;
          if (v14 <= v24)
            goto LABEL_107;
          v26 = (double *)(v117 + 32 * v24);
          width = v26[2];
          if (width > NAN + NAN)
            break;
          v29 = (double *)a1[57];
          v28 = (double *)a1[58];
          if (v28 != v29)
          {
            v30 = 0xAAAAAAAAAAAAAAABLL * (v28 - v29);
            do
            {
              v31 = v30 >> 1;
              v32 = &v29[3 * (v30 >> 1)];
              v34 = *v32;
              v33 = v32 + 3;
              v30 += ~(v30 >> 1);
              if (v34 < *v26)
                v29 = v33;
              else
                v30 = v31;
            }
            while (v30);
          }
          if (v29 != v28)
          {
            x = *v26;
            v44 = v26[3];
            v35 = v44 < 0.0 || width < 0.0;
            do
            {
              v36 = *v29;
              if (v35)
              {
                v127.origin.y = v26[1];
                v127.origin.x = x;
                v127.size.width = width;
                v127.size.height = v44;
                *(CGRect *)(&a6 - 1) = CGRectStandardize(v127);
                if (v36 >= v37 + a6.n128_f64[0])
                  break;
                v38 = v29[2];
                v43 = v26[1];
                v128.origin.x = x;
                v128.origin.y = v43;
                v128.size.width = width;
                v128.size.height = v44;
                *(CGRect *)(&a6 - 1) = CGRectStandardize(v128);
                if (v38 >= v39 + v40)
                {
                  v41 = v29[1];
                  v129.origin.x = x;
                  v129.origin.y = v43;
                  v129.size.width = width;
                  v129.size.height = v44;
                  *(CGRect *)(&a6 - 1) = CGRectStandardize(v129);
                  goto LABEL_40;
                }
              }
              else
              {
                if (v36 >= x + width)
                  break;
                v43 = v26[1];
                if (v29[2] >= v43 + v44)
                {
                  v41 = v29[1];
                  v130.origin.y = v26[1];
LABEL_40:
                  if (v41 <= v130.origin.y)
                    goto LABEL_46;
                }
              }
              v29 += 3;
            }
            while (v29 != v28);
          }
LABEL_42:
          if (v24 == v111)
            goto LABEL_107;
          if (v24 + 1 < v14 - v107)
          {
            v22 += *(_QWORD *)(v16 + 8 * v24++);
            if (v22 < v113)
              continue;
          }
          goto LABEL_105;
        }
        x = *v26;
        v43 = v26[1];
        v44 = v26[3];
LABEL_46:
        v26[2] = 0.0;
        v45 = v109 + 72 * v110;
        v47 = *(double *)(v45 + 40);
        v46 = v45 + 40;
        v48 = v47;
        v49 = *(double *)(v46 - 16);
        a6.n128_u64[0] = *(_QWORD *)(v46 - 8);
        a10.n128_u64[0] = *(_QWORD *)(v46 + 8);
        v50 = *v108;
        v51 = v108[1];
        v52 = v24 + 1;
        v108[1] = v24 + 1;
        v53 = v44 < 0.0 || width < 0.0;
        v54 = x;
        v118 = a6;
        v123 = a10;
        if (v53)
        {
          v131.origin.x = x;
          v131.origin.y = v43;
          v131.size.width = width;
          v131.size.height = v44;
          *(_QWORD *)&v54 = (unint64_t)CGRectStandardize(v131);
          a6 = v118;
          a10 = v123;
        }
        *(double *)v46 = v54 - v49;
        v55 = *v105;
        if (v53)
        {
          v132.origin.x = x;
          v132.origin.y = v43;
          v132.size.width = width;
          v132.size.height = v44;
          v133 = CGRectStandardize(v132);
          x = v133.origin.x;
          width = v133.size.width;
          a6 = v118;
          a10 = v123;
        }
        if (v48 < 0.0 || a10.n128_f64[0] < 0.0)
        {
          v134.origin.x = v49;
          *(_QWORD *)&v134.origin.y = a6.n128_u64[0];
          v134.size.width = v48;
          *(_QWORD *)&v134.size.height = a10.n128_u64[0];
          v135 = CGRectStandardize(v134);
          v49 = v135.origin.x;
          v48 = v135.size.width;
          a6 = v118;
          a10 = v123;
        }
        *(_QWORD *)&v56 = v52 + v50;
        *((_QWORD *)&v56 + 1) = v51 - v52;
        v57 = v22 + v55 + 1;
        *(double *)&v59 = v49 + v48 - (x + width);
        *(double *)&v58 = x + width;
        *((_QWORD *)&v58 + 1) = a6.n128_u64[0];
        *((_QWORD *)&v59 + 1) = a10.n128_u64[0];
        v61 = (_BYTE *)a1[4];
        v60 = (char *)a1[5];
        v62 = &v61[72 * v110];
        v63 = v62 + 72;
        v64 = (uint64_t *)(v109 + 72 * v110 + 56);
        v65 = a1[2];
        a1[2] = v65 + 1;
        v66 = a1[6];
        if ((unint64_t)v60 < v66)
        {
          v67 = *v64;
          if (v63 == v60)
          {
            *(_OWORD *)(v62 + 72) = v56;
            *((_QWORD *)v62 + 11) = v57;
            *((_OWORD *)v62 + 6) = v58;
            *((_OWORD *)v62 + 7) = v59;
            *((_QWORD *)v62 + 16) = v67;
            *((_QWORD *)v62 + 17) = v65;
            a1[5] = v62 + 144;
            v79 = v110;
          }
          else
          {
            v68 = v60 - (v62 + 144);
            v69 = &v63[v68];
            v70 = (__n128 *)v60;
            while (v69 < v60)
            {
              *v70 = *(__n128 *)v69;
              v71 = *((__n128 *)v69 + 1);
              v72 = *((__n128 *)v69 + 2);
              a6 = *((__n128 *)v69 + 3);
              v70[4].n128_u64[0] = *((_QWORD *)v69 + 8);
              v70[2] = v72;
              v70[3] = a6;
              v70[1] = v71;
              v69 += 72;
              v70 = (__n128 *)((char *)v70 + 72);
            }
            a1[5] = v70;
            v79 = v110;
            if (v60 != v62 + 144)
            {
              v120 = v59;
              v125 = v56;
              v115 = v58;
              memmove(v62 + 144, v62 + 72, v68);
              v58 = v115;
              v59 = v120;
              v56 = v125;
            }
            *(_OWORD *)(v62 + 72) = v56;
            *((_QWORD *)v62 + 11) = v57;
            *((_OWORD *)v62 + 6) = v58;
            *((_OWORD *)v62 + 7) = v59;
            *((_QWORD *)v62 + 16) = v67;
            *((_QWORD *)v62 + 17) = v65;
          }
          goto LABEL_88;
        }
        v73 = 0x8E38E38E38E38E39 * ((v60 - v61) >> 3) + 1;
        if (v73 > 0x38E38E38E38E38ELL)
LABEL_108:
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v74 = 0x8E38E38E38E38E39 * ((uint64_t)(v66 - (_QWORD)v61) >> 3);
        if (2 * v74 > v73)
          v73 = 2 * v74;
        if (v74 >= 0x1C71C71C71C71C7)
          v75 = 0x38E38E38E38E38ELL;
        else
          v75 = v73;
        if (v75)
        {
          v119 = v59;
          v124 = v56;
          v114 = v58;
          v76 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v75);
          v58 = v114;
          v59 = v119;
          v56 = v124;
          v78 = v76;
        }
        else
        {
          v78 = 0;
          v77 = 0;
        }
        v80 = &v78[8 * ((v63 - v61) >> 3)];
        v81 = &v78[72 * v77];
        if (0x8E38E38E38E38E39 * ((v63 - v61) >> 3) == v77)
        {
          if (v63 - v61 >= 1)
          {
            v82 = 0x8E38E38E38E38E39 * ((8 * ((v63 - v61) >> 3)) >> 3);
            if (v82 >= -1)
              v83 = v82 + 1;
            else
              v83 = v82 + 2;
            v80 -= 72 * (v83 >> 1);
            goto LABEL_80;
          }
          v116 = v58;
          v121 = v59;
          v126 = v56;
          if (v63 == v61)
            v100 = 1;
          else
            v100 = 0x1C71C71C71C71C72 * ((v63 - v61) >> 3);
          v101 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v100);
          v80 = &v101[72 * (v100 >> 2)];
          v81 = &v101[72 * v102];
          v79 = v110;
          if (v78)
            operator delete(v78);
          v59 = v121;
          v56 = v126;
          v58 = v116;
          if (!v80)
          {
LABEL_107:
            __break(1u);
            goto LABEL_108;
          }
        }
        else
        {
LABEL_80:
          v79 = v110;
          if (!v80)
            goto LABEL_107;
        }
        v84 = *v64;
        *(_OWORD *)v80 = v56;
        *((_QWORD *)v80 + 2) = v57;
        *(_OWORD *)(v80 + 24) = v58;
        *(_OWORD *)(v80 + 40) = v59;
        *((_QWORD *)v80 + 7) = v84;
        *((_QWORD *)v80 + 8) = v65;
        v85 = (char *)a1[4];
        v86 = v80;
        if (v85 != v63)
        {
          v87 = v63;
          v88 = v80;
          do
          {
            *(_OWORD *)(v88 - 72) = *(_OWORD *)(v87 - 72);
            v89 = *(_OWORD *)(v87 - 56);
            v90 = *(_OWORD *)(v87 - 40);
            a6 = *(__n128 *)(v87 - 24);
            v86 = v88 - 72;
            *((_QWORD *)v88 - 1) = *((_QWORD *)v87 - 1);
            *(__n128 *)(v88 - 24) = a6;
            *(_OWORD *)(v88 - 40) = v90;
            *(_OWORD *)(v88 - 56) = v89;
            v87 -= 72;
            v88 -= 72;
          }
          while (v87 != v85);
        }
        v91 = v80 + 72;
        v92 = (_BYTE *)a1[5];
        v93 = v92 - v63;
        if (v92 != v63)
          memmove(v91, v63, v92 - v63);
        v94 = (void *)a1[4];
        a1[4] = v86;
        a1[5] = &v91[v93];
        a1[6] = v81;
        if (v94)
          operator delete(v94);
LABEL_88:
        v11 = v79 + 1;
        if (a3)
        {
          v95 = v103;
          while (1)
          {
            v96 = *v95;
            v97 = v95;
            if (!*v95)
              break;
            while (1)
            {
              v95 = (uint64_t **)v96;
              v98 = v96[4];
              if (v11 < v98)
                break;
              if (v98 > v79)
                goto LABEL_96;
              v96 = v95[1];
              if (!v96)
              {
                v97 = v95 + 1;
                goto LABEL_95;
              }
            }
          }
LABEL_95:
          v99 = (uint64_t *)operator new(0x28uLL);
          v99[4] = v11;
          std::__tree<unsigned long>::__insert_node_at(a3, (uint64_t)v95, v97, v99);
        }
LABEL_96:
        ++v106;
        v13 = a1[4];
        if (0x8E38E38E38E38E39 * ((a1[5] - v13) >> 3) <= v11)
          goto LABEL_107;
      }
LABEL_105:
      v11 = v110 + 1;
    }
    while (v110 + 1 < v106);
  }
}

void sub_184C871A8(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

id PageLayout::getOrderedLayout(PageLayout *this)
{
  void *v1;
  id v2;
  PDFCTLDDelegateForLines *v4;
  void *v5;
  CGRect v7;
  _OWORD v8[2];
  CGFloat x;
  double v10;
  CGRect BoxRect;

  v1 = (void *)*((_QWORD *)this + 40);
  if (v1)
  {
    v2 = v1;
  }
  else
  {
    BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(_QWORD *)this, kCGPDFCropBox);
    v8[0] = vmulq_n_f64((float64x2_t)xmmword_185004990, BoxRect.size.width);
    v8[1] = vmulq_n_f64((float64x2_t)xmmword_185004A20, -BoxRect.size.height);
    x = BoxRect.origin.x;
    v10 = BoxRect.origin.y + BoxRect.size.height;
    v4 = -[PDFCTLDDelegateForLines initWithPageLayout:quadToPageTransform:]([PDFCTLDDelegateForLines alloc], "initWithPageLayout:quadToPageTransform:", this, v8);
    PageLayout::createAtomicElements(this, &v7);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    PageLayout::getOrderedLayout((uint64_t)this, v5, v4, v7.origin.x, v7.origin.y, v7.size.width, v7.size.height);
    v2 = (id)objc_claimAutoreleasedReturnValue();

  }
  return v2;
}

void sub_184C872B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<PageLayoutFactory::TextChunk>::__destroy_vector::operator()[abi:se180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 232;
        std::__destroy_at[abi:se180100]<PageLayoutFactory::TextChunk,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>,std::__unordered_map_hasher<applesauce::CF::ObjectRef<CGFont *>,std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>,std::hash<applesauce::CF::ObjectRef<CGFont *>>,std::equal_to<applesauce::CF::ObjectRef<CGFont *>>,true>,std::__unordered_map_equal<applesauce::CF::ObjectRef<CGFont *>,std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>,std::equal_to<applesauce::CF::ObjectRef<CGFont *>>,std::hash<applesauce::CF::ObjectRef<CGFont *>>,true>,std::allocator<std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>>>::~__hash_table(uint64_t a1)
{
  const void **v2;
  const void **v3;
  void *v4;

  v2 = *(const void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (const void **)*v2;
      std::__destroy_at[abi:se180100]<std::pair<applesauce::CF::ObjectRef<CGFont *> const,double>,0>(v2 + 2);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table(uint64_t a1)
{
  id *v2;
  id *v3;
  void *v4;

  v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (id *)*v2;

      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:se180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0)
          operator delete(*(v4 - 4));
        v4 -= 4;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:se180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 24;
        std::__destroy_at[abi:se180100]<PageLayout::CharacterStyle,0>(v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

id PageLayout::createAtomicElements(PageLayout *this, CGRect *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  CGFloat v7;
  double v8;
  double v9;
  double v10;
  double v11;
  unint64_t v12;
  __double2 v13;
  _BOOL4 v14;
  CGFloat v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  uint64_t *v21;
  void *v22;
  double v23;
  double v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat v27;
  CGFloat v28;
  CGFloat v29;
  uint64_t *v30;
  CGFloat v31;
  CGFloat v32;
  CGFloat v33;
  CGFloat v34;
  PDFTextLineElement *v35;
  PDFAtomicElement *v36;
  uint64_t v37;
  id v38;
  CGSize v39;
  CGFloat y;
  CGFloat x;
  double d;
  double c;
  double b;
  double a;
  double width;
  double height;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  CGFloat v60;
  CGFloat v61;
  _QWORD v62[4];
  id v63;
  uint64_t *v64;
  CGAffineTransform v65;
  CGFloat v66;
  CGFloat v67;
  double v68;
  double v69;
  TextLine v70;
  $5CFEE62CA76FAE445C6F9DBCEE669C70 v71;
  unint64_t v72;
  double v73;
  CGFloat v74;
  double v75;
  CGFloat v76;
  double v77;
  unint64_t v78;
  CGAffineTransform v79;
  CGAffineTransform v80;
  $5CFEE62CA76FAE445C6F9DBCEE669C70 v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  __n128 (*v86)(uint64_t, uint64_t);
  uint64_t (*v87)();
  const char *v88;
  __int128 v89;
  __int128 v90;
  CGAffineTransform v91;
  CGAffineTransform v92;
  CGRect BoxRect;
  CGRect v94;
  CGRect v95;
  CGRect v96;
  CGRect v97;
  CGRect v98;
  CGRect v99;
  CGRect v100;
  CGRect v101;
  CGRect v102;
  CGRect v103;
  CGRect v104;
  CGRect v105;
  CGRect v106;
  CGRect v107;
  CGRect v108;
  CGRect v109;

  v4 = (void *)objc_opt_new();
  BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(_QWORD *)this, kCGPDFCropBox);
  y = BoxRect.origin.y;
  height = BoxRect.size.height;
  memset(&v92, 0, sizeof(v92));
  width = BoxRect.size.width;
  *(float64x2_t *)&v91.a = vmulq_n_f64((float64x2_t)xmmword_185004990, BoxRect.size.width);
  *(float64x2_t *)&v91.c = vmulq_n_f64((float64x2_t)xmmword_185004A20, -BoxRect.size.height);
  x = BoxRect.origin.x;
  v91.tx = BoxRect.origin.x;
  v91.ty = BoxRect.origin.y + BoxRect.size.height;
  CGAffineTransformInvert(&v92, &v91);
  v83 = 0;
  v84 = &v83;
  v85 = 0x5012000000;
  v86 = __Block_byref_object_copy__67_10556;
  v87 = __Block_byref_object_dispose__68_10557;
  v88 = "";
  v89 = 0u;
  v90 = 0u;
  v5 = *((_QWORD *)this + 4);
  v6 = *((_QWORD *)this + 5);
  if (v5 != v6)
  {
    d = v92.d;
    c = v92.c;
    b = v92.b;
    a = v92.a;
    v56 = v92.d * 0.0 + v92.b * 0.0 + v92.ty;
    v57 = v92.tx + v92.c * 0.0 + v92.a * 0.0;
    do
    {
      v81 = *($5CFEE62CA76FAE445C6F9DBCEE669C70 *)v5;
      v82 = *(_QWORD *)(v5 + 16);
      v8 = *(double *)(v5 + 24);
      v7 = *(double *)(v5 + 32);
      v10 = *(double *)(v5 + 40);
      v9 = *(double *)(v5 + 48);
      v11 = *(double *)(v5 + 56);
      v12 = *(_QWORD *)(v5 + 64);
      v60 = v9;
      v61 = v7;
      v59 = v11;
      if (v11 == 0.0)
      {
        v79 = v92;
        v99.origin.x = v8;
        v99.origin.y = v7;
        v99.size.width = v10;
        v99.size.height = v9;
        v100 = CGRectApplyAffineTransform(v99, &v79);
        v17 = v100.origin.x;
        v18 = v100.origin.y;
        v19 = v100.size.width;
        v20 = v100.size.height;
        v21 = v84;
        *(CGRect *)(v21 + 6) = CGRectUnion(*(CGRect *)(v84 + 6), v100);
        v22 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v17, v18, v19, v20, width, height);
      }
      else
      {
        v13 = __sincos_stret(v11);
        v14 = v9 < 0.0 || v10 < 0.0;
        v58 = v8;
        v15 = v7;
        v16 = v9;
        if (v14)
        {
          v94.origin.x = v8;
          v94.origin.y = v7;
          v94.size.width = v10;
          v94.size.height = v9;
          *(_QWORD *)&v58 = (unint64_t)CGRectStandardize(v94);
          v95.origin.x = v8;
          v95.origin.y = v7;
          v95.size.width = v10;
          v95.size.height = v9;
          *(CGRect *)(&v15 - 1) = CGRectStandardize(v95);
        }
        v54 = v16;
        v55 = v15;
        if (v14)
        {
          v96.origin.x = v8;
          v96.origin.y = v7;
          v96.size.width = v10;
          v96.size.height = v9;
          v97 = CGRectStandardize(v96);
          v53 = v97.origin.x + v97.size.width;
          v97.origin.x = v8;
          v97.origin.y = v7;
          v97.size.width = v10;
          v97.size.height = v9;
          v98 = CGRectStandardize(v97);
          v51 = v98.size.height;
          v52 = v98.origin.y;
        }
        else
        {
          v52 = v7;
          v53 = v8 + v10;
          v51 = v9;
        }
        if (v14)
        {
          v101.origin.x = v8;
          v101.origin.y = v7;
          v101.size.width = v10;
          v101.size.height = v9;
          v102 = CGRectStandardize(v101);
          v50 = v102.origin.x + v102.size.width;
          v102.origin.x = v8;
          v102.origin.y = v7;
          v102.size.width = v10;
          v102.size.height = v9;
          v103 = CGRectStandardize(v102);
          v49 = v103.origin.y;
        }
        else
        {
          v49 = v7;
          v50 = v8 + v10;
        }
        v23 = v8;
        v24 = v7;
        if (v14)
        {
          v104.origin.x = v8;
          v104.origin.y = v7;
          v104.size.width = v10;
          v104.size.height = v9;
          *(_QWORD *)&v23 = (unint64_t)CGRectStandardize(v104);
          v105.origin.x = v8;
          v105.origin.y = v7;
          v105.size.width = v10;
          v105.size.height = v9;
          v106 = CGRectStandardize(v105);
          v24 = v106.origin.y;
        }
        v25 = v10;
        v26 = v13.__sinval * c + v13.__cosval * a;
        v27 = v13.__sinval * d + v13.__cosval * b;
        v28 = v13.__cosval * c - v13.__sinval * a;
        v29 = v13.__cosval * d - v13.__sinval * b;
        v22 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedTopLeft:topRight:bottomRight:bottomLeft:size:", v57 + (v55 + v54) * v28 + v26 * v58, v56 + (v55 + v54) * v29 + v27 * v58, v57 + (v52 + v51) * v28 + v26 * v53, v56 + (v52 + v51) * v29 + v27 * v53, v57 + v49 * v28 + v26 * v50, v56 + v49 * v29 + v27 * v50, v57 + v24 * v28 + v26 * v23, v56 + v24 * v29 + v27 * v23, *(_QWORD *)&width, *(_QWORD *)&height);
        v80.a = v26;
        v80.b = v27;
        v80.c = v28;
        v80.d = v29;
        v80.tx = v57;
        v80.ty = v56;
        v30 = v84;
        v31 = *((double *)v84 + 6);
        v32 = *((double *)v84 + 7);
        v33 = *((double *)v84 + 8);
        v34 = *((double *)v84 + 9);
        v107.origin.x = v8;
        v107.size.height = v60;
        v107.origin.y = v61;
        v10 = v25;
        v107.size.width = v25;
        v109 = CGRectApplyAffineTransform(v107, &v80);
        v108.origin.x = v31;
        v108.origin.y = v32;
        v108.size.width = v33;
        v108.size.height = v34;
        *(CGRect *)(v30 + 6) = CGRectUnion(v108, v109);
      }
      v35 = [PDFTextLineElement alloc];
      v71 = v81;
      v72 = v82;
      v73 = v8;
      v74 = v61;
      v75 = v10;
      v76 = v60;
      v77 = v59;
      v78 = v12;
      v36 = -[PDFTextLineElement initWithTextLine:boundingBox:](v35, "initWithTextLine:boundingBox:", &v71, v22);
      v70.textRange = v81;
      v70.uniCharStart = v82;
      v70.bbox.origin.x = v8;
      v70.bbox.origin.y = v61;
      v70.bbox.size.width = v10;
      v70.bbox.size.height = v60;
      v70.rotation = v59;
      v70.identifier = v12;
      PageLayout::addCTLDMapping(this, &v70, v36);
      objc_msgSend(v4, "addObject:", v36);

      v5 += 72;
    }
    while (v5 != v6);
  }
  v37 = *(_QWORD *)this;
  v62[0] = MEMORY[0x1E0C809B0];
  v62[1] = 3221225472;
  v62[2] = ___ZN10PageLayout20createAtomicElementsEP6CGRect_block_invoke;
  v62[3] = &unk_1E165AAD0;
  v65 = v92;
  v64 = &v83;
  v66 = x;
  v67 = y;
  v68 = width;
  v69 = height;
  v38 = v4;
  v63 = v38;
  CGPDFPageEnumerateAnnotations(v37, (uint64_t)v62);
  if (a2)
  {
    v39 = (CGSize)*((_OWORD *)v84 + 4);
    a2->origin = (CGPoint)*((_OWORD *)v84 + 3);
    a2->size = v39;
  }

  _Block_object_dispose(&v83, 8);
  return v38;
}

void sub_184C87A94(_Unwind_Exception *a1)
{
  void *v1;

  _Block_object_dispose(&STACK[0x270], 8);

  _Unwind_Resume(a1);
}

void PageLayout::getOrderedLayout(uint64_t a1, void *a2, void *a3, double a4, double a5, double a6, double a7)
{
  double width;
  double height;
  PDFCRGroupRegion *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  void *v29;
  PDFCRGroupRegion *v30;
  void *v31;
  PDFCRGroupRegion *v32;
  void *v33;
  void *v34;
  _BOOL4 v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t j;
  uint64_t v40;
  PageLayout *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t k;
  void *v47;
  PDFCRGroupRegion *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  PDFCRGroupRegion *v52;
  id v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  unint64_t v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t *v63;
  uint64_t *v64;
  id v65;
  uint64_t *v66;
  uint64_t *v67;
  int8x8_t v68;
  unint64_t v69;
  uint8x8_t v70;
  uint64_t *v71;
  uint64_t *v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  id v77;
  char *v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  char *v85;
  uint64_t v86;
  char *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  char *v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  id v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  char *v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  __int128 v109;
  uint64_t v110;
  _OWORD *v111;
  char *v112;
  __int128 v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  __int128 v120;
  char *v121;
  char *v122;
  __int128 v123;
  __int128 v124;
  uint64_t v125;
  _OWORD *v126;
  char *v127;
  __int128 v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  char *v133;
  uint64_t v134;
  __int128 v135;
  char *v136;
  char *v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  void *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  char *v147;
  uint64_t v148;
  char *v149;
  uint64_t v150;
  __int128 v151;
  uint64_t v152;
  uint64_t v153;
  void *v154;
  uint64_t v155;
  unint64_t v156;
  unint64_t v157;
  char *v158;
  uint64_t v159;
  char *v160;
  uint64_t v161;
  __int128 v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  void *v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;
  unint64_t v171;
  unint64_t v172;
  uint64_t v173;
  char *v174;
  uint64_t v175;
  char *v176;
  __int16 v177;
  __int128 v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v184;
  __int128 v185;
  uint64_t v186;
  _QWORD *v187;
  _QWORD *v188;
  char *v189;
  uint64_t v190;
  char *v191;
  uint64_t v192;
  unint64_t v193;
  unint64_t v194;
  char *v195;
  uint64_t v196;
  char *v197;
  uint64_t v198;
  uint64_t v199;
  _QWORD *v200;
  unint64_t v201;
  uint64_t v202;
  _BOOL4 v203;
  uint64_t v204;
  void *v205;
  uint64_t v206;
  uint64_t v207;
  unint64_t v208;
  unint64_t v209;
  char *v210;
  uint64_t v211;
  char *v212;
  uint64_t v213;
  _QWORD *v214;
  __int128 v215;
  void *v216;
  int64_t v217;
  unint64_t v218;
  unint64_t v219;
  char *v220;
  uint64_t v221;
  char *v222;
  char *v223;
  char *v224;
  uint64_t v225;
  _QWORD *v226;
  void *v227;
  int64_t v228;
  unint64_t v229;
  unint64_t v230;
  char *v231;
  uint64_t v232;
  char *v233;
  char *v234;
  char *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  __int128 v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  void *v244;
  uint64_t v245;
  unint64_t v246;
  unint64_t v247;
  char *v248;
  uint64_t v249;
  uint64_t *v250;
  uint64_t v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  __int128 v257;
  void *v258;
  void *v259;
  void *v260;
  _QWORD *v261;
  void *v262;
  void *v263;
  uint64_t v264;
  id v265;
  void *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t ii;
  void *v270;
  void *v271;
  uint64_t *v272;
  uint64_t *v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  TextGrouping *v279;
  void *StringForStringRanges;
  TextGrouping *v281;
  uint64_t v282;
  void *v283;
  id v284;
  void *v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  void *v289;
  uint64_t v290;
  void *v291;
  void *v292;
  void *v293;
  void *v294;
  void *v295;
  uint64_t v296;
  uint64_t v297;
  void *v298;
  void *v299;
  void *v300;
  _QWORD *v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  void *v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  char *v309;
  uint64_t v310;
  char *v311;
  __int128 v312;
  __int128 v313;
  __int128 v314;
  char *v315;
  char *v316;
  char *v317;
  __int128 v318;
  __int128 v319;
  __int128 v320;
  id v321;
  void *v322;
  void *v323;
  PDFListItemElement *v324;
  PDFCRGroupRegion *v325;
  void *v326;
  void *v327;
  void *v328;
  unsigned int v329;
  unint64_t v330;
  std::logic_error *exception;
  uint64_t v332;
  uint64_t v333;
  void *v334;
  uint64_t v335;
  void *v336;
  void *v337;
  id v338;
  id v339;
  void *v340;
  id *location;
  uint64_t v342;
  id v343;
  unint64_t v344;
  id v345;
  uint64_t v346;
  uint64_t v347;
  char *v348;
  void *v349;
  _QWORD *v350;
  char *v351;
  uint64_t v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  __int128 v356;
  uint64_t v357;
  id v358;
  uint64_t v359;
  uint64_t m;
  uint64_t v361;
  unint64_t v362;
  id v363;
  id v364;
  char *v365;
  id v366;
  char *v367;
  id v368;
  char *v369;
  uint64_t v370;
  char *v371;
  id v372;
  char *v373;
  uint64_t v374;
  char *v375;
  uint64_t v376;
  void *v377;
  id obj;
  __int128 v379;
  char *v380;
  void *v381;
  __int128 v382;
  void *v383;
  id v384[2];
  id v385;
  uint64_t jj;
  uint64_t v387;
  __int128 v388;
  uint64_t v389;
  unint64_t v390;
  uint64_t v391;
  id v392[2];
  uint64_t v393;
  void *v394;
  uint64_t i;
  __int128 v396;
  __int128 v397;
  uint64_t n;
  uint64_t v399;
  id v400;
  __int128 v401;
  void *v402;
  __int128 v403;
  __int128 v404;
  __int128 v405;
  __int128 v406;
  __int128 v407;
  __int128 v408;
  __int128 v409;
  __int128 v410;
  __int128 v411;
  __int128 v412;
  __int128 v413;
  __int128 v414;
  unint64_t v415;
  void **v416;
  __int128 v417;
  __int128 v418;
  __int128 v419;
  __int128 v420;
  uint64_t v421;
  __int128 v422;
  __int128 v423;
  __int128 v424;
  __int128 v425;
  __int128 v426;
  __int128 v427;
  __int128 v428;
  __int128 v429;
  __int128 v430;
  __int128 v431;
  __int128 v432;
  __int128 v433;
  __int128 v434;
  __int128 v435;
  __int128 v436;
  __int128 v437;
  void *v438[2];
  __int128 v439;
  __int128 v440;
  __int128 v441;
  void *__p[2];
  __int128 v443;
  __int128 v444;
  __int128 v445;
  void *v446;
  void *v447;
  unint64_t v448;
  uint64_t v449;
  _BYTE v450[128];
  _BYTE v451[128];
  _BYTE v452[128];
  __int128 v453;
  __int128 v454;
  __int128 v455;
  __int128 v456;
  _OWORD v457[4];
  uint64_t v458;
  _OWORD v459[4];
  uint64_t v460;
  void *v461[2];
  _OWORD v462[7];
  _BYTE v463[128];
  _BYTE v464[128];
  uint64_t v465;
  CGRect BoxRect;

  v465 = *MEMORY[0x1E0C80C00];
  v338 = a2;
  v339 = a3;
  BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(_QWORD *)a1, kCGPDFCropBox);
  width = BoxRect.size.width;
  height = BoxRect.size.height;
  v377 = (void *)objc_msgSend(objc_alloc((Class)getCRCTLDClass()), "init");
  v340 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", a4, a5, a6, a7, width, height);
  v15 = -[PDFCRGroupRegion initWithBoundingQuad:layoutDirection:subregions:parent:]([PDFCRGroupRegion alloc], "initWithBoundingQuad:layoutDirection:subregions:parent:", v340, 1, 0, 0);
  v16 = *(void **)(a1 + 320);
  *(_QWORD *)(a1 + 320) = v15;

  v17 = objc_opt_new();
  v18 = *(void **)(a1 + 328);
  *(_QWORD *)(a1 + 328) = v17;

  v19 = (void *)objc_msgSend(objc_alloc((Class)getCRCTLDConfigClass()), "init");
  LODWORD(v20) = 0;
  objc_msgSend(v19, "setAngleThresholdForRotationCorrection:", v20);
  objc_msgSend(v19, "setFlatMergeJumps:", 0);
  objc_msgSend(v19, "setMaxRegions:", 60);
  objc_msgSend(v19, "setMaxQueueCapacity:", 0xFFFFFFFFLL);
  objc_msgSend(v19, "setNumLookupElements:", 40);
  objc_msgSend(v19, "setNumPointsForSegmentsIntersection:", 9);
  LODWORD(v21) = 8.0;
  objc_msgSend(v19, "setMinSubRectangleSize:", v21);
  LODWORD(v22) = 1035122882;
  objc_msgSend(v19, "setMinQuadrilateralRotation:", v22);
  LODWORD(v23) = 1065185444;
  objc_msgSend(v19, "setMinWhitespaceHeightForReadingOrder:", v23);
  LODWORD(v24) = 1063675494;
  objc_msgSend(v19, "setAllowedOverlap:", v24);
  LODWORD(v25) = 1045220557;
  objc_msgSend(v19, "setMinWhitespaceWidth:", v25);
  LODWORD(v26) = 1073993482;
  objc_msgSend(v19, "setMinWhitespaceHeight:", v26);
  LODWORD(v27) = 1081333514;
  objc_msgSend(v19, "setQualityHeightFactor:", v27);
  LODWORD(v28) = 1065688760;
  objc_msgSend(v19, "setQualityWidthFactor:", v28);
  objc_msgSend(v377, "groupAndOrderRegions:config:delegate:", v338, v19, v339);
  v29 = (void *)objc_claimAutoreleasedReturnValue();

  v413 = 0u;
  v414 = 0u;
  v411 = 0u;
  v412 = 0u;
  obj = v29;
  v391 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v411, v452, 16);
  if (v391)
  {
    v387 = *(_QWORD *)v412;
    do
    {
      for (i = 0; i != v391; ++i)
      {
        if (*(_QWORD *)v412 != v387)
          objc_enumerationMutation(obj);
        v400 = *(id *)(*((_QWORD *)&v411 + 1) + 8 * i);
        v30 = [PDFCRGroupRegion alloc];
        objc_msgSend(v400, "boundingQuad");
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = -[PDFCRGroupRegion initWithBoundingQuad:layoutDirection:subregions:parent:](v30, "initWithBoundingQuad:layoutDirection:subregions:parent:", v31, objc_msgSend(v400, "layoutDirection"), 0, *(_QWORD *)(a1 + 320));

        objc_msgSend(*(id *)(a1 + 320), "addChild:", v32);
        objc_msgSend(v400, "subregions");
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v33, "objectAtIndex:", 0);
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        v35 = objc_msgSend(v34, "type") == 6;

        if (v35)
        {
          -[PDFCRGroupRegion setType:](v32, "setType:", 7);
          v409 = 0u;
          v410 = 0u;
          v407 = 0u;
          v408 = 0u;
          objc_msgSend(v400, "subregions");
          v36 = (id)objc_claimAutoreleasedReturnValue();
          v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v407, v451, 16);
          if (v37)
          {
            v38 = *(_QWORD *)v408;
            do
            {
              for (j = 0; j != v37; ++j)
              {
                if (*(_QWORD *)v408 != v38)
                  objc_enumerationMutation(v36);
                v40 = *(_QWORD *)(*((_QWORD *)&v407 + 1) + 8 * j);
                -[PDFCRGroupRegion addChild:](v32, "addChild:", v40);
                objc_msgSend(*(id *)(a1 + 328), "addObject:", v40);
              }
              v37 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v407, v451, 16);
            }
            while (v37);
          }
        }
        else
        {
          objc_msgSend(v400, "subregions");
          v41 = (PageLayout *)objc_claimAutoreleasedReturnValue();
          PageLayout::createFineCTLDConfig(v41);
          v42 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v377, "groupAndOrderRegions:config:delegate:", v41, v42, 0);
          v43 = (void *)objc_claimAutoreleasedReturnValue();

          v405 = 0u;
          v406 = 0u;
          v403 = 0u;
          v404 = 0u;
          v36 = v43;
          v44 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v403, v450, 16);
          if (v44)
          {
            v45 = *(_QWORD *)v404;
            do
            {
              for (k = 0; k != v44; ++k)
              {
                if (*(_QWORD *)v404 != v45)
                  objc_enumerationMutation(v36);
                v47 = *(void **)(*((_QWORD *)&v403 + 1) + 8 * k);
                v48 = [PDFCRGroupRegion alloc];
                objc_msgSend(v47, "boundingQuad");
                v49 = (void *)objc_claimAutoreleasedReturnValue();
                v50 = objc_msgSend(v47, "layoutDirection");
                objc_msgSend(v47, "subregions");
                v51 = (void *)objc_claimAutoreleasedReturnValue();
                v52 = -[PDFCRGroupRegion initWithBoundingQuad:layoutDirection:subregions:parent:](v48, "initWithBoundingQuad:layoutDirection:subregions:parent:", v49, v50, v51, v32);

                -[PDFCRGroupRegion addChild:](v32, "addChild:", v52);
                objc_msgSend(*(id *)(a1 + 328), "addObject:", v52);

              }
              v44 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v403, v450, 16);
            }
            while (v44);
          }

        }
      }
      v391 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v411, v452, 16);
    }
    while (v391);
  }

  if (!objc_msgSend(*(id *)(a1 + 328), "count"))
    goto LABEL_343;
  v345 = objc_alloc_init(MEMORY[0x1E0CB37A0]);
  __p[1] = 0;
  __p[0] = 0;
  *(_QWORD *)&v443 = 0;
  v438[1] = 0;
  v438[0] = 0;
  *(_QWORD *)&v439 = 0;
  location = (id *)(a1 + 24);
  v344 = objc_msgSend(*(id *)(a1 + 24), "length");
  objc_msgSend(*(id *)(a1 + 328), "lastObject");
  v337 = (void *)objc_claimAutoreleasedReturnValue();
  v456 = 0u;
  v455 = 0u;
  v454 = 0u;
  v453 = 0u;
  v53 = *(id *)(a1 + 328);
  v334 = v53;
  v54 = objc_msgSend(v53, "countByEnumeratingWithState:objects:count:", &v453, v464, 16);
  if (v54)
  {
    v373 = 0;
    v375 = 0;
    v55 = 0;
    v369 = 0;
    v371 = 0;
    v365 = 0;
    v367 = 0;
    v348 = 0;
    v56 = 0;
    v57 = 0;
    v58 = *(_QWORD *)v454;
    v350 = (_QWORD *)(a1 + 336);
    v351 = 0;
    v379 = 0u;
    v382 = 0u;
    v356 = 0u;
    v396 = 0u;
    v401 = 0u;
    v388 = 0u;
    *(_OWORD *)v392 = 0u;
    *(_OWORD *)v384 = 0u;
    v332 = *(_QWORD *)v454;
    while (1)
    {
      v335 = 0;
      v333 = v54;
      do
      {
        if (*(_QWORD *)v454 != v58)
          objc_enumerationMutation(v53);
        v336 = *(void **)(*((_QWORD *)&v453 + 1) + 8 * v335);
        objc_msgSend(v336, "subregions");
        v59 = (void *)objc_claimAutoreleasedReturnValue();
        v419 = 0u;
        v420 = 0u;
        v417 = 0u;
        v418 = 0u;
        v343 = v59;
        v347 = objc_msgSend(v343, "countByEnumeratingWithState:objects:count:", &v417, v463, 16);
        if (v347)
        {
          v346 = *(_QWORD *)v418;
          do
          {
            for (m = 0; m != v347; ++m)
            {
              if (*(_QWORD *)v418 != v346)
                objc_enumerationMutation(v343);
              v358 = *(id *)(*((_QWORD *)&v417 + 1) + 8 * m);
              if (objc_msgSend(v358, "type") == 1)
              {
                if (v358)
                {
                  objc_msgSend(v358, "textLine");
                  v353 = (unint64_t)v461[0];
                  v349 = v461[1];
                  v60 = *(_QWORD *)&v462[0];
                  v461[0] = v351;
                  *(_QWORD *)&v462[0] = v57;
                  objc_msgSend(v358, "textLine");
                  v362 = (unint64_t)v349 + v353;
                  v61 = v462[3];
                  v62 = v460;
                }
                else
                {
                  v62 = 0;
                  v61 = 0;
                  v60 = 0;
                  v362 = 0;
                  v349 = 0;
                  v353 = 0;
                  v461[1] = 0;
                  memset((char *)v462 + 8, 0, 48);
                  v461[0] = v351;
                  *(_QWORD *)&v462[0] = v57;
                  memset(v459, 0, sizeof(v459));
                  v460 = 0;
                }
                v63 = std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(v350, v62);
                if (v63)
                {
                  v64 = v63;
                  v65 = (id)v63[3];
                  v66 = std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(v350, *((_DWORD *)v64 + 4));
                  if (v66)
                  {
                    v67 = v66;
                    v68 = *(int8x8_t *)(a1 + 344);
                    v69 = v66[1];
                    v70 = (uint8x8_t)vcnt_s8(v68);
                    v70.i16[0] = vaddlv_u8(v70);
                    if (v70.u32[0] > 1uLL)
                    {
                      if (v69 >= *(_QWORD *)&v68)
                        v69 %= *(_QWORD *)&v68;
                    }
                    else
                    {
                      v69 &= *(_QWORD *)&v68 - 1;
                    }
                    v71 = *(uint64_t **)(*v350 + 8 * v69);
                    do
                    {
                      v72 = v71;
                      v71 = (uint64_t *)*v71;
                    }
                    while (v71 != v66);
                    if (v72 == (uint64_t *)(a1 + 352))
                      goto LABEL_59;
                    v73 = v72[1];
                    if (v70.u32[0] > 1uLL)
                    {
                      if (v73 >= *(_QWORD *)&v68)
                        v73 %= *(_QWORD *)&v68;
                    }
                    else
                    {
                      v73 &= *(_QWORD *)&v68 - 1;
                    }
                    if (v73 != v69)
                    {
LABEL_59:
                      if (!*v66)
                        goto LABEL_60;
                      v74 = *(_QWORD *)(*v66 + 8);
                      if (v70.u32[0] > 1uLL)
                      {
                        if (v74 >= *(_QWORD *)&v68)
                          v74 %= *(_QWORD *)&v68;
                      }
                      else
                      {
                        v74 &= *(_QWORD *)&v68 - 1;
                      }
                      if (v74 != v69)
LABEL_60:
                        *(_QWORD *)(*v350 + 8 * v69) = 0;
                    }
                    v75 = *v66;
                    if (*v66)
                    {
                      v76 = *(_QWORD *)(v75 + 8);
                      if (v70.u32[0] > 1uLL)
                      {
                        if (v76 >= *(_QWORD *)&v68)
                          v76 %= *(_QWORD *)&v68;
                      }
                      else
                      {
                        v76 &= *(_QWORD *)&v68 - 1;
                      }
                      if (v76 != v69)
                      {
                        *(_QWORD *)(*v350 + 8 * v76) = v72;
                        v75 = *v66;
                      }
                    }
                    *v72 = v75;
                    *v66 = 0;
                    --*(_QWORD *)(a1 + 360);

                    operator delete(v67);
                  }
                  LODWORD(v434) = v61;
                  v77 = v65;
                  *((_QWORD *)&v434 + 1) = v77;
                  std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,PDFAtomicElement * {__strong}>>((uint64_t)v350, v61, (uint64_t)&v434);

                }
                v78 = (char *)*((_QWORD *)&v356 + 1);
                if (*((_QWORD *)&v356 + 1) >= (unint64_t)v348)
                {
                  v83 = 0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)&v356 + 1) - v356) >> 3) + 1;
                  if (v83 > 0x38E38E38E38E38ELL)
                    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                  if (0x1C71C71C71C71C72 * ((uint64_t)&v348[-v356] >> 3) > v83)
                    v83 = 0x1C71C71C71C71C72 * ((uint64_t)&v348[-v356] >> 3);
                  if (0x8E38E38E38E38E39 * ((uint64_t)&v348[-v356] >> 3) >= 0x1C71C71C71C71C7)
                    v84 = 0x38E38E38E38E38ELL;
                  else
                    v84 = v83;
                  if (!v84)
                    goto LABEL_464;
                  v85 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v84);
                  if (!v85)
                    goto LABEL_464;
                  v87 = &v85[8 * ((uint64_t)(*((_QWORD *)&v356 + 1) - v356) >> 3)];
                  *(_OWORD *)v87 = *(_OWORD *)v461;
                  v88 = v462[0];
                  v89 = v462[1];
                  v90 = v462[2];
                  *((_QWORD *)v87 + 8) = *(_QWORD *)&v462[3];
                  *((_OWORD *)v87 + 2) = v89;
                  *((_OWORD *)v87 + 3) = v90;
                  *((_OWORD *)v87 + 1) = v88;
                  v91 = v87;
                  if (*((_QWORD *)&v356 + 1) != (_QWORD)v356)
                  {
                    do
                    {
                      *(_OWORD *)(v91 - 72) = *(_OWORD *)(v78 - 72);
                      v92 = *(_OWORD *)(v78 - 56);
                      v93 = *(_OWORD *)(v78 - 40);
                      v94 = *(_OWORD *)(v78 - 24);
                      *((_QWORD *)v91 - 1) = *((_QWORD *)v78 - 1);
                      *(_OWORD *)(v91 - 24) = v94;
                      *(_OWORD *)(v91 - 40) = v93;
                      *(_OWORD *)(v91 - 56) = v92;
                      v91 -= 72;
                      v78 -= 72;
                    }
                    while (v78 != (char *)v356);
                    v78 = (char *)v356;
                  }
                  v348 = &v85[72 * v86];
                  v82 = (uint64_t)(v87 + 72);
                  *(_QWORD *)&v356 = v91;
                  if (v78)
                    operator delete(v78);
                }
                else
                {
                  if (!*((_QWORD *)&v356 + 1))
                    goto LABEL_464;
                  **((_OWORD **)&v356 + 1) = *(_OWORD *)v461;
                  v79 = v462[0];
                  v80 = v462[1];
                  v81 = v462[2];
                  *(_QWORD *)(*((_QWORD *)&v356 + 1) + 64) = *(_QWORD *)&v462[3];
                  *(_OWORD *)(*((_QWORD *)&v356 + 1) + 32) = v80;
                  *(_OWORD *)(*((_QWORD *)&v356 + 1) + 48) = v81;
                  *(_OWORD *)(*((_QWORD *)&v356 + 1) + 16) = v79;
                  v82 = *((_QWORD *)&v356 + 1) + 72;
                }
                *(_QWORD *)&v95 = v356;
                *((_QWORD *)&v95 + 1) = v82;
                v356 = v95;
                v457[2] = v462[1];
                v457[3] = v462[2];
                v458 = *(_QWORD *)&v462[3];
                v457[1] = v462[0];
                v457[0] = *(_OWORD *)v461;
                objc_msgSend(v358, "setTextLine:", v457);
                v96 = v353;
                if (v353 < v362)
                {
                  v98 = *(_QWORD *)(a1 + 80);
                  v97 = *(_QWORD *)(a1 + 88);
                  do
                  {
                    if (v96 >= (v97 - v98) >> 3)
LABEL_454:
                      std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
                    v99 = (char *)v392[1];
                    if (v392[1] >= v371)
                    {
                      v101 = v392[0];
                      v102 = ((char *)v392[1] - (char *)v392[0]) >> 3;
                      v103 = v102 + 1;
                      if ((unint64_t)(v102 + 1) >> 61)
                        goto LABEL_455;
                      if ((v371 - (char *)v392[0]) >> 2 > v103)
                        v103 = (v371 - (char *)v392[0]) >> 2;
                      if ((unint64_t)(v371 - (char *)v392[0]) >= 0x7FFFFFFFFFFFFFF8)
                        v104 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v104 = v103;
                      if (!v104)
                        goto LABEL_464;
                      v105 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v104);
                      if (!v105)
                        goto LABEL_464;
                      v107 = &v105[8 * v102];
                      *(_QWORD *)v107 = *(_QWORD *)(v98 + 8 * v96);
                      v100 = (uint64_t)(v107 + 8);
                      while (v99 != v392[0])
                      {
                        v108 = *((_QWORD *)v99 - 1);
                        v99 -= 8;
                        *((_QWORD *)v107 - 1) = v108;
                        v107 -= 8;
                      }
                      v371 = &v105[8 * v106];
                      v392[0] = v107;
                      if (v101)
                        operator delete(v101);
                    }
                    else
                    {
                      if (!v392[1])
                        goto LABEL_464;
                      *(_QWORD *)v392[1] = *(_QWORD *)(v98 + 8 * v96);
                      v100 = (uint64_t)v392[1] + 8;
                    }
                    *(id *)&v109 = v392[0];
                    *((_QWORD *)&v109 + 1) = v100;
                    *(_OWORD *)v392 = v109;
                    v110 = *(_QWORD *)(a1 + 104);
                    if (v96 >= (*(_QWORD *)(a1 + 112) - v110) >> 5)
                      goto LABEL_453;
                    v111 = (_OWORD *)(v110 + 32 * v96);
                    v112 = (char *)*((_QWORD *)&v388 + 1);
                    if (*((_QWORD *)&v388 + 1) >= (unint64_t)v369)
                    {
                      v115 = (uint64_t)(*((_QWORD *)&v388 + 1) - v388) >> 5;
                      v116 = v115 + 1;
                      if ((unint64_t)(v115 + 1) >> 59)
                        goto LABEL_456;
                      if ((uint64_t)&v369[-v388] >> 4 > v116)
                        v116 = (uint64_t)&v369[-v388] >> 4;
                      if ((unint64_t)&v369[-v388] >= 0x7FFFFFFFFFFFFFE0)
                        v117 = 0x7FFFFFFFFFFFFFFLL;
                      else
                        v117 = v116;
                      if (!v117)
                        goto LABEL_464;
                      v118 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v117);
                      if (!v118)
                        goto LABEL_464;
                      v120 = v111[1];
                      v121 = &v118[32 * v115];
                      *(_OWORD *)v121 = *v111;
                      *((_OWORD *)v121 + 1) = v120;
                      v122 = v121;
                      if (*((_QWORD *)&v388 + 1) != (_QWORD)v388)
                      {
                        do
                        {
                          v123 = *((_OWORD *)v112 - 1);
                          *((_OWORD *)v122 - 2) = *((_OWORD *)v112 - 2);
                          *((_OWORD *)v122 - 1) = v123;
                          v122 -= 32;
                          v112 -= 32;
                        }
                        while (v112 != (char *)v388);
                        v112 = (char *)v388;
                      }
                      v369 = &v118[32 * v119];
                      v114 = (uint64_t)(v121 + 32);
                      *(_QWORD *)&v388 = v122;
                      if (v112)
                        operator delete(v112);
                    }
                    else
                    {
                      if (!*((_QWORD *)&v388 + 1))
                        goto LABEL_464;
                      v113 = v111[1];
                      **((_OWORD **)&v388 + 1) = *v111;
                      *(_OWORD *)(*((_QWORD *)&v388 + 1) + 16) = v113;
                      v114 = *((_QWORD *)&v388 + 1) + 32;
                    }
                    *(_QWORD *)&v124 = v388;
                    *((_QWORD *)&v124 + 1) = v114;
                    v388 = v124;
                    v125 = *(_QWORD *)(a1 + 128);
                    if (v96 >= (*(_QWORD *)(a1 + 136) - v125) >> 5)
LABEL_453:
                      std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
                    v126 = (_OWORD *)(v125 + 32 * v96);
                    v127 = (char *)v384[1];
                    if (v384[1] >= v367)
                    {
                      v130 = ((char *)v384[1] - (char *)v384[0]) >> 5;
                      v131 = v130 + 1;
                      if ((unint64_t)(v130 + 1) >> 59)
LABEL_456:
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                      if ((v367 - (char *)v384[0]) >> 4 > v131)
                        v131 = (v367 - (char *)v384[0]) >> 4;
                      if ((unint64_t)(v367 - (char *)v384[0]) >= 0x7FFFFFFFFFFFFFE0)
                        v132 = 0x7FFFFFFFFFFFFFFLL;
                      else
                        v132 = v131;
                      if (!v132)
                        goto LABEL_464;
                      v133 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v132);
                      if (!v133)
                        goto LABEL_464;
                      v135 = v126[1];
                      v136 = &v133[32 * v130];
                      *(_OWORD *)v136 = *v126;
                      *((_OWORD *)v136 + 1) = v135;
                      v137 = v136;
                      if (v384[1] != v384[0])
                      {
                        do
                        {
                          v138 = *((_OWORD *)v127 - 1);
                          *((_OWORD *)v137 - 2) = *((_OWORD *)v127 - 2);
                          *((_OWORD *)v137 - 1) = v138;
                          v137 -= 32;
                          v127 -= 32;
                        }
                        while (v127 != v384[0]);
                        v127 = (char *)v384[0];
                      }
                      v367 = &v133[32 * v134];
                      v129 = (uint64_t)(v136 + 32);
                      v384[0] = v137;
                      if (v127)
                        operator delete(v127);
                    }
                    else
                    {
                      if (!v384[1])
                        goto LABEL_464;
                      v128 = v126[1];
                      *(_OWORD *)v384[1] = *v126;
                      *((_OWORD *)v384[1] + 1) = v128;
                      v129 = (uint64_t)v384[1] + 32;
                    }
                    *(id *)&v139 = v384[0];
                    *((_QWORD *)&v139 + 1) = v129;
                    *(_OWORD *)v384 = v139;
                    v140 = *(_QWORD *)(a1 + 272);
                    if (v96 >= (*(_QWORD *)(a1 + 280) - v140) >> 3)
                      goto LABEL_454;
                    v141 = *((_QWORD *)&v382 + 1);
                    if (*((_QWORD *)&v382 + 1) >= (unint64_t)v365)
                    {
                      v143 = (void *)v382;
                      v144 = (uint64_t)(*((_QWORD *)&v382 + 1) - v382) >> 3;
                      v145 = v144 + 1;
                      if ((unint64_t)(v144 + 1) >> 61)
                        goto LABEL_455;
                      if ((uint64_t)&v365[-v382] >> 2 > v145)
                        v145 = (uint64_t)&v365[-v382] >> 2;
                      if ((unint64_t)&v365[-v382] >= 0x7FFFFFFFFFFFFFF8)
                        v146 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v146 = v145;
                      if (!v146)
                        goto LABEL_464;
                      v147 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v146);
                      if (!v147)
                        goto LABEL_464;
                      v149 = &v147[8 * v144];
                      *(_QWORD *)v149 = *(_QWORD *)(v140 + 8 * v96);
                      v142 = (uint64_t)(v149 + 8);
                      while (v141 != (_QWORD)v382)
                      {
                        v150 = *(_QWORD *)(v141 - 8);
                        v141 -= 8;
                        *((_QWORD *)v149 - 1) = v150;
                        v149 -= 8;
                      }
                      v365 = &v147[8 * v148];
                      *(_QWORD *)&v382 = v149;
                      if (v143)
                        operator delete(v143);
                    }
                    else
                    {
                      if (!*((_QWORD *)&v382 + 1))
                        goto LABEL_464;
                      **((_QWORD **)&v382 + 1) = *(_QWORD *)(v140 + 8 * v96);
                      v142 = *((_QWORD *)&v382 + 1) + 8;
                    }
                    *(_QWORD *)&v151 = v382;
                    *((_QWORD *)&v151 + 1) = v142;
                    v382 = v151;
                    v152 = *((_QWORD *)&v396 + 1);
                    if (*((_QWORD *)&v396 + 1) >= (unint64_t)v373)
                    {
                      v154 = (void *)v396;
                      v155 = (uint64_t)(*((_QWORD *)&v396 + 1) - v396) >> 3;
                      v156 = v155 + 1;
                      if ((unint64_t)(v155 + 1) >> 61)
LABEL_455:
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                      if ((uint64_t)&v373[-v396] >> 2 > v156)
                        v156 = (uint64_t)&v373[-v396] >> 2;
                      if ((unint64_t)&v373[-v396] >= 0x7FFFFFFFFFFFFFF8)
                        v157 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v157 = v156;
                      if (!v157)
                        goto LABEL_464;
                      v158 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v157);
                      if (!v158)
                        goto LABEL_464;
                      v160 = &v158[8 * v155];
                      *(_QWORD *)v160 = v56;
                      v153 = (uint64_t)(v160 + 8);
                      while (v152 != (_QWORD)v396)
                      {
                        v161 = *(_QWORD *)(v152 - 8);
                        v152 -= 8;
                        *((_QWORD *)v160 - 1) = v161;
                        v160 -= 8;
                      }
                      v373 = &v158[8 * v159];
                      *(_QWORD *)&v396 = v160;
                      if (v154)
                        operator delete(v154);
                    }
                    else
                    {
                      if (!*((_QWORD *)&v396 + 1))
                        goto LABEL_464;
                      **((_QWORD **)&v396 + 1) = v56;
                      v153 = *((_QWORD *)&v396 + 1) + 8;
                    }
                    *(_QWORD *)&v162 = v396;
                    *((_QWORD *)&v162 + 1) = v153;
                    v396 = v162;
                    v98 = *(_QWORD *)(a1 + 80);
                    v97 = *(_QWORD *)(a1 + 88);
                    if (v96 >= (v97 - v98) >> 3)
LABEL_449:
                      std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
                    if (*(_QWORD *)(v98 + 8 * v96))
                    {
                      v163 = 0;
                      do
                      {
                        v164 = *(_QWORD *)(a1 + 56);
                        if (v60 >= (*(_QWORD *)(a1 + 64) - v164) >> 1)
                          std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
                        v165 = *((_QWORD *)&v401 + 1);
                        if (*((_QWORD *)&v401 + 1) >= (unint64_t)v55)
                        {
                          v167 = (void *)v401;
                          v168 = *((_QWORD *)&v401 + 1) - v401;
                          if ((uint64_t)(*((_QWORD *)&v401 + 1) - v401) <= -3)
                            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                          v169 = v55;
                          v170 = v168 >> 1;
                          v171 = (unint64_t)&v169[-v401];
                          if (v171 <= (v168 >> 1) + 1)
                            v172 = v170 + 1;
                          else
                            v172 = v171;
                          if (v171 >= 0x7FFFFFFFFFFFFFFELL)
                            v173 = 0x7FFFFFFFFFFFFFFFLL;
                          else
                            v173 = v172;
                          if (!v173)
                            goto LABEL_464;
                          v174 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<unsigned short>>(v173);
                          if (!v174)
                            goto LABEL_464;
                          v176 = &v174[2 * v170];
                          *(_WORD *)v176 = *(_WORD *)(v164 + 2 * v60);
                          v166 = (uint64_t)(v176 + 2);
                          while (v165 != (_QWORD)v401)
                          {
                            v177 = *(_WORD *)(v165 - 2);
                            v165 -= 2;
                            *((_WORD *)v176 - 1) = v177;
                            v176 -= 2;
                          }
                          v55 = &v174[2 * v175];
                          *(_QWORD *)&v401 = v176;
                          if (v167)
                            operator delete(v167);
                        }
                        else
                        {
                          if (!*((_QWORD *)&v401 + 1))
                            goto LABEL_464;
                          **((_WORD **)&v401 + 1) = *(_WORD *)(v164 + 2 * v60);
                          v166 = *((_QWORD *)&v401 + 1) + 2;
                        }
                        *(_QWORD *)&v178 = v401;
                        *((_QWORD *)&v178 + 1) = v166;
                        v401 = v178;
                        v98 = *(_QWORD *)(a1 + 80);
                        v97 = *(_QWORD *)(a1 + 88);
                        if (v96 >= (v97 - v98) >> 3)
                          goto LABEL_449;
                        ++v60;
                        ++v56;
                        ++v163;
                        ++v57;
                      }
                      while (v163 < *(_QWORD *)(v98 + 8 * v96));
                    }
                    ++v96;
                  }
                  while (v96 != v362);
                }
                v179 = *(_QWORD *)(a1 + 152);
                v180 = (*(_QWORD *)(a1 + 160) - v179) >> 3;
                if (v180 <= v353 || v180 <= v362)
                  std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
                v181 = *(_QWORD *)(v179 + 8 * v353);
                v182 = *(_QWORD *)(v179 + 8 * v362);
                if (v344 < v182 - v181 || v181 > v344 - (v182 - v181))
                {
                  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                  std::logic_error::logic_error(exception, "lineStringRange");
                  exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                  __cxa_throw(exception, (struct type_info *)off_1E1620B30, MEMORY[0x1E0DE42E0]);
                }
                objc_msgSend(*location, "substringWithRange:", v181);
                v363 = (id)objc_claimAutoreleasedReturnValue();
                v184 = objc_msgSend(v345, "length");
                objc_msgSend(v345, "appendString:", v363);
                v342 = v184;
                v354 = v182;
                if (v182 != v181)
                {
                  v186 = *(_QWORD *)(a1 + 200);
                  v187 = (_QWORD *)(v186 + 8 * v182);
                  v188 = (_QWORD *)(v186 + 8 * v181);
                  v185 = v379;
                  while (1)
                  {
                    v189 = (char *)*((_QWORD *)&v185 + 1);
                    v380 = (char *)v185;
                    if (*((_QWORD *)&v185 + 1) >= (unint64_t)v375)
                    {
                      v191 = (char *)v185;
                      v192 = (uint64_t)(*((_QWORD *)&v185 + 1) - v185) >> 3;
                      v193 = v192 + 1;
                      if ((unint64_t)(v192 + 1) >> 61)
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                      if ((uint64_t)&v375[-v185] >> 2 > v193)
                        v193 = (uint64_t)&v375[-v185] >> 2;
                      if ((unint64_t)&v375[-v185] >= 0x7FFFFFFFFFFFFFF8)
                        v194 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v194 = v193;
                      if (!v194)
                        goto LABEL_464;
                      v195 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v194);
                      if (!v195)
                        goto LABEL_464;
                      v197 = &v195[8 * v192];
                      *(_QWORD *)v197 = *v188;
                      v190 = (uint64_t)(v197 + 8);
                      while (v189 != v191)
                      {
                        v198 = *((_QWORD *)v189 - 1);
                        v189 -= 8;
                        *((_QWORD *)v197 - 1) = v198;
                        v197 -= 8;
                      }
                      v375 = &v195[8 * v196];
                      v380 = v197;
                      if (v191)
                        operator delete(v191);
                    }
                    else
                    {
                      if (!*((_QWORD *)&v185 + 1))
                        goto LABEL_464;
                      **((_QWORD **)&v185 + 1) = *v188;
                      v190 = *((_QWORD *)&v185 + 1) + 8;
                    }
                    *(_QWORD *)&v185 = v380;
                    *((_QWORD *)&v185 + 1) = v190;
                    if (++v188 == v187)
                      goto LABEL_222;
                  }
                }
                v185 = v379;
LABEL_222:
                v379 = v185;
                std::__unwrap_and_dispatch[abi:se180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<double *>,std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<double>>,0>((_QWORD *)(*(_QWORD *)(a1 + 224) + 8 * v181), (_QWORD *)(*(_QWORD *)(a1 + 224) + 8 * v354), __p);
                if (*(_BYTE *)(a1 + 8))
                {
                  v199 = *(_QWORD *)(a1 + 296);
                  v416 = v438;
                  if (v354 != v181)
                  {
                    v200 = (_QWORD *)(v199 + 8 * v181);
                    v201 = v342 - v181;
                    v202 = 8 * v354 - 8 * v181;
                    do
                    {
                      v415 = v201 + *v200;
                      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&v416, &v415);
                      ++v200;
                      v202 -= 8;
                    }
                    while (v202);
                  }
                }
                if (objc_msgSend(v363, "length"))
                  v203 = objc_msgSend(v363, "characterAtIndex:", objc_msgSend(v363, "length") - 1) == 10;
                else
                  v203 = 0;
                if (0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32)) >> 3) >= 2
                  && objc_msgSend(v345, "length")
                  && v354 == v344
                  && v336 != v337)
                {
                  objc_msgSend(v345, "appendString:", CFSTR("\n"));
                  v204 = *((_QWORD *)&v379 + 1);
                  v205 = (void *)v379;
                  if ((_QWORD)v379 == *((_QWORD *)&v379 + 1))
                    goto LABEL_464;
                  if (*((_QWORD *)&v379 + 1) >= (unint64_t)v375)
                  {
                    v207 = (uint64_t)(*((_QWORD *)&v379 + 1) - v379) >> 3;
                    v208 = v207 + 1;
                    if ((unint64_t)(v207 + 1) >> 61)
                      goto LABEL_461;
                    if ((uint64_t)&v375[-v379] >> 2 > v208)
                      v208 = (uint64_t)&v375[-v379] >> 2;
                    if ((unint64_t)&v375[-v379] >= 0x7FFFFFFFFFFFFFF8)
                      v209 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v209 = v208;
                    if (!v209)
                      goto LABEL_464;
                    v210 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v209);
                    if (!v210)
                      goto LABEL_464;
                    v375 = &v210[8 * v211];
                    v212 = &v210[8 * v207];
                    *(_QWORD *)v212 = *(_QWORD *)(*((_QWORD *)&v379 + 1) - 8);
                    v206 = (uint64_t)(v212 + 8);
                    do
                    {
                      v213 = *(_QWORD *)(v204 - 8);
                      v204 -= 8;
                      *((_QWORD *)v212 - 1) = v213;
                      v212 -= 8;
                    }
                    while (v204 != (_QWORD)v379);
                    *(_QWORD *)&v379 = v212;
                    if (v205)
                      operator delete(v205);
                  }
                  else
                  {
                    if (!*((_QWORD *)&v379 + 1))
                      goto LABEL_464;
                    **((_QWORD **)&v379 + 1) = *(_QWORD *)(*((_QWORD *)&v379 + 1) - 8);
                    v206 = *((_QWORD *)&v379 + 1) + 8;
                  }
                  v214 = __p[1];
                  if (__p[0] == __p[1])
                    goto LABEL_464;
                  *(_QWORD *)&v215 = v379;
                  *((_QWORD *)&v215 + 1) = v206;
                  v379 = v215;
                  if (__p[1] >= (void *)v443)
                  {
                    v217 = ((char *)__p[1] - (char *)__p[0]) >> 3;
                    if ((unint64_t)(v217 + 1) >> 61)
                      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                    v218 = (uint64_t)(v443 - (unint64_t)__p[0]) >> 2;
                    if (v218 <= v217 + 1)
                      v218 = v217 + 1;
                    if ((unint64_t)v443 - (unint64_t)__p[0] >= 0x7FFFFFFFFFFFFFF8)
                      v219 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v219 = v218;
                    if (!v219)
                      goto LABEL_464;
                    v220 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v219);
                    if (!v220)
                      goto LABEL_464;
                    v222 = &v220[8 * v217];
                    *(_QWORD *)v222 = *(v214 - 1);
                    v216 = v222 + 8;
                    v223 = (char *)__p[1];
                    v224 = (char *)__p[0];
                    while (v223 != v224)
                    {
                      v225 = *((_QWORD *)v223 - 1);
                      v223 -= 8;
                      *((_QWORD *)v222 - 1) = v225;
                      v222 -= 8;
                    }
                    __p[0] = v222;
                    __p[1] = v216;
                    *(_QWORD *)&v443 = &v220[8 * v221];
                    if (v224)
                      operator delete(v224);
                  }
                  else
                  {
                    if (!__p[1])
                      goto LABEL_464;
                    *(_QWORD *)__p[1] = *((_QWORD *)__p[1] - 1);
                    v216 = v214 + 1;
                  }
                  __p[1] = v216;
                  if (*(_BYTE *)(a1 + 8))
                  {
                    v226 = v438[1];
                    if (v438[0] == v438[1])
                      goto LABEL_464;
                    if (v438[1] >= (void *)v439)
                    {
                      v228 = ((char *)v438[1] - (char *)v438[0]) >> 3;
                      if ((unint64_t)(v228 + 1) >> 61)
LABEL_461:
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                      v229 = (uint64_t)(v439 - (unint64_t)v438[0]) >> 2;
                      if (v229 <= v228 + 1)
                        v229 = v228 + 1;
                      if ((unint64_t)v439 - (unint64_t)v438[0] >= 0x7FFFFFFFFFFFFFF8)
                        v230 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v230 = v229;
                      if (!v230)
                        goto LABEL_464;
                      v231 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v230);
                      if (!v231)
                        goto LABEL_464;
                      v233 = &v231[8 * v228];
                      *(_QWORD *)v233 = *(v226 - 1);
                      v227 = v233 + 8;
                      v234 = (char *)v438[1];
                      v235 = (char *)v438[0];
                      while (v234 != v235)
                      {
                        v236 = *((_QWORD *)v234 - 1);
                        v234 -= 8;
                        *((_QWORD *)v233 - 1) = v236;
                        v233 -= 8;
                      }
                      v438[0] = v233;
                      v438[1] = v227;
                      *(_QWORD *)&v439 = &v231[8 * v232];
                      if (v235)
                        operator delete(v235);
                    }
                    else
                    {
                      if (!v438[1])
                        goto LABEL_464;
                      *(_QWORD *)v438[1] = *((_QWORD *)v438[1] - 1);
                      v227 = v226 + 1;
                    }
                    v438[1] = v227;
                  }
LABEL_287:
                  ++v56;
                }
                else if (v203)
                {
                  goto LABEL_287;
                }

                v351 = &v351[(_QWORD)v349];
              }

            }
            v347 = objc_msgSend(v343, "countByEnumeratingWithState:objects:count:", &v417, v463, 16);
          }
          while (v347);
        }

        v53 = v334;
        v58 = v332;
        ++v335;
      }
      while (v335 != v333);
      v54 = objc_msgSend(v334, "countByEnumeratingWithState:objects:count:", &v453, v464, 16);
      if (!v54)
        goto LABEL_295;
    }
  }
  v373 = 0;
  v375 = 0;
  v55 = 0;
  v369 = 0;
  v371 = 0;
  v365 = 0;
  v367 = 0;
  v348 = 0;
  v379 = 0u;
  v382 = 0u;
  v356 = 0u;
  v396 = 0u;
  v401 = 0u;
  v388 = 0u;
  *(_OWORD *)v392 = 0u;
  *(_OWORD *)v384 = 0u;
LABEL_295:

  v237 = objc_msgSend(v345, "length");
  if (objc_msgSend(v345, "length"))
  {
    v238 = v237 - 1;
    if (objc_msgSend(v345, "characterAtIndex:", v238) == 10)
    {
      objc_msgSend(v345, "deleteCharactersInRange:", v238, 1);
      if ((_QWORD)v379 == *((_QWORD *)&v379 + 1) || __p[0] == __p[1])
        goto LABEL_464;
      *(_QWORD *)&v239 = v379;
      *((_QWORD *)&v239 + 1) = *((_QWORD *)&v379 + 1) - 8;
      v379 = v239;
      __p[1] = (char *)__p[1] - 8;
      if (*(_BYTE *)(a1 + 8))
      {
        if (v438[0] == v438[1])
          goto LABEL_464;
        v438[1] = (char *)v438[1] - 8;
      }
    }
  }
  v240 = objc_msgSend(v345, "length");
  v241 = v240;
  v242 = *((_QWORD *)&v396 + 1);
  if (*((_QWORD *)&v396 + 1) >= (unint64_t)v373)
  {
    v244 = (void *)v396;
    v245 = (uint64_t)(*((_QWORD *)&v396 + 1) - v396) >> 3;
    v246 = v245 + 1;
    if ((unint64_t)(v245 + 1) >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    if ((uint64_t)&v373[-v396] >> 2 > v246)
      v246 = (uint64_t)&v373[-v396] >> 2;
    if ((unint64_t)&v373[-v396] >= 0x7FFFFFFFFFFFFFF8)
      v247 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v247 = v246;
    if (v247)
    {
      v248 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v247);
      if (v248)
      {
        v373 = &v248[8 * v249];
        v250 = (uint64_t *)&v248[8 * v245];
        *v250 = v241;
        v243 = (uint64_t)(v250 + 1);
        while (v242 != (_QWORD)v396)
        {
          v251 = *(_QWORD *)(v242 - 8);
          v242 -= 8;
          *--v250 = v251;
        }
        *(_QWORD *)&v396 = v250;
        if (v244)
          operator delete(v244);
        goto LABEL_318;
      }
    }
LABEL_464:
    __break(1u);
    return;
  }
  if (!*((_QWORD *)&v396 + 1))
    goto LABEL_464;
  **((_QWORD **)&v396 + 1) = v240;
  v243 = *((_QWORD *)&v396 + 1) + 8;
LABEL_318:
  v252 = *(void **)(a1 + 56);
  if (v252)
  {
    *(_QWORD *)(a1 + 64) = v252;
    operator delete(v252);
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
  }
  v253 = *(void **)(a1 + 80);
  *(_OWORD *)(a1 + 56) = v401;
  *(_QWORD *)(a1 + 72) = v55;
  if (v253)
  {
    *(_QWORD *)(a1 + 88) = v253;
    operator delete(v253);
    *(_QWORD *)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 96) = 0;
  }
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v392;
  *(_QWORD *)(a1 + 96) = v371;
  objc_storeStrong(location, v345);
  v254 = *(void **)(a1 + 128);
  if (v254)
  {
    *(_QWORD *)(a1 + 136) = v254;
    operator delete(v254);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 144) = 0;
  }
  v255 = *(void **)(a1 + 104);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)v384;
  *(_QWORD *)(a1 + 144) = v367;
  if (v255)
  {
    *(_QWORD *)(a1 + 112) = v255;
    operator delete(v255);
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 120) = 0;
  }
  *(_OWORD *)(a1 + 104) = v388;
  *(_QWORD *)(a1 + 120) = v369;
  v256 = *(void **)(a1 + 272);
  if (v256)
  {
    *(_QWORD *)(a1 + 280) = v256;
    operator delete(v256);
    *(_QWORD *)(a1 + 272) = 0;
    *(_QWORD *)(a1 + 280) = 0;
    *(_QWORD *)(a1 + 288) = 0;
  }
  *(_QWORD *)&v257 = v396;
  *((_QWORD *)&v257 + 1) = v243;
  v397 = v257;
  v258 = *(void **)(a1 + 152);
  *(_OWORD *)(a1 + 272) = v382;
  *(_QWORD *)(a1 + 288) = v365;
  if (v258)
  {
    *(_QWORD *)(a1 + 160) = v258;
    operator delete(v258);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 160) = 0;
    *(_QWORD *)(a1 + 168) = 0;
  }
  v259 = *(void **)(a1 + 200);
  *(_OWORD *)(a1 + 152) = v397;
  *(_QWORD *)(a1 + 168) = v373;
  if (v259)
  {
    *(_QWORD *)(a1 + 208) = v259;
    operator delete(v259);
    *(_QWORD *)(a1 + 200) = 0;
    *(_QWORD *)(a1 + 208) = 0;
    *(_QWORD *)(a1 + 216) = 0;
  }
  v260 = *(void **)(a1 + 224);
  *(_OWORD *)(a1 + 200) = v379;
  *(_QWORD *)(a1 + 216) = v375;
  if (v260)
  {
    *(_QWORD *)(a1 + 232) = v260;
    operator delete(v260);
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 240) = 0;
  }
  *(_OWORD *)(a1 + 224) = *(_OWORD *)__p;
  *(_QWORD *)(a1 + 240) = v443;
  *(_QWORD *)&v443 = 0;
  __p[1] = 0;
  __p[0] = 0;
  v261 = (_QWORD *)(a1 + 296);
  v262 = *(void **)(a1 + 296);
  if (v262)
  {
    *(_QWORD *)(a1 + 304) = v262;
    operator delete(v262);
    *v261 = 0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
  }
  *(_OWORD *)v261 = *(_OWORD *)v438;
  v263 = *(void **)(a1 + 32);
  *(_QWORD *)(a1 + 312) = v439;
  *(_QWORD *)&v439 = 0;
  v438[1] = 0;
  v438[0] = 0;
  if (v263)
  {
    *(_QWORD *)(a1 + 40) = v263;
    operator delete(v263);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
  *(_OWORD *)(a1 + 32) = v356;
  *(_QWORD *)(a1 + 48) = v348;

  if (v438[0])
  {
    v438[1] = v438[0];
    operator delete(v438[0]);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

LABEL_343:
  if (*(_BYTE *)(a1 + 8))
    goto LABEL_344;
  v264 = objc_msgSend(*(id *)(a1 + 24), "length");
  v383 = (void *)objc_opt_new();
  v402 = (void *)objc_opt_new();
  v445 = 0u;
  v444 = 0u;
  v443 = 0u;
  *(_OWORD *)__p = 0u;
  v385 = *(id *)(a1 + 328);
  v393 = objc_msgSend(v385, "countByEnumeratingWithState:objects:count:", __p, v464, 16);
  if (!v393)
    goto LABEL_388;
  v389 = *(_QWORD *)v443;
  do
  {
    for (n = 0; n != v393; ++n)
    {
      if (*(_QWORD *)v443 != v389)
        objc_enumerationMutation(v385);
      v265 = *((id *)__p[1] + n);
      if (objc_msgSend(v265, "type") == 6)
      {
        if (!objc_msgSend(v402, "count"))
          goto LABEL_386;
        objc_msgSend(v383, "addObject:", v402);
        v266 = v402;
        v402 = (void *)objc_opt_new();
      }
      else
      {
        v440 = 0u;
        v441 = 0u;
        *(_OWORD *)v438 = 0u;
        v439 = 0u;
        objc_msgSend(v265, "subregions");
        v266 = (void *)objc_claimAutoreleasedReturnValue();
        v267 = objc_msgSend(v266, "countByEnumeratingWithState:objects:count:", v438, v463, 16);
        if (v267)
        {
          v268 = *(_QWORD *)v439;
          do
          {
            for (ii = 0; ii != v267; ++ii)
            {
              if (*(_QWORD *)v439 != v268)
                objc_enumerationMutation(v266);
              v270 = (void *)*((_QWORD *)v438[1] + ii);
              if (objc_msgSend(v270, "type") == 1)
              {
                objc_msgSend(v270, "setParent:", v265);
                v459[0] = 0uLL;
                if (v270)
                {
                  objc_msgSend(v270, "textLine");
                }
                else
                {
                  memset(v462, 0, 56);
                  *(_OWORD *)v461 = 0u;
                }
                v459[0] = *(_OWORD *)v461;
                v461[1] = 0;
                v461[0] = 0;
                *(_QWORD *)&v462[0] = 0;
                *(_QWORD *)&v457[0] = v459;
                *((_QWORD *)&v457[0] + 1) = 1;
                *(_QWORD *)&v453 = v461;
                PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(a1, (uint64_t)v457, (void ***)&v453);
                v271 = v461[0];
                v272 = (uint64_t *)v461[1];
                v273 = (uint64_t *)v461[0];
                if (v461[0] == v461[1])
                {
LABEL_380:
                  v279 = [TextGrouping alloc];
                  *(void **)&v457[0] = v461[0];
                  *((_QWORD *)&v457[0] + 1) = ((char *)v461[1] - (char *)v461[0]) >> 4;
                  StringForStringRanges = (void *)PageLayout::CreateStringForStringRanges(a1, (uint64_t)v457);
                  v281 = -[TextGrouping initWithTextElement:text:](v279, "initWithTextElement:text:", v270, StringForStringRanges);
                  objc_msgSend(v402, "addObject:", v281);

                  v271 = v461[0];
                }
                else
                {
                  while (1)
                  {
                    v275 = *v273;
                    v274 = v273[1];
                    v276 = v274 + *v273;
                    if (*v273 < 0 || v276 > v264)
                    {
                      v277 = v264 >= v276 ? v274 + *v273 : v264;
                      if (v275 > 0 || v276 < 1)
                      {
                        if (v275 < 0)
                        {
                          v275 = 0;
                          v277 = 0;
                        }
                        else
                        {
                          v277 -= v275;
                          if (v275 >= v264)
                          {
                            v275 = 0;
                            v277 = 0;
                          }
                        }
                      }
                      else
                      {
                        v275 = 0;
                      }
                      *v273 = v275;
                      v273[1] = v277;
                      if (!v277)
                        break;
                    }
                    v273 += 2;
                    if (v273 == v272)
                      goto LABEL_380;
                  }
                }
                if (v271)
                {
                  v461[1] = v271;
                  operator delete(v271);
                }
              }
            }
            v267 = objc_msgSend(v266, "countByEnumeratingWithState:objects:count:", v438, v463, 16);
          }
          while (v267);
        }
      }

LABEL_386:
    }
    v393 = objc_msgSend(v385, "countByEnumeratingWithState:objects:count:", __p, v464, 16);
  }
  while (v393);
LABEL_388:

  if (objc_msgSend(v402, "count"))
    objc_msgSend(v383, "addObject:", v402);
  v436 = 0u;
  v437 = 0u;
  v434 = 0u;
  v435 = 0u;
  v364 = v383;
  v282 = objc_msgSend(v364, "countByEnumeratingWithState:objects:count:", &v434, v461, 16);
  if (v282)
  {
    v361 = *(_QWORD *)v435;
    do
    {
      v370 = 0;
      v355 = v282;
      do
      {
        if (*(_QWORD *)v435 != v361)
          objc_enumerationMutation(v364);
        v368 = *(id *)(*((_QWORD *)&v434 + 1) + 8 * v370);
        v446 = 0;
        v447 = &v446;
        v448 = 0x2050000000;
        v283 = (void *)getCRLayoutUtilitiesClass(void)::softClass;
        v449 = getCRLayoutUtilitiesClass(void)::softClass;
        if (!getCRLayoutUtilitiesClass(void)::softClass)
        {
          *(_QWORD *)&v417 = MEMORY[0x1E0C809B0];
          *((_QWORD *)&v417 + 1) = 3221225472;
          *(_QWORD *)&v418 = ___ZL25getCRLayoutUtilitiesClassv_block_invoke;
          *((_QWORD *)&v418 + 1) = &unk_1E165AB10;
          *(_QWORD *)&v419 = &v446;
          ___ZL25getCRLayoutUtilitiesClassv_block_invoke((uint64_t)&v417);
          v283 = (void *)*((_QWORD *)v447 + 3);
        }
        v284 = objc_retainAutorelease(v283);
        _Block_object_dispose(&v446, 8);
        objc_msgSend(v284, "listsWithRegionGroups:", v368);
        v285 = (void *)objc_claimAutoreleasedReturnValue();
        v432 = 0u;
        v433 = 0u;
        v430 = 0u;
        v431 = 0u;
        v366 = v285;
        v286 = objc_msgSend(v366, "countByEnumeratingWithState:objects:count:", &v430, v459, 16);
        if (v286)
        {
          v287 = *(_QWORD *)v431;
          v352 = *(_QWORD *)v431;
          do
          {
            v288 = 0;
            v357 = v286;
            do
            {
              if (*(_QWORD *)v431 != v287)
                objc_enumerationMutation(v366);
              v289 = *(void **)(*((_QWORD *)&v430 + 1) + 8 * v288);
              v381 = (void *)objc_opt_new();
              v428 = 0u;
              v429 = 0u;
              v426 = 0u;
              v427 = 0u;
              objc_msgSend(v289, "items");
              v372 = (id)objc_claimAutoreleasedReturnValue();
              v290 = objc_msgSend(v372, "countByEnumeratingWithState:objects:count:", &v426, v457, 16);
              v359 = v288;
              if (v290)
              {
                v291 = 0;
                v292 = 0;
                v374 = v290;
                v376 = *(_QWORD *)v427;
                v390 = -1;
                do
                {
                  for (jj = 0; jj != v374; ++jj)
                  {
                    if (*(_QWORD *)v427 != v376)
                      objc_enumerationMutation(v372);
                    v293 = *(void **)(*((_QWORD *)&v426 + 1) + 8 * jj);
                    v447 = 0;
                    v446 = 0;
                    v448 = 0;
                    v422 = 0u;
                    v423 = 0u;
                    v424 = 0u;
                    v425 = 0u;
                    objc_msgSend(v293, "groups");
                    v294 = (void *)objc_claimAutoreleasedReturnValue();
                    v394 = v294;
                    v295 = 0;
                    v296 = objc_msgSend(v294, "countByEnumeratingWithState:objects:count:", &v422, &v453, 16);
                    if (v296)
                    {
                      v399 = *(_QWORD *)v423;
                      do
                      {
                        v297 = 0;
                        v298 = v295;
                        do
                        {
                          if (*(_QWORD *)v423 != v399)
                            objc_enumerationMutation(v394);
                          objc_msgSend(*(id *)(*((_QWORD *)&v422 + 1) + 8 * v297), "subregions");
                          v299 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v299, "firstObject");
                          v300 = (void *)objc_claimAutoreleasedReturnValue();

                          objc_msgSend(v300, "parent");
                          v295 = (void *)objc_claimAutoreleasedReturnValue();

                          if (v300)
                          {
                            objc_msgSend(v300, "textLine");
                          }
                          else
                          {
                            v421 = 0;
                            v419 = 0u;
                            v420 = 0u;
                            v417 = 0u;
                            v418 = 0u;
                          }
                          v301 = v447;
                          if ((unint64_t)v447 >= v448)
                          {
                            v306 = 0x8E38E38E38E38E39 * (((_BYTE *)v447 - (_BYTE *)v446) >> 3);
                            v307 = v306 + 1;
                            if (v306 + 1 > 0x38E38E38E38E38ELL)
                              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
                            if (0x1C71C71C71C71C72 * ((uint64_t)(v448 - (_QWORD)v446) >> 3) > v307)
                              v307 = 0x1C71C71C71C71C72 * ((uint64_t)(v448 - (_QWORD)v446) >> 3);
                            if (0x8E38E38E38E38E39 * ((uint64_t)(v448 - (_QWORD)v446) >> 3) >= 0x1C71C71C71C71C7)
                              v308 = 0x38E38E38E38E38ELL;
                            else
                              v308 = v307;
                            if (!v308)
                              goto LABEL_464;
                            v309 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v308);
                            if (!v309)
                              goto LABEL_464;
                            v311 = &v309[72 * v306];
                            *(_OWORD *)v311 = v417;
                            v312 = v418;
                            v313 = v419;
                            v314 = v420;
                            *((_QWORD *)v311 + 8) = v421;
                            *((_OWORD *)v311 + 2) = v313;
                            *((_OWORD *)v311 + 3) = v314;
                            *((_OWORD *)v311 + 1) = v312;
                            v315 = (char *)v447;
                            v316 = (char *)v446;
                            v317 = v311;
                            if (v447 != v446)
                            {
                              do
                              {
                                *(_OWORD *)(v317 - 72) = *(_OWORD *)(v315 - 72);
                                v318 = *(_OWORD *)(v315 - 56);
                                v319 = *(_OWORD *)(v315 - 40);
                                v320 = *(_OWORD *)(v315 - 24);
                                *((_QWORD *)v317 - 1) = *((_QWORD *)v315 - 1);
                                *(_OWORD *)(v317 - 24) = v320;
                                *(_OWORD *)(v317 - 40) = v319;
                                *(_OWORD *)(v317 - 56) = v318;
                                v317 -= 72;
                                v315 -= 72;
                              }
                              while (v315 != v316);
                              v315 = v316;
                            }
                            v305 = v311 + 72;
                            v446 = v317;
                            v447 = v311 + 72;
                            v448 = (unint64_t)&v309[72 * v310];
                            if (v315)
                              operator delete(v315);
                          }
                          else
                          {
                            if (!v447)
                              goto LABEL_464;
                            *(_OWORD *)v447 = v417;
                            v302 = v418;
                            v303 = v419;
                            v304 = v420;
                            v301[8] = v421;
                            *((_OWORD *)v301 + 2) = v303;
                            *((_OWORD *)v301 + 3) = v304;
                            *((_OWORD *)v301 + 1) = v302;
                            v305 = v301 + 9;
                          }
                          v447 = v305;
                          if (!v291)
                          {
                            v321 = v295;

                            objc_msgSend(v321, "parent");
                            v322 = (void *)objc_claimAutoreleasedReturnValue();
                            objc_msgSend(v322, "children");
                            v323 = (void *)objc_claimAutoreleasedReturnValue();
                            v390 = objc_msgSend(v323, "indexOfObject:", v321);

                            v291 = v322;
                            v292 = v321;
                          }
                          objc_msgSend(v295, "removeSubregion:", v300);

                          ++v297;
                          v298 = v295;
                        }
                        while (v297 != v296);
                        v294 = v394;
                        v296 = objc_msgSend(v394, "countByEnumeratingWithState:objects:count:", &v422, &v453, 16);
                      }
                      while (v296);
                    }

                    v324 = -[PDFListItemElement initWithTextLines:boundingBox:]([PDFListItemElement alloc], "initWithTextLines:boundingBox:", &v446, 0);
                    objc_msgSend(v381, "addObject:", v324);

                    if (v446)
                    {
                      v447 = v446;
                      operator delete(v446);
                    }
                  }
                  v374 = objc_msgSend(v372, "countByEnumeratingWithState:objects:count:", &v426, v457, 16);
                }
                while (v374);
              }
              else
              {
                v291 = 0;
                v292 = 0;
                v390 = -1;
              }

              v325 = -[PDFCRGroupRegion initWithBoundingQuad:layoutDirection:subregions:parent:]([PDFCRGroupRegion alloc], "initWithBoundingQuad:layoutDirection:subregions:parent:", 0, 0, v381, v291);
              objc_msgSend(v291, "children");
              v326 = (void *)objc_claimAutoreleasedReturnValue();
              if (objc_msgSend(v326, "count") <= v390)
              {

                v330 = v390;
              }
              else
              {
                objc_msgSend(v291, "children");
                v327 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v327, "objectAtIndex:", v390);
                v328 = (void *)objc_claimAutoreleasedReturnValue();
                v329 = objc_msgSend(v328, "isEqual:", v292);

                v330 = v390 + v329;
              }
              objc_msgSend(v291, "insertChildren:atIndex:", v325, v330);
              objc_msgSend(*(id *)(a1 + 328), "addObject:", v325);

              v288 = v359 + 1;
              v287 = v352;
            }
            while (v359 + 1 != v357);
            v286 = objc_msgSend(v366, "countByEnumeratingWithState:objects:count:", &v430, v459, 16);
          }
          while (v286);
        }

        ++v370;
      }
      while (v370 != v355);
      v282 = objc_msgSend(v364, "countByEnumeratingWithState:objects:count:", &v434, v461, 16);
    }
    while (v282);
  }

LABEL_344:
  *(id *)(a1 + 320);

}

void sub_184C89F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,void *a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59)
{

  _Unwind_Resume(a1);
}

id getCRCTLDClass(void)
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getCRCTLDClass(void)::softClass;
  v7 = getCRCTLDClass(void)::softClass;
  if (!getCRCTLDClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZL14getCRCTLDClassv_block_invoke;
    v3[3] = &unk_1E165AB10;
    v3[4] = &v4;
    ___ZL14getCRCTLDClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_184C8A564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getCRNormalizedQuadClass(void)
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getCRNormalizedQuadClass(void)::softClass;
  v7 = getCRNormalizedQuadClass(void)::softClass;
  if (!getCRNormalizedQuadClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZL24getCRNormalizedQuadClassv_block_invoke;
    v3[3] = &unk_1E165AB10;
    v3[4] = &v4;
    ___ZL24getCRNormalizedQuadClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_184C8A61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id PageLayout::createFineCTLDConfig(PageLayout *this)
{
  void *v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;

  v1 = (void *)objc_msgSend(objc_alloc((Class)getCRCTLDConfigClass()), "init");
  LODWORD(v2) = 0;
  objc_msgSend(v1, "setAngleThresholdForRotationCorrection:", v2);
  objc_msgSend(v1, "setFlatMergeJumps:", 1);
  objc_msgSend(v1, "setMaxRegions:", 169);
  objc_msgSend(v1, "setMaxQueueCapacity:", 0xFFFFFFFFLL);
  objc_msgSend(v1, "setNumLookupElements:", 57);
  objc_msgSend(v1, "setNumPointsForSegmentsIntersection:", 4);
  LODWORD(v3) = 8.0;
  objc_msgSend(v1, "setMinSubRectangleSize:", v3);
  LODWORD(v4) = 1035122882;
  objc_msgSend(v1, "setMinQuadrilateralRotation:", v4);
  LODWORD(v5) = 1060320051;
  objc_msgSend(v1, "setMinWhitespaceHeightForReadingOrder:", v5);
  LODWORD(v6) = 1050589266;
  objc_msgSend(v1, "setAllowedOverlap:", v6);
  LODWORD(v7) = 1047233823;
  objc_msgSend(v1, "setMinWhitespaceWidth:", v7);
  LODWORD(v8) = 1063843267;
  objc_msgSend(v1, "setMinWhitespaceHeight:", v8);
  LODWORD(v9) = 1078523331;
  objc_msgSend(v1, "setQualityHeightFactor:", v9);
  LODWORD(v10) = 1066863165;
  objc_msgSend(v1, "setQualityWidthFactor:", v10);
  return v1;
}

void sub_184C8A720(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(uint64_t a1, uint64_t a2, void ***a3)
{
  id v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[7];
  __int128 v31;
  uint64_t v32;
  __n128 (*v33)(__n128 *, __n128 *);
  uint64_t (*v34)();
  const char *v35;
  __int128 v36;

  if (*(_BYTE *)(a1 + 8))
  {
    v6 = objc_alloc_init(MEMORY[0x1E0CB3788]);
    v7 = *(_QWORD *)(a2 + 8);
    if (v7)
    {
      v8 = *(unint64_t **)a2;
      v9 = &v8[2 * v7];
      do
      {
        v10 = v8[1];
        if (v10 >= 1)
        {
          v11 = *v8;
          v12 = v10 + *v8;
          v14 = *(_QWORD *)(a1 + 80);
          v13 = *(_QWORD *)(a1 + 88);
          while (1)
          {
            if (v11 >= (v13 - v14) >> 3)
              goto LABEL_29;
            if (*(_QWORD *)(v14 + 8 * v11))
              break;
LABEL_18:
            if ((uint64_t)++v11 >= v12)
              goto LABEL_19;
          }
          v15 = 0;
          while (1)
          {
            v16 = *(_QWORD *)(a1 + 152);
            if (v11 >= (*(_QWORD *)(a1 + 160) - v16) >> 3)
              std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
            v17 = *(_QWORD **)(a1 + 296);
            v18 = *(_QWORD **)(a1 + 304);
            if (v17 == v18)
            {
              v20 = *(_QWORD **)(a1 + 296);
            }
            else
            {
              v19 = *(_QWORD *)(v16 + 8 * v11) + v15;
              v20 = *(_QWORD **)(a1 + 296);
              while (*v20 != v19)
              {
                if (++v20 == v18)
                {
                  v20 = *(_QWORD **)(a1 + 304);
                  break;
                }
              }
            }
            objc_msgSend(v6, "addIndex:", v20 - v17);
            v14 = *(_QWORD *)(a1 + 80);
            v13 = *(_QWORD *)(a1 + 88);
            if (v11 >= (v13 - v14) >> 3)
              break;
            if ((unint64_t)++v15 >= *(_QWORD *)(v14 + 8 * v11))
              goto LABEL_18;
          }
LABEL_29:
          std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
        }
LABEL_19:
        v8 += 2;
      }
      while (v8 != v9);
    }
    *(_QWORD *)&v31 = 0;
    *((_QWORD *)&v31 + 1) = &v31;
    v32 = 0x4012000000;
    v33 = __Block_byref_object_copy__305;
    v34 = __Block_byref_object_dispose__306;
    v35 = "";
    v36 = xmmword_185004A10;
    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 3221225472;
    v30[2] = ___ZNK10PageLayout31ConvertTextRangesToStringRangesINSt3__14spanI7CFRangeLm18446744073709551615EEENS1_20back_insert_iteratorINS1_6vectorIS3_NS1_9allocatorIS3_EEEEEEEEvOT_OT0__block_invoke;
    v30[3] = &unk_1E165F018;
    v30[4] = &v31;
    v30[5] = a1;
    v30[6] = a3;
    objc_msgSend(v6, "enumerateRangesUsingBlock:", v30);
    if (*(_QWORD *)(*((_QWORD *)&v31 + 1) + 48) != -1)
      std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:se180100](a3, (_OWORD *)(*((_QWORD *)&v31 + 1) + 48));
    _Block_object_dispose(&v31, 8);

  }
  else
  {
    v21 = *(_QWORD *)(a2 + 8);
    if (v21)
    {
      v22 = *(unint64_t **)a2;
      v23 = *(_QWORD *)a2 + 16 * v21;
      do
      {
        v24 = *v22;
        v25 = *(_QWORD *)(a1 + 152);
        v26 = (*(_QWORD *)(a1 + 160) - v25) >> 3;
        if (v26 <= *v22)
          std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
        v27 = v22[1] + v24;
        if (v26 <= v27)
          std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
        v28 = *(_QWORD *)(v25 + 8 * v24);
        v29 = *(_QWORD *)(v25 + 8 * v27) - v28;
        *(_QWORD *)&v31 = v28;
        *((_QWORD *)&v31 + 1) = v29;
        std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:se180100](a3, &v31);
        v22 += 2;
      }
      while (v22 != (unint64_t *)v23);
    }
  }
}

void sub_184C8A98C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_184C8A9A8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  void *v36;
  const char *v37;

  if (a2 != 1)
    JUMPOUT(0x184C8A9A0);
  v36 = __cxa_begin_catch(a1);
  v37 = (const char *)(*(uint64_t (**)(void *))(*(_QWORD *)v36 + 16))(v36);
  pdf_error("%s caught exception: %s", "void PageLayout::ConvertTextRangesToStringRanges(I &&, O &&) const [I = std::span<CFRange>, O = std::back_insert_iterator<std::vector<CFRange>>]", v37);
  __cxa_end_catch();
}

#error "184C8AA38: call analysis failed (funcsize=15)"

uint64_t PageLayout::CreateStringForStringRanges(uint64_t a1, uint64_t a2)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  NSUInteger v7;
  NSRange *v8;
  uint64_t v9;
  NSRange v10;
  void *v11;
  void *v12;
  uint64_t v13;
  NSRange v15;

  v4 = objc_alloc_init(MEMORY[0x1E0CB37A0]);
  v5 = objc_msgSend(*(id *)(a1 + 24), "length");
  v6 = *(_QWORD *)(a2 + 8);
  if (v6)
  {
    v7 = v5;
    v8 = *(NSRange **)a2;
    v9 = *(_QWORD *)a2 + 16 * v6;
    do
    {
      v15.location = 0;
      v15.length = v7;
      v10 = NSIntersectionRange(*v8, v15);
      if (v10.length)
      {
        objc_msgSend(*(id *)(a1 + 24), "substringWithRange:", v10.location, v10.length);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v4, "appendString:", v11);

      }
      ++v8;
    }
    while (v8 != (NSRange *)v9);
  }
  objc_msgSend(MEMORY[0x1E0CB3500], "newlineCharacterSet");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringByTrimmingCharactersInSet:", v12);
  v13 = objc_claimAutoreleasedReturnValue();

  return v13;
}

void sub_184C8AB24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL25getCRLayoutUtilitiesClassv_block_invoke(uint64_t a1)
{
  TextRecognitionLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("CRLayoutUtilities");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getCRLayoutUtilitiesClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    TextRecognitionLibrary();
  }
}

void TextRecognitionLibrary(void)
{
  void *v0;

  if (!TextRecognitionLibraryCore(char **)::frameworkLibrary)
  {
    TextRecognitionLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    if (!TextRecognitionLibraryCore(char **)::frameworkLibrary)
    {
      v0 = (void *)abort_report_np();
      free(v0);
    }
  }
}

__n128 __Block_byref_object_copy__305(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(_QWORD *a1, unsigned int a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t **v5;
  uint64_t *result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
      v4 = a2 % v2;
  }
  else
  {
    v4 = ((_DWORD)v2 - 1) & a2;
  }
  v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  for (result = *v5; result; result = (uint64_t *)*result)
  {
    v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2)
        return result;
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
          v7 %= v2;
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4)
        return 0;
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,PDFAtomicElement * {__strong}>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = *(_DWORD *)a3;
  v13 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(a3 + 8) = 0;
  v12[3] = v13;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    v16 = 1;
    if (v7 >= 3)
      v16 = (v7 & (v7 - 1)) != 0;
    v17 = v16 | (2 * v7);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>(a1, v19);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *v12 = *v21;
LABEL_38:
    *v21 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    v22 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v22 >= v7)
        v22 %= v7;
    }
    else
    {
      v22 &= v7 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_184C8AFEC(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,void *>>>::operator()[abi:se180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,void *>>>::operator()[abi:se180100](char a1, id *a2)
{
  if (a1)
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

id getCRCTLDConfigClass(void)
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getCRCTLDConfigClass(void)::softClass;
  v7 = getCRCTLDConfigClass(void)::softClass;
  if (!getCRCTLDConfigClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZL20getCRCTLDConfigClassv_block_invoke;
    v3[3] = &unk_1E165AB10;
    v3[4] = &v4;
    ___ZL20getCRCTLDConfigClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_184C8B0E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL20getCRCTLDConfigClassv_block_invoke(uint64_t a1)
{
  Class result;
  uint64_t v3;

  TextRecognitionLibrary();
  result = objc_getClass("CRCTLDConfig");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getCRCTLDConfigClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = abort_report_np();
    return ___ZL24getCRNormalizedQuadClassv_block_invoke(v3);
  }
  return result;
}

Class ___ZL24getCRNormalizedQuadClassv_block_invoke(uint64_t a1)
{
  Class result;
  uint64_t v3;

  TextRecognitionLibrary();
  result = objc_getClass("CRNormalizedQuad");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getCRNormalizedQuadClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = abort_report_np();
    return (Class)___ZL14getCRCTLDClassv_block_invoke(v3);
  }
  return result;
}

double ___ZL14getCRCTLDClassv_block_invoke(uint64_t a1)
{
  double result;
  uint64_t v3;
  uint64_t v4;

  TextRecognitionLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("CRCTLD");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getCRCTLDClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = abort_report_np();
    *(_QWORD *)&result = __Block_byref_object_copy__67_10556(v3, v4).n128_u64[0];
  }
  return result;
}

__n128 __Block_byref_object_copy__67_10556(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void ___ZN10PageLayout20createAtomicElementsEP6CGRect_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  double x;
  double y;
  double width;
  double height;
  uint64_t v10;
  PDFAnnotationElement *v11;
  id v12;
  CGAffineTransform v13;
  CGRect v14;
  CGRect v15;

  v14.origin.x = CGPDFAnnotationGetRect(a3);
  v5 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v13.a = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v13.c = v5;
  *(_OWORD *)&v13.tx = *(_OWORD *)(a1 + 80);
  v15 = CGRectApplyAffineTransform(v14, &v13);
  x = v15.origin.x;
  y = v15.origin.y;
  width = v15.size.width;
  height = v15.size.height;
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  *(CGRect *)(v10 + 48) = CGRectUnion(*(CGRect *)(v10 + 48), v15);
  v12 = (id)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", x, y, width, height, *(double *)(a1 + 112), *(double *)(a1 + 120));
  v11 = -[PDFAnnotationElement initWithAnnotation:boundingBox:]([PDFAnnotationElement alloc], "initWithAnnotation:boundingBox:", a3, v12);
  objc_msgSend(*(id *)(a1 + 32), "addObject:", v11);

}

void sub_184C8B344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void PageLayout::addCTLDMapping(PageLayout *this, TextLine *a2, PDFAtomicElement *a3)
{
  _QWORD *v6;
  unsigned int identifier;
  uint64_t *v8;
  PDFAtomicElement *v9;
  unsigned int v10;
  PDFAtomicElement *v11;

  v9 = a3;
  v6 = (_QWORD *)((char *)this + 336);
  identifier = a2->identifier;
  v8 = std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(v6, identifier);
  if (v8)
  {
    objc_storeStrong((id *)v8 + 3, a3);
  }
  else
  {
    v10 = identifier;
    v11 = v9;
    std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,PDFAtomicElement * {__strong}>>((uint64_t)v6, identifier, (uint64_t)&v10);

  }
}

void sub_184C8B3F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void std::vector<unsigned long>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    v7 = &v4[8 * v6];
    v8 = (char *)*a1;
    v9 = (char *)a1[1];
    v10 = v5;
    if (v9 != *a1)
    {
      v10 = v5;
      do
      {
        v11 = *((_QWORD *)v9 - 1);
        v9 -= 8;
        *((_QWORD *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void std::vector<CGRect>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  __int128 v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFE0];
    v7 = &v4[32 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 32;
        v8 -= 32;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void PageLayout::getTextRangeIndex(PageLayout *a1, int a2, unsigned int a3, double a4, double a5)
{
  uint64_t v5;
  uint64_t v6;
  double v7;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  double *v12;
  unint64_t v13;
  double v14;
  double v15;
  __double2 v16;
  double y;
  double v18;
  double height;
  double v20;
  double v21;
  double v22;
  _BOOL4 v23;
  _BOOL4 v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  int v32;
  uint64_t v33;
  CGFloat *v34;
  CGFloat v35;
  CGFloat v36;
  CGFloat v37;
  CGFloat v38;
  __double2 v39;
  CGFloat v40;
  CGFloat width;
  CGFloat v42;
  char *v43;
  char *v44;
  unint64_t v45;
  CGFloat *v46;
  CGFloat v47;
  CGFloat v48;
  CGFloat v49;
  CGFloat v50;
  __double2 v51;
  PageLayout *v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t *v62;
  double v63;
  unint64_t v64;
  unint64_t *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  double v69;
  __double2 v70;
  uint64_t v71;
  unint64_t v72;
  BOOL v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  double v78;
  double v79;
  CGFloat *v80;
  unint64_t v81;
  double v82;
  CGFloat v83;
  double v84;
  double v85;
  _BOOL4 v86;
  double v87;
  double v88;
  double v89;
  double v90;
  CGFloat v91;
  CGFloat v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  unsigned int v98;
  double v99;
  __double2 v100;
  uint64_t v101;
  double x;
  CGFloat v103;
  double v104;
  double v105;
  double v106;
  int v107;
  double v108;
  unint64_t *v109;
  unint64_t v110;
  uint64_t v111;
  int64_t v112;
  double v113;
  __double2 v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t v119;
  double *v120;
  double v121;
  double v122;
  double v123;
  double v124;
  uint64_t v125;
  double v126;
  double v127;
  double v128;
  uint64_t v129;
  _QWORD *WordRange;
  uint64_t v131;
  double v132;
  unint64_t v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  unint64_t v137;
  _BOOL4 v138;
  uint64_t v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v145;
  uint64_t v146;
  char *__p;
  PageLayout *v148;
  double v149;
  int v150;
  CGRect rect1;
  unint64_t v154;
  CGAffineTransform v155;
  CGAffineTransform v156;
  CGRect v157;
  CGRect v158;
  CGRect v159;
  CGRect v160;
  CGRect v161;
  CGRect v162;
  CGRect v163;
  CGRect v164;
  CGRect v165;
  CGRect v166;
  CGRect v167;
  CGRect v168;
  CGRect v169;
  CGRect v170;
  CGRect v171;
  CGRect v172;
  CGRect v173;
  CGRect v174;
  CGRect v175;

  v5 = *((_QWORD *)a1 + 4);
  v6 = *((_QWORD *)a1 + 5);
  if (v5 != v6)
  {
    v7 = a4;
    v9 = 0;
    v150 = 0;
    v10 = (v6 - v5) / 72;
    v11 = v10 <= 1 ? 1 : (v6 - v5) / 72;
    v145 = *((_QWORD *)a1 + 4);
    v12 = (double *)(v5 + 56);
    v13 = -1;
    rect1.origin.x = 1.79769313e308;
    v149 = 1.79769313e308;
    do
    {
      v14 = v7;
      v15 = a5;
      if (*v12 != 0.0)
      {
        v16 = __sincos_stret(*v12);
        v14 = a5 * v16.__sinval + v16.__cosval * v7 + 0.0;
        v15 = a5 * v16.__cosval - v16.__sinval * v7 + 0.0;
      }
      v18 = *(v12 - 4);
      y = *(v12 - 3);
      v20 = *(v12 - 2);
      height = *(v12 - 1);
      if (v20 < 0.0 || height < 0.0)
      {
        v27 = COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(v12 - 4))) - v14;
        v157.origin.x = v18;
        v157.origin.y = y;
        v157.size.width = v20;
        v157.size.height = height;
        v158 = CGRectStandardize(v157);
        v28 = v14 - (v158.origin.x + v158.size.width);
        v23 = v27 < 0.0;
        if (v27 >= 0.0)
          v29 = v27;
        else
          v29 = 0.0;
        v24 = v29 < v28;
        if (v29 >= v28)
          v25 = v29;
        else
          v25 = v28;
        v159.origin.x = v18;
        v159.origin.y = y;
        v159.size.width = v20;
        v159.size.height = height;
        v160 = CGRectStandardize(v159);
        v26 = v160.origin.y - v15;
        v160.origin.x = v18;
        v160.origin.y = y;
        v160.size.width = v20;
        v160.size.height = height;
        v161 = CGRectStandardize(v160);
        y = v161.origin.y;
        height = v161.size.height;
      }
      else
      {
        v21 = v18 - v14;
        v22 = v14 - (v18 + v20);
        v23 = v18 - v14 < 0.0;
        if (v18 - v14 < 0.0)
          v21 = 0.0;
        v24 = v21 < v22;
        if (v21 >= v22)
          v25 = v21;
        else
          v25 = v14 - (v18 + v20);
        v26 = y - v15;
      }
      v30 = v15 - (y + height);
      if (v26 >= 0.0)
        v31 = v26;
      else
        v31 = 0.0;
      if (v31 >= v30)
        v30 = v31;
      if (v30 * v30 + v25 * v25 < rect1.origin.x)
      {
        if (v24)
          v32 = 2;
        else
          v32 = v23;
        v150 = v32;
        v13 = v9;
        v149 = v30;
        rect1.origin.x = v30 * v30 + v25 * v25;
      }
      ++v9;
      v12 += 9;
      v7 = a4;
    }
    while (v11 != v9);
    if (v13 != -1)
    {
      if (v10 <= v13)
        goto LABEL_182;
      v148 = a1;
      v33 = v145;
      v34 = (CGFloat *)(v145 + 72 * v13);
      v35 = v34[3];
      v36 = v34[4];
      v37 = v34[5];
      v38 = v34[6];
      v39 = __sincos_stret(v34[7]);
      v156.a = v39.__cosval;
      v156.b = v39.__sinval;
      v156.c = -v39.__sinval;
      v156.d = v39.__cosval;
      v156.tx = 0.0;
      v156.ty = 0.0;
      v162.origin.x = v35;
      v162.origin.y = v36;
      v162.size.width = v37;
      v162.size.height = v38;
      v163 = CGRectApplyAffineTransform(v162, &v156);
      rect1.origin.x = v163.origin.x;
      v40 = v163.origin.y;
      width = v163.size.width;
      v42 = v163.size.height;
      v43 = 0;
      v44 = 0;
      __p = 0;
      v45 = 0;
      do
      {
        v46 = (CGFloat *)(v33 + 72 * v45);
        v47 = v46[3];
        v48 = v46[4];
        v49 = v46[5];
        v50 = v46[6];
        v51 = __sincos_stret(v46[7]);
        v155.a = v51.__cosval;
        v155.b = v51.__sinval;
        v155.c = -v51.__sinval;
        v155.d = v51.__cosval;
        v155.tx = 0.0;
        v155.ty = 0.0;
        v164.origin.x = v47;
        v164.origin.y = v48;
        v164.size.width = v49;
        v164.size.height = v50;
        v175 = CGRectApplyAffineTransform(v164, &v155);
        v165.origin.x = rect1.origin.x;
        v165.origin.y = v40;
        v165.size.width = width;
        v165.size.height = v42;
        if (CGRectIntersectsRect(v165, v175))
        {
          if (v44 >= v43)
          {
            v52 = v148;
            v54 = (v44 - __p) >> 3;
            v55 = v54 + 1;
            if ((unint64_t)(v54 + 1) >> 61)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            if ((v43 - __p) >> 2 > v55)
              v55 = (v43 - __p) >> 2;
            if ((unint64_t)(v43 - __p) >= 0x7FFFFFFFFFFFFFF8)
              v56 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v56 = v55;
            if (!v56)
              goto LABEL_182;
            v57 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v56);
            if (!v57)
              goto LABEL_182;
            v59 = (unint64_t *)&v57[8 * v54];
            *v59 = v45;
            v53 = (char *)(v59 + 1);
            while (v44 != __p)
            {
              v60 = *((_QWORD *)v44 - 1);
              v44 -= 8;
              *--v59 = v60;
            }
            v43 = &v57[8 * v58];
            if (__p)
              operator delete(__p);
            __p = (char *)v59;
          }
          else
          {
            v52 = v148;
            if (!v44)
              goto LABEL_182;
            *(_QWORD *)v44 = v45;
            v53 = v44 + 8;
          }
          v33 = *((_QWORD *)v52 + 4);
          v6 = *((_QWORD *)v52 + 5);
          v44 = v53;
        }
        ++v45;
        v61 = 0x8E38E38E38E38E39 * ((v6 - v33) >> 3);
      }
      while (v45 < v61);
      v146 = v33;
      v62 = (unint64_t *)__p;
      if ((unint64_t)(v44 - __p) < 9)
      {
        v98 = a3;
        v99 = a5;
        v107 = v150;
      }
      else
      {
        if (__p != v44)
        {
          v63 = 1.79769313e308;
          do
          {
            v64 = *v62;
            if (v61 <= *v62)
              goto LABEL_182;
            v65 = (unint64_t *)(v146 + 72 * v64);
            v66 = v65[1];
            if (v66 >= 1)
            {
              v67 = *v65;
              v68 = v66 + *v65;
              v69 = *(double *)(v146 + 72 * v64 + 56);
              v70 = __sincos_stret(v69);
              v71 = *((_QWORD *)v148 + 16);
              v72 = (*((_QWORD *)v148 + 17) - v71) >> 5;
              v73 = v72 >= v67;
              v74 = v72 - v67;
              if (v73)
                v75 = v74;
              else
                v75 = 0;
              if (v68 <= (uint64_t)(v67 + 1))
                v76 = v67 + 1;
              else
                v76 = v68;
              v77 = v76 + ~v67;
              if (v69 == 0.0)
                v78 = v7;
              else
                v78 = a5 * v70.__sinval + v70.__cosval * v7 + 0.0;
              rect1.origin.x = v78;
              if (v69 == 0.0)
                v79 = a5;
              else
                v79 = a5 * v70.__cosval - v70.__sinval * v7 + 0.0;
              v80 = (CGFloat *)(v71 + 32 * v67 + 16);
              v81 = v76 - v67;
              while (v75 > v77)
              {
                v83 = *(v80 - 2);
                v82 = *(v80 - 1);
                v85 = *v80;
                v84 = v80[1];
                v86 = v84 < 0.0 || *v80 < 0.0;
                if (v86)
                {
                  *(_QWORD *)&v87 = (unint64_t)CGRectStandardize(*(CGRect *)(v80 - 2));
                  v166.origin.x = v83;
                  v166.origin.y = v82;
                  v166.size.width = v85;
                  v166.size.height = v84;
                  v167 = CGRectStandardize(v166);
                }
                else
                {
                  v87 = *(v80 - 2);
                  v167.origin.x = v87;
                  v167.size.width = *v80;
                }
                v88 = v87 - rect1.origin.x;
                v89 = rect1.origin.x - (v167.origin.x + v167.size.width);
                if (v87 - rect1.origin.x < 0.0)
                  v88 = 0.0;
                if (v88 >= v89)
                  v90 = v88;
                else
                  v90 = v89;
                if (v86)
                {
                  v168.origin.x = v83;
                  v168.origin.y = v82;
                  v168.size.width = v85;
                  v168.size.height = v84;
                  v169 = CGRectStandardize(v168);
                  v91 = v169.origin.y;
                  v169.origin.x = v83;
                  v169.origin.y = v82;
                  v169.size.width = v85;
                  v169.size.height = v84;
                  v170 = CGRectStandardize(v169);
                  v84 = v170.size.height;
                  v82 = v91;
                }
                else
                {
                  v170.origin.y = v82;
                }
                v92 = v170.origin.y + v84;
                v93 = v82 - v79;
                v94 = v79 - v92;
                if (v82 - v79 < 0.0)
                  v93 = 0.0;
                if (v93 >= v94)
                  v94 = v93;
                v95 = v94 * v94 + v90 * v90;
                if (v95 < v63)
                {
                  v13 = v64;
                  v63 = v95;
                }
                v80 += 4;
                if (!--v81)
                  goto LABEL_97;
              }
              goto LABEL_182;
            }
LABEL_97:
            ++v62;
            v7 = a4;
          }
          while (v62 != (unint64_t *)v44);
        }
        if (v61 <= v13)
          goto LABEL_182;
        v96 = *(double *)(v146 + 72 * v13 + 56);
        v97 = v7;
        v98 = a3;
        v99 = a5;
        if (v96 != 0.0)
        {
          v100 = __sincos_stret(v96);
          v97 = a5 * v100.__sinval + v100.__cosval * v7 + 0.0;
        }
        v101 = v146 + 72 * v13;
        x = *(double *)(v101 + 24);
        v103 = *(double *)(v101 + 32);
        v104 = *(double *)(v101 + 40);
        v105 = *(double *)(v101 + 48);
        if (v104 < 0.0 || v105 < 0.0)
        {
          *(_QWORD *)&v106 = (unint64_t)CGRectStandardize(*(CGRect *)(v101 + 24));
          v171.origin.x = x;
          v171.origin.y = v103;
          v171.size.width = v104;
          v171.size.height = v105;
          v172 = CGRectStandardize(v171);
          x = v172.origin.x;
          v104 = v172.size.width;
        }
        else
        {
          v106 = *(double *)(v101 + 24);
        }
        v108 = v106 - v97;
        if (v106 - v97 < 0.0)
          v108 = 0.0;
        if (v108 >= v97 - (x + v104))
          v107 = v106 - v97 < 0.0;
        else
          v107 = 2;
      }
      if (v98 == 2 && (v107 != 1 || v149 != 0.0))
        goto LABEL_124;
      if (v61 > v13)
      {
        v109 = (unint64_t *)(v146 + 72 * v13);
        v110 = *v109;
        v154 = v110;
        v111 = v109[1];
        v112 = v111 + v110;
        *(_QWORD *)&rect1.size.height = v111 + v110;
        if (v107 == 2 || !v107)
        {
          PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()((uint64_t)v148, &v154, &rect1.size.height, 0);
          goto LABEL_124;
        }
        if (a2 == 2)
        {
          if (v98 - 2 >= 2 && v98 > 1)
            goto LABEL_124;
          goto LABEL_123;
        }
        v113 = *(double *)(v146 + 72 * v13 + 56);
        if (v113 != 0.0)
        {
          v114 = __sincos_stret(v113);
          v7 = v99 * v114.__sinval + v114.__cosval * v7 + 0.0;
        }
        if (v111 >= 1)
        {
          v115 = *((_QWORD *)v148 + 16);
          v116 = *((_QWORD *)v148 + 17) - v115;
          v117 = v116 >> 5;
          if (v112 <= (uint64_t)(v110 + 1))
            v118 = v110 + 1;
          else
            v118 = v111 + v110;
          if (v110 <= v116 >> 5)
            v119 = v116 >> 5;
          else
            v119 = v110;
          v120 = (double *)(v115 + 32 * v110 + 16);
          while (1)
          {
            if (v119 == v110)
              goto LABEL_182;
            v121 = v7;
            v122 = *(v120 - 2);
            v123 = *v120;
            v124 = v120[1];
            if (*v120 < 0.0 || v124 < 0.0)
            {
              if (COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(v120 - 2))) > v121)
                goto LABEL_146;
              v173.origin.y = *(v120 - 1);
              v173.origin.x = v122;
              v173.size.width = v123;
              v173.size.height = v124;
              v174 = CGRectStandardize(v173);
              v122 = v174.origin.x;
              v123 = v174.size.width;
            }
            else if (v122 > v121)
            {
              goto LABEL_146;
            }
            if (v121 <= v122 + v123)
            {
              v7 = v121;
              if (a3 == 2)
                goto LABEL_124;
              goto LABEL_153;
            }
LABEL_146:
            ++v110;
            v120 += 4;
            v7 = v121;
            if ((uint64_t)v110 >= v112)
            {
              v110 = v118;
              break;
            }
          }
        }
        if (a3 == 2 || v110 == -1)
          goto LABEL_124;
        v115 = *((_QWORD *)v148 + 16);
        v117 = (*((_QWORD *)v148 + 17) - v115) >> 5;
LABEL_153:
        if (v117 > v110)
        {
          v125 = v115 + 32 * v110;
          v126 = *(double *)v125;
          v127 = *(double *)(v125 + 16);
          v128 = *(double *)(v125 + 24);
          if (v127 < 0.0 || v128 < 0.0)
          {
            v129 = *(_QWORD *)(v125 + 8);
            *(CGRect *)&v126 = CGRectStandardize(*(CGRect *)&v126);
          }
          if (a2)
          {
            WordRange = PageLayout::getWordRange(v148, v13, v110);
            *(_QWORD *)&rect1.origin.y = (char *)WordRange + v131;
            *(_QWORD *)&rect1.size.width = WordRange;
            PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()((uint64_t)v148, (unint64_t *)&rect1.size, &rect1.origin.y, 1);
            goto LABEL_124;
          }
          v132 = v126 + v127 * 0.5;
          if (!*((_BYTE *)v148 + 8))
          {
LABEL_124:
            if (__p)
              operator delete(__p);
            return;
          }
          v133 = (unint64_t)PageLayout::convertRTLTextRangeIndexToStringRangeIndex(v148, v110);
          if (v133 == ((uint64_t)(*((_QWORD *)v148 + 38) - *((_QWORD *)v148 + 37)) >> 3) - 1)
            goto LABEL_185;
          v134 = v133 + 1;
          if (objc_msgSend(*((id *)v148 + 3), "characterAtIndex:", v133 + 1) == 10)
            goto LABEL_185;
          v135 = *((_QWORD *)v148 + 37);
          v136 = (*((_QWORD *)v148 + 38) - v135) >> 3;
          if (v136 <= v133 || v136 <= v134)
            goto LABEL_182;
          if (*(_QWORD *)(v135 + 8 * v133) > *(_QWORD *)(v135 + 8 * v134))
          {
LABEL_185:
            if (v133
              && (v137 = v133 - 1, objc_msgSend(*((id *)v148 + 3), "characterAtIndex:", v133 - 1) != 10))
            {
              v139 = *((_QWORD *)v148 + 37);
              v140 = (*((_QWORD *)v148 + 38) - v139) >> 3;
              if (v140 <= v137 || v140 <= v133)
                goto LABEL_182;
              v138 = *(_QWORD *)(v139 + 8 * v137) > *(_QWORD *)(v139 + 8 * v133);
            }
            else
            {
              v138 = 1;
            }
          }
          else
          {
            v138 = 0;
          }
          if (v138 == v7 >= v132 || v133 >= ((uint64_t)(*((_QWORD *)v148 + 38) - *((_QWORD *)v148 + 37)) >> 3) - 1)
            goto LABEL_124;
          v141 = v133 + 1;
          if (objc_msgSend(*((id *)v148 + 3), "characterAtIndex:", v141) == 10)
          {
LABEL_123:
            PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()((uint64_t)v148, &v154, &rect1.size.height, 1);
            goto LABEL_124;
          }
          v142 = *((_QWORD *)v148 + 37);
          if (v141 < (*((_QWORD *)v148 + 38) - v142) >> 3)
          {
            PageLayout::convertStringRangeIndexToTextRangeIndex(*((_QWORD **)v148 + 19), *((_QWORD **)v148 + 20), *(_QWORD *)(v142 + 8 * v141));
            goto LABEL_124;
          }
        }
      }
LABEL_182:
      __break(1u);
    }
  }
}

void sub_184C8BFF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *PageLayout::convertRTLTextRangeIndexToStringRangeIndex(_QWORD *this, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;

  v2 = this[19];
  if (a2 >= (this[20] - v2) >> 3 || (v3 = this[10], a2 >= (this[11] - v3) >> 3))
  {
    __break(1u);
  }
  else
  {
    v4 = *(_QWORD *)(v3 + 8 * a2);
    if (v4 <= 1)
      v5 = 1;
    else
      v5 = v4;
    v6 = (_QWORD *)this[37];
    v7 = (_QWORD *)this[38];
    if (v6 == v7)
    {
      v9 = (_QWORD *)this[37];
    }
    else
    {
      v8 = *(_QWORD *)(v2 + 8 * a2);
      v9 = (_QWORD *)this[37];
LABEL_8:
      v10 = 0;
      while (*v9 != v10 + v8)
      {
        v10 = (v10 + 1);
        if (v10 == v5)
        {
          if (++v9 != v7)
            goto LABEL_8;
          v9 = (_QWORD *)this[38];
          break;
        }
      }
    }
    v11 = v9 - v6;
    if (v11 < v7 - v6 - 1 && v4 == 0)
      return (_QWORD *)(v11 + 1);
    else
      return (_QWORD *)(v9 - v6);
  }
  return this;
}

_QWORD *PageLayout::CreateSelectionForStringRange(id *this, CFRange a2)
{
  uint64_t v2;
  unint64_t location;
  _QWORD *v5;
  _QWORD *result;
  id v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;
  _BYTE *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  CFRange v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v24[6];

  v2 = 0;
  if (a2.location < 0 || a2.length < 1)
    return (_QWORD *)v2;
  location = a2.location;
  v5 = (_QWORD *)(a2.location + a2.length);
  result = (_QWORD *)objc_msgSend(this[3], "length");
  if ((uint64_t)v5 > (uint64_t)result)
    return 0;
  if (*((_BYTE *)this + 8))
  {
    v2 = CGPDFSelectionCreateWithPage(*this);
    v7 = objc_alloc_init(MEMORY[0x1E0CB3788]);
    do
    {
      result = (_QWORD *)objc_msgSend(this[3], "characterAtIndex:", location);
      if ((_DWORD)result != 10)
      {
        v8 = this[37];
        if (location >= ((_BYTE *)this[38] - v8) >> 3)
          goto LABEL_30;
        objc_msgSend(v7, "addIndex:", PageLayout::convertStringRangeIndexToTextRangeIndex(this[19], this[20], *(_QWORD *)&v8[8 * location]));
      }
      ++location;
    }
    while ((uint64_t)location < (uint64_t)v5);
    v24[0] = MEMORY[0x1E0C809B0];
    v24[1] = 3221225472;
    v24[2] = ___ZNK10PageLayout29CreateSelectionForStringRangeE7CFRange_block_invoke;
    v24[3] = &__block_descriptor_48_e24_v32__0__NSRange_QQ_8_B24l;
    v24[4] = this;
    v24[5] = v2 + 168;
    objc_msgSend(v7, "enumerateRangesUsingBlock:", v24);
    Selection::Normalize((Selection *)(v2 + 168));

    return (_QWORD *)v2;
  }
  v9 = this[19];
  v10 = this[20];
  v11 = (v10 - v9) >> 3;
  if (v10 == v9)
  {
    v12 = this[19];
  }
  else
  {
    v12 = this[19];
    v13 = (v10 - v9) >> 3;
    do
    {
      v14 = v13 >> 1;
      v15 = (unint64_t *)&v12[8 * (v13 >> 1)];
      v17 = *v15;
      v16 = v15 + 1;
      v13 += ~(v13 >> 1);
      if (v17 < location)
        v12 = v16;
      else
        v13 = v14;
    }
    while (v13);
  }
  if (v11 <= (v12 - v9) >> 3)
  {
LABEL_30:
    __break(1u);
  }
  else
  {
    v18.location = ((v12 - v9) >> 3) - (*(_QWORD *)&v9[8 * ((v12 - v9) >> 3)] != location);
    if (v10 != v12)
    {
      v19 = (v10 - v12) >> 3;
      do
      {
        v20 = v19 >> 1;
        v21 = (unint64_t *)&v12[8 * (v19 >> 1)];
        v23 = *v21;
        v22 = v21 + 1;
        v19 += ~(v19 >> 1);
        if (v23 < (unint64_t)v5)
          v12 = v22;
        else
          v19 = v20;
      }
      while (v19);
      v11 = (v12 - v9) >> 3;
    }
    v18.length = v11 - v18.location;
    return PageLayout::CreateSelectionForTextRange((PageLayout *)this, v18);
  }
  return result;
}

void sub_184C8C2B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *PageLayout::CreateSelectionForTextRange(PageLayout *this, CFRange a2)
{
  _QWORD *v2;
  CFIndex length;
  CFIndex location;
  unint64_t LineIndex;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  unint64_t *v19;
  char *v20;
  char *v21;
  __int128 v22;

  v2 = 0;
  if ((a2.location & 0x8000000000000000) == 0)
  {
    length = a2.length;
    if (a2.length >= 1)
    {
      location = a2.location;
      if (a2.location + a2.length > (uint64_t)(*((_QWORD *)this + 14) - *((_QWORD *)this + 13)) >> 5)
        return 0;
      v2 = (_QWORD *)CGPDFSelectionCreateWithPage(*(const void **)this);
      LineIndex = PageLayout::getLineIndex(*((PageLayout **)this + 4), *((PageLayout **)this + 5), location);
      v7 = LineIndex;
      v8 = (unint64_t *)v2[24];
      v9 = v2[25];
      if ((unint64_t)v8 >= v9)
      {
        v11 = v2[23];
        v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v8 - v11) >> 3);
        v13 = v12 + 1;
        if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
          goto LABEL_24;
        v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v11) >> 3);
        if (2 * v14 > v13)
          v13 = 2 * v14;
        if (v14 >= 0x555555555555555)
          v15 = 0xAAAAAAAAAAAAAAALL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v15);
          if (v16)
          {
            v18 = &v16[24 * v17];
            v19 = (unint64_t *)&v16[24 * v12];
            *v19 = v7;
            v19[1] = location;
            v19[2] = length;
            v10 = v19 + 3;
            v21 = (char *)v2[23];
            v20 = (char *)v2[24];
            if (v20 != v21)
            {
              do
              {
                v22 = *(_OWORD *)(v20 - 24);
                *(v19 - 1) = *((_QWORD *)v20 - 1);
                *(_OWORD *)(v19 - 3) = v22;
                v19 -= 3;
                v20 -= 24;
              }
              while (v20 != v21);
              v20 = (char *)v2[23];
            }
            v2[23] = v19;
            v2[24] = v10;
            v2[25] = v18;
            if (v20)
              operator delete(v20);
            goto LABEL_21;
          }
        }
      }
      else if (v8)
      {
        *v8 = LineIndex;
        v8[1] = location;
        v10 = v8 + 3;
        v8[2] = length;
LABEL_21:
        v2[24] = v10;
        Selection::Normalize((Selection *)(v2 + 21));
        return v2;
      }
      __break(1u);
LABEL_24:
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    }
  }
  return v2;
}

void ___ZNK10PageLayout29CreateSelectionForStringRangeE7CFRange_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t LineIndex;
  unint64_t v7;
  _QWORD *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  unint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;

  LineIndex = PageLayout::getLineIndex(*(PageLayout **)(*(_QWORD *)(a1 + 32) + 32), *(PageLayout **)(*(_QWORD *)(a1 + 32) + 40), a2);
  v7 = LineIndex;
  v8 = *(_QWORD **)(a1 + 40);
  v9 = (unint64_t *)v8[3];
  v10 = v8[4];
  if ((unint64_t)v9 < v10)
  {
    if (v9)
    {
      *v9 = LineIndex;
      v9[1] = a2;
      v11 = v9 + 3;
      v9[2] = a3;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v12 = v8[2];
  v13 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v12) >> 3);
  v14 = v13 + 1;
  if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_19;
  v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v12) >> 3);
  if (2 * v15 > v14)
    v14 = 2 * v15;
  if (v15 >= 0x555555555555555)
    v16 = 0xAAAAAAAAAAAAAAALL;
  else
    v16 = v14;
  if (!v16
    || (v17 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v16)) == 0)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v19 = &v17[24 * v18];
  v20 = (unint64_t *)&v17[24 * v13];
  *v20 = v7;
  v20[1] = a2;
  v20[2] = a3;
  v11 = v20 + 3;
  v22 = (char *)v8[2];
  v21 = (char *)v8[3];
  if (v21 != v22)
  {
    do
    {
      v23 = *(_OWORD *)(v21 - 24);
      *(v20 - 1) = *((_QWORD *)v21 - 1);
      *(_OWORD *)(v20 - 3) = v23;
      v20 -= 3;
      v21 -= 24;
    }
    while (v21 != v22);
    v21 = (char *)v8[2];
  }
  v8[2] = v20;
  v8[3] = v11;
  v8[4] = v19;
  if (v21)
    operator delete(v21);
LABEL_17:
  v8[3] = v11;
}

_QWORD *PageLayout::convertStringRangeIndexToTextRangeIndex(_QWORD *this, _QWORD *a2, unint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *i;
  uint64_t v16;
  uint64_t v17;

  v3 = this;
  v4 = a2 - this;
  if (a2 != this)
  {
    v3 = this;
    v5 = a2 - this;
    do
    {
      v6 = v5 >> 1;
      v7 = &v3[v5 >> 1];
      v9 = *v7;
      v8 = v7 + 1;
      v5 += ~(v5 >> 1);
      if (v9 < a3)
        v3 = v8;
      else
        v5 = v6;
    }
    while (v5);
  }
  if (*v3 == a3)
    v10 = 0;
  else
    v10 = -1;
  v11 = (char *)&v3[v10] - (char *)this;
  v12 = v11 >> 3;
  v13 = v4 - 1;
  if (v11 >> 3 > v4 - 1)
    v13 = v11 >> 3;
  if (v12 <= v4)
    v14 = a2 - this;
  else
    v14 = v11 >> 3;
  for (i = (_QWORD *)((char *)this + (v11 & 0xFFFFFFFFFFFFFFF8) + 8); ; ++i)
  {
    if (v13 == v12)
      return (_QWORD *)v13;
    if (v14 == v12)
      break;
    if (v4 <= ++v12)
      break;
    v16 = *(i - 1);
    v17 = *i;
    if (v16 != v17)
      return (_QWORD *)(v12 - 1);
  }
  __break(1u);
  return this;
}

unint64_t PageLayout::getLineIndex(PageLayout *this, PageLayout *a2, uint64_t a3)
{
  PageLayout *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  PageLayout *v7;
  uint64_t v8;

  v3 = this;
  if (a2 != this)
  {
    v4 = 0x8E38E38E38E38E39 * ((a2 - this) >> 3);
    v3 = this;
    do
    {
      v5 = v4 >> 1;
      v6 = (uint64_t *)((char *)v3 + 72 * (v4 >> 1));
      v8 = *v6;
      v7 = (PageLayout *)(v6 + 9);
      v4 += ~(v4 >> 1);
      if (v8 < a3)
        v3 = v7;
      else
        v4 = v5;
    }
    while (v4);
  }
  if (v3 == a2 || *(_QWORD *)v3 != a3)
    v3 = (PageLayout *)((char *)v3 - 72);
  return 0x8E38E38E38E38E39 * ((v3 - this) >> 3);
}

void PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()(uint64_t a1, unint64_t *a2, _QWORD *a3, char a4)
{
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  void **p_p;
  _QWORD v20[2];
  void *__p;
  void *v22;
  uint64_t v23;
  _QWORD v24[2];

  if (*(_BYTE *)(a1 + 8))
  {
    v8 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex((_QWORD *)a1, *a3 - 1);
    v9 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex((_QWORD *)a1, *a2);
    v10 = *a3 - *a2;
    v24[0] = *a2;
    v24[1] = v10;
    __p = 0;
    v22 = 0;
    v23 = 0;
    v20[0] = v24;
    v20[1] = 1;
    p_p = &__p;
    PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(a1, (uint64_t)v20, &p_p);
    v11 = __p;
    if (__p != v22)
    {
      v12 = *(_QWORD *)__p;
      v13 = *(_QWORD *)(a1 + 296);
      v14 = (*(_QWORD *)(a1 + 304) - v13) >> 3;
      if ((int64_t)(v14 - 1) >= *((_QWORD *)__p + 1) + *(_QWORD *)__p)
        v15 = *((_QWORD *)__p + 1) + *(_QWORD *)__p;
      else
        v15 = v14 - 1;
      if (v14 <= v12
        || (*a2 = (unint64_t)PageLayout::convertStringRangeIndexToTextRangeIndex(*(_QWORD **)(a1 + 152), *(_QWORD **)(a1 + 160), *(_QWORD *)(v13 + 8 * v12)), v16 = *(_QWORD *)(a1 + 296), v15 >= (*(_QWORD *)(a1 + 304) - v16) >> 3))
      {
        __break(1u);
        return;
      }
      v17 = PageLayout::convertStringRangeIndexToTextRangeIndex(*(_QWORD **)(a1 + 152), *(_QWORD **)(a1 + 160), *(_QWORD *)(v16 + 8 * v15));
      *a3 = v17;
      if ((a4 & 1) == 0 && (uint64_t)v8 < (uint64_t)v9)
      {
        v18 = *a2;
        *a2 = (unint64_t)v17;
        *a3 = v18;
      }
      v11 = __p;
    }
    if (v11)
    {
      v22 = v11;
      operator delete(v11);
    }
  }
}

void sub_184C8C7F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *PageLayout::getWordRange(_QWORD *this, unint64_t a2, unint64_t a3)
{
  uint64_t v3;
  _QWORD *v5;
  int64_t *v6;
  int64_t v7;
  int64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  _BOOL4 v25;
  BOOL v26;
  int v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  _BOOL4 v35;
  int v36;
  BOOL v37;
  _BOOL4 v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v43;
  int64_t v44;
  unint64_t v45;
  uint64_t v46;
  _BOOL4 v48;
  int v49;
  BOOL v50;
  _BOOL4 v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;

  v3 = this[4];
  if (0x8E38E38E38E38E39 * ((this[5] - v3) >> 3) > a2)
  {
    v5 = this;
    v6 = (int64_t *)(v3 + 72 * a2);
    v7 = *v6;
    v8 = v6[1];
    v9 = v6[2];
    v10 = __OFSUB__(a3, *v6);
    v11 = a3 - *v6;
    if (!((v11 < 0) ^ v10 | (v11 == 0)))
    {
      v12 = this[10];
      v13 = (this[11] - v12) >> 3;
      v14 = v13 >= v7;
      v15 = v13 - v7;
      if (!v14)
        v15 = 0;
      v16 = (uint64_t *)(v12 + 8 * v7);
      while (v15 > ~v7 + a3)
      {
        v17 = *v16++;
        v9 += v17;
        if (!--v11)
          goto LABEL_8;
      }
      goto LABEL_100;
    }
LABEL_8:
    v18 = this[7];
    if (v9 >= (this[8] - v18) >> 1)
      return 0;
    v19 = MEMORY[0x186DC3438](*(unsigned __int16 *)(v18 + 2 * v9));
    objc_msgSend(MEMORY[0x1E0CB3780], "punctuationCharacterSet");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceCharacterSet");
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v20, "formUnionWithCharacterSet:", v21);

    this = v20;
    v22 = v5[7];
    if (v9 < (v5[8] - v22) >> 1)
    {
      v23 = this;
      this = (_QWORD *)MEMORY[0x186DC3438](*(unsigned __int16 *)(v22 + 2 * v9));
      v25 = (_DWORD)this != 10 && (_DWORD)this != 17;
      if (v19 == (_DWORD)this)
        v25 = 0;
      v26 = v19 == 10 || v19 == 17;
      v27 = v26 ? (int)this : v19;
      v28 = !v26 && v25;
      v29 = v5[10];
      if (a3 < (v5[11] - v29) >> 3)
      {
        if (*(_QWORD *)(v29 + 8 * a3) != 1)
        {
          if (!v28)
          {
LABEL_31:
            if ((uint64_t)a3 > v7)
            {
              v31 = a3 - 1;
              v32 = v9;
              while (1)
              {
                v33 = v5[7];
                if (v32 >= (v5[8] - v33) >> 1)
                  goto LABEL_100;
                this = (_QWORD *)MEMORY[0x186DC3438](*(unsigned __int16 *)(v33 + 2 * v32));
                v35 = (_DWORD)this != 10 && (_DWORD)this != 17;
                if (v27 == (_DWORD)this)
                  v35 = 0;
                if (v27 == 17)
                  v36 = (int)this;
                else
                  v36 = v27;
                if (v27 == 17)
                  v35 = 0;
                v37 = v27 == 10;
                v27 = v27 == 10 ? (int)this : v36;
                v38 = !v37 && v35;
                v39 = v5[10];
                v40 = (v5[11] - v39) >> 3;
                if (v40 <= a3)
                  goto LABEL_100;
                if (*(_QWORD *)(v39 + 8 * a3) == 1)
                {
                  v41 = v5[7];
                  if (v32 >= (v5[8] - v41) >> 1)
                    goto LABEL_100;
                  this = (_QWORD *)objc_msgSend(v23, "characterIsMember:", *(unsigned __int16 *)(v41 + 2 * v32));
                  if (((this | v38) & 1) != 0)
                  {
LABEL_67:
                    v43 = v31 + 2;
                    goto LABEL_68;
                  }
                  v39 = v5[10];
                  v40 = (v5[11] - v39) >> 3;
                }
                else if (v38)
                {
                  goto LABEL_67;
                }
                if (v40 <= v31)
                  goto LABEL_100;
                v32 -= *(_QWORD *)(v39 + 8 * v31);
                if ((uint64_t)v31-- <= v7)
                {
                  v43 = v7;
                  goto LABEL_68;
                }
              }
            }
            v43 = a3;
LABEL_68:
            v44 = v8 + v7;
            if (v44 > (uint64_t)a3)
            {
              v45 = a3;
              while (1)
              {
                v46 = v5[7];
                if (v9 >= (v5[8] - v46) >> 1)
                  goto LABEL_100;
                this = (_QWORD *)MEMORY[0x186DC3438](*(unsigned __int16 *)(v46 + 2 * v9));
                v48 = (_DWORD)this != 10 && (_DWORD)this != 17;
                if (v27 == (_DWORD)this)
                  v48 = 0;
                if (v27 == 17)
                  v49 = (int)this;
                else
                  v49 = v27;
                if (v27 == 17)
                  v48 = 0;
                v50 = v27 == 10;
                v27 = v27 == 10 ? (int)this : v49;
                v51 = !v50 && v48;
                v52 = v5[10];
                v53 = (v5[11] - v52) >> 3;
                if (v53 <= a3)
                  goto LABEL_100;
                if (*(_QWORD *)(v52 + 8 * a3) == 1)
                {
                  v54 = v5[7];
                  if (v9 >= (v5[8] - v54) >> 1)
                    goto LABEL_100;
                  this = (_QWORD *)objc_msgSend(v23, "characterIsMember:", *(unsigned __int16 *)(v54 + 2 * v9));
                  if (((this | v51) & 1) != 0)
                    goto LABEL_98;
                  v52 = v5[10];
                  v53 = (v5[11] - v52) >> 3;
                }
                else if (v51)
                {
                  goto LABEL_98;
                }
                if (v53 <= v45)
                  goto LABEL_100;
                v9 += *(_QWORD *)(v52 + 8 * v45++);
                if (v44 == v45)
                  goto LABEL_98;
              }
            }
            goto LABEL_98;
          }
LABEL_65:
          v43 = a3;
LABEL_98:

          return (_QWORD *)v43;
        }
        v30 = v5[7];
        if (v9 < (v5[8] - v30) >> 1)
        {
          this = (_QWORD *)objc_msgSend(v23, "characterIsMember:", *(unsigned __int16 *)(v30 + 2 * v9));
          if (((this | v28) & 1) == 0)
            goto LABEL_31;
          goto LABEL_65;
        }
      }
    }
  }
LABEL_100:
  __break(1u);
  return this;
}

void sub_184C8CBA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id PageLayout::CreateAttributedStringForStringRanges(uint64_t a1, uint64_t a2)
{
  id *v4;
  void *v5;
  id *v6;
  void *v7;
  uint64_t v8;
  NSRange *v9;
  NSRange v10;
  id v11;
  void *v12;
  uint64_t v13;
  NSUInteger v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  __int128 *v20;
  __int128 v21;
  double v22;
  std::string *v23;
  PageLayout *v24;
  uint64_t v25;
  PageLayout *v26;
  double v27;
  void *CTFont;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  _BOOL4 v34;
  id v36;
  uint64_t v37;
  NSUInteger range2;
  NSRange *v39;
  id v40;
  id v41;
  id v42;
  void *v43;
  std::string v44;
  NSString *v45;
  _QWORD v46[3];
  _QWORD v47[5];
  NSRange v48;

  v47[3] = *MEMORY[0x1E0C80C00];
  v44.__r_.__value_.__r.__words[0] = 0;
  v44.__r_.__value_.__l.__size_ = (std::string::size_type)&v44;
  v44.__r_.__value_.__r.__words[2] = 0x2020000000;
  v4 = (id *)getkCTFontAttributeNameSymbolLoc(void)::ptr;
  v45 = (NSString *)getkCTFontAttributeNameSymbolLoc(void)::ptr;
  if (!getkCTFontAttributeNameSymbolLoc(void)::ptr)
  {
    v5 = (void *)CoreTextLibrary();
    v4 = (id *)dlsym(v5, "kCTFontAttributeName");
    *(_QWORD *)(v44.__r_.__value_.__l.__size_ + 24) = v4;
    getkCTFontAttributeNameSymbolLoc(void)::ptr = (uint64_t)v4;
  }
  _Block_object_dispose(&v44, 8);
  if (!v4)
    goto LABEL_32;
  v41 = *v4;
  v42 = (id)kCGPDFSelectionForegroundColorAttributeName;
  v44.__r_.__value_.__r.__words[0] = 0;
  v44.__r_.__value_.__l.__size_ = (std::string::size_type)&v44;
  v44.__r_.__value_.__r.__words[2] = 0x2020000000;
  v6 = (id *)getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  v45 = (NSString *)getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  if (!getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr)
  {
    v7 = (void *)CoreTextLibrary();
    v6 = (id *)dlsym(v7, "kCTBaselineOffsetAttributeName");
    *(_QWORD *)(v44.__r_.__value_.__l.__size_ + 24) = v6;
    getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr = (uint64_t)v6;
  }
  _Block_object_dispose(&v44, 8);
  if (!v6)
  {
LABEL_32:
    dlerror();
    abort_report_np();
    goto LABEL_33;
  }
  v40 = *v6;
  v36 = objc_alloc_init(MEMORY[0x1E0CB3778]);
  range2 = objc_msgSend(*(id *)(a1 + 24), "length");
  v8 = *(_QWORD *)(a2 + 8);
  if (v8)
  {
    v9 = *(NSRange **)a2;
    v37 = *(_QWORD *)a2 + 16 * v8;
    do
    {
      v39 = v9;
      v48.location = 0;
      v48.length = range2;
      v10 = NSIntersectionRange(*v9, v48);
      if (v10.length)
      {
        v11 = objc_alloc(MEMORY[0x1E0CB3778]);
        objc_msgSend(*(id *)(a1 + 24), "substringWithRange:", v10.location, v10.length);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v43 = (void *)objc_msgSend(v11, "initWithString:", v12);

        if ((uint64_t)v10.length >= 1)
        {
          v13 = 0;
          v14 = 8 * v10.location;
          while (1)
          {
            v15 = *(_QWORD *)(a1 + 200);
            if (v10.location + v13 >= (*(_QWORD *)(a1 + 208) - v15) >> 3)
              break;
            v16 = *(_QWORD *)(v15 + v14 + 8 * v13);
            v17 = *(_QWORD *)(a1 + 176);
            if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 184) - v17) >> 3) <= v16)
              break;
            v18 = *(_QWORD *)(v17 + 24 * v16);
            v19 = *(_QWORD *)(a1 + 248);
            if (v18 >= (*(_QWORD *)(a1 + 256) - v19) >> 5)
              break;
            v20 = (__int128 *)(v19 + 32 * v18);
            if (*((char *)v20 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v44, *(const std::string::value_type **)v20, *((_QWORD *)v20 + 1));
            }
            else
            {
              v21 = *v20;
              v44.__r_.__value_.__r.__words[2] = *((_QWORD *)v20 + 2);
              *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v21;
            }
            LODWORD(v45) = *(_DWORD *)(v19 + 32 * v18 + 24);
            v22 = *(double *)(v17 + 24 * v16 + 8);
            v23 = (v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &v44
                : (std::string *)v44.__r_.__value_.__r.__words[0];
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v23);
            v24 = (PageLayout *)objc_claimAutoreleasedReturnValue();
            v25 = *(_QWORD *)(a1 + 224);
            if (v10.location + v13 >= (*(_QWORD *)(a1 + 232) - v25) >> 3)
              break;
            v26 = v24;
            v27 = *(double *)(v25 + v14 + 8 * v13);
            CTFont = (void *)PageLayout::CreateCTFont(v24, (NSString *)v45, v22);
            v47[0] = CTFont;
            v46[0] = v41;
            v46[1] = v42;
            v29 = v17 + 24 * v16;
            v30 = *(void **)(v29 + 16);
            if (v30)
              CFRetain(*(CFTypeRef *)(v29 + 16));
            v47[1] = v30;
            v46[2] = v40;
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v27);
            v31 = (void *)objc_claimAutoreleasedReturnValue();
            v47[2] = v31;
            objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v47, v46, 3);
            v32 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v43, "setAttributes:range:", v32, v13, 1);

            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v44.__r_.__value_.__l.__data_);
            if (v10.length == ++v13)
              goto LABEL_27;
          }
LABEL_33:
          __break(1u);
        }
LABEL_27:
        objc_msgSend(v36, "appendAttributedString:", v43);

      }
      v9 = v39 + 1;
    }
    while (&v39[1] != (NSRange *)v37);
  }
  objc_msgSend(v36, "string");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = objc_msgSend(v33, "characterAtIndex:", objc_msgSend(v36, "length") - 1) == 10;

  if (v34)
    objc_msgSend(v36, "deleteCharactersInRange:", objc_msgSend(v36, "length") - 1, 1);

  return v36;
}

void sub_184C8D01C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  _Block_object_dispose(&__p, 8);

  _Unwind_Resume(a1);
}

uint64_t CoreTextLibrary(void)
{
  uint64_t v0;
  void *v2;

  if (CoreTextLibraryCore(char **)::frameworkLibrary)
    return CoreTextLibraryCore(char **)::frameworkLibrary;
  CoreTextLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  v0 = CoreTextLibraryCore(char **)::frameworkLibrary;
  if (!CoreTextLibraryCore(char **)::frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

uint64_t PageLayout::CreateCTFont(PageLayout *this, NSString *a2, double a3)
{
  char v3;
  PageLayout *v5;
  const CGAffineTransform *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const CGAffineTransform *v10;
  const __CFString *v11;
  const __CFString *v12;
  __CFString *v13;

  v3 = (char)a2;
  v5 = this;
  if ((unint64_t)-[PageLayout length](v5, "length") >= 8
    && -[PageLayout characterAtIndex:](v5, "characterAtIndex:", 6) == 43)
  {
    -[PageLayout substringFromIndex:](v5, "substringFromIndex:", 7);
    v7 = objc_claimAutoreleasedReturnValue();

    v5 = (PageLayout *)v7;
  }
  v8 = CTFontCreateWithName((const __CFString *)v5, a3, v6);
  if (!v8)
  {
    objc_msgSend(&unk_1E1674C58, "objectForKey:", v5);
    v9 = objc_claimAutoreleasedReturnValue();
    v11 = CFSTR("Monaco");
    if ((v3 & 1) != 0)
    {
      v12 = CFSTR("Courier");
    }
    else
    {
      v11 = CFSTR("Helvetica");
      v12 = CFSTR("Times");
    }
    if ((v3 & 2) != 0)
      v11 = v12;
    if (v9)
      v13 = (__CFString *)v9;
    else
      v13 = (__CFString *)v11;
    v8 = CTFontCreateWithName(v13, a3, v10);

  }
  return v8;
}

void sub_184C8D2C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t CTFontCreateWithName(const __CFString *a1, double a2, const CGAffineTransform *a3)
{
  void *v5;
  void *v6;
  _Unwind_Exception *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  void *v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v5 = getCTFontCreateWithNameSymbolLoc(void)::ptr;
  v12 = getCTFontCreateWithNameSymbolLoc(void)::ptr;
  if (!getCTFontCreateWithNameSymbolLoc(void)::ptr)
  {
    v6 = (void *)CoreTextLibrary();
    v5 = dlsym(v6, "CTFontCreateWithName");
    v10[3] = (uint64_t)v5;
    getCTFontCreateWithNameSymbolLoc(void)::ptr = v5;
  }
  _Block_object_dispose(&v9, 8);
  if (!v5)
  {
    dlerror();
    v8 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v9, 8);
    _Unwind_Resume(v8);
  }
  return ((uint64_t (*)(const __CFString *, _QWORD, double))v5)(a1, 0, a2);
}

void PageLayout::GetBoundsForRangeWithinLine(_QWORD *a1, unint64_t a2, unint64_t a3, unint64_t LineIndex, char a5)
{
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  CGRect *v13;
  CGRect *v14;
  CGFloat width;
  CGFloat x;
  CGFloat y;
  CGFloat height;
  PageLayout *v19;
  PageLayout *v20;
  __double2 v21;
  CGAffineTransform v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;

  v5 = a1[13];
  v6 = (a1[14] - v5) >> 5;
  v7 = v6 >= a2;
  v8 = v6 - a2;
  if (!v7)
    goto LABEL_16;
  if (a3 == -1)
  {
    a3 = v8;
    if (v8)
    {
LABEL_6:
      v13 = (CGRect *)(v5 + 32 * a2);
      v14 = &v13[a3];
      width = 0.0;
      x = INFINITY;
      y = INFINITY;
      height = 0.0;
      do
      {
        v23.origin.x = x;
        v23.origin.y = y;
        v23.size.width = width;
        v23.size.height = height;
        v24 = CGRectUnion(v23, *v13);
        x = v24.origin.x;
        y = v24.origin.y;
        width = v24.size.width;
        height = v24.size.height;
        ++v13;
      }
      while (v13 != v14);
      goto LABEL_11;
    }
  }
  else
  {
    if (v8 < a3)
      goto LABEL_16;
    if (a3)
      goto LABEL_6;
  }
  height = 0.0;
  y = INFINITY;
  width = 0.0;
  x = INFINITY;
LABEL_11:
  if (a5)
  {
    v19 = (PageLayout *)a1[4];
    v20 = (PageLayout *)a1[5];
  }
  else
  {
    v19 = (PageLayout *)a1[4];
    v20 = (PageLayout *)a1[5];
    LineIndex = PageLayout::getLineIndex(v19, v20, a2);
  }
  if (0x8E38E38E38E38E39 * ((v20 - v19) >> 3) > LineIndex)
  {
    v21 = __sincos_stret(*((double *)v19 + 9 * LineIndex + 7));
    v22.a = v21.__cosval;
    v22.b = v21.__sinval;
    v22.c = -v21.__sinval;
    v22.d = v21.__cosval;
    v22.tx = 0.0;
    v22.ty = 0.0;
    v25.origin.x = x;
    v25.origin.y = y;
    v25.size.width = width;
    v25.size.height = height;
    CGRectApplyAffineTransform(v25, &v22);
    return;
  }
LABEL_16:
  __break(1u);
}

void PageLayout::GetBoundsForTextRange(PageLayout *this, CFRange a2)
{
  CFIndex length;
  CFIndex location;
  PageLayout *v5;
  PageLayout *v6;
  unint64_t LineIndex;
  unint64_t v8;
  _QWORD *v9;
  CFIndex v10;
  CFIndex v11;
  uint64_t v12;
  CGFloat height;
  CGFloat y;
  CGFloat width;
  CGFloat x;
  CFIndex v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat v21;
  uint64_t v22;
  CGFloat v23;
  CGFloat v24;
  CGFloat v25;
  CGFloat v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;
  CGRect v30;
  CGRect v31;

  length = a2.length;
  location = a2.location;
  v5 = (PageLayout *)*((_QWORD *)this + 4);
  v6 = (PageLayout *)*((_QWORD *)this + 5);
  LineIndex = PageLayout::getLineIndex(v5, v6, a2.location);
  if (0x8E38E38E38E38E39 * ((v6 - v5) >> 3) <= LineIndex)
  {
LABEL_9:
    __break(1u);
    return;
  }
  v8 = LineIndex;
  v9 = (_QWORD *)((char *)v5 + 72 * LineIndex);
  v10 = length + location;
  v11 = v9[1] + *v9;
  if (length + location > v11)
  {
    v12 = 72 * LineIndex;
    height = 0.0;
    y = INFINITY;
    width = 0.0;
    x = INFINITY;
    while (1)
    {
      v17 = v11;
      PageLayout::GetBoundsForRangeWithinLine(this, location, v11 - location, v8++, 1);
      v22 = *((_QWORD *)this + 4);
      if (0x8E38E38E38E38E39 * ((*((_QWORD *)this + 5) - v22) >> 3) <= v8)
        goto LABEL_9;
      v30.origin.x = v18;
      v30.origin.y = v19;
      v30.size.width = v20;
      v30.size.height = v21;
      v27.origin.x = x;
      v27.origin.y = y;
      v27.size.width = width;
      v27.size.height = height;
      v28 = CGRectUnion(v27, v30);
      x = v28.origin.x;
      y = v28.origin.y;
      width = v28.size.width;
      height = v28.size.height;
      v11 = *(_QWORD *)(v22 + v12 + 80) + *(_QWORD *)(v22 + v12 + 72);
      v12 += 72;
      location = v17;
      if (v10 <= v11)
      {
        length = v10 - v17;
        location = v17;
        goto LABEL_8;
      }
    }
  }
  height = 0.0;
  y = INFINITY;
  width = 0.0;
  x = INFINITY;
LABEL_8:
  PageLayout::GetBoundsForRangeWithinLine(this, location, length, v8, 1);
  v31.origin.x = v23;
  v31.origin.y = v24;
  v31.size.width = v25;
  v31.size.height = v26;
  v29.origin.x = x;
  v29.origin.y = y;
  v29.size.width = width;
  v29.size.height = height;
  CGRectUnion(v29, v31);
}

void ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke(double *a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  CGPDFLayout *v4;
  CGPDFLayout *v5;
  __n64 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGFloat v12;
  CGFloat v13;
  const CGRect *v14;
  uint64_t v15;
  CGPoint v16;

  v2 = *((_QWORD *)a1 + 5);
  v3 = (os_unfair_lock_s *)(v2 + 376);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 376));
  *(_BYTE *)(v2 + 380) = 1;
  v15 = v2;
  v4 = CGPDFLayoutCreateWithPage(*(_QWORD *)v2);
  v5 = v4;
  if (v4)
    v6 = (__n64 *)*((_QWORD *)v4 + 13);
  else
    v6 = 0;
  _ZZZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectEEUb_ENK3__4clIRS7_EEDaP9CGPDFNodeOT_(&v15, v6, (uint64_t)&v15);
  if (v5)
    CFRelease(v5);
  v7 = *((_QWORD *)a1 + 4);
  v8 = *((_QWORD *)a1 + 6);
  v9 = *(_QWORD *)(v8 + 384);
  v10 = *(_QWORD *)(v8 + 392);
  if (v9 == v10)
  {
    v14 = &CGRectNull;
  }
  else
  {
    v11 = 0;
    v12 = a1[7];
    v13 = a1[8];
    do
    {
      v16.x = v12;
      v16.y = v13;
      if (CGRectContainsPoint(*(CGRect *)v9, v16) && (!v11 || *(_QWORD *)(v9 + 32) >= *(_QWORD *)(v11 + 32)))
        v11 = v9;
      v9 += 40;
    }
    while (v9 != v10);
    v14 = &CGRectNull;
    if (v11)
      v14 = (const CGRect *)v11;
  }
  (*(void (**)(uint64_t, CGFloat, CGFloat, CGFloat, CGFloat))(v7 + 16))(v7, v14->origin.x, v14->origin.y, v14->size.width, v14->size.height);
  os_unfair_lock_unlock(v3);
}

void sub_184C8D7F8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void _ZZZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectEEUb_ENK3__4clIRS7_EEDaP9CGPDFNodeOT_(_QWORD *a1, __n64 *a2, uint64_t a3)
{
  __n64 *v3;
  _QWORD *v4;
  __n64 v5;
  __n64 v6;
  __n64 v7;
  __n64 v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t i;
  uint64_t v16;
  __n64 *v17;
  unint64_t v18;
  __n64 *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  unint64_t *v28;
  char *v29;
  char *v30;
  __int128 v31;
  __int128 v32;

  if (a2)
  {
    v3 = a2;
    if (a2->n64_u32[0] == 515)
    {
      v4 = (_QWORD *)*a1;
      v5.n64_u64[0] = CGPDFNodeGetBounds(a2).n64_u64[0];
      v9 = v5.n64_u64[0];
      v10 = v6.n64_u64[0];
      v11 = v7.n64_u64[0];
      v12 = v8.n64_u64[0];
      while ((v3->n64_u8[1] & 3) == 0)
      {
        v3 = (__n64 *)v3[1].n64_u64[0];
        if (!v3)
          goto LABEL_17;
      }
      v3 = (__n64 *)v3[12].n64_u64[0];
LABEL_17:
      v17 = (__n64 *)v4[49];
      v18 = v4[50];
      if ((unint64_t)v17 >= v18)
      {
        v20 = v4[48];
        v21 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v17 - v20) >> 3);
        v22 = v21 + 1;
        if (v21 + 1 > 0x666666666666666)
          goto LABEL_36;
        v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v18 - v20) >> 3);
        if (2 * v23 > v22)
          v22 = 2 * v23;
        if (v23 >= 0x333333333333333)
          v24 = 0x666666666666666;
        else
          v24 = v22;
        if (v24)
        {
          v25 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::Column>>(v24);
          if (v25)
          {
            v27 = &v25[40 * v26];
            v28 = (unint64_t *)&v25[40 * v21];
            *v28 = v9;
            v28[1] = v10;
            v28[2] = v11;
            v28[3] = v12;
            v28[4] = (unint64_t)v3;
            v19 = (__n64 *)(v28 + 5);
            v30 = (char *)v4[48];
            v29 = (char *)v4[49];
            if (v29 != v30)
            {
              do
              {
                v31 = *(_OWORD *)(v29 - 40);
                v32 = *(_OWORD *)(v29 - 24);
                *(v28 - 1) = *((_QWORD *)v29 - 1);
                *(_OWORD *)(v28 - 3) = v32;
                *(_OWORD *)(v28 - 5) = v31;
                v28 -= 5;
                v29 -= 40;
              }
              while (v29 != v30);
              v29 = (char *)v4[48];
            }
            v4[48] = v28;
            v4[49] = v19;
            v4[50] = v27;
            if (v29)
              operator delete(v29);
            goto LABEL_33;
          }
        }
      }
      else if (v17)
      {
        v17->n64_u64[0] = v5.n64_u64[0];
        v17[1].n64_u64[0] = v6.n64_u64[0];
        v17[2].n64_u64[0] = v7.n64_u64[0];
        v17[3].n64_u64[0] = v8.n64_u64[0];
        v19 = v17 + 5;
        v17[4].n64_u64[0] = (unint64_t)v3;
LABEL_33:
        v4[49] = v19;
        return;
      }
      __break(1u);
LABEL_36:
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    }
    if ((a2->n64_u32[0] & 0x200) != 0)
    {
      v13 = a2[5].n64_u32[1];
      if ((_DWORD)v13)
      {
        for (i = 0; i != v13; ++i)
        {
          if ((v3->n64_u8[1] & 2) != 0 && i < v3[5].n64_u32[1])
            v16 = *(_QWORD *)(v3[7].n64_u64[0] + 8 * i);
          else
            v16 = 0;
          _ZZZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectEEUb_ENK3__4clIRS7_EEDaP9CGPDFNodeOT_(a3, v16, a3);
        }
      }
    }
  }
}

void *std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::Column>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:se180100]();
  return operator new(40 * a1);
}

BOOL std::__equal_to::operator()[abi:se180100]<CGRect,CGRect>(CGRect *a1, CGRect *a2)
{
  return CGRectEqualToRect(*a1, *a2);
}

void PageLayout::getWordsInLine(PageLayout *this, const TextLine *a2, unint64_t *a3)
{
  int64_t v5;
  unint64_t v6;
  uint64_t v7;
  int64_t v8;
  int64_t length;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  double rotation;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int64_t v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  int64_t v24;
  __int16 v26;
  int v27;
  void *v28;
  void *v29;
  uint64_t v30;
  id v31;
  id v32;
  uint64_t *v33;
  _BYTE *v34;
  _BYTE *v35;
  int64_t v36;
  char *v37;
  _QWORD v38[4];
  id v39;
  id v40;
  uint64_t *v41;
  char *v42[3];
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  __n128 (*v46)(__n128 *, __n128 *);
  void (*v47)(uint64_t);
  const char *v48;
  void *__p;
  void *v50;
  uint64_t v51;

  v43 = 0;
  v44 = &v43;
  v45 = 0x4812000000;
  v46 = __Block_byref_object_copy__10621;
  v47 = __Block_byref_object_dispose__10622;
  v48 = "";
  __p = 0;
  v50 = 0;
  v51 = 0;
  v6 = *a3;
  v5 = a3[1];
  v7 = a3[2];
  memset(v42, 0, sizeof(v42));
  if (v5 < 1)
  {
LABEL_9:
    v13 = 0;
    v14 = *(_QWORD *)&a2->rotation + 2 * v7;
  }
  else
  {
    v8 = v5 + v6;
    length = a2[1].textRange.length;
    v10 = a2[1].uniCharStart - length;
    if (v6 <= v10 >> 3)
      v11 = v10 >> 3;
    else
      v11 = v6;
    v12 = v6;
    while (1)
    {
      if (v11 == v12)
        std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
      if (*(_QWORD *)(length + 8 * v12) != 1)
        break;
      if ((uint64_t)++v12 >= v8)
        goto LABEL_9;
    }
    std::vector<unsigned short>::resize(v42, v5);
    v13 = v42[0];
    rotation = a2->rotation;
    v16 = a2->identifier - *(_QWORD *)&rotation;
    if (v7 < v16 >> 1)
    {
      v17 = 0;
      v18 = v16 >> 1;
      v19 = a2[1].textRange.length;
      v20 = (int64_t)(a2[1].uniCharStart - v19) >> 3;
      v21 = v20 >= v6;
      v22 = v20 - v6;
      if (!v21)
        v22 = 0;
      while (1)
      {
        if (v22 == v17)
          std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
        v23 = *(_QWORD *)(v19 + 8 * v6 + 8 * v17);
        v24 = v6 + 1 + v17;
        if (v23 != 2 || v24 >= v8)
        {
          if (v18 <= v7)
            goto LABEL_40;
          v26 = *(_WORD *)(*(_QWORD *)&rotation + 2 * v7);
          goto LABEL_20;
        }
        if (v18 <= v7)
          goto LABEL_40;
        if (*(_WORD *)(*(_QWORD *)&rotation + 2 * v7) != 102)
          goto LABEL_27;
        if (v18 <= v7 + 1)
LABEL_40:
          std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
        v27 = *(unsigned __int16 *)(*(_QWORD *)&rotation + 2 * (v7 + 1));
        if (v27 == 105)
          break;
        if (v27 == 108)
        {
          v26 = -1278;
LABEL_20:
          *(_WORD *)&v13[2 * v17] = v26;
        }
LABEL_27:
        if (v24 < v8)
        {
          v7 += v23;
          ++v17;
          if (v7 < (uint64_t)v18)
            continue;
        }
        goto LABEL_31;
      }
      v26 = -1279;
      goto LABEL_20;
    }
LABEL_31:
    v14 = (uint64_t)v13;
  }
  v28 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithCharacters:length:", v14, v5);
  objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceCharacterSet");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = objc_msgSend(v28, "length");
  v38[0] = MEMORY[0x1E0C809B0];
  v38[1] = 3221225472;
  v38[2] = ___ZNK10PageLayout14getWordsInLineERKNS_8TextLineE_block_invoke;
  v38[3] = &unk_1E165AAA8;
  v31 = v28;
  v39 = v31;
  v32 = v29;
  v40 = v32;
  v41 = &v43;
  objc_msgSend(v31, "enumerateSubstringsInRange:options:usingBlock:", 0, v30, 515, v38);

  if (v13)
    operator delete(v13);
  v33 = v44;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  v35 = (_BYTE *)v33[6];
  v34 = (_BYTE *)v33[7];
  v36 = v34 - v35;
  if (v34 != v35)
  {
    std::vector<CFRange>::__vallocate[abi:se180100](this, v36 >> 4);
    v37 = (char *)*((_QWORD *)this + 1);
    memmove(v37, v35, v36);
    *((_QWORD *)this + 1) = &v37[16 * (v36 >> 4)];
  }
  _Block_object_dispose(&v43, 8);
  if (__p)
  {
    v50 = __p;
    operator delete(__p);
  }
}

void sub_184C8DD2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (a17)
    operator delete(a17);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x184C8DC98);
  }
  _Block_object_dispose(&a20, 8);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_184C8DDF0()
{
  JUMPOUT(0x184C8DD50);
}

__n128 __Block_byref_object_copy__10621(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__10622(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZNK10PageLayout14getWordsInLineERKNS_8TextLineE_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;
  char *v28;
  char *v29;
  id v30;

  v30 = a2;
  v9 = objc_msgSend(*(id *)(a1 + 32), "rangeOfCharacterFromSet:options:range:", *(_QWORD *)(a1 + 40), 4, a5, a6);
  v11 = v10;
  if (v10)
  {
    v12 = v9;
    objc_msgSend(MEMORY[0x1E0CB3788], "indexSetWithIndexesInRange:", a5, a6);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "removeIndexesInRange:", v12, v11);
    if (objc_msgSend(v13, "rangeCount"))
    {
      a5 = objc_msgSend(v13, "rangeAtIndex:", 0);
      a6 = v14;
    }

  }
  if (!a6)
    goto LABEL_23;
  v15 = *(_QWORD **)(*(_QWORD *)(a1 + 48) + 8);
  v16 = (uint64_t *)v15[7];
  v17 = v15[8];
  if ((unint64_t)v16 >= v17)
  {
    v19 = v15[6];
    v20 = ((uint64_t)v16 - v19) >> 4;
    v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 60)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v22 = v17 - v19;
    if (v22 >> 3 > v21)
      v21 = v22 >> 3;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
      v23 = 0xFFFFFFFFFFFFFFFLL;
    else
      v23 = v21;
    if (v23)
    {
      v24 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGPoint>>(v23);
      if (v24)
      {
        v26 = &v24[16 * v25];
        v27 = (uint64_t *)&v24[16 * v20];
        *v27 = a5;
        v27[1] = a6;
        v18 = v27 + 2;
        v29 = (char *)v15[6];
        v28 = (char *)v15[7];
        if (v28 != v29)
        {
          do
          {
            *((_OWORD *)v27 - 1) = *((_OWORD *)v28 - 1);
            v27 -= 2;
            v28 -= 16;
          }
          while (v28 != v29);
          v28 = (char *)v15[6];
        }
        v15[6] = v27;
        v15[7] = v18;
        v15[8] = v26;
        if (v28)
          operator delete(v28);
        goto LABEL_22;
      }
    }
  }
  else if (v16)
  {
    *v16 = a5;
    v16[1] = a6;
    v18 = v16 + 2;
LABEL_22:
    v15[7] = v18;
LABEL_23:

    return;
  }
  __break(1u);
}

void sub_184C8DFAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

char *std::vector<CFRange>::__vallocate[abi:se180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  result = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGPoint>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

_QWORD *std::string::basic_string[abi:se180100](_BYTE *a1, _BYTE *__src, size_t __len)
{
  _QWORD *v5;
  size_t v6;
  size_t v7;
  _BYTE *v8;

  v5 = a1;
  if (!__src && __len)
    goto LABEL_16;
  if (__len >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_17;
  if (__len > 0x16)
  {
    v6 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v6 = __len | 7;
    v7 = v6 + 1;
    a1 = operator new(v6 + 1);
    v5[1] = __len;
    v5[2] = v7 | 0x8000000000000000;
    *v5 = a1;
  }
  else
  {
    a1[23] = __len;
  }
  v8 = &a1[__len];
  if (a1 <= __src && v8 > __src)
  {
LABEL_16:
    __break(1u);
LABEL_17:
    std::string::__throw_length_error[abi:se180100]();
  }
  if (__len)
    memmove(a1, __src, __len);
  *v8 = 0;
  return v5;
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  int64_t v3;
  char *v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int *v7;
  std::vector<unsigned int>::pointer begin;
  unsigned int *end;
  unsigned int *v10;
  unsigned int v11;

  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v3 = (char *)this->__end_ - (char *)this->__begin_;
    v4 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<float>>(__n);
    v5 = (unsigned int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    v7 = (unsigned int *)&v4[4 * v6];
    begin = this->__begin_;
    end = this->__end_;
    v10 = v5;
    if (end != this->__begin_)
    {
      v10 = v5;
      do
      {
        v11 = *--end;
        *--v10 = v11;
      }
      while (end != begin);
    }
    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin)
      operator delete(begin);
  }
}

_QWORD *std::vector<std::unique_ptr<PBPageLayoutPkg::PBRect>>::reserve(_QWORD *result, unint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[5];

  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v2 = result;
    v3 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 8 * v4;
    std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(v2, v5);
    return (_QWORD *)std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

unint64_t PB::PtrVector<PBPageLayoutPkg::PBRect>::emplace_back<PBPageLayoutPkg::PBRect>(_QWORD *a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  _QWORD v14[5];

  result = operator new();
  v5 = result;
  *(_QWORD *)result = &off_1E1628E78;
  *(_DWORD *)(result + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = 0;
  *(_OWORD *)(result + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(result + 8) = *(_OWORD *)(a2 + 8);
  v6 = a1[2];
  v7 = (unint64_t *)a1[1];
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((uint64_t)v7 - *a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v10 = v6 - *a1;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      result = 0x1FFFFFFFFFFFFFFFLL;
    else
      result = v11;
    v14[4] = a1 + 2;
    if (result)
    {
      result = (unint64_t)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(result);
      v12 = (unint64_t *)(result + 8 * v9);
      v14[0] = result;
      v14[1] = v12;
      v14[3] = result + 8 * v13;
      if (result)
      {
        *v12 = v5;
        v14[2] = v12 + 1;
        std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(a1, v14);
        v8 = (_QWORD *)a1[1];
        result = std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v14);
        goto LABEL_13;
      }
    }
  }
  else if (v7)
  {
    *v7 = result;
    v8 = v7 + 1;
LABEL_13:
    a1[1] = v8;
    return result;
  }
  __break(1u);
  return result;
}

void sub_184C8E2F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void ***std::unique_ptr<PB::Data>::reset[abi:se180100](void ***result, void **a2)
{
  void **v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    free(*v2);
    JUMPOUT(0x186DC23C4);
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:se180100]<unsigned long const*,unsigned long const*,std::back_insert_iterator<std::vector<unsigned long long>>>(uint64_t *a1, uint64_t *a2, void **a3)
{
  uint64_t *v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *i;
  uint64_t v18;

  if (a1 != a2)
  {
    v5 = a1;
    v6 = (char *)a3[1];
    do
    {
      v7 = *v5;
      v8 = (unint64_t)a3[2];
      if ((unint64_t)v6 >= v8)
      {
        v9 = (v6 - (_BYTE *)*a3) >> 3;
        if ((unint64_t)(v9 + 1) >> 61)
          goto LABEL_22;
        v10 = v8 - (_QWORD)*a3;
        v11 = v10 >> 2;
        if (v10 >> 2 <= (unint64_t)(v9 + 1))
          v11 = v9 + 1;
        if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
          v12 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v12 = v11;
        if (!v12
          || (v13 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v12)) == 0)
        {
LABEL_21:
          __break(1u);
LABEL_22:
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        }
        v15 = &v13[8 * v9];
        *(_QWORD *)v15 = v7;
        v6 = v15 + 8;
        v16 = (char *)*a3;
        for (i = (char *)a3[1]; i != v16; i -= 8)
        {
          v18 = *((_QWORD *)i - 1);
          *((_QWORD *)v15 - 1) = v18;
          v15 -= 8;
        }
        *a3 = v15;
        a3[1] = v6;
        a3[2] = &v13[8 * v14];
        if (v16)
          operator delete(v16);
      }
      else
      {
        if (!v6)
          goto LABEL_21;
        *(_QWORD *)v6 = v7;
        v6 += 8;
      }
      a3[1] = v6;
      ++v5;
    }
    while (v5 != a2);
  }
}

_QWORD *std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *--v2;
    *v2 = 0;
    *(_QWORD *)(v4 - 8) = v5;
    v4 -= 8;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::default_delete<std::string>::operator()[abi:se180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  JUMPOUT(0x186DC23C4);
}

void *std::__allocate_at_least[abi:se180100]<std::allocator<float>>(unint64_t a1)
{
  if (a1 >> 62)
    std::__throw_bad_array_new_length[abi:se180100]();
  return operator new(4 * a1);
}

void ***std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:se180100](void ***a1, _DWORD *a2)
{
  void **v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *i;
  int v18;

  v4 = *a1;
  v6 = (*a1)[1];
  v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 < v5)
  {
    if (v6)
    {
      *v6 = *a2;
      v7 = v6 + 1;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v8 = ((char *)v6 - (_BYTE *)*v4) >> 2;
  if ((unint64_t)(v8 + 1) >> 62)
    goto LABEL_19;
  v9 = v5 - (_QWORD)*v4;
  v10 = v9 >> 1;
  if (v9 >> 1 <= (unint64_t)(v8 + 1))
    v10 = v8 + 1;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL)
    v11 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v11 = v10;
  if (!v11 || (v12 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<float>>(v11)) == 0)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v14 = &v12[4 * v13];
  v15 = &v12[4 * v8];
  *(_DWORD *)v15 = *a2;
  v7 = v15 + 4;
  v16 = (char *)*v4;
  for (i = (char *)v4[1]; i != v16; i -= 4)
  {
    v18 = *((_DWORD *)i - 1);
    *((_DWORD *)v15 - 1) = v18;
    v15 -= 4;
  }
  *v4 = v15;
  v4[1] = v7;
  v4[2] = v14;
  if (v16)
    operator delete(v16);
LABEL_17:
  v4[1] = v7;
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_184C8E85C(_Unwind_Exception *a1)
{
  id *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,void *>>>::operator()[abi:se180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t cmyk64_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unsigned int *v39;
  unsigned int *v40;
  unint64_t v41;
  unint64_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  unsigned int v45;
  int v46;
  int v47;
  int64_t v48;
  unsigned int *v49;
  unint64_t v50;
  unint64_t v51;
  unsigned int *v52;
  unint64_t v53;
  unsigned int *v54;
  unint64_t v55;
  unsigned __int8 *v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  uint64_t v61;
  char v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  unint64_t v66;
  char v67;
  unint64_t v68;
  unint64_t v69;
  unsigned int *v70;
  unint64_t v71;
  unsigned __int8 *v72;
  uint64_t v73;
  char v74;
  unint64_t v75;
  unsigned int *v76;
  uint64_t v77;
  unsigned __int8 *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  _WORD *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unsigned int *v86;
  unsigned __int8 *v87;
  unint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_QWORD *)(result + 176);
  v91 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v8 = *(_QWORD *)(result + 120);
  v10 = *(_QWORD *)(result + 152) - 16;
  v93 = *(_QWORD *)(result + 88);
  v94 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v11 = 0;
  else
    v11 = 0xFF00000000;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v95 = *(_DWORD *)(result + 28);
  v89 = *(_DWORD *)(result + 188);
  v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v95));
  v15 = v4 + (v12 * v6) + 4 * v13 - 8;
  v92 = *(_QWORD *)(result + 72);
  v90 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v92)
    {
      if (a3 <= v93)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v90;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v93;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_43;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v90;
        v25 = v89 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v92 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_43;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v90;
      v25 = v89 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v89;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v9;
    a3 += v8;
    v10 += 16;
    *(_BYTE *)++v94 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v91)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_29;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v91;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_43;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v89;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_43;
  v36 = v26 >> 32;
  v37 = v31 >> 32;
  v38 = v4 + (int)v36 * (uint64_t)v6 + 4 * v37;
  v39 = *(unsigned int **)(result + 32);
  if (v15 >= v38)
    v40 = (unsigned int *)(v4 + (int)v36 * (uint64_t)v6 + 4 * v37);
  else
    v40 = (unsigned int *)v15;
  if (v40 < v39)
    v40 = *(unsigned int **)(result + 32);
  v41 = bswap32(*v40);
  if (v5)
  {
    v42 = v5 + (int)v36 * (uint64_t)v95 + v37;
    v43 = *(unsigned __int8 **)(result + 40);
    if ((unint64_t)v14 >= v42)
      v44 = (unsigned __int8 *)v42;
    else
      v44 = v14;
    if (v44 >= v43)
      v43 = v44;
    v41 |= (unint64_t)*v43 << 32;
    if (!v7)
      goto LABEL_104;
  }
  else
  {
    v42 = 0;
    if (!v7)
      goto LABEL_104;
  }
  v45 = *(_DWORD *)(v7 + (v32 | v24));
LABEL_48:
  v46 = v45 & 0xF;
  v47 = HIBYTE(v45) & 3;
  if (v46 == 1)
  {
    v70 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
    if (v15 < (unint64_t)v70)
      v70 = (unsigned int *)v15;
    if (v70 < v39)
      v70 = v39;
    v71 = bswap32(*v70);
    if (v5)
    {
      v72 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
      if (v14 < v72)
        v72 = v14;
      if ((unint64_t)v72 < *(_QWORD *)(result + 40))
        v72 = *(unsigned __int8 **)(result + 40);
      v71 |= (unint64_t)*v72 << 32;
    }
    v73 = interpolate_cif10a[v47];
    v74 = v47 + 1;
    v68 = v41 - ((v73 & v41) >> v74);
    v75 = (v73 & v71) >> v74;
  }
  else
  {
    if (v46 == 2)
    {
      v76 = (unsigned int *)(v38 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 54));
      if (v15 < (unint64_t)v76)
        v76 = (unsigned int *)v15;
      if (v76 < v39)
        v76 = v39;
      v77 = bswap32(*v76);
      if (v5)
      {
        v78 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v78)
          v78 = v14;
        if ((unint64_t)v78 < *(_QWORD *)(result + 40))
          v78 = *(unsigned __int8 **)(result + 40);
        v77 |= (unint64_t)*v78 << 32;
      }
      v79 = (v45 >> 28) & 3;
      v80 = interpolate_cif10a[v79];
      v67 = v79 + 1;
      v68 = v41 - ((v80 & v41) >> v67);
      v69 = v80 & v77;
    }
    else
    {
      if (v46 != 3)
        goto LABEL_104;
      v48 = (unint64_t)HIWORD(v45) << 56;
      v49 = (unsigned int *)(v38 + (v48 >> 54));
      if (v15 < (unint64_t)v49)
        v49 = (unsigned int *)v15;
      if (v49 < v39)
        v49 = v39;
      v50 = bswap32(*v49);
      v51 = v38 + SBYTE1(v45) * (uint64_t)v6;
      if (v15 >= v51)
        v52 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      else
        v52 = (unsigned int *)v15;
      if (v52 < v39)
        v52 = v39;
      v53 = bswap32(*v52);
      v54 = (unsigned int *)(v51 + (v48 >> 54));
      if (v15 < (unint64_t)v54)
        v54 = (unsigned int *)v15;
      if (v54 < v39)
        v54 = v39;
      v55 = bswap32(*v54);
      if (v5)
      {
        v56 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        v57 = *(_QWORD *)(result + 40);
        if (v14 < v56)
          v56 = v14;
        if ((unint64_t)v56 < v57)
          v56 = *(unsigned __int8 **)(result + 40);
        v50 |= (unint64_t)*v56 << 32;
        v58 = v42 + SBYTE1(v45) * (uint64_t)v95;
        if ((unint64_t)v14 >= v58)
          v59 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
        else
          v59 = v14;
        if ((unint64_t)v59 < v57)
          v59 = *(unsigned __int8 **)(result + 40);
        v53 |= (unint64_t)*v59 << 32;
        v60 = (unsigned __int8 *)(v58 + SBYTE2(v45));
        if (v14 < v60)
          v60 = v14;
        if ((unint64_t)v60 < v57)
          v60 = *(unsigned __int8 **)(result + 40);
        v55 |= (unint64_t)*v60 << 32;
      }
      v61 = interpolate_cif10a[v47];
      v62 = v47 + 1;
      v63 = v41 - ((v61 & v41) >> v62) + ((v61 & v53) >> v62);
      v64 = v50 - ((v61 & v50) >> v62) + ((v61 & v55) >> v62);
      v65 = (v45 >> 28) & 3;
      v66 = interpolate_cif10a[v65];
      v67 = v65 + 1;
      v68 = v63 - ((v63 & v66) >> v67);
      v69 = v64 & v66;
    }
    v75 = v69 >> v67;
  }
  v41 = v68 + v75;
LABEL_104:
  v81 = 0;
  v82 = (_WORD *)(v10 + 24);
  a3 += v8;
  v83 = v93 - a3;
  a2 += v9;
  v84 = v91 - a2;
  while (1)
  {
    HIDWORD(v85) = BYTE3(v41);
    LODWORD(v85) = v41;
    *((_QWORD *)v82 - 1) = ((unint64_t)(v41 | ((_DWORD)v41 << 8)) << 48) | ((unint64_t)(BYTE1(v41) | (BYTE1(v41) << 8)) << 32) | v41 & 0xFF0000 | ((unint64_t)BYTE2(v41) << 24) | (v85 >> 24);
    *v82 = ((v41 | v11) >> 32) | (unsigned __int16)((unsigned __int16)((v41 | v11) >> 32) << 8);
    *(_BYTE *)(v94 + 1 + v81) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v81)
      return result;
    if ((v83 | v84 | (a3 - v92) | (a2 - v90)) < 0)
    {
      v10 = (uint64_t)(v82 - 4);
      v94 += v81 + 1;
      a4 += ~(_DWORD)v81;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
    v39 = *(unsigned int **)(result + 32);
    if (v15 >= v38)
      v86 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
    else
      v86 = (unsigned int *)v15;
    if (v86 < v39)
      v86 = *(unsigned int **)(result + 32);
    v41 = bswap32(*v86);
    if (v5)
    {
      v42 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      v87 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42)
        v88 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      else
        v88 = (unint64_t)v14;
      if (v88 >= (unint64_t)v87)
        v87 = (unsigned __int8 *)v88;
      v41 |= (unint64_t)*v87 << 32;
    }
    if (v7)
    {
      v45 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        v10 = (uint64_t)(v82 - 4);
        v94 += v81 + 1;
        a4 += ~(_DWORD)v81;
        v25 = -1;
        goto LABEL_48;
      }
    }
    v82 += 8;
    ++v81;
    a3 += v8;
    v83 -= v8;
    a2 += v9;
    v84 -= v9;
    v25 = -1;
  }
}

uint64_t cmyk64_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unsigned int *v39;
  unsigned int *v40;
  unint64_t v41;
  unint64_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  unsigned int v45;
  int v46;
  int v47;
  int64_t v48;
  unsigned int *v49;
  unint64_t v50;
  unint64_t v51;
  unsigned int *v52;
  unint64_t v53;
  unsigned int *v54;
  unint64_t v55;
  unsigned __int8 *v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  uint64_t v61;
  char v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  unint64_t v66;
  char v67;
  unint64_t v68;
  unint64_t v69;
  unsigned int *v70;
  unint64_t v71;
  unsigned __int8 *v72;
  uint64_t v73;
  char v74;
  unint64_t v75;
  unsigned int *v76;
  uint64_t v77;
  unsigned __int8 *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  _WORD *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unsigned int *v86;
  unsigned __int8 *v87;
  unint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_QWORD *)(result + 176);
  v91 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v8 = *(_QWORD *)(result + 120);
  v10 = *(_QWORD *)(result + 152) - 16;
  v93 = *(_QWORD *)(result + 88);
  v94 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v11 = 0;
  else
    v11 = 0xFF00000000;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v95 = *(_DWORD *)(result + 28);
  v89 = *(_DWORD *)(result + 188);
  v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v95));
  v15 = v4 + (v12 * v6) + 4 * v13 - 8;
  v92 = *(_QWORD *)(result + 72);
  v90 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v92)
    {
      if (a3 <= v93)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v90;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v93;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_43;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v90;
        v25 = v89 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v92 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_43;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v90;
      v25 = v89 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v89;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v9;
    a3 += v8;
    v10 += 16;
    *(_BYTE *)++v94 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v91)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_29;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v91;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_43;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v89;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_43;
  v36 = v26 >> 32;
  v37 = v31 >> 32;
  v38 = v4 + (int)v36 * (uint64_t)v6 + 4 * v37;
  v39 = *(unsigned int **)(result + 32);
  if (v15 >= v38)
    v40 = (unsigned int *)(v4 + (int)v36 * (uint64_t)v6 + 4 * v37);
  else
    v40 = (unsigned int *)v15;
  if (v40 < v39)
    v40 = *(unsigned int **)(result + 32);
  v41 = *v40;
  if (v5)
  {
    v42 = v5 + (int)v36 * (uint64_t)v95 + v37;
    v43 = *(unsigned __int8 **)(result + 40);
    if ((unint64_t)v14 >= v42)
      v44 = (unsigned __int8 *)v42;
    else
      v44 = v14;
    if (v44 >= v43)
      v43 = v44;
    v41 |= (unint64_t)*v43 << 32;
    if (!v7)
      goto LABEL_104;
  }
  else
  {
    v42 = 0;
    if (!v7)
      goto LABEL_104;
  }
  v45 = *(_DWORD *)(v7 + (v32 | v24));
LABEL_48:
  v46 = v45 & 0xF;
  v47 = HIBYTE(v45) & 3;
  if (v46 == 1)
  {
    v70 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
    if (v15 < (unint64_t)v70)
      v70 = (unsigned int *)v15;
    if (v70 < v39)
      v70 = v39;
    v71 = *v70;
    if (v5)
    {
      v72 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
      if (v14 < v72)
        v72 = v14;
      if ((unint64_t)v72 < *(_QWORD *)(result + 40))
        v72 = *(unsigned __int8 **)(result + 40);
      v71 |= (unint64_t)*v72 << 32;
    }
    v73 = interpolate_cif10a[v47];
    v74 = v47 + 1;
    v68 = v41 - ((v73 & v41) >> v74);
    v75 = (v73 & v71) >> v74;
  }
  else
  {
    if (v46 == 2)
    {
      v76 = (unsigned int *)(v38 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 54));
      if (v15 < (unint64_t)v76)
        v76 = (unsigned int *)v15;
      if (v76 < v39)
        v76 = v39;
      v77 = *v76;
      if (v5)
      {
        v78 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v78)
          v78 = v14;
        if ((unint64_t)v78 < *(_QWORD *)(result + 40))
          v78 = *(unsigned __int8 **)(result + 40);
        v77 |= (unint64_t)*v78 << 32;
      }
      v79 = (v45 >> 28) & 3;
      v80 = interpolate_cif10a[v79];
      v67 = v79 + 1;
      v68 = v41 - ((v80 & v41) >> v67);
      v69 = v80 & v77;
    }
    else
    {
      if (v46 != 3)
        goto LABEL_104;
      v48 = (unint64_t)HIWORD(v45) << 56;
      v49 = (unsigned int *)(v38 + (v48 >> 54));
      if (v15 < (unint64_t)v49)
        v49 = (unsigned int *)v15;
      if (v49 < v39)
        v49 = v39;
      v50 = *v49;
      v51 = v38 + SBYTE1(v45) * (uint64_t)v6;
      if (v15 >= v51)
        v52 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      else
        v52 = (unsigned int *)v15;
      if (v52 < v39)
        v52 = v39;
      v53 = *v52;
      v54 = (unsigned int *)(v51 + (v48 >> 54));
      if (v15 < (unint64_t)v54)
        v54 = (unsigned int *)v15;
      if (v54 < v39)
        v54 = v39;
      v55 = *v54;
      if (v5)
      {
        v56 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        v57 = *(_QWORD *)(result + 40);
        if (v14 < v56)
          v56 = v14;
        if ((unint64_t)v56 < v57)
          v56 = *(unsigned __int8 **)(result + 40);
        v50 |= (unint64_t)*v56 << 32;
        v58 = v42 + SBYTE1(v45) * (uint64_t)v95;
        if ((unint64_t)v14 >= v58)
          v59 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
        else
          v59 = v14;
        if ((unint64_t)v59 < v57)
          v59 = *(unsigned __int8 **)(result + 40);
        v53 |= (unint64_t)*v59 << 32;
        v60 = (unsigned __int8 *)(v58 + SBYTE2(v45));
        if (v14 < v60)
          v60 = v14;
        if ((unint64_t)v60 < v57)
          v60 = *(unsigned __int8 **)(result + 40);
        v55 |= (unint64_t)*v60 << 32;
      }
      v61 = interpolate_cif10a[v47];
      v62 = v47 + 1;
      v63 = v41 - ((v61 & v41) >> v62) + ((v61 & v53) >> v62);
      v64 = v50 - ((v61 & v50) >> v62) + ((v61 & v55) >> v62);
      v65 = (v45 >> 28) & 3;
      v66 = interpolate_cif10a[v65];
      v67 = v65 + 1;
      v68 = v63 - ((v63 & v66) >> v67);
      v69 = v64 & v66;
    }
    v75 = v69 >> v67;
  }
  v41 = v68 + v75;
LABEL_104:
  v81 = 0;
  v82 = (_WORD *)(v10 + 24);
  a3 += v8;
  v83 = v93 - a3;
  a2 += v9;
  v84 = v91 - a2;
  while (1)
  {
    HIDWORD(v85) = BYTE3(v41);
    LODWORD(v85) = v41;
    *((_QWORD *)v82 - 1) = ((unint64_t)(v41 | ((_DWORD)v41 << 8)) << 48) | ((unint64_t)(BYTE1(v41) | (BYTE1(v41) << 8)) << 32) | v41 & 0xFF0000 | ((unint64_t)BYTE2(v41) << 24) | (v85 >> 24);
    *v82 = ((v41 | v11) >> 32) | (unsigned __int16)((unsigned __int16)((v41 | v11) >> 32) << 8);
    *(_BYTE *)(v94 + 1 + v81) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v81)
      return result;
    if ((v83 | v84 | (a3 - v92) | (a2 - v90)) < 0)
    {
      v10 = (uint64_t)(v82 - 4);
      v94 += v81 + 1;
      a4 += ~(_DWORD)v81;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
    v39 = *(unsigned int **)(result + 32);
    if (v15 >= v38)
      v86 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
    else
      v86 = (unsigned int *)v15;
    if (v86 < v39)
      v86 = *(unsigned int **)(result + 32);
    v41 = *v86;
    if (v5)
    {
      v42 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      v87 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42)
        v88 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      else
        v88 = (unint64_t)v14;
      if (v88 >= (unint64_t)v87)
        v87 = (unsigned __int8 *)v88;
      v41 |= (unint64_t)*v87 << 32;
    }
    if (v7)
    {
      v45 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        v10 = (uint64_t)(v82 - 4);
        v94 += v81 + 1;
        a4 += ~(_DWORD)v81;
        v25 = -1;
        goto LABEL_48;
      }
    }
    v82 += 8;
    ++v81;
    a3 += v8;
    v83 -= v8;
    a2 += v9;
    v84 -= v9;
    v25 = -1;
  }
}

uint64_t cmyk64_sample_W16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  unsigned int v44;
  unint64_t v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  unsigned int v48;
  int v49;
  int v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unsigned __int16 *v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  unsigned int v56;
  uint64_t v57;
  unsigned __int16 *v58;
  unint64_t v59;
  unint64_t v60;
  unsigned __int16 *v61;
  unsigned __int16 *v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  int v67;
  char v68;
  unsigned int v69;
  unsigned int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  unsigned __int16 *v73;
  int v74;
  char v75;
  unsigned int v76;
  unsigned __int16 *v77;
  unsigned int v78;
  unsigned __int16 *v79;
  int v80;
  int v81;
  unsigned int v82;
  uint64_t v83;
  _WORD *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unsigned __int16 *v88;
  unsigned __int16 *v89;
  unsigned __int16 *v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v95 = *(_QWORD *)(result + 80);
  v97 = *(_QWORD *)(result + 88);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 16;
  v12 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v13 = 0;
  else
    v13 = -65536;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = v5 + (v14 * v7) + 2 * (v15 - 1);
  v94 = *(_DWORD *)(result + 188);
  v17 = v4 + (v14 * v6) + 2 * v15 - 2;
  v96 = *(_QWORD *)(result + 64);
  v98 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v98)
      {
        if (a3 <= v97)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
          v29 = v96;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v97;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_43;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v29 = v96;
          v27 = v94 | v25;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v98 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_43;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v29 = v96;
        v27 = v94 | v21;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v29)
        break;
      v30 = *(_QWORD *)(result + 192);
      v31 = v29 - *(_QWORD *)(result + 200);
      v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v94;
        v33 = v31 + 0x1000000;
        v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 16;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v95)
    {
      v34 = ((unint64_t)a2 >> 26) & 0x3C;
      v33 = a2;
      goto LABEL_29;
    }
    v35 = *(_QWORD *)(result + 192);
    v36 = *(_QWORD *)(result + 200) + v95;
    v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1)
      goto LABEL_43;
    if (v37 < v35)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v37) >> 32) >> 15)) | v94;
    v33 = v36 - 0x1000000;
    v34 = 28;
LABEL_29:
    if (v27 < 0x400000)
      goto LABEL_43;
    v38 = v28 >> 32;
    v39 = v4 + (int)v38 * (uint64_t)v6;
    v40 = (v33 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    v41 = v39 + v40;
    v42 = *(unsigned __int16 **)(result + 32);
    if (v17 >= v39 + v40)
      v43 = (unsigned __int16 *)(v39 + v40);
    else
      v43 = (unsigned __int16 *)v17;
    if (v43 < v42)
      v43 = *(unsigned __int16 **)(result + 32);
    v44 = bswap32(*v43) >> 16;
    if (v5)
    {
      v45 = v5 + (int)v38 * (uint64_t)v7 + v40;
      v46 = *(unsigned __int16 **)(result + 40);
      if (v16 >= v45)
        v47 = (unsigned __int16 *)v45;
      else
        v47 = (unsigned __int16 *)v16;
      if (v47 >= v46)
        v46 = v47;
      v44 |= bswap32(*v46) & 0xFFFF0000;
      if (!v8)
        goto LABEL_104;
    }
    else
    {
      v45 = 0;
      if (!v8)
        goto LABEL_104;
    }
    v48 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    v49 = v48 & 0xF;
    v50 = HIBYTE(v48) & 3;
    switch(v49)
    {
      case 1:
        v71 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 < (unint64_t)v71)
          v71 = (unsigned __int16 *)v17;
        if (v71 < v42)
          v71 = v42;
        v72 = bswap32(*v71) >> 16;
        if (v5)
        {
          v73 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          if (v16 < (unint64_t)v73)
            v73 = (unsigned __int16 *)v16;
          if ((unint64_t)v73 < *(_QWORD *)(result + 40))
            v73 = *(unsigned __int16 **)(result + 40);
          v72 |= bswap32(*v73) & 0xFFFF0000;
        }
        v74 = interpolate_1616[v50];
        v75 = v50 + 1;
        v69 = v44 - ((v74 & v44) >> v75);
        v76 = (v74 & v72) >> v75;
        goto LABEL_103;
      case 2:
        v77 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v77)
          v77 = (unsigned __int16 *)v17;
        if (v77 < v42)
          v77 = v42;
        v78 = bswap32(*v77) >> 16;
        if (v5)
        {
          v79 = (unsigned __int16 *)(v45 + 2 * SBYTE2(v48));
          if (v16 < (unint64_t)v79)
            v79 = (unsigned __int16 *)v16;
          if ((unint64_t)v79 < *(_QWORD *)(result + 40))
            v79 = *(unsigned __int16 **)(result + 40);
          v78 |= bswap32(*v79) & 0xFFFF0000;
        }
        v80 = (v48 >> 28) & 3;
        v81 = interpolate_1616[v80];
        v68 = v80 + 1;
        v69 = v44 - ((v81 & v44) >> v68);
        v70 = v81 & v78;
        goto LABEL_102;
      case 3:
        v92 = HIBYTE(v48) & 3;
        v51 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v51)
          v51 = (unsigned __int16 *)v17;
        if (v51 < v42)
          v51 = v42;
        v52 = bswap32(*v51) >> 16;
        v53 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 >= (unint64_t)v53)
          v54 = v53;
        else
          v54 = (unsigned __int16 *)v17;
        if (v54 < v42)
          v54 = v42;
        v93 = bswap32(*v54) >> 16;
        v55 = &v53[SBYTE2(v48)];
        if (v17 < (unint64_t)v55)
          v55 = (unsigned __int16 *)v17;
        if (v55 < v42)
          v55 = v42;
        v56 = bswap32(*v55) >> 16;
        if (v5)
        {
          v57 = 2 * SBYTE2(v48);
          v58 = (unsigned __int16 *)(v45 + v57);
          v59 = *(_QWORD *)(result + 40);
          if (v16 < v45 + v57)
            v58 = (unsigned __int16 *)v16;
          if ((unint64_t)v58 < v59)
            v58 = *(unsigned __int16 **)(result + 40);
          v52 |= bswap32(*v58) & 0xFFFF0000;
          v60 = v45 + SBYTE1(v48) * (uint64_t)v7;
          if (v16 >= v60)
            v61 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          else
            v61 = (unsigned __int16 *)v16;
          if ((unint64_t)v61 < v59)
            v61 = *(unsigned __int16 **)(result + 40);
          v93 |= bswap32(*v61) & 0xFFFF0000;
          v62 = (unsigned __int16 *)(v60 + v57);
          if (v16 < (unint64_t)v62)
            v62 = (unsigned __int16 *)v16;
          if ((unint64_t)v62 < v59)
            v62 = *(unsigned __int16 **)(result + 40);
          v56 |= bswap32(*v62) & 0xFFFF0000;
        }
        v63 = interpolate_1616[v92];
        v64 = v44 - ((v63 & v44) >> (v92 + 1)) + ((v63 & v93) >> (v92 + 1));
        v65 = v52 - ((v63 & v52) >> (v92 + 1)) + ((v63 & v56) >> (v92 + 1));
        v66 = (v48 >> 28) & 3;
        v67 = interpolate_1616[v66];
        v68 = v66 + 1;
        v69 = v64 - ((v64 & v67) >> v68);
        v70 = v65 & v67;
LABEL_102:
        v76 = v70 >> v68;
LABEL_103:
        v44 = v69 + v76;
        break;
    }
LABEL_104:
    v82 = (v44 | v13) >> 16;
    *(_QWORD *)(v11 + 16) = (unint64_t)(v82 - v44) << 48;
    *(_WORD *)(v11 + 24) = v82;
    *(_BYTE *)(v12 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v83 = 0;
    v84 = (_WORD *)(v11 + 40);
    a2 += v10;
    v85 = v95 - a2;
    a3 += v9;
    v86 = v97 - a3;
    while (((v86 | v85 | (a3 - v98) | (a2 - v96)) & 0x8000000000000000) == 0)
    {
      v87 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      v41 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v87;
      v42 = *(unsigned __int16 **)(result + 32);
      if (v17 >= v41)
        v88 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v87);
      else
        v88 = (unsigned __int16 *)v17;
      if (v88 < v42)
        v88 = *(unsigned __int16 **)(result + 32);
      v44 = bswap32(*v88) >> 16;
      if (v5)
      {
        v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v87;
        v89 = *(unsigned __int16 **)(result + 40);
        if (v16 >= v45)
          v90 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v87);
        else
          v90 = (unsigned __int16 *)v16;
        if (v90 >= v89)
          v89 = v90;
        v44 |= bswap32(*v89) & 0xFFFF0000;
      }
      if (v8)
      {
        v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v48 & 0xF) != 0)
        {
          v12 += v83 + 1;
          v11 = (uint64_t)(v84 - 12);
          a4 += ~(_DWORD)v83;
          v27 = -1;
          goto LABEL_48;
        }
      }
      v91 = (v44 | v13) >> 16;
      *((_QWORD *)v84 - 1) = (unint64_t)(v91 - v44) << 48;
      *v84 = v91;
      v84 += 8;
      *(_BYTE *)(v12 + v83++ + 2) = -1;
      a2 += v10;
      v85 -= v10;
      a3 += v9;
      v86 -= v9;
      if (a4 - 1 == (_DWORD)v83)
        return result;
    }
    v12 += v83 + 1;
    v11 = (uint64_t)(v84 - 12);
    a4 += ~(_DWORD)v83;
  }
  while (a4);
  return result;
}

uint64_t cmyk64_sample_w16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  unsigned int v44;
  unint64_t v45;
  unsigned __int16 *v46;
  unsigned __int16 *v47;
  unsigned int v48;
  int v49;
  int v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unsigned __int16 *v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  unsigned int v56;
  unsigned __int16 *v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int16 *v60;
  unsigned __int16 *v61;
  int v62;
  char v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  int v67;
  char v68;
  unsigned int v69;
  unsigned int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  unsigned __int16 *v73;
  int v74;
  char v75;
  unsigned int v76;
  unsigned __int16 *v77;
  int v78;
  unsigned __int16 *v79;
  int v80;
  int v81;
  unsigned int v82;
  uint64_t v83;
  _WORD *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unsigned __int16 *v88;
  unsigned __int16 *v89;
  unsigned __int16 *v90;
  unsigned int v91;
  uint64_t v92;
  unsigned int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v95 = *(_QWORD *)(result + 80);
  v97 = *(_QWORD *)(result + 88);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 16;
  v12 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v13 = 0;
  else
    v13 = -65536;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = v5 + (v14 * v7) + 2 * (v15 - 1);
  v94 = *(_DWORD *)(result + 188);
  v17 = v4 + (v14 * v6) + 2 * v15 - 2;
  v96 = *(_QWORD *)(result + 64);
  v98 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v98)
      {
        if (a3 <= v97)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
          v29 = v96;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v97;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_43;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v29 = v96;
          v27 = v94 | v25;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v98 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_43;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v29 = v96;
        v27 = v94 | v21;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v29)
        break;
      v30 = *(_QWORD *)(result + 192);
      v31 = v29 - *(_QWORD *)(result + 200);
      v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v94;
        v33 = v31 + 0x1000000;
        v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 16;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v95)
    {
      v34 = ((unint64_t)a2 >> 26) & 0x3C;
      v33 = a2;
      goto LABEL_29;
    }
    v35 = *(_QWORD *)(result + 192);
    v36 = *(_QWORD *)(result + 200) + v95;
    v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1)
      goto LABEL_43;
    if (v37 < v35)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v37) >> 32) >> 15)) | v94;
    v33 = v36 - 0x1000000;
    v34 = 28;
LABEL_29:
    if (v27 < 0x400000)
      goto LABEL_43;
    v38 = v28 >> 32;
    v39 = v4 + (int)v38 * (uint64_t)v6;
    v40 = (v33 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    v41 = v39 + v40;
    v42 = *(unsigned __int16 **)(result + 32);
    if (v17 >= v39 + v40)
      v43 = (unsigned __int16 *)(v39 + v40);
    else
      v43 = (unsigned __int16 *)v17;
    if (v43 < v42)
      v43 = *(unsigned __int16 **)(result + 32);
    v44 = *v43;
    if (v5)
    {
      v45 = v5 + (int)v38 * (uint64_t)v7 + v40;
      v46 = *(unsigned __int16 **)(result + 40);
      if (v16 >= v45)
        v47 = (unsigned __int16 *)v45;
      else
        v47 = (unsigned __int16 *)v16;
      if (v47 >= v46)
        v46 = v47;
      v44 |= *v46 << 16;
      if (!v8)
        goto LABEL_104;
    }
    else
    {
      v45 = 0;
      if (!v8)
        goto LABEL_104;
    }
    v48 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    v49 = v48 & 0xF;
    v50 = HIBYTE(v48) & 3;
    switch(v49)
    {
      case 1:
        v71 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 < (unint64_t)v71)
          v71 = (unsigned __int16 *)v17;
        if (v71 < v42)
          v71 = v42;
        v72 = *v71;
        if (v5)
        {
          v73 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          if (v16 < (unint64_t)v73)
            v73 = (unsigned __int16 *)v16;
          if ((unint64_t)v73 < *(_QWORD *)(result + 40))
            v73 = *(unsigned __int16 **)(result + 40);
          v72 |= *v73 << 16;
        }
        v74 = interpolate_1616[v50];
        v75 = v50 + 1;
        v69 = v44 - ((v74 & v44) >> v75);
        v76 = (v74 & v72) >> v75;
        goto LABEL_103;
      case 2:
        v77 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v77)
          v77 = (unsigned __int16 *)v17;
        if (v77 < v42)
          v77 = v42;
        v78 = *v77;
        if (v5)
        {
          v79 = (unsigned __int16 *)(v45 + 2 * SBYTE2(v48));
          if (v16 < (unint64_t)v79)
            v79 = (unsigned __int16 *)v16;
          if ((unint64_t)v79 < *(_QWORD *)(result + 40))
            v79 = *(unsigned __int16 **)(result + 40);
          v78 |= *v79 << 16;
        }
        v80 = (v48 >> 28) & 3;
        v81 = interpolate_1616[v80];
        v68 = v80 + 1;
        v69 = v44 - ((v81 & v44) >> v68);
        v70 = v81 & v78;
        goto LABEL_102;
      case 3:
        v51 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v51)
          v51 = (unsigned __int16 *)v17;
        if (v51 < v42)
          v51 = v42;
        v52 = *v51;
        v53 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 >= (unint64_t)v53)
          v54 = v53;
        else
          v54 = (unsigned __int16 *)v17;
        if (v54 < v42)
          v54 = v42;
        v93 = *v54;
        v55 = &v53[SBYTE2(v48)];
        if (v17 < (unint64_t)v55)
          v55 = (unsigned __int16 *)v17;
        if (v55 < v42)
          v55 = v42;
        v56 = *v55;
        if (v5)
        {
          v92 = 2 * SBYTE2(v48);
          v57 = (unsigned __int16 *)(v45 + v92);
          v58 = *(_QWORD *)(result + 40);
          if (v16 < v45 + v92)
            v57 = (unsigned __int16 *)v16;
          if ((unint64_t)v57 < v58)
            v57 = *(unsigned __int16 **)(result + 40);
          v52 |= *v57 << 16;
          v59 = v45 + SBYTE1(v48) * (uint64_t)v7;
          if (v16 >= v59)
            v60 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          else
            v60 = (unsigned __int16 *)v16;
          if ((unint64_t)v60 < v58)
            v60 = *(unsigned __int16 **)(result + 40);
          v93 |= *v60 << 16;
          v61 = (unsigned __int16 *)(v59 + v92);
          if (v16 < v59 + v92)
            v61 = (unsigned __int16 *)v16;
          if ((unint64_t)v61 < v58)
            v61 = *(unsigned __int16 **)(result + 40);
          v56 |= *v61 << 16;
        }
        v62 = interpolate_1616[v50];
        v63 = v50 + 1;
        v64 = v44 - ((v62 & v44) >> v63) + ((v62 & v93) >> v63);
        v65 = v52 - ((v62 & v52) >> v63) + ((v62 & v56) >> v63);
        v66 = (v48 >> 28) & 3;
        v67 = interpolate_1616[v66];
        v68 = v66 + 1;
        v69 = v64 - ((v64 & v67) >> v68);
        v70 = v65 & v67;
LABEL_102:
        v76 = v70 >> v68;
LABEL_103:
        v44 = v69 + v76;
        break;
    }
LABEL_104:
    v82 = (v44 | v13) >> 16;
    *(_QWORD *)(v11 + 16) = (unint64_t)(v82 - v44) << 48;
    *(_WORD *)(v11 + 24) = v82;
    *(_BYTE *)(v12 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v83 = 0;
    v84 = (_WORD *)(v11 + 40);
    a2 += v10;
    v85 = v95 - a2;
    a3 += v9;
    v86 = v97 - a3;
    while (((v86 | v85 | (a3 - v98) | (a2 - v96)) & 0x8000000000000000) == 0)
    {
      v87 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      v41 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v87;
      v42 = *(unsigned __int16 **)(result + 32);
      if (v17 >= v41)
        v88 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v87);
      else
        v88 = (unsigned __int16 *)v17;
      if (v88 < v42)
        v88 = *(unsigned __int16 **)(result + 32);
      v44 = *v88;
      if (v5)
      {
        v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v87;
        v89 = *(unsigned __int16 **)(result + 40);
        if (v16 >= v45)
          v90 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v87);
        else
          v90 = (unsigned __int16 *)v16;
        if (v90 >= v89)
          v89 = v90;
        v44 |= *v89 << 16;
      }
      if (v8)
      {
        v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v48 & 0xF) != 0)
        {
          v12 += v83 + 1;
          v11 = (uint64_t)(v84 - 12);
          a4 += ~(_DWORD)v83;
          v27 = -1;
          goto LABEL_48;
        }
      }
      v91 = (v44 | v13) >> 16;
      *((_QWORD *)v84 - 1) = (unint64_t)(v91 - v44) << 48;
      *v84 = v91;
      v84 += 8;
      *(_BYTE *)(v12 + v83++ + 2) = -1;
      a2 += v10;
      v85 -= v10;
      a3 += v9;
      v86 -= v9;
      if (a4 - 1 == (_DWORD)v83)
        return result;
    }
    v12 += v83 + 1;
    v11 = (uint64_t)(v84 - 12);
    a4 += ~(_DWORD)v83;
  }
  while (a4);
  return result;
}

uint64_t cmyk64_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned __int16 *v43;
  unint64_t v44;
  unint64_t v45;
  unsigned __int16 *v46;
  unint64_t v47;
  unsigned __int16 *v48;
  uint64_t v49;
  char v50;
  unint64_t v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  char v55;
  unint64_t v56;
  unsigned __int16 *v57;
  unsigned __int16 *v58;
  uint64_t v59;
  _WORD *v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  unsigned __int16 *v65;
  int v66;
  uint64_t v67;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 64);
  v8 = *(_QWORD *)(result + 72);
  v9 = *(_QWORD *)(result + 88);
  v67 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v11 = *(_QWORD *)(result + 120);
  v12 = *(_QWORD *)(result + 152) - 16;
  v13 = *(_QWORD *)(result + 144) - 1;
  v66 = *(_DWORD *)(result + 188);
  v14 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v8)
    {
      if ((uint64_t)a3 <= v9)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v9;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_34;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v66 | v22;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v8 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_34;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v66 | v18;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v7)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v7 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v66;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v10;
    a3 += v11;
    v12 += 16;
    *(_BYTE *)++v13 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v67)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v67;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v66;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v24 < 0x400000)
    goto LABEL_34;
  v34 = v29 >> 32;
  v35 = v4 + SHIDWORD(v25) * (uint64_t)v5;
  v36 = v35 + 6 * (int)v34;
  v37 = *(unsigned __int16 **)(result + 32);
  if (v14 >= v36)
    v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  else
    v38 = (unsigned __int16 *)v14;
  if (v38 < v37)
    v38 = *(unsigned __int16 **)(result + 32);
  v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6)
    goto LABEL_66;
  v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v14 < (unint64_t)v57)
        v57 = (unsigned __int16 *)v14;
      if (v57 < v37)
        v57 = v37;
      v52 = (bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000;
      goto LABEL_64;
    case 2:
      v58 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v58)
        v58 = (unsigned __int16 *)v14;
      if (v58 < v37)
        v58 = v37;
      v52 = (bswap32(*v58) >> 16) | ((unint64_t)(bswap32(v58[1]) >> 16) << 16) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | 0xFFFF000000000000;
      v42 = (v40 >> 28) & 3;
LABEL_64:
      v54 = interpolate_16161616_19469[v42];
      v55 = v42 + 1;
      v56 = v39 - ((v54 & v39) >> v55);
      goto LABEL_65;
    case 3:
      v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v43)
        v43 = (unsigned __int16 *)v14;
      if (v43 < v37)
        v43 = v37;
      v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v14 >= v45)
        v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      else
        v46 = (unsigned __int16 *)v14;
      if (v46 < v37)
        v46 = v37;
      v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v48)
        v48 = (unsigned __int16 *)v14;
      if (v48 < v37)
        v48 = v37;
      v49 = interpolate_16161616_19469[v42];
      v50 = v42 + 1;
      v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      v53 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v53];
      v55 = v53 + 1;
      v56 = v51 - ((v51 & v54) >> v55);
LABEL_65:
      v39 = v56 + ((v52 & v54) >> v55);
      break;
  }
LABEL_66:
  v59 = 0;
  v60 = (_WORD *)(v12 + 24);
  a3 += v11;
  v61 = v9 - a3;
  a2 += v10;
  v62 = v67 - a2;
  while (1)
  {
    v63 = (unsigned __int16)v39;
    if ((unsigned __int16)v39 <= WORD1(v39))
      v63 = WORD1(v39);
    if (WORD2(v39) > v63)
      v63 = WORD2(v39);
    *((_QWORD *)v60 - 1) = ((unint64_t)(unsigned __int16)(v63 - WORD2(v39)) << 32) | ((HIWORD(v39) - v63) << 48) | ((v63 - WORD1(v39)) << 16) | (unsigned __int16)(v63 - v39);
    *v60 = HIWORD(v39);
    *(_BYTE *)(v13 + 1 + v59) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v59)
      return result;
    if (((v61 | v62 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
    {
      v13 += v59 + 1;
      v12 = (uint64_t)(v60 - 4);
      a4 += ~(_DWORD)v59;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v64 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v36 = v64 + 6 * SHIDWORD(a2);
    v37 = *(unsigned __int16 **)(result + 32);
    if (v14 >= v36)
      v65 = (unsigned __int16 *)(v64 + 6 * SHIDWORD(a2));
    else
      v65 = (unsigned __int16 *)v14;
    if (v65 < v37)
      v65 = *(unsigned __int16 **)(result + 32);
    v39 = (bswap32(*v65) >> 16) | ((unint64_t)(bswap32(v65[1]) >> 16) << 16) | ((unint64_t)(bswap32(v65[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v13 += v59 + 1;
        v12 = (uint64_t)(v60 - 4);
        a4 += ~(_DWORD)v59;
        v24 = -1;
        goto LABEL_37;
      }
    }
    ++v59;
    v60 += 8;
    a3 += v11;
    v61 -= v11;
    a2 += v10;
    v62 -= v10;
    v24 = -1;
  }
}

uint64_t cmyk64_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  unsigned int *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int *v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int *v46;
  unint64_t v47;
  unsigned int *v48;
  uint64_t v49;
  char v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  unint64_t v54;
  unsigned int *v55;
  uint64_t v56;
  char v57;
  unint64_t v58;
  unint64_t v59;
  unsigned int *v60;
  char v61;
  uint64_t v62;
  _WORD *v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v67;
  uint64_t v68;
  unsigned int *v69;
  int v70;
  uint64_t v71;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 64);
  v8 = *(_QWORD *)(result + 72);
  v9 = *(_QWORD *)(result + 88);
  v71 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v11 = *(_QWORD *)(result + 120);
  v12 = *(_QWORD *)(result + 152) - 16;
  v13 = *(_QWORD *)(result + 144) - 1;
  v70 = *(_DWORD *)(result + 188);
  v14 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v8)
    {
      if ((uint64_t)a3 <= v9)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v9;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_34;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v70 | v22;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v8 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_34;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v70 | v18;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v7)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v7 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v70;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v10;
    a3 += v11;
    v12 += 16;
    *(_BYTE *)++v13 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v71)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v71;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v70;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v24 < 0x400000)
    goto LABEL_34;
  v34 = v29 >> 32;
  v35 = v4 + SHIDWORD(v25) * (uint64_t)v5;
  v36 = v35 + 6 * (int)v34;
  v37 = *(unsigned int **)(result + 32);
  if (v14 >= v36)
    v38 = (unsigned int *)(v35 + 6 * (int)v34);
  else
    v38 = (unsigned int *)v14;
  if (v38 < v37)
    v38 = *(unsigned int **)(result + 32);
  v39 = *v38 | ((unint64_t)*((unsigned __int16 *)v38 + 2) << 32) | 0xFFFF000000000000;
  if (!v6)
    goto LABEL_66;
  v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v55 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v14 < (unint64_t)v55)
        v55 = (unsigned int *)v14;
      if (v55 < v37)
        v55 = v37;
      v56 = interpolate_16161616_19469[v42];
      v57 = v42 + 1;
      v58 = v39 - ((v56 & v39) >> v57);
      v59 = ((*v55 | ((unint64_t)*((unsigned __int16 *)v55 + 2) << 32) | 0xFFFF000000000000) & v56) >> v57;
LABEL_65:
      v39 = v58 + v59;
      break;
    case 2:
      v60 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v60)
        v60 = (unsigned int *)v14;
      if (v60 < v37)
        v60 = v37;
      v51 = *v60 | ((unint64_t)*((unsigned __int16 *)v60 + 2) << 32) | 0xFFFF000000000000;
      v52 = (v40 >> 28) & 3;
      v53 = interpolate_16161616_19469[v52];
      v54 = v53 & v39;
LABEL_64:
      v61 = v52 + 1;
      v58 = v39 - (v54 >> v61);
      v59 = (v51 & v53) >> v61;
      goto LABEL_65;
    case 3:
      v43 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v43)
        v43 = (unsigned int *)v14;
      if (v43 < v37)
        v43 = v37;
      v44 = *v43 | ((unint64_t)*((unsigned __int16 *)v43 + 2) << 32) | 0xFFFF000000000000;
      v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v14 >= v45)
        v46 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      else
        v46 = (unsigned int *)v14;
      if (v46 < v37)
        v46 = v37;
      v47 = *v46 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32) | 0xFFFF000000000000;
      v48 = (unsigned int *)(v45 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v48)
        v48 = (unsigned int *)v14;
      if (v48 < v37)
        v48 = v37;
      v49 = interpolate_16161616_19469[v42];
      v50 = v42 + 1;
      v39 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      v51 = v44
          - ((v49 & v44) >> v50)
          + (((*v48 | ((unint64_t)*((unsigned __int16 *)v48 + 2) << 32) | 0xFFFF000000000000) & v49) >> v50);
      v52 = (v40 >> 28) & 3;
      v53 = interpolate_16161616_19469[v52];
      v54 = v39 & v53;
      goto LABEL_64;
  }
LABEL_66:
  v62 = 0;
  v63 = (_WORD *)(v12 + 24);
  a3 += v11;
  v64 = v9 - a3;
  a2 += v10;
  v65 = v71 - a2;
  while (1)
  {
    v66 = (unsigned __int16)v39;
    v67 = WORD2(v39);
    if ((unsigned __int16)v39 <= WORD1(v39))
      v66 = WORD1(v39);
    if (WORD2(v39) <= v66)
      v67 = v66;
    *((_QWORD *)v63 - 1) = ((unint64_t)(unsigned __int16)(v67 - WORD2(v39)) << 32) | ((HIWORD(v39) - v67) << 48) | ((v67 - WORD1(v39)) << 16) | (unsigned __int16)(v67 - v39);
    *v63 = HIWORD(v39);
    *(_BYTE *)(v13 + 1 + v62) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v62)
      return result;
    if (((v64 | v65 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
    {
      v13 += v62 + 1;
      v12 = (uint64_t)(v63 - 4);
      a4 += ~(_DWORD)v62;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v68 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v36 = v68 + 6 * SHIDWORD(a2);
    v37 = *(unsigned int **)(result + 32);
    if (v14 >= v36)
      v69 = (unsigned int *)(v68 + 6 * SHIDWORD(a2));
    else
      v69 = (unsigned int *)v14;
    if (v69 < v37)
      v69 = *(unsigned int **)(result + 32);
    v39 = *v69 | ((unint64_t)*((unsigned __int16 *)v69 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v13 += v62 + 1;
        v12 = (uint64_t)(v63 - 4);
        a4 += ~(_DWORD)v62;
        v24 = -1;
        goto LABEL_37;
      }
    }
    ++v62;
    v63 += 8;
    a3 += v11;
    v64 -= v11;
    a2 += v10;
    v65 -= v10;
    v24 = -1;
  }
}

uint64_t cmyk64_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  unint64_t v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned __int16 *v45;
  unint64_t v46;
  unint64_t v47;
  unsigned __int16 *v48;
  unint64_t v49;
  unsigned __int16 *v50;
  uint64_t v51;
  char v52;
  unint64_t v53;
  unsigned __int16 *v54;
  uint64_t v55;
  char v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int16 *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  _WORD *v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  uint64_t v68;
  unsigned __int16 *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v7 = *(_QWORD *)(result + 88);
  v72 = *(_QWORD *)(result + 80);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v70 = *(_DWORD *)(result + 188);
  v10 = *(_QWORD *)(result + 152) - 16;
  v11 = *(_QWORD *)(result + 144) - 1;
  v12 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v13 = 0;
  else
    v13 = 0xFFFF000000000000;
  v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  v71 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
        v26 = v71;
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v7;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_37;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v26 = v71;
        v24 = v70 | v22;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v6 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_37;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v26 = v71;
      v24 = v70 | v18;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v26)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v26 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v70;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v72)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_29;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v72;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_37;
  if (v34 < v32)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v70;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_29:
  if (v24 < 0x400000)
    goto LABEL_37;
  v35 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  v36 = v30 >> 32;
  v37 = v35 + 8 * v36;
  v38 = *(unsigned __int16 **)(result + 32);
  if (v14 >= v37)
    v39 = (unsigned __int16 *)(v35 + 8 * v36);
  else
    v39 = (unsigned __int16 *)v14;
  if (v39 < v38)
    v39 = *(unsigned __int16 **)(result + 32);
  v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    v41 = *(_DWORD *)(v5 + (v31 | v23));
LABEL_40:
    v42 = v41 & 0xF;
    v43 = HIBYTE(v41) & 3;
    if (v42 == 1)
    {
      v54 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      if (v14 < (unint64_t)v54)
        v54 = (unsigned __int16 *)v14;
      if (v54 < v38)
        v54 = v38;
      v55 = interpolate_16161616_19469[v43];
      v56 = v43 + 1;
      v57 = v40 - ((v55 & v40) >> v56);
      v58 = ((((unint64_t)(bswap32(v54[2]) >> 16) << 32) | ((unint64_t)(bswap32(v54[3]) >> 16) << 48) | bswap32(v54[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v54) >> 16)) & v55) >> v56;
    }
    else
    {
      if (v42 != 2)
      {
        if (v42 == 3)
        {
          v44 = (unint64_t)HIWORD(v41) << 56;
          v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
          if (v14 < (unint64_t)v45)
            v45 = (unsigned __int16 *)v14;
          if (v45 < v38)
            v45 = v38;
          v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
          v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
          if (v14 >= v47)
            v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
          else
            v48 = (unsigned __int16 *)v14;
          if (v48 < v38)
            v48 = v38;
          v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
          v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
          if (v14 < (unint64_t)v50)
            v50 = (unsigned __int16 *)v14;
          if (v50 < v38)
            v50 = v38;
          v51 = interpolate_16161616_19469[v43];
          v52 = v43 + 1;
          v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
          v40 = v53
              - ((v53 & interpolate_16161616_19469[(v41 >> 28) & 3]) >> (((v41 >> 28) & 3) + 1))
              + (((v46
                 - ((v51 & v46) >> v52)
                 + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52)) & interpolate_16161616_19469[(v41 >> 28) & 3]) >> (((v41 >> 28) & 3) + 1));
        }
        goto LABEL_68;
      }
      v59 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
      if (v14 < (unint64_t)v59)
        v59 = (unsigned __int16 *)v14;
      if (v59 < v38)
        v59 = v38;
      v60 = (v41 >> 28) & 3;
      v61 = interpolate_16161616_19469[v60];
      LOBYTE(v60) = v60 + 1;
      v57 = v40 - ((v61 & v40) >> v60);
      v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v61) >> v60;
    }
    v40 = v57 + v58;
  }
LABEL_68:
  v62 = 0;
  v63 = (_WORD *)(v10 + 24);
  a3 += v9;
  v64 = v7 - a3;
  a2 += v8;
  v65 = v72 - a2;
  while (1)
  {
    v66 = (unsigned __int16)v40;
    if ((unsigned __int16)v40 <= WORD1(v40))
      v66 = WORD1(v40);
    if ((unsigned __int16)((v40 | v13) >> 32) > v66)
      v66 = (unsigned __int16)((v40 | v13) >> 32);
    v67 = (v40 | v13) >> 48;
    *((_QWORD *)v63 - 1) = ((unint64_t)(unsigned __int16)(v66 - ((v40 | v13) >> 32)) << 32) | ((unint64_t)(v67 - v66) << 48) | ((v66 - WORD1(v40)) << 16) | (unsigned __int16)(v66 - v40);
    *v63 = v67;
    *(_BYTE *)(v11 + 1 + v62) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v62)
      return result;
    if (((v64 | v65 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v11 += v62 + 1;
      v10 = (uint64_t)(v63 - 4);
      a4 += ~(_DWORD)v62;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v68 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    v37 = v68 + 8 * (a2 >> 32);
    v38 = *(unsigned __int16 **)(result + 32);
    if (v14 >= v37)
      v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    else
      v69 = (unsigned __int16 *)v14;
    if (v69 < v38)
      v69 = *(unsigned __int16 **)(result + 32);
    v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v11 += v62 + 1;
        v10 = (uint64_t)(v63 - 4);
        a4 += ~(_DWORD)v62;
        v24 = -1;
        goto LABEL_40;
      }
    }
    ++v62;
    v63 += 8;
    a3 += v9;
    v64 -= v9;
    a2 += v8;
    v65 -= v8;
    v24 = -1;
  }
}

uint64_t cmyk64_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t *v37;
  unint64_t v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  int v42;
  int64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t *v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  int v54;
  unint64_t v55;
  char v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  char v61;
  unint64_t v62;
  unint64_t *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  _WORD *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t *v74;
  uint64_t v75;
  int v76;
  uint64_t v77;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v7 = *(_QWORD *)(result + 88);
  v75 = *(_QWORD *)(result + 80);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v76 = *(_DWORD *)(result + 188);
  v10 = *(_QWORD *)(result + 152) - 16;
  v11 = *(_QWORD *)(result + 144) - 1;
  v12 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v13 = 0;
  else
    v13 = 0xFFFF000000000000;
  v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  v77 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        v24 = (a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        v18 = v77;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v7;
        v22 = v21 - a3 + (v20 >> 1);
        v18 = v77;
        if (v22 < 1)
          goto LABEL_37;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v25 = v76 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v6 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      v18 = v77;
      if (v17 < 1)
        goto LABEL_37;
      if (v17 >= v15)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v25 = v76 | v19;
      v26 = v16 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v18)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v18 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v76;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v75)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_29;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v75;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_37;
  if (v34 < v32)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v76;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_37;
  v35 = v12 + SHIDWORD(v26) * (uint64_t)v4 + 8 * (v30 >> 32);
  v36 = *(unint64_t **)(result + 32);
  if (v14 >= v35)
    v37 = (unint64_t *)v35;
  else
    v37 = (unint64_t *)v14;
  if (v37 < v36)
    v37 = *(unint64_t **)(result + 32);
  v38 = *v37;
  if (!v5)
  {
    v40 = v75;
    goto LABEL_70;
  }
  v39 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_41:
  v41 = v39 & 0xF;
  v42 = HIBYTE(v39) & 3;
  v40 = v75;
  switch(v41)
  {
    case 1:
      v59 = (unint64_t *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v14 < (unint64_t)v59)
        v59 = (unint64_t *)v14;
      if (v59 < v36)
        v59 = v36;
      v60 = interpolate_16161616_19469[v42];
      v61 = v42 + 1;
      v57 = v38 - ((v60 & v38) >> v61);
      v62 = (v60 & *v59) >> v61;
LABEL_69:
      v38 = v57 + v62;
      break;
    case 2:
      v63 = (unint64_t *)(v35 + ((uint64_t)((unint64_t)HIWORD(v39) << 56) >> 53));
      if (v14 < (unint64_t)v63)
        v63 = (unint64_t *)v14;
      if (v63 < v36)
        v63 = v36;
      v64 = (v39 >> 28) & 3;
      v65 = interpolate_16161616_19469[v64];
      v56 = v64 + 1;
      v57 = v38 - ((v65 & v38) >> v56);
      v58 = v65 & *v63;
LABEL_68:
      v62 = v58 >> v56;
      goto LABEL_69;
    case 3:
      v43 = (unint64_t)HIWORD(v39) << 56;
      v44 = (unint64_t *)(v35 + (v43 >> 53));
      if (v14 < (unint64_t)v44)
        v44 = (unint64_t *)v14;
      if (v44 < v36)
        v44 = v36;
      v45 = *v44;
      v46 = (unint64_t *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v14 >= (unint64_t)v46)
        v47 = v46;
      else
        v47 = (unint64_t *)v14;
      if (v47 < v36)
        v47 = v36;
      v48 = *v47;
      v49 = (unint64_t *)((char *)v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49)
        v49 = (unint64_t *)v14;
      if (v49 < v36)
        v49 = v36;
      v50 = interpolate_16161616_19469[v42];
      v51 = v42 + 1;
      v52 = v38 - ((v50 & v38) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      v54 = (v39 >> 28) & 3;
      v55 = interpolate_16161616_19469[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      v58 = v53 & v55;
      goto LABEL_68;
  }
LABEL_70:
  v66 = 0;
  v67 = (_WORD *)(v10 + 24);
  a3 += v9;
  v68 = v7 - a3;
  a2 += v8;
  v69 = v40 - a2;
  while (1)
  {
    v70 = (unsigned __int16)v38;
    v71 = (unsigned __int16)((v38 | v13) >> 32);
    if ((unsigned __int16)v38 <= WORD1(v38))
      v70 = WORD1(v38);
    if (v71 <= v70)
      v71 = v70;
    v72 = (v38 | v13) >> 48;
    *((_QWORD *)v67 - 1) = ((unint64_t)(unsigned __int16)(v71 - ((v38 | v13) >> 32)) << 32) | ((unint64_t)(v72 - v71) << 48) | ((v71 - WORD1(v38)) << 16) | (unsigned __int16)(v71 - v38);
    *v67 = v72;
    *(_BYTE *)(v11 + 1 + v66) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v66)
      return result;
    if (((v68 | v69 | (a3 - v6) | (a2 - v77)) & 0x8000000000000000) != 0)
    {
      v10 = (uint64_t)(v67 - 4);
      v11 += v66 + 1;
      a4 += ~(_DWORD)v66;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v73 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    v35 = v73 + 8 * (a2 >> 32);
    v36 = *(unint64_t **)(result + 32);
    if (v14 >= v35)
      v74 = (unint64_t *)(v73 + 8 * (a2 >> 32));
    else
      v74 = (unint64_t *)v14;
    if (v74 < v36)
      v74 = *(unint64_t **)(result + 32);
    v38 = *v74;
    if (v5)
    {
      v39 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v10 = (uint64_t)(v67 - 4);
        v11 += v66 + 1;
        a4 += ~(_DWORD)v66;
        v25 = -1;
        goto LABEL_41;
      }
    }
    v67 += 8;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    v25 = -1;
  }
}

uint64_t cmyk64_sample_CMYK64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unsigned __int16 *v49;
  unsigned __int16 *v50;
  unint64_t v51;
  unsigned __int16 *v52;
  unsigned __int16 *v53;
  uint64_t v54;
  int v55;
  unint64_t v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  int64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int16 *v70;
  unint64_t v71;
  unint64_t v72;
  unsigned __int16 *v73;
  unsigned __int16 *v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned __int16 *v78;
  unint64_t v79;
  unint64_t v80;
  unsigned __int16 *v81;
  unsigned __int16 *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  int v86;
  unsigned int v87;
  char *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned __int16 *v93;
  unint64_t v94;
  unsigned int v95;
  unsigned __int16 *v96;
  char *v97;
  char v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned __int16 *v104;
  unint64_t v105;
  unsigned int v106;
  unsigned __int16 *v107;
  unsigned int v108;
  char *v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned __int16 *v122;
  unsigned __int16 *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unsigned int v128;
  uint64_t v129;
  unsigned int v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;

  v4 = *(_DWORD *)(result + 24);
  v138 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v137 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v137 = v5 % v6;
  }
  else
  {
    v137 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 40);
  v139 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v136 = v11;
  }
  else
  {
    v136 = 0;
  }
  v132 = *(_QWORD *)(result + 80);
  v133 = *(_QWORD *)(result + 64);
  v134 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 152) - 16;
  v13 = *(_QWORD *)(result + 144) - 1;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = v9 + (v14 * v138) + 2 * (v15 - 1);
  v131 = *(_DWORD *)(result + 188);
  v17 = v139 + (v14 * v4) + 8 * v15 - 16;
  v135 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 < v135)
    {
      v18 = *(_QWORD *)(result + 216);
      v19 = v135 - *(_QWORD *)(result + 224);
      v20 = a3 - v19 + (v18 >> 1);
      v21 = a4;
      if (v20 < 1)
        goto LABEL_57;
      if (v20 >= v18)
        LODWORD(v22) = 0x3FFFFFFF;
      else
        v22 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
      v29 = v131 | v22;
      v30 = v19 + 0x1000000;
      v27 = a3 - v30;
      v28 = 512;
      goto LABEL_22;
    }
    if (a3 <= v134)
    {
      v27 = 0;
      v28 = ((unint64_t)a3 >> 22) & 0x3C0;
      v29 = 0x3FFFFFFF;
      v30 = a3;
      v21 = a4;
LABEL_22:
      v31 = v133;
      goto LABEL_25;
    }
    v23 = *(_QWORD *)(result + 216);
    v24 = *(_QWORD *)(result + 224) + v134;
    v25 = v24 - a3 + (v23 >> 1);
    v21 = a4;
    if (v25 < 1)
      goto LABEL_57;
    if (v25 >= v23)
      LODWORD(v26) = 0x3FFFFFFF;
    else
      v26 = (unint64_t)(*(_QWORD *)(result + 232) * v25) >> 32;
    v31 = v133;
    v29 = v131 | v26;
    v30 = v24 - 0x1000000;
    v27 = a3 - v30;
    v28 = 448;
LABEL_25:
    if (a2 >= v31)
      break;
    v32 = *(_QWORD *)(result + 192);
    v33 = v31 - *(_QWORD *)(result + 200);
    v34 = a2 - v33 + (v32 >> 1);
    if (v34 >= 1)
    {
      if (v34 < v32)
        v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v131;
      v35 = v33 + 0x1000000;
      v36 = a2 - (v33 + 0x1000000);
      v37 = 32;
      goto LABEL_36;
    }
LABEL_57:
    v55 = v21 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 16;
    *(_BYTE *)++v13 = 0;
LABEL_58:
    a4 = v55;
    if (!v55)
      return result;
  }
  if (a2 <= v132)
  {
    v36 = 0;
    v37 = ((unint64_t)a2 >> 26) & 0x3C;
    v35 = a2;
    goto LABEL_36;
  }
  v38 = *(_QWORD *)(result + 192);
  v39 = *(_QWORD *)(result + 200) + v132;
  v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1)
    goto LABEL_57;
  if (v40 < v38)
    v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v131;
  v35 = v39 - 0x1000000;
  v36 = a2 - (v39 - 0x1000000);
  v37 = 28;
LABEL_36:
  if (v29 < 0x400000)
    goto LABEL_57;
  v130 = v29;
  if (v6)
  {
    v41 = (v7 & ((v30 % v7) >> 63)) + v30 % v7;
    v42 = (v6 & ((v35 % v6) >> 63)) + v35 % v6;
    if (v41 >= v7)
      v43 = v7;
    else
      v43 = 0;
    v30 = v41 - v43;
    if (v42 >= v6)
      v44 = v6;
    else
      v44 = 0;
    v35 = v42 - v44;
    v27 += v30;
    v36 += v35;
  }
  v45 = v30 >> 32;
  v46 = v35 >> 32;
  v47 = v139 + SHIDWORD(v30) * (uint64_t)v4;
  v48 = v47 + 8 * v46;
  v49 = *(unsigned __int16 **)(result + 32);
  if (v17 >= v48)
    v50 = (unsigned __int16 *)(v47 + 8 * v46);
  else
    v50 = (unsigned __int16 *)v17;
  if (v50 < v49)
    v50 = *(unsigned __int16 **)(result + 32);
  if (v9)
  {
    v51 = v9 + (int)v45 * (uint64_t)v138 + 2 * v46;
    v52 = *(unsigned __int16 **)(result + 40);
    if (v16 >= v51)
      v53 = (unsigned __int16 *)v51;
    else
      v53 = (unsigned __int16 *)v16;
    if (v53 >= v52)
      v52 = v53;
    v54 = bswap32(*v52) >> 16;
  }
  else
  {
    v51 = 0;
    v54 = 0xFFFFLL;
  }
  v56 = ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16);
  if (v8)
  {
    v57 = *(_DWORD *)(v8 + (v37 | v28));
LABEL_64:
    v58 = v57 & 0xF;
    v59 = HIBYTE(v57) & 3;
    if (v58 == 1)
    {
      LODWORD(v89) = SBYTE1(v57);
      if (v6)
      {
        v90 = v27 + ((uint64_t)SBYTE1(v57) << 32);
        v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7)
          v92 = v7;
        else
          v92 = 0;
        v89 = (v91 + ((uint64_t)SBYTE1(v57) << 32) - v92) >> 32;
      }
      v93 = (unsigned __int16 *)(v48 + (int)v89 * (uint64_t)v4);
      if (v17 < (unint64_t)v93)
        v93 = (unsigned __int16 *)v17;
      if (v93 < v49)
        v93 = v49;
      v94 = ((unint64_t)(bswap32(v93[2]) >> 16) << 32) | ((unint64_t)(bswap32(v93[3]) >> 16) << 48) | bswap32(v93[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v93) >> 16);
      LOWORD(v95) = -1;
      if (v9)
      {
        v96 = (unsigned __int16 *)(v51 + (int)v89 * (uint64_t)v138);
        if (v16 < (unint64_t)v96)
          v96 = (unsigned __int16 *)v16;
        if ((unint64_t)v96 < *(_QWORD *)(result + 40))
          v96 = *(unsigned __int16 **)(result + 40);
        v95 = bswap32(*v96) >> 16;
      }
      v97 = (char *)&interpolate_cmyk64 + 16 * v59;
      v98 = v59 + 1;
      v56 = v56 - ((*(_QWORD *)v97 & v56) >> v98) + ((*(_QWORD *)v97 & v94) >> v98);
      v99 = v54
          - ((unsigned __int16)(*((_WORD *)v97 + 4) & v54) >> v98)
          + ((unsigned __int16)(*((_WORD *)v97 + 4) & v95) >> v98);
    }
    else
    {
      if (v58 != 2)
      {
        if (v58 == 3)
        {
          v128 = HIBYTE(v57) & 3;
          v129 = v12;
          LODWORD(v60) = SBYTE1(v57);
          v61 = SBYTE2(v57);
          if (v6)
          {
            v62 = (unint64_t)HIWORD(v57) << 56;
            v63 = v27 + ((uint64_t)SBYTE1(v57) << 32);
            v64 = v36 + (v62 >> 24);
            v65 = v7 & (v63 >> 63);
            v66 = v6 & (v64 >> 63);
            v67 = v66 + v64;
            if (v65 + v63 >= v7)
              v68 = v7;
            else
              v68 = 0;
            if (v67 >= v6)
              v69 = v6;
            else
              v69 = 0;
            v60 = (v65 + ((uint64_t)((unint64_t)(v57 >> 8) << 56) >> 24) - v68) >> 32;
            v61 = (v66 + (v62 >> 24) - v69) >> 32;
          }
          v70 = (unsigned __int16 *)(v48 + 8 * v61);
          if (v17 < (unint64_t)v70)
            v70 = (unsigned __int16 *)v17;
          if (v70 < v49)
            v70 = v49;
          v71 = ((unint64_t)(bswap32(v70[2]) >> 16) << 32) | ((unint64_t)(bswap32(v70[3]) >> 16) << 48) | bswap32(v70[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v70) >> 16);
          v72 = v48 + (int)v60 * (uint64_t)v4;
          if (v17 >= v72)
            v73 = (unsigned __int16 *)(v48 + (int)v60 * (uint64_t)v4);
          else
            v73 = (unsigned __int16 *)v17;
          if (v73 < v49)
            v73 = v49;
          v127 = ((unint64_t)(bswap32(v73[2]) >> 16) << 32) | ((unint64_t)(bswap32(v73[3]) >> 16) << 48) | bswap32(v73[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v73) >> 16);
          v74 = (unsigned __int16 *)(v72 + 8 * v61);
          if (v17 < (unint64_t)v74)
            v74 = (unsigned __int16 *)v17;
          if (v74 < v49)
            v74 = v49;
          v126 = ((unint64_t)(bswap32(v74[2]) >> 16) << 32) | ((unint64_t)(bswap32(v74[3]) >> 16) << 48) | bswap32(v74[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v74) >> 16);
          v75 = 0xFFFF;
          v76 = 0xFFFF;
          v77 = 0xFFFF;
          if (v9)
          {
            v78 = (unsigned __int16 *)(v51 + 2 * v61);
            v79 = *(_QWORD *)(result + 40);
            if (v16 < (unint64_t)v78)
              v78 = (unsigned __int16 *)v16;
            if ((unint64_t)v78 < v79)
              v78 = *(unsigned __int16 **)(result + 40);
            v75 = bswap32(*v78) >> 16;
            v80 = v51 + (int)v60 * (uint64_t)v138;
            if (v16 >= v80)
              v81 = (unsigned __int16 *)(v51 + (int)v60 * (uint64_t)v138);
            else
              v81 = (unsigned __int16 *)v16;
            if ((unint64_t)v81 < v79)
              v81 = *(unsigned __int16 **)(result + 40);
            v76 = bswap32(*v81) >> 16;
            v82 = (unsigned __int16 *)(v80 + 2 * v61);
            if (v16 < (unint64_t)v82)
              v82 = (unsigned __int16 *)v16;
            if ((unint64_t)v82 < v79)
              v82 = *(unsigned __int16 **)(result + 40);
            v77 = bswap32(*v82) >> 16;
          }
          v83 = (char *)&interpolate_cmyk64 + 16 * v128;
          v84 = *(_QWORD *)v83;
          v85 = v56 - ((*(_QWORD *)v83 & v56) >> (v128 + 1));
          LODWORD(v83) = *((unsigned __int16 *)v83 + 4);
          v86 = v54
              - ((v83 & v54) >> (v128 + 1))
              + ((v83 & v76) >> (v128 + 1));
          LODWORD(v83) = v75 - ((v83 & v75) >> (v128 + 1)) + ((v83 & v77) >> (v128 + 1));
          v87 = (v57 >> 28) & 3;
          v88 = (char *)&interpolate_cmyk64 + 16 * v87;
          LOBYTE(v87) = v87 + 1;
          v56 = v85
              + ((v84 & v127) >> (v128 + 1))
              - (((v85 + ((v84 & v127) >> (v128 + 1))) & *(_QWORD *)v88) >> v87)
              + (((v71 - ((v84 & v71) >> (v128 + 1)) + ((v84 & v126) >> (v128 + 1))) & *(_QWORD *)v88) >> v87);
          v54 = (unsigned __int16)(v86
                                 - ((unsigned __int16)(v86 & *((_WORD *)v88 + 4)) >> v87)
                                 + ((unsigned __int16)((unsigned __int16)v83 & *((_WORD *)v88 + 4)) >> v87));
          v12 = v129;
        }
        goto LABEL_137;
      }
      v100 = SBYTE2(v57);
      if (v6)
      {
        v101 = v36 + ((uint64_t)SBYTE2(v57) << 32);
        v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6)
          v103 = v6;
        else
          v103 = 0;
        v100 = (v102 + ((uint64_t)((unint64_t)HIWORD(v57) << 56) >> 24) - v103) >> 32;
      }
      v104 = (unsigned __int16 *)(v48 + 8 * v100);
      if (v17 < (unint64_t)v104)
        v104 = (unsigned __int16 *)v17;
      if (v104 < v49)
        v104 = v49;
      v105 = ((unint64_t)(bswap32(v104[2]) >> 16) << 32) | ((unint64_t)(bswap32(v104[3]) >> 16) << 48) | bswap32(v104[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v104) >> 16);
      LOWORD(v106) = -1;
      if (v9)
      {
        v107 = (unsigned __int16 *)(v51 + 2 * v100);
        if (v16 < (unint64_t)v107)
          v107 = (unsigned __int16 *)v16;
        if ((unint64_t)v107 < *(_QWORD *)(result + 40))
          v107 = *(unsigned __int16 **)(result + 40);
        v106 = bswap32(*v107) >> 16;
      }
      v108 = (v57 >> 28) & 3;
      v109 = (char *)&interpolate_cmyk64 + 16 * v108;
      LOBYTE(v108) = v108 + 1;
      v56 = v56 - ((*(_QWORD *)v109 & v56) >> v108) + ((*(_QWORD *)v109 & v105) >> v108);
      v99 = v54 - ((unsigned __int16)(*((_WORD *)v109 + 4) & v54) >> v108) + ((*((_WORD *)v109 + 4) & v106) >> v108);
    }
    v54 = (unsigned __int16)v99;
  }
LABEL_137:
  *(_QWORD *)(v12 + 16) = v56;
  *(_QWORD *)(v12 + 24) = v54;
  *(_BYTE *)(v13 + 1) = v130 >> 22;
  if (v21 != 1)
  {
    v110 = 0;
    v111 = (uint64_t *)(v12 + 40);
    a2 += v5;
    v112 = v132 - a2;
    a3 += v10;
    v113 = v134 - a3;
    while (((v113 | v112 | (a3 - v135) | (a2 - v133)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v114 = (v7 & ((v27 + v136) >> 63)) + v27 + v136;
        v115 = (v6 & ((v36 + v137) >> 63)) + v36 + v137;
        if (v114 >= v7)
          v116 = v7;
        else
          v116 = 0;
        v27 = v114 - v116;
        if (v115 >= v6)
          v117 = v6;
        else
          v117 = 0;
        v36 = v115 - v117;
        v118 = v27;
        v119 = v36;
      }
      else
      {
        v118 = a3;
        v119 = a2;
      }
      v120 = v119 >> 32;
      v121 = v118 >> 32;
      v48 = v139 + SHIDWORD(v118) * (uint64_t)v4 + 8 * (v119 >> 32);
      v49 = *(unsigned __int16 **)(result + 32);
      if (v17 >= v48)
        v122 = (unsigned __int16 *)v48;
      else
        v122 = (unsigned __int16 *)v17;
      if (v122 < v49)
        v122 = *(unsigned __int16 **)(result + 32);
      if (v9)
      {
        v51 = v9 + (int)v121 * (uint64_t)v138 + 2 * v120;
        v123 = *(unsigned __int16 **)(result + 40);
        if (v16 >= v51)
          v124 = v9 + (int)v121 * (uint64_t)v138 + 2 * v120;
        else
          v124 = v16;
        if (v124 >= (unint64_t)v123)
          v123 = (unsigned __int16 *)v124;
        v54 = bswap32(*v123) >> 16;
      }
      else
      {
        v54 = 0xFFFFLL;
      }
      v56 = ((unint64_t)(bswap32(v122[2]) >> 16) << 32) | ((unint64_t)(bswap32(v122[3]) >> 16) << 48) | bswap32(v122[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v122) >> 16);
      if (v8)
      {
        v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v57 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 = (uint64_t)(v111 - 3);
          v21 += ~(_DWORD)v110;
          v130 = -1;
          goto LABEL_64;
        }
      }
      *(v111 - 1) = v56;
      *v111 = v54;
      v125 = v13 + v110++;
      v111 += 2;
      a2 += v5;
      *(_BYTE *)(v125 + 2) = -1;
      v112 -= v5;
      a3 += v10;
      v113 -= v10;
      if (v21 - 1 == (_DWORD)v110)
        return result;
    }
    v13 += v110 + 1;
    v12 = (uint64_t)(v111 - 3);
    v55 = ~(_DWORD)v110 + v21;
    goto LABEL_58;
  }
  return result;
}

uint64_t cmyk64_sample_cmyk64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  unint64_t v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t *v74;
  int v75;
  unint64_t v76;
  unint64_t *v77;
  unint64_t *v78;
  int v79;
  int v80;
  int v81;
  unsigned __int16 *v82;
  unint64_t v83;
  unint64_t v84;
  unsigned __int16 *v85;
  unsigned __int16 *v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  char *v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  int v102;
  unsigned __int16 *v103;
  char *v104;
  uint64_t v105;
  char v106;
  unint64_t v107;
  int v108;
  unsigned int v109;
  uint64_t v110;
  int64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t *v115;
  unint64_t v116;
  int v117;
  unsigned __int16 *v118;
  unsigned int v119;
  char *v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  uint64_t *v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t *v136;
  unsigned __int16 *v137;
  unsigned __int16 *v138;
  uint64_t v139;
  int v140;
  unint64_t v141;
  unint64_t v142;
  int64_t v143;
  unint64_t v144;
  unsigned int v145;
  unsigned int v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  int v154;

  v5 = *(_DWORD *)(result + 24);
  v154 = *(_DWORD *)(result + 28);
  v6 = *(_QWORD *)(result + 112);
  v7 = *(_QWORD *)(result + 48);
  v8 = *(_QWORD *)(result + 56);
  if (v7)
  {
    v153 = *(_QWORD *)(result + 112);
    if (v6 > v7)
      v153 = v6 % v7;
  }
  else
  {
    v153 = 0;
  }
  v9 = *(_QWORD *)(result + 176);
  v11 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 40);
  v12 = *(_QWORD *)(result + 120);
  if (v8)
  {
    v13 = v12 % v8;
    if (v12 <= v8)
      v13 = *(_QWORD *)(result + 120);
    v152 = v13;
  }
  else
  {
    v152 = 0;
  }
  v151 = *(_QWORD *)(result + 80);
  v148 = *(_QWORD *)(result + 64);
  v149 = *(_QWORD *)(result + 88);
  v14 = *(_QWORD *)(result + 152) - 16;
  v15 = *(_QWORD *)(result + 144) - 1;
  v16 = *(_DWORD *)(result + 260) - 1;
  v17 = *(unsigned int *)(result + 256);
  v18 = v10 + (v16 * v154) + 2 * (v17 - 1);
  v147 = *(_DWORD *)(result + 188);
  v19 = v11 + (v16 * v5) + 8 * v17 - 16;
  v150 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 < v150)
    {
      v20 = *(_QWORD *)(result + 216);
      v21 = v150 - *(_QWORD *)(result + 224);
      v22 = a3 - v21 + (v20 >> 1);
      if (v22 < 1)
        goto LABEL_57;
      if (v22 >= v20)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
      v30 = v147 | v23;
      v31 = v21 + 0x1000000;
      v28 = a3 - (v21 + 0x1000000);
      v29 = 512;
      goto LABEL_22;
    }
    if (a3 <= v149)
    {
      v28 = 0;
      v29 = ((unint64_t)a3 >> 22) & 0x3C0;
      v30 = 0x3FFFFFFF;
      v31 = a3;
LABEL_22:
      v32 = v148;
      v33 = v151;
      goto LABEL_25;
    }
    v24 = *(_QWORD *)(result + 216);
    v25 = *(_QWORD *)(result + 224) + v149;
    v26 = v25 - a3 + (v24 >> 1);
    if (v26 < 1)
      goto LABEL_57;
    if (v26 >= v24)
      LODWORD(v27) = 0x3FFFFFFF;
    else
      v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
    v32 = v148;
    v33 = v151;
    v30 = v147 | v27;
    v31 = v25 - 0x1000000;
    v28 = a3 - (v25 - 0x1000000);
    v29 = 448;
LABEL_25:
    if (a2 >= v32)
      break;
    v34 = *(_QWORD *)(result + 192);
    v35 = v32 - *(_QWORD *)(result + 200);
    v36 = a2 - v35 + (v34 >> 1);
    if (v36 >= 1)
    {
      if (v36 < v34)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v147;
      v37 = v35 + 0x1000000;
      v38 = a2 - (v35 + 0x1000000);
      v39 = 32;
      goto LABEL_36;
    }
LABEL_57:
    v57 = a4 - 1;
    a2 += v6;
    a3 += v12;
    v14 += 16;
    *(_BYTE *)++v15 = 0;
LABEL_58:
    a4 = v57;
    if (!v57)
      return result;
  }
  if (a2 <= v33)
  {
    v38 = 0;
    v39 = ((unint64_t)a2 >> 26) & 0x3C;
    v37 = a2;
    goto LABEL_36;
  }
  v40 = *(_QWORD *)(result + 192);
  v41 = *(_QWORD *)(result + 200) + v33;
  v42 = v41 - a2 + (v40 >> 1);
  if (v42 < 1)
    goto LABEL_57;
  if (v42 < v40)
    v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v147;
  v37 = v41 - 0x1000000;
  v38 = a2 - (v41 - 0x1000000);
  v39 = 28;
LABEL_36:
  if (v30 < 0x400000)
    goto LABEL_57;
  if (v7)
  {
    v43 = (v8 & ((v31 % v8) >> 63)) + v31 % v8;
    v44 = (v7 & ((v37 % v7) >> 63)) + v37 % v7;
    if (v43 >= v8)
      v45 = v8;
    else
      v45 = 0;
    v31 = v43 - v45;
    if (v44 >= v7)
      v46 = v7;
    else
      v46 = 0;
    v37 = v44 - v46;
    v28 += v31;
    v38 += v37;
  }
  v47 = v31 >> 32;
  v48 = v37 >> 32;
  v49 = v11 + (int)v47 * (uint64_t)v5;
  v50 = v49 + 8 * v48;
  v51 = *(uint64_t **)(result + 32);
  if (v19 >= v50)
    v52 = (uint64_t *)(v49 + 8 * v48);
  else
    v52 = (uint64_t *)v19;
  if (v52 < v51)
    v52 = *(uint64_t **)(result + 32);
  if (v10)
  {
    v53 = v10 + (int)v47 * (uint64_t)v154 + 2 * v48;
    v54 = *(unsigned __int16 **)(result + 40);
    if (v18 >= v53)
      v55 = (unsigned __int16 *)v53;
    else
      v55 = (unsigned __int16 *)v18;
    if (v55 >= v54)
      v54 = v55;
    v56 = *v54;
  }
  else
  {
    v53 = 0;
    v56 = 0xFFFFLL;
  }
  v58 = *v52;
  if (!v9)
    goto LABEL_63;
  v59 = *(_DWORD *)(v9 + (v39 | v29));
LABEL_65:
  v61 = v59 & 0xF;
  v62 = v59 >> 8;
  v63 = HIBYTE(v59) & 3;
  v146 = v30;
  if (v61 == 1)
  {
    LODWORD(v95) = SBYTE1(v59);
    if (v7)
    {
      v96 = v62 << 56;
      v97 = v28 + (v96 >> 24);
      v98 = v8 & (v97 >> 63);
      if (v98 + v97 >= v8)
        v99 = v8;
      else
        v99 = 0;
      v95 = (v98 + (v96 >> 24) - v99) >> 32;
    }
    v100 = (unint64_t *)(v50 + (int)v95 * (uint64_t)v5);
    if (v19 < (unint64_t)v100)
      v100 = (unint64_t *)v19;
    if (v100 < (unint64_t *)v51)
      v100 = (unint64_t *)v51;
    v101 = *v100;
    v102 = 0xFFFF;
    if (v10)
    {
      v103 = (unsigned __int16 *)(v53 + (int)v95 * (uint64_t)v154);
      if (v18 < (unint64_t)v103)
        v103 = (unsigned __int16 *)v18;
      if ((unint64_t)v103 < *(_QWORD *)(result + 40))
        v103 = *(unsigned __int16 **)(result + 40);
      v102 = *v103;
    }
    v104 = (char *)&interpolate_cmyk64 + 16 * v63;
    v105 = *(_QWORD *)v104;
    v106 = v63 + 1;
    v107 = v58 - ((*(_QWORD *)v104 & (unint64_t)v58) >> v106);
    LODWORD(v104) = *((unsigned __int16 *)v104 + 4);
    v108 = v56 - ((v104 & v56) >> v106);
    v94 = (v105 & v101) >> v106;
    v109 = (v104 & v102) >> v106;
    goto LABEL_137;
  }
  if (v61 == 2)
  {
    v110 = SBYTE2(v59);
    if (v7)
    {
      v111 = (unint64_t)HIWORD(v59) << 56;
      v112 = v38 + (v111 >> 24);
      v113 = v7 & (v112 >> 63);
      if (v113 + v112 >= v7)
        v114 = v7;
      else
        v114 = 0;
      v110 = (v113 + (v111 >> 24) - v114) >> 32;
    }
    v115 = (unint64_t *)(v50 + 8 * v110);
    if (v19 < (unint64_t)v115)
      v115 = (unint64_t *)v19;
    if (v115 < (unint64_t *)v51)
      v115 = (unint64_t *)v51;
    v116 = *v115;
    v117 = 0xFFFF;
    if (v10)
    {
      v118 = (unsigned __int16 *)(v53 + 2 * v110);
      if (v18 < (unint64_t)v118)
        v118 = (unsigned __int16 *)v18;
      if ((unint64_t)v118 < *(_QWORD *)(result + 40))
        v118 = *(unsigned __int16 **)(result + 40);
      v117 = *v118;
    }
    v119 = (v59 >> 28) & 3;
    v120 = (char *)&interpolate_cmyk64 + 16 * v119;
    v121 = *(_QWORD *)v120;
    LOBYTE(v119) = v119 + 1;
    v107 = v58 - ((*(_QWORD *)v120 & (unint64_t)v58) >> v119);
    LODWORD(v120) = *((unsigned __int16 *)v120 + 4);
    v108 = v56 - ((v120 & v56) >> v119);
    v94 = (v121 & v116) >> v119;
    v109 = (v120 & v117) >> v119;
LABEL_137:
    v58 = v107 + v94;
    LOWORD(v94) = v108 + v109;
    goto LABEL_138;
  }
  if (v61 != 3)
  {
LABEL_63:
    v60 = a4;
    goto LABEL_139;
  }
  v145 = HIBYTE(v59) & 3;
  LODWORD(v64) = SBYTE1(v59);
  v65 = SBYTE2(v59);
  if (v7)
  {
    v66 = v62 << 56;
    v143 = (unint64_t)HIWORD(v59) << 56;
    v67 = v28 + ((uint64_t)SBYTE1(v59) << 32);
    v68 = v38 + (v143 >> 24);
    v69 = v8 & (v67 >> 63);
    v70 = v7 & (v68 >> 63);
    v71 = v70 + v68;
    if (v69 + v67 >= v8)
      v72 = v8;
    else
      v72 = 0;
    if (v71 >= v7)
      v73 = v7;
    else
      v73 = 0;
    v64 = (v69 + (v66 >> 24) - v72) >> 32;
    v65 = (v70 + (v143 >> 24) - v73) >> 32;
  }
  v74 = (unint64_t *)(v50 + 8 * v65);
  if (v19 < (unint64_t)v74)
    v74 = (unint64_t *)v19;
  if (v74 < (unint64_t *)v51)
    v74 = (unint64_t *)v51;
  v144 = *v74;
  v75 = v64;
  v76 = v50 + (int)v64 * (uint64_t)v5;
  if (v19 >= v76)
    v77 = (unint64_t *)(v50 + (int)v64 * (uint64_t)v5);
  else
    v77 = (unint64_t *)v19;
  if (v77 < (unint64_t *)v51)
    v77 = (unint64_t *)v51;
  v78 = (unint64_t *)(v76 + 8 * v65);
  if (v19 < (unint64_t)v78)
    v78 = (unint64_t *)v19;
  if (v78 < (unint64_t *)v51)
    v78 = (unint64_t *)v51;
  v141 = *v78;
  v142 = *v77;
  v79 = 0xFFFF;
  v80 = 0xFFFF;
  v81 = 0xFFFF;
  if (v10)
  {
    v82 = (unsigned __int16 *)(v53 + 2 * v65);
    v83 = *(_QWORD *)(result + 40);
    if (v18 < (unint64_t)v82)
      v82 = (unsigned __int16 *)v18;
    if ((unint64_t)v82 < v83)
      v82 = *(unsigned __int16 **)(result + 40);
    v79 = *v82;
    v84 = v53 + v75 * (uint64_t)v154;
    if (v18 >= v84)
      v85 = (unsigned __int16 *)(v53 + v75 * (uint64_t)v154);
    else
      v85 = (unsigned __int16 *)v18;
    if ((unint64_t)v85 < v83)
      v85 = *(unsigned __int16 **)(result + 40);
    v80 = *v85;
    v86 = (unsigned __int16 *)(v84 + 2 * v65);
    if (v18 < (unint64_t)v86)
      v86 = (unsigned __int16 *)v18;
    if ((unint64_t)v86 < v83)
      v86 = *(unsigned __int16 **)(result + 40);
    v81 = *v86;
  }
  v140 = v81;
  v87 = (char *)&interpolate_cmyk64 + 16 * v145;
  v88 = *(_QWORD *)v87;
  v89 = v58 - ((*(_QWORD *)v87 & (unint64_t)v58) >> (v145 + 1));
  LODWORD(v87) = *((unsigned __int16 *)v87 + 4);
  v90 = v79 - ((v87 & v79) >> (v145 + 1));
  v91 = v56 - ((v87 & v56) >> (v145 + 1)) + ((v87 & v80) >> (v145 + 1));
  v92 = v90 + ((v87 & v140) >> (v145 + 1));
  LODWORD(v87) = (v59 >> 28) & 3;
  v93 = (char *)&interpolate_cmyk64 + 16 * v87;
  LOBYTE(v87) = (_BYTE)v87 + 1;
  v58 = v89
      + ((v88 & v142) >> (v145 + 1))
      - (((v89 + ((v88 & v142) >> (v145 + 1))) & *(_QWORD *)v93) >> (char)v87)
      + (((v144 - ((v88 & v144) >> (v145 + 1)) + ((v88 & v141) >> (v145 + 1))) & *(_QWORD *)v93) >> (char)v87);
  LODWORD(v94) = v91
               - ((unsigned __int16)(v91 & *((_WORD *)v93 + 4)) >> (char)v87)
               + ((unsigned __int16)(v92 & *((_WORD *)v93 + 4)) >> (char)v87);
LABEL_138:
  v56 = (unsigned __int16)v94;
  v60 = a4;
  v30 = v146;
LABEL_139:
  *(_QWORD *)(v14 + 16) = v58;
  *(_QWORD *)(v14 + 24) = v56;
  *(_BYTE *)(v15 + 1) = v30 >> 22;
  if (v60 != 1)
  {
    v122 = v60;
    v123 = 0;
    v124 = (uint64_t *)(v14 + 40);
    v125 = v60 - 1;
    a2 += v6;
    v126 = v151 - a2;
    a3 += v12;
    v127 = v149 - a3;
    while (((v127 | v126 | (a3 - v150) | (a2 - v148)) & 0x8000000000000000) == 0)
    {
      if (v7)
      {
        v128 = (v8 & ((v28 + v152) >> 63)) + v28 + v152;
        v129 = (v7 & ((v38 + v153) >> 63)) + v38 + v153;
        if (v128 >= v8)
          v130 = v8;
        else
          v130 = 0;
        v131 = v128 - v130;
        if (v129 >= v7)
          v132 = v7;
        else
          v132 = 0;
        v133 = v129 - v132;
        v38 = v133;
        v28 = v131;
      }
      else
      {
        v133 = a2;
        v131 = a3;
      }
      v134 = v131 >> 32;
      v135 = v133 >> 32;
      v50 = v11 + SHIDWORD(v131) * (uint64_t)v5 + 8 * (v133 >> 32);
      v51 = *(uint64_t **)(result + 32);
      if (v19 >= v50)
        v136 = (uint64_t *)v50;
      else
        v136 = (uint64_t *)v19;
      if (v136 < v51)
        v136 = *(uint64_t **)(result + 32);
      if (v10)
      {
        v53 = v10 + (int)v134 * (uint64_t)v154 + 2 * v135;
        v137 = *(unsigned __int16 **)(result + 40);
        if (v18 >= v53)
          v138 = (unsigned __int16 *)v53;
        else
          v138 = (unsigned __int16 *)v18;
        if (v138 >= v137)
          v137 = v138;
        v56 = *v137;
      }
      else
      {
        v56 = 0xFFFFLL;
      }
      v58 = *v136;
      if (v9)
      {
        v59 = *(_DWORD *)(v9 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v59 & 0xF) != 0)
        {
          v15 += v123 + 1;
          v14 = (uint64_t)(v124 - 3);
          a4 = ~(_DWORD)v123 + v122;
          v30 = -1;
          goto LABEL_65;
        }
      }
      *(v124 - 1) = v58;
      *v124 = v56;
      v139 = v15 + v123++;
      v124 += 2;
      a2 += v6;
      *(_BYTE *)(v139 + 2) = -1;
      v126 -= v6;
      a3 += v12;
      v127 -= v12;
      if (v125 == (_DWORD)v123)
        return result;
    }
    v15 += v123 + 1;
    v14 = (uint64_t)(v124 - 3);
    v57 = ~(_DWORD)v123 + v122;
    goto LABEL_58;
  }
  return result;
}

