int *resample_float_h_4cpp_ap(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  int v16;
  int *v17;
  int v18;
  float *v19;
  uint64_t v20;
  float32x4_t *v21;
  __int32 *v22;
  float32x4_t v23;
  float v24;
  float v25;
  float v26;
  float32x4_t v27;
  float32x4_t v28;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = a6[1];
    v11 = *a7;
    v12 = a7[1];
    v13 = 4 * a2 + 8;
    v14 = a8;
    do
    {
      if (a4)
      {
        v15 = *(float32x4_t **)(a5 + 8 * v8);
        v16 = a4;
        v17 = result;
        do
        {
          v18 = v17[1];
          if (v18)
          {
            v19 = (float *)(v17 + 2);
            v20 = *v17;
            v21 = (float32x4_t *)(v9 + v8 * v11 + 16 * v20);
            v22 = (__int32 *)(v10 + v8 * v12 + 4 * v20);
            v23 = 0uLL;
            v24 = 0.0;
            do
            {
              v25 = *v19++;
              v26 = v25;
              v27 = *v21++;
              v28 = v27;
              v27.i32[0] = *v22++;
              v23 = vmlaq_n_f32(v23, v28, v26);
              v24 = v24 + (float)(v27.f32[0] * v26);
              --v18;
            }
            while (v18);
          }
          else
          {
            v23 = 0uLL;
            v24 = 0.0;
          }
          *v15 = v23;
          v15[1].f32[0] = v24;
          v15 = (float32x4_t *)((char *)v15 + 20);
          v17 = (int *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

_DWORD *resample_float_h_Ncpp_ap(_DWORD *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float *v17;
  int v18;
  _DWORD *v19;
  int v20;
  int v21;
  float *v22;
  int v23;
  float v24;
  float *v25;
  float *v26;
  int v27;
  float v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = a3;
    v10 = a3 - 1;
    v11 = *a6;
    v12 = a6[1];
    v13 = *a7;
    v14 = a7[1];
    v15 = a8;
    v16 = 4 * a3 - 4;
    do
    {
      if (a4)
      {
        v17 = *(float **)(a5 + 8 * v8);
        v18 = a4;
        v19 = result;
        do
        {
          v21 = *v19;
          v20 = v19[1];
          v22 = (float *)(v19 + 2);
          if (v9 >= 2)
          {
            v23 = 0;
            do
            {
              v24 = 0.0;
              if (v20)
              {
                v25 = (float *)(v11 + v8 * v13 + 4 * v21 * v10);
                v26 = (float *)(v19 + 2);
                v27 = v20;
                do
                {
                  v28 = *v26++;
                  v24 = v24 + (float)(*v25 * v28);
                  v25 = (float *)((char *)v25 + v16);
                  --v27;
                }
                while (v27);
              }
              *v17++ = v24;
              ++v23;
            }
            while (v23 != v10);
          }
          if (v20)
          {
            v29 = (float *)(v12 + v8 * v14 + 4 + 4 * (v21 - 1));
            v30 = 0.0;
            do
            {
              v31 = *v22++;
              v32 = v31;
              v33 = *v29++;
              v30 = v30 + (float)(v33 * v32);
              --v20;
            }
            while (v20);
          }
          else
          {
            v30 = 0.0;
          }
          *v17++ = v30;
          v19 += a2 + 2;
          --v18;
        }
        while (v18);
      }
      ++v8;
    }
    while (v8 != v15);
  }
  return result;
}

float *resample_float_h_1cpp_ap(float *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  int v16;
  float *v17;
  uint64_t v18;
  float v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  unsigned int v30;
  float *v31;
  float *v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  float v37;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = a6[1];
    v11 = *a7;
    v12 = a7[1];
    v13 = 4 * a2 + 8;
    v14 = a8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == v14)
        return result;
    }
    v15 = *(float **)(a5 + 8 * v8);
    v16 = a4;
    v17 = result;
    while (1)
    {
      v18 = (uint64_t)(v17 + 2);
      v19 = v17[2];
      v20 = *((_DWORD *)v17 + 1);
      v21 = 4 * *(int *)v17 - 4;
      v22 = v9 + v8 * v11 + v21;
      v23 = v10 + v8 * v12 + v21;
      if (v20 >= 2)
        break;
      v26 = 0.0;
      v25 = 0.0;
      if (v20)
        goto LABEL_11;
LABEL_13:
      *v15 = v26;
      v15[1] = v25;
      v15 += 2;
      v17 = (float *)((char *)v17 + v13);
      if (!--v16)
        goto LABEL_14;
    }
    v24 = 0;
    v25 = 0.0;
    v26 = 0.0;
    do
    {
      v27 = v26 + (float)(*(float *)(v22 + v24 + 4) * v19);
      v28 = v25 + (float)(*(float *)(v23 + v24 + 4) * v19);
      v29 = v17[v24 / 4 + 3];
      v19 = v17[v24 / 4 + 4];
      v26 = v27 + (float)(*(float *)(v22 + v24 + 8) * v29);
      v30 = v20;
      v20 -= 2;
      v25 = v28 + (float)(*(float *)(v23 + v24 + 8) * v29);
      v24 += 8;
    }
    while (v30 > 3);
    v23 += v24;
    v22 += v24;
    v18 = (uint64_t)&v17[v24 / 4 + 2];
    if (!v20)
      goto LABEL_13;
LABEL_11:
    v31 = (float *)(v23 + 4);
    v32 = (float *)(v22 + 4);
    v33 = (float *)(v18 + 4);
    do
    {
      v34 = *v32++;
      v35 = v34;
      v36 = *v31++;
      v26 = v26 + (float)(v35 * v19);
      v25 = v25 + (float)(v36 * v19);
      v37 = *v33++;
      v19 = v37;
      --v20;
    }
    while (v20);
    goto LABEL_13;
  }
  return result;
}

uint64_t resample_float_v_Ncpp(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float32x4_t **a5, uint64_t *a6)
{
  float32x4_t *v6;
  int v7;
  float *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t i;
  float32x4_t v12;
  uint64_t *v13;
  float *v14;
  int v15;
  float v16;
  float v17;
  uint64_t v18;
  float v19;
  uint64_t *v20;
  float *v21;
  int v22;
  float v23;
  float v24;
  uint64_t v25;

  v6 = *a5;
  v7 = *(_DWORD *)(result + 4);
  v8 = (float *)(result + 8);
  v9 = a3 * a4;
  v10 = v9 & 0xFFFFFFFC;
  if ((int)v10 < 1)
  {
    LODWORD(i) = 0;
  }
  else
  {
    for (i = 0; i < v10; i += 4)
    {
      v12 = 0uLL;
      if (v7)
      {
        v13 = a6;
        v14 = v8;
        v15 = v7;
        do
        {
          v16 = *v14++;
          v17 = v16;
          v18 = *v13++;
          result = 4 * i;
          v12 = vmlaq_n_f32(v12, *(float32x4_t *)(v18 + 4 * i), v17);
          --v15;
        }
        while (v15);
      }
      *v6++ = v12;
    }
  }
  if ((int)i < (int)v9)
  {
    i = i;
    do
    {
      v19 = 0.0;
      if (v7)
      {
        v20 = a6;
        v21 = v8;
        v22 = v7;
        do
        {
          v23 = *v21++;
          v24 = v23;
          v25 = *v20++;
          v19 = v19 + (float)(*(float *)(v25 + 4 * i) * v24);
          --v22;
        }
        while (v22);
      }
      v6->f32[0] = v19;
      v6 = (float32x4_t *)((char *)v6 + 4);
      ++i;
    }
    while (i != v9);
  }
  return result;
}

uint64_t resample_float_v_3cpp_af(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float **a5, uint64_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  int v8;
  float *v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t *v15;
  float *v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;

  v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    v7 = 0;
    v8 = *(_DWORD *)(result + 4);
    v9 = (float *)(result + 8);
    v10 = *a5;
    do
    {
      v11 = 0.0;
      v12 = 0.0;
      v13 = 0.0;
      v14 = 0.0;
      if (v8)
      {
        v15 = a6;
        v16 = v9;
        LODWORD(result) = v8;
        do
        {
          v17 = *v16++;
          v18 = v17;
          v19 = *v15++;
          v11 = v11 + (float)(*(float *)(v19 + 4 * v7) * v18);
          v12 = v12 + (float)(*(float *)(v19 + 4 * (v7 | 1)) * v18);
          v13 = v13 + (float)(*(float *)(v19 + 4 * (v7 | 2)) * v18);
          v14 = v14 + (float)(*(float *)(v19 + 4 * (v7 | 3)) * v18);
          result = (result - 1);
        }
        while ((_DWORD)result);
      }
      if (v12 > v11)
        v11 = v12;
      if (v13 > v11)
        v11 = v13;
      if (v14 > v11)
        v11 = v14;
      if (v11 >= 0.0)
        v20 = v11;
      else
        v20 = 0.0;
      if (v11 <= 1.0)
        v21 = v20;
      else
        v21 = 1.0;
      *v10 = v21;
      v10[1] = v12;
      v10[2] = v13;
      v10[3] = v14;
      v10 += 4;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float_v_Ncpp_af(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, _QWORD *a5, uint64_t *a6)
{
  float *v6;
  int v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  float v13;
  unsigned int v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t *v20;
  float *v21;
  int v22;
  float v23;
  float v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t *v35;
  float *v36;
  float v37;
  float v38;
  uint64_t v39;
  float v40;
  float v41;

  v6 = (float *)(*a5 - 4);
  v7 = *(_DWORD *)(result + 4);
  v8 = (float *)(result + 8);
  v9 = 2 - a3;
  v10 = a3 * a4;
  v11 = v10 & 0xFFFFFFFC;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
    v13 = 0.0;
    v14 = a3;
  }
  else
  {
    v12 = 0;
    v13 = 0.0;
    v14 = a3;
    do
    {
      v15 = v12 | 1;
      v16 = 0.0;
      v17 = 0.0;
      v18 = 0.0;
      v19 = 0.0;
      if (v7)
      {
        v20 = a6;
        v21 = v8;
        v22 = v7;
        do
        {
          v23 = *v21++;
          v24 = v23;
          v25 = *v20++;
          v16 = v16 + (float)(*(float *)(v25 + 4 * v12) * v24);
          v17 = v17 + (float)(*(float *)(v25 + 4 * v15) * v24);
          v18 = v18 + (float)(*(float *)(v25 + 4 * (v12 | 2)) * v24);
          v19 = v19 + (float)(*(float *)(v25 + 4 * (v12 | 3)) * v24);
          --v22;
        }
        while (v22);
      }
      if (v13 < v16)
        v13 = v16;
      if (v15 == v14)
      {
        v26 = 0.0;
        if (v13 >= 0.0)
          v26 = v13;
        if (v13 <= 1.0)
          v27 = v26;
        else
          v27 = 1.0;
        v6[(int)v9] = v27;
        result = v14 + a3;
        v14 += a3;
        v13 = 0.0;
      }
      else
      {
        result = v14;
      }
      v6[1] = v16;
      if (v13 < v17)
        v13 = v17;
      if ((v12 | 2) == result)
      {
        v28 = 0.0;
        if (v13 >= 0.0)
          v28 = v13;
        if (v13 <= 1.0)
          v29 = v28;
        else
          v29 = 1.0;
        v6[(int)v9 + 1] = v29;
        result = v14 + a3;
        v14 += a3;
        v13 = 0.0;
      }
      v6[2] = v17;
      if (v13 < v18)
        v13 = v18;
      if ((v12 | 3) == result)
      {
        v30 = 0.0;
        if (v13 >= 0.0)
          v30 = v13;
        if (v13 <= 1.0)
          v31 = v30;
        else
          v31 = 1.0;
        v6[(int)v9 + 2] = v31;
        result = v14 + a3;
        v14 += a3;
        v13 = 0.0;
      }
      v6[3] = v18;
      if (v13 < v19)
        v13 = v19;
      v12 += 4;
      if (v12 == result)
      {
        v32 = 0.0;
        if (v13 >= 0.0)
          v32 = v13;
        if (v13 <= 1.0)
          v33 = v32;
        else
          v33 = 1.0;
        v6[(int)v9 + 3] = v33;
        v14 += a3;
        v13 = 0.0;
      }
      v6[4] = v19;
      v6 += 4;
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    v12 = v12;
    do
    {
      v34 = 0.0;
      if (v7)
      {
        v35 = a6;
        v36 = v8;
        LODWORD(result) = v7;
        do
        {
          v37 = *v36++;
          v38 = v37;
          v39 = *v35++;
          v34 = v34 + (float)(*(float *)(v39 + 4 * v12) * v38);
          result = (result - 1);
        }
        while ((_DWORD)result);
      }
      if (v13 < v34)
        v13 = v34;
      if (++v12 == v14)
      {
        v40 = 0.0;
        if (v13 >= 0.0)
          v40 = v13;
        if (v13 <= 1.0)
          v41 = v40;
        else
          v41 = 1.0;
        v6[v9] = v41;
        v14 += a3;
        v13 = 0.0;
      }
      v6[1] = v34;
      ++v6;
    }
    while (v12 != v10);
  }
  return result;
}

uint64_t resample_float_v_3cpp_al(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, float **a5, uint64_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  int v8;
  float *v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t *v15;
  float *v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;

  v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    v7 = 0;
    v8 = *(_DWORD *)(result + 4);
    v9 = (float *)(result + 8);
    v10 = *a5;
    do
    {
      v11 = 0.0;
      v12 = 0.0;
      v13 = 0.0;
      v14 = 0.0;
      if (v8)
      {
        v15 = a6;
        v16 = v9;
        LODWORD(result) = v8;
        do
        {
          v17 = *v16++;
          v18 = v17;
          v19 = *v15++;
          v11 = v11 + (float)(*(float *)(v19 + 4 * v7) * v18);
          v12 = v12 + (float)(*(float *)(v19 + 4 * (v7 | 1)) * v18);
          v13 = v13 + (float)(*(float *)(v19 + 4 * (v7 | 2)) * v18);
          v14 = v14 + (float)(*(float *)(v19 + 4 * (v7 | 3)) * v18);
          result = (result - 1);
        }
        while ((_DWORD)result);
      }
      if (v11 > v14)
        v14 = v11;
      if (v12 > v14)
        v14 = v12;
      if (v13 > v14)
        v14 = v13;
      *v10 = v11;
      v10[1] = v12;
      if (v14 >= 0.0)
        v20 = v14;
      else
        v20 = 0.0;
      if (v14 > 1.0)
        v20 = 1.0;
      v10[2] = v13;
      v10[3] = v20;
      v10 += 4;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float_v_Ncpp_al(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, _QWORD *a5, uint64_t *a6)
{
  float *v6;
  int v7;
  float *v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  float v13;
  unsigned int v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t *v20;
  float *v21;
  int v22;
  float v23;
  float v24;
  uint64_t v25;
  float v26;
  BOOL v27;
  uint64_t v28;
  float v29;
  float v30;
  float v31;
  uint64_t *v32;
  float *v33;
  int v34;
  float v35;
  float v36;
  uint64_t v37;

  v6 = (float *)(*a5 - 4);
  v7 = *(_DWORD *)(result + 4);
  v8 = (float *)(result + 8);
  v9 = a3;
  v10 = a3 * a4;
  v11 = v10 & 0xFFFFFFFC;
  if ((int)v11 < 1)
  {
    LODWORD(v12) = 0;
    v13 = 0.0;
    v14 = a3;
  }
  else
  {
    v12 = 0;
    v13 = 0.0;
    v14 = a3;
    do
    {
      v15 = v12 | 1;
      v16 = 0.0;
      v17 = 0.0;
      v18 = 0.0;
      v19 = 0.0;
      if (v7)
      {
        v20 = a6;
        v21 = v8;
        v22 = v7;
        do
        {
          v23 = *v21++;
          v24 = v23;
          v25 = *v20++;
          v16 = v16 + (float)(*(float *)(v25 + 4 * v12) * v24);
          v17 = v17 + (float)(*(float *)(v25 + 4 * v15) * v24);
          v18 = v18 + (float)(*(float *)(v25 + 4 * (v12 | 2)) * v24);
          v19 = v19 + (float)(*(float *)(v25 + 4 * (v12 | 3)) * v24);
          --v22;
        }
        while (v22);
      }
      if (v13 < v16)
        v13 = v16;
      if (v13 >= 0.0)
        v26 = v13;
      else
        v26 = 0.0;
      if (v13 > 1.0)
        v26 = 1.0;
      v27 = v15 == v14;
      if (v15 == v14)
        v28 = v14 + v9;
      else
        v28 = v14;
      if (v27)
        v14 += v9;
      if (v27)
        v13 = 0.0;
      if (v27)
        v16 = v26;
      if (v13 < v17)
        v13 = v17;
      if (v13 >= 0.0)
        v29 = v13;
      else
        v29 = 0.0;
      if (v13 > 1.0)
        v29 = 1.0;
      if ((v12 | 2) == v28)
      {
        v28 = v14 + v9;
        v14 += v9;
        v13 = 0.0;
        v17 = v29;
      }
      v6[1] = v16;
      v6[2] = v17;
      if (v13 < v18)
        v13 = v18;
      if (v13 >= 0.0)
        v30 = v13;
      else
        v30 = 0.0;
      if (v13 > 1.0)
        v30 = 1.0;
      result = v14 + v9;
      if ((v12 | 3) == v28)
      {
        v28 = v14 + v9;
        v14 += v9;
        v13 = 0.0;
        v18 = v30;
      }
      v6[3] = v18;
      if (v13 < v19)
        v13 = v19;
      v12 += 4;
      if (v12 == v28)
      {
        v19 = 0.0;
        if (v13 >= 0.0)
          v19 = v13;
        if (v13 > 1.0)
          v19 = 1.0;
        v14 += v9;
        v13 = 0.0;
      }
      v6[4] = v19;
      v6 += 4;
    }
    while (v12 < v11);
  }
  if ((int)v12 < (int)v10)
  {
    v12 = v12;
    do
    {
      v31 = 0.0;
      if (v7)
      {
        v32 = a6;
        v33 = v8;
        v34 = v7;
        do
        {
          v35 = *v33++;
          v36 = v35;
          v37 = *v32++;
          result = v37;
          v31 = v31 + (float)(*(float *)(v37 + 4 * v12) * v36);
          --v34;
        }
        while (v34);
      }
      if (v13 < v31)
        v13 = v31;
      if (++v12 == v14)
      {
        v31 = 0.0;
        if (v13 >= 0.0)
          v31 = v13;
        if (v13 > 1.0)
          v31 = 1.0;
        v14 += v9;
        v13 = 0.0;
      }
      v6[1] = v31;
      ++v6;
    }
    while (v12 != v10);
  }
  return result;
}

int *resample_float_h_4cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x4_t *v12;
  int v13;
  int *v14;
  int v15;
  float *v16;
  float32x4_t *v17;
  float32x4_t v18;
  float v19;
  float v20;
  float32x4_t v21;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = *a7;
    v11 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        v12 = *(float32x4_t **)(a5 + 8 * v8);
        v13 = a4;
        v14 = result;
        do
        {
          v15 = v14[1];
          if (v15)
          {
            v16 = (float *)(v14 + 2);
            v17 = (float32x4_t *)(v9 + v8 * v10 + 16 * *v14);
            v18 = 0uLL;
            do
            {
              v19 = *v16++;
              v20 = v19;
              v21 = *v17++;
              v18 = vmlaq_n_f32(v18, v21, v20);
              --v15;
            }
            while (v15);
          }
          else
          {
            v18 = 0uLL;
          }
          *v12++ = v18;
          v14 = (int *)((char *)v14 + v11);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

_DWORD *resample_float_h_3cpp_ap(_DWORD *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x4_t *v15;
  int v16;
  _DWORD *v17;
  int v18;
  float *v19;
  uint64_t v20;
  __int32 *v21;
  float32x4_t v22;
  float v23;
  float v24;
  float32x4_t v25;
  __int32 v26;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = a6[1];
    v11 = *a7;
    v12 = a7[1];
    v13 = 4 * a2 + 8;
    v14 = a8;
    do
    {
      if (a4)
      {
        v15 = *(float32x4_t **)(a5 + 8 * v8);
        v16 = a4;
        v17 = result;
        do
        {
          v18 = v17[1];
          if (v18)
          {
            v19 = (float *)(v17 + 2);
            v20 = v9 + v8 * v11 + 12 * *v17;
            v21 = (__int32 *)(v10 + v8 * v12 + 4 + 4 * (*v17 - 1));
            v22 = 0uLL;
            do
            {
              v23 = *v19++;
              v24 = v23;
              v25.i64[0] = *(_QWORD *)v20;
              v26 = *v21++;
              v25.i32[2] = *(_DWORD *)(v20 + 8);
              v25.i32[3] = v26;
              v22 = vmlaq_n_f32(v22, v25, v24);
              v20 += 12;
              --v18;
            }
            while (v18);
          }
          else
          {
            v22 = 0uLL;
          }
          *v15++ = v22;
          v17 = (_DWORD *)((char *)v17 + v13);
          --v16;
        }
        while (v16);
      }
      ++v8;
    }
    while (v8 != v14);
  }
  return result;
}

_DWORD *resample_float_h_Ncpp(_DWORD *result, unsigned int a2, unsigned __int8 a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  float v20;
  float *v21;
  float *v22;
  int v23;
  float v24;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = a3;
    v10 = *a6;
    v11 = *a7;
    v12 = 4 * a2 + 8;
    v13 = a8;
    do
    {
      if (a4)
      {
        v14 = *(float **)(a5 + 8 * v8);
        v15 = a4;
        v16 = result;
        do
        {
          if ((_DWORD)v9)
          {
            v17 = 0;
            v18 = v16[1];
            v19 = v10 + v8 * v11 + 4 * *v16 * (int)v9;
            do
            {
              v20 = 0.0;
              if (v18)
              {
                v21 = (float *)v19;
                v22 = (float *)(v16 + 2);
                v23 = v18;
                do
                {
                  v24 = *v22++;
                  v20 = v20 + (float)(*v21 * v24);
                  v21 += v9;
                  --v23;
                }
                while (v23);
              }
              *v14++ = v20;
              ++v17;
              v19 += 4;
            }
            while (v17 != v9);
          }
          v16 = (_DWORD *)((char *)v16 + v12);
          --v15;
        }
        while (v15);
      }
      ++v8;
    }
    while (v8 != v13);
  }
  return result;
}

int *resample_float_h_1cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  int v13;
  int *v14;
  int v15;
  int *v16;
  float v17;
  uint64_t v18;
  float *v19;
  float v20;
  unsigned int v21;
  float v22;
  float v23;
  float *v24;
  float *v25;
  float v26;
  float v27;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = *a7;
    v11 = 4 * a2 + 8;
    while (!a4)
    {
LABEL_14:
      if (++v8 == a8)
        return result;
    }
    v12 = *(float **)(a5 + 8 * v8);
    v13 = a4;
    v14 = result;
    while (1)
    {
      v15 = v14[1];
      v16 = v14 + 2;
      v17 = *((float *)v14 + 2);
      v18 = v9 + v8 * v10 + 4 * *v14 - 4;
      if (v15 >= 4)
        break;
      v20 = 0.0;
      if (v15)
        goto LABEL_11;
LABEL_13:
      *v12++ = v20;
      v14 = (int *)((char *)v14 + v11);
      if (!--v13)
        goto LABEL_14;
    }
    v19 = (float *)(v14 + 6);
    v20 = 0.0;
    do
    {
      v21 = v15;
      v22 = *(float *)(v18 + 16);
      v18 += 16;
      v15 -= 4;
      v20 = (float)((float)((float)(v20 + (float)(*(float *)(v18 - 12) * v17))
                          + (float)(*(float *)(v18 - 8) * *(v19 - 3)))
                  + (float)(*(float *)(v18 - 4) * *(v19 - 2)))
          + (float)(v22 * *(v19 - 1));
      v23 = *v19;
      v19 += 4;
      v17 = v23;
    }
    while (v21 > 7);
    v16 = (int *)(v19 - 4);
    if (!v15)
      goto LABEL_13;
LABEL_11:
    v24 = (float *)(v18 + 4);
    v25 = (float *)(v16 + 1);
    do
    {
      v26 = *v24++;
      v20 = v20 + (float)(v26 * v17);
      v27 = *v25++;
      v17 = v27;
      --v15;
    }
    while (v15);
    goto LABEL_13;
  }
  return result;
}

int *resample_float_h_3cpp(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t *v12;
  int v13;
  int *v14;
  int v15;
  float *v16;
  float32x2_t *v17;
  float32x2_t v18;
  float v19;
  float v20;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = *a6;
    v10 = *a7;
    v11 = 4 * a2 + 8;
    do
    {
      if (a4)
      {
        v12 = *(float32x2_t **)(a5 + 8 * v8);
        v13 = a4;
        v14 = result;
        do
        {
          v15 = v14[1];
          if (v15)
          {
            v16 = (float *)(v14 + 2);
            v17 = (float32x2_t *)(v9 + v8 * v10 + 12 * *v14);
            v18 = 0;
            v19 = 0.0;
            do
            {
              v20 = *v16++;
              v18 = vmla_n_f32(v18, *v17, v20);
              v19 = v19 + (float)(v17[1].f32[0] * v20);
              v17 = (float32x2_t *)((char *)v17 + 12);
              --v15;
            }
            while (v15);
          }
          else
          {
            v18 = 0;
            v19 = 0.0;
          }
          *v12 = v18;
          v12[1].f32[0] = v19;
          v12 = (float32x2_t *)((char *)v12 + 12);
          v14 = (int *)((char *)v14 + v11);
          --v13;
        }
        while (v13);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

void CGSConvertABGR8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  int v16;
  char *v17;
  char v18;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertABGR8888toARGB8888", 111, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertABGR8888toARGB8888", 111, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      v14 = 0;
      v15 = v10 + 3;
      do
      {
        if (a5 >= 1)
        {
          v16 = a5;
          v17 = v15;
          do
          {
            v18 = *(v17 - 2);
            *(v17 - 2) = *v17;
            *v17 = v18;
            v17 += 4;
            --v16;
          }
          while (v16);
        }
        ++v14;
        v15 += v11;
      }
      while (v14 != v9);
    }
  }
  else
  {
    src.data = v13;
    src.height = (int)a6;
    src.width = a5;
    src.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 16909056;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void CGSConvertBGRA8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  uint8x8_t v14;
  uint64_t i;
  __int32 *v16;
  int v17;
  int16x8_t v18;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertBGRA8888toARGB8888", 177, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertBGRA8888toARGB8888", 177, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          v16 = (__int32 *)&v10[i * v11];
          v17 = a5;
          do
          {
            v14.i32[0] = *v16;
            v18 = (int16x8_t)vmovl_u8(v14);
            *(int16x4_t *)v18.i8 = vrev64_s16(*(int16x4_t *)v18.i8);
            v14 = (uint8x8_t)vmovn_s16(v18);
            *v16++ = v14.i32[0];
            --v17;
          }
          while (v17);
        }
      }
    }
  }
  else
  {
    src.data = v13;
    src.height = (int)a6;
    src.width = a5;
    src.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 66051;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void CGSConvertBGRX8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  uint64_t i;
  char *v15;
  int v16;
  char v17;
  char v18;
  char v19;
  uint8_t backgroundColor[4];
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertBGRX8888toARGB8888", 208, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertBGRX8888toARGB8888", 208, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          v15 = &v10[i * v11];
          v16 = a5;
          do
          {
            v17 = *v15;
            v18 = v15[1];
            v19 = v15[2];
            *v15 = -1;
            v15[1] = v19;
            v15[2] = v18;
            v15[3] = v17;
            v15 += 4;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  else
  {
    src.data = v13;
    src.height = (int)a6;
    src.width = a5;
    src.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 66051;
    *(_DWORD *)backgroundColor = -1;
    vImagePermuteChannelsWithMaskedInsert_ARGB8888(&src, &dest, permuteMap, 8u, backgroundColor, 0);
  }
}

void CGSConvertRGBA8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  uint8x8_t v14;
  uint64_t i;
  __int32 *v16;
  int v17;
  int16x8_t v18;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertRGBA8888toARGB8888", 274, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertRGBA8888toARGB8888", 274, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          v16 = (__int32 *)&v10[i * v11];
          v17 = a5;
          do
          {
            v14.i32[0] = *v16;
            v18 = (int16x8_t)vmovl_u8(v14);
            *(int8x8_t *)v18.i8 = vext_s8(*(int8x8_t *)v18.i8, *(int8x8_t *)v18.i8, 6uLL);
            v14 = (uint8x8_t)vmovn_s16(v18);
            *v16++ = v14.i32[0];
            --v17;
          }
          while (v17);
        }
      }
    }
  }
  else
  {
    src.data = v13;
    src.height = (int)a6;
    src.width = a5;
    src.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 33619971;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void CGSConvertRGBX8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  uint64_t i;
  char *v15;
  int v16;
  __int16 v17;
  char v18;
  uint8_t backgroundColor[4];
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertRGBX8888toARGB8888", 305, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertRGBX8888toARGB8888", 305, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          v15 = &v10[i * v11];
          v16 = a5;
          do
          {
            v17 = *(_WORD *)v15;
            v18 = v15[2];
            *v15 = -1;
            *(_WORD *)(v15 + 1) = v17;
            v15[3] = v18;
            v15 += 4;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  else
  {
    src.data = v13;
    src.height = (int)a6;
    src.width = a5;
    src.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 33619971;
    *(_DWORD *)backgroundColor = -1;
    vImagePermuteChannelsWithMaskedInsert_ARGB8888(&src, &dest, permuteMap, 8u, backgroundColor, 0);
  }
}

void CGSConvertXBGR8888toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  int v16;
  char *v17;
  char v18;
  char v19;
  uint8_t backgroundColor[4];
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertXBGR8888toARGB8888", 338, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertXBGR8888toARGB8888", 338, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      v14 = 0;
      v15 = v10 + 3;
      do
      {
        if (a5 >= 1)
        {
          v16 = a5;
          v17 = v15;
          do
          {
            v18 = *(v17 - 2);
            v19 = *v17;
            *(v17 - 3) = -1;
            *(v17 - 2) = v19;
            *v17 = v18;
            v17 += 4;
            --v16;
          }
          while (v16);
        }
        ++v14;
        v15 += v11;
      }
      while (v14 != v9);
    }
  }
  else
  {
    src.data = v13;
    src.height = (int)a6;
    src.width = a5;
    src.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    *(_DWORD *)permuteMap = 16909056;
    *(_DWORD *)backgroundColor = -1;
    vImagePermuteChannelsWithMaskedInsert_ARGB8888(&src, &dest, permuteMap, 8u, backgroundColor, 0);
  }
}

vImage_Error CGSConvertXRGB8888toARGB8888(char *a1, int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  int v9;
  char *v10;
  size_t v11;
  vImage_Buffer dest;
  vImage_Buffer src;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertXRGB8888toARGB8888", 371, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertXRGB8888toARGB8888", 371, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  v8 = &a1[((int)a6 - 1) * (uint64_t)a2];
  if (a4 >= 0)
    v9 = a2;
  else
    v9 = -a2;
  if (a4 >= 0)
    v8 = a1;
  src.data = v8;
  src.height = (int)a6;
  src.width = a5;
  src.rowBytes = v9;
  v10 = &a3[((int)a6 - 1) * a4];
  if (a4 >= 0)
    v10 = a3;
  dest.data = v10;
  dest.height = (int)a6;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  dest.width = a5;
  dest.rowBytes = v11;
  return vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &src, &dest, 8u, 0);
}

void CGSConvertW8toARGB8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  char *v10;
  size_t v11;
  size_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t i;
  char *v17;
  int v18;
  char *v19;
  char v20;
  vImage_Buffer dest;
  vImage_Buffer blue;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertW8toARGB8888", 387, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertW8toARGB8888", 387, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  if (a4 < 0)
    v10 = &a3[((int)a6 - 1) * a4];
  else
    v10 = a3;
  if (a4 >= 0)
    v11 = a4;
  else
    v11 = -a4;
  if (a4 >= 0)
    v12 = a2;
  else
    v12 = -a2;
  if (a4 < 0)
    v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  else
    v13 = a1;
  if ((v12 & 0x80000000) != 0)
  {
    v14 = (char *)malloc_type_malloc((int)v11 * (int)a6, 0x4604072DuLL);
    v15 = v14;
    if (v9 >= 1)
    {
      for (i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          v17 = &v14[i * v11];
          v18 = a5;
          v19 = &v13[i * (int)v12];
          do
          {
            v20 = *v19++;
            *v17 = -1;
            v17[1] = v20;
            v17[2] = v20;
            v17[3] = v20;
            v17 += 4;
            --v18;
          }
          while (v18);
        }
      }
    }
    CGBlt_copyBytes(4 * a5, v9, v14, v10, v11, v11);
    free(v15);
  }
  else
  {
    blue.data = v13;
    blue.height = (int)a6;
    blue.width = a5;
    blue.rowBytes = v12;
    dest.data = v10;
    dest.height = (int)a6;
    dest.width = a5;
    dest.rowBytes = v11;
    vImageConvert_Planar8ToXRGB8888(0xFFu, &blue, &blue, &blue, &dest, 0);
  }
}

void CGSConvertW16toARGB8888(uint64_t a1, int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  int v17;
  uint64_t i;
  char *v19;
  int v20;
  char *v21;
  char v22;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertW16toARGB8888", 552, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertW16toARGB8888", 552, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  v10 = (int)a6 - 1;
  if (a4 < 0)
    v11 = &a3[v10 * a4];
  else
    v11 = a3;
  if (a4 >= 0)
    v12 = a4;
  else
    v12 = -a4;
  if (a4 >= 0)
    v13 = a2;
  else
    v13 = -a2;
  if (a4 < 0)
    v14 = a1 + (int)v10 * (uint64_t)a2;
  else
    v14 = a1;
  v15 = v14 + (int)((v13 * v10) & (v13 >> 31));
  v16 = v11;
  if (v15 <= (unint64_t)&v11[(int)a6 * (uint64_t)(int)v12])
  {
    v17 = v13 >= 0 ? v13 : -v13;
    v16 = v11;
    if (v15 + (int)a6 * (uint64_t)v17 >= (unint64_t)v11)
      v16 = (char *)malloc_type_malloc((int)a6 * (uint64_t)(int)v12, 0x46DC5C89uLL);
  }
  if (v9 >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      if (a5 >= 1)
      {
        v19 = &v16[i * v12];
        v20 = a5;
        v21 = (char *)(v14 + i * v13);
        do
        {
          v22 = *v21;
          v21 += 2;
          *v19 = -1;
          v19[1] = v22;
          v19[2] = v22;
          v19[3] = v22;
          v19 += 4;
          --v20;
        }
        while (v20);
      }
    }
  }
  if (v16 != v11)
  {
    CGBlt_copyBytes(4 * a5, v9, v16, v11, v12, v12);
    free(v16);
  }
}

void CGSConvertw16toARGB8888(uint64_t a1, int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  int v17;
  uint64_t v18;
  char *v19;
  char *v20;
  int v21;
  char *v22;
  char v23;

  if (a5 < 0)
    _CGHandleAssert("CGSConvertw16toARGB8888", 714, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, a5);
  v9 = a6;
  if ((a6 & 0x80000000) != 0)
    _CGHandleAssert("CGSConvertw16toARGB8888", 714, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, a6);
  v10 = (int)a6 - 1;
  if (a4 < 0)
    v11 = &a3[v10 * a4];
  else
    v11 = a3;
  if (a4 >= 0)
    v12 = a4;
  else
    v12 = -a4;
  if (a4 >= 0)
    v13 = a2;
  else
    v13 = -a2;
  if (a4 < 0)
    v14 = a1 + (int)v10 * (uint64_t)a2;
  else
    v14 = a1;
  v15 = v14 + (int)((v13 * v10) & (v13 >> 31));
  v16 = v11;
  if (v15 <= (unint64_t)&v11[(int)a6 * (uint64_t)(int)v12])
  {
    v17 = v13 >= 0 ? v13 : -v13;
    v16 = v11;
    if (v15 + (int)a6 * (uint64_t)v17 >= (unint64_t)v11)
      v16 = (char *)malloc_type_malloc((int)a6 * (uint64_t)(int)v12, 0x262C1751uLL);
  }
  if (v9 >= 1)
  {
    v18 = 0;
    v19 = (char *)(v14 + 1);
    do
    {
      if (a5 >= 1)
      {
        v20 = &v16[v18 * v12];
        v21 = a5;
        v22 = v19;
        do
        {
          v23 = *v22;
          v22 += 2;
          *v20 = -1;
          v20[1] = v23;
          v20[2] = v23;
          v20[3] = v23;
          v20 += 4;
          --v21;
        }
        while (v21);
      }
      ++v18;
      v19 += v13;
    }
    while (v18 != v9);
  }
  if (v16 != v11)
  {
    CGBlt_copyBytes(4 * a5, v9, v16, v11, v12, v12);
    free(v16);
  }
}

char *fill_runs(char *result, _WORD *a2, _WORD *a3, unsigned int a4, int a5)
{
  _WORD *v6;
  _WORD *v7;
  char *v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  char *v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;

  v6 = a3;
  v7 = a2;
  v8 = result;
  if ((((_DWORD)a3 - (_DWORD)a2) & 2) != 0)
  {
    *a3 = 0;
    v6 = a3 + 1;
  }
  if (v6 > a2)
  {
    v9 = 0;
    if (a5)
      v10 = -1;
    else
      v10 = 0;
    do
    {
      v11 = (unsigned __int16)*v7;
      if (v9 + v11 > a4)
      {
        v11 = a4 - v9;
        *v7 = a4 - v9;
      }
      if (!v11)
        goto LABEL_28;
      v12 = &v8[v9 >> 3];
      v13 = 8 - (v9 & 7);
      if (v11 <= v13)
      {
        v16 = (-1 << (8 - v11)) >> (v9 & 7);
        LOBYTE(v15) = v16;
      }
      else
      {
        if ((v9 & 7) != 0)
        {
          *v12 = (-1 << v13) & *v12 | v10 & ~(-1 << v13);
          ++v12;
          v11 -= v13;
        }
        if (v11 >= 8)
        {
          v14 = v11 >> 3;
          switch((int)v14)
          {
            case 1:
              goto LABEL_21;
            case 2:
              goto LABEL_20;
            case 3:
              goto LABEL_19;
            case 4:
              goto LABEL_18;
            case 5:
              goto LABEL_17;
            case 6:
              goto LABEL_16;
            case 7:
              v12[6] = v10;
LABEL_16:
              v12[5] = v10;
LABEL_17:
              v12[4] = v10;
LABEL_18:
              v12[3] = v10;
LABEL_19:
              v12[2] = v10;
LABEL_20:
              v12[1] = v10;
LABEL_21:
              *v12 = v10;
              break;
            default:
              result = (char *)memset(v12, v10, v11 >> 3);
              break;
          }
          v12 += v14;
          v11 &= 7u;
        }
        if (!v11)
          goto LABEL_27;
        v15 = -1 << (8 - v11);
        LOBYTE(v16) = v15 & 0xFE;
      }
      *v12 = *v12 & ~(_BYTE)v16 | v15 & v10;
LABEL_27:
      v9 += (unsigned __int16)*v7;
LABEL_28:
      v10 = ~v10;
      ++v7;
    }
    while (v7 < v6);
  }
  return result;
}

void pdf_error(char *a1, ...)
{
  FILE **v2;
  va_list va;

  va_start(va, a1);
  if (pdf_is_verbose_onceToken[0] != -1)
    dispatch_once(pdf_is_verbose_onceToken, &__block_literal_global_4_5967);
  if (pdf_is_verbose_isVerbose)
  {
    v2 = (FILE **)MEMORY[0x1E0C80C10];
    vfprintf_l((FILE *)*MEMORY[0x1E0C80C10], 0, a1, va);
    fprintf_l(*v2, 0, "\n");
  }
  else if (pdf_error_onceToken != -1)
  {
    dispatch_once(&pdf_error_onceToken, &__block_literal_global_5968);
  }
}

uint64_t __pdf_error_block_invoke()
{
  return fprintf((FILE *)*MEMORY[0x1E0C80C10], "CoreGraphics PDF has logged an error. Set environment variable \"%s\" to learn more.\n", "CG_PDF_VERBOSE");
}

char *__pdf_is_verbose_block_invoke()
{
  char *result;

  result = getenv("CG_PDF_VERBOSE");
  pdf_is_verbose_isVerbose = result != 0;
  return result;
}

void pdf_log(char *a1, ...)
{
  FILE **v2;
  va_list va;

  va_start(va, a1);
  if (pdf_is_verbose_onceToken[0] != -1)
    dispatch_once(pdf_is_verbose_onceToken, &__block_literal_global_4_5967);
  if (pdf_is_verbose_isVerbose)
  {
    v2 = (FILE **)MEMORY[0x1E0C80C10];
    vfprintf_l((FILE *)*MEMORY[0x1E0C80C10], 0, a1, va);
    fprintf_l(*v2, 0, "\n");
  }
}

__int128 *std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(__int128 *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *a2;
  v4 = *a3;
  if (*(_QWORD *)result >= *a2)
  {
    if (v3 < v4)
    {
      v8 = a2[2];
      v9 = *(_OWORD *)a2;
      v10 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v10;
      *(_OWORD *)a3 = v9;
      a3[2] = v8;
      if (*(_QWORD *)result < *a2)
      {
        v11 = *((_QWORD *)result + 2);
        v12 = *result;
        v13 = a2[2];
        *result = *(_OWORD *)a2;
        *((_QWORD *)result + 2) = v13;
        *(_OWORD *)a2 = v12;
        a2[2] = v11;
      }
    }
  }
  else
  {
    if (v3 >= v4)
    {
      v14 = *((_QWORD *)result + 2);
      v15 = *result;
      v16 = a2[2];
      *result = *(_OWORD *)a2;
      *((_QWORD *)result + 2) = v16;
      *(_OWORD *)a2 = v15;
      a2[2] = v14;
      if (*a2 >= *a3)
        return result;
      v5 = a2[2];
      v6 = *(_OWORD *)a2;
      v17 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v17;
    }
    else
    {
      v5 = *((_QWORD *)result + 2);
      v6 = *result;
      v7 = a3[2];
      *result = *(_OWORD *)a3;
      *((_QWORD *)result + 2) = v7;
    }
    *(_OWORD *)a3 = v6;
    a3[2] = v5;
  }
  return result;
}

__n128 std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  __n128 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__int128 *)a1, a2, a3);
  if (*a3 < *(_QWORD *)a4)
  {
    v9 = a3[2];
    result = *(__n128 *)a3;
    v10 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v10;
    *(__n128 *)a4 = result;
    *(_QWORD *)(a4 + 16) = v9;
    if (*a2 < *a3)
    {
      v11 = a2[2];
      result = *(__n128 *)a2;
      v12 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v12;
      *(__n128 *)a3 = result;
      a3[2] = v11;
      if (*(_QWORD *)a1 < *a2)
      {
        v13 = *(_QWORD *)(a1 + 16);
        result = *(__n128 *)a1;
        v14 = a2[2];
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        a2[2] = v13;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(__n128 *a1, uint64_t *a2, uint64_t *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  result.n128_u64[0] = std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((uint64_t)a1, a2, a3, (uint64_t)a4).n128_u64[0];
  if ((int64_t)a4->n128_u64[0] < (int64_t)a5->n128_u64[0])
  {
    v11 = a4[1].n128_u64[0];
    result = *a4;
    v12 = a5[1].n128_u64[0];
    *a4 = *a5;
    a4[1].n128_u64[0] = v12;
    *a5 = result;
    a5[1].n128_u64[0] = v11;
    if (*a3 < (int64_t)a4->n128_u64[0])
    {
      v13 = a3[2];
      result = *(__n128 *)a3;
      v14 = a4[1].n128_i64[0];
      *(__n128 *)a3 = *a4;
      a3[2] = v14;
      *a4 = result;
      a4[1].n128_u64[0] = v13;
      if (*a2 < *a3)
      {
        v15 = a2[2];
        result = *(__n128 *)a2;
        v16 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v16;
        *(__n128 *)a3 = result;
        a3[2] = v15;
        if ((int64_t)a1->n128_u64[0] < *a2)
        {
          v17 = a1[1].n128_i64[0];
          result = *a1;
          v18 = a2[2];
          *a1 = *(__n128 *)a2;
          a1[1].n128_u64[0] = v18;
          *(__n128 *)a2 = result;
          a2[2] = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__int128 *)(a2 - 24);
      if (*(_QWORD *)a1 < *(_QWORD *)(a2 - 24))
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_OWORD *)a1;
        v9 = *(_QWORD *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(_QWORD *)(a1 + 16) = v9;
        *v6 = v8;
        *(_QWORD *)(a2 - 8) = v7;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__int128 *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a2 - 24));
      return 1;
    case 4uLL:
      std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>(a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48), a2 - 24);
      return 1;
    case 5uLL:
      std::__sort5[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__n128 *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48), (__n128 *)(a1 + 72), (__n128 *)(a2 - 24));
      return 1;
    default:
      v10 = (_QWORD *)(a1 + 48);
      std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,ClipperLib::LocMinSorter &,ClipperLib::LocalMinimum *>((__int128 *)a1, (uint64_t *)(a1 + 24), (uint64_t *)(a1 + 48));
      v11 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *(_QWORD *)v11;
    if (*v10 < *(_QWORD *)v11)
    {
      v18 = *(_OWORD *)(v11 + 8);
      v15 = v12;
      while (1)
      {
        v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(_QWORD *)(v16 + 88) = *(_QWORD *)(a1 + v15 + 64);
        if (v15 == -48)
          break;
        v15 -= 24;
        if (*(_QWORD *)(v16 + 24) >= v14)
        {
          v17 = a1 + v15 + 72;
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_QWORD *)v17 = v14;
      *(_OWORD *)(v17 + 8) = v18;
      if (++v13 == 8)
        return v11 + 24 == a2;
    }
    v10 = (_QWORD *)v11;
    v12 += 24;
    v11 += 24;
    if (v11 == a2)
      return 1;
  }
}

unint64_t *ClipperLib::Int128Mul(unint64_t *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (a2 >= 0)
    v3 = a2;
  else
    v3 = -a2;
  if (a3 >= 0)
    v4 = a3;
  else
    v4 = -a3;
  v5 = v4 * (unint64_t)v3;
  v6 = ((HIDWORD(v4) * (unint64_t)v3 + v4 * (unint64_t)HIDWORD(v3)) >> 32)
     + HIDWORD(v4) * (unint64_t)HIDWORD(v3);
  v7 = v4 * v3;
  *this = v7;
  this[1] = v6;
  if (v7 < v5)
    this[1] = ++v6;
  if ((unint64_t)a2 >> 63 != (unint64_t)a3 >> 63)
  {
    v8 = -(uint64_t)v6;
    if (v7)
      v8 = ~v6;
    *this = -(uint64_t)v7;
    this[1] = v8;
  }
  return this;
}

void ClipperLib::clipperException::~clipperException(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)&off_1E1628CA8;
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::exception::~exception(this);
}

{
  ClipperLib::clipperException::~clipperException(this);
  JUMPOUT(0x186DC23C4);
}

uint64_t ClipperLib::clipperException::what(ClipperLib::clipperException *this)
{
  uint64_t result;

  result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

char **ClipperLib::clipperException::clipperException(char **this, char *a2)
{
  *this = (char *)&off_1E1628CA8;
  std::string::basic_string[abi:se180100]<0>(this + 1, a2);
  return this;
}

void sub_184BDEB50(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void `virtual thunk to'ClipperLib::Clipper::~Clipper(ClipperLib::Clipper *this)
{
  _QWORD *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24));
  *v1 = &off_1E1628CD8;
  v1[18] = &unk_1E1628D20;
  std::__list_imp<long long>::clear(v1 + 11);
  v2 = (void *)v1[7];
  if (v2)
  {
    v1[8] = v2;
    operator delete(v2);
  }
  v3 = (void *)v1[4];
  if (v3)
  {
    v1[5] = v3;
    operator delete(v3);
  }
  v4 = (void *)v1[1];
  if (v4)
  {
    v1[2] = v4;
    operator delete(v4);
  }
  ClipperLib::ClipperBase::~ClipperBase((ClipperLib::ClipperBase *)(v1 + 18));
}

{
  _QWORD *v1;
  void *v2;
  void *v3;
  void *v4;

  v1 = (_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24));
  *v1 = &off_1E1628CD8;
  v1[18] = &unk_1E1628D20;
  std::__list_imp<long long>::clear(v1 + 11);
  v2 = (void *)v1[7];
  if (v2)
  {
    v1[8] = v2;
    operator delete(v2);
  }
  v3 = (void *)v1[4];
  if (v3)
  {
    v1[5] = v3;
    operator delete(v3);
  }
  v4 = (void *)v1[1];
  if (v4)
  {
    v1[2] = v4;
    operator delete(v4);
  }
  ClipperLib::ClipperBase::~ClipperBase((ClipperLib::ClipperBase *)(v1 + 18));
  JUMPOUT(0x186DC23C4);
}

uint64_t ClipperLib::PointInPolygon(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  BOOL v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  double v17;

  result = 0;
  v5 = a3;
  while (1)
  {
    v6 = v5;
    v5 = (_QWORD *)v5[7];
    v7 = v5[2];
    if (v7 == a2)
    {
      v8 = v5[1];
      if (v8 == a1)
        return 0xFFFFFFFFLL;
      v9 = v6[2];
      if (v9 == a2)
      {
        if (v8 <= a1 != v6[1] < a1)
          return 0xFFFFFFFFLL;
        goto LABEL_20;
      }
    }
    else
    {
      v9 = v6[2];
    }
    if (v7 < a2 != v9 >= a2)
      goto LABEL_20;
    v10 = v6[1];
    v11 = v5[1];
    v13 = __OFSUB__(v10, a1);
    v12 = v10 - a1 < 0;
    v14 = v10 - a1;
    if (v12 == v13)
      break;
    v13 = __OFSUB__(v11, a1);
    v15 = v11 == a1;
    v12 = v11 - a1 < 0;
    v16 = v11 - a1;
    if (!(v12 ^ v13 | v15))
      goto LABEL_16;
LABEL_20:
    if (v5 == a3)
      return result;
  }
  v13 = __OFSUB__(v11, a1);
  v15 = v11 == a1;
  v12 = v11 - a1 < 0;
  v16 = v11 - a1;
  if (!(v12 ^ v13 | v15))
  {
    result = (1 - result);
    goto LABEL_20;
  }
LABEL_16:
  v17 = (double)v14 * (double)(v7 - a2) - (double)v16 * (double)(v9 - a2);
  if (v17 != 0.0)
  {
    if (v7 > v9 != v17 <= 0.0)
      result = (1 - result);
    else
      result = result;
    goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ClipperLib::Clipper::FixupFirstLefts2(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;

  v20 = *(_QWORD *)result;
  v3 = *(_QWORD *)(*(_QWORD *)result - 24);
  v4 = *(_QWORD *)(result + v3 + 80);
  if (*(_QWORD *)(result + v3 + 88) != v4)
  {
    v7 = result;
    v8 = 0;
    v21 = *(_QWORD *)(a3 + 8);
    do
    {
      v9 = *(_QWORD *)(v4 + 8 * v8);
      v10 = *(uint64_t **)(v9 + 24);
      if (v9 != a2 && v9 != a3 && v10 != 0)
      {
        v13 = *(_QWORD *)(v9 + 8);
        if (v13)
        {
          v14 = *(_QWORD *)(v9 + 8);
          do
          {
            if (*(_QWORD *)(v14 + 24))
              break;
            v14 = *(_QWORD *)(v14 + 8);
          }
          while (v14);
        }
        else
        {
          v14 = 0;
        }
        if (v14 == a3 || v14 == v21 || v14 == a2)
        {
          v15 = *(_QWORD **)(a2 + 24);
          v16 = *(uint64_t **)(v9 + 24);
          while (1)
          {
            result = ClipperLib::PointInPolygon(v16[1], v16[2], v15);
            if ((result & 0x80000000) == 0)
              break;
            v16 = (uint64_t *)v16[7];
            if (v16 == v10)
            {
              v17 = a2;
LABEL_29:
              *(_QWORD *)(v9 + 8) = v17;
              v3 = *(_QWORD *)(v20 - 24);
              goto LABEL_30;
            }
          }
          v17 = a2;
          if ((_DWORD)result)
            goto LABEL_29;
          v18 = *(_QWORD **)(a3 + 24);
          v19 = v10;
          while (1)
          {
            result = ClipperLib::PointInPolygon(v19[1], v19[2], v18);
            if ((result & 0x80000000) == 0)
              break;
            v19 = (uint64_t *)v19[7];
            if (v19 == v10)
            {
              v17 = a3;
              goto LABEL_29;
            }
          }
          v17 = a3;
          if ((_DWORD)result)
            goto LABEL_29;
          v17 = v21;
          if (v13 == a2)
            goto LABEL_29;
          v17 = v21;
          if (v13 == a3)
            goto LABEL_29;
        }
      }
LABEL_30:
      ++v8;
      v4 = *(_QWORD *)(v7 + v3 + 80);
    }
    while (v8 < (*(_QWORD *)(v7 + v3 + 88) - v4) >> 3);
  }
  return result;
}

uint64_t ClipperLib::Clipper::FixupFirstLefts1(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t *v14;

  v3 = *(_QWORD *)result;
  v4 = *(_QWORD *)(*(_QWORD *)result - 24);
  v5 = *(_QWORD *)(result + v4 + 80);
  if (*(_QWORD *)(result + v4 + 88) != v5)
  {
    v8 = result;
    v9 = 0;
    do
    {
      v10 = *(_QWORD *)(v5 + 8 * v9);
      for (i = *(_QWORD *)(v10 + 8); i; i = *(_QWORD *)(i + 8))
      {
        if (*(_QWORD *)(i + 24))
          break;
      }
      if (i == a2)
      {
        v12 = *(uint64_t **)(v10 + 24);
        if (v12)
        {
          v13 = *(_QWORD **)(a3 + 24);
          v14 = *(uint64_t **)(v10 + 24);
          while (1)
          {
            result = ClipperLib::PointInPolygon(v14[1], v14[2], v13);
            if ((result & 0x80000000) == 0)
              break;
            v14 = (uint64_t *)v14[7];
            if (v14 == v12)
              goto LABEL_13;
          }
          if (!(_DWORD)result)
            goto LABEL_14;
LABEL_13:
          *(_QWORD *)(v10 + 8) = a3;
          v4 = *(_QWORD *)(v3 - 24);
        }
      }
LABEL_14:
      ++v9;
      v5 = *(_QWORD *)(v8 + v4 + 80);
    }
    while (v9 < (*(_QWORD *)(v8 + v4 + 88) - v5) >> 3);
  }
  return result;
}

_QWORD *ClipperLib::DisposeOutPts(_QWORD *result)
{
  _QWORD **v1;

  if (*result)
  {
    v1 = (_QWORD **)result;
    *(_QWORD *)(*(_QWORD *)(*result + 64) + 56) = 0;
    while (1)
    {
      result = *v1;
      if (!*v1)
        break;
      *v1 = (_QWORD *)result[7];
      MEMORY[0x186DC23C4]();
    }
  }
  return result;
}

int *ClipperLib::Clipper::GetOutRec(int *this, int a2)
{
  uint64_t v2;
  unint64_t v3;
  int *v4;
  unint64_t v5;

  v2 = *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24) + 80);
  v3 = (*(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 24) + 88) - v2) >> 3;
  if (v3 > a2)
  {
    v4 = *(int **)(v2 + 8 * a2);
    while (1)
    {
      this = v4;
      v5 = *v4;
      if (v3 <= v5)
        break;
      v4 = *(int **)(v2 + 8 * v5);
      if (this == v4)
        return this;
    }
  }
  __break(1u);
  return this;
}

uint64_t ClipperLib::GetLowermostRec(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *BottomPt;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = a1;
  BottomPt = *(_QWORD **)(a1 + 32);
  if (!BottomPt)
  {
    BottomPt = (_QWORD *)ClipperLib::GetBottomPt(*(_QWORD **)(v3 + 24));
    *(_QWORD *)(v3 + 32) = BottomPt;
  }
  v5 = *(_QWORD **)(a2 + 32);
  if (!v5)
  {
    v5 = (_QWORD *)ClipperLib::GetBottomPt(*(_QWORD **)(a2 + 24));
    *(_QWORD *)(a2 + 32) = v5;
    BottomPt = *(_QWORD **)(v3 + 32);
  }
  v6 = BottomPt[2];
  v7 = v5[2];
  if (v6 <= v7)
  {
    if (v6 < v7)
      return a2;
    v8 = BottomPt[1];
    v9 = v5[1];
    if (v8 < v9)
      return v3;
    if (v8 > v9 || (_QWORD *)BottomPt[7] == BottomPt)
    {
      return a2;
    }
    else if ((_QWORD *)v5[7] != v5 && !ClipperLib::FirstIsBottomPt((uint64_t)BottomPt, v5))
    {
      return a2;
    }
  }
  return v3;
}

uint64_t ClipperLib::Clipper::JoinPoints(_QWORD *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  __int128 *v12;
  BOOL v13;
  uint64_t v14;
  _QWORD *v17;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v26;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _BOOL4 v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  _QWORD *v81;
  uint64_t v82;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v87;
  uint64_t v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;
  uint64_t v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  uint64_t v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  int v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v114;
  uint64_t v115;
  uint64_t v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v128;
  __int128 *v129;
  int v130;
  int v133;
  uint64_t v134;
  int v135;
  __int128 v136;
  __int128 v137;

  v5 = (_QWORD *)*a2;
  v6 = a2[1];
  v8 = *a2 + 8;
  v7 = *(_QWORD *)v8;
  v9 = *(_QWORD *)(*a2 + 16);
  v10 = a2[3];
  if (v9 != v10)
  {
    v46 = (uint64_t)(v5 + 7);
    do
    {
      v47 = *(_QWORD **)v46;
      v48 = *(_QWORD *)(*(_QWORD *)v46 + 8);
      v49 = *(_QWORD *)(*(_QWORD *)v46 + 16);
      v46 = *(_QWORD *)v46 + 56;
    }
    while (v47 != v5 && v48 == v7 && v49 == v9);
    if (v49 <= v9
      && (v52 = *((unsigned __int8 *)a1 + *(_QWORD *)(*a1 - 24) + 40),
          v134 = a2[2],
          ClipperLib::SlopesEqual(v7, v9, v48, v49, v134, v10, v52)))
    {
      v130 = 0;
    }
    else
    {
      v47 = v5;
      do
      {
        v47 = (_QWORD *)v47[8];
        v53 = v47[1];
        v54 = v47[2];
      }
      while (v47 != v5 && v53 == v7 && v54 == v9);
      if (v54 > v9)
        return 0;
      v52 = *((unsigned __int8 *)a1 + *(_QWORD *)(*a1 - 24) + 40);
      v134 = a2[2];
      if (!ClipperLib::SlopesEqual(v7, v9, v53, v54, v134, v10, v52))
        return 0;
      v130 = 1;
    }
    v57 = *(_QWORD *)(v6 + 8);
    v58 = v6 + 56;
    v129 = (__int128 *)(v6 + 8);
    v59 = *(_QWORD *)(v6 + 16);
    do
    {
      v60 = *(_QWORD **)v58;
      v61 = *(_QWORD *)(*(_QWORD *)v58 + 8);
      v62 = *(_QWORD *)(*(_QWORD *)v58 + 16);
      v58 = *(_QWORD *)v58 + 56;
    }
    while (v61 == v57 && v62 == v59 && v60 != (_QWORD *)v6);
    if (v62 <= v59 && ClipperLib::SlopesEqual(v57, *(_QWORD *)(v6 + 16), v61, v62, v134, v10, v52 != 0))
    {
      v65 = 0;
    }
    else
    {
      v60 = (_QWORD *)v6;
      do
      {
        v60 = (_QWORD *)v60[8];
        v66 = v60[1];
        v67 = v60[2];
      }
      while (v66 == v57 && v67 == v59 && v60 != (_QWORD *)v6);
      if (v67 > v59 || !ClipperLib::SlopesEqual(v57, v59, v66, v67, v134, v10, v52 != 0))
        return 0;
      v65 = 1;
    }
    v70 = 0;
    if (v47 == v60 || v47 == v5 || v60 == (_QWORD *)v6)
      return v70;
    if (a3 != a4 || v130 != v65)
    {
      v71 = operator new();
      v72 = v71;
      v74 = *(_OWORD *)(v8 + 16);
      v73 = *(_OWORD *)(v8 + 32);
      *(_OWORD *)(v71 + 8) = *(_OWORD *)v8;
      *(_OWORD *)(v71 + 40) = v73;
      *(_OWORD *)(v71 + 24) = v74;
      *(_DWORD *)v71 = *(_DWORD *)v5;
      if (v130)
      {
        v75 = v5[8];
        *(_QWORD *)(v71 + 56) = v5;
        *(_QWORD *)(v71 + 64) = v75;
        *(_QWORD *)(v75 + 56) = v71;
        v5[8] = v71;
        v76 = operator new();
        v77 = *v129;
        v78 = *(_OWORD *)(v6 + 24);
        *(_OWORD *)(v76 + 40) = *(_OWORD *)(v6 + 40);
        *(_OWORD *)(v76 + 24) = v78;
        *(_OWORD *)(v76 + 8) = v77;
        *(_DWORD *)v76 = *(_DWORD *)v6;
        v79 = *(_QWORD *)(v6 + 56);
        *(_QWORD *)(v76 + 56) = v79;
        *(_QWORD *)(v79 + 64) = v76;
        v5[8] = v6;
        *(_QWORD *)(v6 + 56) = v5;
        *(_QWORD *)(v72 + 56) = v76;
        *(_QWORD *)(v76 + 64) = v72;
      }
      else
      {
        v97 = v5[7];
        *(_QWORD *)(v71 + 56) = v97;
        *(_QWORD *)(v71 + 64) = v5;
        *(_QWORD *)(v97 + 64) = v71;
        v5[7] = v71;
        v98 = operator new();
        v99 = *v129;
        v100 = *(_OWORD *)(v6 + 24);
        *(_OWORD *)(v98 + 40) = *(_OWORD *)(v6 + 40);
        *(_OWORD *)(v98 + 24) = v100;
        *(_OWORD *)(v98 + 8) = v99;
        *(_DWORD *)v98 = *(_DWORD *)v6;
        v101 = *(_QWORD *)(v6 + 64);
        *(_QWORD *)(v98 + 64) = v101;
        *(_QWORD *)(v101 + 56) = v98;
        v5[7] = v6;
        *(_QWORD *)(v6 + 64) = v5;
        *(_QWORD *)(v72 + 64) = v98;
        *(_QWORD *)(v98 + 56) = v72;
      }
      *a2 = (uint64_t)v5;
      a2[1] = v72;
      return 1;
    }
    return 0;
  }
  v11 = (_QWORD *)*a2;
  if (a2[2] != v7
    || ((v12 = (__int128 *)(v6 + 8), v7 == *(_QWORD *)(v6 + 8)) ? (v13 = v9 == *(_QWORD *)(v6 + 16)) : (v13 = 0),
        v11 = (_QWORD *)*a2,
        !v13))
  {
    do
    {
      v14 = (uint64_t)v11;
      v11 = (_QWORD *)v11[8];
    }
    while (v11 != v5 && v11[2] == v9 && v11 != (_QWORD *)v6);
    do
    {
      v17 = v5;
      v5 = (_QWORD *)v5[7];
    }
    while (v5 != (_QWORD *)v14 && v5[2] == v9 && v5 != (_QWORD *)v6);
    if (v5 != (_QWORD *)v14 && v5 != (_QWORD *)v6)
    {
      v21 = *(_QWORD *)(v6 + 16);
      v22 = (_QWORD *)a2[1];
      do
      {
        v23 = (uint64_t)v22;
        v22 = (_QWORD *)v22[8];
      }
      while (v22 != v17 && v22[2] == v21 && v22 != (_QWORD *)v6);
      do
      {
        v26 = v6;
        v6 = *(_QWORD *)(v6 + 56);
      }
      while (v6 != v14 && v6 != v23 && *(_QWORD *)(v6 + 16) == v21);
      if (v6 != v23 && v6 != v14)
      {
        v30 = *(_QWORD *)(v14 + 8);
        v31 = v17[1];
        v32 = *(_QWORD *)(v23 + 8);
        v33 = *(_QWORD *)(v26 + 8);
        v34 = v32 < v33;
        if (v31 <= v33)
          v35 = *(_QWORD *)(v26 + 8);
        else
          v35 = v17[1];
        if (v32 >= v30)
          v36 = *(_QWORD *)(v14 + 8);
        else
          v36 = *(_QWORD *)(v23 + 8);
        if (v31 <= v32)
          v37 = *(_QWORD *)(v23 + 8);
        else
          v37 = v17[1];
        if (v33 >= v30)
          v38 = *(_QWORD *)(v14 + 8);
        else
          v38 = *(_QWORD *)(v26 + 8);
        if (v32 < v33)
          v36 = v38;
        else
          v37 = v35;
        if (v30 <= v33)
          v39 = *(_QWORD *)(v26 + 8);
        else
          v39 = *(_QWORD *)(v14 + 8);
        if (v32 >= v31)
          v40 = v17[1];
        else
          v40 = *(_QWORD *)(v23 + 8);
        if (v30 <= v32)
          v41 = *(_QWORD *)(v23 + 8);
        else
          v41 = *(_QWORD *)(v14 + 8);
        if (v33 >= v31)
          v42 = v17[1];
        else
          v42 = *(_QWORD *)(v26 + 8);
        if (v32 < v33)
          v40 = v42;
        else
          v41 = v39;
        if (v30 < v31)
        {
          v37 = v41;
          v36 = v40;
        }
        if (v37 < v36)
        {
          if (v30 < v37 || v30 > v36)
          {
            if (v32 < v37 || v32 > v36)
            {
              if (v31 < v37 || v31 > v36)
              {
                v43 = *(_QWORD *)(v26 + 16);
                v136 = *(_OWORD *)(v26 + 24);
                v137 = *(_OWORD *)(v26 + 40);
                v44 = *(_QWORD *)(v26 + 8);
              }
              else
              {
                v43 = v17[2];
                v136 = *(_OWORD *)(v17 + 3);
                v137 = *(_OWORD *)(v17 + 5);
                v44 = v17[1];
                v34 = v30 < v31;
              }
            }
            else
            {
              v43 = *(_QWORD *)(v23 + 16);
              v136 = *(_OWORD *)(v23 + 24);
              v137 = *(_OWORD *)(v23 + 40);
              v34 = v32 > v33;
              v44 = *(_QWORD *)(v23 + 8);
            }
          }
          else
          {
            v43 = *(_QWORD *)(v14 + 16);
            v136 = *(_OWORD *)(v14 + 24);
            v137 = *(_OWORD *)(v14 + 40);
            v34 = v30 > v31;
            v44 = *(_QWORD *)(v14 + 8);
          }
          *a2 = v14;
          a2[1] = v23;
          v107 = v30 <= v31;
          v108 = v32 <= v33;
          v70 = v107 ^ v108;
          if (v107 == v108)
            return v70;
          v135 = v34;
          if (v30 > v31)
          {
            do
            {
              v109 = v14;
              v14 = *(_QWORD *)(v14 + 56);
              v115 = *(_QWORD *)(v14 + 8);
            }
            while (v115 >= v44 && v115 <= *(_QWORD *)(v109 + 8) && *(_QWORD *)(v14 + 16) == v43);
            if (!v34 && *(_QWORD *)(v109 + 8) != v44)
              v109 = v14;
            v111 = ClipperLib::DupOutPt(v109, v34);
            v112 = v111;
            if (*(_QWORD *)(v111 + 8) != v44 || *(_QWORD *)(v111 + 16) != v43)
            {
              *(_QWORD *)(v111 + 8) = v44;
              *(_QWORD *)(v111 + 16) = v43;
              *(_OWORD *)(v111 + 24) = v136;
              *(_OWORD *)(v111 + 40) = v137;
              v114 = v135;
              goto LABEL_193;
            }
          }
          else
          {
            do
            {
              v109 = v14;
              v14 = *(_QWORD *)(v14 + 56);
              v110 = *(_QWORD *)(v14 + 8);
            }
            while (v110 <= v44 && v110 >= *(_QWORD *)(v109 + 8) && *(_QWORD *)(v14 + 16) == v43);
            if (v34 && *(_QWORD *)(v109 + 8) != v44)
              v109 = v14;
            v133 = !v34;
            v111 = ClipperLib::DupOutPt(v109, !v34);
            v112 = v111;
            if (*(_QWORD *)(v111 + 8) != v44 || *(_QWORD *)(v111 + 16) != v43)
            {
              *(_QWORD *)(v111 + 8) = v44;
              *(_QWORD *)(v111 + 16) = v43;
              *(_OWORD *)(v111 + 24) = v136;
              *(_OWORD *)(v111 + 40) = v137;
              v114 = v133;
LABEL_193:
              v117 = ClipperLib::DupOutPt(v111, v114);
LABEL_195:
              if (v32 > v33)
              {
                do
                {
                  v118 = (_QWORD *)v23;
                  v23 = *(_QWORD *)(v23 + 56);
                  v124 = *(_QWORD *)(v23 + 8);
                }
                while (v124 >= v44 && v124 <= v118[1] && *(_QWORD *)(v23 + 16) == v43);
                v125 = v117;
                if ((v135 & 1) == 0 && v118[1] != v44)
                  v118 = (_QWORD *)v23;
                v126 = ClipperLib::DupOutPt((uint64_t)v118, v135);
                v122 = v126;
                if (*(_QWORD *)(v126 + 8) != v44 || *(_QWORD *)(v126 + 16) != v43)
                {
                  *(_QWORD *)(v126 + 8) = v44;
                  *(_QWORD *)(v126 + 16) = v43;
                  *(_OWORD *)(v126 + 24) = v136;
                  *(_OWORD *)(v126 + 40) = v137;
                  v118 = (_QWORD *)v126;
                  v122 = ClipperLib::DupOutPt(v126, v135);
                }
                v120 = v125;
              }
              else
              {
                do
                {
                  v118 = (_QWORD *)v23;
                  v23 = *(_QWORD *)(v23 + 56);
                  v119 = *(_QWORD *)(v23 + 8);
                }
                while (v119 <= v44 && v119 >= v118[1] && *(_QWORD *)(v23 + 16) == v43);
                v120 = v117;
                if (v135 && v118[1] != v44)
                  v118 = (_QWORD *)v23;
                v121 = ClipperLib::DupOutPt((uint64_t)v118, v135 ^ 1u);
                v122 = v121;
                if (*(_QWORD *)(v121 + 8) != v44 || *(_QWORD *)(v121 + 16) != v43)
                {
                  *(_QWORD *)(v121 + 8) = v44;
                  *(_QWORD *)(v121 + 16) = v43;
                  *(_OWORD *)(v121 + 24) = v136;
                  *(_OWORD *)(v121 + 40) = v137;
                  v118 = (_QWORD *)v121;
                  v122 = ClipperLib::DupOutPt(v121, v135 ^ 1u);
                }
              }
              if ((((v30 <= v31) ^ v135) & 1) != 0)
              {
                *(_QWORD *)(v112 + 56) = v118;
                v118[8] = v112;
                v128 = (uint64_t *)(v122 + 56);
                *(_QWORD *)(v120 + 64) = v122;
              }
              else
              {
                *(_QWORD *)(v112 + 64) = v118;
                v118[7] = v112;
                v128 = (uint64_t *)(v122 + 64);
                *(_QWORD *)(v120 + 56) = v122;
              }
              *v128 = v120;
              return v70;
            }
          }
          v117 = v112;
          v112 = v109;
          goto LABEL_195;
        }
      }
    }
    return 0;
  }
  if (a3 != a4)
    return 0;
  v81 = (_QWORD *)*a2;
  while (1)
  {
    v81 = (_QWORD *)v81[7];
    if (v81 == v5)
      break;
    v82 = v81[2];
    if (v81[1] != v7 || v82 != v9)
      goto LABEL_147;
  }
  v82 = *(_QWORD *)(*a2 + 16);
LABEL_147:
  v84 = (_QWORD *)a2[1];
  while (1)
  {
    v84 = (_QWORD *)v84[7];
    if (v84 == (_QWORD *)v6)
      break;
    v85 = v84[2];
    if (v84[1] != v7 || v85 != v9)
    {
      if (v82 > v9 != v85 <= v9)
        return 0;
      goto LABEL_156;
    }
  }
  if (v82 <= v9)
    return 0;
LABEL_156:
  v87 = operator new();
  v88 = v87;
  v90 = *(_OWORD *)(v8 + 16);
  v89 = *(_OWORD *)(v8 + 32);
  *(_OWORD *)(v87 + 8) = *(_OWORD *)v8;
  *(_OWORD *)(v87 + 40) = v89;
  *(_OWORD *)(v87 + 24) = v90;
  *(_DWORD *)v87 = *(_DWORD *)v5;
  if (v82 <= v9)
  {
    v102 = v5[7];
    *(_QWORD *)(v87 + 56) = v102;
    *(_QWORD *)(v87 + 64) = v5;
    *(_QWORD *)(v102 + 64) = v87;
    v5[7] = v87;
    v103 = operator new();
    v104 = *v12;
    v105 = *(_OWORD *)(v6 + 24);
    *(_OWORD *)(v103 + 40) = *(_OWORD *)(v6 + 40);
    *(_OWORD *)(v103 + 24) = v105;
    *(_OWORD *)(v103 + 8) = v104;
    *(_DWORD *)v103 = *(_DWORD *)v6;
    v106 = *(_QWORD *)(v6 + 64);
    *(_QWORD *)(v103 + 64) = v106;
    v96 = (uint64_t *)(v103 + 56);
    *(_QWORD *)(v106 + 56) = v103;
    v5[7] = v6;
    *(_QWORD *)(v6 + 64) = v5;
    *(_QWORD *)(v88 + 64) = v103;
  }
  else
  {
    v91 = v5[8];
    *(_QWORD *)(v87 + 56) = v5;
    *(_QWORD *)(v87 + 64) = v91;
    *(_QWORD *)(v91 + 56) = v87;
    v5[8] = v87;
    v92 = operator new();
    v93 = *v12;
    v94 = *(_OWORD *)(v6 + 24);
    *(_OWORD *)(v92 + 40) = *(_OWORD *)(v6 + 40);
    *(_OWORD *)(v92 + 24) = v94;
    *(_OWORD *)(v92 + 8) = v93;
    *(_DWORD *)v92 = *(_DWORD *)v6;
    v95 = *(_QWORD *)(v6 + 56);
    *(_QWORD *)(v92 + 56) = v95;
    v96 = (uint64_t *)(v92 + 64);
    *(_QWORD *)(v95 + 64) = v92;
    v5[8] = v6;
    *(_QWORD *)(v6 + 56) = v5;
    *(_QWORD *)(v88 + 56) = v92;
  }
  *v96 = v88;
  v70 = 1;
  *a2 = (uint64_t)v5;
  a2[1] = v88;
  return v70;
}

uint64_t ClipperLib::DupOutPt(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;

  result = operator new();
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(result + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(result + 40) = *(_OWORD *)(a1 + 40);
  *(_DWORD *)result = *(_DWORD *)a1;
  if (a2)
  {
    v5 = (uint64_t *)(a1 + 56);
    v6 = *(_QWORD *)(a1 + 56);
    v7 = (uint64_t *)(v6 + 64);
  }
  else
  {
    v6 = a1;
    v5 = (uint64_t *)(a1 + 64);
    a1 = *(_QWORD *)(a1 + 64);
    v7 = (uint64_t *)(a1 + 56);
  }
  *(_QWORD *)(result + 56) = v6;
  *(_QWORD *)(result + 64) = a1;
  *v7 = result;
  *v5 = result;
  return result;
}

uint64_t ClipperLib::GetBottomPt(_QWORD *a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v1 = (uint64_t)a1;
  v2 = (_QWORD *)a1[7];
  if (v2 == a1)
    return v1;
  v3 = 0;
  do
  {
    v4 = v2[2];
    v5 = *(_QWORD *)(v1 + 16);
    if (v4 > v5)
    {
LABEL_4:
      v3 = 0;
      v1 = (uint64_t)v2;
      goto LABEL_11;
    }
    if (v4 == v5)
    {
      v6 = v2[1];
      v7 = *(_QWORD *)(v1 + 8);
      if (v6 <= v7)
      {
        if (v6 < v7)
          goto LABEL_4;
        if (v2[7] != v1 && v2[8] != v1)
          v3 = v2;
      }
    }
LABEL_11:
    v2 = (_QWORD *)v2[7];
  }
  while (v2 != (_QWORD *)v1);
  if (!v3 || v3 == (_QWORD *)v1)
    return v1;
  v8 = (_QWORD *)v1;
  do
  {
    if (!ClipperLib::FirstIsBottomPt(v1, v3))
      v8 = v3;
    do
      v3 = (_QWORD *)v3[7];
    while (v3[1] != v8[1] || v3[2] != v8[2]);
  }
  while (v3 != (_QWORD *)v1);
  return (uint64_t)v8;
}

uint64_t ClipperLib::FirstIsBottomPt(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  double v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v16;
  double v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  double v26;
  double v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  double v33;
  uint64_t v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  _QWORD *v42;
  _BOOL4 v43;

  v2 = *(_QWORD *)(result + 8);
  v3 = *(_QWORD *)(result + 16);
  v4 = (_QWORD *)result;
  do
  {
    v4 = (_QWORD *)v4[8];
    v5 = v4[1];
    v6 = v4[2];
  }
  while (v4 != (_QWORD *)result && v5 == v2 && v6 == v3);
  v9 = v6 - v3;
  if (v9)
    v10 = (double)(v5 - v2) / (double)v9;
  else
    v10 = -1.0e40;
  v11 = (_QWORD *)result;
  do
  {
    v11 = (_QWORD *)v11[7];
    v12 = v11[1];
    v13 = v11[2];
  }
  while (v11 != (_QWORD *)result && v12 == v2 && v13 == v3);
  v16 = v13 - v3;
  if (v16)
    v17 = (double)(v12 - v2) / (double)v16;
  else
    v17 = -1.0e40;
  v18 = fabs(v10);
  v19 = a2[1];
  v20 = a2[2];
  v21 = a2;
  do
  {
    v21 = (_QWORD *)v21[8];
    v22 = v21[1];
    v23 = v21[2];
  }
  while (v21 != a2 && v22 == v19 && v23 == v20);
  if (v23 == v20)
    v26 = -1.0e40;
  else
    v26 = (double)(v22 - v19) / (double)(v23 - v20);
  v27 = fabs(v17);
  v28 = a2;
  do
  {
    v28 = (_QWORD *)v28[7];
    v29 = v28[1];
    v30 = v28[2];
  }
  while (v28 != a2 && v29 == v19 && v30 == v20);
  v33 = fabs(v26);
  v34 = v30 - v20;
  if (v34)
    v35 = (double)(v29 - v19) / (double)v34;
  else
    v35 = -1.0e40;
  v36 = fabs(v35);
  if (v18 >= v27)
    v37 = v18;
  else
    v37 = v27;
  if (v33 >= v36)
    v38 = v33;
  else
    v38 = v36;
  if (v37 == v38 && (v27 >= v18 ? (v39 = v18) : (v39 = v27), v36 >= v33 ? (v40 = v33) : (v40 = v36), v39 == v40))
  {
    if (result)
    {
      v41 = 0.0;
      v42 = (_QWORD *)result;
      do
      {
        v41 = v41
            + (double)(uint64_t)(v42[1] + *(_QWORD *)(v42[8] + 8))
            * (double)(uint64_t)(*(_QWORD *)(v42[8] + 16) - v42[2]);
        v42 = (_QWORD *)v42[7];
      }
      while (v42 != (_QWORD *)result);
      return v41 * 0.5 > 0.0;
    }
  }
  else
  {
    v43 = v27 >= v33;
    if (v27 < v36)
      v43 = 0;
    return v18 >= v33 && v18 >= v36 || v43;
  }
  return result;
}

void ClipperLib::Clipper::AddJoin(_QWORD *a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;

  v8 = operator new();
  v9 = v8;
  *(_QWORD *)v8 = a2;
  *(_QWORD *)(v8 + 8) = a3;
  v10 = a4[1];
  *(_OWORD *)(v8 + 16) = *a4;
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 48) = a4[2];
  v12 = (uint64_t *)a1[2];
  v11 = a1[3];
  if ((unint64_t)v12 >= v11)
  {
    v14 = a1[1];
    v15 = ((uint64_t)v12 - v14) >> 3;
    if ((unint64_t)(v15 + 1) >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v16 = v11 - v14;
    v17 = v16 >> 2;
    if (v16 >> 2 <= (unint64_t)(v15 + 1))
      v17 = v15 + 1;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v17;
    if (v18)
      v18 = (unint64_t)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v18);
    else
      v19 = 0;
    v20 = (uint64_t *)(v18 + 8 * v15);
    v21 = v18 + 8 * v19;
    *v20 = v9;
    v13 = v20 + 1;
    v23 = (char *)a1[1];
    v22 = (char *)a1[2];
    if (v22 != v23)
    {
      do
      {
        v24 = *((_QWORD *)v22 - 1);
        v22 -= 8;
        *--v20 = v24;
      }
      while (v22 != v23);
      v22 = (char *)a1[1];
    }
    a1[1] = v20;
    a1[2] = v13;
    a1[3] = v21;
    if (v22)
      operator delete(v22);
  }
  else
  {
    *v12 = v8;
    v13 = v12 + 1;
  }
  a1[2] = v13;
}

BOOL ClipperLib::SlopesEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unint64_t v15[2];
  unint64_t v16[2];

  if (a9)
  {
    ClipperLib::Int128Mul(v16, a2 - a4, a5 - a7);
    ClipperLib::Int128Mul(v15, a1 - a3, a6 - a8);
    return v16[1] == v15[1] && v16[0] == v15[0];
  }
  else
  {
    return (a5 - a7) * (a2 - a4) == (a6 - a8) * (a1 - a3);
  }
}

_QWORD *ClipperLib::Clipper::AppendPolygon(_QWORD *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int8x16_t v23;
  uint64_t v24;
  int8x16_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;

  v3 = *(int *)(a2 + 172);
  v4 = *(_QWORD *)((char *)result + *(_QWORD *)(*result - 24) + 80);
  v5 = (*(_QWORD *)((char *)result + *(_QWORD *)(*result - 24) + 88) - v4) >> 3;
  if (v5 <= v3 || (v7 = *(int *)(a3 + 172), v5 <= v7))
  {
    __break(1u);
  }
  else
  {
    v9 = result;
    v10 = *(_QWORD *)(v4 + 8 * v3);
    v11 = *(_QWORD *)(v4 + 8 * v7);
    v12 = v10;
    do
      v12 = *(_QWORD *)(v12 + 8);
    while (v12 != v11 && v12 != 0);
    result = (_QWORD *)v11;
    if (v12 != v11)
    {
      v14 = v11;
      do
        v14 = *(_QWORD *)(v14 + 8);
      while (v14 != v10 && v14 != 0);
      result = (_QWORD *)v10;
      if (v14 != v10)
        result = (_QWORD *)ClipperLib::GetLowermostRec(v10, v11);
    }
    v16 = *(_QWORD *)(v10 + 24);
    v17 = *(_QWORD *)(v16 + 64);
    v18 = *(_QWORD *)(v11 + 24);
    v19 = *(_QWORD *)(v18 + 64);
    v20 = *(_DWORD *)(a2 + 156);
    v21 = *(_DWORD *)(a3 + 156);
    if (v20 == 1)
    {
      if (v21 == 1)
      {
        v22 = *(_QWORD *)(v11 + 24);
        do
        {
          v23 = *(int8x16_t *)(v22 + 56);
          *(int8x16_t *)(v22 + 56) = vextq_s8(v23, v23, 8uLL);
          v22 = v23.i64[0];
        }
        while (v23.i64[0] != v18);
        *(_QWORD *)(v18 + 56) = v16;
        *(_QWORD *)(v16 + 64) = v18;
        *(_QWORD *)(v17 + 56) = v19;
        *(_QWORD *)(v19 + 64) = v17;
        *(_QWORD *)(v10 + 24) = v19;
      }
      else
      {
        *(_QWORD *)(v19 + 56) = v16;
        *(_QWORD *)(v16 + 64) = v19;
        *(_QWORD *)(v18 + 64) = v17;
        *(_QWORD *)(v17 + 56) = v18;
        *(_QWORD *)(v10 + 24) = v18;
      }
    }
    else if (v21 == 2)
    {
      v24 = *(_QWORD *)(v11 + 24);
      do
      {
        v25 = *(int8x16_t *)(v24 + 56);
        *(int8x16_t *)(v24 + 56) = vextq_s8(v25, v25, 8uLL);
        v24 = v25.i64[0];
      }
      while (v25.i64[0] != v18);
      *(_QWORD *)(v17 + 56) = v19;
      *(_QWORD *)(v19 + 64) = v17;
      *(_QWORD *)(v18 + 56) = v16;
      *(_QWORD *)(v16 + 64) = v18;
    }
    else
    {
      *(_QWORD *)(v17 + 56) = v18;
      *(_QWORD *)(v18 + 64) = v17;
      *(_QWORD *)(v16 + 64) = v19;
      *(_QWORD *)(v19 + 56) = v16;
    }
    *(_QWORD *)(v10 + 32) = 0;
    if (result == (_QWORD *)v11)
    {
      v26 = *(_QWORD *)(v11 + 8);
      if (v26 != v10)
        *(_QWORD *)(v10 + 8) = v26;
      *(_BYTE *)(v10 + 4) = *(_BYTE *)(v11 + 4);
    }
    *(_QWORD *)(v11 + 24) = 0;
    *(_QWORD *)(v11 + 32) = 0;
    *(_QWORD *)(v11 + 8) = v10;
    v27 = *(_DWORD *)(a2 + 172);
    v28 = *(_DWORD *)(a3 + 172);
    *(_DWORD *)(a2 + 172) = -1;
    *(_DWORD *)(a3 + 172) = -1;
    v29 = *(_QWORD *)((char *)v9 + *(_QWORD *)(*v9 - 24) + 104);
    if (v29)
    {
      while (*(_DWORD *)(v29 + 172) != v28)
      {
        v29 = *(_QWORD *)(v29 + 200);
        if (!v29)
          goto LABEL_38;
      }
      *(_DWORD *)(v29 + 172) = v27;
      *(_DWORD *)(v29 + 156) = v20;
    }
LABEL_38:
    *(_DWORD *)v11 = *(_DWORD *)v10;
  }
  return result;
}

uint64_t ClipperLib::Clipper::DisposeIntersectNodes(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v1 = this;
  v3 = *(_QWORD *)(this + 56);
  v2 = *(_QWORD *)(this + 64);
  if (v2 == v3)
  {
    v3 = *(_QWORD *)(this + 64);
  }
  else
  {
    v4 = 0;
    do
    {
      this = *(_QWORD *)(v3 + 8 * v4);
      if (this)
      {
        this = MEMORY[0x186DC23C4](this, 0x1020C40038FC326);
        v3 = *(_QWORD *)(v1 + 56);
        v2 = *(_QWORD *)(v1 + 64);
      }
      ++v4;
    }
    while (v4 < (v2 - v3) >> 3);
  }
  *(_QWORD *)(v1 + 64) = v3;
  return this;
}

BOOL ClipperLib::IntersectListSort(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 24) < *(_QWORD *)(a1 + 24);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(uint64_t result, char *a2, uint64_t (**a3)(_QWORD), uint64_t a4, char a5)
{
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  BOOL v29;
  BOOL v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char *v42;
  BOOL v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  int64_t v51;
  int64_t v52;
  uint64_t v53;
  char *v54;
  char *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t v70;
  char *v71;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  int64_t v80;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int64_t v85;

  v8 = (char *)result;
LABEL_2:
  v9 = a2 - 8;
  v10 = v8;
  while (2)
  {
    v8 = v10;
    v11 = a2 - v10;
    v12 = (a2 - v10) >> 3;
    switch(v12)
    {
      case 0:
      case 1:
        return result;
      case 2:
        result = ((uint64_t (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)v9, *(_QWORD *)v10);
        if ((_DWORD)result)
        {
          v41 = *(_QWORD *)v10;
          *(_QWORD *)v10 = *(_QWORD *)v9;
          *(_QWORD *)v9 = v41;
        }
        return result;
      case 3:
        return std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v10, (_QWORD *)v10 + 1, v9, a3);
      case 4:
        return std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v10, (_QWORD *)v10 + 1, (_QWORD *)v10 + 2, v9, a3);
      case 5:
        return std::__sort5[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v10, (_QWORD *)v10 + 1, (_QWORD *)v10 + 2, (_QWORD *)v10 + 3, v9, a3);
      default:
        if (v11 <= 191)
        {
          v42 = v10 + 8;
          v44 = v10 == a2 || v42 == a2;
          if ((a5 & 1) != 0)
          {
            if (!v44)
            {
              v45 = 0;
              v46 = v10;
              do
              {
                v47 = *(_QWORD *)v46;
                v46 = v42;
                result = ((uint64_t (*)(_QWORD, uint64_t))*a3)(*(_QWORD *)v42, v47);
                if ((_DWORD)result)
                {
                  v48 = *(_QWORD *)v42;
                  v49 = v45;
                  while (1)
                  {
                    *(_QWORD *)&v10[v49 + 8] = *(_QWORD *)&v10[v49];
                    if (!v49)
                      break;
                    result = ((uint64_t (*)(uint64_t, _QWORD))*a3)(v48, *(_QWORD *)&v10[v49 - 8]);
                    v49 -= 8;
                    if ((result & 1) == 0)
                    {
                      v50 = &v10[v49 + 8];
                      goto LABEL_79;
                    }
                  }
                  v50 = v10;
LABEL_79:
                  *(_QWORD *)v50 = v48;
                }
                v42 = v46 + 8;
                v45 += 8;
              }
              while (v46 + 8 != a2);
            }
          }
          else if (!v44)
          {
            v73 = 0;
            v74 = -1;
            v75 = 1;
            while (1)
            {
              v76 = *(_QWORD *)&v10[8 * v73];
              v73 = v75;
              result = ((uint64_t (*)(_QWORD, uint64_t))*a3)(*(_QWORD *)v42, v76);
              if ((_DWORD)result)
                break;
LABEL_123:
              v75 = v73 + 1;
              v42 += 8;
              --v74;
              if (v42 == a2)
                return result;
            }
            v77 = *(_QWORD *)v42;
            v78 = v74;
            v79 = v42;
            while (1)
            {
              *(_QWORD *)v79 = *((_QWORD *)v79 - 1);
              if (!v78)
                break;
              result = ((uint64_t (*)(uint64_t, _QWORD))*a3)(v77, *((_QWORD *)v79 - 2));
              v79 -= 8;
              ++v78;
              if ((result & 1) == 0)
              {
                *(_QWORD *)v79 = v77;
                goto LABEL_123;
              }
            }
LABEL_125:
            __break(1u);
          }
          return result;
        }
        if (!a4)
        {
          if (v10 != a2)
          {
            v51 = (unint64_t)(v12 - 2) >> 1;
            v85 = v51;
            do
            {
              v52 = v51;
              if (v85 >= v51)
              {
                v53 = (2 * v51) | 1;
                v54 = &v8[8 * v53];
                if (2 * v51 + 2 < v12
                  && ((unsigned int (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)v54, *((_QWORD *)v54 + 1)))
                {
                  v54 += 8;
                  v53 = 2 * v52 + 2;
                }
                v55 = &v8[8 * v52];
                result = ((uint64_t (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)v54, *(_QWORD *)v55);
                if ((result & 1) == 0)
                {
                  v80 = v52;
                  v82 = *(_QWORD *)v55;
                  do
                  {
                    v56 = v54;
                    *(_QWORD *)v55 = *(_QWORD *)v54;
                    if (v85 < v53)
                      break;
                    v57 = (2 * v53) | 1;
                    v54 = &v8[8 * v57];
                    v58 = 2 * v53 + 2;
                    if (v58 < v12
                      && ((unsigned int (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)v54, *((_QWORD *)v54 + 1)))
                    {
                      v54 += 8;
                      v57 = v58;
                    }
                    result = ((uint64_t (*)(_QWORD, uint64_t))*a3)(*(_QWORD *)v54, v82);
                    v55 = v56;
                    v53 = v57;
                  }
                  while (!(_DWORD)result);
                  v52 = v80;
                  *(_QWORD *)v56 = v82;
                }
              }
              v51 = v52 - 1;
            }
            while (v52);
            v59 = (unint64_t)v11 >> 3;
            do
            {
              v60 = 0;
              v61 = v59 - 2;
              v83 = *(_QWORD *)v8;
              if (v59 < 2)
                v61 = v59 - 1;
              v62 = v61 >> 1;
              v63 = v8;
              do
              {
                v64 = &v63[8 * v60 + 8];
                v65 = (2 * v60) | 1;
                v66 = 2 * v60 + 2;
                if (v66 < v59)
                {
                  result = ((uint64_t (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)&v63[8 * v60 + 8], *(_QWORD *)&v63[8 * v60 + 16]);
                  if ((_DWORD)result)
                  {
                    v64 += 8;
                    v65 = v66;
                  }
                }
                *(_QWORD *)v63 = *(_QWORD *)v64;
                v63 = v64;
                v60 = v65;
              }
              while (v65 <= v62);
              a2 -= 8;
              if (v64 == a2)
              {
                *(_QWORD *)v64 = v83;
              }
              else
              {
                *(_QWORD *)v64 = *(_QWORD *)a2;
                *(_QWORD *)a2 = v83;
                v67 = v64 - v8 + 8;
                if (v67 >= 9)
                {
                  v68 = (unint64_t)((v67 >> 3) - 2) >> 1;
                  v69 = &v8[8 * v68];
                  result = ((uint64_t (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)v69, *(_QWORD *)v64);
                  if ((_DWORD)result)
                  {
                    v70 = *(_QWORD *)v64;
                    do
                    {
                      v71 = v69;
                      *(_QWORD *)v64 = *(_QWORD *)v69;
                      if (!v68)
                        break;
                      v68 = (v68 - 1) >> 1;
                      v69 = &v8[8 * v68];
                      result = ((uint64_t (*)(_QWORD, uint64_t))*a3)(*(_QWORD *)v69, v70);
                      v64 = v71;
                    }
                    while ((result & 1) != 0);
                    *(_QWORD *)v71 = v70;
                  }
                }
              }
            }
            while (v59-- > 2);
          }
          return result;
        }
        v13 = (unint64_t)v12 >> 1;
        v14 = &v10[8 * ((unint64_t)v12 >> 1)];
        if ((unint64_t)v11 < 0x401)
        {
          result = std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v14, v10, v9, a3);
        }
        else
        {
          std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v10, v14, v9, a3);
          std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((_QWORD *)v10 + 1, (_QWORD *)v14 - 1, (_QWORD *)a2 - 2, a3);
          std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((_QWORD *)v10 + 2, &v10[8 * v13 + 8], (_QWORD *)a2 - 3, a3);
          result = std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((_QWORD *)v14 - 1, v14, &v10[8 * v13 + 8], a3);
          v15 = *(_QWORD *)v10;
          *(_QWORD *)v10 = *(_QWORD *)v14;
          *(_QWORD *)v14 = v15;
        }
        --a4;
        if ((a5 & 1) == 0)
        {
          result = ((uint64_t (*)(_QWORD, _QWORD))*a3)(*((_QWORD *)v10 - 1), *(_QWORD *)v10);
          if ((result & 1) == 0)
          {
            v31 = *(_QWORD *)v10;
            result = ((uint64_t (*)(_QWORD, _QWORD))*a3)(*(_QWORD *)v10, *(_QWORD *)v9);
            v32 = v10 + 8;
            if ((result & 1) != 0)
            {
              do
              {
                if (v32 == a2)
                  goto LABEL_125;
                v33 = *(_QWORD *)v32;
                v32 += 8;
                result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v31, v33);
              }
              while ((result & 1) == 0);
              v10 = v32 - 8;
            }
            else
            {
              do
              {
                v10 = v32;
                if (v32 >= a2)
                  break;
                v32 += 8;
                result = ((uint64_t (*)(uint64_t, _QWORD))*a3)(v31, *(_QWORD *)v10);
              }
              while ((result & 1) == 0);
            }
            v34 = a2;
            if (v10 < a2)
            {
              v34 = a2;
              while (v34 != v8)
              {
                v35 = *((_QWORD *)v34 - 1);
                v34 -= 8;
                result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v31, v35);
                if ((result & 1) == 0)
                  goto LABEL_52;
              }
              goto LABEL_125;
            }
LABEL_52:
            if (v10 < v34)
            {
              v36 = *(_QWORD *)v10;
              *(_QWORD *)v10 = *(_QWORD *)v34;
              *(_QWORD *)v34 = v36;
              v37 = v10 + 8;
              while (v37 != a2)
              {
                v10 = v37;
                v38 = *(_QWORD *)v37;
                v37 += 8;
                result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v31, v38);
                if ((_DWORD)result)
                {
                  while (v34 != v8)
                  {
                    v39 = *((_QWORD *)v34 - 1);
                    v34 -= 8;
                    result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v31, v39);
                    if ((result & 1) == 0)
                      goto LABEL_52;
                  }
                  goto LABEL_125;
                }
              }
              goto LABEL_125;
            }
            v40 = v10 - 8;
            if (v10 - 8 != v8)
              *(_QWORD *)v8 = *(_QWORD *)v40;
            a5 = 0;
            *(_QWORD *)v40 = v31;
            continue;
          }
        }
        v16 = v10 + 8;
        v17 = *(_QWORD *)v10;
        do
        {
          if (v16 == a2)
            goto LABEL_125;
          v18 = v16;
          v19 = v16 - 8;
          result = ((uint64_t (*)(_QWORD, uint64_t))*a3)(*(_QWORD *)v16, v17);
          v16 = v18 + 8;
        }
        while ((result & 1) != 0);
        v84 = a4;
        v20 = v9;
        v21 = a2;
        if (v19 != v8)
        {
          while (v21 != v8)
          {
            v22 = *((_QWORD *)v21 - 1);
            v21 -= 8;
            result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v22, v17);
            if ((_DWORD)result)
              goto LABEL_21;
          }
          goto LABEL_125;
        }
        v21 = a2;
        do
        {
          if (v18 >= v21)
            break;
          v23 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v23, v17);
        }
        while ((result & 1) == 0);
LABEL_21:
        if (v18 < v21)
        {
          v24 = v18;
          v25 = v21;
          do
          {
            v26 = *(_QWORD *)v24;
            *(_QWORD *)v24 = *(_QWORD *)v25;
            *(_QWORD *)v25 = v26;
            v27 = v24 + 8;
            do
            {
              if (v27 == a2)
                goto LABEL_125;
              v24 = v27;
              v19 = v27 - 8;
              result = ((uint64_t (*)(_QWORD, uint64_t))*a3)(*(_QWORD *)v27, v17);
              v27 = v24 + 8;
            }
            while ((result & 1) != 0);
            do
            {
              if (v25 == v8)
                goto LABEL_125;
              v28 = *((_QWORD *)v25 - 1);
              v25 -= 8;
              result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v28, v17);
            }
            while (!(_DWORD)result);
          }
          while (v24 < v25);
        }
        if (v19 != v8)
          *(_QWORD *)v8 = *(_QWORD *)v19;
        *(_QWORD *)v19 = v17;
        v29 = v18 >= v21;
        v9 = v20;
        a4 = v84;
        if (!v29)
        {
LABEL_35:
          result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **,false>(v8, v19, a3, v84, a5 & 1);
          a5 = 0;
          v10 = v19 + 8;
          continue;
        }
        v30 = std::__insertion_sort_incomplete[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(v8, v19, a3);
        v10 = v19 + 8;
        result = std::__insertion_sort_incomplete[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>((_QWORD *)v19 + 1, a2, a3);
        if (!(_DWORD)result)
        {
          if (v30)
            continue;
          goto LABEL_35;
        }
        a2 = v19;
        if (!v30)
          goto LABEL_2;
        return result;
    }
  }
}

uint64_t std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t (**a4)(_QWORD))
{
  char v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a2, *a1);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a3, *a2);
  if ((v8 & 1) != 0)
  {
    v10 = *a1;
    if ((_DWORD)result)
    {
      *a1 = *a3;
      *a3 = v10;
    }
    else
    {
      *a1 = *a2;
      *a2 = v10;
      result = (*a4)(*a3);
      if ((_DWORD)result)
      {
        v13 = *a2;
        *a2 = *a3;
        *a3 = v13;
      }
    }
  }
  else if ((_DWORD)result)
  {
    v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a2, *a1);
    if ((_DWORD)result)
    {
      v12 = *a1;
      *a1 = *a2;
      *a2 = v12;
    }
  }
  return result;
}

uint64_t std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t (**a5)(_QWORD))
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a2, a3, a5);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a4, *a3);
  if ((_DWORD)result)
  {
    v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a3, *a2);
    if ((_DWORD)result)
    {
      v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a2, *a1);
      if ((_DWORD)result)
      {
        v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t (**a6)(_QWORD))
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a2, a3, a4, a6);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a5, *a4);
  if ((_DWORD)result)
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a4, *a3);
    if ((_DWORD)result)
    {
      v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a3, *a2);
      if ((_DWORD)result)
      {
        v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a2, *a1);
        if ((_DWORD)result)
        {
          v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(_QWORD *a1, _QWORD *a2, uint64_t (**a3)(_QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*(a2 - 1), *a1))
      {
        v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v9 = a1 + 2;
      std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,BOOL (*&)(ClipperLib::IntersectNode *,ClipperLib::IntersectNode *),ClipperLib::IntersectNode **>(a1, a1 + 1, a1 + 2, a3);
      v10 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*v10, *v9))
    {
      v13 = *v10;
      v14 = v11;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_QWORD *)((char *)a1 + v14 + 24) = *(_QWORD *)((char *)a1 + v14 + 16);
        if (v14 == -16)
          break;
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, _QWORD))*a3)(v13, *((_QWORD *)v15 + 1)) & 1) == 0)
        {
          v16 = (_QWORD *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v13;
      if (++v12 == 8)
        return v10 + 1 == a2;
    }
    v9 = v10;
    v11 += 8;
    if (++v10 == a2)
      return 1;
  }
}

void ClipperLib::Clipper::AddGhostJoin(_QWORD *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  unint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v6 = operator new();
  v7 = v6;
  *(_QWORD *)v6 = a2;
  *(_QWORD *)(v6 + 8) = 0;
  v8 = a3[1];
  *(_OWORD *)(v6 + 16) = *a3;
  *(_OWORD *)(v6 + 32) = v8;
  *(_OWORD *)(v6 + 48) = a3[2];
  v10 = (uint64_t *)a1[5];
  v9 = a1[6];
  if ((unint64_t)v10 >= v9)
  {
    v12 = a1[4];
    v13 = ((uint64_t)v10 - v12) >> 3;
    if ((unint64_t)(v13 + 1) >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v14 = v9 - v12;
    v15 = v14 >> 2;
    if (v14 >> 2 <= (unint64_t)(v13 + 1))
      v15 = v13 + 1;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
      v16 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v16 = v15;
    if (v16)
      v16 = (unint64_t)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v16);
    else
      v17 = 0;
    v18 = (uint64_t *)(v16 + 8 * v13);
    v19 = v16 + 8 * v17;
    *v18 = v7;
    v11 = v18 + 1;
    v21 = (char *)a1[4];
    v20 = (char *)a1[5];
    if (v20 != v21)
    {
      do
      {
        v22 = *((_QWORD *)v20 - 1);
        v20 -= 8;
        *--v18 = v22;
      }
      while (v20 != v21);
      v20 = (char *)a1[4];
    }
    a1[4] = v18;
    a1[5] = v11;
    a1[6] = v19;
    if (v20)
      operator delete(v20);
  }
  else
  {
    *v10 = v6;
    v11 = v10 + 1;
  }
  a1[5] = v11;
}

BOOL ClipperLib::SlopesEqual(_QWORD *a1, _QWORD *a2, int a3)
{
  unint64_t v7[2];
  unint64_t v8[2];

  if (a3)
  {
    ClipperLib::Int128Mul(v8, a1[13] - a1[1], a2[12] - *a2);
    ClipperLib::Int128Mul(v7, a1[12] - *a1, a2[13] - a2[1]);
    return v8[1] == v7[1] && v8[0] == v7[0];
  }
  else
  {
    return (a2[12] - *a2) * (a1[13] - a1[1]) == (a2[13] - a2[1]) * (a1[12] - *a1);
  }
}

_QWORD *ClipperLib::PolyTree::Clear(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v1 = this;
  v2 = this[10];
  v3 = this[11];
  if (v3 != v2)
  {
    v4 = 0;
    do
    {
      this = *(_QWORD **)(v2 + 8 * v4);
      if (this)
      {
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
        v2 = v1[10];
        v3 = v1[11];
      }
      ++v4;
    }
    while (v4 < (v3 - v2) >> 3);
    if (v3 != v2)
      v1[11] = v2;
  }
  v5 = v1[4];
  if (v1[5] != v5)
    v1[5] = v5;
  return this;
}

_QWORD *std::vector<ClipperLib::IntPoint>::__init_with_size[abi:se180100]<ClipperLib::IntPoint*,ClipperLib::IntPoint*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v4;
  _QWORD *v7;
  uint64_t v8;
  size_t v9;

  if (a4)
  {
    v4 = result;
    if (a4 >= 0x555555555555556)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    result = std::__allocate_at_least[abi:se180100]<std::allocator<ClipperLib::IntPoint>>(a4);
    v7 = result;
    *v4 = result;
    v4[1] = result;
    v4[2] = &result[6 * v8];
    v9 = a3 - (_QWORD)a2;
    if (v9)
      result = memmove(result, a2, v9);
    v4[1] = (char *)v7 + v9;
  }
  return result;
}

void sub_184BE1074(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<ClipperLib::PolyNode *>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    v7 = &v4[8 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_QWORD *)v8 - 1);
        v8 -= 8;
        *((_QWORD *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_6())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyASCIIDescriptionString");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  color_space_state_create_flexGTC_proxy_f_26 = v1;
  return result;
}

uint64_t colorsync_smart_null_6025()
{
  return 0;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_5())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  color_space_state_create_flexGTC_proxy_f_20 = v1;
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_4())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileGetMD5");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  color_space_state_create_flexGTC_proxy_f_15 = v1;
  return result;
}

void flexGTC_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  const void *v12;
  uint64_t v13;
  const void *v14;
  const void *v15;

  v8 = *(_DWORD *)(a1 + 20);
  if (v8 != 11)
    _CGHandleAssert("flexGTC_finalize", 68, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not FlexGTC based. type = %d", a6, a7, a8, v8);
  v9 = *(_QWORD *)(a1 + 88);
  if (v9)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(v9 + 32));
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    v10 = *(const void **)(v9 + 24);
    if (v10)
      CFRelease(v10);
    v11 = *(const void **)(v9 + 40);
    if (v11)
      CFRelease(v11);
    v12 = *(const void **)(v9 + 48);
    if (v12)
      CFRelease(v12);
    _Block_release(*(const void **)(v9 + 56));
    if (!*(_QWORD *)(v9 + 80))
    {
      v13 = *(_QWORD *)(v9 + 64);
      if (v13)
        (*(void (**)(uint64_t, _QWORD, _QWORD))(v13 + 16))(v13, *(_QWORD *)(v9 + 72), 0);
    }
    v14 = *(const void **)(v9 + 64);
    if (v14)
      _Block_release(v14);
    v15 = *(const void **)(v9 + 80);
    if (v15)
      CFRelease(v15);
    free(*(void **)(v9 + 88));
  }
}

uint64_t flexGTC_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

CFTypeRef flexGTC_create_icc_profile_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  CFTypeRef result;

  v8 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v8 + 20) != 11)
    _CGHandleAssert("flexGTC_create_icc_profile_description", 138, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "space->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace must be FlexGTC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 20));
  result = *(CFTypeRef *)(*(_QWORD *)(v8 + 88) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

BOOL flexGTC_md5_equal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v8 = *(_DWORD *)(a1 + 20);
  if (v8 != 11 || (v8 = *(_DWORD *)(a2 + 20), v8 != 11))
    _CGHandleAssert("flexGTC_get_icc_md5", 48, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not FlexGTC based. type = %d", a6, a7, a8, v8);
  v9 = *(_QWORD *)(a1 + 88);
  v10 = *(_QWORD *)(a2 + 88);
  if (v9 == v10)
    return 1;
  v12 = *(_QWORD *)(v9 + 8);
  v11 = *(_QWORD *)(v9 + 16);
  v14 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 16);
  return v12 == v14 && v11 == v13;
}

CFTypeRef flexGTC_create_icc_profile_ascii_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;
  CFTypeRef result;

  v8 = *(_QWORD *)(a1 + 24);
  v9 = *(_DWORD *)(v8 + 20);
  if (v9 != 6 && v9 != 11)
    _CGHandleAssert("flexGTC_create_icc_profile_ascii_description", 148, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "space->state->type == kCGColorSpaceICCBased || space->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace must be ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 20));
  result = *(CFTypeRef *)(*(_QWORD *)(v8 + 88) + 40);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_3())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileIsHLGBased");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  color_space_state_create_flexGTC_proxy_f_10 = v1;
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke_2())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileIsPQBased");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  color_space_state_create_flexGTC_proxy_f_5 = v1;
  return result;
}

uint64_t (*__color_space_state_create_flexGTC_proxy_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileIsWideGamut");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  color_space_state_create_flexGTC_proxy_f = v1;
  return result;
}

uint64_t CGColorSpaceFlexGTCProxyGetFlexGTCProfile(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t FlexGTCProfile_f;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFDictionary *MutableCopy;
  __CFDictionary *v9;
  const __CFDictionary *Value;
  __CFDictionary *v11;
  __CFDictionary *v12;

  v2 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v3 + 20) != 11)
    goto LABEL_9;
  v4 = *(_QWORD *)(v3 + 88);
  FlexGTCProfile_f = *(_QWORD *)(v4 + 80);
  if (FlexGTCProfile_f)
    goto LABEL_10;
  v6 = (const __CFDictionary *)(*(uint64_t (**)(void))(*(_QWORD *)(v4 + 56) + 16))();
  if (!v6)
  {
LABEL_9:
    FlexGTCProfile_f = 0;
    goto LABEL_10;
  }
  v7 = v6;
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v6);
  if (MutableCopy)
  {
    v9 = MutableCopy;
    Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("com.apple.ColorSync.MonoGainMapParams"));
    v11 = CFDictionaryCreateMutableCopy(0, 0, Value);
    if (v11)
    {
      v12 = v11;
      CFDictionarySetValue(v11, CFSTR("com.apple.ColorSync.GUID"), *(const void **)(v4 + 48));
      CFDictionarySetValue(v9, CFSTR("com.apple.ColorSync.MonoGainMapParams"), v12);
      if (CGColorSpaceFlexGTCProxyGetFlexGTCProfile_cglibrarypredicate != -1)
        dispatch_once(&CGColorSpaceFlexGTCProxyGetFlexGTCProfile_cglibrarypredicate, &__block_literal_global_36_6043);
      FlexGTCProfile_f = CGColorSpaceFlexGTCProxyGetFlexGTCProfile_f(*(_QWORD *)v4, v7);
      *(_QWORD *)(v4 + 80) = FlexGTCProfile_f;
      CFRelease(v12);
    }
    else
    {
      FlexGTCProfile_f = 0;
    }
    CFRelease(v9);
  }
  else
  {
    FlexGTCProfile_f = 0;
  }
  CFRelease(v7);
LABEL_10:
  pthread_mutex_unlock(v2);
  return FlexGTCProfile_f;
}

uint64_t CGColorSpaceCopyFlexGTCInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v8;
  const void *v9;
  CFTypeID v10;
  uint64_t v11;

  v8 = CGColorSpaceCopyColorSyncProfile(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = CFGetTypeID(v8);
  if (CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate != -1)
    dispatch_once(&CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate, &__block_literal_global_39_6048);
  if (v10 == CGColorSpaceCopyFlexGTCInfo_f())
  {
    if (CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate_42 != -1)
      dispatch_once(&CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate_42, &__block_literal_global_44);
    v11 = CGColorSpaceCopyFlexGTCInfo_f_41(v9);
  }
  else
  {
    v11 = 0;
  }
  CFRelease(v9);
  return v11;
}

BOOL CGColorSpaceContainsFlexGTCInfo(_BOOL8 result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeID v9;
  int v10;
  const void *v11;

  if (result)
  {
    v1 = result;
    v9 = CFGetTypeID((CFTypeRef)result);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1)
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_77);
    if (v9 == CGColorSpaceGetTypeID_type_id)
    {
      v10 = *(_DWORD *)(*(_QWORD *)(v1 + 24) + 20);
      if (v10 == 11)
        return 1;
      if (v10 == 6)
      {
        v11 = (const void *)CGColorSpaceCopyFlexGTCInfo(v1, v2, v3, v4, v5, v6, v7, v8);
        result = v11 != 0;
        if (!v11)
          return result;
        CFRelease(v11);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t CGColorSpaceCreateFlexGTCProxy(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t v5;
  CFUUIDRef v9;
  CFUUIDRef v10;
  uint64_t v11;
  int v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  CFDictionaryRef v18;
  CFTypeRef v19;
  CFDictionaryRef v20;
  uint64_t flexGTX_profile_stub_f;
  uint64_t v22;
  int v23;
  const void **v24;
  const void *v25;
  _BYTE *v26;
  uint64_t v27;
  char flexGTC_proxy_f_10;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t flexGTC_proxy_f_20;
  const __CFString *v33;
  uint64_t flexGTC_proxy_f_26;
  const __CFString *v35;
  CFTypeRef v36;
  _OWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CC_MD5_CTX *v42;
  uint64_t v43;
  uint64_t i;
  float v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  unsigned int v55;
  __int128 v56;
  int valuePtr;
  void *values;
  CFTypeRef cf;
  CFNumberRef v60;
  CFNumberRef v61;
  CFNumberRef v62;
  CFNumberRef v63;
  CFNumberRef v64;
  CFNumberRef v65;
  void *keys[2];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v5 = *(_QWORD *)(a1 + 24);
  if (!*(_BYTE *)(v5 + 16) || !*(_QWORD *)(v5 + 72))
    return 0;
  v9 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v10 = v9;
  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_DWORD *)(v11 + 20);
  if (v12 == 11)
  {
    v13 = *(uint64_t **)(v11 + 88);
  }
  else
  {
    if (v12 != 6)
    {
      v16 = 0;
      goto LABEL_12;
    }
    v13 = (uint64_t *)(*(_QWORD *)(v11 + 88) + 16);
  }
  v16 = *v13;
LABEL_12:
  *(_OWORD *)keys = xmmword_1E1646030;
  v67 = *(_OWORD *)&off_1E1646040;
  v68 = xmmword_1E1646050;
  v69 = *(_OWORD *)off_1E1646060;
  values = v9;
  valuePtr = 1069547520;
  cf = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  valuePtr = 1075838976;
  v60 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  valuePtr = 1080033280;
  v61 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  valuePtr = 1083179008;
  v62 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  valuePtr = 1085276160;
  v63 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  valuePtr = 1087373312;
  v64 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  valuePtr = 1089470464;
  v65 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  v17 = 8;
  v18 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 8, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  do
  {
    CFRelease(*(void **)((char *)&values + v17));
    v17 += 8;
  }
  while (v17 != 64);
  if (create_node_table_predicate != -1)
    dispatch_once(&create_node_table_predicate, &__block_literal_global_71_6055);
  v19 = (CFTypeRef)create_node_table_node_table;
  if (create_node_table_node_table)
    v19 = CFRetain((CFTypeRef)create_node_table_node_table);
  *(_OWORD *)keys = xmmword_1E1646020;
  values = v18;
  cf = v19;
  v20 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFRelease(values);
  CFRelease(cf);
  if (create_flexGTX_profile_stub_cglibrarypredicate != -1)
    dispatch_once(&create_flexGTX_profile_stub_cglibrarypredicate, &__block_literal_global_53_6056);
  flexGTX_profile_stub_f = create_flexGTX_profile_stub_f(v16, v20);
  if (v20)
    CFRelease(v20);
  v22 = *(_QWORD *)(a1 + 24);
  v23 = *(_DWORD *)(v22 + 20);
  switch(v23)
  {
    case 6:
      v24 = (const void **)(*(_QWORD *)(v22 + 88) + 56);
      break;
    case 10:
      v24 = (const void **)(*(_QWORD *)(v22 + 88) + 48);
      break;
    case 8:
      v24 = (const void **)(*(_QWORD *)(v22 + 88) + 8);
      break;
    default:
      v25 = 0;
      if (!flexGTX_profile_stub_f)
        goto LABEL_69;
      goto LABEL_31;
  }
  v25 = *v24;
  if (!flexGTX_profile_stub_f)
    goto LABEL_69;
LABEL_31:
  v26 = malloc_type_calloc(0x70uLL, 1uLL, 0x7405B4D7uLL);
  v27 = (uint64_t)v26;
  if (!v26)
    goto LABEL_70;
  *(_DWORD *)v26 = 1;
  v26[12] = 1;
  *((_DWORD *)v26 + 2) = 0x10000;
  if (color_space_state_create_flexGTC_proxy_cglibrarypredicate != -1)
    dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate, &__block_literal_global_6015);
  *(_BYTE *)(v27 + 14) = color_space_state_create_flexGTC_proxy_f(flexGTX_profile_stub_f);
  *(_BYTE *)(v27 + 15) = 1;
  if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_6 != -1)
    dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_6, &__block_literal_global_8_6016);
  *(_BYTE *)(v27 + 16) = color_space_state_create_flexGTC_proxy_f_5(flexGTX_profile_stub_f);
  if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_11 != -1)
    dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_11, &__block_literal_global_13);
  flexGTC_proxy_f_10 = color_space_state_create_flexGTC_proxy_f_10(flexGTX_profile_stub_f);
  *(_QWORD *)(v27 + 20) = 0x10000000BLL;
  *(_BYTE *)(v27 + 17) = flexGTC_proxy_f_10;
  *(_BYTE *)(v27 + 13) = 0;
  *(_QWORD *)(v27 + 40) = 3;
  *(_QWORD *)(v27 + 104) = flexGTC_vtable;
  *(_DWORD *)(v27 + 28) = 1;
  *(_QWORD *)(v27 + 80) = 0;
  *(_QWORD *)(v27 + 72) = 0;
  *(_QWORD *)(v27 + 32) = &icc_get_default_color_components_components03;
  v29 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F20409491EBA0uLL);
  *(_QWORD *)(v27 + 88) = v29;
  if (v29)
  {
    v30 = v29;
    *v29 = flexGTX_profile_stub_f;
    if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_16 != -1)
      dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_16, &__block_literal_global_18_6017);
    v30[1] = color_space_state_create_flexGTC_proxy_f_15(flexGTX_profile_stub_f);
    v30[2] = v31;
    if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_21 != -1)
      dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_21, &__block_literal_global_23);
    flexGTC_proxy_f_20 = color_space_state_create_flexGTC_proxy_f_20(flexGTX_profile_stub_f);
    if (flexGTC_proxy_f_20)
      v33 = (const __CFString *)flexGTC_proxy_f_20;
    else
      v33 = CFSTR("<no description>");
    v30[3] = v33;
    if (v25)
      CFRetain(v25);
    v30[4] = v25;
    if (color_space_state_create_flexGTC_proxy_cglibrarypredicate_27 != -1)
      dispatch_once(&color_space_state_create_flexGTC_proxy_cglibrarypredicate_27, &__block_literal_global_29_6019);
    flexGTC_proxy_f_26 = color_space_state_create_flexGTC_proxy_f_26(flexGTX_profile_stub_f);
    if (flexGTC_proxy_f_26)
      v35 = (const __CFString *)flexGTC_proxy_f_26;
    else
      v35 = CFSTR("<no description>");
    v30[5] = v35;
    if (v10)
      v36 = CFRetain(v10);
    else
      v36 = 0;
    v30[6] = v36;
    v37 = malloc_type_malloc(0x30uLL, 0x100004000313F17uLL);
    v30[11] = v37;
    if (v37)
    {
      *v37 = xmmword_185004A20;
      v37[1] = xmmword_185004A20;
      v37[2] = xmmword_185004A20;
      keys[0] = 0;
      keys[1] = 0;
      if (*(_DWORD *)(v27 + 20) != 11)
        _CGHandleAssert("flexGTC_get_md5", 26, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_FlexGTCProxy.c", "state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not FlexGTC based. type = %d", v38, v39, v40, *(_DWORD *)(v27 + 20));
      v41 = *(_QWORD *)(v27 + 88);
      v42 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
      CC_MD5_Init(v42);
      if (v42)
      {
        CC_MD5_Update(v42, (const void *)(v27 + 20), 4u);
        CC_MD5_Update(v42, (const void *)(v41 + 8), 0x10u);
      }
      v43 = 2 * *(_QWORD *)(v27 + 40);
      if (v43)
      {
        for (i = 0; i != v43; ++i)
        {
          v45 = *(double *)(*(_QWORD *)(v41 + 88) + 8 * i);
          *(float *)&values = v45;
          if (v42)
            CC_MD5_Update(v42, &values, 4u);
        }
      }
      if (v42)
      {
        CC_MD5_Final((unsigned __int8 *)keys, v42);
        v46 = *(_OWORD *)keys;
      }
      else
      {
        v46 = 0uLL;
      }
      v56 = v46;
      free(v42);
      *(_OWORD *)(v27 + 56) = v56;
      goto LABEL_70;
    }
    free(*(void **)(v27 + 88));
  }
  free((void *)v27);
LABEL_69:
  v27 = 0;
LABEL_70:
  *(_QWORD *)(*(_QWORD *)(v27 + 88) + 56) = _Block_copy(a3);
  *(_QWORD *)(*(_QWORD *)(v27 + 88) + 64) = _Block_copy(a4);
  *(_QWORD *)(*(_QWORD *)(v27 + 88) + 72) = a2;
  v14 = CGColorSpaceCreateWithState((unsigned int *)v27, v47, v48, v49, v50, v51, v52, v53);
  do
  {
    v54 = __ldxr((unsigned int *)v27);
    v55 = v54 - 1;
  }
  while (__stxr(v55, (unsigned int *)v27));
  if (!v55)
    color_space_state_dealloc(v27);
  if (v10)
    CFRelease(v10);
  return v14;
}

uint64_t (*__create_flexGTX_profile_stub_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateCopyWithFlexGTC");
  v1 = colorsync_smart_null_6025;
  if (result)
    v1 = result;
  create_flexGTX_profile_stub_f = (uint64_t (*)(_QWORD, _QWORD))v1;
  return result;
}

void __create_node_table_block_invoke()
{
  float v0;
  char v1;
  const CFDictionaryKeyCallBacks *v2;
  const CFDictionaryValueCallBacks *v3;
  char v4;
  float v5;
  CFDictionaryRef v6;
  uint64_t i;
  float valuePtr;
  void *values;
  CFNumberRef v10;
  CFNumberRef v11;
  void *keys[2];
  const __CFString *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  create_node_table_node_table = (uint64_t)CFArrayCreateMutable(0, 2, MEMORY[0x1E0C9B378]);
  v0 = 0.0;
  v1 = 1;
  v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v4 = v1;
    *(_OWORD *)keys = xmmword_1E16460B0;
    v5 = (float)(v0 * 0.3) + 0.4;
    v13 = CFSTR("com.apple.ColorSync.FlexGTCNodeSlope");
    values = 0;
    v10 = 0;
    v11 = 0;
    valuePtr = v5;
    values = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    valuePtr = v5 + 0.5;
    v10 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    valuePtr = v5 + 0.7;
    v11 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 3, v2, v3);
    for (i = 0; i != 24; i += 8)
      CFRelease(*(void **)((char *)&values + i));
    CFArrayAppendValue((CFMutableArrayRef)create_node_table_node_table, v6);
    CFRelease(v6);
    v1 = 0;
    v0 = 1.0;
  }
  while ((v4 & 1) != 0);
}

CFStringRef data_provider_copy_format_description(uint64_t a1)
{
  if (os_variant_has_internal_content())
    return data_provider_copy_debug_string(a1, 0);
  else
    return 0;
}

CFStringRef data_provider_copy_debug_description(uint64_t a1)
{
  if (os_variant_has_internal_content())
    return data_provider_copy_debug_string(a1, 0);
  else
    return 0;
}

CFStringRef data_provider_copy_debug_string(uint64_t a1, const __CFString *a2)
{
  __int128 v4;
  __int128 v5;
  uint64_t i;
  const void *v7;
  uint64_t v8;
  const char *v9;
  CFStringRef v10;
  const __CFString *v11;
  Dl_info v13;
  char *v14;
  char __str[128];
  char v16[1161];
  _OWORD v17[4];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v14 = 0;
  v4 = *(_OWORD *)(a1 + 56);
  v17[0] = *(_OWORD *)(a1 + 40);
  v17[1] = v4;
  v5 = *(_OWORD *)(a1 + 88);
  v17[2] = *(_OWORD *)(a1 + 72);
  v17[3] = v5;
  v18 = *(_QWORD *)(a1 + 112);
  bzero(v16, 0x489uLL);
  for (i = 0; i != 72; i += 8)
  {
    v7 = *(const void **)((char *)v17 + i);
    if (v7)
    {
      memset(&v13, 0, sizeof(v13));
      if (dladdr(v7, &v13))
        snprintf(__str, 0x80uLL, "%s %s:%s");
      else
        snprintf(__str, 0x80uLL, "%s %p");
      __strcat_chk();
      __strcat_chk();
    }
  }
  v8 = *(unsigned int *)(a1 + 20);
  if (v8 > 3)
    v9 = "?";
  else
    v9 = off_1E1646198[v8];
  asprintf(&v14, "CGDataProvider: %p type: %s size: %lld retain count: %d retained pointer: %p\n%s", (const void *)a1, v9, *(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 252), *(const void **)(a1 + 264), v16);
  v11 = &stru_1E1664C98;
  if (a2)
    v11 = a2;
  v10 = CFStringCreateWithFormat(0, 0, CFSTR("%s\n%@"), v14, v11);
  free(v14);
  return v10;
}

CGDataProviderRef CGDataProviderCreateSequential(void *info, const CGDataProviderSequentialCallbacks *callbacks)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CGDataProvider *v9;
  uint64_t provider;
  const __CFData *v12;
  CGDataProvider *v13;

  if (!callbacks || !callbacks->getBytes || callbacks->version)
    return 0;
  provider = create_provider((uint64_t)info, 1, v2, v3, v4, v5, v6, v7);
  v9 = (CGDataProvider *)provider;
  if (provider)
  {
    *(_OWORD *)(provider + 40) = *(_OWORD *)&callbacks->getBytes;
    *(_OWORD *)(provider + 64) = *(_OWORD *)&callbacks->rewind;
    if (!CGDataProviderIsRewindable(provider))
    {
      v12 = CGDataProviderCopyData(v9);
      v13 = CGDataProviderCreateWithCFData(v12);
      if (v12)
        CFRelease(v12);
      CFRelease(v9);
      return v13;
    }
  }
  return v9;
}

BOOL CGDataProviderIsRewindable(uint64_t a1)
{
  CFTypeID v2;

  v2 = CFGetTypeID((CFTypeRef)a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1)
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_26_6088);
  return v2 == CGDataProviderGetTypeID_id && (*(_DWORD *)(a1 + 20) & 0xFFFFFFFD) == 1 && *(_QWORD *)(a1 + 64) != 0;
}

uint64_t CGDataProviderCreateSequentialWithInternalCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (!a2)
    return 0;
  if (*(_DWORD *)a2 != 1 || !*(_QWORD *)(a2 + 24) || !*(_QWORD *)(a2 + 16))
    return 0;
  result = create_provider(a1, 1, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 24);
    *(_QWORD *)(result + 120) = *(_QWORD *)(a2 + 40);
    *(_OWORD *)(result + 144) = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(result + 160) = *(_OWORD *)(a2 + 64);
    *(_QWORD *)(result + 176) = *(_QWORD *)(a2 + 80);
  }
  return result;
}

uint64_t CGDataProviderCreateMultiRangeDirectAccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (a2 <= 0)
  {
    CGPostError((uint64_t)"%s: Invalid size = %lld", a2, a3, a4, a5, a6, a7, a8, (char)"CGDataProviderCreateMultiRangeDirectAccess");
    if (!a3)
      return 0;
  }
  else if (!a3)
  {
    return 0;
  }
  result = 0;
  if (a2 >= 1 && !*(_DWORD *)a3)
  {
    if (!*(_QWORD *)(a3 + 8) && !*(_QWORD *)(a3 + 16))
      return 0;
    result = create_provider(a1, 0, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      *(_QWORD *)(result + 32) = a2;
      *(_OWORD *)(result + 96) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(result + 72) = *(_QWORD *)(a3 + 24);
    }
  }
  return result;
}

uint64_t CGDataProviderGetType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!a1)
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, vars0);
  return *(unsigned int *)(a1 + 20);
}

uint64_t CGDataProviderGetBytes(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeID v13;
  char v15;

  if (!a1)
    return 0;
  v13 = CFGetTypeID(a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1)
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_26_6088);
  if (v13 != CGDataProviderGetTypeID_id)
  {
    CGPostError((uint64_t)"%s - bad argument", v6, v7, v8, v9, v10, v11, v12, (char)"CGDataProviderGetBytes");
    return 0;
  }
  if ((a1[5] & 0xFFFFFFFD) != 1)
    _CGHandleAssert("CGDataProviderGetBytes", 557, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider)", "provider is not sequential", v10, v11, v12, v15);
  return CGDataProviderSequentialGetBytesInternal((uint64_t)a1, a2, a3);
}

void CGDataProviderRewind(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeID v9;
  void (*v10)(_QWORD);
  char v11;

  if (a1)
  {
    v9 = CFGetTypeID((CFTypeRef)a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1)
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_26_6088);
    if (v9 == CGDataProviderGetTypeID_id)
    {
      if ((*(_DWORD *)(a1 + 20) & 0xFFFFFFFD) != 1)
        _CGHandleAssert("CGDataProviderRewind", 583, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider)", "provider is not sequential", v6, v7, v8, v11);
      v10 = *(void (**)(_QWORD))(a1 + 64);
      if (v10)
        v10(*(_QWORD *)(a1 + 24));
      *(_BYTE *)(a1 + 261) = 0;
    }
    else
    {
      CGPostError((uint64_t)"%s - bad argument", v2, v3, v4, v5, v6, v7, v8, (char)"CGDataProviderRewind");
    }
  }
}

uint64_t CGDataProviderSkipForwardInternal(uint64_t a1, uint64_t a2)
{
  unint64_t BytesInternal;
  uint64_t (*v4)(_QWORD, uint64_t);
  void (*v5)(_QWORD, uint64_t);
  uint64_t v6;
  char *v7;
  char *v8;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  if (a2 < 1)
    return 0;
  BytesInternal = a2;
  v4 = *(uint64_t (**)(_QWORD, uint64_t))(a1 + 48);
  if (v4)
  {
    BytesInternal = v4(*(_QWORD *)(a1 + 24), a2);
    if (!BytesInternal)
      *(_BYTE *)(a1 + 261) = 1;
  }
  else
  {
    v5 = *(void (**)(_QWORD, uint64_t))(a1 + 56);
    if (v5)
    {
      v5(*(_QWORD *)(a1 + 24), a2);
    }
    else
    {
      MEMORY[0x1E0C80A78]();
      v7 = (char *)v10 - v6;
      if (BytesInternal > 0x400)
      {
        v8 = (char *)malloc_type_malloc(BytesInternal, 0x59FA0E00uLL);
        BytesInternal = CGDataProviderSequentialGetBytesInternal(a1, (uint64_t)v8, BytesInternal);
        if (v8 != v7)
          free(v8);
      }
      else
      {
        return CGDataProviderSequentialGetBytesInternal(a1, (uint64_t)v10 - v6, BytesInternal);
      }
    }
  }
  return BytesInternal;
}

void CGDataProviderSkipForward(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFTypeID v7;
  char v8;

  if (a1)
  {
    v7 = CFGetTypeID(a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1)
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_26_6088);
    if (v7 == CGDataProviderGetTypeID_id)
    {
      if ((a1[5] & 0xFFFFFFFD) != 1)
        _CGHandleAssert("CGDataProviderSkipForward", 631, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider)", "provider is not sequential", v4, v5, v6, v8);
      CGDataProviderSkipForwardInternal((uint64_t)a1, a2);
    }
  }
}

void CGDataProviderGetBytesInRanges(_QWORD *a1, __CFArray *a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;
  void (*v9)(_QWORD, __CFArray *, uint64_t, uint64_t);
  CFIndex v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  size_t *v13;
  char *v14;
  const UInt8 *v15;
  CFDataRef v16;
  CFDataRef v17;

  if (a1)
  {
    v8 = CFGetTypeID(a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1)
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_26_6088);
    if (v8 == CGDataProviderGetTypeID_id)
    {
      v9 = (void (*)(_QWORD, __CFArray *, uint64_t, uint64_t))a1[13];
      if (v9)
      {
        v9(a1[3], a2, a3, a4);
      }
      else if (a4)
      {
        v10 = 0;
        v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE10];
        v13 = (size_t *)(a3 + 8);
        do
        {
          v14 = (char *)malloc_type_malloc(*v13, 0x47D328A9uLL);
          if (v14)
          {
            v15 = (const UInt8 *)v14;
            CGDataProviderGetBytesAtPosition((uint64_t)a1, v14, *(v13 - 1), *v13);
            v16 = CFDataCreateWithBytesNoCopy(v11, v15, *v13, v12);
            if (v16)
            {
              v17 = v16;
              CFArraySetValueAtIndex(a2, v10, v16);
              CFRelease(v17);
            }
          }
          ++v10;
          v13 += 2;
        }
        while (a4 != v10);
      }
    }
  }
}

const void *CGDataProviderGetProperty(uint64_t a1, const void *a2)
{
  uint64_t v2;

  if (a1 && a2 && (v2 = *(_QWORD *)(a1 + 272)) != 0)
    return CGPropertiesGetProperty(v2, a2);
  else
    return 0;
}

void CGDataProviderUngetBytePtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((CGDataProviderUngetBytePtr_warned & 1) == 0)
  {
    CGDataProviderUngetBytePtr_warned = 1;
  }
  CGDataProviderReleaseBytePtr(a1);
}

uint64_t CGDataProviderGetBytePtr(uint64_t a1)
{
  if (CGDataProviderGetBytePtr_predicate != -1)
    dispatch_once(&CGDataProviderGetBytePtr_predicate, &__block_literal_global_31);
  return CGDataProviderRetainBytePtr(a1);
}

void *__cdecl CGDataProviderGetInfo(void *provider)
{
  if (provider)
    return (void *)*((_QWORD *)provider + 3);
  return provider;
}

void pdf_object_scanner_release(uint64_t *a1)
{
  if (a1)
  {
    pdf_lexer_release(a1[2]);
    free(a1);
  }
}

uint64_t *pdf_object_scanner_set_source(uint64_t *result, const void *a2)
{
  uint64_t *v3;

  if ((const void *)result[1] != a2)
  {
    v3 = result;
    pdf_lexer_release(result[2]);
    result = pdf_lexer_create(*v3, a2, 2 * *((unsigned __int8 *)v3 + 24));
    v3[1] = (uint64_t)a2;
    v3[2] = (uint64_t)result;
  }
  return result;
}

void handle_choke(uint64_t a1)
{
  uint64_t v1;

  if (!a1 || *(_DWORD *)(a1 + 8) != 6 || (v1 = *(_QWORD *)(a1 + 32)) == 0)
  {
LABEL_10:
    return;
  }
  if (*(_QWORD *)(v1 + 24))
    decrypt_string(*(_QWORD *)(a1 + 32));
  if (*(_QWORD *)(v1 + 72) < 0x33uLL)
  {
    if (*(_QWORD *)(v1 + 24))
      decrypt_string(v1);
    goto LABEL_10;
  }
  if (*(_QWORD *)(v1 + 24))
    decrypt_string(v1);
}

void Type1Subset::~Type1Subset(Type1Subset *this)
{
  FontSubset::~FontSubset(this);
  JUMPOUT(0x186DC23C4);
}

void Type1Subset::emit_definition(Type1Subset *this)
{
  const PDFFont *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  std::vector<char>::size_type v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned __int16 *v77;
  uint64_t v78;
  char v79;
  int v80;
  BOOL v81;
  std::vector<char>::pointer begin;
  std::vector<char>::pointer end;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  const PDFFont *v124;
  _QWORD v125[3];
  _QWORD v126[3];
  std::vector<char> v127;

  if (*((_QWORD *)this + 13))
  {
    v2 = (const PDFFont *)*((_QWORD *)this + 1);
    FontDescriptor::FontDescriptor((FontDescriptor *)v125, v2, *((_DWORD *)this + 10) == 1);
    v3 = **((_QWORD **)v2 + 1);
    PDFDocumentBeginObject(v3, *((_QWORD *)this + 6), v4, v5, v6, v7, v8, v9);
    PDFDocumentPrintf(v3, (uint64_t)"<<", v10, v11, v12, v13, v14, v15, v116);
    PDFDocumentPrintf(v3, (uint64_t)"/Type /Font", v16, v17, v18, v19, v20, v21, v117);
    PDFDocumentPrintf(v3, (uint64_t)"/Subtype /Type1", v22, v23, v24, v25, v26, v27, v118);
    v35 = (char *)this + 64;
    v34 = (char *)*((_QWORD *)this + 8);
    if (*((char *)this + 87) >= 0)
      v34 = (char *)this + 64;
    PDFDocumentPrintf(v3, (uint64_t)"/BaseFont /%N", v28, v29, v30, v31, v32, v33, (uint64_t)v34);
    PDFDocumentPrintReference(v3, (uint64_t)"/FontDescriptor %R", v125[1], v36, v37, v38, v39, v40);
    v47 = *((_QWORD *)this + 1);
    v48 = **(_QWORD **)(v47 + 8);
    if (*((_DWORD *)this + 10) == 1)
    {
      PDFDocumentPrintf(**(_QWORD **)(v47 + 8), (uint64_t)"/Encoding /MacRomanEncoding", v41, v42, v43, v44, v45, v46, v119);
    }
    else
    {
      v49 = *(_QWORD *)(v47 + 16);
      if (v49)
      {
        v50 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(v49 + 16) + 288))(*(_QWORD *)(v49 + 112));
        if (v50)
        {
          v57 = v50;
          v124 = v2;
          PDFDocumentPrintf(v48, (uint64_t)"/Encoding <<", v51, v52, v53, v54, v55, v56, v119);
          PDFDocumentPrintf(v48, (uint64_t)"/Type /Encoding", v58, v59, v60, v61, v62, v63, v120);
          PDFDocumentPrintf(v48, (uint64_t)"/Differences [", v64, v65, v66, v67, v68, v69, v121);
          std::vector<char>::vector(&v127, v57);
          FontSubset::get_encoding_vector((FontSubset *)v126, (uint64_t)this);
          v76 = 0;
          v77 = (unsigned __int16 *)v126[0];
          v78 = (uint64_t)(v126[1] - v126[0]) >> 1;
          v79 = 1;
          do
          {
            if (v78 == v76)
            {
LABEL_29:
              __break(1u);
              return;
            }
            v80 = v77[v76];
            v81 = v80 == 0xFFFF;
            if (v80 != 0xFFFF)
            {
              if ((v79 & 1) != 0)
                PDFDocumentPrintf(v48, (uint64_t)"%d", v70, v71, v72, v73, v74, v75, v76);
              begin = v127.__begin_;
              end = v127.__end_;
              if (v127.__end_ == v127.__begin_)
                goto LABEL_29;
              v84 = *(_QWORD *)(v47 + 16);
              if (v84)
              {
                (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v84 + 16) + 296))(*(_QWORD *)(v84 + 112), v77[v76]);
                begin = v127.__begin_;
                end = v127.__end_;
              }
              if (end == begin)
                goto LABEL_29;
              PDFDocumentPrintf(v48, (uint64_t)"/%N", (uint64_t)begin, v71, v72, v73, v74, v75, (uint64_t)begin);
            }
            ++v76;
            v79 = v81;
          }
          while (v76 != 256);
          PDFDocumentPrintf(v48, (uint64_t)"]", v70, v71, v72, v73, v74, v75, v122);
          PDFDocumentPrintf(v48, (uint64_t)">>", v85, v86, v87, v88, v89, v90, v123);
          operator delete(v77);
          v2 = v124;
          v35 = (char *)this + 64;
          if (v127.__begin_)
          {
            v127.__end_ = v127.__begin_;
            operator delete(v127.__begin_);
          }
        }
      }
    }
    if (*((_DWORD *)this + 10) == 1)
    {
      v91 = 0;
    }
    else
    {
      v91 = PDFXRefTableAddObject(*(_QWORD **)(v3 + 464));
      PDFDocumentPrintReference(v3, (uint64_t)"/ToUnicode %R", v91, v92, v93, v94, v95, v96);
    }
    FontSubset::emit_widths(this);
    PDFDocumentPrintf(v3, (uint64_t)">>", v97, v98, v99, v100, v101, v102, v119);
    PDFDocumentEndObject(v3, v103, v104, v105, v106, v107, v108, v109);
    if (v91)
    {
      v126[0] = v2;
      FontSubset::get_encoding_vector((FontSubset *)&v127, (uint64_t)this);
      ToUnicode::write<std::vector<unsigned short>>((uint64_t)v126, v91, &v127);
      if (v127.__begin_)
        operator delete(v127.__begin_);
    }
    v110 = PDFXRefTableAddObject(*(_QWORD **)(v3 + 464));
    FontDescriptor::emit_definition(v125, (uint64_t)v35, v110, v111, v112, v113, v114, v115);
    (*(void (**)(Type1Subset *, uint64_t))(*(_QWORD *)this + 24))(this, v110);
  }
}

void sub_184BE3244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_BYTE *Type1Subset::emit_font_file(Type1Subset *this, uint64_t a2)
{
  const __CFData *embedded_font_data;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  CFIndex v43;
  char *p_p;
  uint64_t v45;
  char *v46;
  int v47;
  int v48;
  CFIndex v49;
  const UInt8 *v50;
  unsigned __int8 *v51;
  CFIndex v52;
  char *v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const UInt8 *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char v64;
  uint64_t v65;
  char *v66;
  const UInt8 *v67;
  unsigned __int8 *v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  void **v73;
  const UInt8 *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  void *v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  BOOL v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  unsigned __int8 *v90;
  unsigned __int8 *v91;
  const UInt8 *v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  unsigned __int8 *v97;
  uint64_t v98;
  const UInt8 *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  void *v169[2];
  unsigned __int8 v170;
  void *__p;
  uint64_t v172;
  unsigned __int8 v173;

  embedded_font_data = (const __CFData *)Type1Subset::create_embedded_font_data(this);
  v5 = **(_QWORD **)(*((_QWORD *)this + 1) + 8);
  v6 = PDFStreamCreateWithObjectNumber(v5, a2);
  PDFDocumentBeginObject(*v6, v6[1], v7, v8, v9, v10, v11, v12);
  PDFDocumentPrintf(*v6, (uint64_t)"<<", v13, v14, v15, v16, v17, v18, v164);
  v19 = PDFXRefTableAddObject(*(_QWORD **)(v5 + 464));
  PDFDocumentPrintReference(v5, (uint64_t)"/Length1 %R", v19, v20, v21, v22, v23, v24);
  v25 = PDFXRefTableAddObject(*(_QWORD **)(v5 + 464));
  PDFDocumentPrintReference(v5, (uint64_t)"/Length2 %R", v25, v26, v27, v28, v29, v30);
  v31 = PDFXRefTableAddObject(*(_QWORD **)(v5 + 464));
  PDFDocumentPrintReference(v5, (uint64_t)"/Length3 %R", v31, v32, v33, v34, v35, v36);
  PDFStreamBeginData((CGDataConsumerRef)v6);
  if (!embedded_font_data)
  {
    v57 = 0;
    v58 = 0;
    v59 = 0;
    goto LABEL_134;
  }
  Length = CFDataGetLength(embedded_font_data);
  BytePtr = CFDataGetBytePtr(embedded_font_data);
  v39 = v6[3];
  if (v39)
    v40 = (uint64_t *)(v39 + 40);
  else
    v40 = v6 + 2;
  v41 = *v40;
  std::string::basic_string[abi:se180100]<0>((char **)&__p, "eexec");
  v42 = (unint64_t)&BytePtr[Length];
  v43 = v173;
  if ((v173 & 0x80u) == 0)
    p_p = (char *)&__p;
  else
    p_p = (char *)__p;
  if ((v173 & 0x80u) != 0)
    v43 = v172;
  v166 = v41;
  if (v43)
  {
    if (Length < v43)
      goto LABEL_31;
    v45 = v42 - v43 + 1;
    if ((const UInt8 *)v45 == BytePtr)
      goto LABEL_31;
    v48 = *p_p;
    v46 = p_p + 1;
    v47 = v48;
    v49 = v43 - 1;
    v50 = BytePtr;
    while (*v50 != v47)
    {
LABEL_18:
      if (++v50 == (const UInt8 *)v45)
        goto LABEL_31;
    }
    v51 = (unsigned __int8 *)(v50 + 1);
    v52 = v49;
    v53 = v46;
    while (v52)
    {
      v55 = *v51++;
      v54 = v55;
      v56 = *v53++;
      --v52;
      if (v54 != v56)
        goto LABEL_18;
    }
  }
  else
  {
    v50 = BytePtr;
  }
  if ((const UInt8 *)v42 == v50)
  {
LABEL_31:
    v60 = 0;
    v64 = 1;
    goto LABEL_35;
  }
  v60 = v50 + 5;
  if ((unint64_t)(v50 + 5) >= v42)
  {
    v64 = 0;
    goto LABEL_35;
  }
  v167 = v31;
  v61 = &BytePtr[Length] - v50 - 5;
  v62 = MEMORY[0x1E0C80978];
  while (1)
  {
    v63 = *v60;
    if (*(char *)v60 < 0)
      break;
    if ((*(_DWORD *)(v62 + 4 * v63 + 60) & 0x4000) == 0)
      goto LABEL_33;
LABEL_29:
    ++v60;
    if (!--v61)
    {
      v64 = 0;
      v60 = &BytePtr[Length];
      goto LABEL_34;
    }
  }
  if (__maskrune_l(v63, 0x4000uLL, 0))
    goto LABEL_29;
LABEL_33:
  v64 = 0;
LABEL_34:
  v31 = v167;
LABEL_35:
  if ((char)v173 < 0)
  {
    operator delete(__p);
    if ((v64 & 1) != 0)
      goto LABEL_88;
  }
  else if ((v64 & 1) != 0)
  {
    goto LABEL_88;
  }
  std::string::basic_string[abi:se180100]<0>((char **)&__p, "/Encoding StandardEncoding def");
  v65 = v173;
  if ((v173 & 0x80u) == 0)
    v66 = (char *)&__p;
  else
    v66 = (char *)__p;
  if ((v173 & 0x80u) != 0)
    v65 = v172;
  v168 = v31;
  if (BytePtr == v60 || !v65)
    goto LABEL_58;
  v67 = BytePtr;
  v68 = (unsigned __int8 *)v60;
  do
  {
    if (*v67 == *v66)
    {
      v69 = 1;
      while (v65 != v69)
      {
        if (&v67[v69] == v60)
          goto LABEL_56;
        v70 = v67[v69];
        v71 = v66[v69++];
        if (v70 != v71)
          goto LABEL_48;
      }
      v68 = (unsigned __int8 *)v67;
    }
LABEL_48:
    ++v67;
  }
  while (v67 != v60);
LABEL_56:
  if (v68 == v60)
  {
LABEL_58:
    std::string::basic_string[abi:se180100]<0>((char **)v169, "currentdict end");
    v72 = v170;
    if ((v170 & 0x80u) == 0)
      v73 = v169;
    else
      v73 = (void **)v169[0];
    if ((v170 & 0x80u) != 0)
      v72 = (unint64_t)v169[1];
    if (BytePtr == v60 || !v72)
      goto LABEL_83;
    v74 = BytePtr;
    v75 = (uint64_t)v60;
    do
    {
      if (*v74 == *(char *)v73)
      {
        v76 = 1;
        while (v72 != v76)
        {
          if (&v74[v76] == v60)
            goto LABEL_75;
          v77 = v74[v76];
          v78 = *((char *)v73 + v76++);
          if (v77 != v78)
            goto LABEL_67;
        }
        v75 = (uint64_t)v74;
      }
LABEL_67:
      ++v74;
    }
    while (v74 != v60);
LABEL_75:
    if ((const UInt8 *)v75 == v60)
    {
LABEL_83:
      v81 = 1;
    }
    else
    {
      CGDataConsumerPutBytes(v6[3], (uint64_t)BytePtr, v75 - (_QWORD)BytePtr);
      if ((v173 & 0x80u) == 0)
        v79 = &__p;
      else
        v79 = __p;
      if ((v173 & 0x80u) == 0)
        v80 = v173;
      else
        v80 = v172;
      CGDataConsumerPutBytes(v6[3], (uint64_t)v79, v80);
      CGDataConsumerPutBytes(v6[3], (uint64_t)"\n", 1);
      CGDataConsumerPutBytes(v6[3], v75, (uint64_t)&v60[-v75]);
      v81 = 0;
    }
    v31 = v168;
    if ((char)v170 < 0)
    {
      operator delete(v169[0]);
      if ((v81 & 1) == 0)
        goto LABEL_90;
    }
    else if ((v81 & 1) == 0)
    {
      goto LABEL_90;
    }
    if ((char)v173 < 0)
      operator delete(__p);
LABEL_88:
    v59 = 0;
    v58 = 0;
    v57 = 0;
  }
  else
  {
    CGDataConsumerPutBytes(v6[3], (uint64_t)BytePtr, v60 - BytePtr);
LABEL_90:
    v165 = v25;
    if ((char)v173 < 0)
      operator delete(__p);
    v82 = BytePtr - v60 + Length;
    v83 = v6[3];
    v84 = (uint64_t *)(v83 + 40);
    v85 = v83 == 0;
    v86 = v6 + 2;
    if (!v85)
      v86 = v84;
    v87 = *v86;
    std::string::basic_string[abi:se180100]<0>((char **)&__p, "cleartomark");
    v88 = v172;
    if ((v173 & 0x80u) == 0)
      v89 = (char *)&__p;
    else
      v89 = (char *)__p;
    if ((v173 & 0x80u) == 0)
      v88 = v173;
    if (!v82 || !v88)
      goto LABEL_123;
    v90 = (unsigned __int8 *)&BytePtr[Length];
    v91 = (unsigned __int8 *)v60;
    v92 = &BytePtr[Length];
    do
    {
      if (*v91 == *v89)
      {
        v93 = 1;
        while (v88 != v93)
        {
          if (&v91[v93] == v90)
            goto LABEL_111;
          v94 = v91[v93];
          v95 = v89[v93++];
          if (v94 != v95)
            goto LABEL_103;
        }
        v92 = v91;
      }
LABEL_103:
      ++v91;
    }
    while (v91 != v90);
LABEL_111:
    if (v92 != v90)
    {
      if (v92 > v60)
      {
        v96 = 0;
        v97 = (unsigned __int8 *)(v92 - 1);
        v98 = MEMORY[0x1E0C80978];
        do
        {
          v99 = v97;
          v100 = *v97;
          if (v100 == 48)
          {
            if (++v96 == 512)
            {
              CGDataConsumerPutBytes(v6[3], (uint64_t)v60, v97 - v60);
              v82 -= v99 - v60;
              v60 = v99;
              goto LABEL_125;
            }
          }
          else if ((v100 & 0x80) != 0)
          {
            if (!__maskrune_l(v100, 0x4000uLL, 0))
              break;
          }
          else if ((*(_DWORD *)(v98 + 4 * v100 + 60) & 0x4000) == 0)
          {
            break;
          }
          v97 = (unsigned __int8 *)(v99 - 1);
        }
        while (v99 > v60);
      }
      pdf_error("invalid Type1 font stream: missing 512 zeroes.");
    }
    else
    {
LABEL_123:
    }
LABEL_125:
    v59 = v87 - v166;
    if ((char)v173 < 0)
      operator delete(__p);
    v101 = v6[3];
    v102 = (uint64_t *)(v101 + 40);
    if (!v101)
      v102 = v6 + 2;
    v103 = *v102;
    v58 = *v102 - v87;
    CGDataConsumerPutBytes(v101, (uint64_t)v60, v82);
    v104 = v6[3];
    if (v104)
      v105 = (_QWORD *)(v104 + 40);
    else
      v105 = v6 + 2;
    v57 = *v105 - v103;
    v31 = v168;
    v25 = v165;
  }
  CFRelease(embedded_font_data);
LABEL_134:
  PDFStreamEndData(v6);
  PDFStreamEnd((CFDataRef *)v6);
  PDFStreamRelease((uint64_t)v6);
  PDFDocumentBeginObject(v5, v19, v106, v107, v108, v109, v110, v111);
  PDFDocumentPrintf(v5, (uint64_t)"%O", v112, v113, v114, v115, v116, v117, v59);
  PDFDocumentEndObject(v5, v118, v119, v120, v121, v122, v123, v124);
  PDFDocumentBeginObject(v5, v25, v125, v126, v127, v128, v129, v130);
  PDFDocumentPrintf(v5, (uint64_t)"%O", v131, v132, v133, v134, v135, v136, v58);
  PDFDocumentEndObject(v5, v137, v138, v139, v140, v141, v142, v143);
  PDFDocumentBeginObject(v5, v31, v144, v145, v146, v147, v148, v149);
  PDFDocumentPrintf(v5, (uint64_t)"%O", v150, v151, v152, v153, v154, v155, v57);
  return PDFDocumentEndObject(v5, v156, v157, v158, v159, v160, v161, v162);
}

void sub_184BE398C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFTypeRef Type1Subset::create_embedded_font_data(Type1Subset *this)
{
  _QWORD *v2;
  char *glyph_index_set;
  CFTypeRef embedded_font;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  glyph_index_set = FontSubset::create_glyph_index_set(this);
  embedded_font = PDFFont::create_embedded_font(v2, (uint64_t *)this + 8, (uint64_t)glyph_index_set, 0, 0);
  CGFontIndexSetRelease((uint64_t)glyph_index_set);
  if (embedded_font
    && (unint64_t)(CFDataGetLength((CFDataRef)embedded_font) - 0x80000000) <= 0xFFFFFFFF80000000)
  {
    CFRelease(embedded_font);
    return 0;
  }
  return embedded_font;
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  char *v4;
  char *v5;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    if ((__n & 0x8000000000000000) != 0)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v4 = (char *)operator new(__n);
    this->__begin_ = v4;
    v5 = &v4[__n];
    this->__end_cap_.__value_ = &v4[__n];
    bzero(v4, __n);
    this->__end_ = v5;
  }
  return this;
}

void sub_184BE3A94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RGBAf_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  unint64_t v46;
  unsigned __int8 *v47;
  int v48;
  unsigned __int8 *v49;
  unsigned int v50;
  char v51;
  unsigned int v52;
  int v53;
  int v54;
  unsigned int v55;
  char v56;
  unsigned int v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  uint64_t v60;
  uint64_t v61;
  _DWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned __int8 *v66;
  int v67;
  uint64_t v68;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 64);
  v8 = *(_QWORD *)(result + 72);
  v9 = *(_QWORD *)(result + 88);
  v68 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v11 = *(_QWORD *)(result + 120);
  v12 = *(_QWORD *)(result + 152) - 16;
  v13 = *(_QWORD *)(result + 144) - 1;
  v14 = v4
      + (3 * *(_DWORD *)(result + 256) - 3)
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      - 3;
  v67 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v8)
    {
      if ((uint64_t)a3 <= v9)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v9;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_34;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v22 | v67;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v8 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_34;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v18 | v67;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v7)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v7 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v67;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v10;
    a3 += v11;
    v12 += 16;
    *(_BYTE *)++v13 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v68)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v68;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v67;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v24 < 0x400000)
    goto LABEL_34;
  v34 = v4 + SHIDWORD(v25) * (uint64_t)v5;
  v35 = 3 * (v29 >> 32);
  v36 = v34 + v35;
  v37 = *(unsigned __int8 **)(result + 32);
  if (v14 >= v34 + v35)
    v38 = (unsigned __int8 *)(v34 + v35);
  else
    v38 = (unsigned __int8 *)v14;
  if (v38 < v37)
    v38 = *(unsigned __int8 **)(result + 32);
  v39 = (v38[1] << 16) | (*v38 << 24) | (v38[2] << 8) | 0xFF;
  if (!v6)
    goto LABEL_66;
  v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v58 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v14 < (unint64_t)v58)
        v58 = (unsigned __int8 *)v14;
      if (v58 < v37)
        v58 = v37;
      v53 = (v58[1] << 16) | (*v58 << 24) | (v58[2] << 8) | 0xFF;
      goto LABEL_64;
    case 2:
      v59 = (unsigned __int8 *)(v36 + 3 * SBYTE2(v40));
      if (v14 < (unint64_t)v59)
        v59 = (unsigned __int8 *)v14;
      if (v59 < v37)
        v59 = v37;
      v53 = (v59[1] << 16) | (*v59 << 24) | (v59[2] << 8) | 0xFF;
      v42 = (v40 >> 28) & 3;
LABEL_64:
      v55 = interpolate_8888_19472[v42];
      v56 = v42 + 1;
      v57 = v39 - ((v55 & v39) >> v56);
      goto LABEL_65;
    case 3:
      v43 = 3 * SBYTE2(v40);
      v44 = (unsigned __int8 *)(v36 + v43);
      if (v14 < v36 + v43)
        v44 = (unsigned __int8 *)v14;
      if (v44 < v37)
        v44 = v37;
      v45 = (v44[1] << 16) | (*v44 << 24) | (v44[2] << 8) | 0xFF;
      v46 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v14 >= v46)
        v47 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      else
        v47 = (unsigned __int8 *)v14;
      if (v47 < v37)
        v47 = v37;
      v48 = (v47[1] << 16) | (*v47 << 24) | (v47[2] << 8) | 0xFF;
      v49 = (unsigned __int8 *)(v46 + v43);
      if (v14 < (unint64_t)v49)
        v49 = (unsigned __int8 *)v14;
      if (v49 < v37)
        v49 = v37;
      v50 = interpolate_8888_19472[v42];
      v51 = v42 + 1;
      v52 = v39 - ((v50 & v39) >> v51) + ((v48 & v50) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((((v49[1] << 16) | (*v49 << 24) | (v49[2] << 8) | 0xFF) & v50) >> v51);
      v54 = (v40 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
LABEL_65:
      v39 = v57 + ((v53 & v55) >> v56);
      break;
  }
LABEL_66:
  v60 = 0;
  a2 += v10;
  v61 = v68 - a2;
  v62 = (_DWORD *)(v12 + 28);
  a3 += v11;
  v63 = v9 - a3;
  while (1)
  {
    *(v62 - 3) = _blt_float[HIBYTE(v39)];
    *(v62 - 2) = _blt_float[BYTE2(v39)];
    *(v62 - 1) = _blt_float[BYTE1(v39)];
    *v62 = _blt_float[v39];
    *(_BYTE *)(v13 + 1 + v60) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v60)
      return result;
    if (((v63 | v61 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
    {
      v13 += v60 + 1;
      v12 = (uint64_t)(v62 - 3);
      a4 += ~(_DWORD)v60;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v64 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v65 = 3 * (a2 >> 32);
    v36 = v64 + v65;
    v37 = *(unsigned __int8 **)(result + 32);
    if (v14 >= v64 + v65)
      v66 = (unsigned __int8 *)(v64 + v65);
    else
      v66 = (unsigned __int8 *)v14;
    if (v66 < v37)
      v66 = *(unsigned __int8 **)(result + 32);
    v39 = (v66[1] << 16) | (*v66 << 24) | (v66[2] << 8) | 0xFF;
    if (v6)
    {
      v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v13 += v60 + 1;
        v12 = (uint64_t)(v62 - 3);
        a4 += ~(_DWORD)v60;
        v24 = -1;
        goto LABEL_37;
      }
    }
    ++v60;
    v61 -= v10;
    a2 += v10;
    v62 += 4;
    a3 += v11;
    v63 -= v11;
    v24 = -1;
  }
}

uint64_t RGBAf_sample_RGBA32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  int64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  int v50;
  char v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  char v56;
  unsigned int v57;
  unsigned int *v58;
  int v59;
  char v60;
  unsigned int v61;
  unsigned int *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int *v70;
  int v71;
  uint64_t v72;
  uint64_t v73;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v7 = *(_QWORD *)(result + 88);
  v72 = *(_QWORD *)(result + 64);
  v73 = *(_QWORD *)(result + 80);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v10 = *(_QWORD *)(result + 152) - 16;
  v11 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_QWORD *)(result + 32);
  v12 = *(_QWORD *)(result + 40);
  v14 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  v71 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v7;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_34;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v22 | v71;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v6 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_34;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v18 | v71;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v72)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v72 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v71;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v73)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v73;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v71;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v24 < 0x400000)
    goto LABEL_34;
  v34 = v13 + SHIDWORD(v25) * (uint64_t)v4;
  v35 = v29 >> 32;
  v36 = v34 + 4 * v35;
  v37 = *(unsigned int **)(result + 32);
  if (v14 >= v36)
    v38 = (unsigned int *)(v34 + 4 * v35);
  else
    v38 = (unsigned int *)v14;
  if (v38 < v37)
    v38 = *(unsigned int **)(result + 32);
  v39 = bswap32(*v38);
  if (!v5)
    goto LABEL_66;
  v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v58 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v58)
        v58 = (unsigned int *)v14;
      if (v58 < v37)
        v58 = v37;
      v59 = interpolate_8888_19472[v42];
      v60 = v42 + 1;
      v57 = v39 - ((v59 & v39) >> v60);
      v61 = (bswap32(*v58) & v59) >> v60;
LABEL_65:
      v39 = v57 + v61;
      break;
    case 2:
      v62 = (unsigned int *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 54));
      if (v14 < (unint64_t)v62)
        v62 = (unsigned int *)v14;
      if (v62 < v37)
        v62 = v37;
      v53 = bswap32(*v62);
      v63 = (v40 >> 28) & 3;
      v55 = interpolate_8888_19472[v63];
      v56 = v63 + 1;
      v57 = v39 - ((v55 & v39) >> v56);
LABEL_64:
      v61 = (v53 & v55) >> v56;
      goto LABEL_65;
    case 3:
      v43 = (unint64_t)HIWORD(v40) << 56;
      v44 = (unsigned int *)(v36 + (v43 >> 54));
      if (v14 < (unint64_t)v44)
        v44 = (unsigned int *)v14;
      if (v44 < v37)
        v44 = v37;
      v45 = bswap32(*v44);
      v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46)
        v47 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      else
        v47 = (unsigned int *)v14;
      if (v47 < v37)
        v47 = v37;
      v48 = bswap32(*v47);
      v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v14 < (unint64_t)v49)
        v49 = (unsigned int *)v14;
      if (v49 < v37)
        v49 = v37;
      v50 = interpolate_8888_19472[v42];
      v51 = v42 + 1;
      v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((bswap32(*v49) & v50) >> v51);
      v54 = (v40 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      goto LABEL_64;
  }
LABEL_66:
  v64 = 0;
  a2 += v8;
  v65 = v73 - a2;
  v66 = (_DWORD *)(v10 + 28);
  a3 += v9;
  v67 = v7 - a3;
  while (1)
  {
    *(v66 - 3) = _blt_float[HIBYTE(v39)];
    *(v66 - 2) = _blt_float[BYTE2(v39)];
    *(v66 - 1) = _blt_float[BYTE1(v39)];
    v68 = v39;
    if (!v12)
      v68 = 255;
    *v66 = _blt_float[v68];
    *(_BYTE *)(v11 + 1 + v64) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v67 | v65 | (a3 - v6) | (a2 - v72)) & 0x8000000000000000) != 0)
    {
      v10 = (uint64_t)(v66 - 3);
      v11 += v64 + 1;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v69 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    v36 = v69 + 4 * (a2 >> 32);
    v37 = *(unsigned int **)(result + 32);
    if (v14 >= v36)
      v70 = (unsigned int *)(v69 + 4 * (a2 >> 32));
    else
      v70 = (unsigned int *)v14;
    if (v70 < v37)
      v70 = *(unsigned int **)(result + 32);
    v39 = bswap32(*v70);
    if (v5)
    {
      v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v10 = (uint64_t)(v66 - 3);
        v11 += v64 + 1;
        a4 += ~(_DWORD)v64;
        v24 = -1;
        goto LABEL_37;
      }
    }
    v65 -= v8;
    a2 += v8;
    v66 += 4;
    ++v64;
    a3 += v9;
    v67 -= v9;
    v24 = -1;
  }
}

uint64_t RGBAf_sample_rgba32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  int64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  char v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  char v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int v60;
  char v61;
  unsigned int v62;
  unsigned int *v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  _DWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int *v72;
  int v73;
  uint64_t v74;
  uint64_t v75;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v7 = *(_QWORD *)(result + 88);
  v74 = *(_QWORD *)(result + 64);
  v75 = *(_QWORD *)(result + 80);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v10 = *(_QWORD *)(result + 152) - 16;
  v11 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_QWORD *)(result + 32);
  v12 = *(_QWORD *)(result + 40);
  v14 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  v73 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v7;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_34;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v22 | v73;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v6 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_34;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v18 | v73;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v74)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v74 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v73;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v75)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v75;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v73;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v24 < 0x400000)
    goto LABEL_34;
  v34 = v13 + SHIDWORD(v25) * (uint64_t)v4;
  v35 = v29 >> 32;
  v36 = v34 + 4 * v35;
  v37 = *(unsigned int **)(result + 32);
  if (v14 >= v36)
    v38 = (unsigned int *)(v34 + 4 * v35);
  else
    v38 = (unsigned int *)v14;
  if (v38 < v37)
    v38 = *(unsigned int **)(result + 32);
  v39 = *v38;
  if (!v5)
    goto LABEL_66;
  v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v59 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59)
        v59 = (unsigned int *)v14;
      if (v59 < v37)
        v59 = v37;
      v60 = interpolate_8888_19472[v42];
      v61 = v42 + 1;
      v57 = v39 - ((v60 & v39) >> v61);
      v62 = (v60 & *v59) >> v61;
LABEL_65:
      v39 = v57 + v62;
      break;
    case 2:
      v63 = (unsigned int *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 54));
      if (v14 < (unint64_t)v63)
        v63 = (unsigned int *)v14;
      if (v63 < v37)
        v63 = v37;
      v64 = (v40 >> 28) & 3;
      v65 = interpolate_8888_19472[v64];
      v56 = v64 + 1;
      v57 = v39 - ((v65 & v39) >> v56);
      v58 = v65 & *v63;
LABEL_64:
      v62 = v58 >> v56;
      goto LABEL_65;
    case 3:
      v43 = (unint64_t)HIWORD(v40) << 56;
      v44 = (unsigned int *)(v36 + (v43 >> 54));
      if (v14 < (unint64_t)v44)
        v44 = (unsigned int *)v14;
      if (v44 < v37)
        v44 = v37;
      v45 = *v44;
      v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46)
        v47 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      else
        v47 = (unsigned int *)v14;
      if (v47 < v37)
        v47 = v37;
      v48 = *v47;
      v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v14 < (unint64_t)v49)
        v49 = (unsigned int *)v14;
      if (v49 < v37)
        v49 = v37;
      v50 = interpolate_8888_19472[v42];
      v51 = v42 + 1;
      v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      v54 = (v40 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      v58 = v53 & v55;
      goto LABEL_64;
  }
LABEL_66:
  v66 = 0;
  a2 += v8;
  v67 = v75 - a2;
  v68 = (_DWORD *)(v10 + 28);
  a3 += v9;
  v69 = v7 - a3;
  while (1)
  {
    *(v68 - 3) = _blt_float[HIBYTE(v39)];
    *(v68 - 2) = _blt_float[BYTE2(v39)];
    *(v68 - 1) = _blt_float[BYTE1(v39)];
    v70 = v39;
    if (!v12)
      v70 = 255;
    *v68 = _blt_float[v70];
    *(_BYTE *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v66)
      return result;
    if (((v69 | v67 | (a3 - v6) | (a2 - v74)) & 0x8000000000000000) != 0)
    {
      v10 = (uint64_t)(v68 - 3);
      v11 += v66 + 1;
      a4 += ~(_DWORD)v66;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v71 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    v36 = v71 + 4 * (a2 >> 32);
    v37 = *(unsigned int **)(result + 32);
    if (v14 >= v36)
      v72 = (unsigned int *)(v71 + 4 * (a2 >> 32));
    else
      v72 = (unsigned int *)v14;
    if (v72 < v37)
      v72 = *(unsigned int **)(result + 32);
    v39 = *v72;
    if (v5)
    {
      v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v10 = (uint64_t)(v68 - 3);
        v11 += v66 + 1;
        a4 += ~(_DWORD)v66;
        v24 = -1;
        goto LABEL_37;
      }
    }
    v67 -= v8;
    a2 += v8;
    v68 += 4;
    ++v66;
    a3 += v9;
    v69 -= v9;
    v24 = -1;
  }
}

uint64_t RGBAf_sample_ARGB32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned int *v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int *v50;
  int v51;
  char v52;
  unsigned int v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int *v57;
  int v58;
  char v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int *v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int *v69;
  int v70;
  uint64_t v71;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 64);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v71 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 16;
  v12 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v14 = 0;
  else
    v14 = -16777216;
  v15 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  v70 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        v24 = (a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v8;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_37;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v25 = v23 | v70;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v7 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_37;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v25 = v19 | v70;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v6)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v6 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v70;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 16;
    *(_BYTE *)++v12 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v71)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_29;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v71;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_37;
  if (v34 < v32)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v70;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_37;
  v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
  v36 = v30 >> 32;
  v37 = v35 + 4 * v36;
  v38 = *(unsigned int **)(result + 32);
  if (v15 >= v37)
    v39 = (unsigned int *)(v35 + 4 * v36);
  else
    v39 = (unsigned int *)v15;
  if (v39 < v38)
    v39 = *(unsigned int **)(result + 32);
  v40 = bswap32(*v39);
  if (!v5)
    goto LABEL_69;
  v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
  v42 = v41 & 0xF;
  v43 = HIBYTE(v41) & 3;
  switch(v42)
  {
    case 1:
      v57 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      if (v15 < (unint64_t)v57)
        v57 = (unsigned int *)v15;
      if (v57 < v38)
        v57 = v38;
      v58 = interpolate_8888_19472[v43];
      v59 = v43 + 1;
      v60 = v40 - ((v58 & v40) >> v59);
      v61 = (bswap32(*v57) & v58) >> v59;
LABEL_68:
      v40 = v60 + v61;
      break;
    case 2:
      v62 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
      if (v15 < (unint64_t)v62)
        v62 = (unsigned int *)v15;
      if (v62 < v38)
        v62 = v38;
      v53 = bswap32(*v62);
      v54 = (v41 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v55 & v40;
LABEL_67:
      v63 = v54 + 1;
      v60 = v40 - (v56 >> v63);
      v61 = (v53 & v55) >> v63;
      goto LABEL_68;
    case 3:
      v44 = (unint64_t)HIWORD(v41) << 56;
      v45 = (unsigned int *)(v37 + (v44 >> 54));
      if (v15 < (unint64_t)v45)
        v45 = (unsigned int *)v15;
      if (v45 < v38)
        v45 = v38;
      v46 = bswap32(*v45);
      v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
      if (v15 >= v47)
        v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      else
        v48 = (unsigned int *)v15;
      if (v48 < v38)
        v48 = v38;
      v49 = bswap32(*v48);
      v50 = (unsigned int *)(v47 + (v44 >> 54));
      if (v15 < (unint64_t)v50)
        v50 = (unsigned int *)v15;
      if (v50 < v38)
        v50 = v38;
      v51 = interpolate_8888_19472[v43];
      v52 = v43 + 1;
      v40 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
      v53 = v46 - ((v51 & v46) >> v52) + ((bswap32(*v50) & v51) >> v52);
      v54 = (v41 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v40 & v55;
      goto LABEL_67;
  }
LABEL_69:
  v64 = 0;
  a2 += v9;
  v65 = v71 - a2;
  v66 = (_DWORD *)(v11 + 28);
  a3 += v10;
  v67 = v8 - a3;
  while (1)
  {
    *(v66 - 3) = _blt_float[BYTE2(v40)];
    *(v66 - 2) = _blt_float[BYTE1(v40)];
    *(v66 - 1) = _blt_float[v40];
    *v66 = _blt_float[(v40 | v14) >> 24];
    *(_BYTE *)(v12 + 1 + v64) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v67 | v65 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) != 0)
    {
      v11 = (uint64_t)(v66 - 3);
      v12 += v64 + 1;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v68 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    v37 = v68 + 4 * (a2 >> 32);
    v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37)
      v69 = (unsigned int *)(v68 + 4 * (a2 >> 32));
    else
      v69 = (unsigned int *)v15;
    if (v69 < v38)
      v69 = *(unsigned int **)(result + 32);
    v40 = bswap32(*v69);
    if (v5)
    {
      v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v11 = (uint64_t)(v66 - 3);
        v12 += v64 + 1;
        a4 += ~(_DWORD)v64;
        v25 = -1;
        goto LABEL_40;
      }
    }
    v65 -= v9;
    a2 += v9;
    v66 += 4;
    ++v64;
    a3 += v10;
    v67 -= v10;
    v25 = -1;
  }
}

uint64_t RGBAf_sample_argb32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned int *v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int *v50;
  unsigned int v51;
  char v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  int v56;
  char v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int *v60;
  unsigned int v61;
  char v62;
  unsigned int v63;
  unsigned int *v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  _DWORD *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int *v72;
  int v73;
  uint64_t v74;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 64);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v74 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 16;
  v12 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v14 = 0;
  else
    v14 = -16777216;
  v15 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  v73 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        v24 = (a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v8;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_37;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v25 = v23 | v73;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v7 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_37;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v25 = v19 | v73;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v6)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v6 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v73;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 16;
    *(_BYTE *)++v12 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v74)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_29;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v74;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_37;
  if (v34 < v32)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v73;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_37;
  v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
  v36 = v30 >> 32;
  v37 = v35 + 4 * v36;
  v38 = *(unsigned int **)(result + 32);
  if (v15 >= v37)
    v39 = (unsigned int *)(v35 + 4 * v36);
  else
    v39 = (unsigned int *)v15;
  if (v39 < v38)
    v39 = *(unsigned int **)(result + 32);
  v40 = *v39;
  if (!v5)
    goto LABEL_69;
  v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
  v42 = v41 & 0xF;
  v43 = HIBYTE(v41) & 3;
  switch(v42)
  {
    case 1:
      v60 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      if (v15 < (unint64_t)v60)
        v60 = (unsigned int *)v15;
      if (v60 < v38)
        v60 = v38;
      v61 = interpolate_8888_19472[v43];
      v62 = v43 + 1;
      v58 = v40 - ((v61 & v40) >> v62);
      v63 = (v61 & *v60) >> v62;
LABEL_68:
      v40 = v58 + v63;
      break;
    case 2:
      v64 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
      if (v15 < (unint64_t)v64)
        v64 = (unsigned int *)v15;
      if (v64 < v38)
        v64 = v38;
      v65 = (v41 >> 28) & 3;
      v66 = interpolate_8888_19472[v65];
      v57 = v65 + 1;
      v58 = v40 - ((v66 & v40) >> v57);
      v59 = v66 & *v64;
LABEL_67:
      v63 = v59 >> v57;
      goto LABEL_68;
    case 3:
      v44 = (unint64_t)HIWORD(v41) << 56;
      v45 = (unsigned int *)(v37 + (v44 >> 54));
      if (v15 < (unint64_t)v45)
        v45 = (unsigned int *)v15;
      if (v45 < v38)
        v45 = v38;
      v46 = *v45;
      v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
      if (v15 >= v47)
        v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      else
        v48 = (unsigned int *)v15;
      if (v48 < v38)
        v48 = v38;
      v49 = *v48;
      v50 = (unsigned int *)(v47 + (v44 >> 54));
      if (v15 < (unint64_t)v50)
        v50 = (unsigned int *)v15;
      if (v50 < v38)
        v50 = v38;
      v51 = interpolate_8888_19472[v43];
      v52 = v43 + 1;
      v53 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
      v54 = v46 - ((v51 & v46) >> v52) + ((v51 & *v50) >> v52);
      v55 = (v41 >> 28) & 3;
      v56 = interpolate_8888_19472[v55];
      v57 = v55 + 1;
      v58 = v53 - ((v53 & v56) >> v57);
      v59 = v54 & v56;
      goto LABEL_67;
  }
LABEL_69:
  v67 = 0;
  a2 += v9;
  v68 = v74 - a2;
  v69 = (_DWORD *)(v11 + 28);
  a3 += v10;
  v70 = v8 - a3;
  while (1)
  {
    *(v69 - 3) = _blt_float[BYTE2(v40)];
    *(v69 - 2) = _blt_float[BYTE1(v40)];
    *(v69 - 1) = _blt_float[v40];
    *v69 = _blt_float[(v40 | v14) >> 24];
    *(_BYTE *)(v12 + 1 + v67) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v67)
      return result;
    if (((v70 | v68 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) != 0)
    {
      v11 = (uint64_t)(v69 - 3);
      v12 += v67 + 1;
      a4 += ~(_DWORD)v67;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v71 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    v37 = v71 + 4 * (a2 >> 32);
    v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37)
      v72 = (unsigned int *)(v71 + 4 * (a2 >> 32));
    else
      v72 = (unsigned int *)v15;
    if (v72 < v38)
      v72 = *(unsigned int **)(result + 32);
    v40 = *v72;
    if (v5)
    {
      v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v11 = (uint64_t)(v69 - 3);
        v12 += v67 + 1;
        a4 += ~(_DWORD)v67;
        v25 = -1;
        goto LABEL_40;
      }
    }
    v68 -= v9;
    a2 += v9;
    v69 += 4;
    ++v67;
    a3 += v10;
    v70 -= v10;
    v25 = -1;
  }
}

void RGBAf_sample_RGB48(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unint64_t v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  unsigned __int16 *v37;
  unint64_t v38;
  unsigned __int16 *v39;
  unsigned __int16 *v40;
  unint64_t v41;
  unsigned __int16 *v42;
  uint64_t v43;
  char v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  char v49;
  unint64_t v50;
  unsigned __int16 *v51;
  unsigned __int16 *v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int16 *v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;

  v6 = *(_QWORD *)(a1 + 176);
  v61 = *(_QWORD *)(a1 + 80);
  v64 = *(_QWORD *)(a1 + 88);
  v70 = *(_QWORD *)(a1 + 112);
  v69 = *(_QWORD *)(a1 + 120);
  v7 = (float *)(*(_QWORD *)(a1 + 152) - 16);
  v65 = *(_QWORD *)(a1 + 144) - 1;
  v66 = *(_QWORD *)(a1 + 32);
  v67 = *(_DWORD *)(a1 + 24);
  v60 = *(_DWORD *)(a1 + 188);
  v68 = v66
      + ((*(_DWORD *)(a1 + 260) - 1) * v67)
      + 2 * (3 * *(_DWORD *)(a1 + 256) - 3)
      - 6;
  v62 = *(_QWORD *)(a1 + 64);
  v63 = *(_QWORD *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v63)
    {
      if ((uint64_t)a3 <= v64)
      {
        v18 = (a3 >> 22) & 0x3C0;
        v19 = 0x3FFFFFFF;
        HIDWORD(v20) = HIDWORD(a3);
        v11 = a4;
        v12 = v62;
      }
      else
      {
        v14 = *(_QWORD *)(a1 + 216);
        v15 = *(_QWORD *)(a1 + 224) + v64;
        v16 = v15 - a3 + (v14 >> 1);
        v11 = a4;
        v12 = v62;
        if (v16 < 1)
          goto LABEL_33;
        if (v16 >= v14)
          LODWORD(v17) = 0x3FFFFFFF;
        else
          v17 = (unint64_t)(*(_QWORD *)(a1 + 232) * v16) >> 32;
        v19 = v17 | v60;
        v20 = v15 - 0x1000000;
        v18 = 448;
      }
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 216);
      v9 = v63 - *(_QWORD *)(a1 + 224);
      v10 = a3 - v9 + (v8 >> 1);
      v11 = a4;
      v12 = v62;
      if (v10 < 1)
        goto LABEL_33;
      if (v10 >= v8)
        LODWORD(v13) = 0x3FFFFFFF;
      else
        v13 = (unint64_t)(*(_QWORD *)(a1 + 232) * v10) >> 32;
      v19 = v13 | v60;
      v20 = v9 + 0x1000000;
      v18 = 512;
    }
    if ((uint64_t)a2 >= v12)
    {
      if ((uint64_t)a2 <= v61)
      {
        v25 = (a2 >> 26) & 0x3C;
        HIDWORD(v24) = HIDWORD(a2);
      }
      else
      {
        v26 = *(_QWORD *)(a1 + 192);
        v27 = *(_QWORD *)(a1 + 200) + v61;
        v28 = v27 - a2 + (v26 >> 1);
        if (v28 < 1)
          goto LABEL_33;
        if (v28 < v26)
          v19 = ((v19 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v28) >> 32) >> 15)) | v60;
        v24 = v27 - 0x1000000;
        v25 = 28;
      }
    }
    else
    {
      v21 = *(_QWORD *)(a1 + 192);
      v22 = v12 - *(_QWORD *)(a1 + 200);
      v23 = a2 - v22 + (v21 >> 1);
      if (v23 < 1)
        goto LABEL_33;
      if (v23 < v21)
        v19 = ((v19 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v23) >> 32) >> 15)) | v60;
      v24 = v22 + 0x1000000;
      v25 = 32;
    }
    if (v19 >= 0x400000)
      break;
LABEL_33:
    v34 = v11 - 1;
    a2 += v70;
    a3 += v69;
    v7 += 4;
    *(_BYTE *)++v65 = 0;
LABEL_34:
    a4 = v34;
    if (!v34)
      return;
  }
  v29 = v66 + SHIDWORD(v20) * (uint64_t)v67 + 6 * SHIDWORD(v24);
  v30 = *(unsigned __int16 **)(a1 + 32);
  v31 = (unsigned __int16 *)v68;
  if (v68 >= v29)
    v31 = (unsigned __int16 *)v29;
  if (v31 < v30)
    v31 = *(unsigned __int16 **)(a1 + 32);
  v32 = (bswap32(*v31) >> 16) | ((unint64_t)(bswap32(v31[1]) >> 16) << 16) | ((unint64_t)(bswap32(v31[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (v6)
  {
    v33 = *(_DWORD *)(v6 + (v25 | v18));
LABEL_37:
    v35 = v33 & 0xF;
    v36 = HIBYTE(v33) & 3;
    switch(v35)
    {
      case 1:
        v51 = (unsigned __int16 *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 < (unint64_t)v51)
          v51 = (unsigned __int16 *)v68;
        if (v51 >= v30)
          v30 = v51;
        v32 = v32
            - ((interpolate_16161616_19469[v36] & v32) >> (v36 + 1))
            + ((((bswap32(*v30) >> 16) | ((unint64_t)(bswap32(v30[1]) >> 16) << 16) | ((unint64_t)(bswap32(v30[2]) >> 16) << 32) | 0xFFFF000000000000) & interpolate_16161616_19469[v36]) >> (v36 + 1));
        break;
      case 2:
        v52 = (unsigned __int16 *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v52)
          v52 = (unsigned __int16 *)v68;
        if (v52 >= v30)
          v30 = v52;
        v46 = (bswap32(*v30) >> 16) | ((unint64_t)(bswap32(v30[1]) >> 16) << 16) | ((unint64_t)(bswap32(v30[2]) >> 16) << 32) | 0xFFFF000000000000;
        v53 = (v33 >> 28) & 3;
        v48 = interpolate_16161616_19469[v53];
        v49 = v53 + 1;
        v50 = v32 - ((v48 & v32) >> v49);
LABEL_64:
        v32 = v50 + ((v46 & v48) >> v49);
        break;
      case 3:
        v37 = (unsigned __int16 *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v37)
          v37 = (unsigned __int16 *)v68;
        if (v37 < v30)
          v37 = v30;
        v38 = (bswap32(*v37) >> 16) | ((unint64_t)(bswap32(v37[1]) >> 16) << 16) | ((unint64_t)(bswap32(v37[2]) >> 16) << 32) | 0xFFFF000000000000;
        v39 = (unsigned __int16 *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 >= (unint64_t)v39)
          v40 = v39;
        else
          v40 = (unsigned __int16 *)v68;
        if (v40 < v30)
          v40 = v30;
        v41 = (bswap32(*v40) >> 16) | ((unint64_t)(bswap32(v40[1]) >> 16) << 16) | ((unint64_t)(bswap32(v40[2]) >> 16) << 32) | 0xFFFF000000000000;
        v42 = &v39[3 * SBYTE2(v33)];
        if (v68 < (unint64_t)v42)
          v42 = (unsigned __int16 *)v68;
        if (v42 >= v30)
          v30 = v42;
        v43 = interpolate_16161616_19469[v36];
        v44 = v36 + 1;
        v45 = v32 - ((v43 & v32) >> v44) + ((v41 & v43) >> v44);
        v46 = v38
            - ((v43 & v38) >> v44)
            + ((((bswap32(*v30) >> 16) | ((unint64_t)(bswap32(v30[1]) >> 16) << 16) | ((unint64_t)(bswap32(v30[2]) >> 16) << 32) | 0xFFFF000000000000) & v43) >> v44);
        v47 = (v33 >> 28) & 3;
        v48 = interpolate_16161616_19469[v47];
        v49 = v47 + 1;
        v50 = v45 - ((v45 & v48) >> v49);
        goto LABEL_64;
    }
  }
  v54 = 0;
  v7 += 4;
  v59 = v11;
  v55 = v11 - 1;
  a3 += v69;
  v56 = v64 - a3;
  a2 += v70;
  v57 = v61 - a2;
  while (1)
  {
    RGBA64(v7, v32);
    *(_BYTE *)(v65 + 1 + v54) = v19 >> 22;
    if (v55 == (_DWORD)v54)
      break;
    if (((v56 | v57 | (a3 - v63) | (a2 - v62)) & 0x8000000000000000) != 0)
    {
      v65 += v54 + 1;
      v34 = ~(_DWORD)v54 + v59;
      goto LABEL_34;
    }
    v29 = v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2);
    v30 = *(unsigned __int16 **)(a1 + 32);
    v58 = (unsigned __int16 *)v68;
    if (v68 >= v29)
      v58 = (unsigned __int16 *)(v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2));
    if (v58 < v30)
      v58 = *(unsigned __int16 **)(a1 + 32);
    v32 = (bswap32(*v58) >> 16) | ((unint64_t)(bswap32(v58[1]) >> 16) << 16) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v33 = *(_DWORD *)(v6 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v33 & 0xF) != 0)
      {
        v65 += v54 + 1;
        v11 = ~(_DWORD)v54 + v59;
        v19 = -1;
        goto LABEL_37;
      }
    }
    ++v54;
    v7 += 4;
    a3 += v69;
    v56 -= v69;
    a2 += v70;
    v57 -= v70;
    v19 = -1;
  }
}

float RGBA64(float *a1, unint64_t a2)
{
  float result;

  *a1 = *(float *)&_blt_float[a2 + 256] + *(float *)&_blt_float[BYTE1(a2) + 512];
  a1[1] = *(float *)&_blt_float[BYTE2(a2) + 256] + *(float *)&_blt_float[BYTE3(a2) | 0x200];
  a1[2] = *(float *)&_blt_float[BYTE4(a2) + 256] + *(float *)&_blt_float[BYTE5(a2) + 512];
  result = *(float *)&_blt_float[BYTE6(a2) + 256] + *(float *)&_blt_float[HIBYTE(a2) + 512];
  a1[3] = result;
  return result;
}

void RGBAf_sample_rgb48(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unsigned int *v30;
  unsigned int *v31;
  unint64_t v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  unsigned int *v37;
  unint64_t v38;
  unsigned int *v39;
  unsigned int *v40;
  unint64_t v41;
  unsigned int *v42;
  uint64_t v43;
  char v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  char v49;
  unint64_t v50;
  unsigned int *v51;
  unsigned int *v52;
  int v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int *v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;

  v6 = *(_QWORD *)(a1 + 176);
  v61 = *(_QWORD *)(a1 + 80);
  v64 = *(_QWORD *)(a1 + 88);
  v70 = *(_QWORD *)(a1 + 112);
  v69 = *(_QWORD *)(a1 + 120);
  v7 = (float *)(*(_QWORD *)(a1 + 152) - 16);
  v65 = *(_QWORD *)(a1 + 144) - 1;
  v66 = *(_QWORD *)(a1 + 32);
  v67 = *(_DWORD *)(a1 + 24);
  v60 = *(_DWORD *)(a1 + 188);
  v68 = v66
      + ((*(_DWORD *)(a1 + 260) - 1) * v67)
      + 2 * (3 * *(_DWORD *)(a1 + 256) - 3)
      - 6;
  v62 = *(_QWORD *)(a1 + 64);
  v63 = *(_QWORD *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v63)
    {
      if ((uint64_t)a3 <= v64)
      {
        v18 = (a3 >> 22) & 0x3C0;
        v19 = 0x3FFFFFFF;
        HIDWORD(v20) = HIDWORD(a3);
        v11 = a4;
        v12 = v62;
      }
      else
      {
        v14 = *(_QWORD *)(a1 + 216);
        v15 = *(_QWORD *)(a1 + 224) + v64;
        v16 = v15 - a3 + (v14 >> 1);
        v11 = a4;
        v12 = v62;
        if (v16 < 1)
          goto LABEL_33;
        if (v16 >= v14)
          LODWORD(v17) = 0x3FFFFFFF;
        else
          v17 = (unint64_t)(*(_QWORD *)(a1 + 232) * v16) >> 32;
        v19 = v17 | v60;
        v20 = v15 - 0x1000000;
        v18 = 448;
      }
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 216);
      v9 = v63 - *(_QWORD *)(a1 + 224);
      v10 = a3 - v9 + (v8 >> 1);
      v11 = a4;
      v12 = v62;
      if (v10 < 1)
        goto LABEL_33;
      if (v10 >= v8)
        LODWORD(v13) = 0x3FFFFFFF;
      else
        v13 = (unint64_t)(*(_QWORD *)(a1 + 232) * v10) >> 32;
      v19 = v13 | v60;
      v20 = v9 + 0x1000000;
      v18 = 512;
    }
    if ((uint64_t)a2 >= v12)
    {
      if ((uint64_t)a2 <= v61)
      {
        v25 = (a2 >> 26) & 0x3C;
        HIDWORD(v24) = HIDWORD(a2);
      }
      else
      {
        v26 = *(_QWORD *)(a1 + 192);
        v27 = *(_QWORD *)(a1 + 200) + v61;
        v28 = v27 - a2 + (v26 >> 1);
        if (v28 < 1)
          goto LABEL_33;
        if (v28 < v26)
          v19 = ((v19 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v28) >> 32) >> 15)) | v60;
        v24 = v27 - 0x1000000;
        v25 = 28;
      }
    }
    else
    {
      v21 = *(_QWORD *)(a1 + 192);
      v22 = v12 - *(_QWORD *)(a1 + 200);
      v23 = a2 - v22 + (v21 >> 1);
      if (v23 < 1)
        goto LABEL_33;
      if (v23 < v21)
        v19 = ((v19 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v23) >> 32) >> 15)) | v60;
      v24 = v22 + 0x1000000;
      v25 = 32;
    }
    if (v19 >= 0x400000)
      break;
LABEL_33:
    v34 = v11 - 1;
    a2 += v70;
    a3 += v69;
    v7 += 4;
    *(_BYTE *)++v65 = 0;
LABEL_34:
    a4 = v34;
    if (!v34)
      return;
  }
  v29 = v66 + SHIDWORD(v20) * (uint64_t)v67 + 6 * SHIDWORD(v24);
  v30 = *(unsigned int **)(a1 + 32);
  v31 = (unsigned int *)v68;
  if (v68 >= v29)
    v31 = (unsigned int *)v29;
  if (v31 < v30)
    v31 = *(unsigned int **)(a1 + 32);
  v32 = *v31 | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32) | 0xFFFF000000000000;
  if (v6)
  {
    v33 = *(_DWORD *)(v6 + (v25 | v18));
LABEL_37:
    v35 = v33 & 0xF;
    v36 = HIBYTE(v33) & 3;
    switch(v35)
    {
      case 1:
        v51 = (unsigned int *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 < (unint64_t)v51)
          v51 = (unsigned int *)v68;
        if (v51 >= v30)
          v30 = v51;
        v32 = v32
            - ((interpolate_16161616_19469[v36] & v32) >> (v36 + 1))
            + (((*v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32) | 0xFFFF000000000000) & interpolate_16161616_19469[v36]) >> (v36 + 1));
        break;
      case 2:
        v52 = (unsigned int *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v52)
          v52 = (unsigned int *)v68;
        if (v52 >= v30)
          v30 = v52;
        v46 = *v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32) | 0xFFFF000000000000;
        v53 = (v33 >> 28) & 3;
        v48 = interpolate_16161616_19469[v53];
        v49 = v53 + 1;
        v50 = v32 - ((v48 & v32) >> v49);
LABEL_64:
        v32 = v50 + ((v46 & v48) >> v49);
        break;
      case 3:
        v37 = (unsigned int *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v37)
          v37 = (unsigned int *)v68;
        if (v37 < v30)
          v37 = v30;
        v38 = *v37 | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32) | 0xFFFF000000000000;
        v39 = (unsigned int *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 >= (unint64_t)v39)
          v40 = v39;
        else
          v40 = (unsigned int *)v68;
        if (v40 < v30)
          v40 = v30;
        v41 = *v40 | ((unint64_t)*((unsigned __int16 *)v40 + 2) << 32) | 0xFFFF000000000000;
        v42 = (unsigned int *)((char *)v39 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v42)
          v42 = (unsigned int *)v68;
        if (v42 >= v30)
          v30 = v42;
        v43 = interpolate_16161616_19469[v36];
        v44 = v36 + 1;
        v45 = v32 - ((v43 & v32) >> v44) + ((v41 & v43) >> v44);
        v46 = v38
            - ((v43 & v38) >> v44)
            + (((*v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32) | 0xFFFF000000000000) & v43) >> v44);
        v47 = (v33 >> 28) & 3;
        v48 = interpolate_16161616_19469[v47];
        v49 = v47 + 1;
        v50 = v45 - ((v45 & v48) >> v49);
        goto LABEL_64;
    }
  }
  v54 = 0;
  v7 += 4;
  v59 = v11;
  v55 = v11 - 1;
  a3 += v69;
  v56 = v64 - a3;
  a2 += v70;
  v57 = v61 - a2;
  while (1)
  {
    RGBA64(v7, v32);
    *(_BYTE *)(v65 + 1 + v54) = v19 >> 22;
    if (v55 == (_DWORD)v54)
      break;
    if (((v56 | v57 | (a3 - v63) | (a2 - v62)) & 0x8000000000000000) != 0)
    {
      v65 += v54 + 1;
      v34 = ~(_DWORD)v54 + v59;
      goto LABEL_34;
    }
    v29 = v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2);
    v30 = *(unsigned int **)(a1 + 32);
    v58 = (unsigned int *)v68;
    if (v68 >= v29)
      v58 = (unsigned int *)(v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2));
    if (v58 < v30)
      v58 = *(unsigned int **)(a1 + 32);
    v32 = *v58 | ((unint64_t)*((unsigned __int16 *)v58 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v33 = *(_DWORD *)(v6 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v33 & 0xF) != 0)
      {
        v65 += v54 + 1;
        v11 = ~(_DWORD)v54 + v59;
        v19 = -1;
        goto LABEL_37;
      }
    }
    ++v54;
    v7 += 4;
    a3 += v69;
    v56 -= v69;
    a2 += v70;
    v57 -= v70;
    v19 = -1;
  }
}

void RGBAf_sample_RGBA64(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6;
  float *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  unint64_t v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int64_t v38;
  unsigned __int16 *v39;
  unint64_t v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  unint64_t v43;
  unsigned __int16 *v44;
  uint64_t v45;
  char v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  unint64_t v50;
  unsigned __int16 *v51;
  uint64_t v52;
  char v53;
  unint64_t v54;
  unint64_t v55;
  unsigned __int16 *v56;
  char v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  unsigned __int16 *v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  int v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;

  v6 = *(_QWORD *)(a1 + 176);
  v65 = *(_QWORD *)(a1 + 80);
  v68 = *(_QWORD *)(a1 + 88);
  v75 = *(_QWORD *)(a1 + 112);
  v74 = *(_QWORD *)(a1 + 120);
  v64 = *(_DWORD *)(a1 + 188);
  v7 = (float *)(*(_QWORD *)(a1 + 152) - 16);
  v69 = *(_QWORD *)(a1 + 144) - 1;
  v8 = 0xFFFF000000000000;
  if (*(_QWORD *)(a1 + 40))
    v8 = 0;
  v71 = v8;
  v72 = *(_DWORD *)(a1 + 24);
  v70 = *(_QWORD *)(a1 + 32);
  v73 = v70 + ((*(_DWORD *)(a1 + 260) - 1) * v72) + 8 * (*(_DWORD *)(a1 + 256) - 1) - 8;
  v66 = *(_QWORD *)(a1 + 64);
  v67 = *(_QWORD *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v67)
    {
      if ((uint64_t)a3 <= v68)
      {
        v19 = (a3 >> 22) & 0x3C0;
        v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        v12 = a4;
        v13 = v66;
      }
      else
      {
        v15 = *(_QWORD *)(a1 + 216);
        v16 = *(_QWORD *)(a1 + 224) + v68;
        v17 = v16 - a3 + (v15 >> 1);
        v12 = a4;
        v13 = v66;
        if (v17 < 1)
          goto LABEL_35;
        if (v17 >= v15)
          LODWORD(v18) = 0x3FFFFFFF;
        else
          v18 = (unint64_t)(*(_QWORD *)(a1 + 232) * v17) >> 32;
        v20 = v18 | v64;
        v21 = v16 - 0x1000000;
        v19 = 448;
      }
    }
    else
    {
      v9 = *(_QWORD *)(a1 + 216);
      v10 = v67 - *(_QWORD *)(a1 + 224);
      v11 = a3 - v10 + (v9 >> 1);
      v12 = a4;
      v13 = v66;
      if (v11 < 1)
        goto LABEL_35;
      if (v11 >= v9)
        LODWORD(v14) = 0x3FFFFFFF;
      else
        v14 = (unint64_t)(*(_QWORD *)(a1 + 232) * v11) >> 32;
      v20 = v14 | v64;
      v21 = v10 + 0x1000000;
      v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v65)
      {
        v26 = ((unint64_t)a2 >> 26) & 0x3C;
        v25 = a2;
      }
      else
      {
        v27 = *(_QWORD *)(a1 + 192);
        v28 = *(_QWORD *)(a1 + 200) + v65;
        v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1)
          goto LABEL_35;
        if (v29 < v27)
          v20 = ((v20 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v29) >> 32) >> 15)) | v64;
        v25 = v28 - 0x1000000;
        v26 = 28;
      }
    }
    else
    {
      v22 = *(_QWORD *)(a1 + 192);
      v23 = v13 - *(_QWORD *)(a1 + 200);
      v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1)
        goto LABEL_35;
      if (v24 < v22)
        v20 = ((v20 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v24) >> 32) >> 15)) | v64;
      v25 = v23 + 0x1000000;
      v26 = 32;
    }
    if (v20 >= 0x400000)
      break;
LABEL_35:
    v35 = v12 - 1;
    a2 += v75;
    a3 += v74;
    v7 += 4;
    *(_BYTE *)++v69 = 0;
LABEL_36:
    a4 = v35;
    if (!v35)
      return;
  }
  v30 = v70 + SHIDWORD(v21) * (uint64_t)v72 + 8 * (v25 >> 32);
  v31 = *(unsigned __int16 **)(a1 + 32);
  v32 = (unsigned __int16 *)v73;
  if (v73 >= v30)
    v32 = (unsigned __int16 *)v30;
  if (v32 < v31)
    v32 = *(unsigned __int16 **)(a1 + 32);
  v33 = ((unint64_t)(bswap32(v32[2]) >> 16) << 32) | ((unint64_t)(bswap32(v32[3]) >> 16) << 48) | bswap32(v32[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v32) >> 16);
  if (!v6)
    goto LABEL_68;
  v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_39:
  v36 = v34 & 0xF;
  v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      v51 = (unsigned __int16 *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 < (unint64_t)v51)
        v51 = (unsigned __int16 *)v73;
      if (v51 >= v31)
        v31 = v51;
      v52 = interpolate_16161616_19469[v37];
      v53 = v37 + 1;
      v54 = v33 - ((v52 & v33) >> v53);
      v55 = ((((unint64_t)(bswap32(v31[2]) >> 16) << 32) | ((unint64_t)(bswap32(v31[3]) >> 16) << 48) | bswap32(v31[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v31) >> 16)) & v52) >> v53;
LABEL_67:
      v33 = v54 + v55;
      break;
    case 2:
      v56 = (unsigned __int16 *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 53));
      if (v73 < (unint64_t)v56)
        v56 = (unsigned __int16 *)v73;
      if (v56 >= v31)
        v31 = v56;
      v47 = ((unint64_t)(bswap32(v31[2]) >> 16) << 32) | ((unint64_t)(bswap32(v31[3]) >> 16) << 48) | bswap32(v31[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v31) >> 16);
      v48 = (v34 >> 28) & 3;
      v49 = interpolate_16161616_19469[v48];
      v50 = v49 & v33;
LABEL_66:
      v57 = v48 + 1;
      v54 = v33 - (v50 >> v57);
      v55 = (v47 & v49) >> v57;
      goto LABEL_67;
    case 3:
      v38 = (unint64_t)HIWORD(v34) << 56;
      v39 = (unsigned __int16 *)(v30 + (v38 >> 53));
      if (v73 < (unint64_t)v39)
        v39 = (unsigned __int16 *)v73;
      if (v39 < v31)
        v39 = v31;
      v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
      v41 = (unsigned __int16 *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 >= (unint64_t)v41)
        v42 = v41;
      else
        v42 = (unsigned __int16 *)v73;
      if (v42 < v31)
        v42 = v31;
      v43 = ((unint64_t)(bswap32(v42[2]) >> 16) << 32) | ((unint64_t)(bswap32(v42[3]) >> 16) << 48) | bswap32(v42[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v42) >> 16);
      v44 = (unsigned __int16 *)((char *)v41 + (v38 >> 53));
      if (v73 < (unint64_t)v44)
        v44 = (unsigned __int16 *)v73;
      if (v44 >= v31)
        v31 = v44;
      v45 = interpolate_16161616_19469[v37];
      v46 = v37 + 1;
      v33 = v33 - ((v45 & v33) >> v46) + ((v43 & v45) >> v46);
      v47 = v40
          - ((v45 & v40) >> v46)
          + (((((unint64_t)(bswap32(v31[2]) >> 16) << 32) | ((unint64_t)(bswap32(v31[3]) >> 16) << 48) | bswap32(v31[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v31) >> 16)) & v45) >> v46);
      v48 = (v34 >> 28) & 3;
      v49 = interpolate_16161616_19469[v48];
      v50 = v33 & v49;
      goto LABEL_66;
  }
LABEL_68:
  v58 = 0;
  v7 += 4;
  v63 = v12;
  v59 = v12 - 1;
  a3 += v74;
  v60 = v68 - a3;
  a2 += v75;
  v61 = v65 - a2;
  while (1)
  {
    RGBA64(v7, v33 | v71);
    *(_BYTE *)(v69 + 1 + v58) = v20 >> 22;
    if (v59 == (_DWORD)v58)
      break;
    if (((v60 | v61 | (a3 - v67) | (a2 - v66)) & 0x8000000000000000) != 0)
    {
      v69 += v58 + 1;
      v35 = ~(_DWORD)v58 + v63;
      goto LABEL_36;
    }
    v30 = v70 + SHIDWORD(a3) * (uint64_t)v72 + 8 * (a2 >> 32);
    v31 = *(unsigned __int16 **)(a1 + 32);
    v62 = (unsigned __int16 *)v73;
    if (v73 >= v30)
      v62 = (unsigned __int16 *)(v70 + SHIDWORD(a3) * (uint64_t)v72 + 8 * (a2 >> 32));
    if (v62 < v31)
      v62 = *(unsigned __int16 **)(a1 + 32);
    v33 = ((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16);
    if (v6)
    {
      v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v69 += v58 + 1;
        v12 = ~(_DWORD)v58 + v63;
        v20 = -1;
        goto LABEL_39;
      }
    }
    ++v58;
    v7 += 4;
    a3 += v74;
    v60 -= v74;
    a2 += v75;
    v61 -= v75;
    v20 = -1;
  }
}

void RGBAf_sample_rgba64(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6;
  float *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  char v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  char v56;
  unint64_t v57;
  unint64_t *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t *v65;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  int v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v6 = *(_QWORD *)(a1 + 176);
  v68 = *(_QWORD *)(a1 + 80);
  v71 = *(_QWORD *)(a1 + 88);
  v78 = *(_QWORD *)(a1 + 112);
  v77 = *(_QWORD *)(a1 + 120);
  v67 = *(_DWORD *)(a1 + 188);
  v7 = (float *)(*(_QWORD *)(a1 + 152) - 16);
  v72 = *(_QWORD *)(a1 + 144) - 1;
  v8 = 0xFFFF000000000000;
  if (*(_QWORD *)(a1 + 40))
    v8 = 0;
  v74 = v8;
  v75 = *(_DWORD *)(a1 + 24);
  v73 = *(_QWORD *)(a1 + 32);
  v76 = v73 + ((*(_DWORD *)(a1 + 260) - 1) * v75) + 8 * (*(_DWORD *)(a1 + 256) - 1) - 8;
  v69 = *(_QWORD *)(a1 + 64);
  v70 = *(_QWORD *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v70)
    {
      if ((uint64_t)a3 <= v71)
      {
        v19 = (a3 >> 22) & 0x3C0;
        v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        v12 = a4;
        v13 = v69;
      }
      else
      {
        v15 = *(_QWORD *)(a1 + 216);
        v16 = *(_QWORD *)(a1 + 224) + v71;
        v17 = v16 - a3 + (v15 >> 1);
        v12 = a4;
        v13 = v69;
        if (v17 < 1)
          goto LABEL_35;
        if (v17 >= v15)
          LODWORD(v18) = 0x3FFFFFFF;
        else
          v18 = (unint64_t)(*(_QWORD *)(a1 + 232) * v17) >> 32;
        v20 = v18 | v67;
        v21 = v16 - 0x1000000;
        v19 = 448;
      }
    }
    else
    {
      v9 = *(_QWORD *)(a1 + 216);
      v10 = v70 - *(_QWORD *)(a1 + 224);
      v11 = a3 - v10 + (v9 >> 1);
      v12 = a4;
      v13 = v69;
      if (v11 < 1)
        goto LABEL_35;
      if (v11 >= v9)
        LODWORD(v14) = 0x3FFFFFFF;
      else
        v14 = (unint64_t)(*(_QWORD *)(a1 + 232) * v11) >> 32;
      v20 = v14 | v67;
      v21 = v10 + 0x1000000;
      v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v68)
      {
        v26 = ((unint64_t)a2 >> 26) & 0x3C;
        v25 = a2;
      }
      else
      {
        v27 = *(_QWORD *)(a1 + 192);
        v28 = *(_QWORD *)(a1 + 200) + v68;
        v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1)
          goto LABEL_35;
        if (v29 < v27)
          v20 = ((v20 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v29) >> 32) >> 15)) | v67;
        v25 = v28 - 0x1000000;
        v26 = 28;
      }
    }
    else
    {
      v22 = *(_QWORD *)(a1 + 192);
      v23 = v13 - *(_QWORD *)(a1 + 200);
      v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1)
        goto LABEL_35;
      if (v24 < v22)
        v20 = ((v20 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v24) >> 32) >> 15)) | v67;
      v25 = v23 + 0x1000000;
      v26 = 32;
    }
    if (v20 >= 0x400000)
      break;
LABEL_35:
    v35 = v12 - 1;
    a2 += v78;
    a3 += v77;
    v7 += 4;
    *(_BYTE *)++v72 = 0;
LABEL_36:
    a4 = v35;
    if (!v35)
      return;
  }
  v30 = v73 + SHIDWORD(v21) * (uint64_t)v75 + 8 * (v25 >> 32);
  v31 = *(unint64_t **)(a1 + 32);
  v32 = (unint64_t *)v76;
  if (v76 >= v30)
    v32 = (unint64_t *)v30;
  if (v32 < v31)
    v32 = *(unint64_t **)(a1 + 32);
  v33 = *v32;
  if (!v6)
    goto LABEL_68;
  v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_39:
  v36 = v34 & 0xF;
  v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      v54 = (unint64_t *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 < (unint64_t)v54)
        v54 = (unint64_t *)v76;
      if (v54 >= v31)
        v31 = v54;
      v55 = interpolate_16161616_19469[v37];
      v56 = v37 + 1;
      v52 = v33 - ((v55 & v33) >> v56);
      v57 = (v55 & *v31) >> v56;
LABEL_67:
      v33 = v52 + v57;
      break;
    case 2:
      v58 = (unint64_t *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 53));
      if (v76 < (unint64_t)v58)
        v58 = (unint64_t *)v76;
      if (v58 >= v31)
        v31 = v58;
      v59 = (v34 >> 28) & 3;
      v60 = interpolate_16161616_19469[v59];
      v51 = v59 + 1;
      v52 = v33 - ((v60 & v33) >> v51);
      v53 = v60 & *v31;
LABEL_66:
      v57 = v53 >> v51;
      goto LABEL_67;
    case 3:
      v38 = (unint64_t)HIWORD(v34) << 56;
      v39 = (unint64_t *)(v30 + (v38 >> 53));
      if (v76 < (unint64_t)v39)
        v39 = (unint64_t *)v76;
      if (v39 < v31)
        v39 = v31;
      v40 = *v39;
      v41 = (unint64_t *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 >= (unint64_t)v41)
        v42 = v41;
      else
        v42 = (unint64_t *)v76;
      if (v42 < v31)
        v42 = v31;
      v43 = *v42;
      v44 = (unint64_t *)((char *)v41 + (v38 >> 53));
      if (v76 < (unint64_t)v44)
        v44 = (unint64_t *)v76;
      if (v44 >= v31)
        v31 = v44;
      v45 = interpolate_16161616_19469[v37];
      v46 = v37 + 1;
      v47 = v33 - ((v45 & v33) >> v46) + ((v45 & v43) >> v46);
      v48 = v40 - ((v45 & v40) >> v46) + ((v45 & *v31) >> v46);
      v49 = (v34 >> 28) & 3;
      v50 = interpolate_16161616_19469[v49];
      v51 = v49 + 1;
      v52 = v47 - ((v47 & v50) >> v51);
      v53 = v48 & v50;
      goto LABEL_66;
  }
LABEL_68:
  v61 = 0;
  v7 += 4;
  v66 = v12;
  v62 = v12 - 1;
  a3 += v77;
  v63 = v71 - a3;
  a2 += v78;
  v64 = v68 - a2;
  while (1)
  {
    RGBA64(v7, v33 | v74);
    *(_BYTE *)(v72 + 1 + v61) = v20 >> 22;
    if (v62 == (_DWORD)v61)
      break;
    if (((v63 | v64 | (a3 - v70) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v72 += v61 + 1;
      v35 = ~(_DWORD)v61 + v66;
      goto LABEL_36;
    }
    v30 = v73 + SHIDWORD(a3) * (uint64_t)v75 + 8 * (a2 >> 32);
    v31 = *(unint64_t **)(a1 + 32);
    v65 = (unint64_t *)v76;
    if (v76 >= v30)
      v65 = (unint64_t *)(v73 + SHIDWORD(a3) * (uint64_t)v75 + 8 * (a2 >> 32));
    if (v65 < v31)
      v65 = *(unint64_t **)(a1 + 32);
    v33 = *v65;
    if (v6)
    {
      v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v72 += v61 + 1;
        v12 = ~(_DWORD)v61 + v66;
        v20 = -1;
        goto LABEL_39;
      }
    }
    v7 += 4;
    ++v61;
    a3 += v77;
    v63 -= v77;
    a2 += v78;
    v64 -= v78;
    v20 = -1;
  }
}

uint64_t RGBAf_sample_WF(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unsigned int *v41;
  unsigned int *v42;
  unint64_t v43;
  unsigned int *v44;
  unsigned int *v45;
  float v46;
  float v47;
  unsigned int v48;
  int v49;
  int v50;
  unint64_t v51;
  unsigned int *v52;
  float v53;
  unsigned int *v54;
  float v55;
  float v56;
  float v57;
  unint64_t v58;
  unint64_t v59;
  unsigned int *v60;
  unsigned int *v61;
  float v62;
  float v63;
  unsigned int *v64;
  float v65;
  float v66;
  unsigned int *v67;
  float *v68;
  unsigned int *v69;
  unsigned int *v70;
  float v71;
  uint64_t v72;
  float *v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unsigned int *v80;
  unsigned int *v81;
  unsigned int *v82;
  unsigned int v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v86 = *(_QWORD *)(result + 80);
  v87 = *(_QWORD *)(result + 64);
  v88 = *(_QWORD *)(result + 88);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = (float *)(*(_QWORD *)(result + 152) - 16);
  v12 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_DWORD *)(result + 260) - 1;
  v14 = *(_DWORD *)(result + 256) - 1;
  v15 = v5 + (v13 * v7) + 4 * v14;
  v85 = *(_DWORD *)(result + 188);
  v16 = v4 + (v13 * v6) + 4 * v14 - 4;
  v89 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v89)
      {
        if (a3 <= v88)
        {
          v25 = ((unint64_t)a3 >> 22) & 0x3C0;
          v26 = 0x3FFFFFFF;
          v27 = a3;
          v28 = v87;
        }
        else
        {
          v21 = *(_QWORD *)(result + 216);
          v22 = *(_QWORD *)(result + 224) + v88;
          v23 = v22 - a3 + (v21 >> 1);
          if (v23 < 1)
            goto LABEL_39;
          if (v23 >= v21)
            LODWORD(v24) = 0x3FFFFFFF;
          else
            v24 = (unint64_t)(*(_QWORD *)(result + 232) * v23) >> 32;
          v28 = v87;
          v26 = v24 | v85;
          v27 = v22 - 0x1000000;
          v25 = 448;
        }
      }
      else
      {
        v17 = *(_QWORD *)(result + 216);
        v18 = v89 - *(_QWORD *)(result + 224);
        v19 = a3 - v18 + (v17 >> 1);
        if (v19 < 1)
          goto LABEL_39;
        if (v19 >= v17)
          LODWORD(v20) = 0x3FFFFFFF;
        else
          v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
        v28 = v87;
        v26 = v20 | v85;
        v27 = v18 + 0x1000000;
        v25 = 512;
      }
      if (a2 >= v28)
        break;
      v29 = *(_QWORD *)(result + 192);
      v30 = v28 - *(_QWORD *)(result + 200);
      v31 = a2 - v30 + (v29 >> 1);
      if (v31 >= 1)
      {
        if (v31 < v29)
          v26 = ((v26 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v31) >> 32) >> 15)) | v85;
        v32 = v30 + 0x1000000;
        v33 = 32;
        goto LABEL_26;
      }
LABEL_39:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 4;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v86)
    {
      v33 = ((unint64_t)a2 >> 26) & 0x3C;
      v32 = a2;
      goto LABEL_26;
    }
    v34 = *(_QWORD *)(result + 192);
    v35 = *(_QWORD *)(result + 200) + v86;
    v36 = v35 - a2 + (v34 >> 1);
    if (v36 < 1)
      goto LABEL_39;
    if (v36 < v34)
      v26 = ((v26 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v85;
    v32 = v35 - 0x1000000;
    v33 = 28;
LABEL_26:
    if (v26 < 0x400000)
      goto LABEL_39;
    v37 = v27 >> 32;
    v38 = v4 + SHIDWORD(v27) * (uint64_t)v6;
    v39 = (v32 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v40 = v38 + v39;
    v41 = *(unsigned int **)(result + 32);
    if (v16 >= v38 + v39)
      v42 = (unsigned int *)(v38 + v39);
    else
      v42 = (unsigned int *)v16;
    if (v42 < v41)
      v42 = *(unsigned int **)(result + 32);
    if (v5)
    {
      v43 = v5 + (int)v37 * (uint64_t)v7 + v39;
      v44 = *(unsigned int **)(result + 40);
      if (v15 >= v43)
        v45 = (unsigned int *)v43;
      else
        v45 = (unsigned int *)v15;
      if (v45 >= v44)
        v44 = v45;
      v46 = COERCE_FLOAT(bswap32(*v44));
    }
    else
    {
      v43 = 0;
      v46 = 1.0;
    }
    v47 = COERCE_FLOAT(bswap32(*v42));
    if (!v8)
      goto LABEL_92;
    v48 = *(_DWORD *)(v8 + (v33 | v25));
LABEL_45:
    v49 = v48 & 0xF;
    v50 = HIBYTE(v48) & 3;
    if (v49 == 1)
    {
      v64 = (unsigned int *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 < (unint64_t)v64)
        v64 = (unsigned int *)v16;
      if (v64 < v41)
        v64 = v41;
      v65 = COERCE_FLOAT(bswap32(*v64));
      v66 = 1.0;
      if (v5)
      {
        v67 = (unsigned int *)(v43 + SBYTE1(v48) * (uint64_t)v7);
        if (v15 < (unint64_t)v67)
          v67 = (unsigned int *)v15;
        if ((unint64_t)v67 < *(_QWORD *)(result + 40))
          v67 = *(unsigned int **)(result + 40);
        v66 = COERCE_FLOAT(bswap32(*v67));
      }
      v68 = &interpolate_waf[2 * v50];
    }
    else
    {
      if (v49 != 2)
      {
        if (v49 == 3)
        {
          v51 = v40 + 4 * SBYTE2(v48);
          if (v16 >= v51)
            v52 = (unsigned int *)(v40 + 4 * SBYTE2(v48));
          else
            v52 = (unsigned int *)v16;
          if (v52 < v41)
            v52 = v41;
          v53 = COERCE_FLOAT(bswap32(*v52));
          v54 = (unsigned int *)(v51 + SBYTE1(v48) * (uint64_t)v6);
          if (v16 < (unint64_t)v54)
            v54 = (unsigned int *)v16;
          if (v54 < v41)
            v54 = v41;
          v55 = COERCE_FLOAT(bswap32(*v54));
          v56 = 1.0;
          v57 = 1.0;
          if (v5)
          {
            v58 = v43 + 4 * SBYTE2(v48);
            v59 = *(_QWORD *)(result + 40);
            if (v15 >= v58)
              v60 = (unsigned int *)(v43 + 4 * SBYTE2(v48));
            else
              v60 = (unsigned int *)v15;
            if ((unint64_t)v60 < v59)
              v60 = *(unsigned int **)(result + 40);
            v57 = COERCE_FLOAT(bswap32(*v60));
            v61 = (unsigned int *)(v58 + SBYTE1(v48) * (uint64_t)v7);
            if (v15 < (unint64_t)v61)
              v61 = (unsigned int *)v15;
            if ((unint64_t)v61 < v59)
              v61 = *(unsigned int **)(result + 40);
            v56 = COERCE_FLOAT(bswap32(*v61));
          }
          v62 = interpolate_waf[2 * v50 + 1];
          v63 = interpolate_waf[2 * ((v48 >> 28) & 3) + 1];
          v47 = (float)((float)((float)(v47 - (float)(v47 * v62)) + (float)(v53 * v62))
                      - (float)((float)((float)(v47 - (float)(v47 * v62)) + (float)(v53 * v62)) * v63))
              + (float)((float)((float)(v53 - (float)(v53 * v62)) + (float)(v55 * v62)) * v63);
          v46 = (float)((float)((float)(v46 - (float)(v46 * v62)) + (float)(v57 * v62))
                      - (float)((float)((float)(v46 - (float)(v46 * v62)) + (float)(v57 * v62)) * v63))
              + (float)((float)((float)(v57 - (float)(v57 * v62)) + (float)(v56 * v62)) * v63);
        }
        goto LABEL_92;
      }
      v69 = (unsigned int *)(v40 + 4 * SBYTE2(v48));
      if (v16 < (unint64_t)v69)
        v69 = (unsigned int *)v16;
      if (v69 < v41)
        v69 = v41;
      v65 = COERCE_FLOAT(bswap32(*v69));
      v66 = 1.0;
      if (v5)
      {
        v70 = (unsigned int *)(v43 + 4 * SBYTE2(v48));
        if (v15 < (unint64_t)v70)
          v70 = (unsigned int *)v15;
        if ((unint64_t)v70 < *(_QWORD *)(result + 40))
          v70 = *(unsigned int **)(result + 40);
        v66 = COERCE_FLOAT(bswap32(*v70));
      }
      v68 = &interpolate_waf[2 * ((v48 >> 28) & 3)];
    }
    v71 = v68[1];
    v47 = (float)(v47 - (float)(v47 * v71)) + (float)(v65 * v71);
    v46 = (float)(v46 - (float)(v46 * v71)) + (float)(v66 * v71);
LABEL_92:
    v11[4] = v47;
    v11[5] = v47;
    v11[6] = v47;
    v11[7] = v46;
    *(_BYTE *)(v12 + 1) = v26 >> 22;
    if (a4 == 1)
      break;
    v72 = 0;
    v73 = v11 + 11;
    v74 = a4 - 1;
    a2 += v10;
    v75 = v86 - a2;
    a3 += v9;
    v76 = v88 - a3;
    --a4;
    while (1)
    {
      v77 = v12 + v72 + 1;
      v11 = v73 - 7;
      if (((a2 - v87) | v75 | (a3 - v89) | v76) < 0)
        break;
      v78 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      v79 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      v40 = v78 + v79;
      v41 = *(unsigned int **)(result + 32);
      if (v16 >= v78 + v79)
        v80 = (unsigned int *)(v78 + v79);
      else
        v80 = (unsigned int *)v16;
      if (v80 < v41)
        v80 = *(unsigned int **)(result + 32);
      if (v5)
      {
        v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v79;
        v81 = *(unsigned int **)(result + 40);
        if (v15 >= v43)
          v82 = (unsigned int *)v43;
        else
          v82 = (unsigned int *)v15;
        if (v82 >= v81)
          v81 = v82;
        v46 = COERCE_FLOAT(bswap32(*v81));
      }
      else
      {
        v46 = 1.0;
      }
      v83 = bswap32(*v80);
      if (v8)
      {
        v48 = *(_DWORD *)(v8 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v48 & 0xF) != 0)
        {
          v47 = *(float *)&v83;
          v26 = -1;
          v12 = v77;
          goto LABEL_45;
        }
      }
      --a4;
      *((_DWORD *)v73 - 2) = v83;
      *((_DWORD *)v73 - 1) = v83;
      v84 = v12 + v72++;
      *((_DWORD *)v73 - 3) = v83;
      *v73 = v46;
      v73 += 4;
      a2 += v10;
      v75 -= v10;
      a3 += v9;
      v76 -= v9;
      *(_BYTE *)(v84 + 2) = -1;
      if (v74 == (_DWORD)v72)
        return result;
    }
    v12 += v72 + 1;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_Wf(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  float *v42;
  float *v43;
  float *v44;
  unint64_t v45;
  float *v46;
  float *v47;
  float v48;
  float v49;
  unsigned int v50;
  int v51;
  int v52;
  unint64_t v53;
  float *v54;
  float v55;
  float *v56;
  float v57;
  float v58;
  float v59;
  unint64_t v60;
  unint64_t v61;
  float *v62;
  float *v63;
  float v64;
  float v65;
  float *v66;
  float v67;
  float v68;
  float *v69;
  float *v70;
  float *v71;
  float *v72;
  float v73;
  uint64_t v74;
  float *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  float *v80;
  float *v81;
  float *v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 72);
  v85 = *(_QWORD *)(result + 80);
  v86 = *(_QWORD *)(result + 64);
  v87 = *(_QWORD *)(result + 88);
  v11 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v12 = (float *)(*(_QWORD *)(result + 152) - 16);
  v13 = *(_QWORD *)(result + 144) - 1;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(_DWORD *)(result + 256) - 1;
  v16 = v5 + (v14 * v7) + 4 * v15;
  v84 = *(_DWORD *)(result + 188);
  v17 = v4 + (v14 * v6) + 4 * v15 - 4;
  do
  {
    while (1)
    {
      if (a3 >= v9)
      {
        if (a3 <= v87)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
          v29 = v86;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v87;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_40;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v29 = v86;
          v27 = v25 | v84;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v9 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_40;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v29 = v86;
        v27 = v21 | v84;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v29)
        break;
      v30 = *(_QWORD *)(result + 192);
      v31 = v29 - *(_QWORD *)(result + 200);
      v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v84;
        v33 = v31 + 0x1000000;
        v34 = 32;
        goto LABEL_26;
      }
LABEL_40:
      --a4;
      a2 += v11;
      a3 += v10;
      v12 += 4;
      *(_BYTE *)++v13 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v85)
    {
      v34 = ((unint64_t)a2 >> 26) & 0x3C;
      v33 = a2;
      goto LABEL_26;
    }
    v35 = *(_QWORD *)(result + 192);
    v36 = *(_QWORD *)(result + 200) + v85;
    v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1)
      goto LABEL_40;
    if (v37 < v35)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v37) >> 32) >> 15)) | v84;
    v33 = v36 - 0x1000000;
    v34 = 28;
LABEL_26:
    if (v27 < 0x400000)
      goto LABEL_40;
    v38 = v28 >> 32;
    v39 = v4 + SHIDWORD(v28) * (uint64_t)v6;
    v40 = (v33 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v41 = v39 + v40;
    v42 = *(float **)(result + 32);
    if (v17 >= v39 + v40)
      v43 = (float *)(v39 + v40);
    else
      v43 = (float *)v17;
    if (v43 >= v42)
      v44 = v43;
    else
      v44 = *(float **)(result + 32);
    if (v5)
    {
      v45 = v5 + (int)v38 * (uint64_t)v7 + v40;
      v46 = *(float **)(result + 40);
      if (v16 >= v45)
        v47 = (float *)v45;
      else
        v47 = (float *)v16;
      if (v47 >= v46)
        v46 = v47;
      v48 = *v46;
    }
    else
    {
      v45 = 0;
      v48 = 1.0;
    }
    v49 = *v44;
    if (!v8)
      goto LABEL_93;
    v50 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_46:
    v51 = v50 & 0xF;
    v52 = HIBYTE(v50) & 3;
    if (v51 == 1)
    {
      v66 = (float *)(v41 + SBYTE1(v50) * (uint64_t)v6);
      if (v17 < (unint64_t)v66)
        v66 = (float *)v17;
      if (v66 < v42)
        v66 = v42;
      v67 = *v66;
      v68 = 1.0;
      if (v5)
      {
        v69 = (float *)(v45 + SBYTE1(v50) * (uint64_t)v7);
        if (v16 < (unint64_t)v69)
          v69 = (float *)v16;
        if ((unint64_t)v69 < *(_QWORD *)(result + 40))
          v69 = *(float **)(result + 40);
        v68 = *v69;
      }
      v70 = &interpolate_waf[2 * v52];
    }
    else
    {
      if (v51 != 2)
      {
        if (v51 == 3)
        {
          v53 = v41 + 4 * SBYTE2(v50);
          if (v17 >= v53)
            v54 = (float *)(v41 + 4 * SBYTE2(v50));
          else
            v54 = (float *)v17;
          if (v54 < v42)
            v54 = v42;
          v55 = *v54;
          v56 = (float *)(v53 + SBYTE1(v50) * (uint64_t)v6);
          if (v17 < (unint64_t)v56)
            v56 = (float *)v17;
          if (v56 < v42)
            v56 = v42;
          v57 = *v56;
          v58 = 1.0;
          v59 = 1.0;
          if (v5)
          {
            v60 = v45 + 4 * SBYTE2(v50);
            v61 = *(_QWORD *)(result + 40);
            if (v16 >= v60)
              v62 = (float *)(v45 + 4 * SBYTE2(v50));
            else
              v62 = (float *)v16;
            if ((unint64_t)v62 < v61)
              v62 = *(float **)(result + 40);
            v58 = *v62;
            v63 = (float *)(v60 + SBYTE1(v50) * (uint64_t)v7);
            if (v16 < (unint64_t)v63)
              v63 = (float *)v16;
            if ((unint64_t)v63 < v61)
              v63 = *(float **)(result + 40);
            v59 = *v63;
          }
          v64 = interpolate_waf[2 * v52 + 1];
          v65 = interpolate_waf[2 * ((v50 >> 28) & 3) + 1];
          v49 = (float)((float)((float)(v49 - (float)(v49 * v64)) + (float)(v55 * v64))
                      - (float)((float)((float)(v49 - (float)(v49 * v64)) + (float)(v55 * v64)) * v65))
              + (float)((float)((float)(v55 - (float)(v55 * v64)) + (float)(v57 * v64)) * v65);
          v48 = (float)((float)((float)(v48 - (float)(v48 * v64)) + (float)(v58 * v64))
                      - (float)((float)((float)(v48 - (float)(v48 * v64)) + (float)(v58 * v64)) * v65))
              + (float)((float)((float)(v58 - (float)(v58 * v64)) + (float)(v59 * v64)) * v65);
        }
        goto LABEL_93;
      }
      v71 = (float *)(v41 + 4 * SBYTE2(v50));
      if (v17 < (unint64_t)v71)
        v71 = (float *)v17;
      if (v71 < v42)
        v71 = v42;
      v67 = *v71;
      v68 = 1.0;
      if (v5)
      {
        v72 = (float *)(v45 + 4 * SBYTE2(v50));
        if (v16 < (unint64_t)v72)
          v72 = (float *)v16;
        if ((unint64_t)v72 < *(_QWORD *)(result + 40))
          v72 = *(float **)(result + 40);
        v68 = *v72;
      }
      v70 = &interpolate_waf[2 * ((v50 >> 28) & 3)];
    }
    v73 = v70[1];
    v49 = (float)(v49 - (float)(v49 * v73)) + (float)(v67 * v73);
    v48 = (float)(v48 - (float)(v48 * v73)) + (float)(v68 * v73);
LABEL_93:
    v12[4] = v49;
    v12[5] = v49;
    v12[6] = v49;
    v12[7] = v48;
    *(_BYTE *)(v13 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v74 = 0;
    v75 = v12 + 11;
    a3 += v10;
    v76 = v87 - a3;
    a2 += v11;
    v77 = v85 - a2;
    while ((((a2 - v86) | v77 | (a3 - v9) | v76) & 0x8000000000000000) == 0)
    {
      v78 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      v79 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      v41 = v78 + v79;
      v42 = *(float **)(result + 32);
      if (v17 >= v78 + v79)
        v80 = (float *)(v78 + v79);
      else
        v80 = (float *)v17;
      if (v80 < v42)
        v80 = *(float **)(result + 32);
      if (v5)
      {
        v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v79;
        v81 = *(float **)(result + 40);
        if (v16 >= v45)
          v82 = (float *)v45;
        else
          v82 = (float *)v16;
        if (v82 >= v81)
          v81 = v82;
        v48 = *v81;
      }
      else
      {
        v48 = 1.0;
      }
      v49 = *v80;
      if (v8)
      {
        v50 = *(_DWORD *)(v8 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v50 & 0xF) != 0)
        {
          v13 += v74 + 1;
          v12 = v75 - 7;
          a4 += ~(_DWORD)v74;
          v27 = -1;
          goto LABEL_46;
        }
      }
      *(v75 - 2) = v49;
      *(v75 - 1) = v49;
      v83 = v13 + v74++;
      *(v75 - 3) = v49;
      *v75 = v48;
      v75 += 4;
      v76 -= v10;
      a2 += v11;
      v77 -= v11;
      a3 += v10;
      *(_BYTE *)(v83 + 2) = -1;
      if (a4 - 1 == (_DWORD)v74)
        return result;
    }
    v13 += v74 + 1;
    v12 = v75 - 7;
    a4 += ~(_DWORD)v74;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBF(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  int8x8_t *v42;
  int8x8_t *v43;
  float32x2_t v44;
  float v45;
  unsigned int v46;
  float v47;
  int v48;
  int v49;
  unint64_t v50;
  int8x8_t *v51;
  float v52;
  int8x8_t *v53;
  float32x2_t v54;
  float32x2_t v55;
  int8x8_t *v56;
  float v57;
  uint64_t v58;
  _DWORD *v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  int8x8_t *v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;

  v11 = *(_QWORD *)(result + 32);
  v12 = *(_DWORD *)(result + 24);
  v13 = *(_QWORD *)(result + 176);
  v14 = *(_QWORD *)(result + 72);
  v70 = *(_QWORD *)(result + 88);
  v71 = *(_QWORD *)(result + 80);
  v15 = *(_QWORD *)(result + 112);
  v16 = *(_QWORD *)(result + 120);
  v17 = *(_QWORD *)(result + 152) - 16;
  v18 = *(_QWORD *)(result + 144) - 1;
  v19 = v11
      + ((*(_DWORD *)(result + 260) - 1) * v12)
      + 4 * (3 * *(_DWORD *)(result + 256) - 3)
      - 12;
  v69 = *(_QWORD *)(result + 64);
  v68 = *(_DWORD *)(result + 188);
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v14)
      {
        if ((uint64_t)a3 <= v70)
        {
          v28 = (a3 >> 22) & 0x3C0;
          v29 = 0x3FFFFFFF;
          HIDWORD(v30) = HIDWORD(a3);
        }
        else
        {
          v24 = *(_QWORD *)(result + 216);
          v25 = *(_QWORD *)(result + 224) + v70;
          v26 = v25 - a3 + (v24 >> 1);
          if (v26 < 1)
            goto LABEL_34;
          if (v26 >= v24)
            LODWORD(v27) = 0x3FFFFFFF;
          else
            v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
          v29 = v27 | v68;
          v30 = v25 - 0x1000000;
          v28 = 448;
        }
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = v14 - *(_QWORD *)(result + 224);
        v22 = a3 - v21 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_34;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v29 = v23 | v68;
        v30 = v21 + 0x1000000;
        v28 = 512;
      }
      if (a2 >= v69)
        break;
      v31 = *(_QWORD *)(result + 192);
      v32 = v69 - *(_QWORD *)(result + 200);
      v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31)
          v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v68;
        v34 = v32 + 0x1000000;
        v35 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v15;
      a3 += v16;
      v17 += 16;
      *(_BYTE *)++v18 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v71)
    {
      v35 = ((unint64_t)a2 >> 26) & 0x3C;
      v34 = a2;
      goto LABEL_26;
    }
    v36 = *(_QWORD *)(result + 192);
    v37 = *(_QWORD *)(result + 200) + v71;
    v38 = v37 - a2 + (v36 >> 1);
    if (v38 < 1)
      goto LABEL_34;
    if (v38 < v36)
      v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v38) >> 32) >> 15)) | v68;
    v34 = v37 - 0x1000000;
    v35 = 28;
LABEL_26:
    if (v29 < 0x400000)
      goto LABEL_34;
    v39 = v34 >> 32;
    v40 = v11 + SHIDWORD(v30) * (uint64_t)v12;
    v41 = v40 + 12 * (int)v39;
    v42 = *(int8x8_t **)(result + 32);
    if (v19 >= v41)
      v43 = (int8x8_t *)(v40 + 12 * (int)v39);
    else
      v43 = (int8x8_t *)v19;
    if (v43 < v42)
      v43 = *(int8x8_t **)(result + 32);
    v44 = (float32x2_t)vrev32_s8(*v43);
    v45 = COERCE_FLOAT(bswap32(v43[1].u32[0]));
    if (v13)
    {
      v46 = *(_DWORD *)(v13 + (v35 | v28));
LABEL_38:
      v48 = v46 & 0xF;
      v49 = HIBYTE(v46) & 3;
      switch(v48)
      {
        case 1:
          v56 = (int8x8_t *)(v41 + SBYTE1(v46) * (uint64_t)v12);
          if (v19 < (unint64_t)v56)
            v56 = (int8x8_t *)v19;
          if (v56 < v42)
            v56 = v42;
          v57 = COERCE_FLOAT(bswap32(v56[1].u32[0]));
          break;
        case 2:
          v56 = (int8x8_t *)(v41 + 12 * SBYTE2(v46));
          if (v19 < (unint64_t)v56)
            v56 = (int8x8_t *)v19;
          if (v56 < v42)
            v56 = v42;
          v57 = COERCE_FLOAT(bswap32(v56[1].u32[0]));
          v49 = (v46 >> 28) & 3;
          break;
        case 3:
          v50 = v41 + 12 * SBYTE2(v46);
          if (v19 >= v50)
            v51 = (int8x8_t *)(v41 + 12 * SBYTE2(v46));
          else
            v51 = (int8x8_t *)v19;
          if (v51 < v42)
            v51 = v42;
          v52 = COERCE_FLOAT(bswap32(v51[1].u32[0]));
          v53 = (int8x8_t *)(v50 + SBYTE1(v46) * (uint64_t)v12);
          if (v19 < (unint64_t)v53)
            v53 = (int8x8_t *)v19;
          if (v53 < v42)
            v53 = v42;
          LODWORD(a10) = interpolate_rgbaf_19467[4 * v49 + 3];
          LODWORD(a11) = interpolate_rgbaf_19467[4 * ((v46 >> 28) & 3) + 3];
          v45 = (float)((float)((float)(v45 - (float)(v45 * *(float *)&a10)) + (float)(v52 * *(float *)&a10))
                      - (float)((float)((float)(v45 - (float)(v45 * *(float *)&a10)) + (float)(v52 * *(float *)&a10))
                              * *(float *)&a11))
              + (float)((float)((float)(v52 - (float)(v52 * *(float *)&a10))
                              + (float)(COERCE_FLOAT(bswap32(v53[1].u32[0])) * *(float *)&a10))
                      * *(float *)&a11);
          v54 = (float32x2_t)vrev32_s8(*v51);
          v55 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a10, 0), v54, *(float *)&a10);
          a9 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(v54, v54, *(float32x2_t *)&a10, 0), (float32x2_t)vrev32_s8(*v53), *(float *)&a10));
          v44 = vmla_n_f32(vmls_lane_f32(v55, v55, *(float32x2_t *)&a11, 0), *(float32x2_t *)&a9, *(float *)&a11);
          v47 = (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10))
                      - (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11))
              + (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      LODWORD(a9) = interpolate_rgbaf_19467[4 * v49 + 3];
      a10 = COERCE_DOUBLE(vrev32_s8(*v56));
      v44 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a10, *(float *)&a9);
      v45 = (float)(v45 - (float)(v45 * *(float *)&a9)) + (float)(v57 * *(float *)&a9);
      v47 = *(float *)&a9 + (float)(1.0 - *(float *)&a9);
      goto LABEL_62;
    }
LABEL_36:
    v47 = 1.0;
LABEL_62:
    *(float32x2_t *)(v17 + 16) = v44;
    *(float *)(v17 + 24) = v45;
    *(float *)(v17 + 28) = v47;
    *(_BYTE *)(v18 + 1) = v29 >> 22;
    if (a4 == 1)
      break;
    v58 = 0;
    v59 = (_DWORD *)(v17 + 44);
    a2 += v15;
    v60 = v71 - a2;
    a3 += v16;
    v61 = v70 - a3;
    v62 = --a4;
    while (1)
    {
      v63 = v18 + v58 + 1;
      v17 = (uint64_t)(v59 - 7);
      if ((((a2 - v69) | v60 | (a3 - v14) | v61) & 0x8000000000000000) != 0)
        break;
      v64 = v11 + SHIDWORD(a3) * (uint64_t)v12;
      v41 = v64 + 12 * SHIDWORD(a2);
      v42 = *(int8x8_t **)(result + 32);
      if (v19 >= v41)
        v65 = (int8x8_t *)(v64 + 12 * SHIDWORD(a2));
      else
        v65 = (int8x8_t *)v19;
      if (v65 < v42)
        v65 = *(int8x8_t **)(result + 32);
      v44 = (float32x2_t)vrev32_s8(*v65);
      v66 = bswap32(v65[1].u32[0]);
      if (v13)
      {
        v46 = *(_DWORD *)(v13 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v46 & 0xF) != 0)
        {
          v45 = *(float *)&v66;
          v29 = -1;
          v18 = v63;
          goto LABEL_38;
        }
      }
      --a4;
      *(float32x2_t *)(v59 - 3) = v44;
      *(v59 - 1) = v66;
      *v59 = 1065353216;
      v67 = v18 + v58++;
      v59 += 4;
      a2 += v15;
      *(_BYTE *)(v67 + 2) = -1;
      v60 -= v15;
      a3 += v16;
      v61 -= v16;
      if (v62 == (_DWORD)v58)
        return result;
    }
    v18 += v58 + 1;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBf(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  float32x2_t *v45;
  float32x2_t *v46;
  float32x2_t v47;
  float v48;
  unsigned int v49;
  float v50;
  int v51;
  int v52;
  unint64_t v53;
  float32x2_t *v54;
  float32x2_t *v55;
  float32x2_t v56;
  unint64_t v57;
  float v58;
  unint64_t v59;
  uint64_t v60;
  float *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;

  v11 = *(_QWORD *)(result + 32);
  v12 = *(_DWORD *)(result + 24);
  v13 = *(_QWORD *)(result + 176);
  v14 = *(_QWORD *)(result + 64);
  v15 = *(_QWORD *)(result + 72);
  v16 = *(_QWORD *)(result + 80);
  v17 = *(_QWORD *)(result + 88);
  v18 = *(_QWORD *)(result + 112);
  v19 = *(_QWORD *)(result + 120);
  v20 = *(_QWORD *)(result + 152) - 16;
  v21 = *(_QWORD *)(result + 144) - 1;
  v22 = v11
      + ((*(_DWORD *)(result + 260) - 1) * v12)
      + 4 * (3 * *(_DWORD *)(result + 256) - 3)
      - 12;
  v66 = *(_DWORD *)(result + 188);
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v15)
      {
        if ((uint64_t)a3 <= v17)
        {
          v31 = (a3 >> 22) & 0x3C0;
          v32 = 0x3FFFFFFF;
          HIDWORD(v33) = HIDWORD(a3);
        }
        else
        {
          v27 = *(_QWORD *)(result + 216);
          v28 = *(_QWORD *)(result + 224) + v17;
          v29 = v28 - a3 + (v27 >> 1);
          if (v29 < 1)
            goto LABEL_34;
          if (v29 >= v27)
            LODWORD(v30) = 0x3FFFFFFF;
          else
            v30 = (unint64_t)(*(_QWORD *)(result + 232) * v29) >> 32;
          v32 = v30 | v66;
          v33 = v28 - 0x1000000;
          v31 = 448;
        }
      }
      else
      {
        v23 = *(_QWORD *)(result + 216);
        v24 = v15 - *(_QWORD *)(result + 224);
        v25 = a3 - v24 + (v23 >> 1);
        if (v25 < 1)
          goto LABEL_34;
        if (v25 >= v23)
          LODWORD(v26) = 0x3FFFFFFF;
        else
          v26 = (unint64_t)(*(_QWORD *)(result + 232) * v25) >> 32;
        v32 = v26 | v66;
        v33 = v24 + 0x1000000;
        v31 = 512;
      }
      if (a2 >= v14)
        break;
      v34 = *(_QWORD *)(result + 192);
      v35 = v14 - *(_QWORD *)(result + 200);
      v36 = a2 - v35 + (v34 >> 1);
      if (v36 >= 1)
      {
        if (v36 < v34)
          v32 = ((v32 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v66;
        v37 = v35 + 0x1000000;
        v38 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v18;
      a3 += v19;
      v20 += 16;
      *(_BYTE *)++v21 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v16)
    {
      v38 = ((unint64_t)a2 >> 26) & 0x3C;
      v37 = a2;
      goto LABEL_26;
    }
    v39 = *(_QWORD *)(result + 192);
    v40 = *(_QWORD *)(result + 200) + v16;
    v41 = v40 - a2 + (v39 >> 1);
    if (v41 < 1)
      goto LABEL_34;
    if (v41 < v39)
      v32 = ((v32 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v41) >> 32) >> 15)) | v66;
    v37 = v40 - 0x1000000;
    v38 = 28;
LABEL_26:
    if (v32 < 0x400000)
      goto LABEL_34;
    v42 = v37 >> 32;
    v43 = v11 + SHIDWORD(v33) * (uint64_t)v12;
    v44 = v43 + 12 * (int)v42;
    v45 = *(float32x2_t **)(result + 32);
    if (v22 >= v44)
      v46 = (float32x2_t *)(v43 + 12 * (int)v42);
    else
      v46 = (float32x2_t *)v22;
    if (v46 < v45)
      v46 = *(float32x2_t **)(result + 32);
    v47 = *v46;
    v48 = v46[1].f32[0];
    if (v13)
    {
      v49 = *(_DWORD *)(v13 + (v38 | v31));
LABEL_38:
      v51 = v49 & 0xF;
      v52 = HIBYTE(v49) & 3;
      switch(v51)
      {
        case 1:
          v57 = v44 + SBYTE1(v49) * (uint64_t)v12;
          if (v22 < v57)
            v57 = v22;
          if (v57 < (unint64_t)v45)
            v57 = (unint64_t)v45;
          v58 = *(float *)(v57 + 8);
          LODWORD(a9) = interpolate_rgbaf_19467[4 * v52 + 3];
          a10 = *(double *)v57;
          break;
        case 2:
          v59 = v44 + 12 * SBYTE2(v49);
          if (v22 < v59)
            v59 = v22;
          if (v59 < (unint64_t)v45)
            v59 = (unint64_t)v45;
          v58 = *(float *)(v59 + 8);
          LODWORD(a9) = interpolate_rgbaf_19467[4 * ((v49 >> 28) & 3) + 3];
          a10 = *(double *)v59;
          break;
        case 3:
          v53 = v44 + 12 * SBYTE2(v49);
          if (v22 >= v53)
            v54 = (float32x2_t *)(v44 + 12 * SBYTE2(v49));
          else
            v54 = (float32x2_t *)v22;
          if (v54 < v45)
            v54 = v45;
          v55 = (float32x2_t *)(v53 + SBYTE1(v49) * (uint64_t)v12);
          if (v22 < (unint64_t)v55)
            v55 = (float32x2_t *)v22;
          if (v55 < v45)
            v55 = v45;
          LODWORD(a10) = interpolate_rgbaf_19467[4 * v52 + 3];
          LODWORD(a11) = interpolate_rgbaf_19467[4 * ((v49 >> 28) & 3) + 3];
          v48 = (float)((float)((float)(v48 - (float)(v48 * *(float *)&a10)) + (float)(v54[1].f32[0] * *(float *)&a10))
                      - (float)((float)((float)(v48 - (float)(v48 * *(float *)&a10))
                                      + (float)(v54[1].f32[0] * *(float *)&a10))
                              * *(float *)&a11))
              + (float)((float)((float)(v54[1].f32[0] - (float)(v54[1].f32[0] * *(float *)&a10))
                              + (float)(v55[1].f32[0] * *(float *)&a10))
                      * *(float *)&a11);
          v56 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a10, 0), *v54, *(float *)&a10);
          a9 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(*v54, *v54, *(float32x2_t *)&a10, 0), *v55, *(float *)&a10));
          v47 = vmla_n_f32(vmls_lane_f32(v56, v56, *(float32x2_t *)&a11, 0), *(float32x2_t *)&a9, *(float *)&a11);
          v50 = (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10))
                      - (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11))
              + (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      v47 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a10, *(float *)&a9);
      v48 = (float)(v48 - (float)(v48 * *(float *)&a9)) + (float)(v58 * *(float *)&a9);
      v50 = *(float *)&a9 + (float)(1.0 - *(float *)&a9);
      goto LABEL_62;
    }
LABEL_36:
    v50 = 1.0;
LABEL_62:
    *(float32x2_t *)(v20 + 16) = v47;
    *(float *)(v20 + 24) = v48;
    *(float *)(v20 + 28) = v50;
    *(_BYTE *)(v21 + 1) = v32 >> 22;
    if (a4 == 1)
      break;
    v60 = 0;
    v61 = (float *)(v20 + 44);
    a2 += v18;
    v62 = v16 - a2;
    a3 += v19;
    v63 = v17 - a3;
    while ((((a2 - v14) | v62 | (a3 - v15) | v63) & 0x8000000000000000) == 0)
    {
      v44 = v11 + SHIDWORD(a3) * (uint64_t)v12 + 12 * SHIDWORD(a2);
      v45 = *(float32x2_t **)(result + 32);
      if (v22 >= v44)
        v64 = v11 + SHIDWORD(a3) * (uint64_t)v12 + 12 * SHIDWORD(a2);
      else
        v64 = v22;
      if (v64 < (unint64_t)v45)
        v64 = *(_QWORD *)(result + 32);
      v47 = *(float32x2_t *)v64;
      v48 = *(float *)(v64 + 8);
      if (v13)
      {
        v49 = *(_DWORD *)(v13 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v49 & 0xF) != 0)
        {
          v21 += v60 + 1;
          v20 = (uint64_t)(v61 - 7);
          a4 += ~(_DWORD)v60;
          v32 = -1;
          goto LABEL_38;
        }
      }
      *(float32x2_t *)(v61 - 3) = v47;
      *(v61 - 1) = v48;
      v65 = v21 + v60++;
      *v61 = 1.0;
      v61 += 4;
      a2 += v18;
      *(_BYTE *)(v65 + 2) = -1;
      v62 -= v18;
      a3 += v19;
      v63 -= v19;
      if (a4 - 1 == (_DWORD)v60)
        return result;
    }
    v21 += v60 + 1;
    v20 = (uint64_t)(v61 - 7);
    a4 += ~(_DWORD)v60;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBAF_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  float32x2_t v11;
  float32x2_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  int8x8_t *v54;
  int8x8_t *v55;
  float v56;
  float32x2_t v57;
  float v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int8x8_t *v75;
  float32x2_t v76;
  float v77;
  float v78;
  float v79;
  int8x8_t *v80;
  float32x2_t v81;
  float v82;
  float32x2_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int8x8_t *v89;
  float32x2_t v90;
  float v91;
  float v92;
  _DWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int8x8_t *v98;
  uint64_t v99;
  float *v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int8x8_t *v113;
  unsigned int v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;

  v13 = *(_DWORD *)(result + 24);
  v14 = *(_QWORD *)(result + 112);
  v15 = *(_QWORD *)(result + 48);
  v16 = *(_QWORD *)(result + 56);
  if (v15)
  {
    v122 = *(_QWORD *)(result + 112);
    if (v14 > v15)
      v122 = v14 % v15;
  }
  else
  {
    v122 = 0;
  }
  v17 = *(_QWORD *)(result + 176);
  v18 = *(_QWORD *)(result + 32);
  v19 = *(_QWORD *)(result + 120);
  if (v16)
  {
    v20 = v19 % v16;
    if (v19 <= v16)
      v20 = *(_QWORD *)(result + 120);
    v121 = v20;
  }
  else
  {
    v121 = 0;
  }
  v117 = *(_QWORD *)(result + 80);
  v118 = *(_QWORD *)(result + 64);
  v119 = *(_QWORD *)(result + 88);
  v120 = *(_QWORD *)(result + 72);
  v116 = *(_DWORD *)(result + 188);
  v21 = *(_QWORD *)(result + 152) - 16;
  v22 = *(_QWORD *)(result + 144) - 1;
  v23 = *(_QWORD *)(result + 40);
  v24 = v18
      + ((*(_DWORD *)(result + 260) - 1) * v13)
      + 4 * (4 * *(_DWORD *)(result + 256) - 4)
      - 16;
  do
  {
    while (1)
    {
      if (a3 < v120)
      {
        v25 = *(_QWORD *)(result + 216);
        v26 = v120 - *(_QWORD *)(result + 224);
        v27 = a3 - v26 + (v25 >> 1);
        if (v27 < 1)
          goto LABEL_52;
        if (v27 >= v25)
          LODWORD(v28) = 0x3FFFFFFF;
        else
          v28 = (unint64_t)(*(_QWORD *)(result + 232) * v27) >> 32;
        v35 = v116 | v28;
        v36 = v26 + 0x1000000;
        v33 = a3 - (v26 + 0x1000000);
        v34 = 512;
        goto LABEL_22;
      }
      if (a3 <= v119)
      {
        v33 = 0;
        v34 = ((unint64_t)a3 >> 22) & 0x3C0;
        v35 = 0x3FFFFFFF;
        v36 = a3;
LABEL_22:
        v37 = v118;
        goto LABEL_25;
      }
      v29 = *(_QWORD *)(result + 216);
      v30 = *(_QWORD *)(result + 224) + v119;
      v31 = v30 - a3 + (v29 >> 1);
      if (v31 < 1)
        goto LABEL_52;
      if (v31 >= v29)
        LODWORD(v32) = 0x3FFFFFFF;
      else
        v32 = (unint64_t)(*(_QWORD *)(result + 232) * v31) >> 32;
      v37 = v118;
      v35 = v116 | v32;
      v36 = v30 - 0x1000000;
      v33 = a3 - (v30 - 0x1000000);
      v34 = 448;
LABEL_25:
      if (a2 >= v37)
        break;
      v38 = *(_QWORD *)(result + 192);
      v39 = v37 - *(_QWORD *)(result + 200);
      v40 = a2 - v39 + (v38 >> 1);
      if (v40 >= 1)
      {
        if (v40 < v38)
          v35 = ((v35 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v116;
        v41 = v39 + 0x1000000;
        v42 = a2 - (v39 + 0x1000000);
        v43 = 32;
        goto LABEL_36;
      }
LABEL_52:
      --a4;
      a2 += v14;
      a3 += v19;
      v21 += 16;
      *(_BYTE *)++v22 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v117)
    {
      v42 = 0;
      v43 = ((unint64_t)a2 >> 26) & 0x3C;
      v41 = a2;
      goto LABEL_36;
    }
    v44 = *(_QWORD *)(result + 192);
    v45 = *(_QWORD *)(result + 200) + v117;
    v46 = v45 - a2 + (v44 >> 1);
    if (v46 < 1)
      goto LABEL_52;
    if (v46 < v44)
      v35 = ((v35 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v46) >> 32) >> 15)) | v116;
    v41 = v45 - 0x1000000;
    v42 = a2 - (v45 - 0x1000000);
    v43 = 28;
LABEL_36:
    if (v35 < 0x400000)
      goto LABEL_52;
    if (v15)
    {
      v47 = (v16 & ((v36 % v16) >> 63)) + v36 % v16;
      v48 = (v15 & ((v41 % v15) >> 63)) + v41 % v15;
      if (v47 >= v16)
        v49 = v16;
      else
        v49 = 0;
      v36 = v47 - v49;
      if (v48 >= v15)
        v50 = v15;
      else
        v50 = 0;
      v41 = v48 - v50;
      v33 += v36;
      v42 += v41;
    }
    v51 = v18 + SHIDWORD(v36) * (uint64_t)v13;
    v52 = v41 >> 32;
    v53 = v51 + 16 * v52;
    v54 = *(int8x8_t **)(result + 32);
    if (v24 >= v53)
      v55 = (int8x8_t *)(v51 + 16 * v52);
    else
      v55 = (int8x8_t *)v24;
    if (v55 < v54)
      v55 = *(int8x8_t **)(result + 32);
    if (v23)
      v56 = COERCE_FLOAT(bswap32(v55[1].u32[1]));
    else
      v56 = 1.0;
    v57 = (float32x2_t)vrev32_s8(*v55);
    v58 = COERCE_FLOAT(bswap32(v55[1].u32[0]));
    if (!v17)
      goto LABEL_107;
    v59 = *(_DWORD *)(v17 + (v43 | v34));
LABEL_58:
    v60 = v59 & 0xF;
    v61 = v59 >> 8;
    v62 = HIBYTE(v59) & 3;
    if (v60 == 1)
    {
      LODWORD(v84) = SBYTE1(v59);
      if (v15)
      {
        v85 = v61 << 56;
        v86 = v33 + ((uint64_t)SBYTE1(v59) << 32);
        v87 = v16 & (v86 >> 63);
        if (v87 + v86 >= v16)
          v88 = v16;
        else
          v88 = 0;
        v84 = (v87 + (v85 >> 24) - v88) >> 32;
      }
      v89 = (int8x8_t *)(v53 + (int)v84 * (uint64_t)v13);
      if (v24 < (unint64_t)v89)
        v89 = (int8x8_t *)v24;
      if (v89 < v54)
        v89 = v54;
      v90 = (float32x2_t)vrev32_s8(*v89);
      v91 = COERCE_FLOAT(bswap32(v89[1].u32[0]));
      v92 = 1.0;
      if (v23)
        v92 = COERCE_FLOAT(bswap32(v89[1].u32[1]));
      v93 = &interpolate_rgbaf_19467[4 * v62];
    }
    else
    {
      if (v60 != 2)
      {
        if (v60 == 3)
        {
          LODWORD(v63) = SBYTE1(v59);
          v64 = SBYTE2(v59);
          if (v15)
          {
            v65 = v61 << 56;
            v66 = (unint64_t)HIWORD(v59) << 56;
            v67 = v33 + (v65 >> 24);
            v68 = v42 + (v66 >> 24);
            v69 = v16 & (v67 >> 63);
            v70 = v15 & (v68 >> 63);
            v71 = v70 + v68;
            if (v69 + v67 >= v16)
              v72 = v16;
            else
              v72 = 0;
            if (v71 >= v15)
              v73 = v15;
            else
              v73 = 0;
            v63 = (v69 + (v65 >> 24) - v72) >> 32;
            v64 = (v70 + (v66 >> 24) - v73) >> 32;
          }
          v74 = (int)v63 * (uint64_t)v13;
          v75 = (int8x8_t *)(v53 + 16 * v64);
          if (v24 < (unint64_t)v75)
            v75 = (int8x8_t *)v24;
          if (v75 < v54)
            v75 = v54;
          v76 = (float32x2_t)vrev32_s8(*v75);
          v77 = COERCE_FLOAT(bswap32(v75[1].u32[0]));
          v78 = 1.0;
          v79 = 1.0;
          if (v23)
            v79 = COERCE_FLOAT(bswap32(v75[1].u32[1]));
          v80 = (int8x8_t *)(v53 + v74 + 16 * v64);
          if (v24 < (unint64_t)v80)
            v80 = (int8x8_t *)v24;
          if (v80 < v54)
            v80 = v54;
          v81 = (float32x2_t)vrev32_s8(*v80);
          v82 = COERCE_FLOAT(bswap32(v80[1].u32[0]));
          if (v23)
            v78 = COERCE_FLOAT(bswap32(v80[1].u32[1]));
          v11.i32[0] = interpolate_rgbaf_19467[4 * v62 + 3];
          v12.i32[0] = interpolate_rgbaf_19467[4 * ((v59 >> 28) & 3) + 3];
          v58 = (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v77 * v11.f32[0]))
                      - (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v77 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v77 - (float)(v77 * v11.f32[0])) + (float)(v82 * v11.f32[0])) * v12.f32[0]);
          v83 = vmla_n_f32(vmls_lane_f32(v57, v57, v11, 0), v76, v11.f32[0]);
          v57 = vmla_n_f32(vmls_lane_f32(v83, v83, v12, 0), vmla_n_f32(vmls_lane_f32(v76, v76, v11, 0), v81, v11.f32[0]), v12.f32[0]);
          v56 = (float)((float)((float)(v56 - (float)(v56 * v11.f32[0])) + (float)(v79 * v11.f32[0]))
                      - (float)((float)((float)(v56 - (float)(v56 * v11.f32[0])) + (float)(v79 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v79 - (float)(v79 * v11.f32[0])) + (float)(v78 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_107;
      }
      v94 = SBYTE2(v59);
      if (v15)
      {
        v95 = v42 + ((uint64_t)SBYTE2(v59) << 32);
        v96 = v15 & (v95 >> 63);
        if (v96 + v95 >= v15)
          v97 = v15;
        else
          v97 = 0;
        v94 = (v96 + ((uint64_t)((unint64_t)HIWORD(v59) << 56) >> 24) - v97) >> 32;
      }
      v98 = (int8x8_t *)(v53 + 16 * v94);
      if (v24 < (unint64_t)v98)
        v98 = (int8x8_t *)v24;
      if (v98 < v54)
        v98 = v54;
      v90 = (float32x2_t)vrev32_s8(*v98);
      v91 = COERCE_FLOAT(bswap32(v98[1].u32[0]));
      v92 = 1.0;
      if (v23)
        v92 = COERCE_FLOAT(bswap32(v98[1].u32[1]));
      v93 = &interpolate_rgbaf_19467[4 * ((v59 >> 28) & 3)];
    }
    LODWORD(a11) = v93[3];
    v57 = vmla_n_f32(vmls_lane_f32(v57, v57, *(float32x2_t *)&a11, 0), v90, *(float *)&a11);
    v58 = (float)(v58 - (float)(v58 * *(float *)&a11)) + (float)(v91 * *(float *)&a11);
    v56 = (float)(v56 - (float)(v56 * *(float *)&a11)) + (float)(v92 * *(float *)&a11);
LABEL_107:
    *(float32x2_t *)(v21 + 16) = v57;
    *(float *)(v21 + 24) = v58;
    *(float *)(v21 + 28) = v56;
    *(_BYTE *)(v22 + 1) = v35 >> 22;
    if (a4 == 1)
      break;
    v99 = 0;
    v100 = (float *)(v21 + 44);
    a2 += v14;
    v101 = v117 - a2;
    a3 += v19;
    v102 = v119 - a3;
    v103 = --a4;
    while (1)
    {
      v104 = v22 + v99 + 1;
      v21 = (uint64_t)(v100 - 7);
      if ((v102 | v101 | (a3 - v120) | (a2 - v118)) < 0)
        break;
      if (v15)
      {
        v105 = (v16 & ((v33 + v121) >> 63)) + v33 + v121;
        v106 = (v15 & ((v42 + v122) >> 63)) + v42 + v122;
        if (v105 >= v16)
          v107 = v16;
        else
          v107 = 0;
        v108 = v105 - v107;
        if (v106 >= v15)
          v109 = v15;
        else
          v109 = 0;
        v110 = v106 - v109;
        v42 = v110;
        v33 = v108;
      }
      else
      {
        v110 = a2;
        HIDWORD(v108) = HIDWORD(a3);
      }
      v111 = v18 + SHIDWORD(v108) * (uint64_t)v13;
      v112 = v110 >> 32;
      v53 = v111 + 16 * v112;
      v54 = *(int8x8_t **)(result + 32);
      if (v24 >= v53)
        v113 = (int8x8_t *)(v111 + 16 * v112);
      else
        v113 = (int8x8_t *)v24;
      if (v113 < v54)
        v113 = *(int8x8_t **)(result + 32);
      if (v23)
        v56 = COERCE_FLOAT(bswap32(v113[1].u32[1]));
      else
        v56 = 1.0;
      v57 = (float32x2_t)vrev32_s8(*v113);
      v114 = bswap32(v113[1].u32[0]);
      if (v17)
      {
        v59 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v59 & 0xF) != 0)
        {
          v58 = *(float *)&v114;
          v35 = -1;
          v22 = v104;
          goto LABEL_58;
        }
      }
      --a4;
      *(float32x2_t *)(v100 - 3) = v57;
      *((_DWORD *)v100 - 1) = v114;
      v115 = v22 + v99++;
      *v100 = v56;
      v100 += 4;
      a2 += v14;
      *(_BYTE *)(v115 + 2) = -1;
      v101 -= v14;
      a3 += v19;
      v102 -= v19;
      if (v103 == (_DWORD)v99)
        return result;
    }
    v22 += v99 + 1;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBAf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  float32x2_t v11;
  float32x2_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  float32x2_t *v56;
  float32x2_t *v57;
  float v58;
  float32x2_t v59;
  float v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  float32x2_t *v79;
  float32x2_t v80;
  float v81;
  float32x2_t *v82;
  float32x2_t *v83;
  float v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  float32x2_t *v91;
  float32x2_t v92;
  float v93;
  float v94;
  _DWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  float32x2_t *v101;
  float32x2_t *v102;
  float32x2_t v103;
  uint64_t v104;
  float *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  float32x2_t *v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;

  v13 = *(_DWORD *)(result + 24);
  v14 = *(_QWORD *)(result + 112);
  v15 = *(_QWORD *)(result + 48);
  v16 = *(_QWORD *)(result + 56);
  if (v15)
  {
    v17 = *(_QWORD *)(result + 112);
    if (v14 > v15)
      v17 = v14 % v15;
  }
  else
  {
    v17 = 0;
  }
  v18 = *(_QWORD *)(result + 176);
  v19 = *(_QWORD *)(result + 32);
  v20 = *(_QWORD *)(result + 120);
  if (v16)
  {
    v21 = v20 % v16;
    if (v20 <= v16)
      v21 = *(_QWORD *)(result + 120);
    v124 = v21;
  }
  else
  {
    v124 = 0;
  }
  v123 = *(_QWORD *)(result + 80);
  v120 = *(_QWORD *)(result + 64);
  v121 = *(_QWORD *)(result + 88);
  v119 = *(_DWORD *)(result + 188);
  v22 = *(_QWORD *)(result + 152) - 16;
  v23 = *(_QWORD *)(result + 144) - 1;
  v24 = *(_QWORD *)(result + 40);
  v25 = v19
      + ((*(_DWORD *)(result + 260) - 1) * v13)
      + 4 * (4 * *(_DWORD *)(result + 256) - 4)
      - 16;
  v122 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v122)
      {
        if (a3 <= v121)
        {
          v34 = 0;
          v35 = ((unint64_t)a3 >> 22) & 0x3C0;
          v36 = 0x3FFFFFFF;
          v37 = a3;
          v38 = v120;
          v39 = v123;
        }
        else
        {
          v30 = *(_QWORD *)(result + 216);
          v31 = *(_QWORD *)(result + 224) + v121;
          v32 = v31 - a3 + (v30 >> 1);
          if (v32 < 1)
            goto LABEL_51;
          if (v32 >= v30)
            LODWORD(v33) = 0x3FFFFFFF;
          else
            v33 = (unint64_t)(*(_QWORD *)(result + 232) * v32) >> 32;
          v38 = v120;
          v39 = v123;
          v36 = v119 | v33;
          v37 = v31 - 0x1000000;
          v34 = a3 - (v31 - 0x1000000);
          v35 = 448;
        }
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = v122 - *(_QWORD *)(result + 224);
        v28 = a3 - v27 + (v26 >> 1);
        if (v28 < 1)
          goto LABEL_51;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v38 = v120;
        v39 = v123;
        v36 = v119 | v29;
        v37 = v27 + 0x1000000;
        v34 = a3 - (v27 + 0x1000000);
        v35 = 512;
      }
      if (a2 >= v38)
        break;
      v40 = *(_QWORD *)(result + 192);
      v41 = v38 - *(_QWORD *)(result + 200);
      v42 = a2 - v41 + (v40 >> 1);
      if (v42 >= 1)
      {
        if (v42 < v40)
          v36 = ((v36 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v119;
        v43 = v41 + 0x1000000;
        v44 = a2 - (v41 + 0x1000000);
        v45 = 32;
        goto LABEL_35;
      }
LABEL_51:
      --a4;
      a2 += v14;
      a3 += v20;
      v22 += 16;
      *(_BYTE *)++v23 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v39)
    {
      v44 = 0;
      v45 = ((unint64_t)a2 >> 26) & 0x3C;
      v43 = a2;
      goto LABEL_35;
    }
    v46 = *(_QWORD *)(result + 192);
    v47 = *(_QWORD *)(result + 200) + v39;
    v48 = v47 - a2 + (v46 >> 1);
    if (v48 < 1)
      goto LABEL_51;
    if (v48 < v46)
      v36 = ((v36 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v48) >> 32) >> 15)) | v119;
    v43 = v47 - 0x1000000;
    v44 = a2 - (v47 - 0x1000000);
    v45 = 28;
LABEL_35:
    if (v36 < 0x400000)
      goto LABEL_51;
    if (v15)
    {
      v49 = (v16 & ((v37 % v16) >> 63)) + v37 % v16;
      v50 = (v15 & ((v43 % v15) >> 63)) + v43 % v15;
      if (v49 >= v16)
        v51 = v16;
      else
        v51 = 0;
      v37 = v49 - v51;
      if (v50 >= v15)
        v52 = v15;
      else
        v52 = 0;
      v43 = v50 - v52;
      v34 += v37;
      v44 += v43;
    }
    v53 = v19 + SHIDWORD(v37) * (uint64_t)v13;
    v54 = v43 >> 32;
    v55 = v53 + 16 * v54;
    v56 = *(float32x2_t **)(result + 32);
    if (v25 >= v55)
      v57 = (float32x2_t *)(v53 + 16 * v54);
    else
      v57 = (float32x2_t *)v25;
    if (v57 < v56)
      v57 = *(float32x2_t **)(result + 32);
    if (v24)
      v58 = v57[1].f32[1];
    else
      v58 = 1.0;
    v59 = *v57;
    v60 = v57[1].f32[0];
    if (!v18)
      goto LABEL_114;
    v61 = *(_DWORD *)(v18 + (v45 | v35));
LABEL_57:
    v62 = v61 & 0xF;
    v63 = v61 >> 8;
    v64 = HIBYTE(v61) & 3;
    if (v62 == 1)
    {
      LODWORD(v85) = SBYTE1(v61);
      if (v15)
      {
        v86 = v63 << 56;
        v87 = v34 + ((uint64_t)SBYTE1(v61) << 32);
        v88 = v16 & (v87 >> 63);
        if (v88 + v87 >= v16)
          v89 = v16;
        else
          v89 = 0;
        v85 = (v88 + (v86 >> 24) - v89) >> 32;
      }
      v90 = v55 + (int)v85 * (uint64_t)v13;
      if (v25 < v90)
        v90 = v25;
      if (v90 >= (unint64_t)v56)
        v91 = (float32x2_t *)v90;
      else
        v91 = v56;
      v92 = *v91;
      v93 = v91[1].f32[0];
      v94 = 1.0;
      if (v24)
        v94 = v91[1].f32[1];
      v95 = &interpolate_rgbaf_19467[4 * v64];
    }
    else
    {
      if (v62 != 2)
      {
        if (v62 == 3)
        {
          v118 = v17;
          LODWORD(v65) = SBYTE1(v61);
          v66 = SBYTE2(v61);
          if (v15)
          {
            v67 = v63 << 56;
            v68 = v34 + (v67 >> 24);
            v69 = v44 + ((uint64_t)SBYTE2(v61) << 32);
            v70 = v16 & (v68 >> 63);
            v71 = v15 & (v69 >> 63);
            v72 = v71 + v69;
            if (v70 + v68 >= v16)
              v73 = v16;
            else
              v73 = 0;
            if (v72 >= v15)
              v74 = v15;
            else
              v74 = 0;
            v75 = v70 + (v67 >> 24);
            v64 = HIBYTE(v61) & 3;
            v65 = (v75 - v73) >> 32;
            v66 = (v71 + ((uint64_t)((unint64_t)HIWORD(v61) << 56) >> 24) - v74) >> 32;
          }
          v76 = (int)v65 * (uint64_t)v13;
          v77 = 16 * v66;
          v78 = v55 + 16 * v66;
          if (v25 < v78)
            v78 = v25;
          if (v78 >= (unint64_t)v56)
            v79 = (float32x2_t *)v78;
          else
            v79 = v56;
          v80 = *v79;
          if (v24)
          {
            v81 = v79[1].f32[1];
            v82 = (float32x2_t *)(v55 + v76 + v77);
            if (v25 < (unint64_t)v82)
              v82 = (float32x2_t *)v25;
            if (v82 >= v56)
              v83 = v82;
            else
              v83 = v56;
            v84 = v83[1].f32[1];
          }
          else
          {
            v102 = (float32x2_t *)(v55 + v76 + v77);
            if (v25 < (unint64_t)v102)
              v102 = (float32x2_t *)v25;
            if (v102 >= v56)
              v83 = v102;
            else
              v83 = v56;
            v81 = 1.0;
            v84 = 1.0;
          }
          v17 = v118;
          v11.i32[0] = interpolate_rgbaf_19467[4 * v64 + 3];
          v12.i32[0] = interpolate_rgbaf_19467[4 * ((v61 >> 28) & 3) + 3];
          v60 = (float)((float)((float)(v60 - (float)(v60 * v11.f32[0])) + (float)(v79[1].f32[0] * v11.f32[0]))
                      - (float)((float)((float)(v60 - (float)(v60 * v11.f32[0])) + (float)(v79[1].f32[0] * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v79[1].f32[0] - (float)(v79[1].f32[0] * v11.f32[0]))
                              + (float)(v83[1].f32[0] * v11.f32[0]))
                      * v12.f32[0]);
          v103 = vmla_n_f32(vmls_lane_f32(v59, v59, v11, 0), v80, v11.f32[0]);
          v59 = vmla_n_f32(vmls_lane_f32(v103, v103, v12, 0), vmla_n_f32(vmls_lane_f32(v80, v80, v11, 0), *v83, v11.f32[0]), v12.f32[0]);
          v58 = (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v81 * v11.f32[0]))
                      - (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v81 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v81 - (float)(v81 * v11.f32[0])) + (float)(v84 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_114;
      }
      v96 = SBYTE2(v61);
      if (v15)
      {
        v97 = v44 + ((uint64_t)SBYTE2(v61) << 32);
        v98 = v15 & (v97 >> 63);
        if (v98 + v97 >= v15)
          v99 = v15;
        else
          v99 = 0;
        v96 = (v98 + ((uint64_t)((unint64_t)HIWORD(v61) << 56) >> 24) - v99) >> 32;
      }
      v100 = v55 + 16 * v96;
      if (v25 < v100)
        v100 = v25;
      if (v100 >= (unint64_t)v56)
        v101 = (float32x2_t *)v100;
      else
        v101 = v56;
      v92 = *v101;
      v93 = v101[1].f32[0];
      v94 = 1.0;
      if (v24)
        v94 = v101[1].f32[1];
      v95 = &interpolate_rgbaf_19467[4 * ((v61 >> 28) & 3)];
    }
    LODWORD(a11) = v95[3];
    v59 = vmla_n_f32(vmls_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v92, *(float *)&a11);
    v60 = (float)(v60 - (float)(v60 * *(float *)&a11)) + (float)(v93 * *(float *)&a11);
    v58 = (float)(v58 - (float)(v58 * *(float *)&a11)) + (float)(v94 * *(float *)&a11);
LABEL_114:
    *(float32x2_t *)(v22 + 16) = v59;
    *(float *)(v22 + 24) = v60;
    *(float *)(v22 + 28) = v58;
    *(_BYTE *)(v23 + 1) = v36 >> 22;
    if (a4 == 1)
      break;
    v104 = 0;
    v105 = (float *)(v22 + 44);
    a2 += v14;
    v106 = v123 - a2;
    a3 += v20;
    v107 = v121 - a3;
    while (((v107 | v106 | (a3 - v122) | (a2 - v120)) & 0x8000000000000000) == 0)
    {
      if (v15)
      {
        v108 = (v16 & ((v34 + v124) >> 63)) + v34 + v124;
        v109 = (v15 & ((v44 + v17) >> 63)) + v44 + v17;
        if (v108 >= v16)
          v110 = v16;
        else
          v110 = 0;
        v34 = v108 - v110;
        if (v109 >= v15)
          v111 = v15;
        else
          v111 = 0;
        v44 = v109 - v111;
        v112 = HIDWORD(v34);
        v113 = v109 - v111;
      }
      else
      {
        v112 = HIDWORD(a3);
        v113 = a2;
      }
      v114 = v19 + v112 * (uint64_t)v13;
      v55 = v114 + 16 * (v113 >> 32);
      v56 = *(float32x2_t **)(result + 32);
      if (v25 >= v55)
        v115 = v114 + 16 * (v113 >> 32);
      else
        v115 = v25;
      if (v115 >= (unint64_t)v56)
        v116 = (float32x2_t *)v115;
      else
        v116 = *(float32x2_t **)(result + 32);
      if (v24)
        v58 = v116[1].f32[1];
      else
        v58 = 1.0;
      v59 = *v116;
      v60 = v116[1].f32[0];
      if (v18)
      {
        v61 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v61 & 0xF) != 0)
        {
          v23 += v104 + 1;
          v22 = (uint64_t)(v105 - 7);
          a4 += ~(_DWORD)v104;
          v36 = -1;
          goto LABEL_57;
        }
      }
      *(float32x2_t *)(v105 - 3) = v59;
      *(v105 - 1) = v60;
      *v105 = v58;
      v117 = v23 + v104++;
      v105 += 4;
      a2 += v14;
      *(_BYTE *)(v117 + 2) = -1;
      v106 -= v14;
      a3 += v20;
      v107 -= v20;
      if (a4 - 1 == (_DWORD)v104)
        return result;
    }
    v23 += v104 + 1;
    v22 = (uint64_t)(v105 - 7);
    a4 += ~(_DWORD)v104;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  float32x2_t v11;
  float32x2_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int8x8_t *v51;
  int8x8_t *v52;
  unint64_t v53;
  unsigned int *v54;
  unsigned int *v55;
  float32x2_t v56;
  float32x2_t v57;
  unsigned int v58;
  int v59;
  int v60;
  int64_t v61;
  unint64_t v62;
  int8x8_t *v63;
  unint64_t v64;
  float32x2_t v65;
  float32x2_t v66;
  float32x2_t v67;
  float32x2_t v68;
  float v69;
  unsigned int *v70;
  unint64_t v71;
  unsigned int *v72;
  unsigned int *v73;
  float32x2_t v74;
  float32x2_t v75;
  int8x8_t *v76;
  float32x2_t v77;
  float32x2_t v78;
  float v79;
  unsigned int *v80;
  int64_t v81;
  int8x8_t *v82;
  unsigned int *v83;
  uint64_t v84;
  float *v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  int8x8_t *v89;
  unsigned int *v90;
  unsigned int *v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;

  v13 = *(_QWORD *)(result + 32);
  v14 = *(_QWORD *)(result + 40);
  v15 = *(_DWORD *)(result + 24);
  v16 = *(_DWORD *)(result + 28);
  v17 = *(_QWORD *)(result + 176);
  v18 = *(_QWORD *)(result + 72);
  v94 = *(_QWORD *)(result + 80);
  v95 = *(_QWORD *)(result + 88);
  v20 = *(_QWORD *)(result + 112);
  v19 = *(_QWORD *)(result + 120);
  v21 = *(_QWORD *)(result + 152) - 16;
  v22 = *(_QWORD *)(result + 144) - 1;
  v23 = *(_DWORD *)(result + 260) - 1;
  v24 = *(_DWORD *)(result + 256) - 1;
  v25 = v14 + (v23 * v16) + 4 * v24;
  v92 = *(_DWORD *)(result + 188);
  v26 = v13 + (v23 * v15) + 16 * v24 - 16;
  v93 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v18)
    {
      if (a3 <= v95)
      {
        v35 = ((unint64_t)a3 >> 22) & 0x3C0;
        v36 = 0x3FFFFFFF;
        v37 = a3;
        v38 = v93;
      }
      else
      {
        v31 = *(_QWORD *)(result + 216);
        v32 = *(_QWORD *)(result + 224) + v95;
        v33 = v32 - a3 + (v31 >> 1);
        if (v33 < 1)
          goto LABEL_39;
        if (v33 >= v31)
          LODWORD(v34) = 0x3FFFFFFF;
        else
          v34 = (unint64_t)(*(_QWORD *)(result + 232) * v33) >> 32;
        v38 = v93;
        v36 = v34 | v92;
        v37 = v32 - 0x1000000;
        v35 = 448;
      }
    }
    else
    {
      v27 = *(_QWORD *)(result + 216);
      v28 = v18 - *(_QWORD *)(result + 224);
      v29 = a3 - v28 + (v27 >> 1);
      if (v29 < 1)
        goto LABEL_39;
      if (v29 >= v27)
        LODWORD(v30) = 0x3FFFFFFF;
      else
        v30 = (unint64_t)(*(_QWORD *)(result + 232) * v29) >> 32;
      v38 = v93;
      v36 = v30 | v92;
      v37 = v28 + 0x1000000;
      v35 = 512;
    }
    if (a2 >= v38)
      break;
    v39 = *(_QWORD *)(result + 192);
    v40 = v38 - *(_QWORD *)(result + 200);
    v41 = a2 - v40 + (v39 >> 1);
    if (v41 >= 1)
    {
      if (v41 < v39)
        v36 = ((v36 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v41) >> 32) >> 15)) | v92;
      v42 = v40 + 0x1000000;
      v43 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v20;
    a3 += v19;
    v21 += 16;
    *(_BYTE *)++v22 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v94)
  {
    v43 = ((unint64_t)a2 >> 26) & 0x3C;
    v42 = a2;
    goto LABEL_26;
  }
  v44 = *(_QWORD *)(result + 192);
  v45 = *(_QWORD *)(result + 200) + v94;
  v46 = v45 - a2 + (v44 >> 1);
  if (v46 < 1)
    goto LABEL_39;
  if (v46 < v44)
    v36 = ((v36 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v46) >> 32) >> 15)) | v92;
  v42 = v45 - 0x1000000;
  v43 = 28;
LABEL_26:
  if (v36 < 0x400000)
    goto LABEL_39;
  v47 = v37 >> 32;
  v48 = v13 + SHIDWORD(v37) * (uint64_t)v15;
  v49 = (v42 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v50 = v48 + 4 * v49;
  v51 = *(int8x8_t **)(result + 32);
  if (v26 >= v50)
    v52 = (int8x8_t *)(v48 + 4 * v49);
  else
    v52 = (int8x8_t *)v26;
  if (v52 < v51)
    v52 = *(int8x8_t **)(result + 32);
  if (v14)
  {
    v53 = v14 + (int)v47 * (uint64_t)v16 + v49;
    v54 = *(unsigned int **)(result + 40);
    if (v25 >= v53)
      v55 = (unsigned int *)(v14 + (int)v47 * (uint64_t)v16 + v49);
    else
      v55 = (unsigned int *)v25;
    if (v55 >= v54)
      v54 = v55;
    LODWORD(a5) = bswap32(*v54);
  }
  else
  {
    v53 = 0;
    LODWORD(a5) = 1.0;
  }
  v56 = (float32x2_t)vrev32_s8(*v52);
  v57 = (float32x2_t)vrev32_s8(v52[1]);
  if (v17)
  {
    v58 = *(_DWORD *)(v17 + (v43 | v35));
LABEL_45:
    v59 = v58 & 0xF;
    v60 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      v76 = (int8x8_t *)(v50 + SBYTE1(v58) * (uint64_t)v15);
      if (v26 < (unint64_t)v76)
        v76 = (int8x8_t *)v26;
      if (v76 < v51)
        v76 = v51;
      v77 = (float32x2_t)vrev32_s8(*v76);
      v78 = (float32x2_t)vrev32_s8(v76[1]);
      v79 = 1.0;
      if (v14)
      {
        v80 = (unsigned int *)(v53 + SBYTE1(v58) * (uint64_t)v16);
        if (v25 < (unint64_t)v80)
          v80 = (unsigned int *)v25;
        if ((unint64_t)v80 < *(_QWORD *)(result + 40))
          v80 = *(unsigned int **)(result + 40);
        v79 = COERCE_FLOAT(bswap32(*v80));
      }
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          v61 = (unint64_t)HIWORD(v58) << 56;
          v62 = v50 + (v61 >> 52);
          if (v26 >= v62)
            v63 = (int8x8_t *)(v50 + (v61 >> 52));
          else
            v63 = (int8x8_t *)v26;
          if (v63 < v51)
            v63 = v51;
          v64 = v62 + SBYTE1(v58) * (uint64_t)v15;
          if (v26 < v64)
            v64 = v26;
          if (v64 < (unint64_t)v51)
            v64 = (unint64_t)v51;
          v65 = (float32x2_t)vrev32_s8(*v63);
          a11 = *(double *)(v64 + 8);
          v66 = (float32x2_t)vrev32_s8(*(int8x8_t *)v64);
          v67 = (float32x2_t)vrev32_s8(v63[1]);
          v68 = (float32x2_t)vrev32_s8(*(int8x8_t *)&a11);
          v69 = 1.0;
          LODWORD(a11) = 1.0;
          if (v14)
          {
            v70 = (unsigned int *)(v53 + (v61 >> 54));
            v71 = *(_QWORD *)(result + 40);
            if (v25 >= (unint64_t)v70)
              v72 = v70;
            else
              v72 = (unsigned int *)v25;
            if ((unint64_t)v72 < v71)
              v72 = *(unsigned int **)(result + 40);
            LODWORD(a11) = bswap32(*v72);
            v73 = (unsigned int *)((char *)v70 + SBYTE1(v58) * (uint64_t)v16);
            if (v25 < (unint64_t)v73)
              v73 = (unsigned int *)v25;
            if ((unint64_t)v73 < v71)
              v73 = *(unsigned int **)(result + 40);
            v69 = COERCE_FLOAT(bswap32(*v73));
          }
          v11.i32[0] = interpolate_cmykaf[5 * v60 + 4];
          v12.i32[0] = interpolate_cmykaf[5 * ((v58 >> 28) & 3) + 4];
          v74 = vmla_n_f32(vmls_lane_f32(v56, v56, v11, 0), v65, v11.f32[0]);
          v56 = vmla_n_f32(vmls_lane_f32(v74, v74, v12, 0), vmla_n_f32(vmls_lane_f32(v65, v65, v11, 0), v66, v11.f32[0]), v12.f32[0]);
          v75 = vmla_n_f32(vmls_lane_f32(v57, v57, v11, 0), v67, v11.f32[0]);
          v57 = vmla_n_f32(vmls_lane_f32(v75, v75, v12, 0), vmla_n_f32(vmls_lane_f32(v67, v67, v11, 0), v68, v11.f32[0]), v12.f32[0]);
          *(float *)&a5 = (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                        + (float)(*(float *)&a11 * v11.f32[0]))
                                - (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                                + (float)(*(float *)&a11 * v11.f32[0]))
                                        * v12.f32[0]))
                        + (float)((float)((float)(*(float *)&a11 - (float)(*(float *)&a11 * v11.f32[0]))
                                        + (float)(v69 * v11.f32[0]))
                                * v12.f32[0]);
        }
        goto LABEL_91;
      }
      v81 = (unint64_t)HIWORD(v58) << 56;
      v82 = (int8x8_t *)(v50 + (v81 >> 52));
      if (v26 < (unint64_t)v82)
        v82 = (int8x8_t *)v26;
      if (v82 < v51)
        v82 = v51;
      v77 = (float32x2_t)vrev32_s8(*v82);
      v78 = (float32x2_t)vrev32_s8(v82[1]);
      v79 = 1.0;
      if (v14)
      {
        v83 = (unsigned int *)(v53 + (v81 >> 54));
        if (v25 < (unint64_t)v83)
          v83 = (unsigned int *)v25;
        if ((unint64_t)v83 < *(_QWORD *)(result + 40))
          v83 = *(unsigned int **)(result + 40);
        v79 = COERCE_FLOAT(bswap32(*v83));
      }
      v60 = (v58 >> 28) & 3;
    }
    LODWORD(a11) = interpolate_cmykaf[5 * v60 + 4];
    v56 = vmla_n_f32(vmls_lane_f32(v56, v56, *(float32x2_t *)&a11, 0), v77, *(float *)&a11);
    v57 = vmla_n_f32(vmls_lane_f32(v57, v57, *(float32x2_t *)&a11, 0), v78, *(float *)&a11);
    *(float *)&a5 = (float)(*(float *)&a5 - (float)(*(float *)&a5 * *(float *)&a11)) + (float)(v79 * *(float *)&a11);
  }
LABEL_91:
  v84 = 0;
  v85 = (float *)(v21 + 28);
  a2 += v20;
  v86 = v94 - a2;
  a3 += v19;
  v87 = v95 - a3;
  while (1)
  {
    *(float32x2_t *)(v85 - 3) = vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v56), (float32x2_t)vdup_lane_s32((int32x2_t)v57, 1));
    *(v85 - 1) = (float)(*(float *)&a5 - v57.f32[0]) - v57.f32[1];
    *v85 = *(float *)&a5;
    *(_BYTE *)(v22 + 1 + v84) = v36 >> 22;
    if (a4 - 1 == (_DWORD)v84)
      return result;
    if ((v87 | v86 | (a3 - v18) | (a2 - v93)) < 0)
    {
      v22 += v84 + 1;
      v21 = (uint64_t)(v85 - 3);
      a4 += ~(_DWORD)v84;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v88 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v50 = v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v88;
    v51 = *(int8x8_t **)(result + 32);
    if (v26 >= v50)
      v89 = (int8x8_t *)(v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v88);
    else
      v89 = (int8x8_t *)v26;
    if (v89 < v51)
      v89 = *(int8x8_t **)(result + 32);
    if (v14)
    {
      v53 = v14 + SHIDWORD(a3) * (uint64_t)v16 + v88;
      v90 = *(unsigned int **)(result + 40);
      if (v25 >= v53)
        v91 = (unsigned int *)v53;
      else
        v91 = (unsigned int *)v25;
      if (v91 >= v90)
        v90 = v91;
      LODWORD(a5) = bswap32(*v90);
    }
    else
    {
      LODWORD(a5) = 1.0;
    }
    v56 = (float32x2_t)vrev32_s8(*v89);
    v57 = (float32x2_t)vrev32_s8(v89[1]);
    if (v17)
    {
      v58 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v58 & 0xF) != 0)
      {
        v22 += v84 + 1;
        v21 = (uint64_t)(v85 - 3);
        a4 += ~(_DWORD)v84;
        v36 = -1;
        goto LABEL_45;
      }
    }
    ++v84;
    v85 += 4;
    v86 -= v20;
    a3 += v19;
    v87 -= v19;
    a2 += v20;
    v36 = -1;
  }
}

uint64_t RGBAf_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  float32x2_t v11;
  float32x2_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  float32x2_t *v51;
  float32x2_t *v52;
  unint64_t v53;
  _DWORD *v54;
  _DWORD *v55;
  float32x2_t v56;
  float32x2_t v57;
  unsigned int v58;
  int v59;
  int v60;
  int64_t v61;
  unint64_t v62;
  float32x2_t *v63;
  float32x2_t *v64;
  float32x2_t v65;
  float32x2_t v66;
  float32x2_t v67;
  float32x2_t v68;
  float v69;
  float v70;
  float *v71;
  unint64_t v72;
  float *v73;
  float *v74;
  float32x2_t v75;
  float32x2_t v76;
  float32x2_t *v77;
  float32x2_t v78;
  float32x2_t v79;
  float v80;
  float *v81;
  int64_t v82;
  float32x2_t *v83;
  float *v84;
  uint64_t v85;
  float *v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  float32x2_t *v90;
  _DWORD *v91;
  _DWORD *v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;

  v13 = *(_QWORD *)(result + 32);
  v14 = *(_QWORD *)(result + 40);
  v15 = *(_DWORD *)(result + 24);
  v16 = *(_DWORD *)(result + 28);
  v17 = *(_QWORD *)(result + 176);
  v18 = *(_QWORD *)(result + 72);
  v95 = *(_QWORD *)(result + 80);
  v96 = *(_QWORD *)(result + 88);
  v20 = *(_QWORD *)(result + 112);
  v19 = *(_QWORD *)(result + 120);
  v21 = *(_QWORD *)(result + 152) - 16;
  v22 = *(_QWORD *)(result + 144) - 1;
  v23 = *(_DWORD *)(result + 260) - 1;
  v24 = *(_DWORD *)(result + 256) - 1;
  v25 = v14 + (v23 * v16) + 4 * v24;
  v93 = *(_DWORD *)(result + 188);
  v26 = v13 + (v23 * v15) + 16 * v24 - 16;
  v94 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v18)
    {
      if (a3 <= v96)
      {
        v35 = ((unint64_t)a3 >> 22) & 0x3C0;
        v36 = 0x3FFFFFFF;
        v37 = a3;
        v38 = v94;
      }
      else
      {
        v31 = *(_QWORD *)(result + 216);
        v32 = *(_QWORD *)(result + 224) + v96;
        v33 = v32 - a3 + (v31 >> 1);
        if (v33 < 1)
          goto LABEL_39;
        if (v33 >= v31)
          LODWORD(v34) = 0x3FFFFFFF;
        else
          v34 = (unint64_t)(*(_QWORD *)(result + 232) * v33) >> 32;
        v38 = v94;
        v36 = v34 | v93;
        v37 = v32 - 0x1000000;
        v35 = 448;
      }
    }
    else
    {
      v27 = *(_QWORD *)(result + 216);
      v28 = v18 - *(_QWORD *)(result + 224);
      v29 = a3 - v28 + (v27 >> 1);
      if (v29 < 1)
        goto LABEL_39;
      if (v29 >= v27)
        LODWORD(v30) = 0x3FFFFFFF;
      else
        v30 = (unint64_t)(*(_QWORD *)(result + 232) * v29) >> 32;
      v38 = v94;
      v36 = v30 | v93;
      v37 = v28 + 0x1000000;
      v35 = 512;
    }
    if (a2 >= v38)
      break;
    v39 = *(_QWORD *)(result + 192);
    v40 = v38 - *(_QWORD *)(result + 200);
    v41 = a2 - v40 + (v39 >> 1);
    if (v41 >= 1)
    {
      if (v41 < v39)
        v36 = ((v36 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v41) >> 32) >> 15)) | v93;
      v42 = v40 + 0x1000000;
      v43 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v20;
    a3 += v19;
    v21 += 16;
    *(_BYTE *)++v22 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v95)
  {
    v43 = ((unint64_t)a2 >> 26) & 0x3C;
    v42 = a2;
    goto LABEL_26;
  }
  v44 = *(_QWORD *)(result + 192);
  v45 = *(_QWORD *)(result + 200) + v95;
  v46 = v45 - a2 + (v44 >> 1);
  if (v46 < 1)
    goto LABEL_39;
  if (v46 < v44)
    v36 = ((v36 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v46) >> 32) >> 15)) | v93;
  v42 = v45 - 0x1000000;
  v43 = 28;
LABEL_26:
  if (v36 < 0x400000)
    goto LABEL_39;
  v47 = v37 >> 32;
  v48 = v13 + SHIDWORD(v37) * (uint64_t)v15;
  v49 = (v42 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v50 = v48 + 4 * v49;
  v51 = *(float32x2_t **)(result + 32);
  if (v26 >= v50)
    v52 = (float32x2_t *)(v48 + 4 * v49);
  else
    v52 = (float32x2_t *)v26;
  if (v52 < v51)
    v52 = *(float32x2_t **)(result + 32);
  if (v14)
  {
    v53 = v14 + (int)v47 * (uint64_t)v16 + v49;
    v54 = *(_DWORD **)(result + 40);
    if (v25 >= v53)
      v55 = (_DWORD *)(v14 + (int)v47 * (uint64_t)v16 + v49);
    else
      v55 = (_DWORD *)v25;
    if (v55 >= v54)
      v54 = v55;
    LODWORD(a5) = *v54;
  }
  else
  {
    v53 = 0;
    LODWORD(a5) = 1.0;
  }
  v57 = *v52;
  v56 = v52[1];
  if (v17)
  {
    v58 = *(_DWORD *)(v17 + (v43 | v35));
LABEL_45:
    v59 = v58 & 0xF;
    v60 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      v77 = (float32x2_t *)(v50 + SBYTE1(v58) * (uint64_t)v15);
      if (v26 < (unint64_t)v77)
        v77 = (float32x2_t *)v26;
      if (v77 < v51)
        v77 = v51;
      v79 = *v77;
      v78 = v77[1];
      v80 = 1.0;
      if (v14)
      {
        v81 = (float *)(v53 + SBYTE1(v58) * (uint64_t)v16);
        if (v25 < (unint64_t)v81)
          v81 = (float *)v25;
        if ((unint64_t)v81 < *(_QWORD *)(result + 40))
          v81 = *(float **)(result + 40);
        v80 = *v81;
      }
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          v61 = (unint64_t)HIWORD(v58) << 56;
          v62 = v50 + (v61 >> 52);
          if (v26 >= v62)
            v63 = (float32x2_t *)(v50 + (v61 >> 52));
          else
            v63 = (float32x2_t *)v26;
          if (v63 < v51)
            v63 = v51;
          v64 = (float32x2_t *)(v62 + SBYTE1(v58) * (uint64_t)v15);
          if (v26 < (unint64_t)v64)
            v64 = (float32x2_t *)v26;
          if (v64 < v51)
            v64 = v51;
          v66 = *v63;
          v65 = v63[1];
          v68 = *v64;
          v67 = v64[1];
          v69 = 1.0;
          v70 = 1.0;
          if (v14)
          {
            v71 = (float *)(v53 + (v61 >> 54));
            v72 = *(_QWORD *)(result + 40);
            if (v25 >= (unint64_t)v71)
              v73 = v71;
            else
              v73 = (float *)v25;
            if ((unint64_t)v73 < v72)
              v73 = *(float **)(result + 40);
            v69 = *v73;
            v74 = (float *)((char *)v71 + SBYTE1(v58) * (uint64_t)v16);
            if (v25 < (unint64_t)v74)
              v74 = (float *)v25;
            if ((unint64_t)v74 < v72)
              v74 = *(float **)(result + 40);
            v70 = *v74;
          }
          v11.i32[0] = interpolate_cmykaf[5 * v60 + 4];
          v12.i32[0] = interpolate_cmykaf[5 * ((v58 >> 28) & 3) + 4];
          v75 = vmla_n_f32(vmls_lane_f32(v57, v57, v11, 0), v66, v11.f32[0]);
          a11 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(v66, v66, v11, 0), v68, v11.f32[0]));
          v57 = vmla_n_f32(vmls_lane_f32(v75, v75, v12, 0), *(float32x2_t *)&a11, v12.f32[0]);
          v76 = vmla_n_f32(vmls_lane_f32(v56, v56, v11, 0), v65, v11.f32[0]);
          v56 = vmla_n_f32(vmls_lane_f32(v76, v76, v12, 0), vmla_n_f32(vmls_lane_f32(v65, v65, v11, 0), v67, v11.f32[0]), v12.f32[0]);
          *(float *)&a5 = (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                        + (float)(v69 * v11.f32[0]))
                                - (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                                + (float)(v69 * v11.f32[0]))
                                        * v12.f32[0]))
                        + (float)((float)((float)(v69 - (float)(v69 * v11.f32[0])) + (float)(v70 * v11.f32[0]))
                                * v12.f32[0]);
        }
        goto LABEL_91;
      }
      v82 = (unint64_t)HIWORD(v58) << 56;
      v83 = (float32x2_t *)(v50 + (v82 >> 52));
      if (v26 < (unint64_t)v83)
        v83 = (float32x2_t *)v26;
      if (v83 < v51)
        v83 = v51;
      v79 = *v83;
      v78 = v83[1];
      v80 = 1.0;
      if (v14)
      {
        v84 = (float *)(v53 + (v82 >> 54));
        if (v25 < (unint64_t)v84)
          v84 = (float *)v25;
        if ((unint64_t)v84 < *(_QWORD *)(result + 40))
          v84 = *(float **)(result + 40);
        v80 = *v84;
      }
      v60 = (v58 >> 28) & 3;
    }
    LODWORD(a11) = interpolate_cmykaf[5 * v60 + 4];
    v57 = vmla_n_f32(vmls_lane_f32(v57, v57, *(float32x2_t *)&a11, 0), v79, *(float *)&a11);
    v56 = vmla_n_f32(vmls_lane_f32(v56, v56, *(float32x2_t *)&a11, 0), v78, *(float *)&a11);
    *(float *)&a5 = (float)(*(float *)&a5 - (float)(*(float *)&a5 * *(float *)&a11)) + (float)(v80 * *(float *)&a11);
  }
LABEL_91:
  v85 = 0;
  v86 = (float *)(v21 + 28);
  a2 += v20;
  v87 = v95 - a2;
  a3 += v19;
  v88 = v96 - a3;
  while (1)
  {
    *(float32x2_t *)(v86 - 3) = vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v57), (float32x2_t)vdup_lane_s32((int32x2_t)v56, 1));
    *(v86 - 1) = (float)(*(float *)&a5 - v56.f32[0]) - v56.f32[1];
    *v86 = *(float *)&a5;
    *(_BYTE *)(v22 + 1 + v85) = v36 >> 22;
    if (a4 - 1 == (_DWORD)v85)
      return result;
    if ((v88 | v87 | (a3 - v18) | (a2 - v94)) < 0)
    {
      v22 += v85 + 1;
      v21 = (uint64_t)(v86 - 3);
      a4 += ~(_DWORD)v85;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v89 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v50 = v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v89;
    v51 = *(float32x2_t **)(result + 32);
    if (v26 >= v50)
      v90 = (float32x2_t *)(v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v89);
    else
      v90 = (float32x2_t *)v26;
    if (v90 < v51)
      v90 = *(float32x2_t **)(result + 32);
    if (v14)
    {
      v53 = v14 + SHIDWORD(a3) * (uint64_t)v16 + v89;
      v91 = *(_DWORD **)(result + 40);
      if (v25 >= v53)
        v92 = (_DWORD *)v53;
      else
        v92 = (_DWORD *)v25;
      if (v92 >= v91)
        v91 = v92;
      LODWORD(a5) = *v91;
    }
    else
    {
      LODWORD(a5) = 1.0;
    }
    v57 = *v90;
    v56 = v90[1];
    if (v17)
    {
      v58 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v58 & 0xF) != 0)
      {
        v22 += v85 + 1;
        v21 = (uint64_t)(v86 - 3);
        a4 += ~(_DWORD)v85;
        v36 = -1;
        goto LABEL_45;
      }
    }
    ++v85;
    v86 += 4;
    v87 -= v20;
    a3 += v19;
    v88 -= v19;
    a2 += v20;
    v36 = -1;
  }
}

float32x2_t *RGBAf_pattern(uint64_t a1, float32x2_t *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  _DWORD *v15;
  float32x2_t *v16;
  float v17;
  int v18;
  float32x2_t v19;
  float32x2_t *v20;
  double v22;
  double v23;

  v15 = *(_DWORD **)(*(_QWORD *)a1 + 64);
  LODWORD(a9) = *v15;
  LODWORD(a12) = v15[1];
  if (a2 && a3 > 0xF
    || (v22 = a9,
        v23 = a12,
        v16 = (float32x2_t *)malloc_type_malloc(0x40uLL, 0x705560E0uLL),
        a9 = v22,
        a12 = v23,
        (a2 = v16) != 0))
  {
    if (*(float *)&a9 <= a6)
      v17 = a6;
    else
      v17 = *(float *)&a9;
    if (*(float *)&a12 < a6)
      v17 = *(float *)&a12;
    if (a5)
      v18 = a4;
    else
      v18 = 0;
    switch(v18)
    {
      case 1:
        *(float *)&a9 = v17 * a5->f32[0];
        break;
      case 4:
        LODWORD(a8) = a5[2].i32[0];
        v19 = vmul_n_f32(vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a12, 0), *a5), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0)), v17);
        *(float *)&a8 = (float)(*(float *)&a12 - a5[1].f32[0]) - *(float *)&a8;
        goto LABEL_19;
      case 3:
        v19 = vmul_n_f32(*a5, v17);
        LODWORD(a8) = a5[1].i32[0];
LABEL_19:
        *(float *)&a9 = v17 * *(float *)&a8;
        goto LABEL_20;
    }
    v19 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
LABEL_20:
    *(_OWORD *)a2->f32 = xmmword_185004D40;
    a2[3].i32[0] = 0;
    a2[2] = (float32x2_t)1;
    a2[6] = v19;
    if (v17 >= *(float *)&a12)
      v20 = 0;
    else
      v20 = a2 + 6;
    a2[4] = (float32x2_t)&a2[6];
    a2[5] = (float32x2_t)v20;
    a2[7].i32[0] = LODWORD(a9);
    a2[7].f32[1] = v17;
  }
  return a2;
}

uint64_t RGBAf_mark(uint64_t *a1, __n128 a2)
{
  return RGBAf_mark_inner(*a1, a2);
}

uint64_t RGBAf_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  int v21;
  int v22;
  _DWORD *v23;
  uint16x4_t *v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t v27;
  float v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  unsigned int v36;
  size_t v37;
  _BYTE *v38;
  _BYTE *v39;
  float32x4_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  void *v59;
  unint64_t v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  int v64;
  float32x4_t v65;
  unsigned int v66;
  float32x4_t v67;
  float32x4_t v68;
  int v69;
  unsigned int v70;
  int v71;
  int v72;
  float v73;
  int v74;
  int v75;
  float v76;
  int v77;
  int v78;
  int v79;
  int v80;
  float v81;
  float v82;
  float v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  float v92;
  float v93;
  int v94;
  int v95;
  float v96;
  float v97;
  float *v98;
  float v99;
  int v100;
  int v101;
  float v102;
  __int32 v103;
  int v104;
  int v105;
  float v106;
  float v107;
  int v108;
  int v114;
  float v115;
  float32_t v116;
  __int32 v117;
  int v118;
  int v119;
  float v120;
  float v121;
  __int32 v122;
  int v123;
  int v124;
  float v125;
  float v126;
  __int32 v127;
  int v128;
  int v129;
  float v130;
  float v131;
  __int32 v132;
  int v133;
  int v134;
  float v135;
  float v136;
  __int32 v137;
  int v138;
  int v139;
  float v140;
  float v141;
  unsigned int v142;
  __int32 v143;
  int v144;
  int v145;
  float v146;
  __int32 v147;
  __int32 v148;
  int v149;
  int v150;
  float v151;
  float v152;
  int v153;
  int v154;
  float v155;
  float v156;
  float32x2_t v157;
  float32x2_t v158;
  float32x2_t v159;
  float32x2_t v160;
  float32x2_t v161;
  float v162;
  float v163;
  float v164;
  int v165;
  int v166;
  float v167;
  float32_t v168;
  float v169;
  float v170;
  int v171;
  int v172;
  float v173;
  float v174;
  __int32 v175;
  __int32 v176;
  float v177;
  float v178;
  int v179;
  int v180;
  float v181;
  float v182;
  __int32 v183;
  __int32 v184;
  float v185;
  float v186;
  int v187;
  int v188;
  float v189;
  float v190;
  float v191;
  __int32 v192;
  __int32 v193;
  float v194;
  float v195;
  int v196;
  int v197;
  float v198;
  float v199;
  __int32 v200;
  __int32 v201;
  int v202;
  uint64_t v203;
  double v204;
  float32x4_t v205;
  uint64_t v206;
  int v207[4];
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  _DWORD v217[1024];
  uint64_t v218;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v218 = *MEMORY[0x1E0C80C00];
  v17 = *(_QWORD *)(v3 + 48);
  v18 = *(unsigned int *)(*(_QWORD *)(v2 + 56)
                        + 16 * *(_DWORD *)v3
                        + 8 * (*(_QWORD *)(v3 + 96) == 0)
                        + 4 * (v17 == 0));
  if ((int)v18 > 27)
    return 0xFFFFFFFFLL;
  v20 = v3;
  v21 = *(_DWORD *)(v3 + 4);
  if (v21 < 1)
    return 0;
  v22 = *(_DWORD *)(v3 + 8);
  if (v22 < 1)
    return 0;
  v23 = (_DWORD *)v2;
  v24 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v24)
  {
    if ((*(_DWORD *)v3 & 0xFF00) != 0x400)
    {
      RGBAf_mark_pixelshape(v2, v3, v18, v4, v5, v6, *(int8x8_t *)&v9, v10, v11, v12, v13, v14, v15, v16);
      return 1;
    }
    v217[0] = *(_DWORD *)(v3 + 4);
    v207[0] = v22;
    v26 = *(_QWORD *)(v3 + 40);
    v27 = *(float32x4_t *)*(_QWORD *)(v3 + 88);
    v28 = v27.f32[3];
    *(float *)&v12 = 1.0 - v27.f32[3];
    v29 = (unint64_t)*(int *)(v3 + 28) >> 4;
    v30 = *(int *)(v3 + 12) + v29 * *(int *)(v3 + 16);
    v31 = v26 + 16 * v30;
    v204 = v12;
    v205 = v27;
    v202 = *(_DWORD *)(v3 + 28);
    v203 = v31;
    if (v24)
    {
      shape_enum_clip_alloc(v2, v3, (int *)v24, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v21, v22);
      v33 = v32;
      if (!v32)
        return 1;
      goto LABEL_287;
    }
    v33 = 0;
    v40 = (float32x4_t *)(v26 + 16 * v30);
LABEL_27:
    v60 = v29 - v21;
    switch((int)v18)
    {
      case 0:
        v61 = v207[0];
        v62 = 16 * v21;
        goto LABEL_293;
      case 1:
        v63 = *(_QWORD *)(v20 + 88);
        if (v63)
        {
          CGSFillDRAM64(v40, v202 & 0xFFFFFFF0, 16 * v21, v207[0], v63, 16, 16, 1, 0, 0);
          if (!v33)
            return 1;
          goto LABEL_286;
        }
        v62 = 16 * v21;
        v61 = v207[0];
LABEL_293:
        CGBlt_fillBytes(v62, v61, 0, (char *)v40, v202 & 0xFFFFFFF0);
        if (v33)
          goto LABEL_286;
        return 1;
      case 2:
        v64 = v207[0];
        v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v12, 0);
        do
        {
          if (v21 < 4)
          {
            v69 = v21;
          }
          else
          {
            v66 = (v21 >> 2) + 1;
            do
            {
              v67 = vmlaq_f32(v27, v65, v40[1]);
              *v40 = vmlaq_f32(v27, v65, *v40);
              v40[1] = v67;
              v68 = vmlaq_f32(v27, v65, v40[3]);
              v40[2] = vmlaq_f32(v27, v65, v40[2]);
              v40[3] = v68;
              v40 += 4;
              --v66;
            }
            while (v66 > 1);
            v69 = v21 & 3;
          }
          if (v69 >= 1)
          {
            v70 = v69 + 1;
            do
            {
              *v40 = vmlaq_f32(v27, v65, *v40);
              ++v40;
              --v70;
            }
            while (v70 > 1);
          }
          v40 += v60;
          --v64;
        }
        while (v64);
        goto LABEL_239;
      case 3:
        v71 = v207[0];
        do
        {
          v72 = v21;
          do
          {
            v73 = v40->f32[3];
            if (v73 <= 0.0)
            {
              v40->i64[0] = 0;
              v40->i64[1] = 0;
            }
            else if (v73 >= 1.0)
            {
              *v40 = v27;
            }
            else
            {
              *v40 = vmulq_n_f32(v27, v73);
            }
            ++v40;
            --v72;
          }
          while (v72);
          v40 += v60;
          --v71;
        }
        while (v71);
        goto LABEL_239;
      case 4:
        v74 = v207[0];
        do
        {
          v75 = v21;
          do
          {
            v76 = 1.0 - v40->f32[3];
            if (v76 <= 0.0)
            {
              v40->i64[0] = 0;
              v40->i64[1] = 0;
            }
            else if (v76 >= 1.0)
            {
              *v40 = v27;
            }
            else
            {
              *v40 = vmulq_n_f32(v27, v76);
            }
            ++v40;
            --v75;
          }
          while (v75);
          v40 += v60;
          --v74;
        }
        while (v74);
        goto LABEL_239;
      case 5:
        v77 = v207[0];
        do
        {
          v78 = v21;
          do
          {
            *v40 = vmlaq_laneq_f32(vmulq_n_f32(*v40, *(float *)&v12), v27, *v40, 3);
            ++v40;
            --v78;
          }
          while (v78);
          v40 += v60;
          --v77;
        }
        while (v77);
        goto LABEL_239;
      case 6:
        v79 = v207[0];
        while (1)
        {
          v80 = v21;
          do
          {
            v81 = v40->f32[3];
            v82 = 1.0 - v81;
            if ((float)(1.0 - v81) >= 1.0)
            {
              v40->i64[0] = v27.i64[0];
              v40->i32[2] = v27.i32[2];
              v83 = v28;
            }
            else
            {
              if (v82 <= 0.0)
                goto LABEL_75;
              *(float32x2_t *)v40->f32 = vmla_n_f32(*(float32x2_t *)v40->f32, *(float32x2_t *)v27.f32, v82);
              v40->f32[2] = v40->f32[2] + (float)(v27.f32[2] * v82);
              v83 = v81 + (float)(v28 * v82);
            }
            v40->f32[3] = v83;
LABEL_75:
            ++v40;
            --v80;
          }
          while (v80);
          v40 += v60;
          if (!--v79)
            goto LABEL_239;
        }
      case 7:
        v84 = v207[0];
        do
        {
          v85 = v21;
          do
          {
            *v40 = vmulq_laneq_f32(*v40, v27, 3);
            ++v40;
            --v85;
          }
          while (v85);
          v40 += v60;
          --v84;
        }
        while (v84);
        goto LABEL_239;
      case 8:
        v86 = v207[0];
        do
        {
          v87 = v21;
          do
          {
            *v40 = vmulq_n_f32(*v40, *(float *)&v12);
            ++v40;
            --v87;
          }
          while (v87);
          v40 += v60;
          --v86;
        }
        while (v86);
        goto LABEL_239;
      case 9:
        v88 = v207[0];
        do
        {
          v89 = v21;
          do
          {
            *v40 = vmlaq_n_f32(vmulq_laneq_f32(*v40, v27, 3), v27, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v40)));
            ++v40;
            --v89;
          }
          while (v89);
          v40 += v60;
          --v88;
        }
        while (v88);
        goto LABEL_239;
      case 10:
        v90 = v207[0];
        do
        {
          v91 = v21;
          do
          {
            *v40 = vmlaq_n_f32(vmulq_n_f32(*v40, *(float *)&v12), v27, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v40)));
            ++v40;
            --v91;
          }
          while (v91);
          v40 += v60;
          --v90;
        }
        while (v90);
        goto LABEL_239;
      case 11:
        v92 = v28 - v27.f32[0];
        v93 = v28 + 1.0;
        if ((float)(v28 + 1.0) > 1.0)
          v93 = 1.0;
        v94 = v207[0];
        do
        {
          v95 = v21;
          do
          {
            if (v17)
            {
              v96 = v40->f32[3];
              v97 = v28 + v96;
              if ((float)(v28 + v96) > 1.0)
                v97 = 1.0;
              v98 = &v40->f32[1];
              v99 = v96 - v40->f32[1];
              v27.f32[0] = v97 - (float)(v92 + (float)(v96 - v40->f32[0]));
            }
            else
            {
              v96 = 1.0;
              v98 = &v40->f32[1];
              v99 = 1.0 - v40->f32[1];
              v27.f32[0] = v93 - (float)(v92 + (float)(1.0 - v40->f32[0]));
              v97 = v93;
            }
            v40->i32[0] = v27.i32[0];
            v27.i32[0] = v40->i32[2];
            *v98 = v97 - (float)((float)(v28 - v27.f32[1]) + v99);
            v40->f32[2] = v97 - (float)((float)(v28 - v27.f32[2]) + (float)(v96 - v27.f32[0]));
            v40->f32[3] = v97;
            ++v40;
            --v95;
          }
          while (v95);
          v40 += v60;
          --v94;
        }
        while (v94);
        goto LABEL_239;
      case 12:
        v100 = v207[0];
        do
        {
          v101 = v21;
          do
          {
            *(float32x2_t *)v40->f32 = vadd_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v40->f32);
            v102 = v28 + v40->f32[3];
            if (v102 > 1.0)
              v102 = 1.0;
            v40->f32[2] = v27.f32[2] + v40->f32[2];
            v40->f32[3] = v102;
            ++v40;
            --v101;
          }
          while (v101);
          v40 += v60;
          --v100;
        }
        while (v100);
        goto LABEL_239;
      case 13:
        if (v28 <= 0.0)
          goto LABEL_285;
        v103 = v27.i32[2];
        v104 = v207[0];
        while (1)
        {
          v105 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v106 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_125;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v106 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v107 = PDAmultiplyPDA(v40->f32[0], v10, v11, v12, v106, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v103)), v28);
            v27 = v205;
            v40->f32[0] = v107;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_125:
            ++v40;
            --v105;
          }
          while (v105);
          v40 += v60;
          if (!--v104)
            goto LABEL_284;
        }
      case 14:
        if (v28 <= 0.0)
          goto LABEL_285;
        v108 = v207[0];
        __asm { FMOV            V2.2S, #1.0 }
        while (1)
        {
          v114 = v21;
          do
          {
            if (v17)
            {
              v115 = v40->f32[3];
              if (v115 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_136;
              }
            }
            else
            {
              v115 = 1.0;
            }
            v116 = v40->f32[2] + (float)(v27.f32[2] * (float)(1.0 - v40->f32[2]));
            *(float32x2_t *)v40->f32 = vmla_f32(*(float32x2_t *)v40->f32, vsub_f32(_D2, *(float32x2_t *)v40->f32), *(float32x2_t *)v27.f32);
            v40->f32[2] = v116;
            v40->f32[3] = (float)(v28 + v115) - (float)(v115 * v28);
LABEL_136:
            ++v40;
            --v114;
          }
          while (v114);
          v40 += v60;
          if (!--v108)
            goto LABEL_239;
        }
      case 15:
        if (v28 <= 0.0)
          goto LABEL_285;
        v117 = v27.i32[2];
        v118 = v207[0];
        while (1)
        {
          v119 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v120 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_147;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v120 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v121 = PDAoverlayPDA(v40->f32[0], v10, v11, v12, v120, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v117)), v28);
            v27 = v205;
            v40->f32[0] = v121;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_147:
            ++v40;
            --v119;
          }
          while (v119);
          v40 += v60;
          if (!--v118)
            goto LABEL_284;
        }
      case 16:
        if (v28 <= 0.0)
          goto LABEL_285;
        v122 = v27.i32[2];
        v123 = v207[0];
        while (1)
        {
          v124 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v125 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_158;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v125 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v126 = PDAdarkenPDA(v40->f32[0], v10, v11, v12, v125, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v122)), v28);
            v27 = v205;
            v40->f32[0] = v126;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_158:
            ++v40;
            --v124;
          }
          while (v124);
          v40 += v60;
          if (!--v123)
            goto LABEL_284;
        }
      case 17:
        if (v28 <= 0.0)
          goto LABEL_285;
        v127 = v27.i32[2];
        v128 = v207[0];
        while (1)
        {
          v129 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v130 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_169;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v130 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v131 = PDAlightenPDA(v40->f32[0], v10, v11, v12, v130, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v127)), v28);
            v27 = v205;
            v40->f32[0] = v131;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_169:
            ++v40;
            --v129;
          }
          while (v129);
          v40 += v60;
          if (!--v128)
            goto LABEL_284;
        }
      case 18:
        if (v28 <= 0.0)
          goto LABEL_285;
        v132 = v27.i32[2];
        v133 = v207[0];
        while (1)
        {
          v134 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v135 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_180;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v135 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v136 = PDAcolordodgePDA(v40->f32[0], v10, v11, v12, v135, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v132)), v28);
            v27 = v205;
            v40->f32[0] = v136;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_180:
            ++v40;
            --v134;
          }
          while (v134);
          v40 += v60;
          if (!--v133)
            goto LABEL_284;
        }
      case 19:
        if (v28 <= 0.0)
          goto LABEL_285;
        v137 = v27.i32[2];
        v138 = v207[0];
        while (1)
        {
          v139 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v140 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_191;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v140 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v141 = PDAcolorburnPDA(v40->f32[0], v10, v11, v12, v140, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v137)), v28);
            v27 = v205;
            v40->f32[0] = v141;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_191:
            ++v40;
            --v139;
          }
          while (v139);
          v40 += v60;
          if (!--v138)
            goto LABEL_284;
        }
      case 20:
        if (v28 <= 0.0)
          goto LABEL_285;
        v142 = v27.u32[1];
        v143 = v27.i32[2];
        v144 = v207[0];
        while (1)
        {
          v145 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              LODWORD(v13) = LODWORD(v12);
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_202;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              LODWORD(v13) = 1.0;
            }
            LODWORD(v11) = v40->i32[2];
            v146 = PDAsoftlightPDA(v40->f32[0], v40->f32[1], v11, *(int32x2_t *)&v12, v13, v14, v15, v16, v2, v3, (uint64_t)v24, v4, v5, v6, v7, v8, v27.f32[0], v142, __SPAIR64__(LODWORD(v28), v143),
                     v28);
            v27 = v205;
            v40->f32[0] = v146;
            v40->i32[1] = v147;
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_202:
            ++v40;
            --v145;
          }
          while (v145);
          v40 += v60;
          if (!--v144)
            goto LABEL_284;
        }
      case 21:
        if (v28 <= 0.0)
          goto LABEL_285;
        v148 = v27.i32[2];
        v149 = v207[0];
        while (1)
        {
          v150 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v151 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_213;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v151 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            v152 = PDAhardlightPDA(v40->f32[0], v10, v11, v12, v151, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v148)), v28);
            v27 = v205;
            v40->f32[0] = v152;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_213:
            ++v40;
            --v150;
          }
          while (v150);
          v40 += v60;
          if (!--v149)
            goto LABEL_284;
        }
      case 22:
        if (v28 <= 0.0)
          goto LABEL_285;
        v153 = v207[0];
        while (1)
        {
          v154 = v21;
          do
          {
            if (v17)
            {
              v155 = v40->f32[3];
              if (v155 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_226;
              }
            }
            else
            {
              v155 = 1.0;
            }
            v156 = v40->f32[2];
            v157 = vmul_laneq_f32(*(float32x2_t *)v40->f32, v27, 3);
            v158 = vmul_n_f32(*(float32x2_t *)v27.f32, v155);
            v159 = vsub_f32(vadd_f32(*(float32x2_t *)v40->f32, *(float32x2_t *)v27.f32), v157);
            v160 = vsub_f32(v157, v158);
            v161 = vadd_f32(vsub_f32(v159, v158), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v160), (int8x8_t)vneg_f32(v160), (int8x8_t)v160));
            v159.f32[0] = v156 + v27.f32[2];
            v162 = v156 * v28;
            v159.f32[0] = v159.f32[0] - v162;
            v163 = v162 - (float)(v27.f32[2] * v155);
            v164 = v159.f32[0] - (float)(v27.f32[2] * v155);
            if (v163 < 0.0)
              v163 = -v163;
            *(float32x2_t *)v40->f32 = v161;
            v40->f32[2] = v164 + v163;
            v40->f32[3] = (float)(v155 + v28) - (float)(v155 * v28);
LABEL_226:
            ++v40;
            --v154;
          }
          while (v154);
          v40 += v60;
          if (!--v153)
          {
LABEL_239:
            v207[0] = 0;
            if (!v33)
              return 1;
LABEL_286:
            v206 = 0;
LABEL_287:
            v2 = shape_enum_clip_next(v33, (int *)&v206 + 1, &v206, v217, v207);
            if ((_DWORD)v2)
            {
              v40 = (float32x4_t *)(v31 + 16 * v29 * (int)v206 + 16 * SHIDWORD(v206));
              v21 = v217[0];
              v12 = v204;
              v27 = v205;
              goto LABEL_27;
            }
            v59 = (void *)v33;
LABEL_290:
            free(v59);
            return 1;
          }
        }
      case 23:
        if (v28 <= 0.0)
          goto LABEL_285;
        v165 = v207[0];
        while (1)
        {
          v166 = v21;
          do
          {
            if (v17)
            {
              v167 = v40->f32[3];
              if (v167 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_237;
              }
            }
            else
            {
              v167 = 1.0;
            }
            v168 = (float)(v27.f32[2] + v40->f32[2]) + (float)((float)(v27.f32[2] * v40->f32[2]) * -2.0);
            *(float32x2_t *)v40->f32 = vmla_f32(vadd_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v40->f32), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v40->f32));
            v40->f32[2] = v168;
            v40->f32[3] = (float)(v28 + v167) - (float)(v167 * v28);
LABEL_237:
            ++v40;
            --v166;
          }
          while (v166);
          v40 += v60;
          if (!--v165)
            goto LABEL_239;
        }
      case 24:
        if (v28 <= 0.0)
          goto LABEL_285;
        v169 = v27.f32[1];
        v170 = v27.f32[2];
        v171 = v207[0];
        while (1)
        {
          v172 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v173 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_249;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v173 = 1.0;
            }
            v174 = PDAhuePDA(v40->f32[0], v40->f32[1], v40->f32[2], v12, v173, v14, v15, v16, v27.f32[0], v169, v170, v28, v28);
            v27 = v205;
            v40->f32[0] = v174;
            v40->i32[1] = v175;
            v40->i32[2] = v176;
            v40->i32[3] = LODWORD(v12);
LABEL_249:
            ++v40;
            --v172;
          }
          while (v172);
          v40 += v60;
          if (!--v171)
            goto LABEL_284;
        }
      case 25:
        if (v28 <= 0.0)
          goto LABEL_285;
        v177 = v27.f32[1];
        v178 = v27.f32[2];
        v179 = v207[0];
        while (1)
        {
          v180 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              v181 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_260;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              v181 = 1.0;
            }
            v182 = PDAsaturationPDA(v40->f32[0], v40->f32[1], v40->f32[2], v12, v181, v14, v15, v16, v27.f32[0], v177, v178, v28, v28);
            v27 = v205;
            v40->f32[0] = v182;
            v40->i32[1] = v183;
            v40->i32[2] = v184;
            v40->i32[3] = LODWORD(v12);
LABEL_260:
            ++v40;
            --v180;
          }
          while (v180);
          v40 += v60;
          if (!--v179)
            goto LABEL_284;
        }
      case 26:
        if (v28 <= 0.0)
          goto LABEL_285;
        v185 = v27.f32[1];
        v186 = v27.f32[2];
        v187 = v207[0];
        while (1)
        {
          v188 = v21;
          do
          {
            if (v17)
            {
              v189 = v40->f32[3];
              v190 = v189;
              if (v189 <= 0.0)
              {
                *v40 = v27;
                goto LABEL_271;
              }
            }
            else
            {
              v189 = v40->f32[3];
              v190 = 1.0;
            }
            *(float *)&v12 = v28;
            v191 = PDAluminosityPDA(v27.f32[0], v185, v186, v12, v28, v14, v15, v16, COERCE_FLOAT(v40->i64[0]), COERCE_FLOAT(HIDWORD(v40->i64[0])), v40->f32[2], v189, v190);
            v27 = v205;
            v40->f32[0] = v191;
            v40->i32[1] = v192;
            v40->i32[2] = v193;
            v40->i32[3] = LODWORD(v12);
LABEL_271:
            ++v40;
            --v188;
          }
          while (v188);
          v40 += v60;
          if (!--v187)
            goto LABEL_284;
        }
      case 27:
        if (v28 <= 0.0)
          goto LABEL_285;
        v194 = v27.f32[1];
        v195 = v27.f32[2];
        v196 = v207[0];
        break;
      default:
        goto LABEL_285;
    }
LABEL_276:
    v197 = v21;
    while (v17)
    {
      LODWORD(v12) = v40->i32[3];
      v198 = *(float *)&v12;
      if (*(float *)&v12 > 0.0)
        goto LABEL_281;
      *v40 = v27;
LABEL_282:
      ++v40;
      if (!--v197)
      {
        v40 += v60;
        if (!--v196)
        {
LABEL_284:
          v207[0] = 0;
          v31 = v203;
LABEL_285:
          if (v33)
            goto LABEL_286;
          return 1;
        }
        goto LABEL_276;
      }
    }
    LODWORD(v12) = v40->i32[3];
    v198 = 1.0;
LABEL_281:
    v199 = PDAluminosityPDA(v40->f32[0], v40->f32[1], v40->f32[2], v12, v198, v14, v15, v16, v27.f32[0], v194, v195, v28, v28);
    v27 = v205;
    v40->f32[0] = v199;
    v40->i32[1] = v200;
    v40->i32[2] = v201;
    v40->i32[3] = LODWORD(v12);
    goto LABEL_282;
  }
  v25 = *(unsigned int *)(v3 + 128);
  if ((v25 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      RGBAf_mark_constmask(v3, v18, (uint64_t)v24, v4, v5, v6, v25, v8, v9, v10, v11, v12, v13, v14, v15, v16);
    else
      RGBAf_mark_pixelmask((_DWORD *)v2, (int *)v3, v18, v9, v10, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    v34 = *(_DWORD *)(v3 + 112);
    v35 = *(_DWORD *)(v3 + 116);
    v36 = (v34 + 15) & 0xFFFFFFF0;
    v37 = v36 * v35;
    if ((int)v37 <= 4096)
    {
      v39 = v217;
    }
    else
    {
      v38 = malloc_type_malloc(v37, 0xF1367701uLL);
      if (!v38)
        return 1;
      v39 = v38;
      v24 = *(uint16x4_t **)(v20 + 136);
      LODWORD(v25) = *(_DWORD *)(v20 + 128);
    }
    CGSConvertBitsToMask(v24, *(_DWORD *)(v20 + 124), v39, v36, v34, v35, v25);
    v53 = *(_OWORD *)(v20 + 112);
    v213 = *(_OWORD *)(v20 + 96);
    v214 = v53;
    v54 = *(_OWORD *)(v20 + 144);
    v215 = *(_OWORD *)(v20 + 128);
    v216 = v54;
    v55 = *(_OWORD *)(v20 + 48);
    v209 = *(_OWORD *)(v20 + 32);
    v210 = v55;
    v56 = *(_OWORD *)(v20 + 80);
    v211 = *(_OWORD *)(v20 + 64);
    v212 = v56;
    v57 = *(_OWORD *)v20;
    v58 = *(_OWORD *)(v20 + 16);
    *(_OWORD *)v207 = *(_OWORD *)v20;
    v208 = v58;
    HIDWORD(v214) = (v34 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v215 + 1) = v39;
    if (BYTE1(v207[0]) << 8 == 1024)
      RGBAf_mark_constmask((uint64_t)v207, v18, v41, v42, v43, v44, v45, v46, *(double *)&v57, *(double *)&v58, v47, v48, v49, v50, v51, v52);
    else
      RGBAf_mark_pixelmask(v23, v207, v18, *(double *)&v57, *(double *)&v58, v47, v48, v49, v50, v51, v52);
    if (v39 != (_BYTE *)v217)
    {
      v59 = v39;
      goto LABEL_290;
    }
  }
  return 1;
}

float PDAmultiplyPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16;
  float result;

  v16 = a1 * a9;
  result = (float)(a1 * a9) + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0)
    result = v16;
  if (a5 != 1.0)
    return result + (float)(a9 * (float)(1.0 - a5));
  return result;
}

float PDAoverlayPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16;
  BOOL v17;
  float v18;
  float result;

  v16 = (float)(a1 * a9) + (float)(a1 * a9);
  v17 = a1 < (float)(a5 * 0.5);
  v18 = (float)((float)((float)((float)(a5 + 1.0) * a9) + (float)(a1 * (float)(a11 + 1.0))) - v16) - (float)(a5 * a11);
  result = (float)((float)((float)(1.0 - a5) * a9) + (float)(a1 * (float)(1.0 - a11))) + v16;
  if (!v17)
    return v18;
  return result;
}

float PDAlightenPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16;
  float result;

  v16 = a1 * a11;
  if ((float)(a9 * a5) > (float)(a1 * a11))
    v16 = a9 * a5;
  result = v16 + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0)
    result = v16;
  if (a5 != 1.0)
    return result + (float)(a9 * (float)(1.0 - a5));
  return result;
}

float PDAdarkenPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16;
  float result;

  v16 = a1 * a11;
  if ((float)(a9 * a5) < (float)(a1 * a11))
    v16 = a9 * a5;
  result = v16 + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0)
    result = v16;
  if (a5 != 1.0)
    return result + (float)(a9 * (float)(1.0 - a5));
  return result;
}

float PDAcolordodgePDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16;
  float result;

  v16 = 0.0;
  if (a1 != 0.0)
  {
    v16 = 1.0;
    if (a9 != a11)
      v16 = (float)(a1 * (float)(a11 * a11)) / (float)(a11 - a9);
  }
  result = v16 + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0)
    result = v16;
  if (a5 != 1.0)
    result = result + (float)(a9 * (float)(1.0 - a5));
  if (result > (float)((float)(a5 + a11) - (float)(a5 * a11)))
    return (float)(a5 + a11) - (float)(a5 * a11);
  return result;
}

float PDAcolorburnPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v17;
  float result;
  float v19;

  v17 = (float)(a5 * a11) + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0)
    v17 = a5 * a11;
  if (a5 == 1.0)
    result = v17;
  else
    result = v17 + (float)(a9 * (float)(1.0 - a5));
  v19 = a5 - a1;
  if (v19 != 0.0)
  {
    if (a9 == 0.0)
      return 0.0;
    result = result - (float)((float)(v19 * (float)(a11 * a11)) / a9);
    if (result < 0.0)
      return 0.0;
  }
  return result;
}

float PDAhardlightPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16;
  float v17;
  float result;

  v16 = (float)(a1 * a9) + (float)(a1 * a9);
  v17 = (float)((float)((float)(1.0 - a5) * a9) + (float)(a1 * (float)(1.0 - a11))) + v16;
  result = (float)((float)((float)((float)(a5 + 1.0) * a9) + (float)(a1 * (float)(a11 + 1.0))) - v16)
         - (float)(a5 * a11);
  if (a9 <= (float)(a11 * 0.5))
    return v17;
  return result;
}

float PDAsoftlightPDA(float a1, float a2, double a3, int32x2_t a4, double a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float a17, unsigned int a18, uint64_t a19, float a20)
{
  float32x2_t v17;
  float32x2_t v18;
  int8x8_t v19;
  float result;

  *(float *)a4.i32 = a20;
  if (*(float *)&a5 == 0.0)
  {
    v19.i32[1] = 0;
  }
  else
  {
    v17 = vmul_f32((float32x2_t)__PAIR64__(LODWORD(a1), LODWORD(a2)), (float32x2_t)__PAIR64__(LODWORD(a17), a18));
    v18 = vsub_f32(vadd_f32(v17, v17), vdiv_f32(vmul_f32(vmul_f32((float32x2_t)__PAIR64__(LODWORD(a1), LODWORD(a2)), (float32x2_t)__PAIR64__(LODWORD(a1), LODWORD(a2))), vsub_f32(vadd_f32((float32x2_t)__PAIR64__(LODWORD(a17), a18), (float32x2_t)__PAIR64__(LODWORD(a17), a18)), (float32x2_t)vdup_lane_s32(a4, 0))), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0)));
    v19 = vbic_s8((int8x8_t)v18, (int8x8_t)vcltz_f32(v18));
  }
  result = *(float *)&v19.i32[1] + (float)(a1 * (float)(1.0 - a20));
  if (a20 == 1.0)
    result = *(float *)&v19.i32[1];
  if (*(float *)&a5 != 1.0)
    return result + (float)(a17 * (float)(1.0 - *(float *)&a5));
  return result;
}

float PDAhuePDA(float a1, float a2, float a3, double a4, float a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13)
{
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  uint64_t v25;
  _BOOL8 v26;
  uint64_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v35;
  float v36;
  float v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v18 = a1 * a13;
  v19 = a1 - (float)(a1 * a13);
  if (a13 == 1.0)
    v19 = 0.0;
  else
    a3 = a3 * a13;
  if (a13 == 1.0)
    v20 = a2;
  else
    v20 = a2 * a13;
  if (a13 == 1.0)
    v18 = a1;
  v21 = (float)(a9 + v19) - (float)(a9 * a5);
  v22 = a10 * a5;
  if (a5 == 1.0)
    v23 = a9;
  else
    v23 = a9 * a5;
  if (a5 == 1.0)
  {
    v22 = a10;
    v24 = a11;
  }
  else
  {
    v24 = a11 * a5;
  }
  if (a5 == 1.0)
    v21 = v19;
  v35 = v23;
  v36 = v22;
  v37 = v24;
  v25 = v23 < v22;
  v26 = v23 >= v22;
  if (v24 >= *(&v35 + v26))
  {
    v27 = v23 >= v22;
    if (v24 > *(&v35 + v25))
    {
      v26 = v23 < v22;
      v25 = 2;
    }
  }
  else
  {
    v27 = 2;
  }
  v28 = *(&v35 + v25);
  v29 = *(&v35 + v27);
  if (v28 <= v29)
  {
    *(&v35 + v25) = 0.0;
    *(&v35 + v26) = 0.0;
  }
  else
  {
    if (v18 >= v20)
      v30 = v20;
    else
      v30 = v18;
    if (v18 >= v20)
      v31 = v18;
    else
      v31 = v20;
    if (a3 > v31)
      v32 = a3;
    else
      v32 = v31;
    if (a3 >= v30)
      v31 = v32;
    else
      v30 = a3;
    v33 = v31 - v30;
    *(&v35 + v25) = v33;
    *(&v35 + v26) = (float)(v33 / (float)(v28 - v29)) * (float)(*(&v35 + v26) - *(&v35 + v27));
  }
  *(&v35 + v27) = 0.0;
  return v21
       + (float)(v35
               + (float)((float)((float)((float)(v20 - v36) * 0.59) + (float)((float)(v18 - v35) * 0.3))
                       + (float)((float)(a3 - v37) * 0.11)));
}

float PDAsaturationPDA(float a1, float a2, float a3, double a4, float a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13)
{
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  uint64_t v23;
  _BOOL8 v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v32;
  float v33;
  float v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a13 == 1.0)
  {
    v18 = 0.0;
  }
  else
  {
    v18 = a1 - (float)(a1 * a13);
    a3 = a3 * a13;
    a2 = a2 * a13;
    a1 = a1 * a13;
  }
  v19 = a9 * a5;
  v20 = a10 * a5;
  if (a5 == 1.0)
  {
    v19 = a9;
    v20 = a10;
    v21 = a11;
  }
  else
  {
    v21 = a11 * a5;
  }
  if (a5 == 1.0)
    v22 = v18;
  else
    v22 = (float)(a9 + v18) - (float)(a9 * a5);
  v32 = a1;
  v33 = a2;
  v34 = a3;
  v23 = a1 < a2;
  v24 = a1 >= a2;
  if (a3 >= *(&v32 + v24))
  {
    v25 = a1 >= a2;
    if (a3 > *(&v32 + v23))
    {
      v24 = a1 < a2;
      v23 = 2;
    }
  }
  else
  {
    v25 = 2;
  }
  v26 = *(&v32 + v23);
  v27 = *(&v32 + v25);
  if (v26 <= v27)
  {
    *(&v32 + v23) = 0.0;
    *(&v32 + v24) = 0.0;
  }
  else
  {
    if (v19 >= v20)
      v28 = v20;
    else
      v28 = v19;
    if (v19 < v20)
      v19 = v20;
    if (v21 > v19)
      v29 = v21;
    else
      v29 = v19;
    if (v21 >= v28)
    {
      v21 = v28;
      v19 = v29;
    }
    v30 = v19 - v21;
    *(&v32 + v23) = v30;
    *(&v32 + v24) = (float)(v30 / (float)(v26 - v27)) * (float)(*(&v32 + v24) - *(&v32 + v25));
  }
  *(&v32 + v25) = 0.0;
  return v22
       + (float)(v32
               + (float)((float)((float)((float)(a2 - v33) * 0.59) + (float)((float)(a1 - v32) * 0.3))
                       + (float)((float)(a3 - v34) * 0.11)));
}

float PDAluminosityPDA(float a1, float a2, float a3, double a4, float a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13)
{
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;

  v18 = a9;
  v19 = a10;
  v20 = a11;
  v21 = a1 - (float)(a1 * a13);
  if (a13 == 1.0)
    v21 = 0.0;
  else
    a3 = a3 * a13;
  if (a13 != 1.0)
  {
    a2 = a2 * a13;
    a1 = a1 * a13;
  }
  v22 = (float)(a9 + v21) - (float)(a9 * a5);
  if (a5 == 1.0)
  {
    v22 = v21;
  }
  else
  {
    v18 = a9 * a5;
    v19 = a10 * a5;
    v20 = a11 * a5;
  }
  return v22
       + (float)(a1
               + (float)((float)((float)((float)(v19 - a2) * 0.59) + (float)((float)(v18 - a1) * 0.3))
                       + (float)((float)(v20 - a3) * 0.11)));
}

void RGBAf_mark_pixelshape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int8x8_t a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int *v23;
  int64_t v24;
  unint64_t v25;
  float32x4_t *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  float32x4_t *v39;
  float32x4_t *v40;
  uint64_t v41;
  BOOL v42;
  unint64_t v43;
  _BOOL4 v44;
  int v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  int *v49;
  void *v50;
  void *v51;
  unint64_t v52;
  float32x4_t *v53;
  uint64_t v54;
  char *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t i;
  int8x16_t *v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  int8x16_t v76;
  unint64_t j;
  float32x4_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  int8x16_t v86;
  int8x16_t v87;
  int8x16_t v88;
  uint64_t v89;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t n;
  float32x4_t *v96;
  float32x4_t v97;
  unint64_t ii;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  unsigned int v106;
  int8x16_t v107;
  int8x16_t v108;
  int8x16_t v109;
  uint64_t v110;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t mm;
  float32x4_t *v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  unint64_t nn;
  float32x4_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t i3;
  float32x4_t *v136;
  float32x4_t v137;
  unint64_t i4;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  int v145;
  unsigned int v146;
  int8x16_t v147;
  int8x16_t v148;
  int8x16_t v149;
  uint64_t v150;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t i7;
  int8x16_t *v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  int8x16_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  unint64_t i8;
  float32x4_t v167;
  float32x4_t v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  int v175;
  uint64_t v176;
  unint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  unint64_t i11;
  float32x4_t *v183;
  float32x4_t v184;
  unint64_t i12;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  int v192;
  uint64_t v193;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  uint64_t v198;
  unint64_t i15;
  float32x4_t *v200;
  float32x4_t v201;
  unint64_t i16;
  unint64_t v203;
  uint64_t v204;
  unint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  uint64_t v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  uint64_t v214;
  unint64_t i19;
  float32x4_t *v216;
  float32x4_t v217;
  unint64_t i20;
  unint64_t v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  int v225;
  uint64_t v226;
  unint64_t v227;
  unint64_t v228;
  unint64_t v229;
  uint64_t v230;
  unint64_t i23;
  float32x4_t *v232;
  float32x4_t v233;
  float32x4_t v234;
  unint64_t i24;
  unint64_t v236;
  uint64_t v237;
  unint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  int v242;
  unsigned int v243;
  int8x16_t v244;
  int8x16_t v245;
  int8x16_t v246;
  int8x16_t v247;
  unsigned int v248;
  int8x16_t v249;
  int8x16_t v250;
  uint64_t v251;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  uint64_t v256;
  unint64_t i27;
  float32x4_t *v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  unint64_t i28;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  unint64_t v272;
  uint64_t v273;
  unint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  int v278;
  int8x16_t v279;
  int8x16_t v280;
  int8x16_t v281;
  uint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  uint64_t v286;
  unint64_t i31;
  float32x4_t *v288;
  float32x4_t v289;
  unint64_t i32;
  unint64_t v291;
  uint64_t v292;
  unint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  int v297;
  unsigned int v298;
  int8x16_t v299;
  int8x16_t v300;
  int8x16_t v301;
  int8x16_t v302;
  unsigned int v303;
  int8x16_t v304;
  int8x16_t v305;
  uint64_t v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  uint64_t v310;
  unint64_t i35;
  int8x16_t *v312;
  float32x4_t v313;
  float32x4_t v314;
  float32x4_t v315;
  float32x4_t v316;
  unint64_t i36;
  float32x4_t v318;
  float32x4_t v319;
  unint64_t v320;
  uint64_t v321;
  unint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  int v326;
  unsigned int v327;
  int8x16_t v328;
  int8x16_t v329;
  int8x16_t v330;
  unsigned int v331;
  int8x16_t v332;
  int8x16_t v333;
  int8x16_t v334;
  uint64_t v335;
  unint64_t v337;
  unint64_t v338;
  unint64_t v339;
  uint64_t v340;
  unint64_t i39;
  int8x16_t *v342;
  float32x4_t v343;
  float32x4_t v344;
  float32x4_t v345;
  float32x4_t v346;
  unint64_t i40;
  float32x4_t v348;
  float32x4_t v349;
  unint64_t v350;
  uint64_t v351;
  unint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  int v356;
  unsigned int v357;
  int8x16_t v358;
  int8x16_t v359;
  int8x16_t v360;
  int8x16_t v361;
  unsigned int v362;
  int8x16_t v363;
  int8x16_t v364;
  uint64_t v365;
  float32x4_t v366;
  int8x16_t v367;
  unint64_t v368;
  unint64_t v369;
  unint64_t v370;
  uint64_t v371;
  unint64_t i43;
  int8x16_t *v373;
  float32x4_t v374;
  float32x4_t v375;
  float32x4_t v376;
  float32x4_t v377;
  float32x4_t v378;
  float32x4_t v379;
  float32x4_t v380;
  float32x4_t v381;
  int8x16_t v382;
  int8x16_t v383;
  int8x16_t v384;
  int8x16_t v385;
  unint64_t i44;
  float32x4_t v387;
  float32x4_t v388;
  float32x4_t v389;
  float32x4_t v390;
  int8x16_t v391;
  int8x16_t v392;
  unint64_t v393;
  uint64_t v394;
  unint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  int v399;
  unsigned int v400;
  int8x16_t v401;
  int8x16_t v402;
  int8x16_t v403;
  int8x16_t v404;
  unsigned int v405;
  int8x16_t v406;
  int8x16_t v407;
  uint64_t v408;
  unint64_t v409;
  unint64_t v410;
  unint64_t v411;
  uint64_t v412;
  unint64_t i47;
  int8x16_t *v414;
  float32x4_t v415;
  float32x4_t v416;
  float32x4_t v417;
  float32x4_t v418;
  unint64_t i48;
  float32x4_t v420;
  float32x4_t v421;
  unint64_t v422;
  uint64_t v423;
  unint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  int v428;
  unsigned int v429;
  int8x16_t v430;
  int8x16_t v431;
  int8x16_t v432;
  int8x16_t v433;
  unsigned int v434;
  int8x16_t v435;
  int8x16_t v436;
  uint64_t v437;
  unint64_t v438;
  unint64_t v439;
  unint64_t v440;
  uint64_t v441;
  unint64_t i51;
  int8x16_t *v443;
  float32x4_t v444;
  float32x4_t v445;
  float32x4_t v446;
  float32x4_t v447;
  unint64_t i52;
  float32x4_t v449;
  float32x4_t v450;
  unint64_t v451;
  uint64_t v452;
  unint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  int v457;
  unsigned int v458;
  int8x16_t v459;
  int8x16_t v460;
  int8x16_t v461;
  int8x16_t v462;
  unsigned int v463;
  int8x16_t v464;
  int8x16_t v465;
  uint64_t v466;
  unint64_t v468;
  unint64_t v469;
  unint64_t v470;
  uint64_t v471;
  unint64_t i55;
  int8x16_t *v473;
  float32x4_t v474;
  float32x4_t v475;
  float32x4_t v476;
  float32x4_t v477;
  int8x16_t v478;
  float32x4_t v479;
  float32x4_t v480;
  int8x16_t v481;
  float32x4_t v482;
  float32x4_t v483;
  int8x16_t v484;
  float32x4_t v485;
  float32x4_t v486;
  float32x4_t v487;
  int8x16_t v488;
  int8x16_t v489;
  unint64_t i56;
  float32x4_t v491;
  float32x4_t v492;
  float32x4_t v493;
  float32x4_t v494;
  int8x16_t v495;
  int8x16_t v496;
  float32x4_t v497;
  float32x4_t v498;
  int8x16_t v499;
  unint64_t v500;
  uint64_t v501;
  unint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  int v506;
  unsigned int v507;
  int8x16_t v508;
  int8x16_t v509;
  int8x16_t v510;
  unsigned int v511;
  int8x16_t v512;
  int8x16_t v513;
  int8x16_t v514;
  uint64_t v515;
  unint64_t v516;
  unint64_t v517;
  unint64_t v518;
  uint64_t v519;
  unint64_t i59;
  int8x16_t *v521;
  float32x4_t v522;
  float32x4_t v523;
  float32x4_t v524;
  float32x4_t v525;
  float32x4_t v526;
  float32x4_t v527;
  int8x16_t v528;
  int8x16_t v529;
  float32x4_t v530;
  float32x4_t v531;
  unint64_t i60;
  float32x4_t v533;
  float32x4_t v534;
  float32x4_t v535;
  int8x16_t v536;
  float32x4_t v537;
  unint64_t v538;
  uint64_t v539;
  unint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  int v544;
  unsigned int v545;
  int8x16_t v546;
  int8x16_t v547;
  int8x16_t v548;
  int8x16_t v549;
  unsigned int v550;
  int8x16_t v551;
  int8x16_t v552;
  uint64_t v553;
  unint64_t v554;
  unint64_t v555;
  unint64_t v556;
  uint64_t v557;
  unint64_t i63;
  int8x16_t *v559;
  float32x4_t v560;
  float32x4_t v561;
  float32x4_t v562;
  float32x4_t v563;
  float32x4_t v564;
  float32x4_t v565;
  int8x16_t v566;
  int8x16_t v567;
  int8x16_t v568;
  int8x16_t v569;
  float32x4_t v570;
  float32x4_t v571;
  float32x4_t v572;
  float32x4_t v573;
  float32x4_t v574;
  float32x4_t v575;
  float32x4_t v576;
  unint64_t i64;
  float32x4_t v578;
  float32x4_t v579;
  float32x4_t v580;
  int8x16_t v581;
  int8x16_t v582;
  float32x4_t v583;
  float32x4_t v584;
  float32x4_t v585;
  unint64_t v586;
  uint64_t v587;
  unint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  int v592;
  unsigned int v593;
  int8x16_t v594;
  int8x16_t v595;
  int8x16_t v596;
  int8x16_t v597;
  unsigned int v598;
  int8x16_t v599;
  int8x16_t v600;
  uint64_t v601;
  float32x4_t v602;
  int8x16_t v603;
  unint64_t v604;
  unint64_t v605;
  unint64_t v606;
  uint64_t v607;
  unint64_t i67;
  int8x16_t *v609;
  float32x4_t v610;
  float32x4_t v611;
  float32x4_t v612;
  float32x4_t v613;
  float32x4_t v614;
  float32x4_t v615;
  float32x4_t v616;
  float32x4_t v617;
  int8x16_t v618;
  int8x16_t v619;
  int8x16_t v620;
  int8x16_t v621;
  unint64_t i68;
  float32x4_t v623;
  float32x4_t v624;
  float32x4_t v625;
  float32x4_t v626;
  int8x16_t v627;
  int8x16_t v628;
  unint64_t v629;
  uint64_t v630;
  unint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  int v635;
  unsigned int v636;
  int8x16_t v637;
  int8x16_t v638;
  int8x16_t v639;
  int8x16_t v640;
  unsigned int v641;
  int8x16_t v642;
  int8x16_t v643;
  uint64_t v644;
  unint64_t v645;
  unint64_t v646;
  unint64_t v647;
  uint64_t v648;
  unint64_t i71;
  int8x16_t *v650;
  float32x4_t v651;
  float32x4_t v652;
  float32x4_t v653;
  float32x4_t v654;
  float32x4_t v655;
  float32x4_t v656;
  float32x4_t v657;
  float32x4_t v658;
  int8x16_t v659;
  int8x16_t v660;
  unint64_t i72;
  float32x4_t v662;
  float32x4_t v663;
  float32x4_t v664;
  float32x4_t v665;
  int8x16_t v666;
  unint64_t v667;
  uint64_t v668;
  unint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  int v673;
  unsigned int v674;
  int8x16_t v675;
  int8x16_t v676;
  int8x16_t v677;
  int8x16_t v678;
  unsigned int v679;
  int8x16_t v680;
  int8x16_t v681;
  uint64_t v682;
  unint64_t v683;
  unint64_t v684;
  unint64_t v685;
  uint64_t v686;
  unint64_t i75;
  float32x4_t v688;
  int8x16_t *v689;
  float32x4_t v690;
  float32x4_t v691;
  float32x4_t v692;
  float32x4_t v693;
  float32x4_t v694;
  unint64_t i76;
  float32x4_t v696;
  float32x4_t v697;
  float32x4_t v698;
  unint64_t v699;
  uint64_t v700;
  unint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  unsigned int v705;
  int v706;
  float v707;
  __int32 v708;
  __int32 v709;
  unint64_t v710;
  uint64_t v711;
  unint64_t v712;
  unint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  unsigned int v717;
  int v718;
  float v719;
  __int32 v720;
  __int32 v721;
  unint64_t v722;
  uint64_t v723;
  unint64_t v724;
  unint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  unsigned int v729;
  int v730;
  float v731;
  __int32 v732;
  __int32 v733;
  unint64_t v734;
  uint64_t v735;
  unint64_t v736;
  unint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  unsigned int v741;
  int v742;
  float v743;
  __int32 v744;
  __int32 v745;
  unint64_t v746;
  uint64_t v747;
  unint64_t v748;
  unint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  int v753;
  float v754;
  unint64_t v755;
  uint64_t v756;
  unint64_t v757;
  unint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  int v762;
  float v763;
  float v764;
  float v765;
  float v766;
  unint64_t v767;
  uint64_t v768;
  unint64_t v769;
  unint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  int v774;
  float v775;
  float v776;
  float v777;
  float v778;
  unint64_t v779;
  uint64_t v780;
  unint64_t v781;
  unint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  int v786;
  unint64_t v787;
  uint64_t v788;
  unint64_t v789;
  unint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  int v794;
  float v795;
  float v796;
  float v797;
  float v798;
  unint64_t v799;
  uint64_t v800;
  unint64_t v801;
  unint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  int v806;
  float v807;
  unint64_t v808;
  uint64_t v809;
  unint64_t v810;
  unint64_t v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  int v815;
  float v816;
  unint64_t v817;
  uint64_t v818;
  unint64_t v819;
  unint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  int v824;
  unint64_t v825;
  uint64_t v826;
  unint64_t v827;
  unint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  int v832;
  unint64_t v833;
  uint64_t v834;
  unint64_t v835;
  unint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  int v840;
  float v841;
  float v842;
  float v843;
  float v844;
  float v845;
  float v846;
  float v847;
  float v848;
  float v849;
  float v850;
  float v851;
  float v852;
  float v853;
  unint64_t v854;
  uint64_t v855;
  unint64_t v856;
  unint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  int v861;
  float v862;
  float v863;
  unint64_t v864;
  uint64_t v865;
  unint64_t v866;
  unint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  int v872;
  float v873;
  float v874;
  float32_t v875;
  unint64_t v876;
  uint64_t v877;
  unint64_t v878;
  unint64_t v879;
  uint64_t v880;
  uint64_t v881;
  uint64_t v882;
  int v883;
  float v884;
  float v885;
  float v886;
  float v887;
  float32x2_t v888;
  float32x2_t v889;
  float32x2_t v890;
  float32x2_t v891;
  float32x2_t v892;
  float v893;
  float v894;
  float v895;
  float v896;
  unint64_t v897;
  uint64_t v898;
  unint64_t v899;
  unint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  int v904;
  float v905;
  float v906;
  float32_t v907;
  unint64_t v908;
  uint64_t v909;
  unint64_t v910;
  unint64_t v911;
  uint64_t v912;
  uint64_t v913;
  uint64_t v914;
  uint8x8_t v915;
  unsigned int v916;
  uint64_t v917;
  int v918;
  unint64_t v919;
  uint64_t v920;
  unint64_t v921;
  unint64_t v922;
  uint64_t v923;
  uint64_t v924;
  uint64_t v925;
  int v926;
  unint64_t v927;
  uint64_t v928;
  unint64_t v929;
  unint64_t v930;
  uint64_t v931;
  uint64_t v932;
  uint64_t v933;
  int v934;
  float v935;
  unint64_t v936;
  uint64_t v937;
  unint64_t v938;
  unint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  int v943;
  float v944;
  unint64_t v945;
  uint64_t v946;
  unint64_t v947;
  unint64_t v948;
  uint64_t v949;
  uint64_t v950;
  uint64_t v951;
  int v952;
  float v953;
  unint64_t v954;
  uint64_t v955;
  unint64_t v956;
  unint64_t v957;
  uint64_t v958;
  uint64_t v959;
  uint64_t v960;
  int v961;
  float v962;
  unint64_t v963;
  uint64_t v964;
  unint64_t v965;
  unint64_t v966;
  uint64_t v967;
  uint64_t v968;
  uint64_t v969;
  int v970;
  float v971;
  unint64_t v972;
  uint64_t v973;
  unint64_t v974;
  unint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  int v979;
  float v980;
  unint64_t v981;
  uint64_t v982;
  unint64_t v983;
  unint64_t v984;
  uint64_t v985;
  uint64_t v986;
  uint64_t v987;
  int v988;
  __int32 v989;
  unint64_t v990;
  uint64_t v991;
  unint64_t v992;
  unint64_t v993;
  uint64_t v994;
  uint64_t v995;
  uint64_t v996;
  int v997;
  float v998;
  unint64_t v999;
  uint64_t v1000;
  unint64_t v1001;
  unint64_t v1002;
  uint64_t v1003;
  uint64_t v1004;
  uint64_t v1005;
  unsigned int v1006;
  int v1007;
  unint64_t v1008;
  uint64_t v1009;
  unint64_t v1010;
  unint64_t v1011;
  uint64_t v1012;
  uint64_t v1013;
  uint64_t v1014;
  unint64_t v1016;
  unint64_t v1017;
  unint64_t v1018;
  uint64_t v1019;
  unint64_t k;
  int8x16_t *v1021;
  float32x4_t v1022;
  float32x4_t v1023;
  float32x4_t v1024;
  float32x4_t v1025;
  float32x4_t v1026;
  float32x4_t v1027;
  unint64_t m;
  float32x4_t v1029;
  float32x4_t v1030;
  float32x4_t v1031;
  unint64_t v1032;
  uint64_t v1033;
  unint64_t v1034;
  uint64_t v1035;
  uint64_t v1036;
  uint64_t v1037;
  unint64_t v1039;
  unint64_t v1040;
  unint64_t v1041;
  uint64_t v1042;
  unint64_t jj;
  int8x16_t *v1044;
  int8x16_t v1045;
  unint64_t kk;
  unint64_t v1047;
  uint64_t v1048;
  unint64_t v1049;
  uint64_t v1050;
  uint64_t v1051;
  uint64_t v1052;
  unint64_t v1054;
  unint64_t v1055;
  unint64_t v1056;
  uint64_t v1057;
  unint64_t i1;
  int8x16_t *v1059;
  float32x4_t v1060;
  float32x4_t v1061;
  int8x16_t v1062;
  unint64_t i2;
  float32x4_t v1064;
  unint64_t v1065;
  uint64_t v1066;
  unint64_t v1067;
  uint64_t v1068;
  uint64_t v1069;
  uint64_t v1070;
  unint64_t v1071;
  unint64_t v1072;
  unint64_t v1073;
  uint64_t v1074;
  unint64_t i5;
  int8x16_t *v1076;
  float32x4_t v1077;
  float32x4_t v1078;
  float32x4_t v1079;
  float32x4_t v1080;
  unint64_t i6;
  float32x4_t v1082;
  float32x4_t v1083;
  unint64_t v1084;
  uint64_t v1085;
  unint64_t v1086;
  uint64_t v1087;
  uint64_t v1088;
  uint64_t v1089;
  unint64_t v1091;
  unint64_t v1092;
  unint64_t v1093;
  uint64_t v1094;
  unint64_t i9;
  int8x16_t *v1096;
  float32x4_t v1097;
  float32x4_t v1098;
  float32x4_t v1099;
  float32x4_t v1100;
  float32x4_t v1101;
  float32x4_t v1102;
  unint64_t i10;
  float32x4_t v1104;
  float32x4_t v1105;
  float32x4_t v1106;
  unint64_t v1107;
  uint64_t v1108;
  unint64_t v1109;
  uint64_t v1110;
  uint64_t v1111;
  uint64_t v1112;
  unint64_t v1114;
  unint64_t v1115;
  unint64_t v1116;
  uint64_t v1117;
  unint64_t i13;
  int8x16_t *v1119;
  int8x16_t v1120;
  unint64_t i14;
  unint64_t v1122;
  uint64_t v1123;
  unint64_t v1124;
  uint64_t v1125;
  uint64_t v1126;
  uint64_t v1127;
  unint64_t v1129;
  unint64_t v1130;
  unint64_t v1131;
  uint64_t v1132;
  unint64_t i17;
  int8x16_t *v1134;
  float32x4_t v1135;
  float32x4_t v1136;
  int8x16_t v1137;
  unint64_t i18;
  float32x4_t v1139;
  unint64_t v1140;
  uint64_t v1141;
  unint64_t v1142;
  uint64_t v1143;
  uint64_t v1144;
  uint64_t v1145;
  unint64_t v1146;
  unint64_t v1147;
  unint64_t v1148;
  uint64_t v1149;
  unint64_t i21;
  int8x16_t *v1151;
  float32x4_t v1152;
  float32x4_t v1153;
  float32x4_t v1154;
  float32x4_t v1155;
  unint64_t i22;
  float32x4_t v1157;
  float32x4_t v1158;
  unint64_t v1159;
  uint64_t v1160;
  unint64_t v1161;
  uint64_t v1162;
  uint64_t v1163;
  uint64_t v1164;
  unint64_t v1165;
  unint64_t v1166;
  unint64_t v1167;
  uint64_t v1168;
  unint64_t i25;
  int8x16_t *v1170;
  float32x4_t v1171;
  float32x4_t v1172;
  float32x4_t v1173;
  float32x4_t v1174;
  unint64_t i26;
  float32x4_t v1176;
  float32x4_t v1177;
  unint64_t v1178;
  uint64_t v1179;
  unint64_t v1180;
  uint64_t v1181;
  uint64_t v1182;
  uint64_t v1183;
  unint64_t v1185;
  unint64_t v1186;
  unint64_t v1187;
  uint64_t v1188;
  unint64_t i29;
  int8x16_t *v1190;
  float32x4_t v1191;
  float32x4_t v1192;
  float32x4_t v1193;
  float32x4_t v1194;
  float32x4_t v1195;
  float32x4_t v1196;
  float32x4_t v1197;
  float32x4_t v1198;
  unint64_t i30;
  float32x4_t v1200;
  float32x4_t v1201;
  float32x4_t v1202;
  float32x4_t v1203;
  unint64_t v1204;
  uint64_t v1205;
  unint64_t v1206;
  uint64_t v1207;
  uint64_t v1208;
  uint64_t v1209;
  unint64_t v1210;
  unint64_t v1211;
  unint64_t v1212;
  uint64_t v1213;
  unint64_t i33;
  int8x16_t *v1215;
  int8x16_t v1216;
  unint64_t i34;
  unint64_t v1218;
  uint64_t v1219;
  unint64_t v1220;
  uint64_t v1221;
  uint64_t v1222;
  uint64_t v1223;
  unint64_t v1224;
  unint64_t v1225;
  unint64_t v1226;
  uint64_t v1227;
  unint64_t i37;
  int8x16_t *v1229;
  float32x4_t v1230;
  float32x4_t v1231;
  float32x4_t v1232;
  float32x4_t v1233;
  unint64_t i38;
  float32x4_t v1235;
  float32x4_t v1236;
  unint64_t v1237;
  uint64_t v1238;
  unint64_t v1239;
  uint64_t v1240;
  uint64_t v1241;
  uint64_t v1242;
  unint64_t v1244;
  unint64_t v1245;
  unint64_t v1246;
  uint64_t v1247;
  unint64_t i41;
  int8x16_t *v1249;
  float32x4_t v1250;
  float32x4_t v1251;
  float32x4_t v1252;
  float32x4_t v1253;
  unint64_t i42;
  float32x4_t v1255;
  float32x4_t v1256;
  unint64_t v1257;
  uint64_t v1258;
  unint64_t v1259;
  uint64_t v1260;
  uint64_t v1261;
  uint64_t v1262;
  float32x4_t v1263;
  int8x16_t v1264;
  unint64_t v1265;
  unint64_t v1266;
  unint64_t v1267;
  uint64_t v1268;
  unint64_t i45;
  int8x16_t *v1270;
  float32x4_t v1271;
  float32x4_t v1272;
  float32x4_t v1273;
  float32x4_t v1274;
  float32x4_t v1275;
  float32x4_t v1276;
  float32x4_t v1277;
  float32x4_t v1278;
  int8x16_t v1279;
  int8x16_t v1280;
  int8x16_t v1281;
  int8x16_t v1282;
  unint64_t i46;
  float32x4_t v1284;
  float32x4_t v1285;
  float32x4_t v1286;
  float32x4_t v1287;
  int8x16_t v1288;
  int8x16_t v1289;
  unint64_t v1290;
  uint64_t v1291;
  unint64_t v1292;
  uint64_t v1293;
  uint64_t v1294;
  uint64_t v1295;
  unint64_t v1296;
  unint64_t v1297;
  unint64_t v1298;
  uint64_t v1299;
  unint64_t i49;
  int8x16_t *v1301;
  float32x4_t v1302;
  float32x4_t v1303;
  float32x4_t v1304;
  float32x4_t v1305;
  unint64_t i50;
  float32x4_t v1307;
  float32x4_t v1308;
  unint64_t v1309;
  uint64_t v1310;
  unint64_t v1311;
  uint64_t v1312;
  uint64_t v1313;
  uint64_t v1314;
  unint64_t v1315;
  unint64_t v1316;
  unint64_t v1317;
  uint64_t v1318;
  unint64_t i53;
  int8x16_t *v1320;
  float32x4_t v1321;
  float32x4_t v1322;
  float32x4_t v1323;
  float32x4_t v1324;
  unint64_t i54;
  float32x4_t v1326;
  float32x4_t v1327;
  unint64_t v1328;
  uint64_t v1329;
  unint64_t v1330;
  uint64_t v1331;
  uint64_t v1332;
  uint64_t v1333;
  unint64_t v1335;
  unint64_t v1336;
  unint64_t v1337;
  uint64_t v1338;
  unint64_t i57;
  int8x16_t *v1340;
  float32x4_t v1341;
  float32x4_t v1342;
  float32x4_t v1343;
  float32x4_t v1344;
  float32x4_t v1345;
  float32x4_t v1346;
  float32x4_t v1347;
  float32x4_t v1348;
  int8x16_t v1349;
  int8x16_t v1350;
  float32x4_t v1351;
  float32x4_t v1352;
  float32x4_t v1353;
  float32x4_t v1354;
  int8x16_t v1355;
  int8x16_t v1356;
  unint64_t i58;
  float32x4_t v1358;
  float32x4_t v1359;
  float32x4_t v1360;
  float32x4_t v1361;
  int8x16_t v1362;
  int8x16_t v1363;
  float32x4_t v1364;
  float32x4_t v1365;
  int8x16_t v1366;
  unint64_t v1367;
  uint64_t v1368;
  unint64_t v1369;
  uint64_t v1370;
  uint64_t v1371;
  uint64_t v1372;
  unint64_t v1373;
  unint64_t v1374;
  unint64_t v1375;
  uint64_t v1376;
  unint64_t i61;
  int8x16_t *v1378;
  float32x4_t v1379;
  float32x4_t v1380;
  float32x4_t v1381;
  float32x4_t v1382;
  int8x16_t v1383;
  int8x16_t v1384;
  float32x4_t v1385;
  float32x4_t v1386;
  float32x4_t v1387;
  float32x4_t v1388;
  unint64_t i62;
  float32x4_t v1390;
  float32x4_t v1391;
  float32x4_t v1392;
  int8x16_t v1393;
  float32x4_t v1394;
  unint64_t v1395;
  uint64_t v1396;
  unint64_t v1397;
  uint64_t v1398;
  uint64_t v1399;
  uint64_t v1400;
  unint64_t v1401;
  unint64_t v1402;
  unint64_t v1403;
  uint64_t v1404;
  unint64_t i65;
  int8x16_t *v1406;
  float32x4_t v1407;
  float32x4_t v1408;
  float32x4_t v1409;
  float32x4_t v1410;
  float32x4_t v1411;
  int8x16_t v1412;
  int8x16_t v1413;
  float32x4_t v1414;
  int8x16_t v1415;
  int8x16_t v1416;
  float32x4_t v1417;
  float32x4_t v1418;
  float32x4_t v1419;
  float32x4_t v1420;
  float32x4_t v1421;
  float32x4_t v1422;
  float32x4_t v1423;
  unint64_t i66;
  float32x4_t v1425;
  float32x4_t v1426;
  float32x4_t v1427;
  int8x16_t v1428;
  int8x16_t v1429;
  float32x4_t v1430;
  float32x4_t v1431;
  float32x4_t v1432;
  unint64_t v1433;
  uint64_t v1434;
  unint64_t v1435;
  uint64_t v1436;
  uint64_t v1437;
  uint64_t v1438;
  float32x4_t v1439;
  int8x16_t v1440;
  unint64_t v1441;
  unint64_t v1442;
  unint64_t v1443;
  uint64_t v1444;
  unint64_t i69;
  int8x16_t *v1446;
  float32x4_t v1447;
  float32x4_t v1448;
  float32x4_t v1449;
  float32x4_t v1450;
  float32x4_t v1451;
  float32x4_t v1452;
  float32x4_t v1453;
  float32x4_t v1454;
  int8x16_t v1455;
  int8x16_t v1456;
  int8x16_t v1457;
  int8x16_t v1458;
  unint64_t i70;
  float32x4_t v1460;
  float32x4_t v1461;
  float32x4_t v1462;
  float32x4_t v1463;
  int8x16_t v1464;
  int8x16_t v1465;
  unint64_t v1466;
  uint64_t v1467;
  unint64_t v1468;
  uint64_t v1469;
  uint64_t v1470;
  uint64_t v1471;
  unint64_t v1472;
  unint64_t v1473;
  unint64_t v1474;
  uint64_t v1475;
  unint64_t i73;
  int8x16_t *v1477;
  float32x4_t v1478;
  float32x4_t v1479;
  float32x4_t v1480;
  float32x4_t v1481;
  float32x4_t v1482;
  float32x4_t v1483;
  float32x4_t v1484;
  float32x4_t v1485;
  int8x16_t v1486;
  int8x16_t v1487;
  unint64_t i74;
  float32x4_t v1489;
  float32x4_t v1490;
  float32x4_t v1491;
  float32x4_t v1492;
  int8x16_t v1493;
  unint64_t v1494;
  uint64_t v1495;
  unint64_t v1496;
  uint64_t v1497;
  uint64_t v1498;
  uint64_t v1499;
  unint64_t v1500;
  unint64_t v1501;
  unint64_t v1502;
  uint64_t v1503;
  unint64_t i77;
  int8x16_t *v1505;
  float32x4_t v1506;
  float32x4_t v1507;
  float32x4_t v1508;
  float32x4_t v1509;
  float32x4_t v1510;
  float32x4_t v1511;
  unint64_t i78;
  float32x4_t v1513;
  float32x4_t v1514;
  float32x4_t v1515;
  unint64_t v1516;
  uint64_t v1517;
  unint64_t v1518;
  uint64_t v1519;
  uint64_t v1520;
  uint64_t v1521;
  char *v1522;
  unint64_t v1523;
  uint64_t v1524;
  __int128 v1525;
  double v1526;
  double v1527;
  double v1528;
  double v1529;
  double v1530;
  double v1531;
  double v1532;
  _BYTE *v1533;
  int v1534;
  int v1535;
  uint64_t v1537;
  int v1538;
  int v1539;
  unint64_t v1540;
  int v1541;
  int v1542;
  void *v1543;
  float32x4_t *v1544;
  unint64_t v1545;
  int v1546;
  unint64_t v1547;
  unint64_t v1548;
  unint64_t v1549;
  unint64_t v1550;
  uint64_t v1551;
  unsigned int v1552;
  int v1553[3];

  v14 = a3;
  v1533 = (_BYTE *)a1;
  v15 = *(_DWORD *)a2;
  v16 = *(_DWORD *)(a2 + 4);
  v17 = *(int *)(a2 + 8);
  v1552 = *(_DWORD *)(a2 + 8);
  v1553[0] = v16;
  v18 = *(int *)(a2 + 28);
  v19 = *(_QWORD *)(a2 + 40);
  v20 = *(_QWORD *)(a2 + 48);
  v22 = *(_QWORD *)(a2 + 88);
  v21 = *(_QWORD *)(a2 + 96);
  v23 = *(int **)(a2 + 136);
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_6_12441);
  v1546 = v16;
  v24 = v16;
  v1534 = v14;
  v1535 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
  v25 = v18 >> 4;
  v26 = (float32x4_t *)(v19 + 16 * (*(int *)(a2 + 12) + (v18 >> 4) * *(int *)(a2 + 16)));
  v27 = *(unsigned int *)(a2 + 104);
  v28 = *(unsigned int *)(a2 + 108);
  v29 = v15 & 0xFF00;
  v30 = a2;
  v31 = (unint64_t)*(int *)(a2 + 76) >> 4;
  v1538 = *(_DWORD *)(a2 + 60);
  v1539 = *(_DWORD *)(a2 + 56);
  if (v29 != 256)
  {
    v33 = v18 >> 4;
    LODWORD(v1545) = *(_DWORD *)(a2 + 64);
    v1549 = (unint64_t)*(int *)(a2 + 76) >> 4;
    v1542 = *(_DWORD *)(a2 + 68);
    v32 = v22;
    v1548 = v22 + 16 * v31 * v1542;
    v44 = v21 != 0;
    if (v23)
    {
      LODWORD(a4) = 1;
      v1550 = v22;
      goto LABEL_32;
    }
    v45 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
    if (v22)
    {
      v1543 = 0;
      v46 = v22 + 16 * v31 * (v1538 % v1542);
      v1539 %= (int)v1545;
      v47 = v46 + 16 * v1539;
      v22 = v46 + 16 * (int)v1545;
      v1541 = 1;
      v1550 = v47;
      v1544 = v26;
      v1538 %= v1542;
      v48 = v33;
      goto LABEL_38;
    }
    v22 = 0;
    v1541 = 1;
    v48 = v25;
    v52 = (unint64_t)*(int *)(a2 + 76) >> 4;
    goto LABEL_36;
  }
  v32 = v22 + 16 * (*(int *)(a2 + 56) + v31 * *(int *)(a2 + 60));
  v33 = v25;
  if (v31 == v25)
  {
    v34 = (unint64_t)v26 - v32;
    if ((uint64_t)v26 - v32 < 1)
    {
      a4 = 1;
      v1545 = v25;
    }
    else
    {
      v35 = v25;
      v36 = v25 * (v17 - 1);
      v37 = v32 + 16 * v36;
      v38 = v1546 - 1;
      v39 = &v26[v36];
      if ((unint64_t)v26 <= v37 + 16 * (v1546 - 1))
      {
        v25 = -(uint64_t)v25;
      }
      else
      {
        v37 = v32;
        v39 = v26;
      }
      v40 = &v26[v38];
      v41 = v32 + 16 * v38;
      v42 = v24 < (uint64_t)(v34 >> 4);
      if (v24 >= (uint64_t)(v34 >> 4))
        v32 = v41;
      else
        v32 = v37;
      if (v24 >= (uint64_t)(v34 >> 4))
        v26 = v40;
      else
        v26 = v39;
      if (v24 >= (uint64_t)(v34 >> 4))
        v43 = v35;
      else
        v43 = v25;
      v1545 = v43;
      if (v42)
        v33 = v25;
      else
        v33 = v35;
      if (v42)
        a4 = 1;
      else
        a4 = 0xFFFFFFFFLL;
    }
  }
  else
  {
    a4 = 1;
    v1545 = (unint64_t)*(int *)(a2 + 76) >> 4;
  }
  v44 = v21 != 0;
  if (!v23)
  {
    v1541 = a4;
    v1542 = 0;
    v52 = v1545;
    v24 = v1546 * (int)a4;
    v22 = -1;
    v45 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
    v48 = v33;
LABEL_36:
    v1548 = 0;
    v1543 = 0;
    v1549 = v52 - v24;
    v1550 = 0;
    v47 = v32;
    v1544 = v26;
LABEL_38:
    while (2)
    {
      v1547 = v48 - v24;
      switch(v14)
      {
        case 0:
          v53 = &v26[-v1546 + 1];
          v54 = v1547 + v1546;
          if (v1541 < 0)
            v54 = v1547 - v1546;
          else
            v53 = v26;
          v55 = (char *)&v53[(v54 * ((int)v1552 - 1)) & (v54 >> 63)];
          if (v54 < 0)
            v54 = -v54;
          CGBlt_fillBytes(16 * v1546, v1552, 0, v55, 16 * v54);
          goto LABEL_1353;
        case 1:
          v56 = *(unsigned __int8 *)(v30 + 1);
          if (v56 == 2)
          {
            if (v1546 >= 2 && (16 * v1545) <= 0x40)
            {
              a7.i32[0] = 16 * v1545;
              v915 = (uint8x8_t)vcnt_s8(a7);
              v915.i16[0] = vaddlv_u8(v915);
              if (v915.i32[0] <= 1u)
              {
                CGSFillDRAM64(v26, 16 * (v1546 + v1547), 16 * v1546, v1552, v32, 16 * v1549, 16 * v1545, v1542, 16 * v1539, v1538);
                goto LABEL_1353;
              }
            }
          }
          else if (v56 == 1)
          {
            if (v20 != 0 && !v44)
            {
              v1006 = v1552;
              do
              {
                v1007 = v1546;
                do
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = 1065353216;
                  v1008 = v47 + 16 * v1541;
                  if (v1008 >= v22)
                    v1009 = -(uint64_t)(int)v1545;
                  else
                    v1009 = 0;
                  v47 = v1008 + 16 * v1009;
                  v26 += v1541;
                  --v1007;
                }
                while (v1007);
                v26 += v1547;
                v1010 = v1550;
                v1011 = v1550 + 16 * v1549;
                if (v1011 >= v1548)
                  v1012 = -(uint64_t)(v1549 * v1542);
                else
                  v1012 = 0;
                v1013 = v1011 + 16 * v1012;
                v1014 = v22 + 16 * v1012 + 16 * v1549;
                if (v1548)
                {
                  v22 = v1014;
                  v1010 = v1013;
                }
                v1550 = v1010;
                if (v1548)
                  v47 = v1013;
                else
                  v47 += 16 * v1549;
                --v1006;
              }
              while (v1006);
              goto LABEL_1352;
            }
            if (v1541 < 0)
            {
              v57 = v1549 - v1546;
              v47 -= 16 * (v1546 - 1);
              v58 = v1547 - v1546;
              v26 += -v1546 + 1;
            }
            else
            {
              v57 = v1549 + v1546;
              v58 = v1547 + v1546;
            }
            v1522 = (char *)(v47 + 16 * ((v57 * ((int)v1552 - 1)) & (v57 >> 63)));
            if (v57 >= 0)
              v1523 = v57;
            else
              v1523 = -v57;
            if (v58 >= 0)
              LODWORD(v1524) = v58;
            else
              v1524 = -v58;
            v1549 = v1523;
            CGBlt_copyBytes(16 * v1546, v1552, v1522, (char *)&v26[(v58 * ((int)v1552 - 1)) & (v58 >> 63)], 16 * v1523, 16 * v1524);
            goto LABEL_1353;
          }
          v916 = v1552;
          v917 = 16 * v1541;
          if (v20 == 0 || v44)
          {
            do
            {
              v918 = v1546;
              do
              {
                *v26 = *(float32x4_t *)v47;
                v919 = v47 + 16 * v1541;
                if (v919 >= v22)
                  v920 = -(uint64_t)(int)v1545;
                else
                  v920 = 0;
                v47 = v919 + 16 * v920;
                v26 = (float32x4_t *)((char *)v26 + v917);
                --v918;
              }
              while (v918);
              v26 += v1547;
              v921 = v1550;
              v922 = v1550 + 16 * v1549;
              if (v922 >= v1548)
                v923 = -(uint64_t)(v1549 * v1542);
              else
                v923 = 0;
              v924 = v922 + 16 * v923;
              v925 = v22 + 16 * v923 + 16 * v1549;
              if (v1548)
              {
                v22 = v925;
                v921 = v924;
              }
              v1550 = v921;
              if (v1548)
                v47 = v924;
              else
                v47 += 16 * v1549;
              --v916;
            }
            while (v916);
          }
          else
          {
            do
            {
              v926 = v1546;
              do
              {
                v26->i64[0] = *(_QWORD *)v47;
                v26->i32[2] = *(_DWORD *)(v47 + 8);
                v26->i32[3] = 1065353216;
                v927 = v47 + 16 * v1541;
                if (v927 >= v22)
                  v928 = -(uint64_t)(int)v1545;
                else
                  v928 = 0;
                v47 = v927 + 16 * v928;
                v26 = (float32x4_t *)((char *)v26 + v917);
                --v926;
              }
              while (v926);
              v26 += v1547;
              v929 = v1550;
              v930 = v1550 + 16 * v1549;
              if (v930 >= v1548)
                v931 = -(uint64_t)(v1549 * v1542);
              else
                v931 = 0;
              v932 = v930 + 16 * v931;
              v933 = v22 + 16 * v931 + 16 * v1549;
              if (v1548)
              {
                v22 = v933;
                v929 = v932;
              }
              v1550 = v929;
              if (v1548)
                v47 = v932;
              else
                v47 += 16 * v1549;
              --v916;
            }
            while (v916);
          }
          goto LABEL_1352;
        case 2:
          if (v45)
          {
            v59 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v60 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V0.4S, #1.0 }
                v66 = v22;
                v67 = v1550;
                do
                {
                  v68 = (v66 - v47) >> 4;
                  if (v68 >= v1546)
                    v68 = v1546;
                  if (v68 < 2)
                  {
                    i = v68;
                  }
                  else
                  {
                    v69 = 0;
                    for (i = v68; i > 1; i -= 2)
                    {
                      v71 = (int8x16_t *)((char *)v26 + v69);
                      v72 = *(float32x4_t *)(v47 + v69);
                      v73 = *(float32x4_t *)(v47 + v69 + 16);
                      v74 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3);
                      v75 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3);
                      v76 = vbslq_s8((int8x16_t)vcgtzq_f32(v74), (int8x16_t)vaddq_f32(v73, vmlsq_f32(*(float32x4_t *)((char *)v26 + v69 + 16), vmaxnmq_f32(vminnmq_f32(v74, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)v26 + v69 + 16))), *(int8x16_t *)((char *)&v26[1] + v69));
                      *v71 = vbslq_s8((int8x16_t)vcgtzq_f32(v75), (int8x16_t)vaddq_f32(v72, vmlsq_f32(*(float32x4_t *)((char *)v26 + v69), vmaxnmq_f32(vminnmq_f32(v75, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)v26 + v69))), *(int8x16_t *)((char *)v26 + v69));
                      v71[1] = v76;
                      v69 += v60;
                    }
                    v47 += v69;
                    v26 = (float32x4_t *)((char *)v26 + v69);
                  }
                  for (j = i + v1546 - v68; j; --j)
                  {
                    v78 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v47, 3);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v78), (int8x16_t)vaddq_f32(*(float32x4_t *)v47, vmlsq_f32(*v26, vmaxnmq_f32(vminnmq_f32(v78, _Q0), (float32x4_t)0), *v26)), *(int8x16_t *)v26);
                    v79 = v47 + 16 * v1541;
                    if (v79 >= v66)
                      v80 = -(uint64_t)(int)v1545;
                    else
                      v80 = 0;
                    v47 = v79 + 16 * v80;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v81 = v67 + 16 * v1549;
                  if (v81 >= v1548)
                    v82 = -(uint64_t)(v1549 * v1542);
                  else
                    v82 = 0;
                  v83 = v81 + 16 * v82;
                  v84 = v66 + 16 * v82 + 16 * v1549;
                  if (v1548)
                    v47 = v83;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v66 = v84;
                    v67 = v83;
                  }
                  _VF = __OFSUB__(v59--, 1);
                }
                while (!((v59 < 0) ^ _VF | (v59 == 0)));
              }
              else
              {
                __asm { FMOV            V0.4S, #1.0 }
                v1016 = v22;
                v1017 = v1550;
                do
                {
                  v1018 = (v1016 - v47) >> 4;
                  if (v1018 >= v1546)
                    v1018 = v1546;
                  if (v1018 < 2)
                  {
                    k = v1018;
                  }
                  else
                  {
                    v1019 = 0;
                    for (k = v1018; k > 1; k -= 2)
                    {
                      v1021 = (int8x16_t *)((char *)v26 + v1019);
                      v1022 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1019 + 16));
                      v1023 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1019));
                      v1024 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1019));
                      v1025 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1023, 3);
                      v1026 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1019));
                      v1027 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1022, 3);
                      *v1021 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1025), (int8x16_t)vaddq_f32(vmlsq_f32(v1026, vmaxnmq_f32(vminnmq_f32(v1025, _Q0), (float32x4_t)0), v1026), v1023), (int8x16_t)v1026));
                      v1021[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1027), (int8x16_t)vaddq_f32(vmlsq_f32(v1024, vmaxnmq_f32(vminnmq_f32(v1027, _Q0), (float32x4_t)0), v1024), v1022), (int8x16_t)v1024));
                      v1019 += v60;
                    }
                    v47 += v1019;
                    v26 = (float32x4_t *)((char *)v26 + v1019);
                  }
                  for (m = k + v1546 - v1018; m; --m)
                  {
                    v1029 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    v1030 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    v1031 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1029, 3);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1031), (int8x16_t)vaddq_f32(vmlsq_f32(v1030, vmaxnmq_f32(vminnmq_f32(v1031, _Q0), (float32x4_t)0), v1030), v1029), (int8x16_t)v1030));
                    v1032 = v47 + 16 * v1541;
                    if (v1032 >= v1016)
                      v1033 = -(uint64_t)(int)v1545;
                    else
                      v1033 = 0;
                    v47 = v1032 + 16 * v1033;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1034 = v1017 + 16 * v1549;
                  if (v1034 >= v1548)
                    v1035 = -(uint64_t)(v1549 * v1542);
                  else
                    v1035 = 0;
                  v1036 = v1034 + 16 * v1035;
                  v1037 = v1016 + 16 * v1035 + 16 * v1549;
                  if (v1548)
                    v47 = v1036;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1016 = v1037;
                    v1017 = v1036;
                  }
                  _VF = __OFSUB__(v59--, 1);
                }
                while (!((v59 < 0) ^ _VF | (v59 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v59 = v1552;
          }
          do
          {
            v753 = v1546;
            do
            {
              v754 = *(float *)(v47 + 12);
              if (v754 >= 1.0)
              {
                v26->i64[0] = *(_QWORD *)v47;
                v26->i32[2] = *(_DWORD *)(v47 + 8);
                v26->f32[3] = v754;
              }
              else if (v754 > 0.0)
              {
                *v26 = vmlaq_n_f32(*(float32x4_t *)v47, *v26, 1.0 - v754);
              }
              v755 = v47 + 16 * v1541;
              if (v755 >= v22)
                v756 = -(uint64_t)(int)v1545;
              else
                v756 = 0;
              v47 = v755 + 16 * v756;
              v26 += v1541;
              --v753;
            }
            while (v753);
            v26 += v1547;
            v757 = v1550;
            v758 = v1550 + 16 * v1549;
            if (v758 >= v1548)
              v759 = -(uint64_t)(v1549 * v1542);
            else
              v759 = 0;
            v760 = v758 + 16 * v759;
            v761 = v22 + 16 * v759 + 16 * v1549;
            if (v1548)
            {
              v22 = v761;
              v757 = v760;
            }
            v1550 = v757;
            if (v1548)
              v47 = v760;
            else
              v47 += 16 * v1549;
            --v59;
          }
          while (v59);
          goto LABEL_1352;
        case 3:
          if (v45)
          {
            v85 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v86.i64[0] = 0;
              v86.i32[2] = 0;
              v86.i32[3] = v44 - 1;
              v87 = vmvnq_s8(v86);
              v88 = vandq_s8((int8x16_t)vdupq_n_s32(v44 - 1), (int8x16_t)xmmword_185004D50);
              v89 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V3.4S, #1.0 }
                v91 = v22;
                v92 = v1550;
                do
                {
                  v93 = (v91 - v47) >> 4;
                  if (v93 >= v1546)
                    v93 = v1546;
                  if (v93 < 2)
                  {
                    n = v93;
                  }
                  else
                  {
                    v94 = 0;
                    for (n = v93; n > 1; n -= 2)
                    {
                      v96 = (float32x4_t *)((char *)v26 + v94);
                      v97 = vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v26[1] + v94), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v94 + 16), v87), v88));
                      *v96 = vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)v26 + v94), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v94), v87), v88));
                      v96[1] = v97;
                      v94 += v89;
                    }
                    v47 += v94;
                    v26 = (float32x4_t *)((char *)v26 + v94);
                  }
                  for (ii = n + v1546 - v93; ii; --ii)
                  {
                    *v26 = vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v26, 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v87), v88));
                    v99 = v47 + 16 * v1541;
                    if (v99 >= v91)
                      v100 = -(uint64_t)(int)v1545;
                    else
                      v100 = 0;
                    v47 = v99 + 16 * v100;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v101 = v92 + 16 * v1549;
                  if (v101 >= v1548)
                    v102 = -(uint64_t)(v1549 * v1542);
                  else
                    v102 = 0;
                  v103 = v101 + 16 * v102;
                  v104 = v91 + 16 * v102 + 16 * v1549;
                  if (v1548)
                    v47 = v103;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v91 = v104;
                    v92 = v103;
                  }
                  _VF = __OFSUB__(v85--, 1);
                }
                while (!((v85 < 0) ^ _VF | (v85 == 0)));
              }
              else
              {
                __asm { FMOV            V3.4S, #1.0 }
                v1039 = v22;
                v1040 = v1550;
                do
                {
                  v1041 = (v1039 - v47) >> 4;
                  if (v1041 >= v1546)
                    v1041 = v1546;
                  if (v1041 < 2)
                  {
                    jj = v1041;
                  }
                  else
                  {
                    v1042 = 0;
                    for (jj = v1041; jj > 1; jj -= 2)
                    {
                      v1044 = (int8x16_t *)((char *)v26 + v1042);
                      v1045 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1042)), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1042 + 16)), v87), v88)));
                      *v1044 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1042)), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1042)), v87), v88)));
                      v1044[1] = v1045;
                      v1042 += v89;
                    }
                    v47 += v1042;
                    v26 = (float32x4_t *)((char *)v26 + v1042);
                  }
                  for (kk = jj + v1546 - v1041; kk; --kk)
                  {
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v26), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v87), v88)));
                    v1047 = v47 + 16 * v1541;
                    if (v1047 >= v1039)
                      v1048 = -(uint64_t)(int)v1545;
                    else
                      v1048 = 0;
                    v47 = v1047 + 16 * v1048;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1049 = v1040 + 16 * v1549;
                  if (v1049 >= v1548)
                    v1050 = -(uint64_t)(v1549 * v1542);
                  else
                    v1050 = 0;
                  v1051 = v1049 + 16 * v1050;
                  v1052 = v1039 + 16 * v1050 + 16 * v1549;
                  if (v1548)
                    v47 = v1051;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1039 = v1052;
                    v1040 = v1051;
                  }
                  _VF = __OFSUB__(v85--, 1);
                }
                while (!((v85 < 0) ^ _VF | (v85 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v85 = v1552;
          }
          do
          {
            v762 = v1546;
            do
            {
              v763 = v26->f32[3];
              if (v763 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else
              {
                v764 = *(float *)v47;
                if (v763 >= 1.0)
                {
                  v26->f32[0] = v764;
                  *(uint64_t *)((char *)v26->i64 + 4) = *(_QWORD *)(v47 + 4);
                  v766 = 1.0;
                  if (v44)
                    v766 = *(float *)(v47 + 12);
                }
                else
                {
                  v26->f32[0] = v763 * v764;
                  *(float32x2_t *)&v26->i32[1] = vmul_n_f32(*(float32x2_t *)(v47 + 4), v763);
                  v765 = 1.0;
                  if (v44)
                    v765 = *(float *)(v47 + 12);
                  v766 = v763 * v765;
                }
                v26->f32[3] = v766;
              }
              v767 = v47 + 16 * v1541;
              if (v767 >= v22)
                v768 = -(uint64_t)(int)v1545;
              else
                v768 = 0;
              v47 = v767 + 16 * v768;
              v26 += v1541;
              --v762;
            }
            while (v762);
            v26 += v1547;
            v769 = v1550;
            v770 = v1550 + 16 * v1549;
            if (v770 >= v1548)
              v771 = -(uint64_t)(v1549 * v1542);
            else
              v771 = 0;
            v772 = v770 + 16 * v771;
            v773 = v22 + 16 * v771 + 16 * v1549;
            if (v1548)
            {
              v22 = v773;
              v769 = v772;
            }
            v1550 = v769;
            if (v1548)
              v47 = v772;
            else
              v47 += 16 * v1549;
            --v85;
          }
          while (v85);
          goto LABEL_1352;
        case 4:
          if (v45)
          {
            v105 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v106 = 0;
              else
                v106 = -1;
              v107.i64[0] = 0;
              v107.i32[2] = 0;
              v107.i32[3] = v106;
              v108 = vmvnq_s8(v107);
              v109 = vandq_s8((int8x16_t)vdupq_n_s32(v106), (int8x16_t)xmmword_185004D50);
              v110 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V3.4S, #1.0 }
                v112 = v22;
                v113 = v1550;
                do
                {
                  v114 = (v112 - v47) >> 4;
                  if (v114 >= v1546)
                    v114 = v1546;
                  if (v114 < 2)
                  {
                    mm = v114;
                  }
                  else
                  {
                    v115 = 0;
                    for (mm = v114; mm > 1; mm -= 2)
                    {
                      v117 = (float32x4_t *)((char *)v26 + v115);
                      v118 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v115), v108), v109);
                      v119 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v115 + 16), v108), v109);
                      v120 = vmlsq_f32(v119, v119, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v26[1] + v115), 3), _Q3), (float32x4_t)0));
                      *v117 = vmlsq_f32(v118, v118, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)v26 + v115), 3), _Q3), (float32x4_t)0));
                      v117[1] = v120;
                      v115 += v110;
                    }
                    v47 += v115;
                    v26 = (float32x4_t *)((char *)v26 + v115);
                  }
                  for (nn = mm + v1546 - v114; nn; --nn)
                  {
                    v122 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v108), v109);
                    *v26 = vmlsq_f32(v122, v122, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v26, 3), _Q3), (float32x4_t)0));
                    v123 = v47 + 16 * v1541;
                    if (v123 >= v112)
                      v124 = -(uint64_t)(int)v1545;
                    else
                      v124 = 0;
                    v47 = v123 + 16 * v124;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v125 = v113 + 16 * v1549;
                  if (v125 >= v1548)
                    v126 = -(uint64_t)(v1549 * v1542);
                  else
                    v126 = 0;
                  v127 = v125 + 16 * v126;
                  v128 = v112 + 16 * v126 + 16 * v1549;
                  if (v1548)
                    v47 = v127;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v112 = v128;
                    v113 = v127;
                  }
                  _VF = __OFSUB__(v105--, 1);
                }
                while (!((v105 < 0) ^ _VF | (v105 == 0)));
              }
              else
              {
                __asm { FMOV            V3.4S, #1.0 }
                v1054 = v22;
                v1055 = v1550;
                do
                {
                  v1056 = (v1054 - v47) >> 4;
                  if (v1056 >= v1546)
                    v1056 = v1546;
                  if (v1056 < 2)
                  {
                    i1 = v1056;
                  }
                  else
                  {
                    v1057 = 0;
                    for (i1 = v1056; i1 > 1; i1 -= 2)
                    {
                      v1059 = (int8x16_t *)((char *)v26 + v1057);
                      v1060 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1057)), v108), v109);
                      v1061 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1057 + 16)), v108), v109);
                      v1062 = vrev32q_s8((int8x16_t)vmlsq_f32(v1061, v1061, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1057)), 3), _Q3), (float32x4_t)0)));
                      *v1059 = vrev32q_s8((int8x16_t)vmlsq_f32(v1060, v1060, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1057)), 3), _Q3), (float32x4_t)0)));
                      v1059[1] = v1062;
                      v1057 += v110;
                    }
                    v47 += v1057;
                    v26 = (float32x4_t *)((char *)v26 + v1057);
                  }
                  for (i2 = i1 + v1546 - v1056; i2; --i2)
                  {
                    v1064 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v108), v109);
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vmlsq_f32(v1064, v1064, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v26), 3), _Q3), (float32x4_t)0)));
                    v1065 = v47 + 16 * v1541;
                    if (v1065 >= v1054)
                      v1066 = -(uint64_t)(int)v1545;
                    else
                      v1066 = 0;
                    v47 = v1065 + 16 * v1066;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1067 = v1055 + 16 * v1549;
                  if (v1067 >= v1548)
                    v1068 = -(uint64_t)(v1549 * v1542);
                  else
                    v1068 = 0;
                  v1069 = v1067 + 16 * v1068;
                  v1070 = v1054 + 16 * v1068 + 16 * v1549;
                  if (v1548)
                    v47 = v1069;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1054 = v1070;
                    v1055 = v1069;
                  }
                  _VF = __OFSUB__(v105--, 1);
                }
                while (!((v105 < 0) ^ _VF | (v105 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v105 = v1552;
          }
          do
          {
            v774 = v1546;
            do
            {
              v775 = 1.0 - v26->f32[3];
              if (v775 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else
              {
                v776 = *(float *)v47;
                if (v775 >= 1.0)
                {
                  v26->f32[0] = v776;
                  *(uint64_t *)((char *)v26->i64 + 4) = *(_QWORD *)(v47 + 4);
                  v778 = 1.0;
                  if (v44)
                    v778 = *(float *)(v47 + 12);
                }
                else
                {
                  v26->f32[0] = v775 * v776;
                  *(float32x2_t *)&v26->i32[1] = vmul_n_f32(*(float32x2_t *)(v47 + 4), v775);
                  v777 = 1.0;
                  if (v44)
                    v777 = *(float *)(v47 + 12);
                  v778 = v775 * v777;
                }
                v26->f32[3] = v778;
              }
              v779 = v47 + 16 * v1541;
              if (v779 >= v22)
                v780 = -(uint64_t)(int)v1545;
              else
                v780 = 0;
              v47 = v779 + 16 * v780;
              v26 += v1541;
              --v774;
            }
            while (v774);
            v26 += v1547;
            v781 = v1550;
            v782 = v1550 + 16 * v1549;
            if (v782 >= v1548)
              v783 = -(uint64_t)(v1549 * v1542);
            else
              v783 = 0;
            v784 = v782 + 16 * v783;
            v785 = v22 + 16 * v783 + 16 * v1549;
            if (v1548)
            {
              v22 = v785;
              v781 = v784;
            }
            v1550 = v781;
            if (v1548)
              v47 = v784;
            else
              v47 += 16 * v1549;
            --v105;
          }
          while (v105);
          goto LABEL_1352;
        case 5:
          if (v45)
          {
            v129 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v130 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v131 = v22;
                v132 = v1550;
                do
                {
                  v133 = (v131 - v47) >> 4;
                  if (v133 >= v1546)
                    v133 = v1546;
                  if (v133 < 2)
                  {
                    i3 = v133;
                  }
                  else
                  {
                    v134 = 0;
                    for (i3 = v133; i3 > 1; i3 -= 2)
                    {
                      v136 = (float32x4_t *)((char *)v26 + v134);
                      v137 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)v26 + v134 + 16), *(float32x4_t *)((char *)v26 + v134 + 16), *(float32x4_t *)(v47 + v134 + 16), 3), *(float32x4_t *)(v47 + v134 + 16), *(float32x4_t *)((char *)v26 + v134 + 16), 3);
                      *v136 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)v26 + v134), *(float32x4_t *)((char *)v26 + v134), *(float32x4_t *)(v47 + v134), 3), *(float32x4_t *)(v47 + v134), *(float32x4_t *)((char *)v26 + v134), 3);
                      v136[1] = v137;
                      v134 += v130;
                    }
                    v47 += v134;
                    v26 = (float32x4_t *)((char *)v26 + v134);
                  }
                  for (i4 = i3 + v1546 - v133; i4; --i4)
                  {
                    *v26 = vmlaq_laneq_f32(vmlsq_laneq_f32(*v26, *v26, *(float32x4_t *)v47, 3), *(float32x4_t *)v47, *v26, 3);
                    v139 = v47 + 16 * v1541;
                    if (v139 >= v131)
                      v140 = -(uint64_t)(int)v1545;
                    else
                      v140 = 0;
                    v47 = v139 + 16 * v140;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v141 = v132 + 16 * v1549;
                  if (v141 >= v1548)
                    v142 = -(uint64_t)(v1549 * v1542);
                  else
                    v142 = 0;
                  v143 = v141 + 16 * v142;
                  v144 = v131 + 16 * v142 + 16 * v1549;
                  if (v1548)
                    v47 = v143;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v131 = v144;
                    v132 = v143;
                  }
                  _VF = __OFSUB__(v129--, 1);
                }
                while (!((v129 < 0) ^ _VF | (v129 == 0)));
              }
              else
              {
                v1071 = v22;
                v1072 = v1550;
                do
                {
                  v1073 = (v1071 - v47) >> 4;
                  if (v1073 >= v1546)
                    v1073 = v1546;
                  if (v1073 < 2)
                  {
                    i5 = v1073;
                  }
                  else
                  {
                    v1074 = 0;
                    for (i5 = v1073; i5 > 1; i5 -= 2)
                    {
                      v1076 = (int8x16_t *)((char *)v26 + v1074);
                      v1077 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1074 + 16));
                      v1078 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1074));
                      v1079 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1074));
                      v1080 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1074));
                      *v1076 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1080, v1080, v1078, 3), v1078, v1080, 3));
                      v1076[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1079, v1079, v1077, 3), v1077, v1079, 3));
                      v1074 += v130;
                    }
                    v47 += v1074;
                    v26 = (float32x4_t *)((char *)v26 + v1074);
                  }
                  for (i6 = i5 + v1546 - v1073; i6; --i6)
                  {
                    v1082 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    v1083 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1083, v1083, v1082, 3), v1082, v1083, 3));
                    v1084 = v47 + 16 * v1541;
                    if (v1084 >= v1071)
                      v1085 = -(uint64_t)(int)v1545;
                    else
                      v1085 = 0;
                    v47 = v1084 + 16 * v1085;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1086 = v1072 + 16 * v1549;
                  if (v1086 >= v1548)
                    v1087 = -(uint64_t)(v1549 * v1542);
                  else
                    v1087 = 0;
                  v1088 = v1086 + 16 * v1087;
                  v1089 = v1071 + 16 * v1087 + 16 * v1549;
                  if (v1548)
                    v47 = v1088;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1071 = v1089;
                    v1072 = v1088;
                  }
                  _VF = __OFSUB__(v129--, 1);
                }
                while (!((v129 < 0) ^ _VF | (v129 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v129 = v1552;
          }
          do
          {
            v786 = v1546;
            do
            {
              *v26 = vmlaq_laneq_f32(vmulq_n_f32(*v26, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v47))), *(float32x4_t *)v47, *v26, 3);
              v787 = v47 + 16 * v1541;
              if (v787 >= v22)
                v788 = -(uint64_t)(int)v1545;
              else
                v788 = 0;
              v47 = v787 + 16 * v788;
              v26 += v1541;
              --v786;
            }
            while (v786);
            v26 += v1547;
            v789 = v1550;
            v790 = v1550 + 16 * v1549;
            if (v790 >= v1548)
              v791 = -(uint64_t)(v1549 * v1542);
            else
              v791 = 0;
            v792 = v790 + 16 * v791;
            v793 = v22 + 16 * v791 + 16 * v1549;
            if (v1548)
            {
              v22 = v793;
              v789 = v792;
            }
            v1550 = v789;
            if (v1548)
              v47 = v792;
            else
              v47 += 16 * v1549;
            --v129;
          }
          while (v129);
          goto LABEL_1352;
        case 6:
          if (v45)
          {
            v145 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v146 = 0;
              else
                v146 = -1;
              v147.i64[0] = 0;
              v147.i32[2] = 0;
              v147.i32[3] = v146;
              v148 = vmvnq_s8(v147);
              v149 = vandq_s8((int8x16_t)vdupq_n_s32(v146), (int8x16_t)xmmword_185004D50);
              v150 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V3.4S, #1.0 }
                v152 = v22;
                v153 = v1550;
                do
                {
                  v154 = (v152 - v47) >> 4;
                  if (v154 >= v1546)
                    v154 = v1546;
                  if (v154 < 2)
                  {
                    i7 = v154;
                  }
                  else
                  {
                    v155 = 0;
                    for (i7 = v154; i7 > 1; i7 -= 2)
                    {
                      v157 = (int8x16_t *)((char *)v26 + v155);
                      v158 = *(float32x4_t *)((char *)v26 + v155);
                      v159 = *(float32x4_t *)((char *)v26 + v155 + 16);
                      v160 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v159, 3);
                      v161 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v158, 3);
                      v162 = (int8x16_t)vcgtzq_f32(v161);
                      v163 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v155), v148), v149);
                      v164 = vmlsq_f32(v163, vmaxnmq_f32(vminnmq_f32(v161, _Q3), (float32x4_t)0), v163);
                      v165 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v155 + 16), v148), v149);
                      *v157 = vbslq_s8(v162, (int8x16_t)vaddq_f32(v158, v164), (int8x16_t)v163);
                      v157[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v160), (int8x16_t)vaddq_f32(v159, vmlsq_f32(v165, vmaxnmq_f32(vminnmq_f32(v160, _Q3), (float32x4_t)0), v165)), (int8x16_t)v165);
                      v155 += v150;
                    }
                    v47 += v155;
                    v26 = (float32x4_t *)((char *)v26 + v155);
                  }
                  for (i8 = i7 + v1546 - v154; i8; --i8)
                  {
                    v167 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v148), v149);
                    v168 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v26, 3);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v168), (int8x16_t)vaddq_f32(*v26, vmlsq_f32(v167, vmaxnmq_f32(vminnmq_f32(v168, _Q3), (float32x4_t)0), v167)), (int8x16_t)v167);
                    v169 = v47 + 16 * v1541;
                    if (v169 >= v152)
                      v170 = -(uint64_t)(int)v1545;
                    else
                      v170 = 0;
                    v47 = v169 + 16 * v170;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v171 = v153 + 16 * v1549;
                  if (v171 >= v1548)
                    v172 = -(uint64_t)(v1549 * v1542);
                  else
                    v172 = 0;
                  v173 = v171 + 16 * v172;
                  v174 = v152 + 16 * v172 + 16 * v1549;
                  if (v1548)
                    v47 = v173;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v152 = v174;
                    v153 = v173;
                  }
                  _VF = __OFSUB__(v145--, 1);
                }
                while (!((v145 < 0) ^ _VF | (v145 == 0)));
              }
              else
              {
                __asm { FMOV            V3.4S, #1.0 }
                v1091 = v22;
                v1092 = v1550;
                do
                {
                  v1093 = (v1091 - v47) >> 4;
                  if (v1093 >= v1546)
                    v1093 = v1546;
                  if (v1093 < 2)
                  {
                    i9 = v1093;
                  }
                  else
                  {
                    v1094 = 0;
                    for (i9 = v1093; i9 > 1; i9 -= 2)
                    {
                      v1096 = (int8x16_t *)((char *)v26 + v1094);
                      v1097 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1094));
                      v1098 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1094));
                      v1099 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1098, 3);
                      v1100 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1097, 3);
                      v1101 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1094)), v148), v149);
                      v1102 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1094 + 16)), v148), v149);
                      *v1096 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1099), (int8x16_t)vaddq_f32(vmlsq_f32(v1101, vmaxnmq_f32(vminnmq_f32(v1099, _Q3), (float32x4_t)0), v1101), v1098), (int8x16_t)v1101));
                      v1096[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1100), (int8x16_t)vaddq_f32(vmlsq_f32(v1102, vmaxnmq_f32(vminnmq_f32(v1100, _Q3), (float32x4_t)0), v1102), v1097), (int8x16_t)v1102));
                      v1094 += v150;
                    }
                    v47 += v1094;
                    v26 = (float32x4_t *)((char *)v26 + v1094);
                  }
                  for (i10 = i9 + v1546 - v1093; i10; --i10)
                  {
                    v1104 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    v1105 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v148), v149);
                    v1106 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1104, 3);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1106), (int8x16_t)vaddq_f32(vmlsq_f32(v1105, vmaxnmq_f32(vminnmq_f32(v1106, _Q3), (float32x4_t)0), v1105), v1104), (int8x16_t)v1105));
                    v1107 = v47 + 16 * v1541;
                    if (v1107 >= v1091)
                      v1108 = -(uint64_t)(int)v1545;
                    else
                      v1108 = 0;
                    v47 = v1107 + 16 * v1108;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1109 = v1092 + 16 * v1549;
                  if (v1109 >= v1548)
                    v1110 = -(uint64_t)(v1549 * v1542);
                  else
                    v1110 = 0;
                  v1111 = v1109 + 16 * v1110;
                  v1112 = v1091 + 16 * v1110 + 16 * v1549;
                  if (v1548)
                    v47 = v1111;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1091 = v1112;
                    v1092 = v1111;
                  }
                  _VF = __OFSUB__(v145--, 1);
                }
                while (!((v145 < 0) ^ _VF | (v145 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v145 = v1552;
          }
          while (1)
          {
            v794 = v1546;
            do
            {
              v795 = v26->f32[3];
              v796 = 1.0 - v795;
              if ((float)(1.0 - v795) >= 1.0)
              {
                v26->i64[0] = *(_QWORD *)v47;
                v26->i32[2] = *(_DWORD *)(v47 + 8);
                v798 = 1.0;
                if (v44)
                  v798 = *(float *)(v47 + 12);
              }
              else
              {
                if (v796 <= 0.0)
                  goto LABEL_906;
                *(float32x2_t *)v26->f32 = vmla_n_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47, v796);
                v26->f32[2] = v26->f32[2] + (float)(*(float *)(v47 + 8) * v796);
                v797 = 1.0;
                if (v44)
                  v797 = *(float *)(v47 + 12);
                v798 = v795 + (float)(v797 * v796);
              }
              v26->f32[3] = v798;
LABEL_906:
              v799 = v47 + 16 * v1541;
              if (v799 >= v22)
                v800 = -(uint64_t)(int)v1545;
              else
                v800 = 0;
              v47 = v799 + 16 * v800;
              v26 += v1541;
              --v794;
            }
            while (v794);
            v26 += v1547;
            v801 = v1550;
            v802 = v1550 + 16 * v1549;
            if (v802 >= v1548)
              v803 = -(uint64_t)(v1549 * v1542);
            else
              v803 = 0;
            v804 = v802 + 16 * v803;
            v805 = v22 + 16 * v803 + 16 * v1549;
            if (v1548)
            {
              v22 = v805;
              v801 = v804;
            }
            v1550 = v801;
            if (v1548)
              v47 = v804;
            else
              v47 += 16 * v1549;
            if (!--v145)
            {
LABEL_1352:
              v1552 = 0;
              goto LABEL_1353;
            }
          }
        case 7:
          if (v45)
          {
            v175 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v176 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V0.4S, #1.0 }
                v178 = v22;
                v179 = v1550;
                do
                {
                  v180 = (v178 - v47) >> 4;
                  if (v180 >= v1546)
                    v180 = v1546;
                  if (v180 < 2)
                  {
                    i11 = v180;
                  }
                  else
                  {
                    v181 = 0;
                    for (i11 = v180; i11 > 1; i11 -= 2)
                    {
                      v183 = (float32x4_t *)((char *)v26 + v181);
                      v184 = vmulq_f32(*(float32x4_t *)((char *)v26 + v181 + 16), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v181 + 16), 3), _Q0), (float32x4_t)0));
                      *v183 = vmulq_f32(*(float32x4_t *)((char *)v26 + v181), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v181), 3), _Q0), (float32x4_t)0));
                      v183[1] = v184;
                      v181 += v176;
                    }
                    v47 += v181;
                    v26 = (float32x4_t *)((char *)v26 + v181);
                  }
                  for (i12 = i11 + v1546 - v180; i12; --i12)
                  {
                    *v26 = vmulq_f32(*v26, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v47, 3), _Q0), (float32x4_t)0));
                    v186 = v47 + 16 * v1541;
                    if (v186 >= v178)
                      v187 = -(uint64_t)(int)v1545;
                    else
                      v187 = 0;
                    v47 = v186 + 16 * v187;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v188 = v179 + 16 * v1549;
                  if (v188 >= v1548)
                    v189 = -(uint64_t)(v1549 * v1542);
                  else
                    v189 = 0;
                  v190 = v188 + 16 * v189;
                  v191 = v178 + 16 * v189 + 16 * v1549;
                  if (v1548)
                    v47 = v190;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v178 = v191;
                    v179 = v190;
                  }
                  _VF = __OFSUB__(v175--, 1);
                }
                while (!((v175 < 0) ^ _VF | (v175 == 0)));
              }
              else
              {
                __asm { FMOV            V0.4S, #1.0 }
                v1114 = v22;
                v1115 = v1550;
                do
                {
                  v1116 = (v1114 - v47) >> 4;
                  if (v1116 >= v1546)
                    v1116 = v1546;
                  if (v1116 < 2)
                  {
                    i13 = v1116;
                  }
                  else
                  {
                    v1117 = 0;
                    for (i13 = v1116; i13 > 1; i13 -= 2)
                    {
                      v1119 = (int8x16_t *)((char *)v26 + v1117);
                      v1120 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1117 + 16)), 3), _Q0), (float32x4_t)0), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1117))));
                      *v1119 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1117)), 3), _Q0), (float32x4_t)0), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1117))));
                      v1119[1] = v1120;
                      v1117 += v176;
                    }
                    v47 += v1117;
                    v26 = (float32x4_t *)((char *)v26 + v1117);
                  }
                  for (i14 = i13 + v1546 - v1116; i14; --i14)
                  {
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v47), 3), _Q0), (float32x4_t)0), (float32x4_t)vrev32q_s8(*(int8x16_t *)v26)));
                    v1122 = v47 + 16 * v1541;
                    if (v1122 >= v1114)
                      v1123 = -(uint64_t)(int)v1545;
                    else
                      v1123 = 0;
                    v47 = v1122 + 16 * v1123;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1124 = v1115 + 16 * v1549;
                  if (v1124 >= v1548)
                    v1125 = -(uint64_t)(v1549 * v1542);
                  else
                    v1125 = 0;
                  v1126 = v1124 + 16 * v1125;
                  v1127 = v1114 + 16 * v1125 + 16 * v1549;
                  if (v1548)
                    v47 = v1126;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1114 = v1127;
                    v1115 = v1126;
                  }
                  _VF = __OFSUB__(v175--, 1);
                }
                while (!((v175 < 0) ^ _VF | (v175 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v175 = v1552;
          }
          do
          {
            v806 = v1546;
            do
            {
              v807 = *(float *)(v47 + 12);
              if (v807 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else if (v807 < 1.0)
              {
                *v26 = vmulq_n_f32(*v26, v807);
              }
              v808 = v47 + 16 * v1541;
              if (v808 >= v22)
                v809 = -(uint64_t)(int)v1545;
              else
                v809 = 0;
              v47 = v808 + 16 * v809;
              v26 += v1541;
              --v806;
            }
            while (v806);
            v26 += v1547;
            v810 = v1550;
            v811 = v1550 + 16 * v1549;
            if (v811 >= v1548)
              v812 = -(uint64_t)(v1549 * v1542);
            else
              v812 = 0;
            v813 = v811 + 16 * v812;
            v814 = v22 + 16 * v812 + 16 * v1549;
            if (v1548)
            {
              v22 = v814;
              v810 = v813;
            }
            v1550 = v810;
            if (v1548)
              v47 = v813;
            else
              v47 += 16 * v1549;
            --v175;
          }
          while (v175);
          goto LABEL_1352;
        case 8:
          if (v45)
          {
            v192 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v193 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V0.4S, #1.0 }
                v195 = v22;
                v196 = v1550;
                do
                {
                  v197 = (v195 - v47) >> 4;
                  if (v197 >= v1546)
                    v197 = v1546;
                  if (v197 < 2)
                  {
                    i15 = v197;
                  }
                  else
                  {
                    v198 = 0;
                    for (i15 = v197; i15 > 1; i15 -= 2)
                    {
                      v200 = (float32x4_t *)((char *)v26 + v198);
                      v201 = vmlsq_f32(*(float32x4_t *)((char *)v26 + v198 + 16), *(float32x4_t *)((char *)v26 + v198 + 16), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v198 + 16), 3), _Q0), (float32x4_t)0));
                      *v200 = vmlsq_f32(*(float32x4_t *)((char *)v26 + v198), *(float32x4_t *)((char *)v26 + v198), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v198), 3), _Q0), (float32x4_t)0));
                      v200[1] = v201;
                      v198 += v193;
                    }
                    v47 += v198;
                    v26 = (float32x4_t *)((char *)v26 + v198);
                  }
                  for (i16 = i15 + v1546 - v197; i16; --i16)
                  {
                    *v26 = vmlsq_f32(*v26, *v26, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v47, 3), _Q0), (float32x4_t)0));
                    v203 = v47 + 16 * v1541;
                    if (v203 >= v195)
                      v204 = -(uint64_t)(int)v1545;
                    else
                      v204 = 0;
                    v47 = v203 + 16 * v204;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v205 = v196 + 16 * v1549;
                  if (v205 >= v1548)
                    v206 = -(uint64_t)(v1549 * v1542);
                  else
                    v206 = 0;
                  v207 = v205 + 16 * v206;
                  v208 = v195 + 16 * v206 + 16 * v1549;
                  if (v1548)
                    v47 = v207;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v195 = v208;
                    v196 = v207;
                  }
                  _VF = __OFSUB__(v192--, 1);
                }
                while (!((v192 < 0) ^ _VF | (v192 == 0)));
              }
              else
              {
                __asm { FMOV            V0.4S, #1.0 }
                v1129 = v22;
                v1130 = v1550;
                do
                {
                  v1131 = (v1129 - v47) >> 4;
                  if (v1131 >= v1546)
                    v1131 = v1546;
                  if (v1131 < 2)
                  {
                    i17 = v1131;
                  }
                  else
                  {
                    v1132 = 0;
                    for (i17 = v1131; i17 > 1; i17 -= 2)
                    {
                      v1134 = (int8x16_t *)((char *)v26 + v1132);
                      v1135 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1132));
                      v1136 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1132));
                      v1137 = vrev32q_s8((int8x16_t)vmlsq_f32(v1135, v1135, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1132 + 16)), 3), _Q0), (float32x4_t)0)));
                      *v1134 = vrev32q_s8((int8x16_t)vmlsq_f32(v1136, v1136, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1132)), 3), _Q0), (float32x4_t)0)));
                      v1134[1] = v1137;
                      v1132 += v193;
                    }
                    v47 += v1132;
                    v26 = (float32x4_t *)((char *)v26 + v1132);
                  }
                  for (i18 = i17 + v1546 - v1131; i18; --i18)
                  {
                    v1139 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vmlsq_f32(v1139, v1139, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v47), 3), _Q0), (float32x4_t)0)));
                    v1140 = v47 + 16 * v1541;
                    if (v1140 >= v1129)
                      v1141 = -(uint64_t)(int)v1545;
                    else
                      v1141 = 0;
                    v47 = v1140 + 16 * v1141;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1142 = v1130 + 16 * v1549;
                  if (v1142 >= v1548)
                    v1143 = -(uint64_t)(v1549 * v1542);
                  else
                    v1143 = 0;
                  v1144 = v1142 + 16 * v1143;
                  v1145 = v1129 + 16 * v1143 + 16 * v1549;
                  if (v1548)
                    v47 = v1144;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1129 = v1145;
                    v1130 = v1144;
                  }
                  _VF = __OFSUB__(v192--, 1);
                }
                while (!((v192 < 0) ^ _VF | (v192 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v192 = v1552;
          }
          do
          {
            v815 = v1546;
            do
            {
              v816 = 1.0 - *(float *)(v47 + 12);
              if (v816 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else if (v816 < 1.0)
              {
                *v26 = vmulq_n_f32(*v26, v816);
              }
              v817 = v47 + 16 * v1541;
              if (v817 >= v22)
                v818 = -(uint64_t)(int)v1545;
              else
                v818 = 0;
              v47 = v817 + 16 * v818;
              v26 += v1541;
              --v815;
            }
            while (v815);
            v26 += v1547;
            v819 = v1550;
            v820 = v1550 + 16 * v1549;
            if (v820 >= v1548)
              v821 = -(uint64_t)(v1549 * v1542);
            else
              v821 = 0;
            v822 = v820 + 16 * v821;
            v823 = v22 + 16 * v821 + 16 * v1549;
            if (v1548)
            {
              v22 = v823;
              v819 = v822;
            }
            v1550 = v819;
            if (v1548)
              v47 = v822;
            else
              v47 += 16 * v1549;
            --v192;
          }
          while (v192);
          goto LABEL_1352;
        case 9:
          if (v45)
          {
            v209 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v210 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v211 = v22;
                v212 = v1550;
                do
                {
                  v213 = (v211 - v47) >> 4;
                  if (v213 >= v1546)
                    v213 = v1546;
                  if (v213 < 2)
                  {
                    i19 = v213;
                  }
                  else
                  {
                    v214 = 0;
                    for (i19 = v213; i19 > 1; i19 -= 2)
                    {
                      v216 = (float32x4_t *)((char *)v26 + v214);
                      v217 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)(v47 + v214 + 16), *(float32x4_t *)(v47 + v214 + 16), *(float32x4_t *)((char *)v26 + v214 + 16), 3), *(float32x4_t *)((char *)v26 + v214 + 16), *(float32x4_t *)(v47 + v214 + 16), 3);
                      *v216 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)(v47 + v214), *(float32x4_t *)(v47 + v214), *(float32x4_t *)((char *)v26 + v214), 3), *(float32x4_t *)((char *)v26 + v214), *(float32x4_t *)(v47 + v214), 3);
                      v216[1] = v217;
                      v214 += v210;
                    }
                    v47 += v214;
                    v26 = (float32x4_t *)((char *)v26 + v214);
                  }
                  for (i20 = i19 + v1546 - v213; i20; --i20)
                  {
                    *v26 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)v47, *(float32x4_t *)v47, *v26, 3), *v26, *(float32x4_t *)v47, 3);
                    v219 = v47 + 16 * v1541;
                    if (v219 >= v211)
                      v220 = -(uint64_t)(int)v1545;
                    else
                      v220 = 0;
                    v47 = v219 + 16 * v220;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v221 = v212 + 16 * v1549;
                  if (v221 >= v1548)
                    v222 = -(uint64_t)(v1549 * v1542);
                  else
                    v222 = 0;
                  v223 = v221 + 16 * v222;
                  v224 = v211 + 16 * v222 + 16 * v1549;
                  if (v1548)
                    v47 = v223;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v211 = v224;
                    v212 = v223;
                  }
                  _VF = __OFSUB__(v209--, 1);
                }
                while (!((v209 < 0) ^ _VF | (v209 == 0)));
              }
              else
              {
                v1146 = v22;
                v1147 = v1550;
                do
                {
                  v1148 = (v1146 - v47) >> 4;
                  if (v1148 >= v1546)
                    v1148 = v1546;
                  if (v1148 < 2)
                  {
                    i21 = v1148;
                  }
                  else
                  {
                    v1149 = 0;
                    for (i21 = v1148; i21 > 1; i21 -= 2)
                    {
                      v1151 = (int8x16_t *)((char *)v26 + v1149);
                      v1152 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1149 + 16));
                      v1153 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1149));
                      v1154 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1149));
                      v1155 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1149));
                      *v1151 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1153, v1153, v1155, 3), v1155, v1153, 3));
                      v1151[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1152, v1152, v1154, 3), v1154, v1152, 3));
                      v1149 += v210;
                    }
                    v47 += v1149;
                    v26 = (float32x4_t *)((char *)v26 + v1149);
                  }
                  for (i22 = i21 + v1546 - v1148; i22; --i22)
                  {
                    v1157 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    v1158 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1157, v1157, v1158, 3), v1158, v1157, 3));
                    v1159 = v47 + 16 * v1541;
                    if (v1159 >= v1146)
                      v1160 = -(uint64_t)(int)v1545;
                    else
                      v1160 = 0;
                    v47 = v1159 + 16 * v1160;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1161 = v1147 + 16 * v1549;
                  if (v1161 >= v1548)
                    v1162 = -(uint64_t)(v1549 * v1542);
                  else
                    v1162 = 0;
                  v1163 = v1161 + 16 * v1162;
                  v1164 = v1146 + 16 * v1162 + 16 * v1549;
                  if (v1548)
                    v47 = v1163;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1146 = v1164;
                    v1147 = v1163;
                  }
                  _VF = __OFSUB__(v209--, 1);
                }
                while (!((v209 < 0) ^ _VF | (v209 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v209 = v1552;
          }
          do
          {
            v824 = v1546;
            do
            {
              *v26 = vmlaq_n_f32(vmulq_laneq_f32(*v26, *(float32x4_t *)v47, 3), *(float32x4_t *)v47, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v26)));
              v825 = v47 + 16 * v1541;
              if (v825 >= v22)
                v826 = -(uint64_t)(int)v1545;
              else
                v826 = 0;
              v47 = v825 + 16 * v826;
              v26 += v1541;
              --v824;
            }
            while (v824);
            v26 += v1547;
            v827 = v1550;
            v828 = v1550 + 16 * v1549;
            if (v828 >= v1548)
              v829 = -(uint64_t)(v1549 * v1542);
            else
              v829 = 0;
            v830 = v828 + 16 * v829;
            v831 = v22 + 16 * v829 + 16 * v1549;
            if (v1548)
            {
              v22 = v831;
              v827 = v830;
            }
            v1550 = v827;
            if (v1548)
              v47 = v830;
            else
              v47 += 16 * v1549;
            --v209;
          }
          while (v209);
          goto LABEL_1352;
        case 10:
          if (v45)
          {
            v225 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v226 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v227 = v22;
                v228 = v1550;
                do
                {
                  v229 = (v227 - v47) >> 4;
                  if (v229 >= v1546)
                    v229 = v1546;
                  if (v229 < 2)
                  {
                    i23 = v229;
                  }
                  else
                  {
                    v230 = 0;
                    for (i23 = v229; i23 > 1; i23 -= 2)
                    {
                      v232 = (float32x4_t *)((char *)v26 + v230);
                      v233 = *(float32x4_t *)(v47 + v230 + 16);
                      v234 = *(float32x4_t *)((char *)v26 + v230 + 16);
                      *v232 = vaddq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)v26 + v230), *(float32x4_t *)((char *)v26 + v230), *(float32x4_t *)(v47 + v230), 3), vmlsq_laneq_f32(*(float32x4_t *)(v47 + v230), *(float32x4_t *)(v47 + v230), *(float32x4_t *)((char *)v26 + v230), 3));
                      v232[1] = vaddq_f32(vmlsq_laneq_f32(v234, v234, v233, 3), vmlsq_laneq_f32(v233, v233, v234, 3));
                      v230 += v226;
                    }
                    v47 += v230;
                    v26 = (float32x4_t *)((char *)v26 + v230);
                  }
                  for (i24 = i23 + v1546 - v229; i24; --i24)
                  {
                    *v26 = vaddq_f32(vmlsq_laneq_f32(*v26, *v26, *(float32x4_t *)v47, 3), vmlsq_laneq_f32(*(float32x4_t *)v47, *(float32x4_t *)v47, *v26, 3));
                    v236 = v47 + 16 * v1541;
                    if (v236 >= v227)
                      v237 = -(uint64_t)(int)v1545;
                    else
                      v237 = 0;
                    v47 = v236 + 16 * v237;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v238 = v228 + 16 * v1549;
                  if (v238 >= v1548)
                    v239 = -(uint64_t)(v1549 * v1542);
                  else
                    v239 = 0;
                  v240 = v238 + 16 * v239;
                  v241 = v227 + 16 * v239 + 16 * v1549;
                  if (v1548)
                    v47 = v240;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v227 = v241;
                    v228 = v240;
                  }
                  _VF = __OFSUB__(v225--, 1);
                }
                while (!((v225 < 0) ^ _VF | (v225 == 0)));
              }
              else
              {
                v1165 = v22;
                v1166 = v1550;
                do
                {
                  v1167 = (v1165 - v47) >> 4;
                  if (v1167 >= v1546)
                    v1167 = v1546;
                  if (v1167 < 2)
                  {
                    i25 = v1167;
                  }
                  else
                  {
                    v1168 = 0;
                    for (i25 = v1167; i25 > 1; i25 -= 2)
                    {
                      v1170 = (int8x16_t *)((char *)v26 + v1168);
                      v1171 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1168 + 16));
                      v1172 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1168));
                      v1173 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1168));
                      v1174 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1168));
                      *v1170 = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1174, v1174, v1172, 3), vmlsq_laneq_f32(v1172, v1172, v1174, 3)));
                      v1170[1] = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1173, v1173, v1171, 3), vmlsq_laneq_f32(v1171, v1171, v1173, 3)));
                      v1168 += v226;
                    }
                    v47 += v1168;
                    v26 = (float32x4_t *)((char *)v26 + v1168);
                  }
                  for (i26 = i25 + v1546 - v1167; i26; --i26)
                  {
                    v1176 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    v1177 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1177, v1177, v1176, 3), vmlsq_laneq_f32(v1176, v1176, v1177, 3)));
                    v1178 = v47 + 16 * v1541;
                    if (v1178 >= v1165)
                      v1179 = -(uint64_t)(int)v1545;
                    else
                      v1179 = 0;
                    v47 = v1178 + 16 * v1179;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1180 = v1166 + 16 * v1549;
                  if (v1180 >= v1548)
                    v1181 = -(uint64_t)(v1549 * v1542);
                  else
                    v1181 = 0;
                  v1182 = v1180 + 16 * v1181;
                  v1183 = v1165 + 16 * v1181 + 16 * v1549;
                  if (v1548)
                    v47 = v1182;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1165 = v1183;
                    v1166 = v1182;
                  }
                  _VF = __OFSUB__(v225--, 1);
                }
                while (!((v225 < 0) ^ _VF | (v225 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v225 = v1552;
          }
          do
          {
            v832 = v1546;
            do
            {
              *v26 = vmlaq_n_f32(vmulq_n_f32(*v26, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v47))), *(float32x4_t *)v47, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v26)));
              v833 = v47 + 16 * v1541;
              if (v833 >= v22)
                v834 = -(uint64_t)(int)v1545;
              else
                v834 = 0;
              v47 = v833 + 16 * v834;
              v26 += v1541;
              --v832;
            }
            while (v832);
            v26 += v1547;
            v835 = v1550;
            v836 = v1550 + 16 * v1549;
            if (v836 >= v1548)
              v837 = -(uint64_t)(v1549 * v1542);
            else
              v837 = 0;
            v838 = v836 + 16 * v837;
            v839 = v22 + 16 * v837 + 16 * v1549;
            if (v1548)
            {
              v22 = v839;
              v835 = v838;
            }
            v1550 = v835;
            if (v1548)
              v47 = v838;
            else
              v47 += 16 * v1549;
            --v225;
          }
          while (v225);
          goto LABEL_1352;
        case 11:
          if (v45)
          {
            v242 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v243 = 0;
              else
                v243 = -1;
              v244.i64[0] = 0;
              v244.i32[2] = 0;
              v245.i64[0] = 0;
              v245.i32[2] = 0;
              v245.i32[3] = v243;
              v246 = vmvnq_s8(v245);
              v247 = vandq_s8((int8x16_t)vdupq_n_s32(v243), (int8x16_t)xmmword_185004D50);
              if (v20)
                v248 = 0;
              else
                v248 = -1;
              v244.i32[3] = v248;
              v249 = vmvnq_s8(v244);
              v250 = vandq_s8((int8x16_t)vdupq_n_s32(v248), (int8x16_t)xmmword_185004D50);
              v251 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V4.4S, #1.0 }
                v253 = v22;
                v254 = v1550;
                do
                {
                  v255 = (v253 - v47) >> 4;
                  if (v255 >= v1546)
                    v255 = v1546;
                  if (v255 < 2)
                  {
                    i27 = v255;
                  }
                  else
                  {
                    v256 = 0;
                    for (i27 = v255; i27 > 1; i27 -= 2)
                    {
                      v258 = (float32x4_t *)((char *)v26 + v256);
                      v259 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v256 + 16), v246), v247);
                      v260 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v256), v246), v247);
                      v261 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v256), v249), v250);
                      v262 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v256), v249), v250);
                      v263 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v260, 3);
                      v264 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v259, 3);
                      v265 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v262, 3);
                      v266 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v261, 3);
                      *v258 = vsubq_f32(vminnmq_f32(vaddq_f32(v263, v265), _Q4), vaddq_f32(vsubq_f32(v263, v260), vsubq_f32(v265, v262)));
                      v258[1] = vsubq_f32(vminnmq_f32(vaddq_f32(v264, v266), _Q4), vaddq_f32(vsubq_f32(v264, v259), vsubq_f32(v266, v261)));
                      v256 += v251;
                    }
                    v47 += v256;
                    v26 = (float32x4_t *)((char *)v26 + v256);
                  }
                  for (i28 = i27 + v1546 - v255; i28; --i28)
                  {
                    v268 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v246), v247);
                    v269 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v249), v250);
                    v270 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v268, 3);
                    v271 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v269, 3);
                    *v26 = vsubq_f32(vminnmq_f32(vaddq_f32(v270, v271), _Q4), vaddq_f32(vsubq_f32(v270, v268), vsubq_f32(v271, v269)));
                    v272 = v47 + 16 * v1541;
                    if (v272 >= v253)
                      v273 = -(uint64_t)(int)v1545;
                    else
                      v273 = 0;
                    v47 = v272 + 16 * v273;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v274 = v254 + 16 * v1549;
                  if (v274 >= v1548)
                    v275 = -(uint64_t)(v1549 * v1542);
                  else
                    v275 = 0;
                  v276 = v274 + 16 * v275;
                  v277 = v253 + 16 * v275 + 16 * v1549;
                  if (v1548)
                    v47 = v276;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v253 = v277;
                    v254 = v276;
                  }
                  _VF = __OFSUB__(v242--, 1);
                }
                while (!((v242 < 0) ^ _VF | (v242 == 0)));
              }
              else
              {
                __asm { FMOV            V4.4S, #1.0 }
                v1185 = v22;
                v1186 = v1550;
                do
                {
                  v1187 = (v1185 - v47) >> 4;
                  if (v1187 >= v1546)
                    v1187 = v1546;
                  if (v1187 < 2)
                  {
                    i29 = v1187;
                  }
                  else
                  {
                    v1188 = 0;
                    for (i29 = v1187; i29 > 1; i29 -= 2)
                    {
                      v1190 = (int8x16_t *)((char *)v26 + v1188);
                      v1191 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1188 + 16)), v246), v247);
                      v1192 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1188)), v246), v247);
                      v1193 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1188)), v249), v250);
                      v1194 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1192, 3);
                      v1195 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1191, 3);
                      v1196 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1188)), v249), v250);
                      v1197 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1196, 3);
                      v1198 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1193, 3);
                      *v1190 = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v1194, v1197), _Q4), vaddq_f32(vsubq_f32(v1194, v1192), vsubq_f32(v1197, v1196))));
                      v1190[1] = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v1195, v1198), _Q4), vaddq_f32(vsubq_f32(v1195, v1191), vsubq_f32(v1198, v1193))));
                      v1188 += v251;
                    }
                    v47 += v1188;
                    v26 = (float32x4_t *)((char *)v26 + v1188);
                  }
                  for (i30 = i29 + v1546 - v1187; i30; --i30)
                  {
                    v1200 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v246), v247);
                    v1201 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v249), v250);
                    v1202 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1200, 3);
                    v1203 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1201, 3);
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v1202, v1203), _Q4), vaddq_f32(vsubq_f32(v1202, v1200), vsubq_f32(v1203, v1201))));
                    v1204 = v47 + 16 * v1541;
                    if (v1204 >= v1185)
                      v1205 = -(uint64_t)(int)v1545;
                    else
                      v1205 = 0;
                    v47 = v1204 + 16 * v1205;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1206 = v1186 + 16 * v1549;
                  if (v1206 >= v1548)
                    v1207 = -(uint64_t)(v1549 * v1542);
                  else
                    v1207 = 0;
                  v1208 = v1206 + 16 * v1207;
                  v1209 = v1185 + 16 * v1207 + 16 * v1549;
                  if (v1548)
                    v47 = v1208;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1185 = v1209;
                    v1186 = v1208;
                  }
                  _VF = __OFSUB__(v242--, 1);
                }
                while (!((v242 < 0) ^ _VF | (v242 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v242 = v1552;
          }
          do
          {
            v840 = v1546;
            do
            {
              v841 = 1.0;
              v842 = 1.0;
              if (v20)
                v842 = v26->f32[3];
              if (v44)
                v841 = *(float *)(v47 + 12);
              v843 = 1.0;
              v844 = 1.0;
              if (v20)
                v844 = v26->f32[3];
              if (v44)
                v843 = *(float *)(v47 + 12);
              v845 = v842 + v841;
              v846 = 1.0;
              if (v845 > 1.0)
                v845 = 1.0;
              v847 = 1.0;
              if (v20)
                v847 = v26->f32[3];
              if (v44)
                v846 = *(float *)(v47 + 12);
              v848 = v26->f32[1];
              v849 = v844 - v26->f32[0];
              v850 = *(float *)(v47 + 4);
              v26->f32[0] = v845 - (float)(v849 + (float)(v843 - *(float *)v47));
              v851 = 1.0;
              v852 = 1.0;
              if (v20)
                v852 = v26->f32[3];
              if (v44)
                v851 = *(float *)(v47 + 12);
              v853 = (float)(v852 - v26->f32[2]) + (float)(v851 - *(float *)(v47 + 8));
              v26->f32[3] = v845;
              v26->f32[1] = v845 - (float)((float)(v847 - v848) + (float)(v846 - v850));
              v26->f32[2] = v845 - v853;
              v854 = v47 + 16 * v1541;
              if (v854 >= v22)
                v855 = -(uint64_t)(int)v1545;
              else
                v855 = 0;
              v47 = v854 + 16 * v855;
              v26 += v1541;
              --v840;
            }
            while (v840);
            v26 += v1547;
            v856 = v1550;
            v857 = v1550 + 16 * v1549;
            if (v857 >= v1548)
              v858 = -(uint64_t)(v1549 * v1542);
            else
              v858 = 0;
            v859 = v857 + 16 * v858;
            v860 = v22 + 16 * v858 + 16 * v1549;
            if (v1548)
            {
              v22 = v860;
              v856 = v859;
            }
            v1550 = v856;
            if (v1548)
              v47 = v859;
            else
              v47 += 16 * v1549;
            --v242;
          }
          while (v242);
          goto LABEL_1352;
        case 12:
          if (v45)
          {
            v278 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v279.i64[0] = 0;
              v279.i32[2] = 0;
              v279.i32[3] = v44 - 1;
              v280 = vmvnq_s8(v279);
              v281 = vandq_s8((int8x16_t)vdupq_n_s32(v44 - 1), (int8x16_t)xmmword_185004D50);
              v282 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v283 = v22;
                v284 = v1550;
                do
                {
                  v285 = (v283 - v47) >> 4;
                  if (v285 >= v1546)
                    v285 = v1546;
                  if (v285 < 2)
                  {
                    i31 = v285;
                  }
                  else
                  {
                    v286 = 0;
                    for (i31 = v285; i31 > 1; i31 -= 2)
                    {
                      v288 = (float32x4_t *)((char *)v26 + v286);
                      v289 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)v26 + v286 + 16), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v286 + 16), v280), v281)), (float32x4_t)xmmword_1850048F0);
                      *v288 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)v26 + v286), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v286), v280), v281)), (float32x4_t)xmmword_1850048F0);
                      v288[1] = v289;
                      v286 += v282;
                    }
                    v47 += v286;
                    v26 = (float32x4_t *)((char *)v26 + v286);
                  }
                  for (i32 = i31 + v1546 - v285; i32; --i32)
                  {
                    *v26 = vminnmq_f32(vaddq_f32(*v26, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v280), v281)), (float32x4_t)xmmword_1850048F0);
                    v291 = v47 + 16 * v1541;
                    if (v291 >= v283)
                      v292 = -(uint64_t)(int)v1545;
                    else
                      v292 = 0;
                    v47 = v291 + 16 * v292;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v293 = v284 + 16 * v1549;
                  if (v293 >= v1548)
                    v294 = -(uint64_t)(v1549 * v1542);
                  else
                    v294 = 0;
                  v295 = v293 + 16 * v294;
                  v296 = v283 + 16 * v294 + 16 * v1549;
                  if (v1548)
                    v47 = v295;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v283 = v296;
                    v284 = v295;
                  }
                  _VF = __OFSUB__(v278--, 1);
                }
                while (!((v278 < 0) ^ _VF | (v278 == 0)));
              }
              else
              {
                v1210 = v22;
                v1211 = v1550;
                do
                {
                  v1212 = (v1210 - v47) >> 4;
                  if (v1212 >= v1546)
                    v1212 = v1546;
                  if (v1212 < 2)
                  {
                    i33 = v1212;
                  }
                  else
                  {
                    v1213 = 0;
                    for (i33 = v1212; i33 > 1; i33 -= 2)
                    {
                      v1215 = (int8x16_t *)((char *)v26 + v1213);
                      v1216 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1213)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1213 + 16)), v280), v281)), (float32x4_t)xmmword_1850048F0));
                      *v1215 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1213)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1213)), v280), v281)), (float32x4_t)xmmword_1850048F0));
                      v1215[1] = v1216;
                      v1213 += v282;
                    }
                    v47 += v1213;
                    v26 = (float32x4_t *)((char *)v26 + v1213);
                  }
                  for (i34 = i33 + v1546 - v1212; i34; --i34)
                  {
                    *(int8x16_t *)v26 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v26), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v280), v281)), (float32x4_t)xmmword_1850048F0));
                    v1218 = v47 + 16 * v1541;
                    if (v1218 >= v1210)
                      v1219 = -(uint64_t)(int)v1545;
                    else
                      v1219 = 0;
                    v47 = v1218 + 16 * v1219;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1220 = v1211 + 16 * v1549;
                  if (v1220 >= v1548)
                    v1221 = -(uint64_t)(v1549 * v1542);
                  else
                    v1221 = 0;
                  v1222 = v1220 + 16 * v1221;
                  v1223 = v1210 + 16 * v1221 + 16 * v1549;
                  if (v1548)
                    v47 = v1222;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1210 = v1223;
                    v1211 = v1222;
                  }
                  _VF = __OFSUB__(v278--, 1);
                }
                while (!((v278 < 0) ^ _VF | (v278 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v278 = v1552;
          }
          do
          {
            v861 = v1546;
            do
            {
              *(float32x2_t *)v26->f32 = vadd_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47);
              v862 = 1.0;
              if (v44)
                v862 = *(float *)(v47 + 12);
              v863 = v26->f32[3] + v862;
              if (v863 > 1.0)
                v863 = 1.0;
              v26->f32[2] = v26->f32[2] + *(float *)(v47 + 8);
              v26->f32[3] = v863;
              v864 = v47 + 16 * v1541;
              if (v864 >= v22)
                v865 = -(uint64_t)(int)v1545;
              else
                v865 = 0;
              v47 = v864 + 16 * v865;
              v26 += v1541;
              --v861;
            }
            while (v861);
            v26 += v1547;
            v866 = v1550;
            v867 = v1550 + 16 * v1549;
            if (v867 >= v1548)
              v868 = -(uint64_t)(v1549 * v1542);
            else
              v868 = 0;
            v869 = v867 + 16 * v868;
            v870 = v22 + 16 * v868 + 16 * v1549;
            if (v1548)
            {
              v22 = v870;
              v866 = v869;
            }
            v1550 = v866;
            if (v1548)
              v47 = v869;
            else
              v47 += 16 * v1549;
            --v278;
          }
          while (v278);
          goto LABEL_1352;
        case 13:
          v1540 = v48;
          if (v45)
          {
            v297 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v298 = 0;
              else
                v298 = -1;
              v299.i64[0] = 0;
              v299.i32[2] = 0;
              v300.i64[0] = 0;
              v300.i32[2] = 0;
              v300.i32[3] = v298;
              v301 = vmvnq_s8(v300);
              v302 = vandq_s8((int8x16_t)vdupq_n_s32(v298), (int8x16_t)xmmword_185004D50);
              if (v20)
                v303 = 0;
              else
                v303 = -1;
              v299.i32[3] = v303;
              v304 = vmvnq_s8(v299);
              v305 = vandq_s8((int8x16_t)vdupq_n_s32(v303), (int8x16_t)xmmword_185004D50);
              v306 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v307 = v22;
                v308 = v1550;
                do
                {
                  v309 = (v307 - v47) >> 4;
                  if (v309 >= v1546)
                    v309 = v1546;
                  if (v309 < 2)
                  {
                    i35 = v309;
                  }
                  else
                  {
                    v310 = 0;
                    for (i35 = v309; i35 > 1; i35 -= 2)
                    {
                      v312 = (int8x16_t *)((char *)v26 + v310);
                      v313 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v310), v301), v302);
                      v314 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v310 + 16), v301), v302);
                      v315 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v310), v304), v305);
                      v316 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v310), v304), v305);
                      *v312 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v313, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v316, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v316, v316, v313, 3), vmlsq_laneq_f32(v313, v313, v316, 3)), v313, v316), (int8x16_t)v313), (int8x16_t)v316);
                      v312[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v314, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v315, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v315, v315, v314, 3), vmlsq_laneq_f32(v314, v314, v315, 3)), v314, v315), (int8x16_t)v314), (int8x16_t)v315);
                      v310 += v306;
                    }
                    v47 += v310;
                    v26 = (float32x4_t *)((char *)v26 + v310);
                  }
                  for (i36 = i35 + v1546 - v309; i36; --i36)
                  {
                    v318 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v301), v302);
                    v319 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v304), v305);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v318, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v319, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v319, v319, v318, 3), vmlsq_laneq_f32(v318, v318, v319, 3)), v318, v319), (int8x16_t)v318), (int8x16_t)v319);
                    v320 = v47 + 16 * v1541;
                    if (v320 >= v307)
                      v321 = -(uint64_t)(int)v1545;
                    else
                      v321 = 0;
                    v47 = v320 + 16 * v321;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v322 = v308 + 16 * v1549;
                  if (v322 >= v1548)
                    v323 = -(uint64_t)(v1549 * v1542);
                  else
                    v323 = 0;
                  v324 = v322 + 16 * v323;
                  v325 = v307 + 16 * v323 + 16 * v1549;
                  if (v1548)
                    v47 = v324;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v307 = v325;
                    v308 = v324;
                  }
                  _VF = __OFSUB__(v297--, 1);
                }
                while (!((v297 < 0) ^ _VF | (v297 == 0)));
              }
              else
              {
                v1224 = v22;
                v1225 = v1550;
                do
                {
                  v1226 = (v1224 - v47) >> 4;
                  if (v1226 >= v1546)
                    v1226 = v1546;
                  if (v1226 < 2)
                  {
                    i37 = v1226;
                  }
                  else
                  {
                    v1227 = 0;
                    for (i37 = v1226; i37 > 1; i37 -= 2)
                    {
                      v1229 = (int8x16_t *)((char *)v26 + v1227);
                      v1230 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1227 + 16)), v301), v302);
                      v1231 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1227)), v301), v302);
                      v1232 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1227)), v304), v305);
                      v1233 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1227)), v304), v305);
                      *v1229 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1231, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1232, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v1232, v1232, v1231, 3), vmlsq_laneq_f32(v1231, v1231, v1232, 3)), v1231, v1232), (int8x16_t)v1231), (int8x16_t)v1232));
                      v1229[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1230, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1233, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v1233, v1233, v1230, 3), vmlsq_laneq_f32(v1230, v1230, v1233, 3)), v1230, v1233), (int8x16_t)v1230), (int8x16_t)v1233));
                      v1227 += v306;
                    }
                    v47 += v1227;
                    v26 = (float32x4_t *)((char *)v26 + v1227);
                  }
                  for (i38 = i37 + v1546 - v1226; i38; --i38)
                  {
                    v1235 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v301), v302);
                    v1236 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v304), v305);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1235, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1236, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v1236, v1236, v1235, 3), vmlsq_laneq_f32(v1235, v1235, v1236, 3)), v1235, v1236), (int8x16_t)v1235), (int8x16_t)v1236));
                    v1237 = v47 + 16 * v1541;
                    if (v1237 >= v1224)
                      v1238 = -(uint64_t)(int)v1545;
                    else
                      v1238 = 0;
                    v47 = v1237 + 16 * v1238;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1239 = v1225 + 16 * v1549;
                  if (v1239 >= v1548)
                    v1240 = -(uint64_t)(v1549 * v1542);
                  else
                    v1240 = 0;
                  v1241 = v1239 + 16 * v1240;
                  v1242 = v1224 + 16 * v1240 + 16 * v1549;
                  if (v1548)
                    v47 = v1241;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1224 = v1242;
                    v1225 = v1241;
                  }
                  _VF = __OFSUB__(v297--, 1);
                }
                while (!((v297 < 0) ^ _VF | (v297 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v297 = v1552;
          }
          do
          {
            v934 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1169;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v935 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1169;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v935 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1526) = LODWORD(a14);
              LODWORD(v1526) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAmultiplyPDA(v26->f32[0], a8, a9, a10, v935, a12, a13, a14, *(float *)v47, v1526, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1169:
              v936 = v47 + 16 * v1541;
              if (v936 >= v22)
                v937 = -(uint64_t)(int)v1545;
              else
                v937 = 0;
              v47 = v936 + 16 * v937;
              v26 += v1541;
              --v934;
            }
            while (v934);
            v26 += v1547;
            v938 = v1550;
            v939 = v1550 + 16 * v1549;
            v940 = -(uint64_t)(v1549 * v1542);
            if (v939 < v1548)
              v940 = 0;
            v941 = v939 + 16 * v940;
            v942 = v22 + 16 * v940 + 16 * v1549;
            if (v1548)
            {
              v22 = v942;
              v938 = v941;
            }
            v1550 = v938;
            if (v1548)
              v47 = v941;
            else
              v47 += 16 * v1549;
            --v297;
          }
          while (v297);
LABEL_1335:
          v1552 = 0;
          v14 = v1534;
          v45 = v1535;
          v30 = a2;
          v32 = v1537;
LABEL_1336:
          v48 = v1540;
LABEL_1353:
          v51 = v1543;
          v26 = v1544;
          if (!v1543)
            return;
          v1551 = 0;
LABEL_1355:
          a1 = shape_enum_clip_next((uint64_t)v51, (int *)&v1551 + 1, &v1551, v1553, &v1552);
          if (!(_DWORD)a1)
          {
            free(v51);
            return;
          }
          v1543 = v51;
          v1544 = v26;
          if (v1548)
          {
            v26 += v48 * (int)v1551 + SHIDWORD(v1551);
            v24 = v32 + 16 * v1549 * (((int)v1551 + *(_DWORD *)(v30 + 60)) % v1542);
            v1539 = (HIDWORD(v1551) + *(_DWORD *)(v30 + 56)) % (int)v1545;
            v47 = v24 + 16 * v1539;
            v22 = v24 + 16 * (int)v1545;
            v1550 = v47;
            v1546 = v1553[0];
            LODWORD(v24) = v1553[0];
            v1538 = ((int)v1551 + *(_DWORD *)(v30 + 60)) % v1542;
          }
          else
          {
            v1546 = v1553[0];
            LODWORD(v24) = v1553[0] * v1541;
            v26 += v48 * (int)v1551 + HIDWORD(v1551) * v1541;
            v47 = v32 + 16 * (int)v1551 * (int)v1545 + 16 * HIDWORD(v1551) * v1541;
            v1549 = (int)v1545 - v1553[0] * v1541;
          }
          v24 = (int)v24;
          continue;
        case 14:
          if (v45)
          {
            v326 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v327 = 0;
              else
                v327 = -1;
              v328.i64[0] = 0;
              v328.i32[2] = 0;
              v328.i32[3] = v327;
              v329 = vmvnq_s8(v328);
              v330 = vandq_s8((int8x16_t)vdupq_n_s32(v327), (int8x16_t)xmmword_185004D50);
              if (v20)
                v331 = 0;
              else
                v331 = -1;
              v332.i64[0] = 0;
              v332.i32[2] = 0;
              v332.i32[3] = v331;
              v333 = vmvnq_s8(v332);
              v334 = vandq_s8((int8x16_t)vdupq_n_s32(v331), (int8x16_t)xmmword_185004D50);
              v335 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V5.4S, #1.0 }
                v337 = v22;
                v338 = v1550;
                do
                {
                  v339 = (v337 - v47) >> 4;
                  if (v339 >= v1546)
                    v339 = v1546;
                  if (v339 < 2)
                  {
                    i39 = v339;
                  }
                  else
                  {
                    v340 = 0;
                    for (i39 = v339; i39 > 1; i39 -= 2)
                    {
                      v342 = (int8x16_t *)((char *)v26 + v340);
                      v343 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v340 + 16), v329), v330);
                      v344 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v340), v329), v330);
                      v345 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v340), v333), v334);
                      v346 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v340), v333), v334);
                      *v342 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v344, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v345, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v344, v345, v344), v345), (int8x16_t)v344), (int8x16_t)v345);
                      v342[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v343, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v346, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v343, v346, v343), v346), (int8x16_t)v343), (int8x16_t)v346);
                      v340 += v335;
                    }
                    v47 += v340;
                    v26 = (float32x4_t *)((char *)v26 + v340);
                  }
                  for (i40 = i39 + v1546 - v339; i40; --i40)
                  {
                    v348 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v329), v330);
                    v349 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v333), v334);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v348)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v349, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v348, v349, v348), v349), (int8x16_t)v348), (int8x16_t)v349);
                    v350 = v47 + 16 * v1541;
                    if (v350 >= v337)
                      v351 = -(uint64_t)(int)v1545;
                    else
                      v351 = 0;
                    v47 = v350 + 16 * v351;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v352 = v338 + 16 * v1549;
                  if (v352 >= v1548)
                    v353 = -(uint64_t)(v1549 * v1542);
                  else
                    v353 = 0;
                  v354 = v352 + 16 * v353;
                  v355 = v337 + 16 * v353 + 16 * v1549;
                  if (v1548)
                    v47 = v354;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v337 = v355;
                    v338 = v354;
                  }
                  _VF = __OFSUB__(v326--, 1);
                }
                while (!((v326 < 0) ^ _VF | (v326 == 0)));
              }
              else
              {
                __asm { FMOV            V5.4S, #1.0 }
                v1244 = v22;
                v1245 = v1550;
                do
                {
                  v1246 = (v1244 - v47) >> 4;
                  if (v1246 >= v1546)
                    v1246 = v1546;
                  if (v1246 < 2)
                  {
                    i41 = v1246;
                  }
                  else
                  {
                    v1247 = 0;
                    for (i41 = v1246; i41 > 1; i41 -= 2)
                    {
                      v1249 = (int8x16_t *)((char *)v26 + v1247);
                      v1250 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1247)), v329), v330);
                      v1251 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1247 + 16)), v329), v330);
                      v1252 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1247)), v333), v334);
                      v1253 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1247)), v333), v334);
                      *v1249 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1250, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1252, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v1250, v1252, v1250), v1252), (int8x16_t)v1250), (int8x16_t)v1252));
                      v1249[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1251, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1253, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v1251, v1253, v1251), v1253), (int8x16_t)v1251), (int8x16_t)v1253));
                      v1247 += v335;
                    }
                    v47 += v1247;
                    v26 = (float32x4_t *)((char *)v26 + v1247);
                  }
                  for (i42 = i41 + v1546 - v1246; i42; --i42)
                  {
                    v1255 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v329), v330);
                    v1256 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v333), v334);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v1255)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1256, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v1255, v1256, v1255), v1256), (int8x16_t)v1255), (int8x16_t)v1256));
                    v1257 = v47 + 16 * v1541;
                    if (v1257 >= v1244)
                      v1258 = -(uint64_t)(int)v1545;
                    else
                      v1258 = 0;
                    v47 = v1257 + 16 * v1258;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1259 = v1245 + 16 * v1549;
                  if (v1259 >= v1548)
                    v1260 = -(uint64_t)(v1549 * v1542);
                  else
                    v1260 = 0;
                  v1261 = v1259 + 16 * v1260;
                  v1262 = v1244 + 16 * v1260 + 16 * v1549;
                  if (v1548)
                    v47 = v1261;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1244 = v1262;
                    v1245 = v1261;
                  }
                  _VF = __OFSUB__(v326--, 1);
                }
                while (!((v326 < 0) ^ _VF | (v326 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v326 = v1552;
          }
          __asm { FMOV            V1.2S, #1.0 }
          do
          {
            v872 = v1546;
            do
            {
              v873 = 1.0;
              v874 = 1.0;
              if (!v44 || (v874 = *(float *)(v47 + 12), v874 > 0.0))
              {
                if (v20 && (v873 = v26->f32[3], v873 <= 0.0))
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                }
                else
                {
                  v875 = v26->f32[2] + (float)(*(float *)(v47 + 8) * (float)(1.0 - v26->f32[2]));
                  v874 = (float)(v874 + v873) - (float)(v873 * v874);
                  *(float32x2_t *)v26->f32 = vmla_f32(*(float32x2_t *)v26->f32, vsub_f32(_D1, *(float32x2_t *)v26->f32), *(float32x2_t *)v47);
                  v26->f32[2] = v875;
                }
                v26->f32[3] = v874;
              }
              v876 = v47 + 16 * v1541;
              if (v876 >= v22)
                v877 = -(uint64_t)(int)v1545;
              else
                v877 = 0;
              v47 = v876 + 16 * v877;
              v26 += v1541;
              --v872;
            }
            while (v872);
            v26 += v1547;
            v878 = v1550;
            v879 = v1550 + 16 * v1549;
            if (v879 >= v1548)
              v880 = -(uint64_t)(v1549 * v1542);
            else
              v880 = 0;
            v881 = v879 + 16 * v880;
            v882 = v22 + 16 * v880 + 16 * v1549;
            if (v1548)
            {
              v22 = v882;
              v878 = v881;
            }
            v1550 = v878;
            if (v1548)
              v47 = v881;
            else
              v47 += 16 * v1549;
            --v326;
          }
          while (v326);
          goto LABEL_1352;
        case 15:
          v1540 = v48;
          if (v45)
          {
            v356 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v357 = 0;
              else
                v357 = -1;
              v358.i64[0] = 0;
              v358.i32[2] = 0;
              v359.i64[0] = 0;
              v359.i32[2] = 0;
              v359.i32[3] = v357;
              v360 = vmvnq_s8(v359);
              v361 = vandq_s8((int8x16_t)vdupq_n_s32(v357), (int8x16_t)xmmword_185004D50);
              if (v20)
                v362 = 0;
              else
                v362 = -1;
              v358.i32[3] = v362;
              v363 = vmvnq_s8(v358);
              v364 = vandq_s8((int8x16_t)vdupq_n_s32(v362), (int8x16_t)xmmword_185004D50);
              v365 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v366.i64[0] = 0x3F0000003F000000;
                v366.i64[1] = 0x3F0000003F000000;
                v367.i64[0] = 0x8000000080000000;
                v367.i64[1] = 0x8000000080000000;
                v368 = v22;
                v369 = v1550;
                do
                {
                  v370 = (v368 - v47) >> 4;
                  if (v370 >= v1546)
                    v370 = v1546;
                  if (v370 < 2)
                  {
                    i43 = v370;
                  }
                  else
                  {
                    v371 = 0;
                    for (i43 = v370; i43 > 1; i43 -= 2)
                    {
                      v373 = (int8x16_t *)((char *)v26 + v371);
                      v374 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v371), v360), v361);
                      v375 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v371 + 16), v360), v361);
                      v376 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v371), v363), v364);
                      v377 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v375, 3);
                      v378 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v374, 3);
                      v379 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v371), v363), v364);
                      v380 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v379, 3);
                      v381 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v376, 3);
                      v382 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v366, v379, 3), v379);
                      v383 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v366, v376, 3), v376);
                      v384 = vandq_s8(v383, v367);
                      v385 = vandq_s8(v382, v367);
                      *v373 = vbslq_s8((int8x16_t)vcgtzq_f32(v378), vbslq_s8((int8x16_t)vcgtzq_f32(v380), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v379, (float32x4_t)veorq_s8(v385, (int8x16_t)vsubq_f32(v378, v374)), v379), vmlaq_f32(v374, (float32x4_t)veorq_s8(v385, (int8x16_t)vsubq_f32(v380, v379)), v374)), (float32x4_t)vbslq_s8(v382, v367, (int8x16_t)vmulq_laneq_f32(v378, v379, 3))), (int8x16_t)v374), (int8x16_t)v379);
                      v373[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v377), vbslq_s8((int8x16_t)vcgtzq_f32(v381), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v376, (float32x4_t)veorq_s8(v384, (int8x16_t)vsubq_f32(v377, v375)), v376), vmlaq_f32(v375, (float32x4_t)veorq_s8(v384, (int8x16_t)vsubq_f32(v381, v376)), v375)), (float32x4_t)vbslq_s8(v383, v367, (int8x16_t)vmulq_laneq_f32(v377, v376, 3))), (int8x16_t)v375), (int8x16_t)v376);
                      v371 += v365;
                    }
                    v47 += v371;
                    v26 = (float32x4_t *)((char *)v26 + v371);
                  }
                  for (i44 = i43 + v1546 - v370; i44; --i44)
                  {
                    v387 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v360), v361);
                    v388 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v363), v364);
                    v389 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v387, 3);
                    v390 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v388, 3);
                    v391 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v366, v388, 3), v388);
                    v392 = vandq_s8(v391, v367);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v389), vbslq_s8((int8x16_t)vcgtzq_f32(v390), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v388, (float32x4_t)veorq_s8(v392, (int8x16_t)vsubq_f32(v389, v387)), v388), vmlaq_f32(v387, (float32x4_t)veorq_s8(v392, (int8x16_t)vsubq_f32(v390, v388)), v387)), (float32x4_t)vbslq_s8(v391,
                                                                        v367,
                                                                        (int8x16_t)vmulq_laneq_f32(v389, v388, 3))),
                                            (int8x16_t)v387),
                                          (int8x16_t)v388);
                    v393 = v47 + 16 * v1541;
                    if (v393 >= v368)
                      v394 = -(uint64_t)(int)v1545;
                    else
                      v394 = 0;
                    v47 = v393 + 16 * v394;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v395 = v369 + 16 * v1549;
                  if (v395 >= v1548)
                    v396 = -(uint64_t)(v1549 * v1542);
                  else
                    v396 = 0;
                  v397 = v395 + 16 * v396;
                  v398 = v368 + 16 * v396 + 16 * v1549;
                  if (v1548)
                    v47 = v397;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v368 = v398;
                    v369 = v397;
                  }
                  _VF = __OFSUB__(v356--, 1);
                }
                while (!((v356 < 0) ^ _VF | (v356 == 0)));
              }
              else
              {
                v1263.i64[0] = 0x3F0000003F000000;
                v1263.i64[1] = 0x3F0000003F000000;
                v1264.i64[0] = 0x8000000080000000;
                v1264.i64[1] = 0x8000000080000000;
                v1265 = v22;
                v1266 = v1550;
                do
                {
                  v1267 = (v1265 - v47) >> 4;
                  if (v1267 >= v1546)
                    v1267 = v1546;
                  if (v1267 < 2)
                  {
                    i45 = v1267;
                  }
                  else
                  {
                    v1268 = 0;
                    for (i45 = v1267; i45 > 1; i45 -= 2)
                    {
                      v1270 = (int8x16_t *)((char *)v26 + v1268);
                      v1271 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1268 + 16)), v360), v361);
                      v1272 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1268)), v360), v361);
                      v1273 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1268)), v363), v364);
                      v1274 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1272, 3);
                      v1275 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1271, 3);
                      v1276 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1273, 3);
                      v1277 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1268)), v363), v364);
                      v1278 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1277, 3);
                      v1279 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v1263, v1273, 3), v1273);
                      v1280 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v1263, v1277, 3), v1277);
                      v1281 = vandq_s8(v1280, v1264);
                      v1282 = vandq_s8(v1279, v1264);
                      *v1270 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1274), vbslq_s8((int8x16_t)vcgtzq_f32(v1278), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1277, (float32x4_t)veorq_s8(v1281, (int8x16_t)vsubq_f32(v1274, v1272)), v1277), vmlaq_f32(v1272, (float32x4_t)veorq_s8(v1281, (int8x16_t)vsubq_f32(v1278, v1277)), v1272)), (float32x4_t)vbslq_s8(v1280, v1264, (int8x16_t)vmulq_laneq_f32(v1274, v1277, 3))), (int8x16_t)v1272),
                                   (int8x16_t)v1277));
                      v1270[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1275), vbslq_s8((int8x16_t)vcgtzq_f32(v1276), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1273, (float32x4_t)veorq_s8(v1282, (int8x16_t)vsubq_f32(v1275, v1271)), v1273), vmlaq_f32(v1271, (float32x4_t)veorq_s8(v1282, (int8x16_t)vsubq_f32(v1276, v1273)), v1271)), (float32x4_t)vbslq_s8(v1279, v1264, (int8x16_t)vmulq_laneq_f32(v1275, v1273, 3))), (int8x16_t)v1271),
                                     (int8x16_t)v1273));
                      v1268 += v365;
                    }
                    v47 += v1268;
                    v26 = (float32x4_t *)((char *)v26 + v1268);
                  }
                  for (i46 = i45 + v1546 - v1267; i46; --i46)
                  {
                    v1284 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v360), v361);
                    v1285 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1284, 3);
                    v1286 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v363), v364);
                    v1287 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1286, 3);
                    v1288 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v1263, v1286, 3), v1286);
                    v1289 = vandq_s8(v1288, v1264);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1285), vbslq_s8((int8x16_t)vcgtzq_f32(v1287), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1286, (float32x4_t)veorq_s8(v1289, (int8x16_t)vsubq_f32(v1285, v1284)), v1286), vmlaq_f32(v1284, (float32x4_t)veorq_s8(v1289, (int8x16_t)vsubq_f32(v1287, v1286)), v1284)), (float32x4_t)vbslq_s8(
                                                                          v1288,
                                                                          v1264,
                                                                          (int8x16_t)vmulq_laneq_f32(v1285, v1286, 3))),
                                              (int8x16_t)v1284),
                                            (int8x16_t)v1286));
                    v1290 = v47 + 16 * v1541;
                    if (v1290 >= v1265)
                      v1291 = -(uint64_t)(int)v1545;
                    else
                      v1291 = 0;
                    v47 = v1290 + 16 * v1291;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1292 = v1266 + 16 * v1549;
                  if (v1292 >= v1548)
                    v1293 = -(uint64_t)(v1549 * v1542);
                  else
                    v1293 = 0;
                  v1294 = v1292 + 16 * v1293;
                  v1295 = v1265 + 16 * v1293 + 16 * v1549;
                  if (v1548)
                    v47 = v1294;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1265 = v1295;
                    v1266 = v1294;
                  }
                  _VF = __OFSUB__(v356--, 1);
                }
                while (!((v356 < 0) ^ _VF | (v356 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v356 = v1552;
          }
          while (1)
          {
            v943 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1191;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v944 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1191;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v944 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1527) = LODWORD(a14);
              LODWORD(v1527) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAoverlayPDA(v26->f32[0], a8, a9, a10, v944, a12, a13, a14, *(float *)v47, v1527, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1191:
              v945 = v47 + 16 * v1541;
              if (v945 >= v22)
                v946 = -(uint64_t)(int)v1545;
              else
                v946 = 0;
              v47 = v945 + 16 * v946;
              v26 += v1541;
              --v943;
            }
            while (v943);
            v26 += v1547;
            v947 = v1550;
            v948 = v1550 + 16 * v1549;
            v949 = -(uint64_t)(v1549 * v1542);
            if (v948 < v1548)
              v949 = 0;
            v950 = v948 + 16 * v949;
            v951 = v22 + 16 * v949 + 16 * v1549;
            if (v1548)
            {
              v22 = v951;
              v947 = v950;
            }
            v1550 = v947;
            if (v1548)
              v47 = v950;
            else
              v47 += 16 * v1549;
            if (!--v356)
              goto LABEL_1335;
          }
        case 16:
          v1540 = v48;
          if (v45)
          {
            v399 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v400 = 0;
              else
                v400 = -1;
              v401.i64[0] = 0;
              v401.i32[2] = 0;
              v402.i64[0] = 0;
              v402.i32[2] = 0;
              v402.i32[3] = v400;
              v403 = vmvnq_s8(v402);
              v404 = vandq_s8((int8x16_t)vdupq_n_s32(v400), (int8x16_t)xmmword_185004D50);
              if (v20)
                v405 = 0;
              else
                v405 = -1;
              v401.i32[3] = v405;
              v406 = vmvnq_s8(v401);
              v407 = vandq_s8((int8x16_t)vdupq_n_s32(v405), (int8x16_t)xmmword_185004D50);
              v408 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v409 = v22;
                v410 = v1550;
                do
                {
                  v411 = (v409 - v47) >> 4;
                  if (v411 >= v1546)
                    v411 = v1546;
                  if (v411 < 2)
                  {
                    i47 = v411;
                  }
                  else
                  {
                    v412 = 0;
                    for (i47 = v411; i47 > 1; i47 -= 2)
                    {
                      v414 = (int8x16_t *)((char *)v26 + v412);
                      v415 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v412), v406), v407);
                      v416 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v412), v406), v407);
                      v417 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v412), v403), v404);
                      v418 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v412 + 16), v403), v404);
                      *v414 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v417, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v416, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v417, v417, v416, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v416, v417, 3), vmulq_laneq_f32(v417, v416, 3)), vmlsq_laneq_f32(v416, v416, v417, 3))), (int8x16_t)v417), (int8x16_t)v416);
                      v414[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v418, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v415, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v418, v418, v415, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v415, v418, 3), vmulq_laneq_f32(v418, v415, 3)), vmlsq_laneq_f32(v415, v415, v418, 3))), (int8x16_t)v418), (int8x16_t)v415);
                      v412 += v408;
                    }
                    v47 += v412;
                    v26 = (float32x4_t *)((char *)v26 + v412);
                  }
                  for (i48 = i47 + v1546 - v411; i48; --i48)
                  {
                    v420 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v403), v404);
                    v421 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v406), v407);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v420, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v421, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v420, v420, v421, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v421, v420, 3), vmulq_laneq_f32(v420, v421, 3)), vmlsq_laneq_f32(v421, v421, v420, 3))), (int8x16_t)v420), (int8x16_t)v421);
                    v422 = v47 + 16 * v1541;
                    if (v422 >= v409)
                      v423 = -(uint64_t)(int)v1545;
                    else
                      v423 = 0;
                    v47 = v422 + 16 * v423;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v424 = v410 + 16 * v1549;
                  if (v424 >= v1548)
                    v425 = -(uint64_t)(v1549 * v1542);
                  else
                    v425 = 0;
                  v426 = v424 + 16 * v425;
                  v427 = v409 + 16 * v425 + 16 * v1549;
                  if (v1548)
                    v47 = v426;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v409 = v427;
                    v410 = v426;
                  }
                  _VF = __OFSUB__(v399--, 1);
                }
                while (!((v399 < 0) ^ _VF | (v399 == 0)));
              }
              else
              {
                v1296 = v22;
                v1297 = v1550;
                do
                {
                  v1298 = (v1296 - v47) >> 4;
                  if (v1298 >= v1546)
                    v1298 = v1546;
                  if (v1298 < 2)
                  {
                    i49 = v1298;
                  }
                  else
                  {
                    v1299 = 0;
                    for (i49 = v1298; i49 > 1; i49 -= 2)
                    {
                      v1301 = (int8x16_t *)((char *)v26 + v1299);
                      v1302 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1299)), v406), v407);
                      v1303 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1299)), v406), v407);
                      v1304 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1299 + 16)), v403), v404);
                      v1305 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1299)), v403), v404);
                      *v1301 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1305, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1302, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1305, v1305, v1302, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v1302, v1305, 3), vmulq_laneq_f32(v1305, v1302, 3)), vmlsq_laneq_f32(v1302, v1302, v1305, 3))), (int8x16_t)v1305), (int8x16_t)v1302));
                      v1301[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1304, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1303, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1304, v1304, v1303, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v1303, v1304, 3), vmulq_laneq_f32(v1304, v1303, 3)), vmlsq_laneq_f32(v1303, v1303, v1304, 3))), (int8x16_t)v1304), (int8x16_t)v1303));
                      v1299 += v408;
                    }
                    v47 += v1299;
                    v26 = (float32x4_t *)((char *)v26 + v1299);
                  }
                  for (i50 = i49 + v1546 - v1298; i50; --i50)
                  {
                    v1307 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v403), v404);
                    v1308 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v406), v407);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1307, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1308, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1307, v1307, v1308, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v1308, v1307, 3), vmulq_laneq_f32(v1307, v1308, 3)), vmlsq_laneq_f32(v1308, v1308, v1307, 3))), (int8x16_t)v1307), (int8x16_t)v1308));
                    v1309 = v47 + 16 * v1541;
                    if (v1309 >= v1296)
                      v1310 = -(uint64_t)(int)v1545;
                    else
                      v1310 = 0;
                    v47 = v1309 + 16 * v1310;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1311 = v1297 + 16 * v1549;
                  if (v1311 >= v1548)
                    v1312 = -(uint64_t)(v1549 * v1542);
                  else
                    v1312 = 0;
                  v1313 = v1311 + 16 * v1312;
                  v1314 = v1296 + 16 * v1312 + 16 * v1549;
                  if (v1548)
                    v47 = v1313;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1296 = v1314;
                    v1297 = v1313;
                  }
                  _VF = __OFSUB__(v399--, 1);
                }
                while (!((v399 < 0) ^ _VF | (v399 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v399 = v1552;
          }
          while (1)
          {
            v952 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1213;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v953 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1213;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v953 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1528) = LODWORD(a14);
              LODWORD(v1528) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAdarkenPDA(v26->f32[0], a8, a9, a10, v953, a12, a13, a14, *(float *)v47, v1528, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1213:
              v954 = v47 + 16 * v1541;
              if (v954 >= v22)
                v955 = -(uint64_t)(int)v1545;
              else
                v955 = 0;
              v47 = v954 + 16 * v955;
              v26 += v1541;
              --v952;
            }
            while (v952);
            v26 += v1547;
            v956 = v1550;
            v957 = v1550 + 16 * v1549;
            v958 = -(uint64_t)(v1549 * v1542);
            if (v957 < v1548)
              v958 = 0;
            v959 = v957 + 16 * v958;
            v960 = v22 + 16 * v958 + 16 * v1549;
            if (v1548)
            {
              v22 = v960;
              v956 = v959;
            }
            v1550 = v956;
            if (v1548)
              v47 = v959;
            else
              v47 += 16 * v1549;
            if (!--v399)
              goto LABEL_1335;
          }
        case 17:
          v1540 = v48;
          if (v45)
          {
            v428 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v429 = 0;
              else
                v429 = -1;
              v430.i64[0] = 0;
              v430.i32[2] = 0;
              v431.i64[0] = 0;
              v431.i32[2] = 0;
              v431.i32[3] = v429;
              v432 = vmvnq_s8(v431);
              v433 = vandq_s8((int8x16_t)vdupq_n_s32(v429), (int8x16_t)xmmword_185004D50);
              if (v20)
                v434 = 0;
              else
                v434 = -1;
              v430.i32[3] = v434;
              v435 = vmvnq_s8(v430);
              v436 = vandq_s8((int8x16_t)vdupq_n_s32(v434), (int8x16_t)xmmword_185004D50);
              v437 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v438 = v22;
                v439 = v1550;
                do
                {
                  v440 = (v438 - v47) >> 4;
                  if (v440 >= v1546)
                    v440 = v1546;
                  if (v440 < 2)
                  {
                    i51 = v440;
                  }
                  else
                  {
                    v441 = 0;
                    for (i51 = v440; i51 > 1; i51 -= 2)
                    {
                      v443 = (int8x16_t *)((char *)v26 + v441);
                      v444 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v441), v435), v436);
                      v445 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v441), v435), v436);
                      v446 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v441), v432), v433);
                      v447 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v441 + 16), v432), v433);
                      *v443 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v446, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v445, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v446, v446, v445, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v445, v446, 3), vmulq_laneq_f32(v446, v445, 3)), vmlsq_laneq_f32(v445, v445, v446, 3))), (int8x16_t)v446), (int8x16_t)v445);
                      v443[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v447, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v444, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v447, v447, v444, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v444, v447, 3), vmulq_laneq_f32(v447, v444, 3)), vmlsq_laneq_f32(v444, v444, v447, 3))), (int8x16_t)v447), (int8x16_t)v444);
                      v441 += v437;
                    }
                    v47 += v441;
                    v26 = (float32x4_t *)((char *)v26 + v441);
                  }
                  for (i52 = i51 + v1546 - v440; i52; --i52)
                  {
                    v449 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v432), v433);
                    v450 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v435), v436);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v449, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v450, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v449, v449, v450, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v450, v449, 3), vmulq_laneq_f32(v449, v450, 3)), vmlsq_laneq_f32(v450, v450, v449, 3))), (int8x16_t)v449), (int8x16_t)v450);
                    v451 = v47 + 16 * v1541;
                    if (v451 >= v438)
                      v452 = -(uint64_t)(int)v1545;
                    else
                      v452 = 0;
                    v47 = v451 + 16 * v452;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v453 = v439 + 16 * v1549;
                  if (v453 >= v1548)
                    v454 = -(uint64_t)(v1549 * v1542);
                  else
                    v454 = 0;
                  v455 = v453 + 16 * v454;
                  v456 = v438 + 16 * v454 + 16 * v1549;
                  if (v1548)
                    v47 = v455;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v438 = v456;
                    v439 = v455;
                  }
                  _VF = __OFSUB__(v428--, 1);
                }
                while (!((v428 < 0) ^ _VF | (v428 == 0)));
              }
              else
              {
                v1315 = v22;
                v1316 = v1550;
                do
                {
                  v1317 = (v1315 - v47) >> 4;
                  if (v1317 >= v1546)
                    v1317 = v1546;
                  if (v1317 < 2)
                  {
                    i53 = v1317;
                  }
                  else
                  {
                    v1318 = 0;
                    for (i53 = v1317; i53 > 1; i53 -= 2)
                    {
                      v1320 = (int8x16_t *)((char *)v26 + v1318);
                      v1321 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1318)), v435), v436);
                      v1322 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1318)), v435), v436);
                      v1323 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1318 + 16)), v432), v433);
                      v1324 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1318)), v432), v433);
                      *v1320 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1324, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1321, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1324, v1324, v1321, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v1321, v1324, 3), vmulq_laneq_f32(v1324, v1321, 3)), vmlsq_laneq_f32(v1321, v1321, v1324, 3))), (int8x16_t)v1324), (int8x16_t)v1321));
                      v1320[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1323, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1322, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1323, v1323, v1322, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v1322, v1323, 3), vmulq_laneq_f32(v1323, v1322, 3)), vmlsq_laneq_f32(v1322, v1322, v1323, 3))), (int8x16_t)v1323), (int8x16_t)v1322));
                      v1318 += v437;
                    }
                    v47 += v1318;
                    v26 = (float32x4_t *)((char *)v26 + v1318);
                  }
                  for (i54 = i53 + v1546 - v1317; i54; --i54)
                  {
                    v1326 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v432), v433);
                    v1327 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v435), v436);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1326, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1327, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1326, v1326, v1327, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v1327, v1326, 3), vmulq_laneq_f32(v1326, v1327, 3)), vmlsq_laneq_f32(v1327, v1327, v1326, 3))), (int8x16_t)v1326), (int8x16_t)v1327));
                    v1328 = v47 + 16 * v1541;
                    if (v1328 >= v1315)
                      v1329 = -(uint64_t)(int)v1545;
                    else
                      v1329 = 0;
                    v47 = v1328 + 16 * v1329;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1330 = v1316 + 16 * v1549;
                  if (v1330 >= v1548)
                    v1331 = -(uint64_t)(v1549 * v1542);
                  else
                    v1331 = 0;
                  v1332 = v1330 + 16 * v1331;
                  v1333 = v1315 + 16 * v1331 + 16 * v1549;
                  if (v1548)
                    v47 = v1332;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1315 = v1333;
                    v1316 = v1332;
                  }
                  _VF = __OFSUB__(v428--, 1);
                }
                while (!((v428 < 0) ^ _VF | (v428 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v428 = v1552;
          }
          while (1)
          {
            v961 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1235;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v962 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1235;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v962 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1529) = LODWORD(a14);
              LODWORD(v1529) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAlightenPDA(v26->f32[0], a8, a9, a10, v962, a12, a13, a14, *(float *)v47, v1529, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1235:
              v963 = v47 + 16 * v1541;
              if (v963 >= v22)
                v964 = -(uint64_t)(int)v1545;
              else
                v964 = 0;
              v47 = v963 + 16 * v964;
              v26 += v1541;
              --v961;
            }
            while (v961);
            v26 += v1547;
            v965 = v1550;
            v966 = v1550 + 16 * v1549;
            v967 = -(uint64_t)(v1549 * v1542);
            if (v966 < v1548)
              v967 = 0;
            v968 = v966 + 16 * v967;
            v969 = v22 + 16 * v967 + 16 * v1549;
            if (v1548)
            {
              v22 = v969;
              v965 = v968;
            }
            v1550 = v965;
            if (v1548)
              v47 = v968;
            else
              v47 += 16 * v1549;
            if (!--v428)
              goto LABEL_1335;
          }
        case 18:
          v1540 = v48;
          if (v45)
          {
            v457 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v458 = 0;
              else
                v458 = -1;
              v459.i64[0] = 0;
              v459.i32[2] = 0;
              v460.i64[0] = 0;
              v460.i32[2] = 0;
              v460.i32[3] = v458;
              v461 = vmvnq_s8(v460);
              v462 = vandq_s8((int8x16_t)vdupq_n_s32(v458), (int8x16_t)xmmword_185004D50);
              if (v20)
                v463 = 0;
              else
                v463 = -1;
              v459.i32[3] = v463;
              v464 = vmvnq_s8(v459);
              v465 = vandq_s8((int8x16_t)vdupq_n_s32(v463), (int8x16_t)xmmword_185004D50);
              v466 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V4.4S, #1.0 }
                v468 = v22;
                v469 = v1550;
                do
                {
                  v470 = (v468 - v47) >> 4;
                  if (v470 >= v1546)
                    v470 = v1546;
                  if (v470 < 2)
                  {
                    i55 = v470;
                  }
                  else
                  {
                    v471 = 0;
                    for (i55 = v470; i55 > 1; i55 -= 2)
                    {
                      v473 = (int8x16_t *)((char *)v26 + v471);
                      v474 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v471), v464), v465);
                      v475 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v474, 3);
                      v476 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v471), v464), v465);
                      v477 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v476, 3);
                      v478 = (int8x16_t)vcgtzq_f32(v475);
                      v479 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v471), v461), v462);
                      v480 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v479, 3);
                      v481 = (int8x16_t)vcgtzq_f32(v477);
                      v482 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v471 + 16), v461), v462);
                      v483 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v482, 3);
                      v484 = (int8x16_t)vcgtzq_f32(v480);
                      v485 = vaddq_f32(vmlsq_laneq_f32(v476, v476, v479, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v480, v479), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v476, vmulq_f32(v479, v479), 3), vsubq_f32(v480, v479))));
                      v486 = vaddq_f32(v475, vmlsq_laneq_f32(v483, v475, v482, 3));
                      v487 = vaddq_f32(v477, vmlsq_laneq_f32(v480, v477, v479, 3));
                      v488 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v482, v482, v474, 3), vaddq_f32(vmlsq_laneq_f32(v474, v474, v482, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v483, v482), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v474, vmulq_f32(v482, v482), 3), vsubq_f32(v483, v482))))), v486);
                      v488.i32[3] = v486.i32[3];
                      v489 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v479, v479, v476, 3), v485), v487);
                      v489.i32[3] = v487.i32[3];
                      *v473 = vbslq_s8(v484, vbslq_s8(v481, v489, (int8x16_t)v479), (int8x16_t)v476);
                      v473[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v483), vbslq_s8(v478, v488, (int8x16_t)v482), (int8x16_t)v474);
                      v471 += v466;
                    }
                    v47 += v471;
                    v26 = (float32x4_t *)((char *)v26 + v471);
                  }
                  for (i56 = i55 + v1546 - v470; i56; --i56)
                  {
                    v491 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v461), v462);
                    v492 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v464), v465);
                    v493 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v491, 3);
                    v494 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v492, 3);
                    v495 = (int8x16_t)vcgtzq_f32(v494);
                    v496 = (int8x16_t)vcgtzq_f32(v493);
                    v497 = vaddq_f32(vmlsq_laneq_f32(v491, v491, v492, 3), vaddq_f32(vmlsq_laneq_f32(v492, v492, v491, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v493, v491), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v492, vmulq_f32(v491, v491), 3), vsubq_f32(v493, v491)))));
                    v498 = vaddq_f32(v494, vmlsq_laneq_f32(v493, v494, v491, 3));
                    v499 = (int8x16_t)vminnmq_f32(v497, v498);
                    v499.i32[3] = v498.i32[3];
                    *(int8x16_t *)v26 = vbslq_s8(v496, vbslq_s8(v495, v499, (int8x16_t)v491), (int8x16_t)v492);
                    v500 = v47 + 16 * v1541;
                    if (v500 >= v468)
                      v501 = -(uint64_t)(int)v1545;
                    else
                      v501 = 0;
                    v47 = v500 + 16 * v501;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v502 = v469 + 16 * v1549;
                  if (v502 >= v1548)
                    v503 = -(uint64_t)(v1549 * v1542);
                  else
                    v503 = 0;
                  v504 = v502 + 16 * v503;
                  v505 = v468 + 16 * v503 + 16 * v1549;
                  if (v1548)
                    v47 = v504;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v468 = v505;
                    v469 = v504;
                  }
                  _VF = __OFSUB__(v457--, 1);
                }
                while (!((v457 < 0) ^ _VF | (v457 == 0)));
              }
              else
              {
                __asm { FMOV            V4.4S, #1.0 }
                v1335 = v22;
                v1336 = v1550;
                do
                {
                  v1337 = (v1335 - v47) >> 4;
                  if (v1337 >= v1546)
                    v1337 = v1546;
                  if (v1337 < 2)
                  {
                    i57 = v1337;
                  }
                  else
                  {
                    v1338 = 0;
                    for (i57 = v1337; i57 > 1; i57 -= 2)
                    {
                      v1340 = (int8x16_t *)((char *)v26 + v1338);
                      v1341 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1338)), v464), v465);
                      v1342 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1338)), v464), v465);
                      v1343 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1341, 3);
                      v1344 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1342, 3);
                      v1345 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1338 + 16)), v461), v462);
                      v1346 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1345, 3);
                      v1347 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1338)), v461), v462);
                      v1348 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1347, 3);
                      v1349 = (int8x16_t)vcgtzq_f32(v1346);
                      v1350 = (int8x16_t)vcgtzq_f32(v1348);
                      v1351 = vaddq_f32(vmlsq_laneq_f32(v1345, v1345, v1342, 3), vaddq_f32(vmlsq_laneq_f32(v1342, v1342, v1345, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v1346, v1345), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v1342, vmulq_f32(v1345, v1345), 3), vsubq_f32(v1346, v1345)))));
                      v1352 = vaddq_f32(vmlsq_laneq_f32(v1347, v1347, v1341, 3), vaddq_f32(vmlsq_laneq_f32(v1341, v1341, v1347, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v1348, v1347), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v1341, vmulq_f32(v1347, v1347), 3), vsubq_f32(v1348, v1347)))));
                      v1353 = vaddq_f32(v1344, vmlsq_laneq_f32(v1346, v1344, v1345, 3));
                      v1354 = vaddq_f32(v1343, vmlsq_laneq_f32(v1348, v1343, v1347, 3));
                      v1355 = (int8x16_t)vminnmq_f32(v1352, v1354);
                      v1356 = (int8x16_t)vminnmq_f32(v1351, v1353);
                      v1355.i32[3] = v1354.i32[3];
                      v1356.i32[3] = v1353.i32[3];
                      *v1340 = vrev32q_s8(vbslq_s8(v1350, vbslq_s8((int8x16_t)vcgtzq_f32(v1343), v1355, (int8x16_t)v1347), (int8x16_t)v1341));
                      v1340[1] = vrev32q_s8(vbslq_s8(v1349, vbslq_s8((int8x16_t)vcgtzq_f32(v1344), v1356, (int8x16_t)v1345), (int8x16_t)v1342));
                      v1338 += v466;
                    }
                    v47 += v1338;
                    v26 = (float32x4_t *)((char *)v26 + v1338);
                  }
                  for (i58 = i57 + v1546 - v1337; i58; --i58)
                  {
                    v1358 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v461), v462);
                    v1359 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v464), v465);
                    v1360 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1358, 3);
                    v1361 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1359, 3);
                    v1362 = (int8x16_t)vcgtzq_f32(v1361);
                    v1363 = (int8x16_t)vcgtzq_f32(v1360);
                    v1364 = vaddq_f32(vmlsq_laneq_f32(v1358, v1358, v1359, 3), vaddq_f32(vmlsq_laneq_f32(v1359, v1359, v1358, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v1360, v1358), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v1359, vmulq_f32(v1358, v1358), 3), vsubq_f32(v1360, v1358)))));
                    v1365 = vaddq_f32(v1361, vmlsq_laneq_f32(v1360, v1361, v1358, 3));
                    v1366 = (int8x16_t)vminnmq_f32(v1364, v1365);
                    v1366.i32[3] = v1365.i32[3];
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8(v1363, vbslq_s8(v1362, v1366, (int8x16_t)v1358), (int8x16_t)v1359));
                    v1367 = v47 + 16 * v1541;
                    if (v1367 >= v1335)
                      v1368 = -(uint64_t)(int)v1545;
                    else
                      v1368 = 0;
                    v47 = v1367 + 16 * v1368;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1369 = v1336 + 16 * v1549;
                  if (v1369 >= v1548)
                    v1370 = -(uint64_t)(v1549 * v1542);
                  else
                    v1370 = 0;
                  v1371 = v1369 + 16 * v1370;
                  v1372 = v1335 + 16 * v1370 + 16 * v1549;
                  if (v1548)
                    v47 = v1371;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1335 = v1372;
                    v1336 = v1371;
                  }
                  _VF = __OFSUB__(v457--, 1);
                }
                while (!((v457 < 0) ^ _VF | (v457 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v457 = v1552;
          }
          while (1)
          {
            v970 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1257;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v971 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1257;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v971 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1530) = LODWORD(a14);
              LODWORD(v1530) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAcolordodgePDA(v26->f32[0], a8, a9, a10, v971, a12, a13, a14, *(float *)v47, v1530, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1257:
              v972 = v47 + 16 * v1541;
              if (v972 >= v22)
                v973 = -(uint64_t)(int)v1545;
              else
                v973 = 0;
              v47 = v972 + 16 * v973;
              v26 += v1541;
              --v970;
            }
            while (v970);
            v26 += v1547;
            v974 = v1550;
            v975 = v1550 + 16 * v1549;
            v976 = -(uint64_t)(v1549 * v1542);
            if (v975 < v1548)
              v976 = 0;
            v977 = v975 + 16 * v976;
            v978 = v22 + 16 * v976 + 16 * v1549;
            if (v1548)
            {
              v22 = v978;
              v974 = v977;
            }
            v1550 = v974;
            if (v1548)
              v47 = v977;
            else
              v47 += 16 * v1549;
            if (!--v457)
              goto LABEL_1335;
          }
        case 19:
          v1540 = v48;
          if (v45)
          {
            v506 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v507 = 0;
              else
                v507 = -1;
              v508.i64[0] = 0;
              v508.i32[2] = 0;
              v508.i32[3] = v507;
              v509 = vmvnq_s8(v508);
              v510 = vandq_s8((int8x16_t)vdupq_n_s32(v507), (int8x16_t)xmmword_185004D50);
              if (v20)
                v511 = 0;
              else
                v511 = -1;
              v512.i64[0] = 0;
              v512.i32[2] = 0;
              v512.i32[3] = v511;
              v513 = vmvnq_s8(v512);
              v514 = vandq_s8((int8x16_t)vdupq_n_s32(v511), (int8x16_t)xmmword_185004D50);
              v515 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v516 = v22;
                v517 = v1550;
                do
                {
                  v518 = (v516 - v47) >> 4;
                  if (v518 >= v1546)
                    v518 = v1546;
                  if (v518 < 2)
                  {
                    i59 = v518;
                  }
                  else
                  {
                    v519 = 0;
                    for (i59 = v518; i59 > 1; i59 -= 2)
                    {
                      v521 = (int8x16_t *)((char *)v26 + v519);
                      v522 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v519), v513), v514);
                      v523 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v519), v513), v514);
                      v524 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v519), v509), v510);
                      v525 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v524, 3);
                      v526 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v519 + 16), v509), v510);
                      v527 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v526, 3);
                      v528 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v522, 3));
                      v529 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v523, 3));
                      v530 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v526, v526), 3), v526);
                      v531 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v524, v524), 3), v524);
                      *v521 = vbslq_s8((int8x16_t)vcgtzq_f32(v525), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v524, v524, v522, 3), vaddq_f32(vmulq_laneq_f32(v525, v522, 3), vmlsq_laneq_f32(v522, v522, v524, 3))), v531, v522, 3), v522, v531), (float32x4_t)0), vbicq_s8(v528, (int8x16_t)vceqzq_f32(v524))), vbicq_s8((int8x16_t)v524, v528)),
                                (int8x16_t)v522);
                      v521[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v527), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v526, v526, v523, 3), vaddq_f32(vmulq_laneq_f32(v527, v523, 3), vmlsq_laneq_f32(v523, v523, v526, 3))), v530, v523, 3), v523, v530), (float32x4_t)0), vbicq_s8(v529, (int8x16_t)vceqzq_f32(v526))), vbicq_s8((int8x16_t)v526, v529)),
                                  (int8x16_t)v523);
                      v519 += v515;
                    }
                    v47 += v519;
                    v26 = (float32x4_t *)((char *)v26 + v519);
                  }
                  for (i60 = i59 + v1546 - v518; i60; --i60)
                  {
                    v533 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v509), v510);
                    v534 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v513), v514);
                    v535 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v533, 3);
                    v536 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v534, 3));
                    v537 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v533, v533), 3), v533);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v535), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v533, v533, v534, 3), vaddq_f32(vmlsq_laneq_f32(v534, v534, v533, 3), vmulq_laneq_f32(v535, v534, 3))), v537, v534, 3), v534, v537), (float32x4_t)0), vbicq_s8(v536, (int8x16_t)vceqzq_f32(v533))), vbicq_s8((int8x16_t)v533, v536)),
                                          (int8x16_t)v534);
                    v538 = v47 + 16 * v1541;
                    if (v538 >= v516)
                      v539 = -(uint64_t)(int)v1545;
                    else
                      v539 = 0;
                    v47 = v538 + 16 * v539;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v540 = v517 + 16 * v1549;
                  if (v540 >= v1548)
                    v541 = -(uint64_t)(v1549 * v1542);
                  else
                    v541 = 0;
                  v542 = v540 + 16 * v541;
                  v543 = v516 + 16 * v541 + 16 * v1549;
                  if (v1548)
                    v47 = v542;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v516 = v543;
                    v517 = v542;
                  }
                  _VF = __OFSUB__(v506--, 1);
                }
                while (!((v506 < 0) ^ _VF | (v506 == 0)));
              }
              else
              {
                v1373 = v22;
                v1374 = v1550;
                do
                {
                  v1375 = (v1373 - v47) >> 4;
                  if (v1375 >= v1546)
                    v1375 = v1546;
                  if (v1375 < 2)
                  {
                    i61 = v1375;
                  }
                  else
                  {
                    v1376 = 0;
                    for (i61 = v1375; i61 > 1; i61 -= 2)
                    {
                      v1378 = (int8x16_t *)((char *)v26 + v1376);
                      v1379 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1376)), v513), v514);
                      v1380 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1376)), v513), v514);
                      v1381 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1376 + 16)), v509), v510);
                      v1382 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1381, 3);
                      v1383 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1379, 3));
                      v1384 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1380, 3));
                      v1385 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1376)), v509), v510);
                      v1386 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1385, 3);
                      v1387 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v1385, v1385), 3), v1385);
                      v1388 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v1381, v1381), 3), v1381);
                      *v1378 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1386), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v1385, v1385, v1380, 3), vaddq_f32(vmulq_laneq_f32(v1386, v1380, 3), vmlsq_laneq_f32(v1380, v1380, v1385, 3))), v1387, v1380, 3), v1380, v1387), (float32x4_t)0), vbicq_s8(v1384, (int8x16_t)vceqzq_f32(v1385))),
                                     vbicq_s8((int8x16_t)v1385, v1384)),
                                   (int8x16_t)v1380));
                      v1378[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1382), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v1381, v1381, v1379, 3), vaddq_f32(vmulq_laneq_f32(v1382, v1379, 3), vmlsq_laneq_f32(v1379, v1379, v1381, 3))), v1388, v1379, 3), v1379, v1388), (float32x4_t)0), vbicq_s8(v1383, (int8x16_t)vceqzq_f32(v1381))),
                                       vbicq_s8((int8x16_t)v1381, v1383)),
                                     (int8x16_t)v1379));
                      v1376 += v515;
                    }
                    v47 += v1376;
                    v26 = (float32x4_t *)((char *)v26 + v1376);
                  }
                  for (i62 = i61 + v1546 - v1375; i62; --i62)
                  {
                    v1390 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v509), v510);
                    v1391 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v513), v514);
                    v1392 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1390, 3);
                    v1393 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1391, 3));
                    v1394 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v1390, v1390), 3), v1390);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1392), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v1390, v1390, v1391, 3), vaddq_f32(vmlsq_laneq_f32(v1391, v1391, v1390, 3), vmulq_laneq_f32(v1392, v1391, 3))), v1394, v1391, 3), v1391, v1394), (float32x4_t)0), vbicq_s8(v1393, (int8x16_t)vceqzq_f32(v1390))),
                                              vbicq_s8((int8x16_t)v1390, v1393)),
                                            (int8x16_t)v1391));
                    v1395 = v47 + 16 * v1541;
                    if (v1395 >= v1373)
                      v1396 = -(uint64_t)(int)v1545;
                    else
                      v1396 = 0;
                    v47 = v1395 + 16 * v1396;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1397 = v1374 + 16 * v1549;
                  if (v1397 >= v1548)
                    v1398 = -(uint64_t)(v1549 * v1542);
                  else
                    v1398 = 0;
                  v1399 = v1397 + 16 * v1398;
                  v1400 = v1373 + 16 * v1398 + 16 * v1549;
                  if (v1548)
                    v47 = v1399;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1373 = v1400;
                    v1374 = v1399;
                  }
                  _VF = __OFSUB__(v506--, 1);
                }
                while (!((v506 < 0) ^ _VF | (v506 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v506 = v1552;
          }
          while (1)
          {
            v979 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1279;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v980 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1279;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v980 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1531) = LODWORD(a14);
              LODWORD(v1531) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAcolorburnPDA(v26->f32[0], a8, a9, a10, v980, a12, a13, a14, *(float *)v47, v1531, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1279:
              v981 = v47 + 16 * v1541;
              if (v981 >= v22)
                v982 = -(uint64_t)(int)v1545;
              else
                v982 = 0;
              v47 = v981 + 16 * v982;
              v26 += v1541;
              --v979;
            }
            while (v979);
            v26 += v1547;
            v983 = v1550;
            v984 = v1550 + 16 * v1549;
            v985 = -(uint64_t)(v1549 * v1542);
            if (v984 < v1548)
              v985 = 0;
            v986 = v984 + 16 * v985;
            v987 = v22 + 16 * v985 + 16 * v1549;
            if (v1548)
            {
              v22 = v987;
              v983 = v986;
            }
            v1550 = v983;
            if (v1548)
              v47 = v986;
            else
              v47 += 16 * v1549;
            if (!--v506)
              goto LABEL_1335;
          }
        case 20:
          v1540 = v48;
          if (v45)
          {
            v544 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v545 = 0;
              else
                v545 = -1;
              v546.i64[0] = 0;
              v546.i32[2] = 0;
              v547.i64[0] = 0;
              v547.i32[2] = 0;
              v547.i32[3] = v545;
              v548 = vmvnq_s8(v547);
              v549 = vandq_s8((int8x16_t)vdupq_n_s32(v545), (int8x16_t)xmmword_185004D50);
              if (v20)
                v550 = 0;
              else
                v550 = -1;
              v546.i32[3] = v550;
              v551 = vmvnq_s8(v546);
              v552 = vandq_s8((int8x16_t)vdupq_n_s32(v550), (int8x16_t)xmmword_185004D50);
              v553 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v554 = v22;
                v555 = v1550;
                do
                {
                  v556 = (v554 - v47) >> 4;
                  if (v556 >= v1546)
                    v556 = v1546;
                  if (v556 < 2)
                  {
                    i63 = v556;
                  }
                  else
                  {
                    v557 = 0;
                    for (i63 = v556; i63 > 1; i63 -= 2)
                    {
                      v559 = (int8x16_t *)((char *)v26 + v557);
                      v560 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v557), v551), v552);
                      v561 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v557), v551), v552);
                      v562 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v560, 3);
                      v563 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v561, 3);
                      v564 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v557), v548), v549);
                      v565 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v557 + 16), v548), v549);
                      v566 = (int8x16_t)vcgtzq_f32(v562);
                      v567 = (int8x16_t)vcgtzq_f32(v563);
                      v568 = (int8x16_t)vceqzq_f32(v562);
                      v569 = (int8x16_t)vceqzq_f32(v563);
                      v570 = vdivq_f32(v560, v562);
                      v571 = vaddq_f32(v565, v565);
                      v572 = vdivq_f32(v561, v563);
                      v573 = vaddq_f32(v564, v564);
                      v574 = vmlaq_laneq_f32(vmlsq_f32(v571, v570, v571), v570, v565, 3);
                      v575 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v573, v572, v573), v572, v564, 3), v561);
                      v576 = vmulq_f32(v574, v560);
                      *v559 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v564, 3)), vbslq_s8(v567, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v564, v564, v561, 3), vaddq_f32(vmlsq_laneq_f32(v561, v561, v564, 3), (float32x4_t)vandq_s8((int8x16_t)v575, vbicq_s8((int8x16_t)vcgezq_f32(v575), v569)))), (int8x16_t)v564), (int8x16_t)v561);
                      v559[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v565, 3)), vbslq_s8(v566, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v565, v565, v560, 3), vaddq_f32(vmlsq_laneq_f32(v560, v560, v565, 3), (float32x4_t)vandq_s8((int8x16_t)v576, vbicq_s8((int8x16_t)vcgezq_f32(v576), v568)))), (int8x16_t)v565), (int8x16_t)v560);
                      v557 += v553;
                    }
                    v47 += v557;
                    v26 = (float32x4_t *)((char *)v26 + v557);
                  }
                  for (i64 = i63 + v1546 - v556; i64; --i64)
                  {
                    v578 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v548), v549);
                    v579 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v551), v552);
                    v580 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v579, 3);
                    v581 = (int8x16_t)vcgtzq_f32(v580);
                    v582 = (int8x16_t)vceqzq_f32(v580);
                    v583 = vdivq_f32(v579, v580);
                    v584 = vaddq_f32(v578, v578);
                    v585 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v584, v583, v584), v583, v578, 3), v579);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v578, 3)), vbslq_s8(v581, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v578, v578, v579, 3), vaddq_f32(vmlsq_laneq_f32(v579, v579, v578, 3), (float32x4_t)vandq_s8((int8x16_t)v585, vbicq_s8((int8x16_t)vcgezq_f32(v585), v582)))), (int8x16_t)v578), (int8x16_t)v579);
                    v586 = v47 + 16 * v1541;
                    if (v586 >= v554)
                      v587 = -(uint64_t)(int)v1545;
                    else
                      v587 = 0;
                    v47 = v586 + 16 * v587;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v588 = v555 + 16 * v1549;
                  if (v588 >= v1548)
                    v589 = -(uint64_t)(v1549 * v1542);
                  else
                    v589 = 0;
                  v590 = v588 + 16 * v589;
                  v591 = v554 + 16 * v589 + 16 * v1549;
                  if (v1548)
                    v47 = v590;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v554 = v591;
                    v555 = v590;
                  }
                  _VF = __OFSUB__(v544--, 1);
                }
                while (!((v544 < 0) ^ _VF | (v544 == 0)));
              }
              else
              {
                v1401 = v22;
                v1402 = v1550;
                do
                {
                  v1403 = (v1401 - v47) >> 4;
                  if (v1403 >= v1546)
                    v1403 = v1546;
                  if (v1403 < 2)
                  {
                    i65 = v1403;
                  }
                  else
                  {
                    v1404 = 0;
                    for (i65 = v1403; i65 > 1; i65 -= 2)
                    {
                      v1406 = (int8x16_t *)((char *)v26 + v1404);
                      v1407 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1404)), v551), v552);
                      v1408 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1407, 3);
                      v1409 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1404)), v551), v552);
                      v1410 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1409, 3);
                      v1411 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1404 + 16)), v548), v549);
                      v1412 = (int8x16_t)vcgtzq_f32(v1408);
                      v1413 = (int8x16_t)vcgtzq_f32(v1410);
                      v1414 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1404)), v548), v549);
                      v1415 = (int8x16_t)vceqzq_f32(v1408);
                      v1416 = (int8x16_t)vceqzq_f32(v1410);
                      v1417 = vdivq_f32(v1409, v1410);
                      v1418 = vaddq_f32(v1411, v1411);
                      v1419 = vdivq_f32(v1407, v1408);
                      v1420 = vaddq_f32(v1414, v1414);
                      v1421 = vmlaq_laneq_f32(vmlsq_f32(v1420, v1419, v1420), v1419, v1414, 3);
                      v1422 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v1418, v1417, v1418), v1417, v1411, 3), v1409);
                      v1423 = vmulq_f32(v1421, v1407);
                      *v1406 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1414, 3)), vbslq_s8(v1412, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1414, v1414, v1407, 3), vaddq_f32(vmlsq_laneq_f32(v1407, v1407, v1414, 3), (float32x4_t)vandq_s8((int8x16_t)v1423, vbicq_s8((int8x16_t)vcgezq_f32(v1423), v1415)))), (int8x16_t)v1414), (int8x16_t)v1407));
                      v1406[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1411, 3)), vbslq_s8(v1413, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1411, v1411, v1409, 3), vaddq_f32(vmlsq_laneq_f32(v1409, v1409, v1411, 3), (float32x4_t)vandq_s8((int8x16_t)v1422, vbicq_s8((int8x16_t)vcgezq_f32(v1422), v1416)))), (int8x16_t)v1411), (int8x16_t)v1409));
                      v1404 += v553;
                    }
                    v47 += v1404;
                    v26 = (float32x4_t *)((char *)v26 + v1404);
                  }
                  for (i66 = i65 + v1546 - v1403; i66; --i66)
                  {
                    v1425 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v548), v549);
                    v1426 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v551), v552);
                    v1427 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1426, 3);
                    v1428 = (int8x16_t)vcgtzq_f32(v1427);
                    v1429 = (int8x16_t)vceqzq_f32(v1427);
                    v1430 = vdivq_f32(v1426, v1427);
                    v1431 = vaddq_f32(v1425, v1425);
                    v1432 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v1431, v1430, v1431), v1430, v1425, 3), v1426);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1425, 3)), vbslq_s8(v1428, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1425, v1425, v1426, 3), vaddq_f32(vmlsq_laneq_f32(v1426, v1426, v1425, 3), (float32x4_t)vandq_s8((int8x16_t)v1432, vbicq_s8((int8x16_t)vcgezq_f32(v1432), v1429)))), (int8x16_t)v1425), (int8x16_t)v1426));
                    v1433 = v47 + 16 * v1541;
                    if (v1433 >= v1401)
                      v1434 = -(uint64_t)(int)v1545;
                    else
                      v1434 = 0;
                    v47 = v1433 + 16 * v1434;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1435 = v1402 + 16 * v1549;
                  if (v1435 >= v1548)
                    v1436 = -(uint64_t)(v1549 * v1542);
                  else
                    v1436 = 0;
                  v1437 = v1435 + 16 * v1436;
                  v1438 = v1401 + 16 * v1436 + 16 * v1549;
                  if (v1548)
                    v47 = v1437;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1401 = v1438;
                    v1402 = v1437;
                  }
                  _VF = __OFSUB__(v544--, 1);
                }
                while (!((v544 < 0) ^ _VF | (v544 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v544 = v1552;
          }
          while (1)
          {
            v988 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1301;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                LODWORD(a11) = LODWORD(a10);
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1301;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                LODWORD(a11) = 1.0;
              }
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              DWORD2(v1525) = LODWORD(a14);
              *(_QWORD *)&v1525 = *(_QWORD *)(v47 + 4);
              v26->f32[0] = PDAsoftlightPDA(v26->f32[0], v26->f32[1], a9, *(int32x2_t *)&a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, v27, v28, *(float *)v47, v1525, *(uint64_t *)((char *)&v1525 + 4),
                              *(float *)&a12);
              v26->i32[1] = v989;
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1301:
              v990 = v47 + 16 * v1541;
              if (v990 >= v22)
                v991 = -(uint64_t)(int)v1545;
              else
                v991 = 0;
              v47 = v990 + 16 * v991;
              v26 += v1541;
              --v988;
            }
            while (v988);
            v26 += v1547;
            v992 = v1550;
            v993 = v1550 + 16 * v1549;
            v994 = -(uint64_t)(v1549 * v1542);
            if (v993 < v1548)
              v994 = 0;
            v995 = v993 + 16 * v994;
            v996 = v22 + 16 * v994 + 16 * v1549;
            if (v1548)
            {
              v22 = v996;
              v992 = v995;
            }
            v1550 = v992;
            if (v1548)
              v47 = v995;
            else
              v47 += 16 * v1549;
            if (!--v544)
              goto LABEL_1335;
          }
        case 21:
          v1540 = v48;
          if (v45)
          {
            v592 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v593 = 0;
              else
                v593 = -1;
              v594.i64[0] = 0;
              v594.i32[2] = 0;
              v595.i64[0] = 0;
              v595.i32[2] = 0;
              v595.i32[3] = v593;
              v596 = vmvnq_s8(v595);
              v597 = vandq_s8((int8x16_t)vdupq_n_s32(v593), (int8x16_t)xmmword_185004D50);
              if (v20)
                v598 = 0;
              else
                v598 = -1;
              v594.i32[3] = v598;
              v599 = vmvnq_s8(v594);
              v600 = vandq_s8((int8x16_t)vdupq_n_s32(v598), (int8x16_t)xmmword_185004D50);
              v601 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v602.i64[0] = 0x3F0000003F000000;
                v602.i64[1] = 0x3F0000003F000000;
                v603.i64[0] = 0x8000000080000000;
                v603.i64[1] = 0x8000000080000000;
                v604 = v22;
                v605 = v1550;
                do
                {
                  v606 = (v604 - v47) >> 4;
                  if (v606 >= v1546)
                    v606 = v1546;
                  if (v606 < 2)
                  {
                    i67 = v606;
                  }
                  else
                  {
                    v607 = 0;
                    for (i67 = v606; i67 > 1; i67 -= 2)
                    {
                      v609 = (int8x16_t *)((char *)v26 + v607);
                      v610 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v607), v596), v597);
                      v611 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v607 + 16), v596), v597);
                      v612 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v607), v599), v600);
                      v613 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v611, 3);
                      v614 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v610, 3);
                      v615 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v607), v599), v600);
                      v616 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v615, 3);
                      v617 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v612, 3);
                      v618 = (int8x16_t)vcgtq_f32(v610, vmulq_laneq_f32(v602, v610, 3));
                      v619 = (int8x16_t)vcgtq_f32(v611, vmulq_laneq_f32(v602, v611, 3));
                      v620 = vbicq_s8(v603, v619);
                      v621 = vbicq_s8(v603, v618);
                      *v609 = vbslq_s8((int8x16_t)vcgtzq_f32(v614), vbslq_s8((int8x16_t)vcgtzq_f32(v616), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v615, (float32x4_t)veorq_s8(v621, (int8x16_t)vsubq_f32(v614, v610)), v615), vmlaq_f32(v610, (float32x4_t)veorq_s8(v621, (int8x16_t)vsubq_f32(v616, v615)), v610)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v614, v615, 3), v618)), (int8x16_t)v610), (int8x16_t)v615);
                      v609[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v613), vbslq_s8((int8x16_t)vcgtzq_f32(v617), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v612, (float32x4_t)veorq_s8(v620, (int8x16_t)vsubq_f32(v613, v611)), v612), vmlaq_f32(v611, (float32x4_t)veorq_s8(v620, (int8x16_t)vsubq_f32(v617, v612)), v611)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v613, v612, 3), v619)), (int8x16_t)v611), (int8x16_t)v612);
                      v607 += v601;
                    }
                    v47 += v607;
                    v26 = (float32x4_t *)((char *)v26 + v607);
                  }
                  for (i68 = i67 + v1546 - v606; i68; --i68)
                  {
                    v623 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v596), v597);
                    v624 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v599), v600);
                    v625 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v623, 3);
                    v626 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v624, 3);
                    v627 = (int8x16_t)vcgtq_f32(v623, vmulq_laneq_f32(v602, v623, 3));
                    v628 = vbicq_s8(v603, v627);
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v625), vbslq_s8((int8x16_t)vcgtzq_f32(v626), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v624, (float32x4_t)veorq_s8(v628, (int8x16_t)vsubq_f32(v625, v623)), v624), vmlaq_f32(v623, (float32x4_t)veorq_s8(v628, (int8x16_t)vsubq_f32(v626, v624)), v623)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v625, v624, 3),
                                                                        v627)),
                                            (int8x16_t)v623),
                                          (int8x16_t)v624);
                    v629 = v47 + 16 * v1541;
                    if (v629 >= v604)
                      v630 = -(uint64_t)(int)v1545;
                    else
                      v630 = 0;
                    v47 = v629 + 16 * v630;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v631 = v605 + 16 * v1549;
                  if (v631 >= v1548)
                    v632 = -(uint64_t)(v1549 * v1542);
                  else
                    v632 = 0;
                  v633 = v631 + 16 * v632;
                  v634 = v604 + 16 * v632 + 16 * v1549;
                  if (v1548)
                    v47 = v633;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v604 = v634;
                    v605 = v633;
                  }
                  _VF = __OFSUB__(v592--, 1);
                }
                while (!((v592 < 0) ^ _VF | (v592 == 0)));
              }
              else
              {
                v1439.i64[0] = 0x3F0000003F000000;
                v1439.i64[1] = 0x3F0000003F000000;
                v1440.i64[0] = 0x8000000080000000;
                v1440.i64[1] = 0x8000000080000000;
                v1441 = v22;
                v1442 = v1550;
                do
                {
                  v1443 = (v1441 - v47) >> 4;
                  if (v1443 >= v1546)
                    v1443 = v1546;
                  if (v1443 < 2)
                  {
                    i69 = v1443;
                  }
                  else
                  {
                    v1444 = 0;
                    for (i69 = v1443; i69 > 1; i69 -= 2)
                    {
                      v1446 = (int8x16_t *)((char *)v26 + v1444);
                      v1447 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1444 + 16)), v596), v597);
                      v1448 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1444)), v596), v597);
                      v1449 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1444)), v599), v600);
                      v1450 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1448, 3);
                      v1451 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1447, 3);
                      v1452 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1449, 3);
                      v1453 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1444)), v599), v600);
                      v1454 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1453, 3);
                      v1455 = (int8x16_t)vcgtq_f32(v1447, vmulq_laneq_f32(v1439, v1447, 3));
                      v1456 = (int8x16_t)vcgtq_f32(v1448, vmulq_laneq_f32(v1439, v1448, 3));
                      v1457 = vbicq_s8(v1440, v1456);
                      v1458 = vbicq_s8(v1440, v1455);
                      *v1446 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1450), vbslq_s8((int8x16_t)vcgtzq_f32(v1454), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1453, (float32x4_t)veorq_s8(v1457, (int8x16_t)vsubq_f32(v1450, v1448)), v1453), vmlaq_f32(v1448, (float32x4_t)veorq_s8(v1457, (int8x16_t)vsubq_f32(v1454, v1453)), v1448)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v1450, v1453, 3), v1456)), (int8x16_t)v1448), (int8x16_t)v1453));
                      v1446[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1451), vbslq_s8((int8x16_t)vcgtzq_f32(v1452), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1449, (float32x4_t)veorq_s8(v1458, (int8x16_t)vsubq_f32(v1451, v1447)), v1449), vmlaq_f32(v1447, (float32x4_t)veorq_s8(v1458, (int8x16_t)vsubq_f32(v1452, v1449)), v1447)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v1451, v1449, 3), v1455)), (int8x16_t)v1447), (int8x16_t)v1449));
                      v1444 += v601;
                    }
                    v47 += v1444;
                    v26 = (float32x4_t *)((char *)v26 + v1444);
                  }
                  for (i70 = i69 + v1546 - v1443; i70; --i70)
                  {
                    v1460 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v596), v597);
                    v1461 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1460, 3);
                    v1462 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v599), v600);
                    v1463 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1462, 3);
                    v1464 = (int8x16_t)vcgtq_f32(v1460, vmulq_laneq_f32(v1439, v1460, 3));
                    v1465 = vbicq_s8(v1440, v1464);
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1461), vbslq_s8((int8x16_t)vcgtzq_f32(v1463), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1462, (float32x4_t)veorq_s8(v1465, (int8x16_t)vsubq_f32(v1461, v1460)), v1462), vmlaq_f32(v1460, (float32x4_t)veorq_s8(v1465, (int8x16_t)vsubq_f32(v1463, v1462)), v1460)), (float32x4_t)vandq_s8(
                                                                          (int8x16_t)vmulq_laneq_f32(v1461, v1462, 3),
                                                                          v1464)),
                                              (int8x16_t)v1460),
                                            (int8x16_t)v1462));
                    v1466 = v47 + 16 * v1541;
                    if (v1466 >= v1441)
                      v1467 = -(uint64_t)(int)v1545;
                    else
                      v1467 = 0;
                    v47 = v1466 + 16 * v1467;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1468 = v1442 + 16 * v1549;
                  if (v1468 >= v1548)
                    v1469 = -(uint64_t)(v1549 * v1542);
                  else
                    v1469 = 0;
                  v1470 = v1468 + 16 * v1469;
                  v1471 = v1441 + 16 * v1469 + 16 * v1549;
                  if (v1548)
                    v47 = v1470;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1441 = v1471;
                    v1442 = v1470;
                  }
                  _VF = __OFSUB__(v592--, 1);
                }
                while (!((v592 < 0) ^ _VF | (v592 == 0)));
              }
              goto LABEL_1336;
            }
            v1537 = v32;
          }
          else
          {
            v1537 = v32;
            v592 = v1552;
          }
          while (1)
          {
            v997 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_1323;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v998 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1323;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v998 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1532) = LODWORD(a14);
              LODWORD(v1532) = HIDWORD(*(_QWORD *)(v47 + 4));
              v26->f32[0] = PDAhardlightPDA(v26->f32[0], a8, a9, a10, v998, a12, a13, a14, *(float *)v47, v1532, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1323:
              v999 = v47 + 16 * v1541;
              if (v999 >= v22)
                v1000 = -(uint64_t)(int)v1545;
              else
                v1000 = 0;
              v47 = v999 + 16 * v1000;
              v26 += v1541;
              --v997;
            }
            while (v997);
            v26 += v1547;
            v1001 = v1550;
            v1002 = v1550 + 16 * v1549;
            v1003 = -(uint64_t)(v1549 * v1542);
            if (v1002 < v1548)
              v1003 = 0;
            v1004 = v1002 + 16 * v1003;
            v1005 = v22 + 16 * v1003 + 16 * v1549;
            if (v1548)
            {
              v22 = v1005;
              v1001 = v1004;
            }
            v1550 = v1001;
            if (v1548)
              v47 = v1004;
            else
              v47 += 16 * v1549;
            if (!--v592)
              goto LABEL_1335;
          }
        case 22:
          if (v45)
          {
            v635 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v636 = 0;
              else
                v636 = -1;
              v637.i64[0] = 0;
              v637.i32[2] = 0;
              v638.i64[0] = 0;
              v638.i32[2] = 0;
              v638.i32[3] = v636;
              v639 = vmvnq_s8(v638);
              v640 = vandq_s8((int8x16_t)vdupq_n_s32(v636), (int8x16_t)xmmword_185004D50);
              if (v20)
                v641 = 0;
              else
                v641 = -1;
              v637.i32[3] = v641;
              v642 = vmvnq_s8(v637);
              v643 = vandq_s8((int8x16_t)vdupq_n_s32(v641), (int8x16_t)xmmword_185004D50);
              v644 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v645 = v22;
                v646 = v1550;
                do
                {
                  v647 = (v645 - v47) >> 4;
                  if (v647 >= v1546)
                    v647 = v1546;
                  if (v647 < 2)
                  {
                    i71 = v647;
                  }
                  else
                  {
                    v648 = 0;
                    for (i71 = v647; i71 > 1; i71 -= 2)
                    {
                      v650 = (int8x16_t *)((char *)v26 + v648);
                      v651 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v648), v642), v643);
                      v652 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v651, 3);
                      v653 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v648), v642), v643);
                      v654 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v653, 3);
                      v655 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v648), v639), v640);
                      v656 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v655, 3);
                      v657 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v648 + 16), v639), v640);
                      v658 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v657, 3);
                      v659 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v653, v653, v655, 3), vmlsq_laneq_f32(v655, v655, v653, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v653, v655, 3), vmulq_laneq_f32(v655, v653, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
                      v660 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v651, v651, v657, 3), vmlsq_laneq_f32(v657, v657, v651, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v651, v657, 3), vmulq_laneq_f32(v657, v651, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
                      v660.i32[3] = vaddq_f32(v657, vmlsq_laneq_f32(v652, v658, v651, 3)).i32[3];
                      v659.i32[3] = vaddq_f32(v655, vmlsq_laneq_f32(v654, v656, v653, 3)).i32[3];
                      *v650 = vbslq_s8((int8x16_t)vcgtzq_f32(v656), vbslq_s8((int8x16_t)vcgtzq_f32(v654), v659, (int8x16_t)v655), (int8x16_t)v653);
                      v650[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v658), vbslq_s8((int8x16_t)vcgtzq_f32(v652), v660, (int8x16_t)v657), (int8x16_t)v651);
                      v648 += v644;
                    }
                    v47 += v648;
                    v26 = (float32x4_t *)((char *)v26 + v648);
                  }
                  for (i72 = i71 + v1546 - v647; i72; --i72)
                  {
                    v662 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v639), v640);
                    v663 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v642), v643);
                    v664 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v662, 3);
                    v665 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v663, 3);
                    v666 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v663, v663, v662, 3), vmlsq_laneq_f32(v662, v662, v663, 3)), vabdq_f32(vmulq_laneq_f32(v663, v662, 3), vmulq_laneq_f32(v662, v663, 3)));
                    v666.i32[3] = vaddq_f32(v662, vmlsq_laneq_f32(v665, v664, v663, 3)).i32[3];
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v664), vbslq_s8((int8x16_t)vcgtzq_f32(v665), v666, (int8x16_t)v662), (int8x16_t)v663);
                    v667 = v47 + 16 * v1541;
                    if (v667 >= v645)
                      v668 = -(uint64_t)(int)v1545;
                    else
                      v668 = 0;
                    v47 = v667 + 16 * v668;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v669 = v646 + 16 * v1549;
                  if (v669 >= v1548)
                    v670 = -(uint64_t)(v1549 * v1542);
                  else
                    v670 = 0;
                  v671 = v669 + 16 * v670;
                  v672 = v645 + 16 * v670 + 16 * v1549;
                  if (v1548)
                    v47 = v671;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v645 = v672;
                    v646 = v671;
                  }
                  _VF = __OFSUB__(v635--, 1);
                }
                while (!((v635 < 0) ^ _VF | (v635 == 0)));
              }
              else
              {
                v1472 = v22;
                v1473 = v1550;
                do
                {
                  v1474 = (v1472 - v47) >> 4;
                  if (v1474 >= v1546)
                    v1474 = v1546;
                  if (v1474 < 2)
                  {
                    i73 = v1474;
                  }
                  else
                  {
                    v1475 = 0;
                    for (i73 = v1474; i73 > 1; i73 -= 2)
                    {
                      v1477 = (int8x16_t *)((char *)v26 + v1475);
                      v1478 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1475)), v642), v643);
                      v1479 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1475)), v642), v643);
                      v1480 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1478, 3);
                      v1481 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1479, 3);
                      v1482 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1475 + 16)), v639), v640);
                      v1483 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1482, 3);
                      v1484 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1475)), v639), v640);
                      v1485 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1484, 3);
                      v1486 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v1479, v1479, v1482, 3), vmlsq_laneq_f32(v1482, v1482, v1479, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v1479, v1482, 3), vmulq_laneq_f32(v1482, v1479, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
                      v1487 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v1478, v1478, v1484, 3), vmlsq_laneq_f32(v1484, v1484, v1478, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v1478, v1484, 3), vmulq_laneq_f32(v1484, v1478, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
                      v1487.i32[3] = vaddq_f32(v1484, vmlsq_laneq_f32(v1480, v1485, v1478, 3)).i32[3];
                      v1486.i32[3] = vaddq_f32(v1482, vmlsq_laneq_f32(v1481, v1483, v1479, 3)).i32[3];
                      *v1477 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1485), vbslq_s8((int8x16_t)vcgtzq_f32(v1480), v1487, (int8x16_t)v1484), (int8x16_t)v1478));
                      v1477[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1483), vbslq_s8((int8x16_t)vcgtzq_f32(v1481), v1486, (int8x16_t)v1482), (int8x16_t)v1479));
                      v1475 += v644;
                    }
                    v47 += v1475;
                    v26 = (float32x4_t *)((char *)v26 + v1475);
                  }
                  for (i74 = i73 + v1546 - v1474; i74; --i74)
                  {
                    v1489 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v639), v640);
                    v1490 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v642), v643);
                    v1491 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1489, 3);
                    v1492 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1490, 3);
                    v1493 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v1490, v1490, v1489, 3), vmlsq_laneq_f32(v1489, v1489, v1490, 3)), vabdq_f32(vmulq_laneq_f32(v1490, v1489, 3), vmulq_laneq_f32(v1489, v1490, 3)));
                    v1493.i32[3] = vaddq_f32(v1489, vmlsq_laneq_f32(v1492, v1491, v1490, 3)).i32[3];
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1491), vbslq_s8((int8x16_t)vcgtzq_f32(v1492), v1493, (int8x16_t)v1489), (int8x16_t)v1490));
                    v1494 = v47 + 16 * v1541;
                    if (v1494 >= v1472)
                      v1495 = -(uint64_t)(int)v1545;
                    else
                      v1495 = 0;
                    v47 = v1494 + 16 * v1495;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1496 = v1473 + 16 * v1549;
                  if (v1496 >= v1548)
                    v1497 = -(uint64_t)(v1549 * v1542);
                  else
                    v1497 = 0;
                  v1498 = v1496 + 16 * v1497;
                  v1499 = v1472 + 16 * v1497 + 16 * v1549;
                  if (v1548)
                    v47 = v1498;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1472 = v1499;
                    v1473 = v1498;
                  }
                  _VF = __OFSUB__(v635--, 1);
                }
                while (!((v635 < 0) ^ _VF | (v635 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v635 = v1552;
          }
          do
          {
            v883 = v1546;
            do
            {
              v884 = 1.0;
              v885 = 1.0;
              if (!v44 || (v885 = *(float *)(v47 + 12), v885 > 0.0))
              {
                if (v20 && (v884 = v26->f32[3], v884 <= 0.0))
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->f32[3] = v885;
                }
                else
                {
                  v886 = v26->f32[2];
                  v887 = *(float *)(v47 + 8);
                  v888 = vmul_n_f32(*(float32x2_t *)v26->f32, v885);
                  v889 = vmul_n_f32(*(float32x2_t *)v47, v884);
                  v890 = vsub_f32(vadd_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47), v888);
                  v891 = vsub_f32(v888, v889);
                  v892 = vadd_f32(vsub_f32(v890, v889), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v891), (int8x8_t)vneg_f32(v891), (int8x8_t)v891));
                  v889.f32[0] = v886 + v887;
                  v893 = v886 * v885;
                  v894 = v887 * v884;
                  v889.f32[0] = v889.f32[0] - v893;
                  v895 = v893 - v894;
                  v896 = v889.f32[0] - v894;
                  if (v895 < 0.0)
                    v895 = -v895;
                  *(float32x2_t *)v26->f32 = v892;
                  v26->f32[2] = v896 + v895;
                  v26->f32[3] = (float)(v884 + v885) - (float)(v884 * v885);
                }
              }
              v897 = v47 + 16 * v1541;
              if (v897 >= v22)
                v898 = -(uint64_t)(int)v1545;
              else
                v898 = 0;
              v47 = v897 + 16 * v898;
              v26 += v1541;
              --v883;
            }
            while (v883);
            v26 += v1547;
            v899 = v1550;
            v900 = v1550 + 16 * v1549;
            if (v900 >= v1548)
              v901 = -(uint64_t)(v1549 * v1542);
            else
              v901 = 0;
            v902 = v900 + 16 * v901;
            v903 = v22 + 16 * v901 + 16 * v1549;
            if (v1548)
            {
              v22 = v903;
              v899 = v902;
            }
            v1550 = v899;
            if (v1548)
              v47 = v902;
            else
              v47 += 16 * v1549;
            --v635;
          }
          while (v635);
          goto LABEL_1352;
        case 23:
          if (v45)
          {
            v673 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44)
                v674 = 0;
              else
                v674 = -1;
              v675.i64[0] = 0;
              v675.i32[2] = 0;
              v676.i64[0] = 0;
              v676.i32[2] = 0;
              v676.i32[3] = v674;
              v677 = vmvnq_s8(v676);
              v678 = vandq_s8((int8x16_t)vdupq_n_s32(v674), (int8x16_t)xmmword_185004D50);
              if (v20)
                v679 = 0;
              else
                v679 = -1;
              v675.i32[3] = v679;
              v680 = vmvnq_s8(v675);
              v681 = vandq_s8((int8x16_t)vdupq_n_s32(v679), (int8x16_t)xmmword_185004D50);
              v682 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v683 = v22;
                v684 = v1550;
                do
                {
                  v685 = (v683 - v47) >> 4;
                  if (v685 >= v1546)
                    v685 = v1546;
                  if (v685 < 2)
                  {
                    i75 = v685;
                  }
                  else
                  {
                    v686 = 0;
                    for (i75 = v685; i75 > 1; i75 -= 2)
                    {
                      v688 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v686 + 16), v677), v678);
                      v689 = (int8x16_t *)((char *)v26 + v686);
                      v690 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v686), v677), v678);
                      v691 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v686), v680), v681);
                      v692 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v686), v680), v681);
                      v693 = vmlsq_f32(v690, v691, v690);
                      v694 = vmlsq_f32(v688, v692, v688);
                      v693.i32[3] = v690.i32[3];
                      v694.i32[3] = v688.i32[3];
                      *v689 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v690, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v691, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v691, v690, v691), v693), (int8x16_t)v690), (int8x16_t)v691);
                      v689[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v688, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v692, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v692, v688, v692), v694), (int8x16_t)v688), (int8x16_t)v692);
                      v686 += v682;
                    }
                    v47 += v686;
                    v26 = (float32x4_t *)((char *)v26 + v686);
                  }
                  for (i76 = i75 + v1546 - v685; i76; --i76)
                  {
                    v696 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v677), v678);
                    v697 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v680), v681);
                    v698 = vmlsq_f32(v696, v697, v696);
                    v698.i32[3] = v696.i32[3];
                    *(int8x16_t *)v26 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v696)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v697)), 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v697, v696, v697), v698), (int8x16_t)v696), (int8x16_t)v697);
                    v699 = v47 + 16 * v1541;
                    if (v699 >= v683)
                      v700 = -(uint64_t)(int)v1545;
                    else
                      v700 = 0;
                    v47 = v699 + 16 * v700;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v701 = v684 + 16 * v1549;
                  if (v701 >= v1548)
                    v702 = -(uint64_t)(v1549 * v1542);
                  else
                    v702 = 0;
                  v703 = v701 + 16 * v702;
                  v704 = v683 + 16 * v702 + 16 * v1549;
                  if (v1548)
                    v47 = v703;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v683 = v704;
                    v684 = v703;
                  }
                  _VF = __OFSUB__(v673--, 1);
                }
                while (!((v673 < 0) ^ _VF | (v673 == 0)));
              }
              else
              {
                v1500 = v22;
                v1501 = v1550;
                do
                {
                  v1502 = (v1500 - v47) >> 4;
                  if (v1502 >= v1546)
                    v1502 = v1546;
                  if (v1502 < 2)
                  {
                    i77 = v1502;
                  }
                  else
                  {
                    v1503 = 0;
                    for (i77 = v1502; i77 > 1; i77 -= 2)
                    {
                      v1505 = (int8x16_t *)((char *)v26 + v1503);
                      v1506 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1503)), v677), v678);
                      v1507 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1503 + 16)), v677), v678);
                      v1508 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1503)), v680), v681);
                      v1509 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1503)), v680), v681);
                      v1510 = vmlsq_f32(v1506, v1509, v1506);
                      v1511 = vmlsq_f32(v1507, v1508, v1507);
                      v1511.i32[3] = v1507.i32[3];
                      v1510.i32[3] = v1506.i32[3];
                      *v1505 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1506, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1509, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v1509, v1506, v1509), v1510), (int8x16_t)v1506), (int8x16_t)v1509));
                      v1505[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1507, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1508, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v1508, v1507, v1508), v1511), (int8x16_t)v1507), (int8x16_t)v1508));
                      v1503 += v682;
                    }
                    v47 += v1503;
                    v26 = (float32x4_t *)((char *)v26 + v1503);
                  }
                  for (i78 = i77 + v1546 - v1502; i78; --i78)
                  {
                    v1513 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v680), v681);
                    v1514 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v677), v678);
                    v1515 = vmlsq_f32(v1514, v1513, v1514);
                    v1515.i32[3] = v1514.i32[3];
                    *(int8x16_t *)v26 = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v1514)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v1513)), 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v1513, v1514, v1513), v1515), (int8x16_t)v1514), (int8x16_t)v1513));
                    v1516 = v47 + 16 * v1541;
                    if (v1516 >= v1500)
                      v1517 = -(uint64_t)(int)v1545;
                    else
                      v1517 = 0;
                    v47 = v1516 + 16 * v1517;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  v1518 = v1501 + 16 * v1549;
                  if (v1518 >= v1548)
                    v1519 = -(uint64_t)(v1549 * v1542);
                  else
                    v1519 = 0;
                  v1520 = v1518 + 16 * v1519;
                  v1521 = v1500 + 16 * v1519 + 16 * v1549;
                  if (v1548)
                    v47 = v1520;
                  else
                    v47 += 16 * v1549;
                  if (v1548)
                  {
                    v1500 = v1521;
                    v1501 = v1520;
                  }
                  _VF = __OFSUB__(v673--, 1);
                }
                while (!((v673 < 0) ^ _VF | (v673 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            v673 = v1552;
          }
          do
          {
            v904 = v1546;
            do
            {
              v905 = 1.0;
              v906 = 1.0;
              if (!v44 || (v906 = *(float *)(v47 + 12), v906 > 0.0))
              {
                if (v20 && (v905 = v26->f32[3], v905 <= 0.0))
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                }
                else
                {
                  v907 = (float)(v26->f32[2] + *(float *)(v47 + 8))
                       + (float)((float)(*(float *)(v47 + 8) * v26->f32[2]) * -2.0);
                  *(float32x2_t *)v26->f32 = vmla_f32(vadd_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v47, *(float32x2_t *)v26->f32));
                  v906 = (float)(v906 + v905) - (float)(v905 * v906);
                  v26->f32[2] = v907;
                }
                v26->f32[3] = v906;
              }
              v908 = v47 + 16 * v1541;
              if (v908 >= v22)
                v909 = -(uint64_t)(int)v1545;
              else
                v909 = 0;
              v47 = v908 + 16 * v909;
              v26 += v1541;
              --v904;
            }
            while (v904);
            v26 += v1547;
            v910 = v1550;
            v911 = v1550 + 16 * v1549;
            if (v911 >= v1548)
              v912 = -(uint64_t)(v1549 * v1542);
            else
              v912 = 0;
            v913 = v911 + 16 * v912;
            v914 = v22 + 16 * v912 + 16 * v1549;
            if (v1548)
            {
              v22 = v914;
              v910 = v913;
            }
            v1550 = v910;
            if (v1548)
              v47 = v913;
            else
              v47 += 16 * v1549;
            --v673;
          }
          while (v673);
          goto LABEL_1352;
        case 24:
          v1540 = v48;
          v1537 = v32;
          v705 = v1552;
          while (1)
          {
            v706 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_731;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v707 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_731;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v707 = 1.0;
              }
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              v26->f32[0] = PDAhuePDA(v26->f32[0], v26->f32[1], v26->f32[2], a10, v707, a12, a13, a14, *(float *)v47, COERCE_FLOAT(*(_QWORD *)(v47 + 4)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v47 + 4))), *(float *)&a14, *(float *)&a12);
              v26->i32[1] = v708;
              v26->i32[2] = v709;
              v26->i32[3] = LODWORD(a10);
LABEL_731:
              v710 = v47 + 16 * v1541;
              if (v710 >= v22)
                v711 = -(uint64_t)(int)v1545;
              else
                v711 = 0;
              v47 = v710 + 16 * v711;
              v26 += v1541;
              --v706;
            }
            while (v706);
            v26 += v1547;
            v712 = v1550;
            v713 = v1550 + 16 * v1549;
            v714 = -(uint64_t)(v1549 * v1542);
            if (v713 < v1548)
              v714 = 0;
            v715 = v713 + 16 * v714;
            v716 = v22 + 16 * v714 + 16 * v1549;
            if (v1548)
            {
              v22 = v716;
              v712 = v715;
            }
            v1550 = v712;
            if (v1548)
              v47 = v715;
            else
              v47 += 16 * v1549;
            if (!--v705)
              goto LABEL_1335;
          }
        case 25:
          v1540 = v48;
          v1537 = v32;
          v717 = v1552;
          while (1)
          {
            v718 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0)
                  goto LABEL_753;
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                v719 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_753;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                v719 = 1.0;
              }
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              v26->f32[0] = PDAsaturationPDA(v26->f32[0], v26->f32[1], v26->f32[2], a10, v719, a12, a13, a14, *(float *)v47, COERCE_FLOAT(*(_QWORD *)(v47 + 4)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v47 + 4))), *(float *)&a14, *(float *)&a12);
              v26->i32[1] = v720;
              v26->i32[2] = v721;
              v26->i32[3] = LODWORD(a10);
LABEL_753:
              v722 = v47 + 16 * v1541;
              if (v722 >= v22)
                v723 = -(uint64_t)(int)v1545;
              else
                v723 = 0;
              v47 = v722 + 16 * v723;
              v26 += v1541;
              --v718;
            }
            while (v718);
            v26 += v1547;
            v724 = v1550;
            v725 = v1550 + 16 * v1549;
            v726 = -(uint64_t)(v1549 * v1542);
            if (v725 < v1548)
              v726 = 0;
            v727 = v725 + 16 * v726;
            v728 = v22 + 16 * v726 + 16 * v1549;
            if (v1548)
            {
              v22 = v728;
              v724 = v727;
            }
            v1550 = v724;
            if (v1548)
              v47 = v727;
            else
              v47 += 16 * v1549;
            if (!--v717)
              goto LABEL_1335;
          }
        case 26:
          v1540 = v48;
          v1537 = v32;
          v729 = v1552;
          while (1)
          {
            v730 = v1546;
            do
            {
              v731 = 1.0;
              if (v44)
              {
                v731 = *(float *)(v47 + 12);
                if (v731 <= 0.0)
                  goto LABEL_775;
              }
              if (v20)
              {
                LODWORD(a12) = v26->i32[3];
                LODWORD(a13) = LODWORD(a12);
                if (*(float *)&a12 <= 0.0)
                {
                  v26->i64[0] = *(_QWORD *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->f32[3] = v731;
                  goto LABEL_775;
                }
              }
              else
              {
                LODWORD(a12) = v26->i32[3];
                LODWORD(a13) = 1.0;
              }
              LODWORD(a10) = *(_DWORD *)(v47 + 12);
              LODWORD(a14) = v26->i32[2];
              v26->f32[0] = PDAluminosityPDA(*(float *)v47, *(float *)(v47 + 4), *(float *)(v47 + 8), a10, v731, a12, a13, a14, COERCE_FLOAT(v26->i64[0]), COERCE_FLOAT(HIDWORD(v26->i64[0])), *(float *)&a14, *(float *)&a12, *(float *)&a13);
              v26->i32[1] = v732;
              v26->i32[2] = v733;
              v26->i32[3] = LODWORD(a10);
LABEL_775:
              v734 = v47 + 16 * v1541;
              if (v734 >= v22)
                v735 = -(uint64_t)(int)v1545;
              else
                v735 = 0;
              v47 = v734 + 16 * v735;
              v26 += v1541;
              --v730;
            }
            while (v730);
            v26 += v1547;
            v736 = v1550;
            v737 = v1550 + 16 * v1549;
            v738 = -(uint64_t)(v1549 * v1542);
            if (v737 < v1548)
              v738 = 0;
            v739 = v737 + 16 * v738;
            v740 = v22 + 16 * v738 + 16 * v1549;
            if (v1548)
            {
              v22 = v740;
              v736 = v739;
            }
            v1550 = v736;
            if (v1548)
              v47 = v739;
            else
              v47 += 16 * v1549;
            if (!--v729)
              goto LABEL_1335;
          }
        case 27:
          v1540 = v48;
          v1537 = v32;
          v741 = v1552;
          break;
        default:
          goto LABEL_1353;
      }
      break;
    }
LABEL_789:
    v742 = v1546;
    while (1)
    {
      LODWORD(a12) = 1.0;
      if (!v44 || (LODWORD(a12) = *(_DWORD *)(v47 + 12), *(float *)&a12 > 0.0))
      {
        if (!v20)
        {
          LODWORD(a10) = v26->i32[3];
          v743 = 1.0;
LABEL_796:
          LODWORD(a13) = *(_DWORD *)v47;
          LODWORD(a14) = *(_DWORD *)(v47 + 12);
          v26->f32[0] = PDAluminosityPDA(v26->f32[0], v26->f32[1], v26->f32[2], a10, v743, a12, a13, a14, *(float *)v47, COERCE_FLOAT(*(_QWORD *)(v47 + 4)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v47 + 4))), *(float *)&a14, *(float *)&a12);
          v26->i32[1] = v744;
          v26->i32[2] = v745;
          v26->i32[3] = LODWORD(a10);
          goto LABEL_797;
        }
        LODWORD(a10) = v26->i32[3];
        v743 = *(float *)&a10;
        if (*(float *)&a10 > 0.0)
          goto LABEL_796;
        v26->i64[0] = *(_QWORD *)v47;
        v26->i32[2] = *(_DWORD *)(v47 + 8);
        v26->i32[3] = LODWORD(a12);
      }
LABEL_797:
      v746 = v47 + 16 * v1541;
      if (v746 >= v22)
        v747 = -(uint64_t)(int)v1545;
      else
        v747 = 0;
      v47 = v746 + 16 * v747;
      v26 += v1541;
      if (!--v742)
      {
        v26 += v1547;
        v748 = v1550;
        v749 = v1550 + 16 * v1549;
        v750 = -(uint64_t)(v1549 * v1542);
        if (v749 < v1548)
          v750 = 0;
        v751 = v749 + 16 * v750;
        v752 = v22 + 16 * v750 + 16 * v1549;
        if (v1548)
        {
          v22 = v752;
          v748 = v751;
        }
        v1550 = v748;
        if (v1548)
          v47 = v751;
        else
          v47 += 16 * v1549;
        if (!--v741)
          goto LABEL_1335;
        goto LABEL_789;
      }
    }
  }
  v1542 = 0;
  v1550 = 0;
  v1548 = 0;
  v22 = -1;
  v1549 = v1545;
LABEL_32:
  v45 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
  v49 = v23;
  v1541 = a4;
  v48 = v33;
  shape_enum_clip_alloc(a1, a2, v49, a4, v33, 1, v27, v28, v1546, v17);
  v51 = v50;
  if (v50)
    goto LABEL_1355;
}

void RGBAf_mark_constmask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16)
{
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  float32x4_t v20;
  unint64_t v21;
  float32x2_t *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  unint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  unsigned int v43;
  int v44;
  int v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  float32x4_t v52;
  unint64_t v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  unsigned int v62;
  float32x4_t v63;
  int v64;
  int v65;
  unsigned int v66;
  float32x4_t v67;
  int v68;
  unsigned int v69;
  float32x4_t v70;
  int v71;
  float32x4_t v72;
  int v73;
  unsigned int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  int v80;
  unsigned int v81;
  float v82;
  float v83;
  int v84;
  unsigned int v85;
  float v86;
  float v87;
  int v88;
  float v89;
  float v90;
  float32x4_t v91;
  int v92;
  float32x4_t v93;
  int v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  int v103;
  float v104;
  float v105;
  float v106;
  float v107;
  int v108;
  int8x16_t v109;
  float v110;
  double v111;
  float v112;
  float32x2_t v113;
  int v119;
  float v120;
  float32x2_t v121;
  float32x2_t v122;
  float v123;
  float v124;
  int v125;
  int8x16_t v126;
  float v127;
  double v128;
  float v129;
  int v130;
  int8x16_t v131;
  float v132;
  double v133;
  float v134;
  int v135;
  int8x16_t v136;
  float v137;
  double v138;
  float v139;
  int v140;
  int8x16_t v141;
  float v142;
  double v143;
  float v144;
  int v145;
  int8x16_t v146;
  float v147;
  double v148;
  float v149;
  int v150;
  int8x16_t v151;
  float v152;
  __int32 v153;
  int v154;
  int8x16_t v155;
  float v156;
  double v157;
  float v158;
  int v159;
  float32x4_t v160;
  float v161;
  float v162;
  float32x2_t v163;
  float32x2_t v164;
  float32x2_t v165;
  float32x2_t v166;
  float32x2_t v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float32x2_t v173;
  int v174;
  float v175;
  float32x2_t v176;
  __int128 v177;
  float v178;
  float32x2_t v179;
  float32x2_t v180;
  float32x2_t v181;
  float32x2_t v182;
  int v183;
  int8x16_t v184;
  float v185;
  float v186;
  __int32 v187;
  __int32 v188;
  int v189;
  int8x16_t v190;
  float v191;
  float v192;
  __int32 v193;
  __int32 v194;
  int v195;
  float32x4_t v196;
  float v197;
  float v198;
  __int32 v199;
  __int32 v200;
  int v201;
  int8x16_t v202;
  float v203;
  float v204;
  __int32 v205;
  __int32 v206;
  __int128 v207;
  double v208;
  double v209;
  double v210;
  float32x4_t v211;

  v16 = *(_QWORD *)(a1 + 136);
  if (v16)
  {
    v18 = *(_DWORD *)(a1 + 4);
    v17 = *(_DWORD *)(a1 + 8);
    v19 = *(_QWORD *)(a1 + 48);
    v20 = *(float32x4_t *)*(_QWORD *)(a1 + 88);
    v21 = (unint64_t)*(int *)(a1 + 28) >> 4;
    v22 = (float32x2_t *)(*(_QWORD *)(a1 + 40) + 16 * (*(int *)(a1 + 12) + v21 * *(int *)(a1 + 16)));
    v23 = *(int *)(a1 + 124);
    v24 = v16 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v23;
    v25 = v23 - v18;
    v26 = v21 - v18;
    v211 = v20;
    switch((int)a2)
    {
      case 0:
        do
        {
          v27 = v18;
          do
          {
            v28 = *(unsigned __int8 *)v24;
            if (*(_BYTE *)v24)
            {
              if (v28 == 255)
              {
                *v22 = 0;
                v22[1] = 0;
              }
              else
              {
                *(float32x4_t *)v22->f32 = vmulq_n_f32(*(float32x4_t *)v22->f32, (float)(v28 ^ 0xFFu) * 0.0039216);
              }
            }
            ++v24;
            v22 += 2;
            --v27;
          }
          while (v27);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 1:
        v29 = -1;
        v30 = v24 & 3;
        if ((v24 & 3) != 0)
        {
          v18 += v30;
          v29 = -1 << (8 * v30);
          v31 = v24 & 3;
          v24 &= 0xFFFFFFFFFFFFFFFCLL;
          v22 -= 2 * v31;
        }
        v32 = ((_BYTE)v18 + (_BYTE)v24) & 3;
        if ((((_BYTE)v18 + (_BYTE)v24) & 3) != 0)
        {
          v33 = 4 - v32;
          v30 += v33;
          v34 = 0xFFFFFFFF >> (8 * v33);
          if (v18 >= 4)
            v32 = 0xFFFFFFFF >> (8 * v33);
          else
            v32 = 0;
          if (v18 >= 4)
            v34 = -1;
          v29 &= v34;
        }
        v35 = v25 - v30;
        v36 = v26 - v30;
        do
        {
          v37 = *(_DWORD *)v24 & v29;
          v38 = v18 >> 2;
          v39 = v32;
          if (!v37)
            goto LABEL_40;
LABEL_22:
          if (v37 == -1)
          {
            *(float32x4_t *)v22->f32 = v20;
            *(float32x4_t *)v22[2].f32 = v20;
            *(float32x4_t *)v22[4].f32 = v20;
LABEL_37:
            *(float32x4_t *)v22[6].f32 = v20;
            goto LABEL_40;
          }
          while (1)
          {
            if ((_BYTE)v37)
            {
              v40 = v20;
              if (v37 != 255)
                v40 = vmlaq_n_f32(vmulq_n_f32(v20, (float)v37 * 0.0039216), *(float32x4_t *)v22->f32, 1.0 - (float)((float)v37 * 0.0039216));
              *(float32x4_t *)v22->f32 = v40;
            }
            if (BYTE1(v37))
            {
              v41 = v20;
              if (BYTE1(v37) != 255)
                v41 = vmlaq_n_f32(vmulq_n_f32(v20, (float)BYTE1(v37) * 0.0039216), *(float32x4_t *)v22[2].f32, 1.0 - (float)((float)BYTE1(v37) * 0.0039216));
              *(float32x4_t *)v22[2].f32 = v41;
            }
            if (BYTE2(v37))
            {
              v42 = v20;
              if (BYTE2(v37) != 255)
                v42 = vmlaq_n_f32(vmulq_n_f32(v20, (float)BYTE2(v37) * 0.0039216), *(float32x4_t *)v22[4].f32, 1.0 - (float)((float)BYTE2(v37) * 0.0039216));
              *(float32x4_t *)v22[4].f32 = v42;
            }
            v43 = HIBYTE(v37);
            if (v43 == 255)
              goto LABEL_37;
            if (v43)
              *(float32x4_t *)v22[6].f32 = vmlaq_n_f32(vmulq_n_f32(v20, (float)v43 * 0.0039216), *(float32x4_t *)v22[6].f32, 1.0 - (float)((float)v43 * 0.0039216));
LABEL_40:
            while (1)
            {
              v44 = v38;
              v22 += 8;
              --v38;
              v24 += 4;
              if (v44 < 2)
                break;
              v37 = *(_DWORD *)v24;
              if (*(_DWORD *)v24)
                goto LABEL_22;
            }
            if (!v39)
              break;
            v39 = 0;
            v37 = *(_DWORD *)v24 & v32;
          }
          v24 += v35;
          v22 += 2 * v36;
          --v17;
        }
        while (v17);
        return;
      case 2:
        v45 = -1;
        v46 = v24 & 3;
        if ((v24 & 3) != 0)
        {
          v18 += v46;
          v45 = -1 << (8 * v46);
          v47 = v24 & 3;
          v24 &= 0xFFFFFFFFFFFFFFFCLL;
          v22 -= 2 * v47;
        }
        v48 = ((_BYTE)v18 + (_BYTE)v24) & 3;
        if ((((_BYTE)v18 + (_BYTE)v24) & 3) != 0)
        {
          v49 = 4 - v48;
          v46 += v49;
          v50 = 0xFFFFFFFF >> (8 * v49);
          if (v18 >= 4)
            v48 = 0xFFFFFFFF >> (8 * v49);
          else
            v48 = 0;
          if (v18 >= 4)
            v50 = -1;
          v45 &= v50;
        }
        v51 = v25 - v46;
        *(float *)&a9 = 1.0 - v20.f32[3];
        v52 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
        v53 = v26 - v46;
        do
        {
          v54 = *(_DWORD *)v24 & v45;
          v55 = v18 >> 2;
          v56 = v48;
          if (!v54)
            goto LABEL_68;
LABEL_58:
          if (v54 == -1)
          {
            v57 = vmlaq_f32(v20, v52, *(float32x4_t *)v22[2].f32);
            *(float32x4_t *)v22->f32 = vmlaq_f32(v20, v52, *(float32x4_t *)v22->f32);
            *(float32x4_t *)v22[2].f32 = v57;
            v58 = vmlaq_f32(v20, v52, *(float32x4_t *)v22[6].f32);
            *(float32x4_t *)v22[4].f32 = vmlaq_f32(v20, v52, *(float32x4_t *)v22[4].f32);
            *(float32x4_t *)v22[6].f32 = v58;
            goto LABEL_68;
          }
          while (1)
          {
            if ((_BYTE)v54)
            {
              v59 = vmulq_n_f32(v20, (float)v54 * 0.0039216);
              *(float32x4_t *)v22->f32 = vmlaq_n_f32(v59, *(float32x4_t *)v22->f32, 1.0 - v59.f32[3]);
            }
            if ((v54 & 0xFF00) != 0)
            {
              v60 = vmulq_n_f32(v20, (float)BYTE1(v54) * 0.0039216);
              *(float32x4_t *)v22[2].f32 = vmlaq_n_f32(v60, *(float32x4_t *)v22[2].f32, 1.0 - v60.f32[3]);
            }
            if ((v54 & 0xFF0000) != 0)
            {
              v61 = vmulq_n_f32(v20, (float)BYTE2(v54) * 0.0039216);
              *(float32x4_t *)v22[4].f32 = vmlaq_n_f32(v61, *(float32x4_t *)v22[4].f32, 1.0 - v61.f32[3]);
            }
            v62 = HIBYTE(v54);
            if (v62)
            {
              v63 = vmulq_n_f32(v20, (float)v62 * 0.0039216);
              *(float32x4_t *)v22[6].f32 = vmlaq_n_f32(v63, *(float32x4_t *)v22[6].f32, 1.0 - v63.f32[3]);
            }
LABEL_68:
            while (1)
            {
              v64 = v55;
              v22 += 8;
              --v55;
              v24 += 4;
              if (v64 < 2)
                break;
              v54 = *(_DWORD *)v24;
              if (*(_DWORD *)v24)
                goto LABEL_58;
            }
            if (!v56)
              break;
            v56 = 0;
            v54 = *(_DWORD *)v24 & v48;
          }
          v24 += v51;
          v22 += 2 * v53;
          --v17;
        }
        while (v17);
        return;
      case 3:
        do
        {
          v65 = v18;
          do
          {
            v66 = *(unsigned __int8 *)v24;
            if (*(_BYTE *)v24)
            {
              if (v66 == 255)
                v67 = vmulq_n_f32(v20, v22[1].f32[1]);
              else
                v67 = vmlaq_n_f32(vmulq_n_f32(v20, vmuls_lane_f32((float)v66 * 0.0039216, *(float32x4_t *)v22->f32, 3)), *(float32x4_t *)v22->f32, 1.0 - (float)((float)v66 * 0.0039216));
              *(float32x4_t *)v22->f32 = v67;
            }
            ++v24;
            v22 += 2;
            --v65;
          }
          while (v65);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 4:
        do
        {
          v68 = v18;
          do
          {
            v69 = *(unsigned __int8 *)v24;
            if (*(_BYTE *)v24)
            {
              if (v69 == 255)
                v70 = vmulq_n_f32(v20, 1.0 - v22[1].f32[1]);
              else
                v70 = vmlaq_n_f32(vmulq_n_f32(v20, (float)((float)v69 * 0.0039216) * (float)(1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)))), *(float32x4_t *)v22->f32, 1.0 - (float)((float)v69 * 0.0039216));
              *(float32x4_t *)v22->f32 = v70;
            }
            ++v24;
            v22 += 2;
            --v68;
          }
          while (v68);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 5:
        do
        {
          v71 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v72 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              *(float32x4_t *)v22->f32 = vmlaq_laneq_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v72.f32[3]), v72, *(float32x4_t *)v22->f32, 3);
            }
            ++v24;
            v22 += 2;
            --v71;
          }
          while (v71);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 6:
        while (1)
        {
          v73 = v18;
          do
          {
            v74 = *(unsigned __int8 *)v24;
            if (!*(_BYTE *)v24)
              goto LABEL_106;
            v75 = v22[1].f32[1];
            v76 = 1.0 - v75;
            if ((float)(1.0 - v75) >= 1.0)
            {
              v79 = (float)v74 * 0.0039216;
              v78 = v20.f32[3] * v79;
              *v22 = vmul_n_f32(*(float32x2_t *)v20.f32, v79);
              v22[1].f32[0] = v20.f32[2] * v79;
            }
            else
            {
              if (v76 <= 0.0)
                goto LABEL_106;
              v77 = (float)v74 * 0.0039216;
              *v22 = vmla_n_f32(*v22, vmul_n_f32(*(float32x2_t *)v20.f32, v77), v76);
              v22[1].f32[0] = v22[1].f32[0] + (float)((float)(v20.f32[2] * v77) * v76);
              v78 = v75 + (float)((float)(v20.f32[3] * v77) * v76);
            }
            v22[1].f32[1] = v78;
LABEL_106:
            ++v24;
            v22 += 2;
            --v73;
          }
          while (v73);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 7:
        do
        {
          v80 = v18;
          do
          {
            v81 = *(unsigned __int8 *)v24;
            if (*(_BYTE *)v24)
            {
              if (v81 == 255)
              {
                v82 = v20.f32[3] * v22->f32[0];
                v83 = v20.f32[3];
              }
              else
              {
                v83 = (float)(v20.f32[3] * (float)((float)v81 * 0.0039216))
                    + (float)(1.0 - (float)((float)v81 * 0.0039216));
                v82 = v83 * v22->f32[0];
              }
              v22->f32[0] = v82;
              *(float32x2_t *)((char *)v22 + 4) = vmul_n_f32(*(float32x2_t *)((char *)v22 + 4), v83);
              v22[1].f32[1] = v83 * v22[1].f32[1];
            }
            ++v24;
            v22 += 2;
            --v80;
          }
          while (v80);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 8:
        do
        {
          v84 = v18;
          do
          {
            v85 = *(unsigned __int8 *)v24;
            if (*(_BYTE *)v24)
            {
              if (v85 == 255)
              {
                v86 = (float)(1.0 - v20.f32[3]) * v22->f32[0];
                v87 = 1.0 - v20.f32[3];
              }
              else
              {
                v87 = (float)(v20.f32[3] * (float)((float)v85 * -0.0039216)) + 1.0;
                v86 = v87 * v22->f32[0];
              }
              v22->f32[0] = v86;
              *(float32x2_t *)((char *)v22 + 4) = vmul_n_f32(*(float32x2_t *)((char *)v22 + 4), v87);
              v22[1].f32[1] = v87 * v22[1].f32[1];
            }
            ++v24;
            v22 += 2;
            --v84;
          }
          while (v84);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 9:
        do
        {
          v88 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v89 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              v90 = 1.0 - v89;
              v91 = vmulq_n_f32(v20, v89);
              *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, v90 + v91.f32[3]), v91, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
            }
            ++v24;
            v22 += 2;
            --v88;
          }
          while (v88);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 10:
        do
        {
          v92 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v93 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v93.f32[3]), v93, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
            }
            ++v24;
            v22 += 2;
            --v92;
          }
          while (v92);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 11:
        do
        {
          v94 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v95 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              v96 = v20.f32[0] * v95;
              v97 = v20.f32[3] * v95;
              if (v19)
              {
                v98 = v22[1].f32[1];
                v99 = (float)(v97 - v96) + (float)(v98 - v22->f32[0]);
                if ((float)(v97 + v98) <= 1.0)
                  v100 = v97 + v98;
                else
                  v100 = 1.0;
              }
              else
              {
                v98 = 1.0;
                v99 = (float)(v97 - v96) + (float)(1.0 - v22->f32[0]);
                if ((float)(v97 + 1.0) <= 1.0)
                  v100 = v97 + 1.0;
                else
                  v100 = 1.0;
              }
              v101 = (float)(v97 - (float)(v20.f32[1] * v95)) + (float)(v98 - v22->f32[1]);
              v22->f32[0] = v100 - v99;
              v102 = (float)(v97 - (float)(v20.f32[2] * v95)) + (float)(v98 - v22[1].f32[0]);
              v22->f32[1] = v100 - v101;
              v22[1].f32[0] = v100 - v102;
              v22[1].f32[1] = v100;
            }
            ++v24;
            v22 += 2;
            --v94;
          }
          while (v94);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 12:
        do
        {
          v103 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v104 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              v105 = v20.f32[2] * v104;
              *v22 = vadd_f32(vmul_n_f32(*(float32x2_t *)v20.f32, v104), *v22);
              v106 = (float)(v20.f32[3] * v104) + v22[1].f32[1];
              v107 = v105 + v22[1].f32[0];
              if (v106 > 1.0)
                v106 = 1.0;
              v22[1].f32[0] = v107;
              v22[1].f32[1] = v106;
            }
            ++v24;
            v22 += 2;
            --v103;
          }
          while (v103);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 13:
        while (1)
        {
          v108 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v109 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v109.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v110 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v109;
                    goto LABEL_168;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v110 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v111 = vextq_s8(v109, v109, 4uLL).u64[0];
                v112 = PDAmultiplyPDA(v22->f32[0], a10, a11, a12, v110, *(double *)v109.i64, v111, a16, *(float *)v109.i32, COERCE_DOUBLE(__PAIR64__(v109.u32[3], HIDWORD(v111))), *(float *)&v109.i32[3]);
                v20 = v211;
                v22->f32[0] = v112;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_168:
            ++v24;
            v22 += 2;
            --v108;
          }
          while (v108);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 14:
        v113 = (float32x2_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL).u64[0];
        __asm { FMOV            V3.2S, #1.0 }
        while (1)
        {
          v119 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v120 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              v121 = vmul_n_f32(v113, v120);
              if (v121.f32[1] > 0.0)
              {
                v122 = vmul_n_f32(*(float32x2_t *)v20.f32, v120);
                if (v19)
                {
                  v123 = v22[1].f32[1];
                  if (v123 <= 0.0)
                  {
                    *v22 = v122;
                    v22[1] = v121;
                    goto LABEL_180;
                  }
                }
                else
                {
                  v123 = 1.0;
                }
                v124 = vmlas_n_f32(v22[1].f32[0], 1.0 - v22[1].f32[0], v121.f32[0]);
                *v22 = vmla_f32(*v22, vsub_f32(_D3, *v22), v122);
                v22[1].f32[0] = v124;
                v22[1].f32[1] = (float)(v121.f32[1] + v123) - (float)(v123 * v121.f32[1]);
              }
            }
LABEL_180:
            ++v24;
            v22 += 2;
            --v119;
          }
          while (v119);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 15:
        while (1)
        {
          v125 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v126 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v126.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v127 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v126;
                    goto LABEL_191;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v127 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v128 = vextq_s8(v126, v126, 4uLL).u64[0];
                v129 = PDAoverlayPDA(v22->f32[0], a10, a11, a12, v127, *(double *)v126.i64, v128, a16, *(float *)v126.i32, COERCE_DOUBLE(__PAIR64__(v126.u32[3], HIDWORD(v128))), *(float *)&v126.i32[3]);
                v20 = v211;
                v22->f32[0] = v129;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_191:
            ++v24;
            v22 += 2;
            --v125;
          }
          while (v125);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 16:
        while (1)
        {
          v130 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v131 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v131.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v132 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v131;
                    goto LABEL_202;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v132 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v133 = vextq_s8(v131, v131, 4uLL).u64[0];
                v134 = PDAdarkenPDA(v22->f32[0], a10, a11, a12, v132, *(double *)v131.i64, v133, a16, *(float *)v131.i32, COERCE_DOUBLE(__PAIR64__(v131.u32[3], HIDWORD(v133))), *(float *)&v131.i32[3]);
                v20 = v211;
                v22->f32[0] = v134;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_202:
            ++v24;
            v22 += 2;
            --v130;
          }
          while (v130);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 17:
        while (1)
        {
          v135 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v136 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v136.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v137 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v136;
                    goto LABEL_213;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v137 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v138 = vextq_s8(v136, v136, 4uLL).u64[0];
                v139 = PDAlightenPDA(v22->f32[0], a10, a11, a12, v137, *(double *)v136.i64, v138, a16, *(float *)v136.i32, COERCE_DOUBLE(__PAIR64__(v136.u32[3], HIDWORD(v138))), *(float *)&v136.i32[3]);
                v20 = v211;
                v22->f32[0] = v139;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_213:
            ++v24;
            v22 += 2;
            --v135;
          }
          while (v135);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 18:
        while (1)
        {
          v140 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v141 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v141.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v142 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v141;
                    goto LABEL_224;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v142 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v143 = vextq_s8(v141, v141, 4uLL).u64[0];
                v144 = PDAcolordodgePDA(v22->f32[0], a10, a11, a12, v142, *(double *)v141.i64, v143, a16, *(float *)v141.i32, COERCE_DOUBLE(__PAIR64__(v141.u32[3], HIDWORD(v143))), *(float *)&v141.i32[3]);
                v20 = v211;
                v22->f32[0] = v144;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_224:
            ++v24;
            v22 += 2;
            --v140;
          }
          while (v140);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 19:
        while (1)
        {
          v145 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v146 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v146.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v147 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v146;
                    goto LABEL_235;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v147 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v148 = vextq_s8(v146, v146, 4uLL).u64[0];
                v149 = PDAcolorburnPDA(v22->f32[0], a10, a11, a12, v147, *(double *)v146.i64, v148, a16, *(float *)v146.i32, COERCE_DOUBLE(__PAIR64__(v146.u32[3], HIDWORD(v148))), *(float *)&v146.i32[3]);
                v20 = v211;
                v22->f32[0] = v149;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_235:
            ++v24;
            v22 += 2;
            --v145;
          }
          while (v145);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 20:
        while (1)
        {
          v150 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v151 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v151.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  LODWORD(a13) = LODWORD(a12);
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v151;
                    goto LABEL_246;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  LODWORD(a13) = 1.0;
                }
                LODWORD(a11) = v22[1].i32[0];
                DWORD2(v207) = v151.i32[3];
                *(_QWORD *)&v207 = vextq_s8(v151, v151, 4uLL).u64[0];
                v152 = PDAsoftlightPDA(v22->f32[0], v22->f32[1], a11, *(int32x2_t *)&a12, a13, *(double *)v151.i64, *(double *)&v207, a16, a1, a2, a3, a4, a5, a6, a7, a8, *(float *)v151.i32, v207, *(uint64_t *)((char *)&v207 + 4),
                         *(float *)&v151.i32[3]);
                v20 = v211;
                v22->f32[0] = v152;
                v22->i32[1] = v153;
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_246:
            ++v24;
            v22 += 2;
            --v150;
          }
          while (v150);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 21:
        while (1)
        {
          v154 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v155 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v155.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v156 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v155;
                    goto LABEL_257;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v156 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(_QWORD *)&v157 = vextq_s8(v155, v155, 4uLL).u64[0];
                v158 = PDAhardlightPDA(v22->f32[0], a10, a11, a12, v156, *(double *)v155.i64, v157, a16, *(float *)v155.i32, COERCE_DOUBLE(__PAIR64__(v155.u32[3], HIDWORD(v157))), *(float *)&v155.i32[3]);
                v20 = v211;
                v22->f32[0] = v158;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_257:
            ++v24;
            v22 += 2;
            --v154;
          }
          while (v154);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 22:
        while (1)
        {
          v159 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v160 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (v160.f32[3] > 0.0)
              {
                if (v19)
                {
                  v161 = v22[1].f32[1];
                  if (v161 <= 0.0)
                  {
                    *(float32x4_t *)v22->f32 = v160;
                    goto LABEL_270;
                  }
                }
                else
                {
                  v161 = 1.0;
                }
                v162 = v22[1].f32[0];
                v163 = vmul_laneq_f32(*v22, v160, 3);
                v164 = vmul_n_f32(*(float32x2_t *)v160.f32, v161);
                v165 = vsub_f32(vadd_f32(*v22, *(float32x2_t *)v160.f32), v163);
                v166 = vsub_f32(v163, v164);
                v167 = vadd_f32(vsub_f32(v165, v164), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v166), (int8x8_t)vneg_f32(v166), (int8x8_t)v166));
                v168 = v162 + v160.f32[2];
                v169 = v162 * v160.f32[3];
                v170 = vmuls_lane_f32(v161, v160, 2);
                v171 = v168 - v169;
                v172 = v169 - v170;
                v160.f32[0] = v171 - v170;
                if (v172 < 0.0)
                  v172 = -v172;
                *v22 = v167;
                v22[1].f32[0] = v160.f32[0] + v172;
                v22[1].f32[1] = (float)(v161 + v160.f32[3]) - (float)(v161 * v160.f32[3]);
              }
            }
LABEL_270:
            ++v24;
            v22 += 2;
            --v159;
          }
          while (v159);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 23:
        v173 = (float32x2_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL).u64[0];
        while (1)
        {
          v174 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v175 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              v176 = vmul_n_f32(v173, v175);
              if (v176.f32[1] > 0.0)
              {
                *(float32x2_t *)&v177 = vmul_n_f32(*(float32x2_t *)v20.f32, v175);
                if (v19)
                {
                  v178 = v22[1].f32[1];
                  if (v178 <= 0.0)
                  {
                    *((float32x2_t *)&v177 + 1) = v176;
                    *(_OWORD *)v22->f32 = v177;
                    goto LABEL_282;
                  }
                }
                else
                {
                  v178 = 1.0;
                }
                v179.i32[0] = v22[1].i32[0];
                v180.f32[0] = (float)-v179.f32[0] * v176.f32[0];
                v181 = vmla_f32(vadd_f32(*(float32x2_t *)&v177, *v22), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)&v177, *v22));
                v179.f32[1] = v178;
                v180.f32[1] = -v178;
                v182 = vadd_f32(v176, v179);
                v176.i32[0] = 2.0;
                *v22 = v181;
                v22[1] = vmla_f32(v182, v176, v180);
              }
            }
LABEL_282:
            ++v24;
            v22 += 2;
            --v174;
          }
          while (v174);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 24:
        while (1)
        {
          v183 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v184 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v184.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v185 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v184;
                    goto LABEL_293;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v185 = 1.0;
                }
                *(_QWORD *)&v208 = vextq_s8(v184, v184, 4uLL).u64[0];
                v186 = PDAhuePDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a12, v185, *(double *)v184.i64, v208, a16, *(float *)v184.i32, *(float *)&v208, *((float *)&v208 + 1), *(float *)&v184.i32[3], *(float *)&v184.i32[3]);
                v20 = v211;
                v22->f32[0] = v186;
                v22->i32[1] = v187;
                v22[1].i32[0] = v188;
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_293:
            ++v24;
            v22 += 2;
            --v183;
          }
          while (v183);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 25:
        while (1)
        {
          v189 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v190 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v190.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v191 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v190;
                    goto LABEL_304;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  v191 = 1.0;
                }
                *(_QWORD *)&v209 = vextq_s8(v190, v190, 4uLL).u64[0];
                v192 = PDAsaturationPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a12, v191, *(double *)v190.i64, v209, a16, *(float *)v190.i32, *(float *)&v209, *((float *)&v209 + 1), *(float *)&v190.i32[3], *(float *)&v190.i32[3]);
                v20 = v211;
                v22->f32[0] = v192;
                v22->i32[1] = v193;
                v22[1].i32[0] = v194;
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_304:
            ++v24;
            v22 += 2;
            --v189;
          }
          while (v189);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 26:
        while (1)
        {
          v195 = v18;
          do
          {
            if (*(_BYTE *)v24)
            {
              v196 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              LODWORD(a12) = v196.i32[3];
              if (v196.f32[3] > 0.0)
              {
                if (v19)
                {
                  v197 = v22[1].f32[1];
                  *(float *)&a14 = v197;
                  if (v197 <= 0.0)
                  {
                    *(float32x4_t *)v22->f32 = v196;
                    goto LABEL_315;
                  }
                }
                else
                {
                  v197 = v22[1].f32[1];
                  LODWORD(a14) = 1.0;
                }
                LODWORD(a15) = v22[1].i32[0];
                v198 = PDAluminosityPDA(v196.f32[0], v196.f32[1], v196.f32[2], a12, v196.f32[3], a14, a15, a16, COERCE_FLOAT(*v22), COERCE_FLOAT(HIDWORD(*(unint64_t *)v22)), *(float *)&a15, v197, *(float *)&a14);
                v20 = v211;
                v22->f32[0] = v198;
                v22->i32[1] = v199;
                v22[1].i32[0] = v200;
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_315:
            ++v24;
            v22 += 2;
            --v195;
          }
          while (v195);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17)
            return;
        }
      case 27:
        break;
      default:
        return;
    }
LABEL_318:
    v201 = v18;
    while (1)
    {
      if (!*(_BYTE *)v24)
        goto LABEL_326;
      v202 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
      if (*(float *)&v202.i32[3] <= 0.0)
        goto LABEL_326;
      if (!v19)
        break;
      LODWORD(a12) = v22[1].i32[1];
      v203 = *(float *)&a12;
      if (*(float *)&a12 > 0.0)
        goto LABEL_325;
      *(int8x16_t *)v22->f32 = v202;
LABEL_326:
      ++v24;
      v22 += 2;
      if (!--v201)
      {
        v24 += v25;
        v22 += 2 * v26;
        if (!--v17)
          return;
        goto LABEL_318;
      }
    }
    LODWORD(a12) = v22[1].i32[1];
    v203 = 1.0;
LABEL_325:
    *(_QWORD *)&v210 = vextq_s8(v202, v202, 4uLL).u64[0];
    v204 = PDAluminosityPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a12, v203, *(double *)v202.i64, v210, a16, *(float *)v202.i32, *(float *)&v210, *((float *)&v210 + 1), *(float *)&v202.i32[3], *(float *)&v202.i32[3]);
    v20 = v211;
    v22->f32[0] = v204;
    v22->i32[1] = v205;
    v22[1].i32[0] = v206;
    v22[1].i32[1] = LODWORD(a12);
    goto LABEL_326;
  }
}

void RGBAf_mark_pixelmask(_DWORD *a1, int *a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  _DWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _BOOL4 v20;
  unint64_t v21;
  float32x2_t *v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  float32x4_t *v29;
  int v30;
  uint64_t v31;
  float32x4_t *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  float32x4_t *v37;
  _BOOL4 v38;
  int v39;
  float32x4_t *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  float v47;
  float32_t v48;
  float32_t v49;
  float32x4_t *v50;
  uint64_t v51;
  float32x4_t *v52;
  uint64_t v53;
  float32x4_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unsigned int v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  __int32 v66;
  __int32 v67;
  float32x4_t *v68;
  uint64_t v69;
  float32x4_t *v70;
  uint64_t v71;
  float32x4_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  unsigned int v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  __int32 v84;
  __int32 v85;
  float32x4_t *v86;
  uint64_t v87;
  float32x4_t *v88;
  uint64_t v89;
  float32x4_t *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  unsigned int v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  __int32 v103;
  __int32 v104;
  float32x4_t *v105;
  uint64_t v106;
  float32x4_t *v107;
  uint64_t v108;
  float32x4_t *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  unsigned int v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  __int32 v121;
  __int32 v122;
  float32x4_t *v123;
  uint64_t v124;
  float32x4_t *v125;
  uint64_t v126;
  float32x4_t *v127;
  uint64_t v128;
  int v129;
  unsigned int v130;
  float v131;
  float32x4_t v132;
  float32x4_t *v133;
  uint64_t v134;
  float32x4_t *v135;
  uint64_t v136;
  float32x4_t *v137;
  uint64_t v138;
  int v139;
  unsigned int v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float32x4_t *v150;
  uint64_t v151;
  float32x4_t *v152;
  uint64_t v153;
  float32x4_t *v154;
  uint64_t v155;
  int v156;
  unsigned int v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float32x4_t *v167;
  uint64_t v168;
  float32x4_t *v169;
  uint64_t v170;
  float32x4_t *v171;
  uint64_t v172;
  int v173;
  float32x4_t v174;
  float32x4_t *v175;
  uint64_t v176;
  float32x4_t *v177;
  uint64_t v178;
  float32x4_t *v179;
  uint64_t v180;
  int v181;
  unsigned int v182;
  float v183;
  float v184;
  float v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float32x4_t *v190;
  uint64_t v191;
  float32x4_t *v192;
  uint64_t v193;
  float32x4_t *v194;
  uint64_t v195;
  int v196;
  unsigned int v197;
  float32x4_t v198;
  float32x4_t *v199;
  uint64_t v200;
  float32x4_t *v201;
  uint64_t v202;
  float32x4_t *v203;
  uint64_t v204;
  int v205;
  unsigned int v206;
  float v207;
  float *v208;
  float v209;
  float v210;
  float32x4_t *v211;
  uint64_t v212;
  float32x4_t *v213;
  uint64_t v214;
  float32x4_t *v215;
  uint64_t v216;
  int v217;
  float v218;
  float v219;
  float32x4_t v220;
  float32x4_t *v221;
  uint64_t v222;
  float32x4_t *v223;
  uint64_t v224;
  float32x4_t *v225;
  uint64_t v226;
  int v227;
  float32x4_t v228;
  float32x4_t *v229;
  uint64_t v230;
  float32x4_t *v231;
  uint64_t v232;
  float32x4_t *v233;
  uint64_t v234;
  int v235;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  float v243;
  float32_t v244;
  float v245;
  float v246;
  float32x4_t *v247;
  uint64_t v248;
  float32x4_t *v249;
  uint64_t v250;
  float32x4_t *v251;
  uint64_t v252;
  int v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float32x4_t *v259;
  uint64_t v260;
  float32x4_t *v261;
  uint64_t v262;
  float32x4_t *v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  int v268;
  unsigned int v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  float32x4_t *v275;
  uint64_t v276;
  float32x4_t *v277;
  uint64_t v278;
  float32x4_t *v279;
  uint64_t v280;
  int v286;
  float v287;
  float v288;
  float v289;
  float32x2_t v290;
  float v291;
  float v292;
  float32x4_t *v293;
  uint64_t v294;
  float32x4_t *v295;
  uint64_t v296;
  float32x4_t *v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  int v302;
  unsigned int v303;
  float v304;
  float v305;
  float v306;
  float v307;
  float v308;
  float32x4_t *v309;
  uint64_t v310;
  float32x4_t *v311;
  uint64_t v312;
  float32x4_t *v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  int v318;
  unsigned int v319;
  float v320;
  float v321;
  float v322;
  float v323;
  float v324;
  float32x4_t *v325;
  uint64_t v326;
  float32x4_t *v327;
  uint64_t v328;
  float32x4_t *v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  int v334;
  unsigned int v335;
  float v336;
  float v337;
  float v338;
  float v339;
  float v340;
  float32x4_t *v341;
  uint64_t v342;
  float32x4_t *v343;
  uint64_t v344;
  float32x4_t *v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  int v350;
  unsigned int v351;
  float v352;
  float v353;
  float v354;
  float v355;
  float v356;
  float32x4_t *v357;
  uint64_t v358;
  float32x4_t *v359;
  uint64_t v360;
  float32x4_t *v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  int v366;
  unsigned int v367;
  float v368;
  float v369;
  float v370;
  float v371;
  float v372;
  float32x4_t *v373;
  uint64_t v374;
  float32x4_t *v375;
  uint64_t v376;
  float32x4_t *v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  int v382;
  unsigned int v383;
  float v384;
  float v385;
  float v386;
  float v387;
  __int32 v388;
  float32x4_t *v389;
  uint64_t v390;
  float32x4_t *v391;
  uint64_t v392;
  float32x4_t *v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  int v398;
  unsigned int v399;
  float v400;
  float v401;
  float v402;
  float v403;
  float v404;
  float32x4_t *v405;
  uint64_t v406;
  float32x4_t *v407;
  uint64_t v408;
  float32x4_t *v409;
  uint64_t v410;
  int v411;
  float v412;
  float v413;
  float v414;
  float32x2_t v415;
  float v416;
  float v417;
  float v418;
  float32x2_t v419;
  float32x2_t v420;
  float32x2_t v421;
  float32x2_t v422;
  float32x2_t v423;
  float32x2_t v424;
  float v425;
  float v426;
  float v427;
  float v428;
  float v429;
  float32x4_t *v430;
  uint64_t v431;
  float32x4_t *v432;
  uint64_t v433;
  float32x4_t *v434;
  uint64_t v435;
  int v436;
  float v437;
  float v438;
  float v439;
  float32x2_t v440;
  float v441;
  float v442;
  float32x4_t *v443;
  uint64_t v444;
  float32x4_t *v445;
  uint64_t v446;
  float32x4_t *v447;
  uint64_t v448;
  int v449;
  unsigned int v450;
  float32x4_t v451;
  float32x4_t *v452;
  uint64_t v453;
  float32x4_t *v454;
  uint64_t v455;
  float32x4_t *v456;
  uint64_t v457;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  unint64_t v473;
  uint64_t v474;
  uint64_t v475;
  float32x4_t *v476;
  float32x4_t *v477;
  float32x4_t *v478;
  float32x4_t *v479;
  float32x4_t *v480;
  float32x4_t *v481;
  float32x4_t *v482;
  float32x4_t *v483;
  float32x4_t *v484;
  float32x4_t *v485;
  float32x4_t *v486;
  float32x4_t *v487;
  int v488;
  int v489;

  v12 = a1;
  v489 = a2[2];
  v13 = a2[7];
  v14 = *((_QWORD *)a2 + 5);
  v15 = *((_QWORD *)a2 + 6);
  v16 = *((_QWORD *)a2 + 11);
  v17 = *((_QWORD *)a2 + 12);
  v18 = *((_QWORD *)a2 + 17);
  v19 = *a2;
  v488 = a2[1];
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1)
  {
    v459 = a3;
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_6_12441);
    a3 = v459;
    v12 = a1;
  }
  v20 = v15 != 0;
  if (v18)
  {
    v21 = v13 >> 4;
    v22 = (float32x2_t *)(v14 + 16 * (a2[3] + (v13 >> 4) * a2[4]));
    v23 = a2[31];
    v24 = (char *)(v18 + a2[26] + a2[27] * (uint64_t)(int)v23);
    v25 = a2[14];
    v26 = a2[15];
    v27 = a2[19];
    if ((v19 & 0xFF00) != 0x100)
    {
      v34 = a2[16];
      v35 = a2[17];
      v28 = v27 >> 4;
      v36 = v16 + 16 * (v27 >> 4) * v35;
      v33 = 1;
      v37 = (float32x4_t *)v16;
      v29 = (float32x4_t *)v16;
      v30 = v488;
      goto LABEL_15;
    }
    v28 = v27 >> 4;
    v29 = (float32x4_t *)(v16 + 16 * (v25 + (v27 >> 4) * v26));
    v30 = v488;
    if (v27 >> 4 != v21)
    {
      v33 = 1;
LABEL_14:
      v36 = 0;
      v37 = 0;
      v35 = 0;
      v16 = -1;
      v34 = v28;
LABEL_15:
      v38 = v17 != 0;
      v39 = v33 * v30;
      if (v36)
      {
        v40 = &v29[v28 * ((int)v26 % (int)v35)];
        v37 = &v40[(int)v25 % (int)v34];
        v16 = (unint64_t)&v40[(int)v34];
        v29 = v37;
      }
      else
      {
        v28 -= v39;
      }
      v41 = v23 - v39;
      v42 = v21 - v39;
      v474 = v42;
      v475 = v28;
      v472 = v41;
      v473 = v36;
      switch((int)a3)
      {
        case 0:
          do
          {
            v43 = v488;
            do
            {
              v44 = *v24;
              if (*v24)
              {
                if (v44 == 255)
                {
                  *v22 = 0;
                  v22[1] = 0;
                }
                else
                {
                  *(float32x4_t *)v22->f32 = vmulq_n_f32(*(float32x4_t *)v22->f32, (float)((float)v44 * -0.0039216) + 1.0);
                }
              }
              v24 += v33;
              v22 += 2 * v33;
              --v43;
            }
            while (v43);
            v24 += v41;
            v22 += 2 * v42;
            --v489;
          }
          while (v489);
          return;
        case 1:
          if (!v15 || v17)
          {
            do
            {
              v449 = v488;
              do
              {
                v450 = *v24;
                if (*v24)
                {
                  if (v450 == 255)
                    v451 = *v29;
                  else
                    v451 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - (float)((float)v450 * 0.0039216)), *v29, (float)v450 * 0.0039216);
                  *(float32x4_t *)v22->f32 = v451;
                }
                v24 += v33;
                v452 = &v29[v33];
                if ((unint64_t)v452 >= v16)
                  v453 = -(uint64_t)(int)v34;
                else
                  v453 = 0;
                v29 = &v452[v453];
                v22 += 2 * v33;
                --v449;
              }
              while (v449);
              v24 += v41;
              v22 += 2 * v42;
              v454 = &v37[v28];
              if ((unint64_t)v454 >= v36)
                v455 = -(v28 * (int)v35);
              else
                v455 = 0;
              v456 = &v454[v455];
              v457 = v16 + 16 * v455 + 16 * v28;
              if (v36)
              {
                v16 = v457;
                v37 = v456;
                v29 = v456;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          else
          {
            do
            {
              v45 = v488;
              do
              {
                v46 = *v24;
                if (*v24)
                {
                  if (v46 == 255)
                  {
                    *v22 = *(float32x2_t *)v29->f32;
                    v22[1].i32[0] = v29->i32[2];
                    v22[1].i32[1] = 1065353216;
                  }
                  else
                  {
                    v47 = (float)v46 * 0.0039216;
                    *v22 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v47), *v22, 1.0 - v47);
                    v48 = (float)(v47 * v29->f32[2]) + (float)(v22[1].f32[0] * (float)(1.0 - v47));
                    v49 = v47 + (float)(v22[1].f32[1] * (float)(1.0 - v47));
                    v22[1].f32[0] = v48;
                    v22[1].f32[1] = v49;
                  }
                }
                v24 += v33;
                v50 = &v29[v33];
                if ((unint64_t)v50 >= v16)
                  v51 = -(uint64_t)(int)v34;
                else
                  v51 = 0;
                v29 = &v50[v51];
                v22 += 2 * v33;
                --v45;
              }
              while (v45);
              v24 += v41;
              v22 += 2 * v42;
              v52 = &v37[v28];
              if ((unint64_t)v52 >= v36)
                v53 = -(v28 * (int)v35);
              else
                v53 = 0;
              v54 = &v52[v53];
              v55 = v16 + 16 * v53 + 16 * v28;
              if (v36)
              {
                v16 = v55;
                v37 = v54;
                v29 = v54;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 2:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)2,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
            return;
          }
          while (1)
          {
            v129 = v488;
            do
            {
              v130 = *v24;
              if (!*v24)
                goto LABEL_216;
              if (v130 == 255)
              {
                v131 = v29->f32[3];
                if (v131 >= 1.0)
                {
                  *v22 = *(float32x2_t *)v29->f32;
                  v22[1].i32[0] = v29->i32[2];
                  v22[1].f32[1] = v131;
                }
                else if (v131 > 0.0)
                {
                  *(float32x4_t *)v22->f32 = vmlaq_n_f32(*v29, *(float32x4_t *)v22->f32, 1.0 - v131);
                }
              }
              else
              {
                v132 = vmulq_n_f32(*v29, (float)v130 * 0.0039216);
                if (v132.f32[3] < 1.0)
                {
                  if (v132.f32[3] <= 0.0)
                    goto LABEL_216;
                  v132 = vmlaq_n_f32(v132, *(float32x4_t *)v22->f32, 1.0 - v132.f32[3]);
                }
                *(float32x4_t *)v22->f32 = v132;
              }
LABEL_216:
              v24 += v33;
              v133 = &v29[v33];
              if ((unint64_t)v133 >= v16)
                v134 = -(uint64_t)(int)v34;
              else
                v134 = 0;
              v29 = &v133[v134];
              v22 += 2 * v33;
              --v129;
            }
            while (v129);
            v24 += v41;
            v22 += 2 * v42;
            v135 = &v37[v28];
            if ((unint64_t)v135 >= v36)
              v136 = -(v28 * (int)v35);
            else
              v136 = 0;
            v137 = &v135[v136];
            v138 = v16 + 16 * v136 + 16 * v28;
            if (v36)
            {
              v16 = v138;
              v37 = v137;
              v29 = v137;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489)
              return;
          }
        case 3:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)3,_rgbaf_t>((float32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
          }
          else
          {
            do
            {
              v139 = v488;
              do
              {
                v140 = *v24;
                if (*v24)
                {
                  if (v140 == 255)
                  {
                    v141 = v22[1].f32[1];
                    *v22 = vmul_n_f32(*(float32x2_t *)v29->f32, v141);
                    v22[1].f32[0] = v141 * v29->f32[2];
                    if (v17)
                      v142 = v29->f32[3];
                    else
                      v142 = 1.0;
                    v149 = v141 * v142;
                  }
                  else
                  {
                    v143 = (float)v140 * 0.0039216;
                    v144 = 1.0;
                    v145 = 1.0 - v143;
                    v147 = v22[1].f32[0];
                    v146 = v22[1].f32[1];
                    v148 = v143 * v146;
                    *v22 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v148), *v22, v145);
                    v22[1].f32[0] = (float)(v148 * v29->f32[2]) + (float)(v147 * v145);
                    if (v17)
                      v144 = v29->f32[3];
                    v149 = (float)(v148 * v144) + (float)(v146 * v145);
                  }
                  v22[1].f32[1] = v149;
                }
                v24 += v33;
                v150 = &v29[v33];
                if ((unint64_t)v150 >= v16)
                  v151 = -(uint64_t)(int)v34;
                else
                  v151 = 0;
                v29 = &v150[v151];
                v22 += 2 * v33;
                --v139;
              }
              while (v139);
              v24 += v41;
              v22 += 2 * v42;
              v152 = &v37[v28];
              if ((unint64_t)v152 >= v36)
                v153 = -(v28 * (int)v35);
              else
                v153 = 0;
              v154 = &v152[v153];
              v155 = v16 + 16 * v153 + 16 * v28;
              if (v36)
              {
                v16 = v155;
                v37 = v154;
                v29 = v154;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 4:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)4,_rgbaf_t>((float32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
          }
          else
          {
            do
            {
              v156 = v488;
              do
              {
                v157 = *v24;
                if (*v24)
                {
                  if (v157 == 255)
                  {
                    v158 = 1.0;
                    v159 = 1.0 - v22[1].f32[1];
                    *v22 = vmul_n_f32(*(float32x2_t *)v29->f32, v159);
                    v22[1].f32[0] = v159 * v29->f32[2];
                    if (v17)
                      v158 = v29->f32[3];
                    v160 = v159 * v158;
                  }
                  else
                  {
                    v161 = (float)v157 * 0.0039216;
                    v162 = 1.0;
                    v163 = 1.0 - v161;
                    v165 = v22[1].f32[0];
                    v164 = v22[1].f32[1];
                    v166 = v161 * (float)(1.0 - v164);
                    *v22 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v166), *v22, v163);
                    v22[1].f32[0] = (float)(v166 * v29->f32[2]) + (float)(v165 * v163);
                    if (v17)
                      v162 = v29->f32[3];
                    v160 = (float)(v166 * v162) + (float)(v164 * v163);
                  }
                  v22[1].f32[1] = v160;
                }
                v24 += v33;
                v167 = &v29[v33];
                if ((unint64_t)v167 >= v16)
                  v168 = -(uint64_t)(int)v34;
                else
                  v168 = 0;
                v29 = &v167[v168];
                v22 += 2 * v33;
                --v156;
              }
              while (v156);
              v24 += v41;
              v22 += 2 * v42;
              v169 = &v37[v28];
              if ((unint64_t)v169 >= v36)
                v170 = -(v28 * (int)v35);
              else
                v170 = 0;
              v171 = &v169[v170];
              v172 = v16 + 16 * v170 + 16 * v28;
              if (v36)
              {
                v16 = v172;
                v37 = v171;
                v29 = v171;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 5:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)5,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              v173 = v488;
              do
              {
                if (*v24)
                {
                  v174 = vmulq_n_f32(*v29, (float)*v24 * 0.0039216);
                  *(float32x4_t *)v22->f32 = vmlaq_laneq_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v174.f32[3]), v174, *(float32x4_t *)v22->f32, 3);
                }
                v24 += v33;
                v175 = &v29[v33];
                if ((unint64_t)v175 >= v16)
                  v176 = -(uint64_t)(int)v34;
                else
                  v176 = 0;
                v29 = &v175[v176];
                v22 += 2 * v33;
                --v173;
              }
              while (v173);
              v24 += v41;
              v22 += 2 * v42;
              v177 = &v37[v28];
              if ((unint64_t)v177 >= v36)
                v178 = -(v28 * (int)v35);
              else
                v178 = 0;
              v179 = &v177[v178];
              v180 = v16 + 16 * v178 + 16 * v28;
              if (v36)
              {
                v16 = v180;
                v37 = v179;
                v29 = v179;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 6:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)6,_rgbaf_t>((int32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
            return;
          }
          while (1)
          {
            v181 = v488;
            do
            {
              v182 = *v24;
              if (!*v24)
                goto LABEL_301;
              v183 = v22[1].f32[1];
              v184 = 1.0 - v183;
              if ((float)(1.0 - v183) >= 1.0)
              {
                v187 = (float)v182 * 0.0039216;
                *v22 = vmul_n_f32(*(float32x2_t *)v29->f32, v187);
                v22[1].f32[0] = v187 * v29->f32[2];
                if (v17)
                  v188 = v29->f32[3];
                else
                  v188 = 1.0;
                v189 = v187 * v188;
              }
              else
              {
                if (v184 <= 0.0)
                  goto LABEL_301;
                v185 = (float)((float)v182 * 0.0039216) * v184;
                *v22 = vmla_n_f32(*v22, *(float32x2_t *)v29->f32, v185);
                v22[1].f32[0] = v22[1].f32[0] + (float)(v29->f32[2] * v185);
                if (v17)
                  v186 = v29->f32[3];
                else
                  v186 = 1.0;
                v189 = v183 + (float)(v186 * v185);
              }
              v22[1].f32[1] = v189;
LABEL_301:
              v24 += v33;
              v190 = &v29[v33];
              if ((unint64_t)v190 >= v16)
                v191 = -(uint64_t)(int)v34;
              else
                v191 = 0;
              v29 = &v190[v191];
              v22 += 2 * v33;
              --v181;
            }
            while (v181);
            v24 += v41;
            v22 += 2 * v42;
            v192 = &v37[v28];
            if ((unint64_t)v192 >= v36)
              v193 = -(v28 * (int)v35);
            else
              v193 = 0;
            v194 = &v192[v193];
            v195 = v16 + 16 * v193 + 16 * v28;
            if (v36)
            {
              v16 = v195;
              v37 = v194;
              v29 = v194;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489)
              return;
          }
        case 7:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)7,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              v196 = v488;
              do
              {
                v197 = *v24;
                if (*v24)
                {
                  if (v197 == 255)
                    v198 = vmulq_n_f32(*(float32x4_t *)v22->f32, v29->f32[3]);
                  else
                    v198 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - (float)((float)v197 * 0.0039216)), *(float32x4_t *)v22->f32, (float)((float)v197 * 0.0039216) * v29->f32[3]);
                  *(float32x4_t *)v22->f32 = v198;
                }
                v24 += v33;
                v199 = &v29[v33];
                if ((unint64_t)v199 >= v16)
                  v200 = -(uint64_t)(int)v34;
                else
                  v200 = 0;
                v29 = &v199[v200];
                v22 += 2 * v33;
                --v196;
              }
              while (v196);
              v24 += v41;
              v22 += 2 * v42;
              v201 = &v37[v28];
              if ((unint64_t)v201 >= v36)
                v202 = -(v28 * (int)v35);
              else
                v202 = 0;
              v203 = &v201[v202];
              v204 = v16 + 16 * v202 + 16 * v28;
              if (v36)
              {
                v16 = v204;
                v37 = v203;
                v29 = v203;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 8:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)8,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              v205 = v488;
              do
              {
                v206 = *v24;
                if (*v24)
                {
                  if (v206 == 255)
                  {
                    v207 = 1.0 - v29->f32[3];
                    v22->f32[0] = v22->f32[0] * v207;
                    v208 = (float *)v22 + 1;
                    v209 = v22->f32[1];
                    v210 = v207;
                  }
                  else
                  {
                    v209 = (float)((float)((float)v206 * -0.0039216) * v29->f32[3]) + 1.0;
                    v22->f32[0] = v22->f32[0] * v209;
                    v208 = (float *)v22 + 1;
                    v207 = v22->f32[1];
                    v210 = v209;
                  }
                  *v208 = v207 * v209;
                  v22[1] = vmul_n_f32(v22[1], v210);
                }
                v24 += v33;
                v22 += 2 * v33;
                v211 = &v29[v33];
                if ((unint64_t)v211 >= v16)
                  v212 = -(uint64_t)(int)v34;
                else
                  v212 = 0;
                v29 = &v211[v212];
                --v205;
              }
              while (v205);
              v24 += v41;
              v22 += 2 * v42;
              v213 = &v37[v28];
              if ((unint64_t)v213 >= v36)
                v214 = -(v28 * (int)v35);
              else
                v214 = 0;
              v215 = &v213[v214];
              v216 = v16 + 16 * v214 + 16 * v28;
              if (v36)
              {
                v16 = v216;
                v37 = v215;
                v29 = v215;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 9:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)9,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              v217 = v488;
              do
              {
                if (*v24)
                {
                  v218 = (float)*v24 * 0.0039216;
                  v219 = 1.0 - v218;
                  v220 = vmulq_n_f32(*v29, v218);
                  *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, v219 + v220.f32[3]), v220, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
                }
                v24 += v33;
                v221 = &v29[v33];
                if ((unint64_t)v221 >= v16)
                  v222 = -(uint64_t)(int)v34;
                else
                  v222 = 0;
                v29 = &v221[v222];
                v22 += 2 * v33;
                --v217;
              }
              while (v217);
              v24 += v41;
              v22 += 2 * v42;
              v223 = &v37[v28];
              if ((unint64_t)v223 >= v36)
                v224 = -(v28 * (int)v35);
              else
                v224 = 0;
              v225 = &v223[v224];
              v226 = v16 + 16 * v224 + 16 * v28;
              if (v36)
              {
                v16 = v226;
                v37 = v225;
                v29 = v225;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 10:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)10,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              v227 = v488;
              do
              {
                if (*v24)
                {
                  v228 = vmulq_n_f32(*v29, (float)*v24 * 0.0039216);
                  *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v228.f32[3]), v228, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
                }
                v24 += v33;
                v229 = &v29[v33];
                if ((unint64_t)v229 >= v16)
                  v230 = -(uint64_t)(int)v34;
                else
                  v230 = 0;
                v29 = &v229[v230];
                v22 += 2 * v33;
                --v227;
              }
              while (v227);
              v24 += v41;
              v22 += 2 * v42;
              v231 = &v37[v28];
              if ((unint64_t)v231 >= v36)
                v232 = -(v28 * (int)v35);
              else
                v232 = 0;
              v233 = &v231[v232];
              v234 = v16 + 16 * v232 + 16 * v28;
              if (v36)
              {
                v16 = v234;
                v37 = v233;
                v29 = v233;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 11:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)11,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
          }
          else
          {
            do
            {
              v235 = v488;
              do
              {
                if (*v24)
                {
                  v236 = (float)*v24 * 0.0039216;
                  v237 = v236 * v29->f32[0];
                  v238 = v29->f32[3];
                  if (v15)
                  {
                    v239 = v22[1].f32[1];
                    if (!v17)
                      v238 = 1.0;
                    v240 = v236 * v238;
                    v241 = (float)(v240 - v237) + (float)(v239 - v22->f32[0]);
                    if ((float)(v240 + v239) <= 1.0)
                      v242 = v240 + v239;
                    else
                      v242 = 1.0;
                  }
                  else
                  {
                    v239 = 1.0;
                    if (!v17)
                      v238 = 1.0;
                    v240 = v236 * v238;
                    v241 = (float)(v240 - v237) + (float)(1.0 - v22->f32[0]);
                    if ((float)(v240 + 1.0) <= 1.0)
                      v242 = v240 + 1.0;
                    else
                      v242 = 1.0;
                  }
                  v243 = (float)(v240 - (float)(v236 * v29->f32[1])) + (float)(v239 - v22->f32[1]);
                  v244 = v242 - v241;
                  v245 = v29->f32[2];
                  v22->f32[0] = v244;
                  v246 = (float)(v240 - (float)(v236 * v245)) + (float)(v239 - v22[1].f32[0]);
                  v22->f32[1] = v242 - v243;
                  v22[1].f32[0] = v242 - v246;
                  v22[1].f32[1] = v242;
                }
                v24 += v33;
                v22 += 2 * v33;
                v247 = &v29[v33];
                if ((unint64_t)v247 >= v16)
                  v248 = -(uint64_t)(int)v34;
                else
                  v248 = 0;
                v29 = &v247[v248];
                --v235;
              }
              while (v235);
              v24 += v41;
              v22 += 2 * v42;
              v249 = &v37[v28];
              if ((unint64_t)v249 >= v36)
                v250 = -(v28 * (int)v35);
              else
                v250 = 0;
              v251 = &v249[v250];
              v252 = v16 + 16 * v250 + 16 * v28;
              if (v36)
              {
                v16 = v252;
                v37 = v251;
                v29 = v251;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 12:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)12,_rgbaf_t>((float32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
          }
          else
          {
            do
            {
              v253 = v488;
              do
              {
                if (*v24)
                {
                  v254 = (float)*v24 * 0.0039216;
                  v255 = v29->f32[3];
                  v256 = v254 * v29->f32[2];
                  *v22 = vadd_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v254), *v22);
                  if (!v17)
                    v255 = 1.0;
                  v257 = (float)(v254 * v255) + v22[1].f32[1];
                  v258 = v256 + v22[1].f32[0];
                  if (v257 > 1.0)
                    v257 = 1.0;
                  v22[1].f32[0] = v258;
                  v22[1].f32[1] = v257;
                }
                v24 += v33;
                v259 = &v29[v33];
                if ((unint64_t)v259 >= v16)
                  v260 = -(uint64_t)(int)v34;
                else
                  v260 = 0;
                v29 = &v259[v260];
                v22 += 2 * v33;
                --v253;
              }
              while (v253);
              v24 += v41;
              v22 += 2 * v42;
              v261 = &v37[v28];
              if ((unint64_t)v261 >= v36)
                v262 = -(v28 * (int)v35);
              else
                v262 = 0;
              v263 = &v261[v262];
              v264 = v16 + 16 * v262 + 16 * v28;
              if (v36)
              {
                v16 = v264;
                v37 = v263;
                v29 = v263;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 13:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)13,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v265 = v33;
          v266 = -(uint64_t)(int)v34;
          v464 = -(v28 * (int)v35);
          v267 = 16 * v33;
          while (1)
          {
            v480 = v37;
            v268 = v488;
            do
            {
              v269 = *v24;
              if (*v24)
              {
                v270 = (float)v269 * 0.0039216;
                v271 = v29->f32[3];
                *(float *)&a10 = v270 * v271;
                *(float *)&a9 = v17 ? v270 * v271 : (float)v269 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v270 * v29->f32[0];
                  v272 = v270 * v29->f32[1];
                  v273 = v270 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v274 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v272;
                      v22[1].f32[0] = v273;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_436;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v274 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAmultiplyPDA(v22->f32[0], a5, a6, a7, v274, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v273))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_436:
              v24 += v265;
              v275 = &v29[v265];
              if ((unint64_t)v275 >= v16)
                v276 = v266;
              else
                v276 = 0;
              v29 = &v275[v276];
              v22 = (float32x2_t *)((char *)v22 + v267);
              --v268;
            }
            while (v268);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v480;
            v277 = &v480[v475];
            v278 = v464;
            if ((unint64_t)v277 < v473)
              v278 = 0;
            v279 = &v277[v278];
            v280 = v16 + 16 * v278 + 16 * v475;
            if (v473)
            {
              v16 = v280;
              v37 = v279;
              v29 = v279;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 14:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)14,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          __asm { FMOV            V2.2S, #1.0 }
          while (1)
          {
            v286 = v488;
            do
            {
              if (*v24)
              {
                v287 = (float)*v24 * 0.0039216;
                v288 = v29->f32[3];
                if (!v17)
                  v288 = 1.0;
                v289 = v287 * v288;
                if (v289 > 0.0)
                {
                  v290 = vmul_n_f32(*(float32x2_t *)v29->f32, v287);
                  v291 = v287 * v29->f32[2];
                  if (v15)
                  {
                    v292 = v22[1].f32[1];
                    if (v292 <= 0.0)
                    {
                      *v22 = v290;
LABEL_458:
                      v22[1].f32[0] = v291;
                      v22[1].f32[1] = v289;
                      goto LABEL_459;
                    }
                  }
                  else
                  {
                    v292 = 1.0;
                  }
                  v291 = v22[1].f32[0] + (float)(v291 * (float)(1.0 - v22[1].f32[0]));
                  *v22 = vmla_f32(*v22, vsub_f32(_D2, *v22), v290);
                  v289 = (float)(v289 + v292) - (float)(v292 * v289);
                  goto LABEL_458;
                }
              }
LABEL_459:
              v24 += v33;
              v293 = &v29[v33];
              if ((unint64_t)v293 >= v16)
                v294 = -(uint64_t)(int)v34;
              else
                v294 = 0;
              v29 = &v293[v294];
              v22 += 2 * v33;
              --v286;
            }
            while (v286);
            v24 += v41;
            v22 += 2 * v42;
            v295 = &v37[v28];
            if ((unint64_t)v295 >= v36)
              v296 = -(v28 * (int)v35);
            else
              v296 = 0;
            v297 = &v295[v296];
            v298 = v16 + 16 * v296 + 16 * v28;
            if (v36)
            {
              v16 = v298;
              v37 = v297;
              v29 = v297;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489)
              return;
          }
        case 15:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)15,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v299 = v33;
          v300 = -(uint64_t)(int)v34;
          v465 = -(v28 * (int)v35);
          v301 = 16 * v33;
          while (1)
          {
            v481 = v37;
            v302 = v488;
            do
            {
              v303 = *v24;
              if (*v24)
              {
                v304 = (float)v303 * 0.0039216;
                v305 = v29->f32[3];
                *(float *)&a10 = v304 * v305;
                *(float *)&a9 = v17 ? v304 * v305 : (float)v303 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v304 * v29->f32[0];
                  v306 = v304 * v29->f32[1];
                  v307 = v304 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v308 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v306;
                      v22[1].f32[0] = v307;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_483;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v308 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAoverlayPDA(v22->f32[0], a5, a6, a7, v308, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v307))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_483:
              v24 += v299;
              v309 = &v29[v299];
              if ((unint64_t)v309 >= v16)
                v310 = v300;
              else
                v310 = 0;
              v29 = &v309[v310];
              v22 = (float32x2_t *)((char *)v22 + v301);
              --v302;
            }
            while (v302);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v481;
            v311 = &v481[v475];
            v312 = v465;
            if ((unint64_t)v311 < v473)
              v312 = 0;
            v313 = &v311[v312];
            v314 = v16 + 16 * v312 + 16 * v475;
            if (v473)
            {
              v16 = v314;
              v37 = v313;
              v29 = v313;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 16:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)16,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v315 = v33;
          v316 = -(uint64_t)(int)v34;
          v466 = -(v28 * (int)v35);
          v317 = 16 * v33;
          while (1)
          {
            v482 = v37;
            v318 = v488;
            do
            {
              v319 = *v24;
              if (*v24)
              {
                v320 = (float)v319 * 0.0039216;
                v321 = v29->f32[3];
                *(float *)&a10 = v320 * v321;
                *(float *)&a9 = v17 ? v320 * v321 : (float)v319 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v320 * v29->f32[0];
                  v322 = v320 * v29->f32[1];
                  v323 = v320 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v324 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v322;
                      v22[1].f32[0] = v323;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_506;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v324 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAdarkenPDA(v22->f32[0], a5, a6, a7, v324, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v323))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_506:
              v24 += v315;
              v325 = &v29[v315];
              if ((unint64_t)v325 >= v16)
                v326 = v316;
              else
                v326 = 0;
              v29 = &v325[v326];
              v22 = (float32x2_t *)((char *)v22 + v317);
              --v318;
            }
            while (v318);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v482;
            v327 = &v482[v475];
            v328 = v466;
            if ((unint64_t)v327 < v473)
              v328 = 0;
            v329 = &v327[v328];
            v330 = v16 + 16 * v328 + 16 * v475;
            if (v473)
            {
              v16 = v330;
              v37 = v329;
              v29 = v329;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 17:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)17,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v331 = v33;
          v332 = -(uint64_t)(int)v34;
          v467 = -(v28 * (int)v35);
          v333 = 16 * v33;
          while (1)
          {
            v483 = v37;
            v334 = v488;
            do
            {
              v335 = *v24;
              if (*v24)
              {
                v336 = (float)v335 * 0.0039216;
                v337 = v29->f32[3];
                *(float *)&a10 = v336 * v337;
                *(float *)&a9 = v17 ? v336 * v337 : (float)v335 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v336 * v29->f32[0];
                  v338 = v336 * v29->f32[1];
                  v339 = v336 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v340 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v338;
                      v22[1].f32[0] = v339;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_529;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v340 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAlightenPDA(v22->f32[0], a5, a6, a7, v340, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v339))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_529:
              v24 += v331;
              v341 = &v29[v331];
              if ((unint64_t)v341 >= v16)
                v342 = v332;
              else
                v342 = 0;
              v29 = &v341[v342];
              v22 = (float32x2_t *)((char *)v22 + v333);
              --v334;
            }
            while (v334);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v483;
            v343 = &v483[v475];
            v344 = v467;
            if ((unint64_t)v343 < v473)
              v344 = 0;
            v345 = &v343[v344];
            v346 = v16 + 16 * v344 + 16 * v475;
            if (v473)
            {
              v16 = v346;
              v37 = v345;
              v29 = v345;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 18:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)18,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v347 = v33;
          v348 = -(uint64_t)(int)v34;
          v468 = -(v28 * (int)v35);
          v349 = 16 * v33;
          while (1)
          {
            v484 = v37;
            v350 = v488;
            do
            {
              v351 = *v24;
              if (*v24)
              {
                v352 = (float)v351 * 0.0039216;
                v353 = v29->f32[3];
                *(float *)&a10 = v352 * v353;
                *(float *)&a9 = v17 ? v352 * v353 : (float)v351 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v352 * v29->f32[0];
                  v354 = v352 * v29->f32[1];
                  v355 = v352 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v356 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v354;
                      v22[1].f32[0] = v355;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_552;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v356 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAcolordodgePDA(v22->f32[0], a5, a6, a7, v356, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v355))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_552:
              v24 += v347;
              v357 = &v29[v347];
              if ((unint64_t)v357 >= v16)
                v358 = v348;
              else
                v358 = 0;
              v29 = &v357[v358];
              v22 = (float32x2_t *)((char *)v22 + v349);
              --v350;
            }
            while (v350);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v484;
            v359 = &v484[v475];
            v360 = v468;
            if ((unint64_t)v359 < v473)
              v360 = 0;
            v361 = &v359[v360];
            v362 = v16 + 16 * v360 + 16 * v475;
            if (v473)
            {
              v16 = v362;
              v37 = v361;
              v29 = v361;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 19:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)19,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v363 = v33;
          v364 = -(uint64_t)(int)v34;
          v469 = -(v28 * (int)v35);
          v365 = 16 * v33;
          while (1)
          {
            v485 = v37;
            v366 = v488;
            do
            {
              v367 = *v24;
              if (*v24)
              {
                v368 = (float)v367 * 0.0039216;
                v369 = v29->f32[3];
                *(float *)&a10 = v368 * v369;
                *(float *)&a9 = v17 ? v368 * v369 : (float)v367 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v368 * v29->f32[0];
                  v370 = v368 * v29->f32[1];
                  v371 = v368 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v372 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v370;
                      v22[1].f32[0] = v371;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_575;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v372 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAcolorburnPDA(v22->f32[0], a5, a6, a7, v372, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v371))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_575:
              v24 += v363;
              v373 = &v29[v363];
              if ((unint64_t)v373 >= v16)
                v374 = v364;
              else
                v374 = 0;
              v29 = &v373[v374];
              v22 = (float32x2_t *)((char *)v22 + v365);
              --v366;
            }
            while (v366);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v485;
            v375 = &v485[v475];
            v376 = v469;
            if ((unint64_t)v375 < v473)
              v376 = 0;
            v377 = &v375[v376];
            v378 = v16 + 16 * v376 + 16 * v475;
            if (v473)
            {
              v16 = v378;
              v37 = v377;
              v29 = v377;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 20:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)20,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v379 = v33;
          v380 = -(uint64_t)(int)v34;
          v470 = -(v28 * (int)v35);
          v381 = 16 * v33;
          while (1)
          {
            v486 = v37;
            v382 = v488;
            do
            {
              v383 = *v24;
              if (*v24)
              {
                v384 = (float)v383 * 0.0039216;
                v385 = v29->f32[3];
                *(float *)&a9 = v17 ? v384 * v385 : (float)v383 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v384 * v29->f32[0];
                  v386 = v384 * v29->f32[1];
                  v387 = v384 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    LODWORD(a8) = LODWORD(a7);
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v386;
                      v22[1].f32[0] = v387;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_598;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    LODWORD(a8) = 1.0;
                  }
                  LODWORD(a6) = v22[1].i32[0];
                  *(float *)&a10 = v384 * v385;
                  v22->f32[0] = PDAsoftlightPDA(v22->f32[0], v22->f32[1], a6, *(int32x2_t *)&a7, a8, a9, a10, a11, v36, v42, a3, v28, (uint64_t)v37, v35, v34, (uint64_t)v12, *(float *)&a11, LODWORD(v386), __SPAIR64__(LODWORD(a10), LODWORD(v387)),
                                  *(float *)&a9);
                  v22->i32[1] = v388;
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_598:
              v24 += v379;
              v389 = &v29[v379];
              if ((unint64_t)v389 >= v16)
                v390 = v380;
              else
                v390 = 0;
              v29 = &v389[v390];
              v22 = (float32x2_t *)((char *)v22 + v381);
              --v382;
            }
            while (v382);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v486;
            v391 = &v486[v475];
            v392 = v470;
            if ((unint64_t)v391 < v473)
              v392 = 0;
            v393 = &v391[v392];
            v394 = v16 + 16 * v392 + 16 * v475;
            if (v473)
            {
              v16 = v394;
              v37 = v393;
              v29 = v393;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 21:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)21,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          v395 = v33;
          v396 = -(uint64_t)(int)v34;
          v471 = -(v28 * (int)v35);
          v397 = 16 * v33;
          while (1)
          {
            v487 = v37;
            v398 = v488;
            do
            {
              v399 = *v24;
              if (*v24)
              {
                v400 = (float)v399 * 0.0039216;
                v401 = v29->f32[3];
                *(float *)&a10 = v400 * v401;
                *(float *)&a9 = v17 ? v400 * v401 : (float)v399 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v400 * v29->f32[0];
                  v402 = v400 * v29->f32[1];
                  v403 = v400 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v404 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v402;
                      v22[1].f32[0] = v403;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_621;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v404 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAhardlightPDA(v22->f32[0], a5, a6, a7, v404, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v403))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_621:
              v24 += v395;
              v405 = &v29[v395];
              if ((unint64_t)v405 >= v16)
                v406 = v396;
              else
                v406 = 0;
              v29 = &v405[v406];
              v22 = (float32x2_t *)((char *)v22 + v397);
              --v398;
            }
            while (v398);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v487;
            v407 = &v487[v475];
            v408 = v471;
            if ((unint64_t)v407 < v473)
              v408 = 0;
            v409 = &v407[v408];
            v410 = v16 + 16 * v408 + 16 * v475;
            if (v473)
            {
              v16 = v410;
              v37 = v409;
              v29 = v409;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 22:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)22,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          while (1)
          {
            v411 = v488;
            do
            {
              if (*v24)
              {
                v412 = (float)*v24 * 0.0039216;
                v413 = v29->f32[3];
                if (!v17)
                  v413 = 1.0;
                v414 = v412 * v413;
                if (v414 > 0.0)
                {
                  v415 = vmul_n_f32(*(float32x2_t *)v29->f32, v412);
                  v416 = v412 * v29->f32[2];
                  if (v15)
                  {
                    v417 = v22[1].f32[1];
                    if (v417 <= 0.0)
                    {
                      *v22 = v415;
LABEL_644:
                      v22[1].f32[0] = v416;
                      v22[1].f32[1] = v414;
                      goto LABEL_645;
                    }
                  }
                  else
                  {
                    v417 = 1.0;
                  }
                  v418 = v22[1].f32[0];
                  v419 = vadd_f32(*v22, v415);
                  v420 = vmul_n_f32(*v22, v414);
                  v421 = vmul_n_f32(v415, v417);
                  v422 = vsub_f32(v419, v420);
                  v423 = vsub_f32(v420, v421);
                  v424 = vadd_f32(vsub_f32(v422, v421), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v423), (int8x8_t)vneg_f32(v423), (int8x8_t)v423));
                  v423.f32[0] = v418 + v416;
                  v425 = v418 * v414;
                  v426 = v416 * v417;
                  v423.f32[0] = v423.f32[0] - v425;
                  v427 = v425 - v426;
                  v428 = v423.f32[0] - v426;
                  v429 = -v427;
                  if (v427 >= 0.0)
                    v429 = v427;
                  v416 = v428 + v429;
                  *v22 = v424;
                  v414 = (float)(v417 + v414) - (float)(v417 * v414);
                  goto LABEL_644;
                }
              }
LABEL_645:
              v24 += v33;
              v430 = &v29[v33];
              if ((unint64_t)v430 >= v16)
                v431 = -(uint64_t)(int)v34;
              else
                v431 = 0;
              v29 = &v430[v431];
              v22 += 2 * v33;
              --v411;
            }
            while (v411);
            v24 += v41;
            v22 += 2 * v42;
            v432 = &v37[v28];
            if ((unint64_t)v432 >= v36)
              v433 = -(v28 * (int)v35);
            else
              v433 = 0;
            v434 = &v432[v433];
            v435 = v16 + 16 * v433 + 16 * v28;
            if (v36)
            {
              v16 = v435;
              v37 = v434;
              v29 = v434;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489)
              return;
          }
        case 23:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)23,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          while (1)
          {
            v436 = v488;
            do
            {
              if (*v24)
              {
                v437 = (float)*v24 * 0.0039216;
                v438 = v29->f32[3];
                if (!v17)
                  v438 = 1.0;
                v439 = v437 * v438;
                if (v439 > 0.0)
                {
                  v440 = vmul_n_f32(*(float32x2_t *)v29->f32, v437);
                  v441 = v437 * v29->f32[2];
                  if (v15)
                  {
                    v442 = v22[1].f32[1];
                    if (v442 <= 0.0)
                    {
                      *v22 = v440;
LABEL_667:
                      v22[1].f32[0] = v441;
                      v22[1].f32[1] = v439;
                      goto LABEL_668;
                    }
                  }
                  else
                  {
                    v442 = 1.0;
                  }
                  v441 = (float)(v441 + v22[1].f32[0]) + (float)((float)(v441 * v22[1].f32[0]) * -2.0);
                  *v22 = vmla_f32(vadd_f32(v440, *v22), (float32x2_t)0xC0000000C0000000, vmul_f32(v440, *v22));
                  v439 = (float)(v439 + v442) - (float)(v442 * v439);
                  goto LABEL_667;
                }
              }
LABEL_668:
              v24 += v33;
              v443 = &v29[v33];
              if ((unint64_t)v443 >= v16)
                v444 = -(uint64_t)(int)v34;
              else
                v444 = 0;
              v29 = &v443[v444];
              v22 += 2 * v33;
              --v436;
            }
            while (v436);
            v24 += v41;
            v22 += 2 * v42;
            v445 = &v37[v28];
            if ((unint64_t)v445 >= v36)
              v446 = -(v28 * (int)v35);
            else
              v446 = 0;
            v447 = &v445[v446];
            v448 = v16 + 16 * v446 + 16 * v28;
            if (v36)
            {
              v16 = v448;
              v37 = v447;
              v29 = v447;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489)
              return;
          }
        case 24:
          v56 = v33;
          v57 = -(uint64_t)(int)v34;
          v460 = -(v28 * (int)v35);
          v58 = 16 * v33;
          while (1)
          {
            v476 = v37;
            v59 = v488;
            do
            {
              v60 = *v24;
              if (*v24)
              {
                v61 = (float)v60 * 0.0039216;
                v62 = v29->f32[3];
                *(float *)&a9 = v17 ? v61 * v62 : (float)v60 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v61 * v29->f32[0];
                  v63 = v61 * v29->f32[1];
                  v64 = v61 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v65 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v63;
                      v22[1].f32[0] = v64;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_125;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v65 = 1.0;
                  }
                  *(float *)&a10 = v61 * v62;
                  v22->f32[0] = PDAhuePDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a7, v65, a9, a10, a11, *(float *)&a11, v63, v64, *(float *)&a10, *(float *)&a9);
                  v22->i32[1] = v66;
                  v22[1].i32[0] = v67;
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_125:
              v24 += v56;
              v68 = &v29[v56];
              if ((unint64_t)v68 >= v16)
                v69 = v57;
              else
                v69 = 0;
              v29 = &v68[v69];
              v22 = (float32x2_t *)((char *)v22 + v58);
              --v59;
            }
            while (v59);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v476;
            v70 = &v476[v475];
            v71 = v460;
            if ((unint64_t)v70 < v473)
              v71 = 0;
            v72 = &v70[v71];
            v73 = v16 + 16 * v71 + 16 * v475;
            if (v473)
            {
              v16 = v73;
              v37 = v72;
              v29 = v72;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 25:
          v74 = v33;
          v75 = -(uint64_t)(int)v34;
          v461 = -(v28 * (int)v35);
          v76 = 16 * v33;
          while (1)
          {
            v477 = v37;
            v77 = v488;
            do
            {
              v78 = *v24;
              if (*v24)
              {
                v79 = (float)v78 * 0.0039216;
                v80 = v29->f32[3];
                *(float *)&a9 = v17 ? v79 * v80 : (float)v78 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v79 * v29->f32[0];
                  v81 = v79 * v29->f32[1];
                  v82 = v79 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v83 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v81;
                      v22[1].f32[0] = v82;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_148;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    v83 = 1.0;
                  }
                  *(float *)&a10 = v79 * v80;
                  v22->f32[0] = PDAsaturationPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a7, v83, a9, a10, a11, *(float *)&a11, v81, v82, *(float *)&a10, *(float *)&a9);
                  v22->i32[1] = v84;
                  v22[1].i32[0] = v85;
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_148:
              v24 += v74;
              v86 = &v29[v74];
              if ((unint64_t)v86 >= v16)
                v87 = v75;
              else
                v87 = 0;
              v29 = &v86[v87];
              v22 = (float32x2_t *)((char *)v22 + v76);
              --v77;
            }
            while (v77);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v477;
            v88 = &v477[v475];
            v89 = v461;
            if ((unint64_t)v88 < v473)
              v89 = 0;
            v90 = &v88[v89];
            v91 = v16 + 16 * v89 + 16 * v475;
            if (v473)
            {
              v16 = v91;
              v37 = v90;
              v29 = v90;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 26:
          v92 = v33;
          v93 = -(uint64_t)(int)v34;
          v462 = -(v28 * (int)v35);
          v94 = 16 * v33;
          while (1)
          {
            v478 = v37;
            v95 = v488;
            do
            {
              v96 = *v24;
              if (*v24)
              {
                v97 = (float)v96 * 0.0039216;
                v98 = v29->f32[3];
                *(float *)&a7 = v97 * v98;
                v99 = v17 ? v97 * v98 : (float)v96 * 0.0039216;
                if (v99 > 0.0)
                {
                  v100 = v97 * v29->f32[0];
                  v101 = v97 * v29->f32[1];
                  v102 = v97 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a9) = v22[1].i32[1];
                    LODWORD(a10) = LODWORD(a9);
                    if (*(float *)&a9 <= 0.0)
                    {
                      v22->f32[0] = v100;
                      v22->f32[1] = v101;
                      v22[1].f32[0] = v102;
                      v22[1].f32[1] = v99;
                      goto LABEL_171;
                    }
                  }
                  else
                  {
                    LODWORD(a9) = v22[1].i32[1];
                    LODWORD(a10) = 1.0;
                  }
                  LODWORD(a11) = v22[1].i32[0];
                  v22->f32[0] = PDAluminosityPDA(v100, v101, v102, a7, v99, a9, a10, a11, COERCE_FLOAT(*v22), COERCE_FLOAT(HIDWORD(*(unint64_t *)v22)), *(float *)&a11, *(float *)&a9, *(float *)&a10);
                  v22->i32[1] = v103;
                  v22[1].i32[0] = v104;
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_171:
              v24 += v92;
              v105 = &v29[v92];
              if ((unint64_t)v105 >= v16)
                v106 = v93;
              else
                v106 = 0;
              v29 = &v105[v106];
              v22 = (float32x2_t *)((char *)v22 + v94);
              --v95;
            }
            while (v95);
            v24 += v472;
            v22 += 2 * v474;
            v37 = v478;
            v107 = &v478[v475];
            v108 = v462;
            if ((unint64_t)v107 < v473)
              v108 = 0;
            v109 = &v107[v108];
            v110 = v16 + 16 * v108 + 16 * v475;
            if (v473)
            {
              v16 = v110;
              v37 = v109;
              v29 = v109;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489)
              return;
          }
        case 27:
          v111 = v33;
          v112 = -(uint64_t)(int)v34;
          v463 = -(v28 * (int)v35);
          v113 = 16 * v33;
          break;
        default:
          return;
      }
LABEL_183:
      v479 = v37;
      v114 = v488;
      while (1)
      {
        v115 = *v24;
        if (!*v24)
          goto LABEL_194;
        v116 = (float)v115 * 0.0039216;
        v117 = v29->f32[3];
        *(float *)&a9 = v17 ? v116 * v117 : (float)v115 * 0.0039216;
        if (*(float *)&a9 <= 0.0)
          goto LABEL_194;
        *(float *)&a11 = v116 * v29->f32[0];
        v118 = v116 * v29->f32[1];
        v119 = v116 * v29->f32[2];
        if (!v15)
          break;
        LODWORD(a7) = v22[1].i32[1];
        v120 = *(float *)&a7;
        if (*(float *)&a7 > 0.0)
          goto LABEL_193;
        v22->i32[0] = LODWORD(a11);
        v22->f32[1] = v118;
        v22[1].f32[0] = v119;
        v22[1].i32[1] = LODWORD(a9);
LABEL_194:
        v24 += v111;
        v123 = &v29[v111];
        if ((unint64_t)v123 >= v16)
          v124 = v112;
        else
          v124 = 0;
        v29 = &v123[v124];
        v22 = (float32x2_t *)((char *)v22 + v113);
        if (!--v114)
        {
          v24 += v472;
          v22 += 2 * v474;
          v37 = v479;
          v125 = &v479[v475];
          v126 = v463;
          if ((unint64_t)v125 < v473)
            v126 = 0;
          v127 = &v125[v126];
          v128 = v16 + 16 * v126 + 16 * v475;
          if (v473)
          {
            v16 = v128;
            v37 = v127;
            v29 = v127;
          }
          else
          {
            v29 += v475;
          }
          if (!--v489)
            return;
          goto LABEL_183;
        }
      }
      LODWORD(a7) = v22[1].i32[1];
      v120 = 1.0;
LABEL_193:
      *(float *)&a10 = v116 * v117;
      v22->f32[0] = PDAluminosityPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a7, v120, a9, a10, a11, *(float *)&a11, v118, v119, *(float *)&a10, *(float *)&a9);
      v22->i32[1] = v121;
      v22[1].i32[0] = v122;
      v22[1].i32[1] = LODWORD(a7);
      goto LABEL_194;
    }
    if ((char *)v22 - (char *)v29 >= 1)
    {
      if (v488 >= (uint64_t)((unint64_t)((char *)v22 - (char *)v29) >> 4))
      {
        v22 += 2 * v488 - 2;
        v29 += v488 - 1;
        v24 += v488 - 1;
        v33 = -1;
        goto LABEL_13;
      }
      v31 = v489 - 1;
      v32 = &v29[v21 * v31];
      if (v22 <= (float32x2_t *)&v32[v488 - 1])
      {
        v22 += 2 * v21 * v31;
        v28 = -(uint64_t)v21;
        v24 += v23 * v31;
        v23 = -v23;
        v33 = 1;
        v29 = v32;
        v21 = -(uint64_t)v21;
        goto LABEL_14;
      }
    }
    v33 = 1;
LABEL_13:
    v28 = v13 >> 4;
    goto LABEL_14;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)2,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v26;
  float32x4_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int8x16_t *v31;
  int8x16_t *v32;
  int8x16_t *v33;
  int8x16_t *v34;
  uint64_t v35;
  int64_t v36;
  unint64_t v37;
  int8x16_t *v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  int8x16_t v43;
  int8x16_t *v44;
  int8x16_t *v45;
  int8x16_t *v46;
  int8x16_t *v47;
  int64_t v48;
  int64_t v49;
  uint64_t v50;
  int8x16_t *v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t v56;
  unint64_t i;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t *v60;
  uint64_t v61;
  float32x4_t *v62;
  uint64_t v63;
  float32x4_t *v64;
  uint64_t v65;
  int8x16_t v66;
  float32x4_t v67;
  unint64_t v68;
  unint64_t v69;
  int v70;
  int8x16_t *v71;
  int8x16_t *v72;
  int8x16_t *v73;
  int8x16_t *v74;
  uint64_t v75;
  int64_t v76;
  unint64_t v77;
  int8x16_t *v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  int8x16_t *v85;
  int8x16_t *v86;
  int8x16_t *v87;
  int8x16_t *v88;
  int64_t v89;
  int64_t v90;
  uint64_t v91;
  int8x16_t *v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  unint64_t j;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t *v103;
  uint64_t v104;
  float32x4_t *v105;
  uint64_t v106;
  float32x4_t *v107;
  uint64_t v108;

  v17 = 2 * a14;
  v18 = -(a6 * a4);
  v19 = 32 * a14;
  v20 = 16 * a14;
  __asm { FMOV            V0.4S, #1.0 }
  if ((a15 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12)
        v28 = a12;
      v29 = v28;
      if (v28 < 2)
        goto LABEL_37;
      while (1)
      {
        v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v44 = (int8x16_t *)&a10[v29];
          v45 = (int8x16_t *)a10;
          do
            v46 = v45++;
          while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
          do
          {
            v47 = v46;
            v46 = (int8x16_t *)((char *)v46 + 4);
          }
          while (v46 <= v44 && !v47->i32[0]);
          if (v47 < v44)
          {
            while (!v47->i8[0])
            {
              v47 = (int8x16_t *)((char *)v47 + 1);
              if (v47 >= v44)
              {
                v47 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          v48 = (char *)v47 - a10;
          v49 = ((char *)v47 - a10) * a14;
          a3 += v49;
          result += v49;
          a10 += v49;
          v29 -= v48;
          goto LABEL_34;
        }
        if (v30 != 0xFFFF)
          break;
        v31 = (int8x16_t *)&a10[v29];
        v32 = (int8x16_t *)a10;
        do
          v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          v34 = v33;
          v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        v35 = 0;
        v36 = (char *)v34 - a10;
        v37 = (char *)v34 - a10;
        do
        {
          v38 = (int8x16_t *)((char *)result + v35);
          v39 = *(float32x4_t *)((char *)a3 + v35);
          v40 = *(float32x4_t *)((char *)a3 + v35 + 16);
          v41 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 3);
          v42 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 3);
          v43 = vbslq_s8((int8x16_t)vcgtzq_f32(v41), (int8x16_t)vaddq_f32(v40, vmlsq_f32(*(float32x4_t *)((char *)result + v35 + 16), vmaxnmq_f32(vminnmq_f32(v41, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v35 + 16))), *(int8x16_t *)((char *)&result[1] + v35));
          *v38 = vbslq_s8((int8x16_t)vcgtzq_f32(v42), (int8x16_t)vaddq_f32(v39, vmlsq_f32(*(float32x4_t *)((char *)result + v35), vmaxnmq_f32(vminnmq_f32(v42, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v35))), *(int8x16_t *)((char *)result + v35));
          v38[1] = v43;
          a10 += v17;
          v37 -= 2;
          v35 += v19;
        }
        while (v37 > 1);
        a3 = (float32x4_t *)((char *)a3 + v35);
        result = (float32x4_t *)((char *)result + v35);
        v29 = v29 - v36 + v37;
LABEL_34:
        if (v29 <= 1)
          goto LABEL_37;
      }
      v50 = 0;
      while (1)
      {
        v51 = (int8x16_t *)((char *)result + v50);
        v52 = vmulq_f32(*(float32x4_t *)((char *)a3 + v50), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27));
        v53 = vmulq_f32(*(float32x4_t *)((char *)a3 + v50 + 16), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27));
        v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
        v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
        v56 = vbslq_s8((int8x16_t)vcgtzq_f32(v54), (int8x16_t)vaddq_f32(v53, vmlsq_f32(*(float32x4_t *)((char *)result + v50 + 16), vmaxnmq_f32(vminnmq_f32(v54, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v50 + 16))), *(int8x16_t *)((char *)&result[1] + v50));
        *v51 = vbslq_s8((int8x16_t)vcgtzq_f32(v55), (int8x16_t)vaddq_f32(v52, vmlsq_f32(*(float32x4_t *)((char *)result + v50), vmaxnmq_f32(vminnmq_f32(v55, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v50))), *(int8x16_t *)((char *)result + v50));
        v51[1] = v56;
        a10 += v17;
        v29 -= 2;
        if (v29 < 2)
          break;
        LOWORD(v30) = *(_WORD *)a10;
        v50 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v50);
          a3 = (float32x4_t *)((char *)a3 + v50);
          goto LABEL_34;
        }
      }
      result = (float32x4_t *)((char *)result + v19 + v50);
      a3 = (float32x4_t *)((char *)a3 + v19 + v50);
LABEL_37:
      for (i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          v58 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27), *a3);
          v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3);
          *(int8x16_t *)result = vbslq_s8((int8x16_t)vcgtzq_f32(v59), (int8x16_t)vaddq_f32(v58, vmlsq_f32(*result, vmaxnmq_f32(vminnmq_f32(v59, _Q0), (float32x4_t)0), *result)), *(int8x16_t *)result);
        }
        v60 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v60 >= a8)
          v61 = -(uint64_t)a7;
        else
          v61 = 0;
        a3 = &v60[v61];
        result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      v62 = &a5[a4];
      if ((unint64_t)v62 >= a9)
        v63 = v18;
      else
        v63 = 0;
      v64 = &v62[v63];
      v65 = a8 + 16 * v63 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v64;
        a8 = v65;
        a5 = v64;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v66.i64[0] = -1;
  v66.i64[1] = -1;
  v67 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v68 = (a8 - (unint64_t)a3) >> 4;
    if (v68 >= a12)
      v68 = a12;
    v69 = v68;
    if (v68 < 2)
      goto LABEL_87;
    while (1)
    {
      v70 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v85 = (int8x16_t *)&a10[v69];
        v86 = (int8x16_t *)a10;
        do
          v87 = v86++;
        while (v86 <= v85 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v87)) & 0x80) != 0);
        do
        {
          v88 = v87;
          v87 = (int8x16_t *)((char *)v87 + 4);
        }
        while (v87 <= v85 && !v88->i32[0]);
        if (v88 < v85)
        {
          while (!v88->i8[0])
          {
            v88 = (int8x16_t *)((char *)v88 + 1);
            if (v88 >= v85)
            {
              v88 = (int8x16_t *)&a10[v69];
              break;
            }
          }
        }
        v89 = (char *)v88 - a10;
        v90 = ((char *)v88 - a10) * a14;
        a3 += v90;
        result += v90;
        a10 += v90;
        v69 -= v89;
        goto LABEL_84;
      }
      if (v70 != 0xFFFF)
        break;
      v71 = (int8x16_t *)&a10[v69];
      v72 = (int8x16_t *)a10;
      do
        v73 = v72++;
      while (v72 <= v71 && (vminvq_u8((uint8x16_t)vceqq_s8(*v73, v66)) & 0x80) != 0);
      do
      {
        v74 = v73;
        v73 = (int8x16_t *)((char *)v73 + 4);
      }
      while (v73 <= v71 && v74->i32[0] == -1);
      if (v74 < v71)
      {
        while (v74->u8[0] == 255)
        {
          v74 = (int8x16_t *)((char *)v74 + 1);
          if (v74 >= v71)
          {
            v74 = (int8x16_t *)&a10[v69];
            break;
          }
        }
      }
      v75 = 0;
      v76 = (char *)v74 - a10;
      v77 = (char *)v74 - a10;
      do
      {
        v78 = (int8x16_t *)((char *)result + v75);
        v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v75));
        v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v75));
        v81 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v75));
        v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v75));
        v83 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        v84 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3);
        *v78 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v83), (int8x16_t)vaddq_f32(vmlsq_f32(v82, vmaxnmq_f32(vminnmq_f32(v83, _Q0), (float32x4_t)0), v82), v80), (int8x16_t)v82));
        v78[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v84), (int8x16_t)vaddq_f32(vmlsq_f32(v81, vmaxnmq_f32(vminnmq_f32(v84, _Q0), (float32x4_t)0), v81), v79), (int8x16_t)v81));
        a10 += v17;
        v77 -= 2;
        v75 += v19;
      }
      while (v77 > 1);
      a3 = (float32x4_t *)((char *)a3 + v75);
      result = (float32x4_t *)((char *)result + v75);
      v69 = v69 - v76 + v77;
LABEL_84:
      if (v69 <= 1)
        goto LABEL_87;
    }
    v91 = 0;
    while (1)
    {
      v92 = (int8x16_t *)((char *)result + v91);
      v93 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v91));
      v94 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v91));
      v95 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v70) & 0xFF00FF00FF00FFLL))), v67), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v91)));
      v96 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3);
      v97 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v70)) & 0xFF00FF00FF00FFLL))), v67), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v91)));
      v98 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3);
      *v92 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v96), (int8x16_t)vaddq_f32(v95, vmlsq_f32(v94, vmaxnmq_f32(vminnmq_f32(v96, _Q0), (float32x4_t)0), v94)), (int8x16_t)v94));
      v92[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v98), (int8x16_t)vaddq_f32(v97, vmlsq_f32(v93, vmaxnmq_f32(vminnmq_f32(v98, _Q0), (float32x4_t)0), v93)), (int8x16_t)v93));
      a10 += v17;
      v69 -= 2;
      if (v69 < 2)
        break;
      LOWORD(v70) = *(_WORD *)a10;
      v91 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v91);
        a3 = (float32x4_t *)((char *)a3 + v91);
        goto LABEL_84;
      }
    }
    result = (float32x4_t *)((char *)result + v19 + v91);
    a3 = (float32x4_t *)((char *)a3 + v19 + v91);
LABEL_87:
    for (j = a12 - v68 + v69; j; --j)
    {
      if (*a10)
      {
        v100 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v101 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v67), (float32x4_t)vrev32q_s8(*(int8x16_t *)a3));
        v102 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 3);
        *(int8x16_t *)result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v102), (int8x16_t)vaddq_f32(v101, vmlsq_f32(v100, vmaxnmq_f32(vminnmq_f32(v102, _Q0), (float32x4_t)0), v100)), (int8x16_t)v100));
      }
      v103 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v103 >= a8)
        v104 = -(uint64_t)a7;
      else
        v104 = 0;
      a3 = &v103[v104];
      result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    v105 = &a5[a4];
    if ((unint64_t)v105 >= a9)
      v106 = v18;
    else
      v106 = 0;
    v107 = &v105[v106];
    v108 = a8 + 16 * v106 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v107;
      a8 = v108;
      a5 = v107;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int32x4_t *composite_pixelmask<(CGCompositeOperation)6,_rgbaf_t>(int32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  unsigned int v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v31;
  float32x4_t v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  int8x16_t *v36;
  int8x16_t *v37;
  int8x16_t *v38;
  int8x16_t *v39;
  uint64_t v40;
  int64_t v41;
  unint64_t v42;
  int8x16_t *v43;
  int32x4_t v44;
  int32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int8x16_t v48;
  int8x16_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int8x16_t *v52;
  int8x16_t *v53;
  int8x16_t *v54;
  int8x16_t *v55;
  int64_t v56;
  int64_t v57;
  uint64_t v58;
  int8x16_t *v59;
  int32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  int8x16_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x4_t v69;
  unint64_t i;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  int8x16_t *v75;
  uint64_t v76;
  int8x16_t *v77;
  uint64_t v78;
  int8x16_t *v79;
  uint64_t v80;
  int8x16_t v81;
  float32x4_t v82;
  unint64_t v83;
  unint64_t v84;
  int v85;
  int8x16_t *v86;
  int8x16_t *v87;
  int8x16_t *v88;
  int8x16_t *v89;
  uint64_t v90;
  int64_t v91;
  unint64_t v92;
  int8x16_t *v93;
  int32x4_t v94;
  int32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int8x16_t *v102;
  int8x16_t *v103;
  int8x16_t *v104;
  int8x16_t *v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  int8x16_t *v109;
  int32x4_t v110;
  int32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  int8x16_t v116;
  int8x16_t v117;
  float32x4_t v118;
  float32x4_t v119;
  unint64_t j;
  int32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  int8x16_t v125;
  int8x16_t *v126;
  uint64_t v127;
  int8x16_t *v128;
  uint64_t v129;
  int8x16_t *v130;
  uint64_t v131;

  if (a15)
    v18 = 0;
  else
    v18 = -1;
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  v20 = vmvnq_s8(v19);
  v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_185004D50);
  v22 = 2 * a14;
  v23 = -(a6 * a4);
  v24 = 32 * a14;
  v25 = 16 * a14;
  __asm { FMOV            V2.4S, #1.0 }
  if ((a16 & 0x30) != 0)
  {
    v31.i64[0] = -1;
    v31.i64[1] = -1;
    v32 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v33 = (a8 - (unint64_t)a3) >> 4;
      if (v33 >= a12)
        v33 = a12;
      v34 = v33;
      if (v33 < 2)
        goto LABEL_40;
      while (1)
      {
        v35 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v52 = (int8x16_t *)&a10[v34];
          v53 = (int8x16_t *)a10;
          do
            v54 = v53++;
          while (v53 <= v52 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v54)) & 0x80) != 0);
          do
          {
            v55 = v54;
            v54 = (int8x16_t *)((char *)v54 + 4);
          }
          while (v54 <= v52 && !v55->i32[0]);
          if (v55 < v52)
          {
            while (!v55->i8[0])
            {
              v55 = (int8x16_t *)((char *)v55 + 1);
              if (v55 >= v52)
              {
                v55 = (int8x16_t *)&a10[v34];
                break;
              }
            }
          }
          v56 = (char *)v55 - a10;
          v57 = ((char *)v55 - a10) * a14;
          a3 += v57;
          result += v57;
          a10 += v57;
          v34 -= v56;
          goto LABEL_37;
        }
        if (v35 != 0xFFFF)
          break;
        v36 = (int8x16_t *)&a10[v34];
        v37 = (int8x16_t *)a10;
        do
          v38 = v37++;
        while (v37 <= v36 && (vminvq_u8((uint8x16_t)vceqq_s8(*v38, v31)) & 0x80) != 0);
        do
        {
          v39 = v38;
          v38 = (int8x16_t *)((char *)v38 + 4);
        }
        while (v38 <= v36 && v39->i32[0] == -1);
        if (v39 < v36)
        {
          while (v39->u8[0] == 255)
          {
            v39 = (int8x16_t *)((char *)v39 + 1);
            if (v39 >= v36)
            {
              v39 = (int8x16_t *)&a10[v34];
              break;
            }
          }
        }
        v40 = 0;
        v41 = (char *)v39 - a10;
        v42 = (char *)v39 - a10;
        do
        {
          v43 = (int8x16_t *)&result->i8[v40];
          v44 = *(int32x4_t *)((char *)result + v40);
          v45 = *(int32x4_t *)((char *)&result[1] + v40);
          v46 = (float32x4_t)vdupq_laneq_s32(v45, 3);
          v47 = (float32x4_t)vdupq_laneq_s32(v44, 3);
          v48 = (int8x16_t)vcgtzq_f32(v47);
          v49 = (int8x16_t)vcgtzq_f32(v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v40), v20), v21);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v40), v20), v21);
          *v43 = vbslq_s8((int8x16_t)vcgtq_f32(v47, _Q2), (int8x16_t)v44, (int8x16_t)vaddq_f32(vmlsq_f32(v50, (float32x4_t)vandq_s8(v48, (int8x16_t)v47), v50), (float32x4_t)vandq_s8(v48, (int8x16_t)v44)));
          v43[1] = vbslq_s8((int8x16_t)vcgtq_f32(v46, _Q2), (int8x16_t)v45, (int8x16_t)vaddq_f32(vmlsq_f32(v51, (float32x4_t)vandq_s8(v49, (int8x16_t)v46), v51), (float32x4_t)vandq_s8(v49, (int8x16_t)v45)));
          a10 += v22;
          v42 -= 2;
          v40 += v24;
        }
        while (v42 > 1);
        a3 = (int8x16_t *)((char *)a3 + v40);
        result = (int32x4_t *)((char *)result + v40);
        v34 = v34 - v41 + v42;
LABEL_37:
        if (v34 <= 1)
          goto LABEL_40;
      }
      v58 = 0;
      while (1)
      {
        v59 = (int8x16_t *)&result->i8[v58];
        v60 = *(int32x4_t *)((char *)result + v58);
        v61 = *(int32x4_t *)((char *)&result[1] + v58);
        v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v35) & 0xFF00FF00FF00FFLL))), v32);
        v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v35)) & 0xFF00FF00FF00FFLL))), v32);
        v64 = (float32x4_t)vdupq_laneq_s32(v61, 3);
        v65 = (float32x4_t)vdupq_laneq_s32(v60, 3);
        v66 = (int8x16_t)vcgtzq_f32(v65);
        v67 = (int8x16_t)vcgtzq_f32(v64);
        v68 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v58), v20), v21);
        v69 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v58), v20), v21);
        *v59 = vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v62), (int8x16_t)vcgtq_f32(v65, _Q2)), (int8x16_t)v60, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v66, (int8x16_t)v60), v62, vmlsq_f32(v68, (float32x4_t)vandq_s8(v66, (int8x16_t)v65), v68)));
        v59[1] = vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v63), (int8x16_t)vcgtq_f32(v64, _Q2)), (int8x16_t)v61, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v67, (int8x16_t)v61), v63, vmlsq_f32(v69, (float32x4_t)vandq_s8(v67, (int8x16_t)v64), v69)));
        a10 += v22;
        v34 -= 2;
        if (v34 < 2)
          break;
        LOWORD(v35) = *(_WORD *)a10;
        v58 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int32x4_t *)((char *)result + v58);
          a3 = (int8x16_t *)((char *)a3 + v58);
          goto LABEL_37;
        }
      }
      result = (int32x4_t *)((char *)result + v24 + v58);
      a3 = (int8x16_t *)((char *)a3 + v24 + v58);
LABEL_40:
      for (i = a12 - v33 + v34; i; --i)
      {
        if (*a10)
        {
          v71 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v32);
          v72 = (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21);
          v73 = (float32x4_t)vdupq_laneq_s32(*result, 3);
          v74 = (int8x16_t)vcgtzq_f32(v73);
          *(int8x16_t *)result = vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v73, _Q2), (int8x16_t)vceqzq_f32(v71)), *(int8x16_t *)result, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v74, *(int8x16_t *)result), v71, vmlsq_f32(v72, (float32x4_t)vandq_s8(v74, (int8x16_t)v73), v72)));
        }
        v75 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v75 >= a8)
          v76 = -(uint64_t)a7;
        else
          v76 = 0;
        a3 = &v75[v76];
        result = (int32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      v77 = &a5[a4];
      if ((unint64_t)v77 >= a9)
        v78 = v23;
      else
        v78 = 0;
      v79 = &v77[v78];
      v80 = a8 + 16 * v78 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v79;
        a8 = v80;
        a5 = v79;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v81.i64[0] = -1;
  v81.i64[1] = -1;
  v82 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v83 = (a8 - (unint64_t)a3) >> 4;
    if (v83 >= a12)
      v83 = a12;
    v84 = v83;
    if (v83 < 2)
      goto LABEL_90;
    while (1)
    {
      v85 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v102 = (int8x16_t *)&a10[v84];
        v103 = (int8x16_t *)a10;
        do
          v104 = v103++;
        while (v103 <= v102 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v104)) & 0x80) != 0);
        do
        {
          v105 = v104;
          v104 = (int8x16_t *)((char *)v104 + 4);
        }
        while (v104 <= v102 && !v105->i32[0]);
        if (v105 < v102)
        {
          while (!v105->i8[0])
          {
            v105 = (int8x16_t *)((char *)v105 + 1);
            if (v105 >= v102)
            {
              v105 = (int8x16_t *)&a10[v84];
              break;
            }
          }
        }
        v106 = (char *)v105 - a10;
        v107 = ((char *)v105 - a10) * a14;
        a3 += v107;
        result += v107;
        a10 += v107;
        v84 -= v106;
        goto LABEL_87;
      }
      if (v85 != 0xFFFF)
        break;
      v86 = (int8x16_t *)&a10[v84];
      v87 = (int8x16_t *)a10;
      do
        v88 = v87++;
      while (v87 <= v86 && (vminvq_u8((uint8x16_t)vceqq_s8(*v88, v81)) & 0x80) != 0);
      do
      {
        v89 = v88;
        v88 = (int8x16_t *)((char *)v88 + 4);
      }
      while (v88 <= v86 && v89->i32[0] == -1);
      if (v89 < v86)
      {
        while (v89->u8[0] == 255)
        {
          v89 = (int8x16_t *)((char *)v89 + 1);
          if (v89 >= v86)
          {
            v89 = (int8x16_t *)&a10[v84];
            break;
          }
        }
      }
      v90 = 0;
      v91 = (char *)v89 - a10;
      v92 = (char *)v89 - a10;
      do
      {
        v93 = (int8x16_t *)&result->i8[v90];
        v94 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v90));
        v95 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v90));
        v96 = (float32x4_t)vdupq_laneq_s32(v95, 3);
        v97 = (float32x4_t)vdupq_laneq_s32(v94, 3);
        v98 = (int8x16_t)vcgtzq_f32(v97);
        v99 = (int8x16_t)vcgtzq_f32(v96);
        v100 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v90)), v20), v21);
        v101 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v90)), v20), v21);
        *v93 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtq_f32(v97, _Q2), (int8x16_t)v94, (int8x16_t)vaddq_f32(vmlsq_f32(v100, (float32x4_t)vandq_s8(v98, (int8x16_t)v97), v100), (float32x4_t)vandq_s8(v98, (int8x16_t)v94))));
        v93[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtq_f32(v96, _Q2), (int8x16_t)v95, (int8x16_t)vaddq_f32(vmlsq_f32(v101, (float32x4_t)vandq_s8(v99, (int8x16_t)v96), v101), (float32x4_t)vandq_s8(v99, (int8x16_t)v95))));
        a10 += v22;
        v92 -= 2;
        v90 += v24;
      }
      while (v92 > 1);
      a3 = (int8x16_t *)((char *)a3 + v90);
      result = (int32x4_t *)((char *)result + v90);
      v84 = v84 - v91 + v92;
LABEL_87:
      if (v84 <= 1)
        goto LABEL_90;
    }
    v108 = 0;
    while (1)
    {
      v109 = (int8x16_t *)&result->i8[v108];
      v110 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v108));
      v111 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v108));
      v112 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v85)) & 0xFF00FF00FF00FFLL))), v82);
      v113 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v85) & 0xFF00FF00FF00FFLL))), v82);
      v114 = (float32x4_t)vdupq_laneq_s32(v111, 3);
      v115 = (float32x4_t)vdupq_laneq_s32(v110, 3);
      v116 = (int8x16_t)vcgtzq_f32(v115);
      v117 = (int8x16_t)vcgtzq_f32(v114);
      v118 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v108)), v20), v21);
      v119 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v108)), v20), v21);
      *v109 = vrev32q_s8(vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v113), (int8x16_t)vcgtq_f32(v115, _Q2)), (int8x16_t)v110, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v116, (int8x16_t)v110), v113, vmlsq_f32(v118, (float32x4_t)vandq_s8(v116, (int8x16_t)v115), v118))));
      v109[1] = vrev32q_s8(vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v112), (int8x16_t)vcgtq_f32(v114, _Q2)), (int8x16_t)v111, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v117, (int8x16_t)v111), v112, vmlsq_f32(v119, (float32x4_t)vandq_s8(v117, (int8x16_t)v114), v119))));
      a10 += v22;
      v84 -= 2;
      if (v84 < 2)
        break;
      LOWORD(v85) = *(_WORD *)a10;
      v108 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int32x4_t *)((char *)result + v108);
        a3 = (int8x16_t *)((char *)a3 + v108);
        goto LABEL_87;
      }
    }
    result = (int32x4_t *)((char *)result + v24 + v108);
    a3 = (int8x16_t *)((char *)a3 + v24 + v108);
LABEL_90:
    for (j = a12 - v83 + v84; j; --j)
    {
      if (*a10)
      {
        v121 = (int32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v122 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v82);
        v123 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21);
        v124 = (float32x4_t)vdupq_laneq_s32(v121, 3);
        v125 = (int8x16_t)vcgtzq_f32(v124);
        *(int8x16_t *)result = vrev32q_s8(vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v124, _Q2), (int8x16_t)vceqzq_f32(v122)), (int8x16_t)v121, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v125, (int8x16_t)v121), v122, vmlsq_f32(v123, (float32x4_t)vandq_s8(v125, (int8x16_t)v124), v123))));
      }
      v126 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v126 >= a8)
        v127 = -(uint64_t)a7;
      else
        v127 = 0;
      a3 = &v126[v127];
      result = (int32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    v128 = &a5[a4];
    if ((unint64_t)v128 >= a9)
      v129 = v23;
    else
      v129 = 0;
    v130 = &v128[v129];
    v131 = a8 + 16 * v129 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v130;
      a8 = v131;
      a5 = v130;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)3,_rgbaf_t>(float32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  unsigned int v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  float32x4_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int8x16_t *v31;
  int8x16_t *v32;
  int8x16_t *v33;
  int8x16_t *v34;
  uint64_t v35;
  int64_t v36;
  unint64_t v37;
  float32x4_t *v38;
  float32x4_t v39;
  int8x16_t *v40;
  int8x16_t *v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int64_t v44;
  int64_t v45;
  uint64_t v46;
  float32x4_t *v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  unint64_t i;
  float32x4_t v55;
  int8x16_t *v56;
  uint64_t v57;
  int8x16_t *v58;
  uint64_t v59;
  int8x16_t *v60;
  uint64_t v61;
  BOOL v62;
  int8x16_t v63;
  float32x4_t v64;
  unint64_t v65;
  unint64_t v66;
  int v67;
  int8x16_t *v68;
  int8x16_t *v69;
  int8x16_t *v70;
  int8x16_t *v71;
  uint64_t v72;
  int64_t v73;
  unint64_t v74;
  int8x16_t *v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t *v79;
  int8x16_t *v80;
  int8x16_t *v81;
  int8x16_t *v82;
  int64_t v83;
  int64_t v84;
  uint64_t v85;
  int8x16_t *v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t v91;
  unint64_t j;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  uint64_t v96;
  int8x16_t *v97;
  uint64_t v98;
  int8x16_t *v99;
  uint64_t v100;

  if (a15)
    v18 = 0;
  else
    v18 = -1;
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  v20 = vmvnq_s8(v19);
  v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_185004D50);
  v22 = 2 * a14;
  v23 = -(a6 * a4);
  v24 = 32 * a14;
  v25 = 16 * a14;
  if ((a16 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12)
        v28 = a12;
      v29 = v28;
      if (v28 < 2)
        goto LABEL_40;
      while (1)
      {
        v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v40 = (int8x16_t *)&a10[v29];
          v41 = (int8x16_t *)a10;
          do
            v42 = v41++;
          while (v41 <= v40 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v42)) & 0x80) != 0);
          do
          {
            v43 = v42;
            v42 = (int8x16_t *)((char *)v42 + 4);
          }
          while (v42 <= v40 && !v43->i32[0]);
          if (v43 < v40)
          {
            while (!v43->i8[0])
            {
              v43 = (int8x16_t *)((char *)v43 + 1);
              if (v43 >= v40)
              {
                v43 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          v44 = (char *)v43 - a10;
          v45 = ((char *)v43 - a10) * a14;
          a3 += v45;
          result += v45;
          a10 += v45;
          v29 -= v44;
          goto LABEL_37;
        }
        if (v30 != 0xFFFF)
          break;
        v31 = (int8x16_t *)&a10[v29];
        v32 = (int8x16_t *)a10;
        do
          v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          v34 = v33;
          v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        v35 = 0;
        v36 = (char *)v34 - a10;
        v37 = (char *)v34 - a10;
        do
        {
          v38 = (float32x4_t *)((char *)result + v35);
          v39 = vmlaq_laneq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35 + 16), *(float32x4_t *)((char *)result + v35 + 16)), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v35), v20), v21), *(float32x4_t *)((char *)result + v35 + 16), 3);
          *v38 = vmlaq_laneq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35), *(float32x4_t *)((char *)result + v35)), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v35), v20), v21), *(float32x4_t *)((char *)result + v35), 3);
          v38[1] = v39;
          a10 += v22;
          v37 -= 2;
          v35 += v24;
        }
        while (v37 > 1);
        a3 = (int8x16_t *)((char *)a3 + v35);
        result = (float32x4_t *)((char *)result + v35);
        v29 = v29 - v36 + v37;
LABEL_37:
        if (v29 <= 1)
          goto LABEL_40;
      }
      v46 = 0;
      while (1)
      {
        v47 = (float32x4_t *)((char *)result + v46);
        v48 = *(float32x4_t *)((char *)result + v46);
        v49 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27);
        v50 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27);
        v51 = vmulq_f32(v50, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v20), v21));
        v52 = vmlsq_f32(v48, v50, v48);
        v53 = vmlaq_laneq_f32(vmlsq_f32(*(float32x4_t *)((char *)result + v46 + 16), v49, *(float32x4_t *)((char *)result + v46 + 16)), vmulq_f32(v49, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v20), v21)), *(float32x4_t *)((char *)result + v46 + 16), 3);
        *v47 = vmlaq_laneq_f32(v52, v51, v48, 3);
        v47[1] = v53;
        a10 += v22;
        v29 -= 2;
        if (v29 < 2)
          break;
        LOWORD(v30) = *(_WORD *)a10;
        v46 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v46);
          a3 = (int8x16_t *)((char *)a3 + v46);
          goto LABEL_37;
        }
      }
      result = (float32x4_t *)((char *)result + v24 + v46);
      a3 = (int8x16_t *)((char *)a3 + v24 + v46);
LABEL_40:
      for (i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          v55 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27);
          *result = vmlaq_laneq_f32(vmlsq_f32(*result, v55, *result), vmulq_f32(v55, (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21)), *result, 3);
        }
        v56 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v56 >= a8)
          v57 = -(uint64_t)a7;
        else
          v57 = 0;
        a3 = &v56[v57];
        result = (float32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      v58 = &a5[a4];
      if ((unint64_t)v58 >= a9)
        v59 = v23;
      else
        v59 = 0;
      v60 = &v58[v59];
      v61 = a8 + 16 * v59 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v60;
        a8 = v61;
        a5 = v60;
      }
      v62 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v62 | (a13 == 0))
        return result;
    }
  }
  v63.i64[0] = -1;
  v63.i64[1] = -1;
  v64 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v65 = (a8 - (unint64_t)a3) >> 4;
    if (v65 >= a12)
      v65 = a12;
    v66 = v65;
    if (v65 < 2)
      goto LABEL_90;
    while (1)
    {
      v67 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v79 = (int8x16_t *)&a10[v66];
        v80 = (int8x16_t *)a10;
        do
          v81 = v80++;
        while (v80 <= v79 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v81)) & 0x80) != 0);
        do
        {
          v82 = v81;
          v81 = (int8x16_t *)((char *)v81 + 4);
        }
        while (v81 <= v79 && !v82->i32[0]);
        if (v82 < v79)
        {
          while (!v82->i8[0])
          {
            v82 = (int8x16_t *)((char *)v82 + 1);
            if (v82 >= v79)
            {
              v82 = (int8x16_t *)&a10[v66];
              break;
            }
          }
        }
        v83 = (char *)v82 - a10;
        v84 = ((char *)v82 - a10) * a14;
        a3 += v84;
        result += v84;
        a10 += v84;
        v66 -= v83;
        goto LABEL_87;
      }
      if (v67 != 0xFFFF)
        break;
      v68 = (int8x16_t *)&a10[v66];
      v69 = (int8x16_t *)a10;
      do
        v70 = v69++;
      while (v69 <= v68 && (vminvq_u8((uint8x16_t)vceqq_s8(*v70, v63)) & 0x80) != 0);
      do
      {
        v71 = v70;
        v70 = (int8x16_t *)((char *)v70 + 4);
      }
      while (v70 <= v68 && v71->i32[0] == -1);
      if (v71 < v68)
      {
        while (v71->u8[0] == 255)
        {
          v71 = (int8x16_t *)((char *)v71 + 1);
          if (v71 >= v68)
          {
            v71 = (int8x16_t *)&a10[v66];
            break;
          }
        }
      }
      v72 = 0;
      v73 = (char *)v71 - a10;
      v74 = (char *)v71 - a10;
      do
      {
        v75 = (int8x16_t *)((char *)result + v72);
        v76 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v72));
        v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v72));
        v78 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vsubq_f32(v77, v77), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v72)), v20), v21), v77, 3));
        *v75 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vsubq_f32(v76, v76), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v72)), v20), v21), v76, 3));
        v75[1] = v78;
        a10 += v22;
        v74 -= 2;
        v72 += v24;
      }
      while (v74 > 1);
      a3 = (int8x16_t *)((char *)a3 + v72);
      result = (float32x4_t *)((char *)result + v72);
      v66 = v66 - v73 + v74;
LABEL_87:
      if (v66 <= 1)
        goto LABEL_90;
    }
    v85 = 0;
    while (1)
    {
      v86 = (int8x16_t *)((char *)result + v85);
      v87 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v85));
      v88 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v85));
      v89 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v67) & 0xFF00FF00FF00FFLL))), v64);
      v90 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v67)) & 0xFF00FF00FF00FFLL))), v64);
      v91 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_f32(v87, v90, v87), vmulq_f32(v90, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v85)), v20), v21)), v87, 3));
      *v86 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_f32(v88, v89, v88), vmulq_f32(v89, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v85)), v20), v21)), v88, 3));
      v86[1] = v91;
      a10 += v22;
      v66 -= 2;
      if (v66 < 2)
        break;
      LOWORD(v67) = *(_WORD *)a10;
      v85 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v85);
        a3 = (int8x16_t *)((char *)a3 + v85);
        goto LABEL_87;
      }
    }
    result = (float32x4_t *)((char *)result + v24 + v85);
    a3 = (int8x16_t *)((char *)a3 + v24 + v85);
LABEL_90:
    for (j = a12 - v65 + v66; j; --j)
    {
      if (*a10)
      {
        v93 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v64);
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_f32(v93, v94, v93), vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21)), v93, 3));
      }
      v95 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v95 >= a8)
        v96 = -(uint64_t)a7;
      else
        v96 = 0;
      a3 = &v95[v96];
      result = (float32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    v97 = &a5[a4];
    if ((unint64_t)v97 >= a9)
      v98 = v23;
    else
      v98 = 0;
    v99 = &v97[v98];
    v100 = a8 + 16 * v98 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v99;
      a8 = v100;
      a5 = v99;
    }
    v62 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v62 | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)7,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v27;
  float32x4_t v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  int8x16_t *v32;
  int8x16_t *v33;
  int8x16_t *v34;
  int8x16_t *v35;
  uint64_t v36;
  int64_t v37;
  unint64_t v38;
  float32x4_t *v39;
  float32x4_t v40;
  int8x16_t *v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int64_t v45;
  int64_t v46;
  uint64_t v47;
  float32x4_t *v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  unint64_t i;
  float32x4_t v53;
  float32x4_t *v54;
  uint64_t v55;
  float32x4_t *v56;
  uint64_t v57;
  float32x4_t *v58;
  uint64_t v59;
  int8x16_t v60;
  float32x4_t v61;
  unint64_t v62;
  unint64_t v63;
  int v64;
  int8x16_t *v65;
  int8x16_t *v66;
  int8x16_t *v67;
  int8x16_t *v68;
  uint64_t v69;
  int64_t v70;
  unint64_t v71;
  int8x16_t *v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t *v76;
  int8x16_t *v77;
  int8x16_t *v78;
  int8x16_t *v79;
  int64_t v80;
  int64_t v81;
  uint64_t v82;
  int8x16_t *v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  int8x16_t v88;
  unint64_t j;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t *v92;
  uint64_t v93;
  float32x4_t *v94;
  uint64_t v95;
  float32x4_t *v96;
  uint64_t v97;

  v17 = 2 * a14;
  v18 = -(a6 * a4);
  v19 = 32 * a14;
  v20 = 16 * a14;
  __asm
  {
    FMOV            V0.4S, #-1.0
    FMOV            V1.4S, #1.0
  }
  if ((a15 & 0x30) != 0)
  {
    v27.i64[0] = -1;
    v27.i64[1] = -1;
    v28 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v29 = (a8 - (unint64_t)a3) >> 4;
      if (v29 >= a12)
        v29 = a12;
      v30 = v29;
      if (v29 < 2)
        goto LABEL_37;
      while (1)
      {
        v31 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v41 = (int8x16_t *)&a10[v30];
          v42 = (int8x16_t *)a10;
          do
            v43 = v42++;
          while (v42 <= v41 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v43)) & 0x80) != 0);
          do
          {
            v44 = v43;
            v43 = (int8x16_t *)((char *)v43 + 4);
          }
          while (v43 <= v41 && !v44->i32[0]);
          if (v44 < v41)
          {
            while (!v44->i8[0])
            {
              v44 = (int8x16_t *)((char *)v44 + 1);
              if (v44 >= v41)
              {
                v44 = (int8x16_t *)&a10[v30];
                break;
              }
            }
          }
          v45 = (char *)v44 - a10;
          v46 = ((char *)v44 - a10) * a14;
          a3 += v46;
          result += v46;
          a10 += v46;
          v30 -= v45;
          goto LABEL_34;
        }
        if (v31 != 0xFFFF)
          break;
        v32 = (int8x16_t *)&a10[v30];
        v33 = (int8x16_t *)a10;
        do
          v34 = v33++;
        while (v33 <= v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v27)) & 0x80) != 0);
        do
        {
          v35 = v34;
          v34 = (int8x16_t *)((char *)v34 + 4);
        }
        while (v34 <= v32 && v35->i32[0] == -1);
        if (v35 < v32)
        {
          while (v35->u8[0] == 255)
          {
            v35 = (int8x16_t *)((char *)v35 + 1);
            if (v35 >= v32)
            {
              v35 = (int8x16_t *)&a10[v30];
              break;
            }
          }
        }
        v36 = 0;
        v37 = (char *)v35 - a10;
        v38 = (char *)v35 - a10;
        do
        {
          v39 = (float32x4_t *)((char *)result + v36);
          v40 = vmlsq_f32(*(float32x4_t *)((char *)result + v36 + 16), vmlaq_laneq_f32(_Q1, _Q0, *(float32x4_t *)((char *)a3 + v36 + 16), 3), *(float32x4_t *)((char *)result + v36 + 16));
          *v39 = vmlsq_f32(*(float32x4_t *)((char *)result + v36), vmlaq_laneq_f32(_Q1, _Q0, *(float32x4_t *)((char *)a3 + v36), 3), *(float32x4_t *)((char *)result + v36));
          v39[1] = v40;
          a10 += v17;
          v38 -= 2;
          v36 += v19;
        }
        while (v38 > 1);
        a3 = (float32x4_t *)((char *)a3 + v36);
        result = (float32x4_t *)((char *)result + v36);
        v30 = v30 - v37 + v38;
LABEL_34:
        if (v30 <= 1)
          goto LABEL_37;
      }
      v47 = 0;
      while (1)
      {
        v48 = (float32x4_t *)((char *)result + v47);
        v49 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v31)) & 0xFF00FF00FF00FFLL))), v28);
        v50 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v31) & 0xFF00FF00FF00FFLL))), v28);
        v51 = vmlsq_f32(*(float32x4_t *)((char *)result + v47 + 16), vmlsq_laneq_f32(v49, v49, *(float32x4_t *)((char *)a3 + v47 + 16), 3), *(float32x4_t *)((char *)result + v47 + 16));
        *v48 = vmlsq_f32(*(float32x4_t *)((char *)result + v47), vmlsq_laneq_f32(v50, v50, *(float32x4_t *)((char *)a3 + v47), 3), *(float32x4_t *)((char *)result + v47));
        v48[1] = v51;
        a10 += v17;
        v30 -= 2;
        if (v30 < 2)
          break;
        LOWORD(v31) = *(_WORD *)a10;
        v47 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v47);
          a3 = (float32x4_t *)((char *)a3 + v47);
          goto LABEL_34;
        }
      }
      result = (float32x4_t *)((char *)result + v19 + v47);
      a3 = (float32x4_t *)((char *)a3 + v19 + v47);
LABEL_37:
      for (i = a12 - v29 + v30; i; --i)
      {
        if (*a10)
        {
          v53 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v28);
          *result = vmlsq_f32(*result, vmlsq_laneq_f32(v53, v53, *a3, 3), *result);
        }
        v54 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v54 >= a8)
          v55 = -(uint64_t)a7;
        else
          v55 = 0;
        a3 = &v54[v55];
        result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      v56 = &a5[a4];
      if ((unint64_t)v56 >= a9)
        v57 = v18;
      else
        v57 = 0;
      v58 = &v56[v57];
      v59 = a8 + 16 * v57 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v58;
        a8 = v59;
        a5 = v58;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v60.i64[0] = -1;
  v60.i64[1] = -1;
  v61 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v62 = (a8 - (unint64_t)a3) >> 4;
    if (v62 >= a12)
      v62 = a12;
    v63 = v62;
    if (v62 < 2)
      goto LABEL_87;
    while (1)
    {
      v64 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v76 = (int8x16_t *)&a10[v63];
        v77 = (int8x16_t *)a10;
        do
          v78 = v77++;
        while (v77 <= v76 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v78)) & 0x80) != 0);
        do
        {
          v79 = v78;
          v78 = (int8x16_t *)((char *)v78 + 4);
        }
        while (v78 <= v76 && !v79->i32[0]);
        if (v79 < v76)
        {
          while (!v79->i8[0])
          {
            v79 = (int8x16_t *)((char *)v79 + 1);
            if (v79 >= v76)
            {
              v79 = (int8x16_t *)&a10[v63];
              break;
            }
          }
        }
        v80 = (char *)v79 - a10;
        v81 = ((char *)v79 - a10) * a14;
        a3 += v81;
        result += v81;
        a10 += v81;
        v63 -= v80;
        goto LABEL_84;
      }
      if (v64 != 0xFFFF)
        break;
      v65 = (int8x16_t *)&a10[v63];
      v66 = (int8x16_t *)a10;
      do
        v67 = v66++;
      while (v66 <= v65 && (vminvq_u8((uint8x16_t)vceqq_s8(*v67, v60)) & 0x80) != 0);
      do
      {
        v68 = v67;
        v67 = (int8x16_t *)((char *)v67 + 4);
      }
      while (v67 <= v65 && v68->i32[0] == -1);
      if (v68 < v65)
      {
        while (v68->u8[0] == 255)
        {
          v68 = (int8x16_t *)((char *)v68 + 1);
          if (v68 >= v65)
          {
            v68 = (int8x16_t *)&a10[v63];
            break;
          }
        }
      }
      v69 = 0;
      v70 = (char *)v68 - a10;
      v71 = (char *)v68 - a10;
      do
      {
        v72 = (int8x16_t *)((char *)result + v69);
        v73 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v69));
        v74 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v69));
        v75 = vrev32q_s8((int8x16_t)vmlsq_f32(v73, vmlaq_laneq_f32(_Q1, _Q0, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v69)), 3), v73));
        *v72 = vrev32q_s8((int8x16_t)vmlsq_f32(v74, vmlaq_laneq_f32(_Q1, _Q0, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v69)), 3), v74));
        v72[1] = v75;
        a10 += v17;
        v71 -= 2;
        v69 += v19;
      }
      while (v71 > 1);
      a3 = (float32x4_t *)((char *)a3 + v69);
      result = (float32x4_t *)((char *)result + v69);
      v63 = v63 - v70 + v71;
LABEL_84:
      if (v63 <= 1)
        goto LABEL_87;
    }
    v82 = 0;
    while (1)
    {
      v83 = (int8x16_t *)((char *)result + v82);
      v84 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v82));
      v85 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v82));
      v86 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v64)) & 0xFF00FF00FF00FFLL))), v61);
      v87 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v64) & 0xFF00FF00FF00FFLL))), v61);
      v88 = vrev32q_s8((int8x16_t)vmlsq_f32(v84, vmlsq_laneq_f32(v86, v86, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v82)), 3), v84));
      *v83 = vrev32q_s8((int8x16_t)vmlsq_f32(v85, vmlsq_laneq_f32(v87, v87, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v82)), 3), v85));
      v83[1] = v88;
      a10 += v17;
      v63 -= 2;
      if (v63 < 2)
        break;
      LOWORD(v64) = *(_WORD *)a10;
      v82 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v82);
        a3 = (float32x4_t *)((char *)a3 + v82);
        goto LABEL_84;
      }
    }
    result = (float32x4_t *)((char *)result + v19 + v82);
    a3 = (float32x4_t *)((char *)a3 + v19 + v82);
LABEL_87:
    for (j = a12 - v62 + v63; j; --j)
    {
      if (*a10)
      {
        v90 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v91 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v61);
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlsq_f32(v90, vmlsq_laneq_f32(v91, v91, (float32x4_t)vrev32q_s8(*(int8x16_t *)a3), 3), v90));
      }
      v92 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v92 >= a8)
        v93 = -(uint64_t)a7;
      else
        v93 = 0;
      a3 = &v92[v93];
      result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    v94 = &a5[a4];
    if ((unint64_t)v94 >= a9)
      v95 = v18;
    else
      v95 = 0;
    v96 = &v94[v95];
    v97 = a8 + 16 * v95 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v96;
      a8 = v97;
      a5 = v96;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)4,_rgbaf_t>(float32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  unsigned int v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  float32x4_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int8x16_t *v31;
  int8x16_t *v32;
  int8x16_t *v33;
  int8x16_t *v34;
  uint64_t v35;
  int64_t v36;
  unint64_t v37;
  float32x4_t *v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  int64_t v46;
  int64_t v47;
  uint64_t v48;
  float32x4_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  unint64_t i;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t *v58;
  uint64_t v59;
  int8x16_t *v60;
  uint64_t v61;
  int8x16_t *v62;
  uint64_t v63;
  BOOL v64;
  int8x16_t v65;
  float32x4_t v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  int8x16_t *v70;
  int8x16_t *v71;
  int8x16_t *v72;
  int8x16_t *v73;
  uint64_t v74;
  int64_t v75;
  unint64_t v76;
  int8x16_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  int8x16_t *v83;
  int8x16_t *v84;
  int8x16_t *v85;
  int64_t v86;
  int64_t v87;
  uint64_t v88;
  int8x16_t *v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  unint64_t j;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  int8x16_t *v100;
  uint64_t v101;
  int8x16_t *v102;
  uint64_t v103;
  int8x16_t *v104;
  uint64_t v105;

  if (a15)
    v18 = 0;
  else
    v18 = -1;
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  v20 = vmvnq_s8(v19);
  v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_185004D50);
  v22 = 2 * a14;
  v23 = -(a6 * a4);
  v24 = 32 * a14;
  v25 = 16 * a14;
  if ((a16 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12)
        v28 = a12;
      v29 = v28;
      if (v28 < 2)
        goto LABEL_40;
      while (1)
      {
        v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v42 = (int8x16_t *)&a10[v29];
          v43 = (int8x16_t *)a10;
          do
            v44 = v43++;
          while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v44)) & 0x80) != 0);
          do
          {
            v45 = v44;
            v44 = (int8x16_t *)((char *)v44 + 4);
          }
          while (v44 <= v42 && !v45->i32[0]);
          if (v45 < v42)
          {
            while (!v45->i8[0])
            {
              v45 = (int8x16_t *)((char *)v45 + 1);
              if (v45 >= v42)
              {
                v45 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          v46 = (char *)v45 - a10;
          v47 = ((char *)v45 - a10) * a14;
          a3 += v47;
          result += v47;
          a10 += v47;
          v29 -= v46;
          goto LABEL_37;
        }
        if (v30 != 0xFFFF)
          break;
        v31 = (int8x16_t *)&a10[v29];
        v32 = (int8x16_t *)a10;
        do
          v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          v34 = v33;
          v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        v35 = 0;
        v36 = (char *)v34 - a10;
        v37 = (char *)v34 - a10;
        do
        {
          v38 = (float32x4_t *)((char *)result + v35);
          v39 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v35), v20), v21);
          v40 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v35), v20), v21);
          v41 = vaddq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35 + 16), *(float32x4_t *)((char *)result + v35 + 16)), vmlsq_laneq_f32(v40, v40, *(float32x4_t *)((char *)result + v35 + 16), 3));
          *v38 = vaddq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35), *(float32x4_t *)((char *)result + v35)), vmlsq_laneq_f32(v39, v39, *(float32x4_t *)((char *)result + v35), 3));
          v38[1] = v41;
          a10 += v22;
          v37 -= 2;
          v35 += v24;
        }
        while (v37 > 1);
        a3 = (int8x16_t *)((char *)a3 + v35);
        result = (float32x4_t *)((char *)result + v35);
        v29 = v29 - v36 + v37;
LABEL_37:
        if (v29 <= 1)
          goto LABEL_40;
      }
      v48 = 0;
      while (1)
      {
        v49 = (float32x4_t *)((char *)result + v48);
        v50 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27);
        v51 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27);
        v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v48), v20), v21);
        v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v48), v20), v21);
        v54 = vmlaq_f32(vmlsq_f32(*(float32x4_t *)((char *)result + v48 + 16), v50, *(float32x4_t *)((char *)result + v48 + 16)), v50, vmlsq_laneq_f32(v53, v53, *(float32x4_t *)((char *)result + v48 + 16), 3));
        *v49 = vmlaq_f32(vmlsq_f32(*(float32x4_t *)((char *)result + v48), v51, *(float32x4_t *)((char *)result + v48)), v51, vmlsq_laneq_f32(v52, v52, *(float32x4_t *)((char *)result + v48), 3));
        v49[1] = v54;
        a10 += v22;
        v29 -= 2;
        if (v29 < 2)
          break;
        LOWORD(v30) = *(_WORD *)a10;
        v48 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v48);
          a3 = (int8x16_t *)((char *)a3 + v48);
          goto LABEL_37;
        }
      }
      result = (float32x4_t *)((char *)result + v24 + v48);
      a3 = (int8x16_t *)((char *)a3 + v24 + v48);
LABEL_40:
      for (i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          v56 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27);
          v57 = (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21);
          *result = vmlaq_f32(vmlsq_f32(*result, v56, *result), v56, vmlsq_laneq_f32(v57, v57, *result, 3));
        }
        v58 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v58 >= a8)
          v59 = -(uint64_t)a7;
        else
          v59 = 0;
        a3 = &v58[v59];
        result = (float32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      v60 = &a5[a4];
      if ((unint64_t)v60 >= a9)
        v61 = v23;
      else
        v61 = 0;
      v62 = &v60[v61];
      v63 = a8 + 16 * v61 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v62;
        a8 = v63;
        a5 = v62;
      }
      v64 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v64 | (a13 == 0))
        return result;
    }
  }
  v65.i64[0] = -1;
  v65.i64[1] = -1;
  v66 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v67 = (a8 - (unint64_t)a3) >> 4;
    if (v67 >= a12)
      v67 = a12;
    v68 = v67;
    if (v67 < 2)
      goto LABEL_90;
    while (1)
    {
      v69 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v82 = (int8x16_t *)&a10[v68];
        v83 = (int8x16_t *)a10;
        do
          v84 = v83++;
        while (v83 <= v82 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v84)) & 0x80) != 0);
        do
        {
          v85 = v84;
          v84 = (int8x16_t *)((char *)v84 + 4);
        }
        while (v84 <= v82 && !v85->i32[0]);
        if (v85 < v82)
        {
          while (!v85->i8[0])
          {
            v85 = (int8x16_t *)((char *)v85 + 1);
            if (v85 >= v82)
            {
              v85 = (int8x16_t *)&a10[v68];
              break;
            }
          }
        }
        v86 = (char *)v85 - a10;
        v87 = ((char *)v85 - a10) * a14;
        a3 += v87;
        result += v87;
        a10 += v87;
        v68 -= v86;
        goto LABEL_87;
      }
      if (v69 != 0xFFFF)
        break;
      v70 = (int8x16_t *)&a10[v68];
      v71 = (int8x16_t *)a10;
      do
        v72 = v71++;
      while (v71 <= v70 && (vminvq_u8((uint8x16_t)vceqq_s8(*v72, v65)) & 0x80) != 0);
      do
      {
        v73 = v72;
        v72 = (int8x16_t *)((char *)v72 + 4);
      }
      while (v72 <= v70 && v73->i32[0] == -1);
      if (v73 < v70)
      {
        while (v73->u8[0] == 255)
        {
          v73 = (int8x16_t *)((char *)v73 + 1);
          if (v73 >= v70)
          {
            v73 = (int8x16_t *)&a10[v68];
            break;
          }
        }
      }
      v74 = 0;
      v75 = (char *)v73 - a10;
      v76 = (char *)v73 - a10;
      do
      {
        v77 = (int8x16_t *)((char *)result + v74);
        v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v74));
        v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v74));
        v80 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v74)), v20), v21);
        v81 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v74)), v20), v21);
        *v77 = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(v79, v79), vmlsq_laneq_f32(v80, v80, v79, 3)));
        v77[1] = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(v78, v78), vmlsq_laneq_f32(v81, v81, v78, 3)));
        a10 += v22;
        v76 -= 2;
        v74 += v24;
      }
      while (v76 > 1);
      a3 = (int8x16_t *)((char *)a3 + v74);
      result = (float32x4_t *)((char *)result + v74);
      v68 = v68 - v75 + v76;
LABEL_87:
      if (v68 <= 1)
        goto LABEL_90;
    }
    v88 = 0;
    while (1)
    {
      v89 = (int8x16_t *)((char *)result + v88);
      v90 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v88));
      v91 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v88));
      v92 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v69)) & 0xFF00FF00FF00FFLL))), v66);
      v93 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v69) & 0xFF00FF00FF00FFLL))), v66);
      v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v88)), v20), v21);
      v95 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v88)), v20), v21);
      *v89 = vrev32q_s8((int8x16_t)vmlaq_f32(vmlsq_f32(v91, v93, v91), v93, vmlsq_laneq_f32(v94, v94, v91, 3)));
      v89[1] = vrev32q_s8((int8x16_t)vmlaq_f32(vmlsq_f32(v90, v92, v90), v92, vmlsq_laneq_f32(v95, v95, v90, 3)));
      a10 += v22;
      v68 -= 2;
      if (v68 < 2)
        break;
      LOWORD(v69) = *(_WORD *)a10;
      v88 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v88);
        a3 = (int8x16_t *)((char *)a3 + v88);
        goto LABEL_87;
      }
    }
    result = (float32x4_t *)((char *)result + v24 + v88);
    a3 = (int8x16_t *)((char *)a3 + v24 + v88);
LABEL_90:
    for (j = a12 - v67 + v68; j; --j)
    {
      if (*a10)
      {
        v97 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v98 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v66);
        v99 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21);
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlaq_f32(vmlsq_f32(v97, v98, v97), v98, vmlsq_laneq_f32(v99, v99, v97, 3)));
      }
      v100 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v100 >= a8)
        v101 = -(uint64_t)a7;
      else
        v101 = 0;
      a3 = &v100[v101];
      result = (float32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    v102 = &a5[a4];
    if ((unint64_t)v102 >= a9)
      v103 = v23;
    else
      v103 = 0;
    v104 = &v102[v103];
    v105 = a8 + 16 * v103 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v104;
      a8 = v105;
      a5 = v104;
    }
    v64 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v64 | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)8,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  int8x16_t *v27;
  int8x16_t *v28;
  int8x16_t *v29;
  int8x16_t *v30;
  uint64_t v31;
  int64_t v32;
  unint64_t v33;
  float32x4_t *v34;
  float32x4_t v35;
  int8x16_t *v36;
  int8x16_t *v37;
  int8x16_t *v38;
  int8x16_t *v39;
  int64_t v40;
  int64_t v41;
  uint64_t v42;
  float32x4_t *v43;
  float32x4_t v44;
  unint64_t i;
  float32x4_t *v46;
  uint64_t v47;
  float32x4_t *v48;
  uint64_t v49;
  float32x4_t *v50;
  uint64_t v51;
  BOOL v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x4_t v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  int8x16_t *v59;
  int8x16_t *v60;
  int8x16_t *v61;
  int8x16_t *v62;
  uint64_t v63;
  int64_t v64;
  unint64_t v65;
  int8x16_t *v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  int8x16_t *v70;
  int8x16_t *v71;
  int8x16_t *v72;
  int8x16_t *v73;
  int64_t v74;
  int64_t v75;
  uint64_t v76;
  int8x16_t *v77;
  float32x4_t v78;
  float32x4_t v79;
  int8x16_t v80;
  unint64_t j;
  float32x4_t v82;
  float32x4_t *v83;
  uint64_t v84;
  float32x4_t *v85;
  uint64_t v86;
  float32x4_t *v87;
  uint64_t v88;

  v17 = 2 * a14;
  v18 = -(a6 * a4);
  v19 = 32 * a14;
  v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    v23 = (float32x4_t)vdupq_n_s32(0xBB808081);
    while (1)
    {
      v24 = (a8 - (unint64_t)a3) >> 4;
      if (v24 >= a12)
        v24 = a12;
      v25 = v24;
      if (v24 < 2)
        goto LABEL_37;
      while (1)
      {
        v26 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v36 = (int8x16_t *)&a10[v25];
          v37 = (int8x16_t *)a10;
          do
            v38 = v37++;
          while (v37 <= v36 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v38)) & 0x80) != 0);
          do
          {
            v39 = v38;
            v38 = (int8x16_t *)((char *)v38 + 4);
          }
          while (v38 <= v36 && !v39->i32[0]);
          if (v39 < v36)
          {
            while (!v39->i8[0])
            {
              v39 = (int8x16_t *)((char *)v39 + 1);
              if (v39 >= v36)
              {
                v39 = (int8x16_t *)&a10[v25];
                break;
              }
            }
          }
          v40 = (char *)v39 - a10;
          v41 = ((char *)v39 - a10) * a14;
          a3 += v41;
          result += v41;
          a10 += v41;
          v25 -= v40;
          goto LABEL_34;
        }
        if (v26 != 0xFFFF)
          break;
        v27 = (int8x16_t *)&a10[v25];
        v28 = (int8x16_t *)a10;
        do
          v29 = v28++;
        while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, v21)) & 0x80) != 0);
        do
        {
          v30 = v29;
          v29 = (int8x16_t *)((char *)v29 + 4);
        }
        while (v29 <= v27 && v30->i32[0] == -1);
        if (v30 < v27)
        {
          while (v30->u8[0] == 255)
          {
            v30 = (int8x16_t *)((char *)v30 + 1);
            if (v30 >= v27)
            {
              v30 = (int8x16_t *)&a10[v25];
              break;
            }
          }
        }
        v31 = 0;
        v32 = (char *)v30 - a10;
        v33 = (char *)v30 - a10;
        do
        {
          v34 = (float32x4_t *)((char *)result + v31);
          v35 = vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v31 + 16), *(float32x4_t *)((char *)result + v31 + 16), *(float32x4_t *)((char *)a3 + v31 + 16), 3);
          *v34 = vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v31), *(float32x4_t *)((char *)result + v31), *(float32x4_t *)((char *)a3 + v31), 3);
          v34[1] = v35;
          a10 += v17;
          v33 -= 2;
          v31 += v19;
        }
        while (v33 > 1);
        a3 = (float32x4_t *)((char *)a3 + v31);
        result = (float32x4_t *)((char *)result + v31);
        v25 = v25 - v32 + v33;
LABEL_34:
        if (v25 <= 1)
          goto LABEL_37;
      }
      v42 = 0;
      while (1)
      {
        v43 = (float32x4_t *)((char *)result + v42);
        v44 = vmlsq_f32(*(float32x4_t *)((char *)result + v42 + 16), vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v26)) & 0xFF00FF00FF00FFLL))), v22), *(float32x4_t *)((char *)a3 + v42 + 16), 3), *(float32x4_t *)((char *)result + v42 + 16));
        *v43 = vmlsq_f32(*(float32x4_t *)((char *)result + v42), vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v26) & 0xFF00FF00FF00FFLL))), v22), *(float32x4_t *)((char *)a3 + v42), 3), *(float32x4_t *)((char *)result + v42));
        v43[1] = v44;
        a10 += v17;
        v25 -= 2;
        if (v25 < 2)
          break;
        LOWORD(v26) = *(_WORD *)a10;
        v42 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v42);
          a3 = (float32x4_t *)((char *)a3 + v42);
          goto LABEL_34;
        }
      }
      result = (float32x4_t *)((char *)result + v19 + v42);
      a3 = (float32x4_t *)((char *)a3 + v19 + v42);
LABEL_37:
      for (i = a12 - v24 + v25; i; --i)
      {
        if (*a10)
          *result = vmlaq_f32(*result, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v23), *a3, 3), *result);
        v46 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v46 >= a8)
          v47 = -(uint64_t)a7;
        else
          v47 = 0;
        a3 = &v46[v47];
        result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      v48 = &a5[a4];
      if ((unint64_t)v48 >= a9)
        v49 = v18;
      else
        v49 = 0;
      v50 = &v48[v49];
      v51 = a8 + 16 * v49 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v50;
        a8 = v51;
        a5 = v50;
      }
      v52 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v52 | (a13 == 0))
        return result;
    }
  }
  v53.i64[0] = -1;
  v53.i64[1] = -1;
  v54 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  v55 = (float32x4_t)vdupq_n_s32(0xBB808081);
  while (2)
  {
    v56 = (a8 - (unint64_t)a3) >> 4;
    if (v56 >= a12)
      v56 = a12;
    v57 = v56;
    if (v56 < 2)
      goto LABEL_87;
    while (1)
    {
      v58 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v70 = (int8x16_t *)&a10[v57];
        v71 = (int8x16_t *)a10;
        do
          v72 = v71++;
        while (v71 <= v70 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v72)) & 0x80) != 0);
        do
        {
          v73 = v72;
          v72 = (int8x16_t *)((char *)v72 + 4);
        }
        while (v72 <= v70 && !v73->i32[0]);
        if (v73 < v70)
        {
          while (!v73->i8[0])
          {
            v73 = (int8x16_t *)((char *)v73 + 1);
            if (v73 >= v70)
            {
              v73 = (int8x16_t *)&a10[v57];
              break;
            }
          }
        }
        v74 = (char *)v73 - a10;
        v75 = ((char *)v73 - a10) * a14;
        a3 += v75;
        result += v75;
        a10 += v75;
        v57 -= v74;
        goto LABEL_84;
      }
      if (v58 != 0xFFFF)
        break;
      v59 = (int8x16_t *)&a10[v57];
      v60 = (int8x16_t *)a10;
      do
        v61 = v60++;
      while (v60 <= v59 && (vminvq_u8((uint8x16_t)vceqq_s8(*v61, v53)) & 0x80) != 0);
      do
      {
        v62 = v61;
        v61 = (int8x16_t *)((char *)v61 + 4);
      }
      while (v61 <= v59 && v62->i32[0] == -1);
      if (v62 < v59)
      {
        while (v62->u8[0] == 255)
        {
          v62 = (int8x16_t *)((char *)v62 + 1);
          if (v62 >= v59)
          {
            v62 = (int8x16_t *)&a10[v57];
            break;
          }
        }
      }
      v63 = 0;
      v64 = (char *)v62 - a10;
      v65 = (char *)v62 - a10;
      do
      {
        v66 = (int8x16_t *)((char *)result + v63);
        v67 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v63));
        v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v63));
        v69 = vrev32q_s8((int8x16_t)vmlsq_laneq_f32(v67, v67, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v63)), 3));
        *v66 = vrev32q_s8((int8x16_t)vmlsq_laneq_f32(v68, v68, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v63)), 3));
        v66[1] = v69;
        a10 += v17;
        v65 -= 2;
        v63 += v19;
      }
      while (v65 > 1);
      a3 = (float32x4_t *)((char *)a3 + v63);
      result = (float32x4_t *)((char *)result + v63);
      v57 = v57 - v64 + v65;
LABEL_84:
      if (v57 <= 1)
        goto LABEL_87;
    }
    v76 = 0;
    while (1)
    {
      v77 = (int8x16_t *)((char *)result + v76);
      v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v76));
      v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v76));
      v80 = vrev32q_s8((int8x16_t)vmlsq_f32(v78, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v58)) & 0xFF00FF00FF00FFLL))), v54), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v76)), 3), v78));
      *v77 = vrev32q_s8((int8x16_t)vmlsq_f32(v79, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v58) & 0xFF00FF00FF00FFLL))), v54), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v76)), 3), v79));
      v77[1] = v80;
      a10 += v17;
      v57 -= 2;
      if (v57 < 2)
        break;
      LOWORD(v58) = *(_WORD *)a10;
      v76 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v76);
        a3 = (float32x4_t *)((char *)a3 + v76);
        goto LABEL_84;
      }
    }
    result = (float32x4_t *)((char *)result + v19 + v76);
    a3 = (float32x4_t *)((char *)a3 + v19 + v76);
LABEL_87:
    for (j = a12 - v56 + v57; j; --j)
    {
      if (*a10)
      {
        v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlaq_f32(v82, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v55), (float32x4_t)vrev32q_s8(*(int8x16_t *)a3), 3), v82));
      }
      v83 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v83 >= a8)
        v84 = -(uint64_t)a7;
      else
        v84 = 0;
      a3 = &v83[v84];
      result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    v85 = &a5[a4];
    if ((unint64_t)v85 >= a9)
      v86 = v18;
    else
      v86 = 0;
    v87 = &v85[v86];
    v88 = a8 + 16 * v86 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v87;
      a8 = v88;
      a5 = v87;
    }
    v52 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v52 | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)5,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v21;
  float32x4_t v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  int8x16_t *v26;
  int8x16_t *v27;
  int8x16_t *v28;
  int8x16_t *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  int8x16_t *v35;
  int8x16_t *v36;
  int8x16_t *v37;
  int8x16_t *v38;
  int64_t v39;
  int64_t v40;
  uint64_t v41;
  float32x4_t *v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  unint64_t i;
  float32x4_t v47;
  float32x4_t *v48;
  uint64_t v49;
  float32x4_t *v50;
  uint64_t v51;
  float32x4_t *v52;
  uint64_t v53;
  BOOL v54;
  int8x16_t v55;
  float32x4_t v56;
  unint64_t v57;
  unint64_t v58;
  int v59;
  int8x16_t *v60;
  int8x16_t *v61;
  int8x16_t *v62;
  int8x16_t *v63;
  uint64_t v64;
  int64_t v65;
  unint64_t v66;
  int8x16_t *v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t *v72;
  int8x16_t *v73;
  int8x16_t *v74;
  int8x16_t *v75;
  int64_t v76;
  int64_t v77;
  uint64_t v78;
  int8x16_t *v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  unint64_t j;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t *v87;
  uint64_t v88;
  float32x4_t *v89;
  uint64_t v90;
  float32x4_t *v91;
  uint64_t v92;

  v17 = 2 * a14;
  v18 = -(a6 * a4);
  v19 = 32 * a14;
  v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v23 = (a8 - (unint64_t)a3) >> 4;
      if (v23 >= a12)
        v23 = a12;
      v24 = v23;
      if (v23 < 2)
        goto LABEL_37;
      while (1)
      {
        v25 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v35 = (int8x16_t *)&a10[v24];
          v36 = (int8x16_t *)a10;
          do
            v37 = v36++;
          while (v36 <= v35 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v37)) & 0x80) != 0);
          do
          {
            v38 = v37;
            v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= v35 && !v38->i32[0]);
          if (v38 < v35)
          {
            while (!v38->i8[0])
            {
              v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= v35)
              {
                v38 = (int8x16_t *)&a10[v24];
                break;
              }
            }
          }
          v39 = (char *)v38 - a10;
          v40 = ((char *)v38 - a10) * a14;
          a3 += v40;
          result += v40;
          a10 += v40;
          v24 -= v39;
          goto LABEL_34;
        }
        if (v25 != 0xFFFF)
          break;
        v26 = (int8x16_t *)&a10[v24];
        v27 = (int8x16_t *)a10;
        do
          v28 = v27++;
        while (v27 <= v26 && (vminvq_u8((uint8x16_t)vceqq_s8(*v28, v21)) & 0x80) != 0);
        do
        {
          v29 = v28;
          v28 = (int8x16_t *)((char *)v28 + 4);
        }
        while (v28 <= v26 && v29->i32[0] == -1);
        if (v29 < v26)
        {
          while (v29->u8[0] == 255)
          {
            v29 = (int8x16_t *)((char *)v29 + 1);
            if (v29 >= v26)
            {
              v29 = (int8x16_t *)&a10[v24];
              break;
            }
          }
        }
        v30 = 0;
        v31 = (char *)v29 - a10;
        v32 = (char *)v29 - a10;
        do
        {
          v33 = (float32x4_t *)((char *)result + v30);
          v34 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), 3), *(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), 3);
          *v33 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)a3 + v30), 3), *(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)result + v30), 3);
          v33[1] = v34;
          a10 += v17;
          v32 -= 2;
          v30 += v19;
        }
        while (v32 > 1);
        a3 = (float32x4_t *)((char *)a3 + v30);
        result = (float32x4_t *)((char *)result + v30);
        v24 = v24 - v31 + v32;
LABEL_34:
        if (v24 <= 1)
          goto LABEL_37;
      }
      v41 = 0;
      while (1)
      {
        v42 = (float32x4_t *)((char *)result + v41);
        v43 = vmulq_f32(*(float32x4_t *)((char *)a3 + v41 + 16), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v25)) & 0xFF00FF00FF00FFLL))), v22));
        v44 = vmulq_f32(*(float32x4_t *)((char *)a3 + v41), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v25) & 0xFF00FF00FF00FFLL))), v22));
        v45 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), v43, 3), v43, *(float32x4_t *)((char *)result + v41 + 16), 3);
        *v42 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)result + v41), v44, 3), v44, *(float32x4_t *)((char *)result + v41), 3);
        v42[1] = v45;
        a10 += v17;
        v24 -= 2;
        if (v24 < 2)
          break;
        LOWORD(v25) = *(_WORD *)a10;
        v41 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v41);
          a3 = (float32x4_t *)((char *)a3 + v41);
          goto LABEL_34;
        }
      }
      result = (float32x4_t *)((char *)result + v19 + v41);
      a3 = (float32x4_t *)((char *)a3 + v19 + v41);
LABEL_37:
      for (i = a12 - v23 + v24; i; --i)
      {
        if (*a10)
        {
          v47 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v22), *a3);
          *result = vmlaq_laneq_f32(vmlsq_laneq_f32(*result, *result, v47, 3), v47, *result, 3);
        }
        v48 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v48 >= a8)
          v49 = -(uint64_t)a7;
        else
          v49 = 0;
        a3 = &v48[v49];
        result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      v50 = &a5[a4];
      if ((unint64_t)v50 >= a9)
        v51 = v18;
      else
        v51 = 0;
      v52 = &v50[v51];
      v53 = a8 + 16 * v51 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v52;
        a8 = v53;
        a5 = v52;
      }
      v54 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v54 | (a13 == 0))
        return result;
    }
  }
  v55.i64[0] = -1;
  v55.i64[1] = -1;
  v56 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v57 = (a8 - (unint64_t)a3) >> 4;
    if (v57 >= a12)
      v57 = a12;
    v58 = v57;
    if (v57 < 2)
      goto LABEL_87;
    while (1)
    {
      v59 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v72 = (int8x16_t *)&a10[v58];
        v73 = (int8x16_t *)a10;
        do
          v74 = v73++;
        while (v73 <= v72 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v74)) & 0x80) != 0);
        do
        {
          v75 = v74;
          v74 = (int8x16_t *)((char *)v74 + 4);
        }
        while (v74 <= v72 && !v75->i32[0]);
        if (v75 < v72)
        {
          while (!v75->i8[0])
          {
            v75 = (int8x16_t *)((char *)v75 + 1);
            if (v75 >= v72)
            {
              v75 = (int8x16_t *)&a10[v58];
              break;
            }
          }
        }
        v76 = (char *)v75 - a10;
        v77 = ((char *)v75 - a10) * a14;
        a3 += v77;
        result += v77;
        a10 += v77;
        v58 -= v76;
        goto LABEL_84;
      }
      if (v59 != 0xFFFF)
        break;
      v60 = (int8x16_t *)&a10[v58];
      v61 = (int8x16_t *)a10;
      do
        v62 = v61++;
      while (v61 <= v60 && (vminvq_u8((uint8x16_t)vceqq_s8(*v62, v55)) & 0x80) != 0);
      do
      {
        v63 = v62;
        v62 = (int8x16_t *)((char *)v62 + 4);
      }
      while (v62 <= v60 && v63->i32[0] == -1);
      if (v63 < v60)
      {
        while (v63->u8[0] == 255)
        {
          v63 = (int8x16_t *)((char *)v63 + 1);
          if (v63 >= v60)
          {
            v63 = (int8x16_t *)&a10[v58];
            break;
          }
        }
      }
      v64 = 0;
      v65 = (char *)v63 - a10;
      v66 = (char *)v63 - a10;
      do
      {
        v67 = (int8x16_t *)((char *)result + v64);
        v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v64));
        v69 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v64));
        v70 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v64));
        v71 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v64));
        *v67 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v71, v71, v69, 3), v69, v71, 3));
        v67[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v70, v70, v68, 3), v68, v70, 3));
        a10 += v17;
        v66 -= 2;
        v64 += v19;
      }
      while (v66 > 1);
      a3 = (float32x4_t *)((char *)a3 + v64);
      result = (float32x4_t *)((char *)result + v64);
      v58 = v58 - v65 + v66;
LABEL_84:
      if (v58 <= 1)
        goto LABEL_87;
    }
    v78 = 0;
    while (1)
    {
      v79 = (int8x16_t *)((char *)result + v78);
      v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v78));
      v81 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v78));
      v82 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v59)) & 0xFF00FF00FF00FFLL))), v56), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v78)));
      v83 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v59) & 0xFF00FF00FF00FFLL))), v56), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v78)));
      *v79 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v81, v81, v83, 3), v83, v81, 3));
      v79[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v80, v80, v82, 3), v82, v80, 3));
      a10 += v17;
      v58 -= 2;
      if (v58 < 2)
        break;
      LOWORD(v59) = *(_WORD *)a10;
      v78 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v78);
        a3 = (float32x4_t *)((char *)a3 + v78);
        goto LABEL_84;
      }
    }
    result = (float32x4_t *)((char *)result + v19 + v78);
    a3 = (float32x4_t *)((char *)a3 + v19 + v78);
LABEL_87:
    for (j = a12 - v57 + v58; j; --j)
    {
      if (*a10)
      {
        v85 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v86 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v56), (float32x4_t)vrev32q_s8(*(int8x16_t *)a3));
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v85, v85, v86, 3), v86, v85, 3));
      }
      v87 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v87 >= a8)
        v88 = -(uint64_t)a7;
      else
        v88 = 0;
      a3 = &v87[v88];
      result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    v89 = &a5[a4];
    if ((unint64_t)v89 >= a9)
      v90 = v18;
    else
      v90 = 0;
    v91 = &v89[v90];
    v92 = a8 + 16 * v90 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v91;
      a8 = v92;
      a5 = v91;
    }
    v54 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v54 | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)9,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v21;
  float32x4_t v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  int8x16_t *v26;
  int8x16_t *v27;
  int8x16_t *v28;
  int8x16_t *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  int8x16_t *v35;
  int8x16_t *v36;
  int8x16_t *v37;
  int8x16_t *v38;
  int64_t v39;
  int64_t v40;
  uint64_t v41;
  float32x4_t *v42;
  float32x4_t v43;
  unint64_t i;
  float32x4_t *v45;
  uint64_t v46;
  float32x4_t *v47;
  uint64_t v48;
  float32x4_t *v49;
  uint64_t v50;
  BOOL v51;
  int8x16_t v52;
  float32x4_t v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  int8x16_t *v57;
  int8x16_t *v58;
  int8x16_t *v59;
  int8x16_t *v60;
  uint64_t v61;
  int64_t v62;
  unint64_t v63;
  int8x16_t *v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t *v69;
  int8x16_t *v70;
  int8x16_t *v71;
  int8x16_t *v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int8x16_t *v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  unint64_t j;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t *v84;
  uint64_t v85;
  float32x4_t *v86;
  uint64_t v87;
  float32x4_t *v88;
  uint64_t v89;

  v17 = 2 * a14;
  v18 = -(a6 * a4);
  v19 = 32 * a14;
  v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v23 = (a8 - (unint64_t)a3) >> 4;
      if (v23 >= a12)
        v23 = a12;
      v24 = v23;
      if (v23 < 2)
        goto LABEL_37;
      while (1)
      {
        v25 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v35 = (int8x16_t *)&a10[v24];
          v36 = (int8x16_t *)a10;
          do
            v37 = v36++;
          while (v36 <= v35 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v37)) & 0x80) != 0);
          do
          {
            v38 = v37;
            v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= v35 && !v38->i32[0]);
          if (v38 < v35)
          {
            while (!v38->i8[0])
            {
              v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= v35)
              {
                v38 = (int8x16_t *)&a10[v24];
                break;
              }
            }
          }
          v39 = (char *)v38 - a10;
          v40 = ((char *)v38 - a10) * a14;
          a3 += v40;
          result += v40;
          a10 += v40;
          v24 -= v39;
          goto LABEL_34;
        }
        if (v25 != 0xFFFF)
          break;
        v26 = (int8x16_t *)&a10[v24];
        v27 = (int8x16_t *)a10;
        do
          v28 = v27++;
        while (v27 <= v26 && (vminvq_u8((uint8x16_t)vceqq_s8(*v28, v21)) & 0x80) != 0);
        do
        {
          v29 = v28;
          v28 = (int8x16_t *)((char *)v28 + 4);
        }
        while (v28 <= v26 && v29->i32[0] == -1);
        if (v29 < v26)
        {
          while (v29->u8[0] == 255)
          {
            v29 = (int8x16_t *)((char *)v29 + 1);
            if (v29 >= v26)
            {
              v29 = (int8x16_t *)&a10[v24];
              break;
            }
          }
        }
        v30 = 0;
        v31 = (char *)v29 - a10;
        v32 = (char *)v29 - a10;
        do
        {
          v33 = (float32x4_t *)((char *)result + v30);
          v34 = vaddq_f32(*(float32x4_t *)((char *)result + v30 + 16), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), 3)));
          *v33 = vaddq_f32(*(float32x4_t *)((char *)result + v30), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)result + v30), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)a3 + v30), 3)));
          v33[1] = v34;
          a10 += v17;
          v32 -= 2;
          v30 += v19;
        }
        while (v32 > 1);
        a3 = (float32x4_t *)((char *)a3 + v30);
        result = (float32x4_t *)((char *)result + v30);
        v24 = v24 - v31 + v32;
LABEL_34:
        if (v24 <= 1)
          goto LABEL_37;
      }
      v41 = 0;
      while (1)
      {
        v42 = (float32x4_t *)((char *)result + v41);
        v43 = vmlaq_f32(*(float32x4_t *)((char *)result + v41 + 16), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v25)) & 0xFF00FF00FF00FFLL))), v22));
        *v42 = vmlaq_f32(*(float32x4_t *)((char *)result + v41), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)result + v41), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)a3 + v41), 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v25) & 0xFF00FF00FF00FFLL))), v22));
        v42[1] = v43;
        a10 += v17;
        v24 -= 2;
        if (v24 < 2)
          break;
        LOWORD(v25) = *(_WORD *)a10;
        v41 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v41);
          a3 = (float32x4_t *)((char *)a3 + v41);
          goto LABEL_34;
        }
      }
      result = (float32x4_t *)((char *)result + v19 + v41);
      a3 = (float32x4_t *)((char *)a3 + v19 + v41);
LABEL_37:
      for (i = a12 - v23 + v24; i; --i)
      {
        if (*a10)
          *result = vmlaq_f32(*result, vsubq_f32(vmlsq_laneq_f32(*a3, *a3, *result, 3), vmlsq_laneq_f32(*result, *result, *a3, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v22));
        v45 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v45 >= a8)
          v46 = -(uint64_t)a7;
        else
          v46 = 0;
        a3 = &v45[v46];
        result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      v47 = &a5[a4];
      if ((unint64_t)v47 >= a9)
        v48 = v18;
      else
        v48 = 0;
      v49 = &v47[v48];
      v50 = a8 + 16 * v48 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v49;
        a8 = v50;
        a5 = v49;
      }
      v51 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v51 | (a13 == 0))
        return result;
    }
  }
  v52.i64[0] = -1;
  v52.i64[1] = -1;
  v53 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v54 = (a8 - (unint64_t)a3) >> 4;
    if (v54 >= a12)
      v54 = a12;
    v55 = v54;
    if (v54 < 2)
      goto LABEL_87;
    while (1)
    {
      v56 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v69 = (int8x16_t *)&a10[v55];
        v70 = (int8x16_t *)a10;
        do
          v71 = v70++;
        while (v70 <= v69 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v71)) & 0x80) != 0);
        do
        {
          v72 = v71;
          v71 = (int8x16_t *)((char *)v71 + 4);
        }
        while (v71 <= v69 && !v72->i32[0]);
        if (v72 < v69)
        {
          while (!v72->i8[0])
          {
            v72 = (int8x16_t *)((char *)v72 + 1);
            if (v72 >= v69)
            {
              v72 = (int8x16_t *)&a10[v55];
              break;
            }
          }
        }
        v73 = (char *)v72 - a10;
        v74 = ((char *)v72 - a10) * a14;
        a3 += v74;
        result += v74;
        a10 += v74;
        v55 -= v73;
        goto LABEL_84;
      }
      if (v56 != 0xFFFF)
        break;
      v57 = (int8x16_t *)&a10[v55];
      v58 = (int8x16_t *)a10;
      do
        v59 = v58++;
      while (v58 <= v57 && (vminvq_u8((uint8x16_t)vceqq_s8(*v59, v52)) & 0x80) != 0);
      do
      {
        v60 = v59;
        v59 = (int8x16_t *)((char *)v59 + 4);
      }
      while (v59 <= v57 && v60->i32[0] == -1);
      if (v60 < v57)
      {
        while (v60->u8[0] == 255)
        {
          v60 = (int8x16_t *)((char *)v60 + 1);
          if (v60 >= v57)
          {
            v60 = (int8x16_t *)&a10[v55];
            break;
          }
        }
      }
      v61 = 0;
      v62 = (char *)v60 - a10;
      v63 = (char *)v60 - a10;
      do
      {
        v64 = (int8x16_t *)((char *)result + v61);
        v65 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v61));
        v66 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v61));
        v67 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v61));
        v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v61));
        *v64 = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(vmlsq_laneq_f32(v66, v66, v68, 3), vmlsq_laneq_f32(v68, v68, v66, 3)), v68));
        v64[1] = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), vmlsq_laneq_f32(v67, v67, v65, 3)), v67));
        a10 += v17;
        v63 -= 2;
        v61 += v19;
      }
      while (v63 > 1);
      a3 = (float32x4_t *)((char *)a3 + v61);
      result = (float32x4_t *)((char *)result + v61);
      v55 = v55 - v62 + v63;
LABEL_84:
      if (v55 <= 1)
        goto LABEL_87;
    }
    v75 = 0;
    while (1)
    {
      v76 = (int8x16_t *)((char *)result + v75);
      v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v75));
      v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v75));
      v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v75));
      v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v75));
      *v76 = vrev32q_s8((int8x16_t)vmlaq_f32(v80, vsubq_f32(vmlsq_laneq_f32(v78, v78, v80, 3), vmlsq_laneq_f32(v80, v80, v78, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v56) & 0xFF00FF00FF00FFLL))), v53)));
      v76[1] = vrev32q_s8((int8x16_t)vmlaq_f32(v79, vsubq_f32(vmlsq_laneq_f32(v77, v77, v79, 3), vmlsq_laneq_f32(v79, v79, v77, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v56)) & 0xFF00FF00FF00FFLL))), v53)));
      a10 += v17;
      v55 -= 2;
      if (v55 < 2)
        break;
      LOWORD(v56) = *(_WORD *)a10;
      v75 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v75);
        a3 = (float32x4_t *)((char *)a3 + v75);
        goto LABEL_84;
      }
    }
    result = (float32x4_t *)((char *)result + v19 + v75);
    a3 = (float32x4_t *)((char *)a3 + v19 + v75);
LABEL_87:
    for (j = a12 - v54 + v55; j; --j)
    {
      if (*a10)
      {
        v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v83 = (float32x4_t)vrev32q_s8(*(int8x16_t *)a3);
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlaq_f32(v82, vsubq_f32(vmlsq_laneq_f32(v83, v83, v82, 3), vmlsq_laneq_f32(v82, v82, v83, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v53)));
      }
      v84 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v84 >= a8)
        v85 = -(uint64_t)a7;
      else
        v85 = 0;
      a3 = &v84[v85];
      result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    v86 = &a5[a4];
    if ((unint64_t)v86 >= a9)
      v87 = v18;
    else
      v87 = 0;
    v88 = &v86[v87];
    v89 = a8 + 16 * v87 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v88;
      a8 = v89;
      a5 = v88;
    }
    v51 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v51 | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)10,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int8x16_t v21;
  float32x4_t v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  int8x16_t *v26;
  int8x16_t *v27;
  int8x16_t *v28;
  int8x16_t *v29;
  uint64_t v30;
  int64_t v31;
  unint64_t v32;
  float32x4_t *v33;
  float32x4_t v34;
  int8x16_t *v35;
  int8x16_t *v36;
  int8x16_t *v37;
  int8x16_t *v38;
  int64_t v39;
  int64_t v40;
  uint64_t v41;
  float32x4_t *v42;
  float32x4_t v43;
  unint64_t i;
  float32x4_t *v45;
  uint64_t v46;
  float32x4_t *v47;
  uint64_t v48;
  float32x4_t *v49;
  uint64_t v50;
  BOOL v51;
  int8x16_t v52;
  float32x4_t v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  int8x16_t *v57;
  int8x16_t *v58;
  int8x16_t *v59;
  int8x16_t *v60;
  uint64_t v61;
  int64_t v62;
  unint64_t v63;
  int8x16_t *v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t *v69;
  int8x16_t *v70;
  int8x16_t *v71;
  int8x16_t *v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int8x16_t *v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  unint64_t j;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t *v84;
  uint64_t v85;
  float32x4_t *v86;
  uint64_t v87;
  float32x4_t *v88;
  uint64_t v89;

  v17 = 2 * a14;
  v18 = -(a6 * a4);
  v19 = 32 * a14;
  v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v23 = (a8 - (unint64_t)a3) >> 4;
      if (v23 >= a12)
        v23 = a12;
      v24 = v23;
      if (v23 < 2)
        goto LABEL_37;
      while (1)
      {
        v25 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v35 = (int8x16_t *)&a10[v24];
          v36 = (int8x16_t *)a10;
          do
            v37 = v36++;
          while (v36 <= v35 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v37)) & 0x80) != 0);
          do
          {
            v38 = v37;
            v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= v35 && !v38->i32[0]);
          if (v38 < v35)
          {
            while (!v38->i8[0])
            {
              v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= v35)
              {
                v38 = (int8x16_t *)&a10[v24];
                break;
              }
            }
          }
          v39 = (char *)v38 - a10;
          v40 = ((char *)v38 - a10) * a14;
          a3 += v40;
          result += v40;
          a10 += v40;
          v24 -= v39;
          goto LABEL_34;
        }
        if (v25 != 0xFFFF)
          break;
        v26 = (int8x16_t *)&a10[v24];
        v27 = (int8x16_t *)a10;
        do
          v28 = v27++;
        while (v27 <= v26 && (vminvq_u8((uint8x16_t)vceqq_s8(*v28, v21)) & 0x80) != 0);
        do
        {
          v29 = v28;
          v28 = (int8x16_t *)((char *)v28 + 4);
        }
        while (v28 <= v26 && v29->i32[0] == -1);
        if (v29 < v26)
        {
          while (v29->u8[0] == 255)
          {
            v29 = (int8x16_t *)((char *)v29 + 1);
            if (v29 >= v26)
            {
              v29 = (int8x16_t *)&a10[v24];
              break;
            }
          }
        }
        v30 = 0;
        v31 = (char *)v29 - a10;
        v32 = (char *)v29 - a10;
        do
        {
          v33 = (float32x4_t *)((char *)result + v30);
          v34 = vaddq_f32(*(float32x4_t *)((char *)result + v30 + 16), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), 3), *(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), 3));
          *v33 = vaddq_f32(*(float32x4_t *)((char *)result + v30), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)result + v30), 3), *(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)a3 + v30), 3));
          v33[1] = v34;
          a10 += v17;
          v32 -= 2;
          v30 += v19;
        }
        while (v32 > 1);
        a3 = (float32x4_t *)((char *)a3 + v30);
        result = (float32x4_t *)((char *)result + v30);
        v24 = v24 - v31 + v32;
LABEL_34:
        if (v24 <= 1)
          goto LABEL_37;
      }
      v41 = 0;
      while (1)
      {
        v42 = (float32x4_t *)((char *)result + v41);
        v43 = vmlaq_f32(*(float32x4_t *)((char *)result + v41 + 16), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v25)) & 0xFF00FF00FF00FFLL))), v22), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), 3), *(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), 3));
        *v42 = vmlaq_f32(*(float32x4_t *)((char *)result + v41), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v25) & 0xFF00FF00FF00FFLL))), v22), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)result + v41), 3), *(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)a3 + v41), 3));
        v42[1] = v43;
        a10 += v17;
        v24 -= 2;
        if (v24 < 2)
          break;
        LOWORD(v25) = *(_WORD *)a10;
        v41 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v41);
          a3 = (float32x4_t *)((char *)a3 + v41);
          goto LABEL_34;
        }
      }
      result = (float32x4_t *)((char *)result + v19 + v41);
      a3 = (float32x4_t *)((char *)a3 + v19 + v41);
LABEL_37:
      for (i = a12 - v23 + v24; i; --i)
      {
        if (*a10)
          *result = vmlaq_f32(*result, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v22), vmlsq_laneq_f32(vmlsq_laneq_f32(*a3, *a3, *result, 3), *result, *a3, 3));
        v45 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v45 >= a8)
          v46 = -(uint64_t)a7;
        else
          v46 = 0;
        a3 = &v45[v46];
        result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      v47 = &a5[a4];
      if ((unint64_t)v47 >= a9)
        v48 = v18;
      else
        v48 = 0;
      v49 = &v47[v48];
      v50 = a8 + 16 * v48 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v49;
        a8 = v50;
        a5 = v49;
      }
      v51 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v51 | (a13 == 0))
        return result;
    }
  }
  v52.i64[0] = -1;
  v52.i64[1] = -1;
  v53 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v54 = (a8 - (unint64_t)a3) >> 4;
    if (v54 >= a12)
      v54 = a12;
    v55 = v54;
    if (v54 < 2)
      goto LABEL_87;
    while (1)
    {
      v56 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v69 = (int8x16_t *)&a10[v55];
        v70 = (int8x16_t *)a10;
        do
          v71 = v70++;
        while (v70 <= v69 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v71)) & 0x80) != 0);
        do
        {
          v72 = v71;
          v71 = (int8x16_t *)((char *)v71 + 4);
        }
        while (v71 <= v69 && !v72->i32[0]);
        if (v72 < v69)
        {
          while (!v72->i8[0])
          {
            v72 = (int8x16_t *)((char *)v72 + 1);
            if (v72 >= v69)
            {
              v72 = (int8x16_t *)&a10[v55];
              break;
            }
          }
        }
        v73 = (char *)v72 - a10;
        v74 = ((char *)v72 - a10) * a14;
        a3 += v74;
        result += v74;
        a10 += v74;
        v55 -= v73;
        goto LABEL_84;
      }
      if (v56 != 0xFFFF)
        break;
      v57 = (int8x16_t *)&a10[v55];
      v58 = (int8x16_t *)a10;
      do
        v59 = v58++;
      while (v58 <= v57 && (vminvq_u8((uint8x16_t)vceqq_s8(*v59, v52)) & 0x80) != 0);
      do
      {
        v60 = v59;
        v59 = (int8x16_t *)((char *)v59 + 4);
      }
      while (v59 <= v57 && v60->i32[0] == -1);
      if (v60 < v57)
      {
        while (v60->u8[0] == 255)
        {
          v60 = (int8x16_t *)((char *)v60 + 1);
          if (v60 >= v57)
          {
            v60 = (int8x16_t *)&a10[v55];
            break;
          }
        }
      }
      v61 = 0;
      v62 = (char *)v60 - a10;
      v63 = (char *)v60 - a10;
      do
      {
        v64 = (int8x16_t *)((char *)result + v61);
        v65 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v61));
        v66 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v61));
        v67 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v61));
        v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v61));
        *v64 = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(vmlsq_laneq_f32(v66, v66, v68, 3), v68, v66, 3), v68));
        v64[1] = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), v67, v65, 3), v67));
        a10 += v17;
        v63 -= 2;
        v61 += v19;
      }
      while (v63 > 1);
      a3 = (float32x4_t *)((char *)a3 + v61);
      result = (float32x4_t *)((char *)result + v61);
      v55 = v55 - v62 + v63;
LABEL_84:
      if (v55 <= 1)
        goto LABEL_87;
    }
    v75 = 0;
    while (1)
    {
      v76 = (int8x16_t *)((char *)result + v75);
      v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v75));
      v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v75));
      v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v75));
      v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v75));
      *v76 = vrev32q_s8((int8x16_t)vmlaq_f32(v80, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v56) & 0xFF00FF00FF00FFLL))), v53), vmlsq_laneq_f32(vmlsq_laneq_f32(v78, v78, v80, 3), v80, v78, 3)));
      v76[1] = vrev32q_s8((int8x16_t)vmlaq_f32(v79, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v56)) & 0xFF00FF00FF00FFLL))), v53), vmlsq_laneq_f32(vmlsq_laneq_f32(v77, v77, v79, 3), v79, v77, 3)));
      a10 += v17;
      v55 -= 2;
      if (v55 < 2)
        break;
      LOWORD(v56) = *(_WORD *)a10;
      v75 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v75);
        a3 = (float32x4_t *)((char *)a3 + v75);
        goto LABEL_84;
      }
    }
    result = (float32x4_t *)((char *)result + v19 + v75);
    a3 = (float32x4_t *)((char *)a3 + v19 + v75);
LABEL_87:
    for (j = a12 - v54 + v55; j; --j)
    {
      if (*a10)
      {
        v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v83 = (float32x4_t)vrev32q_s8(*(int8x16_t *)a3);
        *(int8x16_t *)result = vrev32q_s8((int8x16_t)vmlaq_f32(v82, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v53), vmlsq_laneq_f32(vmlsq_laneq_f32(v83, v83, v82, 3), v82, v83, 3)));
      }
      v84 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v84 >= a8)
        v85 = -(uint64_t)a7;
      else
        v85 = 0;
      a3 = &v84[v85];
      result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    v86 = &a5[a4];
    if ((unint64_t)v86 >= a9)
      v87 = v18;
    else
      v87 = 0;
    v88 = &v86[v87];
    v89 = a8 + 16 * v87 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v88;
      a8 = v89;
      a5 = v88;
    }
    v51 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v51 | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)11,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  float32x4_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t *v58;
  int8x16_t *v59;
  int8x16_t *v60;
  int8x16_t *v61;
  int64_t v62;
  int64_t v63;
  uint64_t v64;
  int8x16_t *v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  unint64_t i;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  int8x16_t *v79;
  uint64_t v80;
  int8x16_t *v81;
  uint64_t v82;
  int8x16_t *v83;
  uint64_t v84;
  int8x16_t v85;
  float32x4_t v86;
  unint64_t v87;
  unint64_t v88;
  int v89;
  int8x16_t *v90;
  int8x16_t *v91;
  int8x16_t *v92;
  int8x16_t *v93;
  uint64_t v94;
  int64_t v95;
  unint64_t v96;
  int8x16_t *v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  int8x16_t *v106;
  int8x16_t *v107;
  int8x16_t *v108;
  int8x16_t *v109;
  int64_t v110;
  int64_t v111;
  uint64_t v112;
  int8x16_t *v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  unint64_t j;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  int8x16_t *v127;
  uint64_t v128;
  int8x16_t *v129;
  uint64_t v130;
  int8x16_t *v131;
  uint64_t v132;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v58 = (int8x16_t *)&a10[v40];
          v59 = (int8x16_t *)a10;
          do
            v60 = v59++;
          while (v59 <= v58 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v60)) & 0x80) != 0);
          do
          {
            v61 = v60;
            v60 = (int8x16_t *)((char *)v60 + 4);
          }
          while (v60 <= v58 && !v61->i32[0]);
          if (v61 < v58)
          {
            while (!v61->i8[0])
            {
              v61 = (int8x16_t *)((char *)v61 + 1);
              if (v61 >= v58)
              {
                v61 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v62 = (char *)v61 - a10;
          v63 = ((char *)v61 - a10) * a14;
          a3 += v63;
          result += v63;
          a10 += v63;
          v40 -= v62;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (float32x4_t *)&result->i8[v46];
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3);
          v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          *v49 = vsubq_f32(vminnmq_f32(vaddq_f32(v54, v56), _Q5), vaddq_f32(vsubq_f32(v54, v51), vsubq_f32(v56, v53)));
          v49[1] = vsubq_f32(vminnmq_f32(vaddq_f32(v55, v57), _Q5), vaddq_f32(vsubq_f32(v55, v50), vsubq_f32(v57, v52)));
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v64 = 0;
      while (1)
      {
        v65 = (int8x16_t *)((char *)result + v64);
        v66 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v67 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v68 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v64), v22), v25);
        v69 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v64), v22), v25);
        v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v67)), (int8x16_t)_Q5, *(int8x16_t *)((char *)&result[1] + v64));
        v71 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v66)), (int8x16_t)_Q5, *(int8x16_t *)((char *)result + v64));
        v72 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3);
        v73 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3);
        *v65 = vbslq_s8((int8x16_t)vceqzq_f32(v66), (int8x16_t)v71, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v72, v66, v68, 3), _Q5), vmlaq_f32(vsubq_f32(v72, v71), v66, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3), v68))));
        v65[1] = vbslq_s8((int8x16_t)vceqzq_f32(v67), (int8x16_t)v70, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v73, v67, v69, 3), _Q5), vmlaq_f32(vsubq_f32(v73, v70), v67, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3), v69))));
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v64 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v64);
          a3 = (int8x16_t *)((char *)a3 + v64);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v64);
      a3 = (int8x16_t *)((char *)a3 + v30 + v64);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v75 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v76 = (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25);
          v77 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v75)), (int8x16_t)_Q5, *result);
          v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
          *result = vbslq_s8((int8x16_t)vceqzq_f32(v75), (int8x16_t)v77, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v78, v75, v76, 3), _Q5), vmlaq_f32(vsubq_f32(v78, v77), v75, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3), v76))));
        }
        v79 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v79 >= a8)
          v80 = -(uint64_t)a7;
        else
          v80 = 0;
        a3 = &v79[v80];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v81 = &a5[a4];
      if ((unint64_t)v81 >= a9)
        v82 = v29;
      else
        v82 = 0;
      v83 = &v81[v82];
      v84 = a8 + 16 * v82 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v83;
        a8 = v84;
        a5 = v83;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v85.i64[0] = -1;
  v85.i64[1] = -1;
  v86 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v87 = (a8 - (unint64_t)a3) >> 4;
    if (v87 >= a12)
      v87 = a12;
    v88 = v87;
    if (v87 < 2)
      goto LABEL_93;
    while (1)
    {
      v89 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v106 = (int8x16_t *)&a10[v88];
        v107 = (int8x16_t *)a10;
        do
          v108 = v107++;
        while (v107 <= v106 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v108)) & 0x80) != 0);
        do
        {
          v109 = v108;
          v108 = (int8x16_t *)((char *)v108 + 4);
        }
        while (v108 <= v106 && !v109->i32[0]);
        if (v109 < v106)
        {
          while (!v109->i8[0])
          {
            v109 = (int8x16_t *)((char *)v109 + 1);
            if (v109 >= v106)
            {
              v109 = (int8x16_t *)&a10[v88];
              break;
            }
          }
        }
        v110 = (char *)v109 - a10;
        v111 = ((char *)v109 - a10) * a14;
        a3 += v111;
        result += v111;
        a10 += v111;
        v88 -= v110;
        goto LABEL_90;
      }
      if (v89 != 0xFFFF)
        break;
      v90 = (int8x16_t *)&a10[v88];
      v91 = (int8x16_t *)a10;
      do
        v92 = v91++;
      while (v91 <= v90 && (vminvq_u8((uint8x16_t)vceqq_s8(*v92, v85)) & 0x80) != 0);
      do
      {
        v93 = v92;
        v92 = (int8x16_t *)((char *)v92 + 4);
      }
      while (v92 <= v90 && v93->i32[0] == -1);
      if (v93 < v90)
      {
        while (v93->u8[0] == 255)
        {
          v93 = (int8x16_t *)((char *)v93 + 1);
          if (v93 >= v90)
          {
            v93 = (int8x16_t *)&a10[v88];
            break;
          }
        }
      }
      v94 = 0;
      v95 = (char *)v93 - a10;
      v96 = (char *)v93 - a10;
      do
      {
        v97 = (int8x16_t *)((char *)result + v94);
        v98 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v94)), v22), v25);
        v99 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v94)), v22), v25);
        v100 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v94)), v26), v27);
        v101 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v94)), v26), v27);
        v102 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3);
        v103 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3);
        v104 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 3);
        v105 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v100, 3);
        *v97 = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v102, v104), _Q5), vaddq_f32(vsubq_f32(v102, v99), vsubq_f32(v104, v101))));
        v97[1] = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v103, v105), _Q5), vaddq_f32(vsubq_f32(v103, v98), vsubq_f32(v105, v100))));
        a10 += v28;
        v96 -= 2;
        v94 += v30;
      }
      while (v96 > 1);
      a3 = (int8x16_t *)((char *)a3 + v94);
      result = (int8x16_t *)((char *)result + v94);
      v88 = v88 - v95 + v96;
LABEL_90:
      if (v88 <= 1)
        goto LABEL_93;
    }
    v112 = 0;
    while (1)
    {
      v113 = (int8x16_t *)((char *)result + v112);
      v114 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v89) & 0xFF00FF00FF00FFLL))), v86);
      v115 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v89)) & 0xFF00FF00FF00FFLL))), v86);
      v116 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v112)), v22), v25);
      v117 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v112)), v22), v25);
      v118 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v115)), (int8x16_t)_Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v112)));
      v119 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v114)), (int8x16_t)_Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v112)));
      v120 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 3);
      v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3);
      *v113 = vrev32q_s8(vbslq_s8((int8x16_t)vceqzq_f32(v114), (int8x16_t)v119, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v120, v114, v117, 3), _Q5), vmlaq_f32(vsubq_f32(v120, v119), v114, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 3), v117)))));
      v113[1] = vrev32q_s8(vbslq_s8((int8x16_t)vceqzq_f32(v115), (int8x16_t)v118, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v121, v115, v116, 3), _Q5), vmlaq_f32(vsubq_f32(v121, v118), v115, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3), v116)))));
      a10 += v28;
      v88 -= 2;
      if (v88 < 2)
        break;
      LOWORD(v89) = *(_WORD *)a10;
      v112 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v112);
        a3 = (int8x16_t *)((char *)a3 + v112);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v112);
    a3 = (int8x16_t *)((char *)a3 + v30 + v112);
LABEL_93:
    for (j = a12 - v87 + v88; j; --j)
    {
      if (*a10)
      {
        v123 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v86);
        v124 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25);
        v125 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v123)), (int8x16_t)_Q5, vrev32q_s8(*result));
        v126 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v125, 3);
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vceqzq_f32(v123), (int8x16_t)v125, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v126, v123, v124, 3), _Q5), vmlaq_f32(vsubq_f32(v126, v125), v123, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3), v124)))));
      }
      v127 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v127 >= a8)
        v128 = -(uint64_t)a7;
      else
        v128 = 0;
      a3 = &v127[v128];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v129 = &a5[a4];
    if ((unint64_t)v129 >= a9)
      v130 = v29;
    else
      v130 = 0;
    v131 = &v129[v130];
    v132 = a8 + 16 * v130 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v131;
      a8 = v132;
      a5 = v131;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)12,_rgbaf_t>(float32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  unsigned int v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;
  float32x4_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int8x16_t *v31;
  int8x16_t *v32;
  int8x16_t *v33;
  int8x16_t *v34;
  uint64_t v35;
  int64_t v36;
  unint64_t v37;
  float32x4_t *v38;
  float32x4_t v39;
  int8x16_t *v40;
  int8x16_t *v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int64_t v44;
  int64_t v45;
  uint64_t v46;
  int8x16_t *v47;
  float32x4_t v48;
  float32x4_t v49;
  int8x16_t v50;
  unint64_t i;
  float32x4_t v52;
  int8x16_t *v53;
  uint64_t v54;
  int8x16_t *v55;
  uint64_t v56;
  int8x16_t *v57;
  uint64_t v58;
  BOOL v59;
  int8x16_t v60;
  float32x4_t v61;
  unint64_t v62;
  unint64_t v63;
  int v64;
  int8x16_t *v65;
  int8x16_t *v66;
  int8x16_t *v67;
  int8x16_t *v68;
  uint64_t v69;
  int64_t v70;
  unint64_t v71;
  int8x16_t *v72;
  int8x16_t v73;
  int8x16_t *v74;
  int8x16_t *v75;
  int8x16_t *v76;
  int8x16_t *v77;
  int64_t v78;
  int64_t v79;
  uint64_t v80;
  int8x16_t *v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  unint64_t j;
  float32x4_t v88;
  float32x4_t v89;
  int8x16_t *v90;
  uint64_t v91;
  int8x16_t *v92;
  uint64_t v93;
  int8x16_t *v94;
  uint64_t v95;

  if (a15)
    v18 = 0;
  else
    v18 = -1;
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  v20 = vmvnq_s8(v19);
  v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_185004D50);
  v22 = 2 * a14;
  v23 = -(a6 * a4);
  v24 = 32 * a14;
  v25 = 16 * a14;
  if ((a16 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12)
        v28 = a12;
      v29 = v28;
      if (v28 < 2)
        goto LABEL_40;
      while (1)
      {
        v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v40 = (int8x16_t *)&a10[v29];
          v41 = (int8x16_t *)a10;
          do
            v42 = v41++;
          while (v41 <= v40 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v42)) & 0x80) != 0);
          do
          {
            v43 = v42;
            v42 = (int8x16_t *)((char *)v42 + 4);
          }
          while (v42 <= v40 && !v43->i32[0]);
          if (v43 < v40)
          {
            while (!v43->i8[0])
            {
              v43 = (int8x16_t *)((char *)v43 + 1);
              if (v43 >= v40)
              {
                v43 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          v44 = (char *)v43 - a10;
          v45 = ((char *)v43 - a10) * a14;
          a3 += v45;
          result += v45;
          a10 += v45;
          v29 -= v44;
          goto LABEL_37;
        }
        if (v30 != 0xFFFF)
          break;
        v31 = (int8x16_t *)&a10[v29];
        v32 = (int8x16_t *)a10;
        do
          v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          v34 = v33;
          v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        v35 = 0;
        v36 = (char *)v34 - a10;
        v37 = (char *)v34 - a10;
        do
        {
          v38 = (float32x4_t *)((char *)result + v35);
          v39 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)result + v35 + 16), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v35), v20), v21)), (float32x4_t)xmmword_1850048F0);
          *v38 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)result + v35), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v35), v20), v21)), (float32x4_t)xmmword_1850048F0);
          v38[1] = v39;
          a10 += v22;
          v37 -= 2;
          v35 += v24;
        }
        while (v37 > 1);
        a3 = (int8x16_t *)((char *)a3 + v35);
        result = (float32x4_t *)((char *)result + v35);
        v29 = v29 - v36 + v37;
LABEL_37:
        if (v29 <= 1)
          goto LABEL_40;
      }
      v46 = 0;
      while (1)
      {
        v47 = (int8x16_t *)((char *)result + v46);
        v48 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27);
        v49 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27);
        v50 = vbslq_s8((int8x16_t)vcgtzq_f32(v48), (int8x16_t)vminnmq_f32(vmlaq_f32(*(float32x4_t *)((char *)result + v46 + 16), v48, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v20), v21)), (float32x4_t)xmmword_1850048F0), *(int8x16_t *)((char *)&result[1] + v46));
        *v47 = vbslq_s8((int8x16_t)vcgtzq_f32(v49), (int8x16_t)vminnmq_f32(vmlaq_f32(*(float32x4_t *)((char *)result + v46), v49, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v20), v21)), (float32x4_t)xmmword_1850048F0), *(int8x16_t *)((char *)result + v46));
        v47[1] = v50;
        a10 += v22;
        v29 -= 2;
        if (v29 < 2)
          break;
        LOWORD(v30) = *(_WORD *)a10;
        v46 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (float32x4_t *)((char *)result + v46);
          a3 = (int8x16_t *)((char *)a3 + v46);
          goto LABEL_37;
        }
      }
      result = (float32x4_t *)((char *)result + v24 + v46);
      a3 = (int8x16_t *)((char *)a3 + v24 + v46);
LABEL_40:
      for (i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          v52 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27);
          *(int8x16_t *)result = vbslq_s8((int8x16_t)vcgtzq_f32(v52), (int8x16_t)vminnmq_f32(vmlaq_f32(*result, v52, (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21)), (float32x4_t)xmmword_1850048F0), *(int8x16_t *)result);
        }
        v53 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v53 >= a8)
          v54 = -(uint64_t)a7;
        else
          v54 = 0;
        a3 = &v53[v54];
        result = (float32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      v55 = &a5[a4];
      if ((unint64_t)v55 >= a9)
        v56 = v23;
      else
        v56 = 0;
      v57 = &v55[v56];
      v58 = a8 + 16 * v56 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v57;
        a8 = v58;
        a5 = v57;
      }
      v59 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v59 | (a13 == 0))
        return result;
    }
  }
  v60.i64[0] = -1;
  v60.i64[1] = -1;
  v61 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v62 = (a8 - (unint64_t)a3) >> 4;
    if (v62 >= a12)
      v62 = a12;
    v63 = v62;
    if (v62 < 2)
      goto LABEL_90;
    while (1)
    {
      v64 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v74 = (int8x16_t *)&a10[v63];
        v75 = (int8x16_t *)a10;
        do
          v76 = v75++;
        while (v75 <= v74 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v76)) & 0x80) != 0);
        do
        {
          v77 = v76;
          v76 = (int8x16_t *)((char *)v76 + 4);
        }
        while (v76 <= v74 && !v77->i32[0]);
        if (v77 < v74)
        {
          while (!v77->i8[0])
          {
            v77 = (int8x16_t *)((char *)v77 + 1);
            if (v77 >= v74)
            {
              v77 = (int8x16_t *)&a10[v63];
              break;
            }
          }
        }
        v78 = (char *)v77 - a10;
        v79 = ((char *)v77 - a10) * a14;
        a3 += v79;
        result += v79;
        a10 += v79;
        v63 -= v78;
        goto LABEL_87;
      }
      if (v64 != 0xFFFF)
        break;
      v65 = (int8x16_t *)&a10[v63];
      v66 = (int8x16_t *)a10;
      do
        v67 = v66++;
      while (v66 <= v65 && (vminvq_u8((uint8x16_t)vceqq_s8(*v67, v60)) & 0x80) != 0);
      do
      {
        v68 = v67;
        v67 = (int8x16_t *)((char *)v67 + 4);
      }
      while (v67 <= v65 && v68->i32[0] == -1);
      if (v68 < v65)
      {
        while (v68->u8[0] == 255)
        {
          v68 = (int8x16_t *)((char *)v68 + 1);
          if (v68 >= v65)
          {
            v68 = (int8x16_t *)&a10[v63];
            break;
          }
        }
      }
      v69 = 0;
      v70 = (char *)v68 - a10;
      v71 = (char *)v68 - a10;
      do
      {
        v72 = (int8x16_t *)((char *)result + v69);
        v73 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v69)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v69)), v20), v21)), (float32x4_t)xmmword_1850048F0));
        *v72 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v69)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v69)), v20), v21)), (float32x4_t)xmmword_1850048F0));
        v72[1] = v73;
        a10 += v22;
        v71 -= 2;
        v69 += v24;
      }
      while (v71 > 1);
      a3 = (int8x16_t *)((char *)a3 + v69);
      result = (float32x4_t *)((char *)result + v69);
      v63 = v63 - v70 + v71;
LABEL_87:
      if (v63 <= 1)
        goto LABEL_90;
    }
    v80 = 0;
    while (1)
    {
      v81 = (int8x16_t *)((char *)result + v80);
      v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v80));
      v83 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v80));
      v84 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v64) & 0xFF00FF00FF00FFLL))), v61);
      v85 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v64)) & 0xFF00FF00FF00FFLL))), v61);
      v86 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v85), (int8x16_t)vminnmq_f32(vmlaq_f32(v83, v85, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v80)), v20), v21)), (float32x4_t)xmmword_1850048F0), (int8x16_t)v83));
      *v81 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v84), (int8x16_t)vminnmq_f32(vmlaq_f32(v82, v84, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v80)), v20), v21)), (float32x4_t)xmmword_1850048F0), (int8x16_t)v82));
      v81[1] = v86;
      a10 += v22;
      v63 -= 2;
      if (v63 < 2)
        break;
      LOWORD(v64) = *(_WORD *)a10;
      v80 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (float32x4_t *)((char *)result + v80);
        a3 = (int8x16_t *)((char *)a3 + v80);
        goto LABEL_87;
      }
    }
    result = (float32x4_t *)((char *)result + v24 + v80);
    a3 = (int8x16_t *)((char *)a3 + v24 + v80);
LABEL_90:
    for (j = a12 - v62 + v63; j; --j)
    {
      if (*a10)
      {
        v88 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        v89 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v61);
        *(int8x16_t *)result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v89), (int8x16_t)vminnmq_f32(vmlaq_f32(v88, v89, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21)), (float32x4_t)xmmword_1850048F0), (int8x16_t)v88));
      }
      v90 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v90 >= a8)
        v91 = -(uint64_t)a7;
      else
        v91 = 0;
      a3 = &v90[v91];
      result = (float32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    v92 = &a5[a4];
    if ((unint64_t)v92 >= a9)
      v93 = v23;
    else
      v93 = 0;
    v94 = &v92[v93];
    v95 = a8 + 16 * v93 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v94;
      a8 = v95;
      a5 = v94;
    }
    v59 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v59 | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)13,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t *v54;
  int8x16_t *v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  int8x16_t *v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  unint64_t i;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t *v72;
  uint64_t v73;
  int8x16_t *v74;
  uint64_t v75;
  int8x16_t *v76;
  uint64_t v77;
  int8x16_t v78;
  float32x4_t v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  int8x16_t *v83;
  int8x16_t *v84;
  int8x16_t *v85;
  int8x16_t *v86;
  uint64_t v87;
  int64_t v88;
  unint64_t v89;
  int8x16_t *v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int8x16_t *v96;
  int8x16_t *v97;
  int8x16_t *v98;
  int64_t v99;
  int64_t v100;
  uint64_t v101;
  int8x16_t *v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  unint64_t j;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t *v113;
  uint64_t v114;
  int8x16_t *v115;
  uint64_t v116;
  int8x16_t *v117;
  uint64_t v118;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v54 = (int8x16_t *)&a10[v40];
          v55 = (int8x16_t *)a10;
          do
            v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            v57 = v56;
            v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v58 = (char *)v57 - a10;
          v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v53, v53, v50, 3), vmlsq_laneq_f32(v50, v50, v53, 3)), v50, v53), (int8x16_t)v50), (int8x16_t)v53);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v52, v52, v51, 3), vmlsq_laneq_f32(v51, v51, v52, 3)), v51, v52), (int8x16_t)v51), (int8x16_t)v52);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v60 = 0;
      while (1)
      {
        v61 = (int8x16_t *)((char *)result + v60);
        v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v64 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v63)), _Q5, *(int8x16_t *)((char *)&result[1] + v60));
        v65 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v22), v25));
        v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v22), v25));
        v67 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v62)), _Q5, *(int8x16_t *)((char *)result + v60));
        *v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v67, v67, v65, 3), vmlsq_laneq_f32(v65, v65, v67, 3)), v65, v67), (int8x16_t)v65), (int8x16_t)v67);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v64, v64, v66, 3), vmlsq_laneq_f32(v66, v66, v64, 3)), v66, v64), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *result);
          v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          *result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v71, v71, v70, 3), vmlsq_laneq_f32(v70, v70, v71, 3)), v71, v70), (int8x16_t)v71), (int8x16_t)v70);
        }
        v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8)
          v73 = -(uint64_t)a7;
        else
          v73 = 0;
        a3 = &v72[v73];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v74 = &a5[a4];
      if ((unint64_t)v74 >= a9)
        v75 = v29;
      else
        v75 = 0;
      v76 = &v74[v75];
      v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12)
      v80 = a12;
    v81 = v80;
    if (v80 < 2)
      goto LABEL_93;
    while (1)
    {
      v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v95 = (int8x16_t *)&a10[v81];
        v96 = (int8x16_t *)a10;
        do
          v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          v98 = v97;
          v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        v99 = (char *)v98 - a10;
        v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF)
        break;
      v83 = (int8x16_t *)&a10[v81];
      v84 = (int8x16_t *)a10;
      do
        v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        v86 = v85;
        v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      v87 = 0;
      v88 = (char *)v86 - a10;
      v89 = (char *)v86 - a10;
      do
      {
        v90 = (int8x16_t *)((char *)result + v87);
        v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v22), v25);
        v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v22), v25);
        v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v93, v93, v92, 3), vmlsq_laneq_f32(v92, v92, v93, 3)), v92, v93), (int8x16_t)v92), (int8x16_t)v93));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v94, v94, v91, 3), vmlsq_laneq_f32(v91, v91, v94, 3)), v91, v94), (int8x16_t)v91), (int8x16_t)v94));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      result = (int8x16_t *)((char *)result + v87);
      v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1)
        goto LABEL_93;
    }
    v101 = 0;
    while (1)
    {
      v102 = (int8x16_t *)((char *)result + v101);
      v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      v105 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v103)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      v106 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v22), v25));
      v107 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v22), v25));
      v108 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v104)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v108, v108, v107, 3), vmlsq_laneq_f32(v107, v107, v108, 3)), v107, v108), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v105, v105, v106, 3), vmlsq_laneq_f32(v106, v106, v105, 3)), v106, v105), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2)
        break;
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        v111 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*result));
        v112 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v112, v112, v111, 3), vmlsq_laneq_f32(v111, v111, v112, 3)), v112, v111), (int8x16_t)v112), (int8x16_t)v111));
      }
      v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8)
        v114 = -(uint64_t)a7;
      else
        v114 = 0;
      a3 = &v113[v114];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v115 = &a5[a4];
    if ((unint64_t)v115 >= a9)
      v116 = v29;
    else
      v116 = 0;
    v117 = &v115[v116];
    v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)14,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  unsigned int v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t *v54;
  int8x16_t *v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  int8x16_t *v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  unint64_t i;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t *v72;
  uint64_t v73;
  int8x16_t *v74;
  uint64_t v75;
  int8x16_t *v76;
  uint64_t v77;
  int8x16_t v78;
  float32x4_t v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  int8x16_t *v83;
  int8x16_t *v84;
  int8x16_t *v85;
  int8x16_t *v86;
  uint64_t v87;
  int64_t v88;
  unint64_t v89;
  int8x16_t *v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int8x16_t *v96;
  int8x16_t *v97;
  int8x16_t *v98;
  int64_t v99;
  int64_t v100;
  uint64_t v101;
  int8x16_t *v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  unint64_t j;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t *v113;
  uint64_t v114;
  int8x16_t *v115;
  uint64_t v116;
  int8x16_t *v117;
  uint64_t v118;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21 = vmvnq_s8(v20);
  v22 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v23 = 0;
  else
    v23 = -1;
  v24.i64[0] = 0;
  v24.i32[2] = 0;
  v24.i32[3] = v23;
  v25 = vandq_s8(v22, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v24);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v23), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V6.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v54 = (int8x16_t *)&a10[v40];
          v55 = (int8x16_t *)a10;
          do
            v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            v57 = v56;
            v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v58 = (char *)v57 - a10;
          v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v21), v25);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v21), v25);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v51, v52, v51), v52), (int8x16_t)v51), (int8x16_t)v52);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v50, v53, v50), v53), (int8x16_t)v50), (int8x16_t)v53);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v60 = 0;
      while (1)
      {
        v61 = (int8x16_t *)((char *)result + v60);
        v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v64 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v63)), (int8x16_t)_Q6, *(int8x16_t *)((char *)&result[1] + v60));
        v65 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v62)), (int8x16_t)_Q6, *(int8x16_t *)((char *)result + v60));
        v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v21), v25));
        v67 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v21), v25));
        *v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v67, v65, v67), v65), (int8x16_t)v67), (int8x16_t)v65);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v66, v64, v66), v64), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v70 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v69)), (int8x16_t)_Q6, *result);
          v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v21), v25));
          *result = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v71)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v71, v70, v71), v70), (int8x16_t)v71), (int8x16_t)v70);
        }
        v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8)
          v73 = -(uint64_t)a7;
        else
          v73 = 0;
        a3 = &v72[v73];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v74 = &a5[a4];
      if ((unint64_t)v74 >= a9)
        v75 = v29;
      else
        v75 = 0;
      v76 = &v74[v75];
      v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12)
      v80 = a12;
    v81 = v80;
    if (v80 < 2)
      goto LABEL_93;
    while (1)
    {
      v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v95 = (int8x16_t *)&a10[v81];
        v96 = (int8x16_t *)a10;
        do
          v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          v98 = v97;
          v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        v99 = (char *)v98 - a10;
        v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF)
        break;
      v83 = (int8x16_t *)&a10[v81];
      v84 = (int8x16_t *)a10;
      do
        v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        v86 = v85;
        v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      v87 = 0;
      v88 = (char *)v86 - a10;
      v89 = (char *)v86 - a10;
      do
      {
        v90 = (int8x16_t *)((char *)result + v87);
        v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v21), v25);
        v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v21), v25);
        v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v91, v93, v91), v93), (int8x16_t)v91), (int8x16_t)v93));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v92, v94, v92), v94), (int8x16_t)v92), (int8x16_t)v94));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      result = (int8x16_t *)((char *)result + v87);
      v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1)
        goto LABEL_93;
    }
    v101 = 0;
    while (1)
    {
      v102 = (int8x16_t *)((char *)result + v101);
      v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      v105 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v104)), (int8x16_t)_Q6, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      v106 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v21), v25));
      v107 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v21), v25));
      v108 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v103)), (int8x16_t)_Q6, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v107, v108, v107), v108), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v106, v105, v106), v105), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2)
        break;
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        v111 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v110)), (int8x16_t)_Q6, vrev32q_s8(*result));
        v112 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v21), v25));
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v112)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v112, v111, v112), v111), (int8x16_t)v112), (int8x16_t)v111));
      }
      v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8)
        v114 = -(uint64_t)a7;
      else
        v114 = 0;
      a3 = &v113[v114];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v115 = &a5[a4];
    if ((unint64_t)v115 >= a9)
      v116 = v29;
    else
      v116 = 0;
    v117 = &v115[v116];
    v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)15,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  float32x4_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  int8x16_t *v44;
  int8x16_t *v45;
  int8x16_t *v46;
  int8x16_t *v47;
  uint64_t v48;
  int64_t v49;
  unint64_t v50;
  int8x16_t *v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t *v64;
  int8x16_t *v65;
  int8x16_t *v66;
  int8x16_t *v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  int8x16_t *v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  unint64_t i;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t *v95;
  uint64_t v96;
  int8x16_t *v97;
  uint64_t v98;
  int8x16_t *v99;
  uint64_t v100;
  float32x4_t v101;
  int8x16_t v102;
  int8x16_t v103;
  float32x4_t v104;
  unint64_t v105;
  unint64_t v106;
  int v107;
  int8x16_t *v108;
  int8x16_t *v109;
  int8x16_t *v110;
  int8x16_t *v111;
  uint64_t v112;
  int64_t v113;
  unint64_t v114;
  int8x16_t *v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int8x16_t v124;
  int8x16_t v125;
  int8x16_t v126;
  int8x16_t v127;
  int8x16_t *v128;
  int8x16_t *v129;
  int8x16_t *v130;
  int8x16_t *v131;
  int64_t v132;
  int64_t v133;
  uint64_t v134;
  int8x16_t *v135;
  float32x4_t v136;
  float32x4_t v137;
  int8x16_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int8x16_t v147;
  int8x16_t v148;
  int8x16_t v149;
  int8x16_t v150;
  unint64_t j;
  float32x4_t v152;
  int8x16_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  int8x16_t v158;
  int8x16_t v159;
  int8x16_t *v160;
  uint64_t v161;
  int8x16_t *v162;
  uint64_t v163;
  int8x16_t *v164;
  uint64_t v165;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = 0x3F0000003F000000;
    v37.i64[1] = 0x3F0000003F000000;
    v38.i64[0] = 0x8000000080000000;
    v38.i64[1] = 0x8000000080000000;
    v39.i64[0] = -1;
    v39.i64[1] = -1;
    v40 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v41 = (a8 - (unint64_t)a3) >> 4;
      if (v41 >= a12)
        v41 = a12;
      v42 = v41;
      if (v41 < 2)
        goto LABEL_43;
      while (1)
      {
        v43 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v64 = (int8x16_t *)&a10[v42];
          v65 = (int8x16_t *)a10;
          do
            v66 = v65++;
          while (v65 <= v64 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v66)) & 0x80) != 0);
          do
          {
            v67 = v66;
            v66 = (int8x16_t *)((char *)v66 + 4);
          }
          while (v66 <= v64 && !v67->i32[0]);
          if (v67 < v64)
          {
            while (!v67->i8[0])
            {
              v67 = (int8x16_t *)((char *)v67 + 1);
              if (v67 >= v64)
              {
                v67 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          v68 = (char *)v67 - a10;
          v69 = ((char *)v67 - a10) * a14;
          a3 += v69;
          result += v69;
          a10 += v69;
          v42 -= v68;
          goto LABEL_40;
        }
        if (v43 != 0xFFFF)
          break;
        v44 = (int8x16_t *)&a10[v42];
        v45 = (int8x16_t *)a10;
        do
          v46 = v45++;
        while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v39)) & 0x80) != 0);
        do
        {
          v47 = v46;
          v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= v44 && v47->i32[0] == -1);
        if (v47 < v44)
        {
          while (v47->u8[0] == 255)
          {
            v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= v44)
            {
              v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        v48 = 0;
        v49 = (char *)v47 - a10;
        v50 = (char *)v47 - a10;
        do
        {
          v51 = (int8x16_t *)((char *)result + v48);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v48), v22), v25);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v48), v22), v25);
          v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v48), v26), v27);
          v55 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v48), v26), v27);
          v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
          v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
          v60 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v55, 3), v55);
          v61 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v54, 3), v54);
          v62 = vandq_s8(v61, v38);
          v63 = vandq_s8(v60, v38);
          *v51 = vbslq_s8((int8x16_t)vcgtzq_f32(v57), vbslq_s8((int8x16_t)vcgtzq_f32(v58), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v52, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v58, v55)), v52), vmlaq_f32(v55, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v57, v52)), v55)), (float32x4_t)vbslq_s8(v60, v38, (int8x16_t)vmulq_laneq_f32(v57, v55, 3))), (int8x16_t)v52), (int8x16_t)v55);
          v51[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v56), vbslq_s8((int8x16_t)vcgtzq_f32(v59), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v53, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v59, v54)), v53), vmlaq_f32(v54, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v56, v53)), v54)), (float32x4_t)vbslq_s8(v61, v38, (int8x16_t)vmulq_laneq_f32(v56, v54, 3))), (int8x16_t)v53), (int8x16_t)v54);
          a10 += v28;
          v50 -= 2;
          v48 += v30;
        }
        while (v50 > 1);
        a3 = (int8x16_t *)((char *)a3 + v48);
        result = (int8x16_t *)((char *)result + v48);
        v42 = v42 - v49 + v50;
LABEL_40:
        if (v42 <= 1)
          goto LABEL_43;
      }
      v70 = 0;
      while (1)
      {
        v71 = (int8x16_t *)((char *)result + v70);
        v72 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v43) & 0xFF00FF00FF00FFLL))), v40);
        v73 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v43)) & 0xFF00FF00FF00FFLL))), v40);
        v74 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v72));
        v75 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v73)), _Q5, *(int8x16_t *)((char *)&result[1] + v70));
        v76 = vmulq_f32(v72, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v70), v22), v25));
        v77 = vmulq_f32(v73, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v70), v22), v25));
        v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        v79 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3);
        v80 = (float32x4_t)vbslq_s8(v74, _Q5, *(int8x16_t *)((char *)result + v70));
        v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 3);
        v83 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v80, 3), v80);
        v84 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v75, 3), v75);
        v85 = vandq_s8(v84, v38);
        v86 = vandq_s8(v83, v38);
        *v71 = vbslq_s8((int8x16_t)vcgtzq_f32(v79), vbslq_s8((int8x16_t)vcgtzq_f32(v81), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v76, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v81, v80)), v76), vmlaq_f32(v80, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v79, v76)), v80)), (float32x4_t)vbslq_s8(v83, v38, (int8x16_t)vmulq_laneq_f32(v79, v80, 3))), (int8x16_t)v76), (int8x16_t)v80);
        v71[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v78), vbslq_s8((int8x16_t)vcgtzq_f32(v82), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v77, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v82, v75)), v77), vmlaq_f32(v75, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v78, v77)), v75)), (float32x4_t)vbslq_s8(v84, v38, (int8x16_t)vmulq_laneq_f32(v78, v75, 3))), (int8x16_t)v77), (int8x16_t)v75);
        a10 += v28;
        v42 -= 2;
        if (v42 < 2)
          break;
        LOWORD(v43) = *(_WORD *)a10;
        v70 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v70);
          a3 = (int8x16_t *)((char *)a3 + v70);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v70);
      a3 = (int8x16_t *)((char *)a3 + v30 + v70);
LABEL_43:
      for (i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          v88 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v40);
          v89 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v88)), _Q5, *result);
          v90 = vmulq_f32(v88, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          v91 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 3);
          v92 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v89, 3);
          v93 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v89, 3), v89);
          v94 = vandq_s8(v93, v38);
          *result = vbslq_s8((int8x16_t)vcgtzq_f32(v91), vbslq_s8((int8x16_t)vcgtzq_f32(v92), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v90, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v92, v89)), v90), vmlaq_f32(v89, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v91, v90)), v89)), (float32x4_t)vbslq_s8(v93, v38, (int8x16_t)vmulq_laneq_f32(v92, v90, 3))), (int8x16_t)v90), (int8x16_t)v89);
        }
        v95 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v95 >= a8)
          v96 = -(uint64_t)a7;
        else
          v96 = 0;
        a3 = &v95[v96];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v97 = &a5[a4];
      if ((unint64_t)v97 >= a9)
        v98 = v29;
      else
        v98 = 0;
      v99 = &v97[v98];
      v100 = a8 + 16 * v98 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v99;
        a8 = v100;
        a5 = v99;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v101.i64[0] = 0x3F0000003F000000;
  v101.i64[1] = 0x3F0000003F000000;
  v102.i64[0] = 0x8000000080000000;
  v102.i64[1] = 0x8000000080000000;
  v103.i64[0] = -1;
  v103.i64[1] = -1;
  v104 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v105 = (a8 - (unint64_t)a3) >> 4;
    if (v105 >= a12)
      v105 = a12;
    v106 = v105;
    if (v105 < 2)
      goto LABEL_93;
    while (1)
    {
      v107 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v128 = (int8x16_t *)&a10[v106];
        v129 = (int8x16_t *)a10;
        do
          v130 = v129++;
        while (v129 <= v128 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v130)) & 0x80) != 0);
        do
        {
          v131 = v130;
          v130 = (int8x16_t *)((char *)v130 + 4);
        }
        while (v130 <= v128 && !v131->i32[0]);
        if (v131 < v128)
        {
          while (!v131->i8[0])
          {
            v131 = (int8x16_t *)((char *)v131 + 1);
            if (v131 >= v128)
            {
              v131 = (int8x16_t *)&a10[v106];
              break;
            }
          }
        }
        v132 = (char *)v131 - a10;
        v133 = ((char *)v131 - a10) * a14;
        a3 += v133;
        result += v133;
        a10 += v133;
        v106 -= v132;
        goto LABEL_90;
      }
      if (v107 != 0xFFFF)
        break;
      v108 = (int8x16_t *)&a10[v106];
      v109 = (int8x16_t *)a10;
      do
        v110 = v109++;
      while (v109 <= v108 && (vminvq_u8((uint8x16_t)vceqq_s8(*v110, v103)) & 0x80) != 0);
      do
      {
        v111 = v110;
        v110 = (int8x16_t *)((char *)v110 + 4);
      }
      while (v110 <= v108 && v111->i32[0] == -1);
      if (v111 < v108)
      {
        while (v111->u8[0] == 255)
        {
          v111 = (int8x16_t *)((char *)v111 + 1);
          if (v111 >= v108)
          {
            v111 = (int8x16_t *)&a10[v106];
            break;
          }
        }
      }
      v112 = 0;
      v113 = (char *)v111 - a10;
      v114 = (char *)v111 - a10;
      do
      {
        v115 = (int8x16_t *)((char *)result + v112);
        v116 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v112)), v22), v25);
        v117 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v112)), v22), v25);
        v118 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v112)), v26), v27);
        v119 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v112)), v26), v27);
        v120 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 3);
        v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3);
        v122 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 3);
        v123 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3);
        v124 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v119, 3), v119);
        v125 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v118, 3), v118);
        v126 = vandq_s8(v125, v102);
        v127 = vandq_s8(v124, v102);
        *v115 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v120), vbslq_s8((int8x16_t)vcgtzq_f32(v123), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v117, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v123, v118)), v117), vmlaq_f32(v118, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v120, v117)), v118)), (float32x4_t)vbslq_s8(v125, v102, (int8x16_t)vmulq_laneq_f32(v120, v118, 3))), (int8x16_t)v117), (int8x16_t)v118));
        v115[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v121), vbslq_s8((int8x16_t)vcgtzq_f32(v122), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v116, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v122, v119)), v116), vmlaq_f32(v119, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v121, v116)), v119)), (float32x4_t)vbslq_s8(v124, v102, (int8x16_t)vmulq_laneq_f32(v121, v119, 3))), (int8x16_t)v116), (int8x16_t)v119));
        a10 += v28;
        v114 -= 2;
        v112 += v30;
      }
      while (v114 > 1);
      a3 = (int8x16_t *)((char *)a3 + v112);
      result = (int8x16_t *)((char *)result + v112);
      v106 = v106 - v113 + v114;
LABEL_90:
      if (v106 <= 1)
        goto LABEL_93;
    }
    v134 = 0;
    while (1)
    {
      v135 = (int8x16_t *)((char *)result + v134);
      v136 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v107)) & 0xFF00FF00FF00FFLL))), v104);
      v137 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v107) & 0xFF00FF00FF00FFLL))), v104);
      v138 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v137));
      v139 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v136)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v134)));
      v140 = vmulq_f32(v136, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v134)), v22), v25));
      v141 = vmulq_f32(v137, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v134)), v22), v25));
      v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 3);
      v143 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
      v144 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3);
      v145 = (float32x4_t)vbslq_s8(v138, _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v134)));
      v146 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v145, 3);
      v147 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v139, 3), v139);
      v148 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v145, 3), v145);
      v149 = vandq_s8(v148, v102);
      v150 = vandq_s8(v147, v102);
      *v135 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v142), vbslq_s8((int8x16_t)vcgtzq_f32(v146), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v141, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v146, v145)), v141), vmlaq_f32(v145, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v142, v141)), v145)), (float32x4_t)vbslq_s8(v148, v102, (int8x16_t)vmulq_laneq_f32(v142, v145, 3))), (int8x16_t)v141), (int8x16_t)v145));
      v135[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v143), vbslq_s8((int8x16_t)vcgtzq_f32(v144), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v140, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v144, v139)), v140), vmlaq_f32(v139, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v143, v140)), v139)), (float32x4_t)vbslq_s8(v147, v102, (int8x16_t)vmulq_laneq_f32(v143, v139, 3))), (int8x16_t)v140), (int8x16_t)v139));
      a10 += v28;
      v106 -= 2;
      if (v106 < 2)
        break;
      LOWORD(v107) = *(_WORD *)a10;
      v134 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v134);
        a3 = (int8x16_t *)((char *)a3 + v134);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v134);
    a3 = (int8x16_t *)((char *)a3 + v30 + v134);
LABEL_93:
    for (j = a12 - v105 + v106; j; --j)
    {
      if (*a10)
      {
        v152 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v104);
        v153 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v152));
        v154 = vmulq_f32(v152, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v155 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 3);
        v156 = (float32x4_t)vbslq_s8(v153, _Q5, vrev32q_s8(*result));
        v157 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v156, 3);
        v158 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v156, 3), v156);
        v159 = vandq_s8(v158, v102);
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v155), vbslq_s8((int8x16_t)vcgtzq_f32(v157), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v154, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v157, v156)), v154), vmlaq_f32(v156, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v155, v154)), v156)), (float32x4_t)vbslq_s8(v158, v102, (int8x16_t)vmulq_laneq_f32(v157, v154, 3))), (int8x16_t)v154), (int8x16_t)v156));
      }
      v160 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v160 >= a8)
        v161 = -(uint64_t)a7;
      else
        v161 = 0;
      a3 = &v160[v161];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v162 = &a5[a4];
    if ((unint64_t)v162 >= a9)
      v163 = v29;
    else
      v163 = 0;
    v164 = &v162[v163];
    v165 = a8 + 16 * v163 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v164;
      a8 = v165;
      a5 = v164;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)17,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t *v54;
  int8x16_t *v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  int8x16_t *v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  unint64_t i;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t *v72;
  uint64_t v73;
  int8x16_t *v74;
  uint64_t v75;
  int8x16_t *v76;
  uint64_t v77;
  int8x16_t v78;
  float32x4_t v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  int8x16_t *v83;
  int8x16_t *v84;
  int8x16_t *v85;
  int8x16_t *v86;
  uint64_t v87;
  int64_t v88;
  unint64_t v89;
  int8x16_t *v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int8x16_t *v96;
  int8x16_t *v97;
  int8x16_t *v98;
  int64_t v99;
  int64_t v100;
  uint64_t v101;
  int8x16_t *v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  unint64_t j;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t *v113;
  uint64_t v114;
  int8x16_t *v115;
  uint64_t v116;
  int8x16_t *v117;
  uint64_t v118;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v54 = (int8x16_t *)&a10[v40];
          v55 = (int8x16_t *)a10;
          do
            v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            v57 = v56;
            v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v58 = (char *)v57 - a10;
          v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v52, v52, v51, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v51, v52, 3), vmulq_laneq_f32(v52, v51, 3)), vmlsq_laneq_f32(v51, v51, v52, 3))), (int8x16_t)v52), (int8x16_t)v51);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v53, v53, v50, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v50, v53, 3), vmulq_laneq_f32(v53, v50, 3)), vmlsq_laneq_f32(v50, v50, v53, 3))), (int8x16_t)v53), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v60 = 0;
      while (1)
      {
        v61 = (int8x16_t *)((char *)result + v60);
        v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v64 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v63)), _Q5, *(int8x16_t *)((char *)&result[1] + v60));
        v65 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v22), v25));
        v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v22), v25));
        v67 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v62)), _Q5, *(int8x16_t *)((char *)result + v60));
        *v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v67, v65, 3), vmulq_laneq_f32(v65, v67, 3)), vmlsq_laneq_f32(v67, v67, v65, 3))), (int8x16_t)v65), (int8x16_t)v67);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v66, v66, v64, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v64, v66, 3), vmulq_laneq_f32(v66, v64, 3)), vmlsq_laneq_f32(v64, v64, v66, 3))), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *result);
          v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          *result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v71, v71, v70, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v70, v71, 3), vmulq_laneq_f32(v71, v70, 3)), vmlsq_laneq_f32(v70, v70, v71, 3))), (int8x16_t)v71), (int8x16_t)v70);
        }
        v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8)
          v73 = -(uint64_t)a7;
        else
          v73 = 0;
        a3 = &v72[v73];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v74 = &a5[a4];
      if ((unint64_t)v74 >= a9)
        v75 = v29;
      else
        v75 = 0;
      v76 = &v74[v75];
      v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12)
      v80 = a12;
    v81 = v80;
    if (v80 < 2)
      goto LABEL_93;
    while (1)
    {
      v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v95 = (int8x16_t *)&a10[v81];
        v96 = (int8x16_t *)a10;
        do
          v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          v98 = v97;
          v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        v99 = (char *)v98 - a10;
        v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF)
        break;
      v83 = (int8x16_t *)&a10[v81];
      v84 = (int8x16_t *)a10;
      do
        v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        v86 = v85;
        v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      v87 = 0;
      v88 = (char *)v86 - a10;
      v89 = (char *)v86 - a10;
      do
      {
        v90 = (int8x16_t *)((char *)result + v87);
        v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v22), v25);
        v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v22), v25);
        *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v94, v94, v91, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v91, v94, 3), vmulq_laneq_f32(v94, v91, 3)), vmlsq_laneq_f32(v91, v91, v94, 3))), (int8x16_t)v94), (int8x16_t)v91));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v93, v93, v92, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v92, v93, 3), vmulq_laneq_f32(v93, v92, 3)), vmlsq_laneq_f32(v92, v92, v93, 3))), (int8x16_t)v93), (int8x16_t)v92));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      result = (int8x16_t *)((char *)result + v87);
      v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1)
        goto LABEL_93;
    }
    v101 = 0;
    while (1)
    {
      v102 = (int8x16_t *)((char *)result + v101);
      v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      v105 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v103)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      v106 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v22), v25));
      v107 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v22), v25));
      v108 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v104)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v107, v107, v108, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v108, v107, 3), vmulq_laneq_f32(v107, v108, 3)), vmlsq_laneq_f32(v108, v108, v107, 3))), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v106, v106, v105, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v105, v106, 3), vmulq_laneq_f32(v106, v105, 3)), vmlsq_laneq_f32(v105, v105, v106, 3))), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2)
        break;
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        v111 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v112 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*result));
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v111, v111, v112, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v112, v111, 3), vmulq_laneq_f32(v111, v112, 3)), vmlsq_laneq_f32(v112, v112, v111, 3))), (int8x16_t)v111), (int8x16_t)v112));
      }
      v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8)
        v114 = -(uint64_t)a7;
      else
        v114 = 0;
      a3 = &v113[v114];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v115 = &a5[a4];
    if ((unint64_t)v115 >= a9)
      v116 = v29;
    else
      v116 = 0;
    v117 = &v115[v116];
    v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)16,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t *v54;
  int8x16_t *v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  int8x16_t *v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  unint64_t i;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t *v72;
  uint64_t v73;
  int8x16_t *v74;
  uint64_t v75;
  int8x16_t *v76;
  uint64_t v77;
  int8x16_t v78;
  float32x4_t v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  int8x16_t *v83;
  int8x16_t *v84;
  int8x16_t *v85;
  int8x16_t *v86;
  uint64_t v87;
  int64_t v88;
  unint64_t v89;
  int8x16_t *v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t *v95;
  int8x16_t *v96;
  int8x16_t *v97;
  int8x16_t *v98;
  int64_t v99;
  int64_t v100;
  uint64_t v101;
  int8x16_t *v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  unint64_t j;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  int8x16_t *v113;
  uint64_t v114;
  int8x16_t *v115;
  uint64_t v116;
  int8x16_t *v117;
  uint64_t v118;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v54 = (int8x16_t *)&a10[v40];
          v55 = (int8x16_t *)a10;
          do
            v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            v57 = v56;
            v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v58 = (char *)v57 - a10;
          v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v52, v52, v51, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v51, v52, 3), vmulq_laneq_f32(v52, v51, 3)), vmlsq_laneq_f32(v51, v51, v52, 3))), (int8x16_t)v52), (int8x16_t)v51);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v53, v53, v50, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v50, v53, 3), vmulq_laneq_f32(v53, v50, 3)), vmlsq_laneq_f32(v50, v50, v53, 3))), (int8x16_t)v53), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v60 = 0;
      while (1)
      {
        v61 = (int8x16_t *)((char *)result + v60);
        v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v64 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v63)), _Q5, *(int8x16_t *)((char *)&result[1] + v60));
        v65 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v22), v25));
        v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v22), v25));
        v67 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v62)), _Q5, *(int8x16_t *)((char *)result + v60));
        *v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v67, v65, 3), vmulq_laneq_f32(v65, v67, 3)), vmlsq_laneq_f32(v67, v67, v65, 3))), (int8x16_t)v65), (int8x16_t)v67);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v66, v66, v64, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v64, v66, 3), vmulq_laneq_f32(v66, v64, 3)), vmlsq_laneq_f32(v64, v64, v66, 3))), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *result);
          v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          *result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v71, v71, v70, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v70, v71, 3), vmulq_laneq_f32(v71, v70, 3)), vmlsq_laneq_f32(v70, v70, v71, 3))), (int8x16_t)v71), (int8x16_t)v70);
        }
        v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8)
          v73 = -(uint64_t)a7;
        else
          v73 = 0;
        a3 = &v72[v73];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v74 = &a5[a4];
      if ((unint64_t)v74 >= a9)
        v75 = v29;
      else
        v75 = 0;
      v76 = &v74[v75];
      v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12)
      v80 = a12;
    v81 = v80;
    if (v80 < 2)
      goto LABEL_93;
    while (1)
    {
      v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v95 = (int8x16_t *)&a10[v81];
        v96 = (int8x16_t *)a10;
        do
          v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          v98 = v97;
          v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        v99 = (char *)v98 - a10;
        v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF)
        break;
      v83 = (int8x16_t *)&a10[v81];
      v84 = (int8x16_t *)a10;
      do
        v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        v86 = v85;
        v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      v87 = 0;
      v88 = (char *)v86 - a10;
      v89 = (char *)v86 - a10;
      do
      {
        v90 = (int8x16_t *)((char *)result + v87);
        v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v22), v25);
        v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v22), v25);
        *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v94, v94, v91, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v91, v94, 3), vmulq_laneq_f32(v94, v91, 3)), vmlsq_laneq_f32(v91, v91, v94, 3))), (int8x16_t)v94), (int8x16_t)v91));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v93, v93, v92, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v92, v93, 3), vmulq_laneq_f32(v93, v92, 3)), vmlsq_laneq_f32(v92, v92, v93, 3))), (int8x16_t)v93), (int8x16_t)v92));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      result = (int8x16_t *)((char *)result + v87);
      v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1)
        goto LABEL_93;
    }
    v101 = 0;
    while (1)
    {
      v102 = (int8x16_t *)((char *)result + v101);
      v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      v105 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v103)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      v106 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v22), v25));
      v107 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v22), v25));
      v108 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v104)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v107, v107, v108, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v108, v107, 3), vmulq_laneq_f32(v107, v108, 3)), vmlsq_laneq_f32(v108, v108, v107, 3))), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v106, v106, v105, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v105, v106, 3), vmulq_laneq_f32(v106, v105, 3)), vmlsq_laneq_f32(v105, v105, v106, 3))), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2)
        break;
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        v111 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v112 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*result));
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v111, v111, v112, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v112, v111, 3), vmulq_laneq_f32(v111, v112, 3)), vmlsq_laneq_f32(v112, v112, v111, 3))), (int8x16_t)v111), (int8x16_t)v112));
      }
      v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8)
        v114 = -(uint64_t)a7;
      else
        v114 = 0;
      a3 = &v113[v114];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v115 = &a5[a4];
    if ((unint64_t)v115 >= a9)
      v116 = v29;
    else
      v116 = 0;
    v117 = &v115[v116];
    v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)18,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t *v66;
  int8x16_t *v67;
  int8x16_t *v68;
  int8x16_t *v69;
  int64_t v70;
  int64_t v71;
  uint64_t v72;
  int8x16_t *v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int8x16_t v91;
  int8x16_t v92;
  unint64_t i;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t v103;
  int8x16_t *v104;
  uint64_t v105;
  int8x16_t *v106;
  uint64_t v107;
  int8x16_t *v108;
  uint64_t v109;
  int8x16_t v110;
  float32x4_t v111;
  unint64_t v112;
  unint64_t v113;
  int v114;
  int8x16_t *v115;
  int8x16_t *v116;
  int8x16_t *v117;
  int8x16_t *v118;
  uint64_t v119;
  int64_t v120;
  unint64_t v121;
  int8x16_t *v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  int8x16_t v132;
  int8x16_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  int8x16_t v137;
  int8x16_t v138;
  int8x16_t *v139;
  int8x16_t *v140;
  int8x16_t *v141;
  int8x16_t *v142;
  int64_t v143;
  int64_t v144;
  uint64_t v145;
  int8x16_t *v146;
  float32x4_t v147;
  float32x4_t v148;
  int8x16_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  int8x16_t v158;
  int8x16_t v159;
  int8x16_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  int8x16_t v165;
  int8x16_t v166;
  unint64_t j;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  int8x16_t v173;
  int8x16_t v174;
  float32x4_t v175;
  float32x4_t v176;
  int8x16_t v177;
  int8x16_t *v178;
  uint64_t v179;
  int8x16_t *v180;
  uint64_t v181;
  int8x16_t *v182;
  uint64_t v183;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v66 = (int8x16_t *)&a10[v40];
          v67 = (int8x16_t *)a10;
          do
            v68 = v67++;
          while (v67 <= v66 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v68)) & 0x80) != 0);
          do
          {
            v69 = v68;
            v68 = (int8x16_t *)((char *)v68 + 4);
          }
          while (v68 <= v66 && !v69->i32[0]);
          if (v69 < v66)
          {
            while (!v69->i8[0])
            {
              v69 = (int8x16_t *)((char *)v69 + 1);
              if (v69 >= v66)
              {
                v69 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v70 = (char *)v69 - a10;
          v71 = ((char *)v69 - a10) * a14;
          a3 += v71;
          result += v71;
          a10 += v71;
          v40 -= v70;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          v52 = (int8x16_t)vcgtzq_f32(v51);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          v55 = (int8x16_t)vcgtzq_f32(v54);
          v56 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3);
          v58 = (int8x16_t)vcgtzq_f32(v57);
          v59 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          v60 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3);
          v61 = (int8x16_t)vcgtzq_f32(v60);
          v62 = vaddq_f32(v51, vmlsq_laneq_f32(v60, v51, v59, 3));
          v63 = vaddq_f32(v54, vmlsq_laneq_f32(v57, v54, v56, 3));
          v64 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v56, v56, v53, 3), vaddq_f32(vmlsq_laneq_f32(v53, v53, v56, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v57, v56), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v53, vmulq_f32(v56, v56), 3), vsubq_f32(v57, v56))))), v63);
          v65 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v59, v59, v50, 3), vaddq_f32(vmlsq_laneq_f32(v50, v50, v59, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v60, v59), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v50, vmulq_f32(v59, v59), 3), vsubq_f32(v60, v59))))), v62);
          v65.i32[3] = v62.i32[3];
          v64.i32[3] = v63.i32[3];
          *v49 = vbslq_s8(v58, vbslq_s8(v55, v64, (int8x16_t)v56), (int8x16_t)v53);
          v49[1] = vbslq_s8(v61, vbslq_s8(v52, v65, (int8x16_t)v59), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v72 = 0;
      while (1)
      {
        v73 = (int8x16_t *)((char *)result + v72);
        v74 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v75 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v76 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v75)), _Q5, *(int8x16_t *)((char *)&result[1] + v72));
        v77 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v74)), _Q5, *(int8x16_t *)((char *)result + v72));
        v78 = vmulq_f32(v74, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v72), v22), v25));
        v79 = vmulq_f32(v75, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v72), v22), v25));
        v80 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3);
        v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 3);
        v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        v83 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3);
        v84 = (int8x16_t)vcgtzq_f32(v82);
        v85 = (int8x16_t)vcgtzq_f32(v81);
        v86 = (int8x16_t)vcgtzq_f32(v80);
        v87 = vaddq_f32(vmlsq_laneq_f32(v79, v79, v76, 3), vaddq_f32(vmlsq_laneq_f32(v76, v76, v79, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v80, v79), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v76, vmulq_f32(v79, v79), 3), vsubq_f32(v80, v79)))));
        v88 = vaddq_f32(vmlsq_laneq_f32(v78, v78, v77, 3), vaddq_f32(vmlsq_laneq_f32(v77, v77, v78, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v81, v78), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v77, vmulq_f32(v78, v78), 3), vsubq_f32(v81, v78)))));
        v89 = vaddq_f32(v83, vmlsq_laneq_f32(v80, v83, v79, 3));
        v90 = vaddq_f32(v82, vmlsq_laneq_f32(v81, v82, v78, 3));
        v91 = (int8x16_t)vminnmq_f32(v87, v89);
        v91.i32[3] = v89.i32[3];
        v92 = (int8x16_t)vminnmq_f32(v88, v90);
        v92.i32[3] = v90.i32[3];
        *v73 = vbslq_s8(v85, vbslq_s8(v84, v92, (int8x16_t)v78), (int8x16_t)v77);
        v73[1] = vbslq_s8(v86, vbslq_s8((int8x16_t)vcgtzq_f32(v83), v91, (int8x16_t)v79), (int8x16_t)v76);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v72 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v72);
          a3 = (int8x16_t *)((char *)a3 + v72);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v72);
      a3 = (int8x16_t *)((char *)a3 + v30 + v72);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v95 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v94)), _Q5, *result);
          v96 = vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          v97 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3);
          v98 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3);
          v99 = (int8x16_t)vcgtzq_f32(v98);
          v100 = (int8x16_t)vcgtzq_f32(v97);
          v101 = vaddq_f32(vmlsq_laneq_f32(v96, v96, v95, 3), vaddq_f32(vmlsq_laneq_f32(v95, v95, v96, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v97, v96), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v95, vmulq_f32(v96, v96), 3), vsubq_f32(v97, v96)))));
          v102 = vaddq_f32(v98, vmlsq_laneq_f32(v97, v98, v96, 3));
          v103 = (int8x16_t)vminnmq_f32(v101, v102);
          v103.i32[3] = v102.i32[3];
          *result = vbslq_s8(v100, vbslq_s8(v99, v103, (int8x16_t)v96), (int8x16_t)v95);
        }
        v104 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v104 >= a8)
          v105 = -(uint64_t)a7;
        else
          v105 = 0;
        a3 = &v104[v105];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v106 = &a5[a4];
      if ((unint64_t)v106 >= a9)
        v107 = v29;
      else
        v107 = 0;
      v108 = &v106[v107];
      v109 = a8 + 16 * v107 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v108;
        a8 = v109;
        a5 = v108;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v110.i64[0] = -1;
  v110.i64[1] = -1;
  v111 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v112 = (a8 - (unint64_t)a3) >> 4;
    if (v112 >= a12)
      v112 = a12;
    v113 = v112;
    if (v112 < 2)
      goto LABEL_93;
    while (1)
    {
      v114 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v139 = (int8x16_t *)&a10[v113];
        v140 = (int8x16_t *)a10;
        do
          v141 = v140++;
        while (v140 <= v139 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v141)) & 0x80) != 0);
        do
        {
          v142 = v141;
          v141 = (int8x16_t *)((char *)v141 + 4);
        }
        while (v141 <= v139 && !v142->i32[0]);
        if (v142 < v139)
        {
          while (!v142->i8[0])
          {
            v142 = (int8x16_t *)((char *)v142 + 1);
            if (v142 >= v139)
            {
              v142 = (int8x16_t *)&a10[v113];
              break;
            }
          }
        }
        v143 = (char *)v142 - a10;
        v144 = ((char *)v142 - a10) * a14;
        a3 += v144;
        result += v144;
        a10 += v144;
        v113 -= v143;
        goto LABEL_90;
      }
      if (v114 != 0xFFFF)
        break;
      v115 = (int8x16_t *)&a10[v113];
      v116 = (int8x16_t *)a10;
      do
        v117 = v116++;
      while (v116 <= v115 && (vminvq_u8((uint8x16_t)vceqq_s8(*v117, v110)) & 0x80) != 0);
      do
      {
        v118 = v117;
        v117 = (int8x16_t *)((char *)v117 + 4);
      }
      while (v117 <= v115 && v118->i32[0] == -1);
      if (v118 < v115)
      {
        while (v118->u8[0] == 255)
        {
          v118 = (int8x16_t *)((char *)v118 + 1);
          if (v118 >= v115)
          {
            v118 = (int8x16_t *)&a10[v113];
            break;
          }
        }
      }
      v119 = 0;
      v120 = (char *)v118 - a10;
      v121 = (char *)v118 - a10;
      do
      {
        v122 = (int8x16_t *)((char *)result + v119);
        v123 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v119)), v26), v27);
        v124 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v119)), v26), v27);
        v125 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v123, 3);
        v126 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3);
        v127 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v119)), v22), v25);
        v128 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v127, 3);
        v129 = (int8x16_t)vcgtzq_f32(v125);
        v130 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v119)), v22), v25);
        v131 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 3);
        v132 = (int8x16_t)vcgtzq_f32(v128);
        v133 = (int8x16_t)vcgtzq_f32(v131);
        v134 = vaddq_f32(vmlsq_laneq_f32(v127, v127, v124, 3), vaddq_f32(vmlsq_laneq_f32(v124, v124, v127, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v128, v127), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v124, vmulq_f32(v127, v127), 3), vsubq_f32(v128, v127)))));
        v135 = vaddq_f32(v126, vmlsq_laneq_f32(v128, v126, v127, 3));
        v136 = vaddq_f32(v125, vmlsq_laneq_f32(v131, v125, v130, 3));
        v137 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v130, v130, v123, 3), vaddq_f32(vmlsq_laneq_f32(v123, v123, v130, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v131, v130), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v123, vmulq_f32(v130, v130), 3), vsubq_f32(v131, v130))))), v136);
        v138 = (int8x16_t)vminnmq_f32(v134, v135);
        v137.i32[3] = v136.i32[3];
        v138.i32[3] = v135.i32[3];
        *v122 = vrev32q_s8(vbslq_s8(v133, vbslq_s8(v129, v137, (int8x16_t)v130), (int8x16_t)v123));
        v122[1] = vrev32q_s8(vbslq_s8(v132, vbslq_s8((int8x16_t)vcgtzq_f32(v126), v138, (int8x16_t)v127), (int8x16_t)v124));
        a10 += v28;
        v121 -= 2;
        v119 += v30;
      }
      while (v121 > 1);
      a3 = (int8x16_t *)((char *)a3 + v119);
      result = (int8x16_t *)((char *)result + v119);
      v113 = v113 - v120 + v121;
LABEL_90:
      if (v113 <= 1)
        goto LABEL_93;
    }
    v145 = 0;
    while (1)
    {
      v146 = (int8x16_t *)((char *)result + v145);
      v147 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v114)) & 0xFF00FF00FF00FFLL))), v111);
      v148 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v114) & 0xFF00FF00FF00FFLL))), v111);
      v149 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v147));
      v150 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v148)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v145)));
      v151 = vmulq_f32(v147, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v145)), v22), v25));
      v152 = vmulq_f32(v148, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v145)), v22), v25));
      v153 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v152, 3);
      v154 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v151, 3);
      v155 = (float32x4_t)vbslq_s8(v149, _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v145)));
      v156 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 3);
      v157 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v150, 3);
      v158 = (int8x16_t)vcgtzq_f32(v157);
      v159 = (int8x16_t)vcgtzq_f32(v154);
      v160 = (int8x16_t)vcgtzq_f32(v153);
      v161 = vaddq_f32(vmlsq_laneq_f32(v151, v151, v155, 3), vaddq_f32(vmlsq_laneq_f32(v155, v155, v151, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v154, v151), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v155, vmulq_f32(v151, v151), 3), vsubq_f32(v154, v151)))));
      v162 = vaddq_f32(vmlsq_laneq_f32(v152, v152, v150, 3), vaddq_f32(vmlsq_laneq_f32(v150, v150, v152, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v153, v152), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v150, vmulq_f32(v152, v152), 3), vsubq_f32(v153, v152)))));
      v163 = vaddq_f32(v156, vmlsq_laneq_f32(v154, v156, v151, 3));
      v164 = vaddq_f32(v157, vmlsq_laneq_f32(v153, v157, v152, 3));
      v165 = (int8x16_t)vminnmq_f32(v162, v164);
      v166 = (int8x16_t)vminnmq_f32(v161, v163);
      v165.i32[3] = v164.i32[3];
      v166.i32[3] = v163.i32[3];
      *v146 = vrev32q_s8(vbslq_s8(v160, vbslq_s8(v158, v165, (int8x16_t)v152), (int8x16_t)v150));
      v146[1] = vrev32q_s8(vbslq_s8(v159, vbslq_s8((int8x16_t)vcgtzq_f32(v156), v166, (int8x16_t)v151), (int8x16_t)v155));
      a10 += v28;
      v113 -= 2;
      if (v113 < 2)
        break;
      LOWORD(v114) = *(_WORD *)a10;
      v145 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v145);
        a3 = (int8x16_t *)((char *)a3 + v145);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v145);
    a3 = (int8x16_t *)((char *)a3 + v30 + v145);
LABEL_93:
    for (j = a12 - v112 + v113; j; --j)
    {
      if (*a10)
      {
        v168 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v111);
        v169 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v168)), _Q5, vrev32q_s8(*result));
        v170 = vmulq_f32(v168, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v171 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v170, 3);
        v172 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v169, 3);
        v173 = (int8x16_t)vcgtzq_f32(v172);
        v174 = (int8x16_t)vcgtzq_f32(v171);
        v175 = vaddq_f32(vmlsq_laneq_f32(v170, v170, v169, 3), vaddq_f32(vmlsq_laneq_f32(v169, v169, v170, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v171, v170), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v169, vmulq_f32(v170, v170), 3), vsubq_f32(v171, v170)))));
        v176 = vaddq_f32(v172, vmlsq_laneq_f32(v171, v172, v170, 3));
        v177 = (int8x16_t)vminnmq_f32(v175, v176);
        v177.i32[3] = v176.i32[3];
        *result = vrev32q_s8(vbslq_s8(v174, vbslq_s8(v173, v177, (int8x16_t)v170), (int8x16_t)v169));
      }
      v178 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v178 >= a8)
        v179 = -(uint64_t)a7;
      else
        v179 = 0;
      a3 = &v178[v179];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v180 = &a5[a4];
    if ((unint64_t)v180 >= a9)
      v181 = v29;
    else
      v181 = 0;
    v182 = &v180[v181];
    v183 = a8 + 16 * v181 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v182;
      a8 = v183;
      a5 = v182;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)19,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  unsigned int v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t *v60;
  int8x16_t *v61;
  int8x16_t *v62;
  int8x16_t *v63;
  int64_t v64;
  int64_t v65;
  uint64_t v66;
  int8x16_t *v67;
  float32x4_t v68;
  float32x4_t v69;
  int8x16_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  int8x16_t v78;
  float32x4_t v79;
  float32x4_t v80;
  unint64_t i;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  float32x4_t v87;
  int8x16_t *v88;
  uint64_t v89;
  int8x16_t *v90;
  uint64_t v91;
  int8x16_t *v92;
  uint64_t v93;
  int8x16_t v94;
  float32x4_t v95;
  unint64_t v96;
  unint64_t v97;
  int v98;
  int8x16_t *v99;
  int8x16_t *v100;
  int8x16_t *v101;
  int8x16_t *v102;
  uint64_t v103;
  int64_t v104;
  unint64_t v105;
  int8x16_t *v106;
  float32x4_t v107;
  float32x4_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x4_t v111;
  int8x16_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  int8x16_t *v117;
  int8x16_t *v118;
  int8x16_t *v119;
  int8x16_t *v120;
  int64_t v121;
  int64_t v122;
  uint64_t v123;
  int8x16_t *v124;
  float32x4_t v125;
  float32x4_t v126;
  int8x16_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  int8x16_t v134;
  int8x16_t v135;
  float32x4_t v136;
  float32x4_t v137;
  unint64_t j;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  int8x16_t v143;
  float32x4_t v144;
  int8x16_t *v145;
  uint64_t v146;
  int8x16_t *v147;
  uint64_t v148;
  int8x16_t *v149;
  uint64_t v150;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21 = vmvnq_s8(v20);
  v22 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v23 = 0;
  else
    v23 = -1;
  v24.i64[0] = 0;
  v24.i32[2] = 0;
  v24.i32[3] = v23;
  v25 = vandq_s8(v22, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v24);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v23), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V6.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v60 = (int8x16_t *)&a10[v40];
          v61 = (int8x16_t *)a10;
          do
            v62 = v61++;
          while (v61 <= v60 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v62)) & 0x80) != 0);
          do
          {
            v63 = v62;
            v62 = (int8x16_t *)((char *)v62 + 4);
          }
          while (v62 <= v60 && !v63->i32[0]);
          if (v63 < v60)
          {
            while (!v63->i8[0])
            {
              v63 = (int8x16_t *)((char *)v63 + 1);
              if (v63 >= v60)
              {
                v63 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v64 = (char *)v63 - a10;
          v65 = ((char *)v63 - a10) * a14;
          a3 += v65;
          result += v65;
          a10 += v65;
          v40 -= v64;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v21), v25);
          v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          v54 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3));
          v55 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v21), v25);
          v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
          v57 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3));
          v58 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v52, v52), 3), v52);
          v59 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v55, v55), 3), v55);
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32(v53), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v52, v52, v50, 3), vaddq_f32(vmulq_laneq_f32(v53, v50, 3), vmlsq_laneq_f32(v50, v50, v52, 3))), v58, v50, 3), v50, v58), (float32x4_t)0), vbicq_s8(v54, (int8x16_t)vceqzq_f32(v52))), vbicq_s8((int8x16_t)v52, v54)), (int8x16_t)v50);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v56), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v55, v55, v51, 3), vaddq_f32(vmulq_laneq_f32(v56, v51, 3), vmlsq_laneq_f32(v51, v51, v55, 3))), v59, v51, 3), v51, v59), (float32x4_t)0), vbicq_s8(v57, (int8x16_t)vceqzq_f32(v55))), vbicq_s8((int8x16_t)v55, v57)), (int8x16_t)v51);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v66 = 0;
      while (1)
      {
        v67 = (int8x16_t *)((char *)result + v66);
        v68 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v70 = vandq_s8(v24, (int8x16_t)vcgtzq_f32(v68));
        v71 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v69)), _Q6, *(int8x16_t *)((char *)result + v66));
        v72 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v66), v21), v25));
        v73 = vmulq_f32(v68, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v66), v21), v25));
        v74 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3);
        v75 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3);
        v76 = (float32x4_t)vbslq_s8(v70, _Q6, *(int8x16_t *)((char *)&result[1] + v66));
        v77 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3));
        v78 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3));
        v79 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v73, v73), 3), v73);
        v80 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v72, v72), 3), v72);
        *v67 = vbslq_s8((int8x16_t)vcgtzq_f32(v75), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v72, v72, v71, 3), vaddq_f32(vmulq_laneq_f32(v75, v71, 3), vmlsq_laneq_f32(v71, v71, v72, 3))), v80, v71, 3), v71, v80), (float32x4_t)0), vbicq_s8(v77, (int8x16_t)vceqzq_f32(v72))), vbicq_s8((int8x16_t)v72, v77)), (int8x16_t)v71);
        v67[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v74), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v73, v73, v76, 3), vaddq_f32(vmulq_laneq_f32(v74, v76, 3), vmlsq_laneq_f32(v76, v76, v73, 3))), v79, v76, 3), v76, v79), (float32x4_t)0), vbicq_s8(v78, (int8x16_t)vceqzq_f32(v73))), vbicq_s8((int8x16_t)v73, v78)), (int8x16_t)v76);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v66 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v66);
          a3 = (int8x16_t *)((char *)a3 + v66);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v66);
      a3 = (int8x16_t *)((char *)a3 + v30 + v66);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v82 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v83 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v82)), _Q6, *result);
          v84 = vmulq_f32(v82, (float32x4_t)vorrq_s8(vandq_s8(*a3, v21), v25));
          v85 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 3);
          v86 = (int8x16_t)vcgtzq_f32(v85);
          v87 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v84, v84), 3), v84);
          *result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 3)), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v84, v84, v83, 3), vaddq_f32(vmlsq_laneq_f32(v83, v83, v84, 3), vmulq_laneq_f32(v85, v84, 3))), v87, v83, 3), v83, v87), (float32x4_t)0), vbicq_s8(v86, (int8x16_t)vceqzq_f32(v84))), vbicq_s8((int8x16_t)v84, v86)), (int8x16_t)v83);
        }
        v88 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v88 >= a8)
          v89 = -(uint64_t)a7;
        else
          v89 = 0;
        a3 = &v88[v89];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v90 = &a5[a4];
      if ((unint64_t)v90 >= a9)
        v91 = v29;
      else
        v91 = 0;
      v92 = &v90[v91];
      v93 = a8 + 16 * v91 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v92;
        a8 = v93;
        a5 = v92;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v94.i64[0] = -1;
  v94.i64[1] = -1;
  v95 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v96 = (a8 - (unint64_t)a3) >> 4;
    if (v96 >= a12)
      v96 = a12;
    v97 = v96;
    if (v96 < 2)
      goto LABEL_93;
    while (1)
    {
      v98 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v117 = (int8x16_t *)&a10[v97];
        v118 = (int8x16_t *)a10;
        do
          v119 = v118++;
        while (v118 <= v117 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v119)) & 0x80) != 0);
        do
        {
          v120 = v119;
          v119 = (int8x16_t *)((char *)v119 + 4);
        }
        while (v119 <= v117 && !v120->i32[0]);
        if (v120 < v117)
        {
          while (!v120->i8[0])
          {
            v120 = (int8x16_t *)((char *)v120 + 1);
            if (v120 >= v117)
            {
              v120 = (int8x16_t *)&a10[v97];
              break;
            }
          }
        }
        v121 = (char *)v120 - a10;
        v122 = ((char *)v120 - a10) * a14;
        a3 += v122;
        result += v122;
        a10 += v122;
        v97 -= v121;
        goto LABEL_90;
      }
      if (v98 != 0xFFFF)
        break;
      v99 = (int8x16_t *)&a10[v97];
      v100 = (int8x16_t *)a10;
      do
        v101 = v100++;
      while (v100 <= v99 && (vminvq_u8((uint8x16_t)vceqq_s8(*v101, v94)) & 0x80) != 0);
      do
      {
        v102 = v101;
        v101 = (int8x16_t *)((char *)v101 + 4);
      }
      while (v101 <= v99 && v102->i32[0] == -1);
      if (v102 < v99)
      {
        while (v102->u8[0] == 255)
        {
          v102 = (int8x16_t *)((char *)v102 + 1);
          if (v102 >= v99)
          {
            v102 = (int8x16_t *)&a10[v97];
            break;
          }
        }
      }
      v103 = 0;
      v104 = (char *)v102 - a10;
      v105 = (char *)v102 - a10;
      do
      {
        v106 = (int8x16_t *)((char *)result + v103);
        v107 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v103)), v26), v27);
        v108 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v103)), v26), v27);
        v109 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3));
        v110 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v103)), v21), v25);
        v111 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 3);
        v112 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3));
        v113 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v103)), v21), v25);
        v114 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 3);
        v115 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v110, v110), 3), v110);
        v116 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v113, v113), 3), v113);
        *v106 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v114), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v113, v113, v108, 3), vaddq_f32(vmulq_laneq_f32(v114, v108, 3), vmlsq_laneq_f32(v108, v108, v113, 3))), v116, v108, 3), v108, v116), (float32x4_t)0), vbicq_s8(v112, (int8x16_t)vceqzq_f32(v113))),
                      vbicq_s8((int8x16_t)v113, v112)),
                    (int8x16_t)v108));
        v106[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v111), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v110, v110, v107, 3), vaddq_f32(vmulq_laneq_f32(v111, v107, 3), vmlsq_laneq_f32(v107, v107, v110, 3))), v115, v107, 3), v107, v115), (float32x4_t)0), vbicq_s8(v109, (int8x16_t)vceqzq_f32(v110))),
                        vbicq_s8((int8x16_t)v110, v109)),
                      (int8x16_t)v107));
        a10 += v28;
        v105 -= 2;
        v103 += v30;
      }
      while (v105 > 1);
      a3 = (int8x16_t *)((char *)a3 + v103);
      result = (int8x16_t *)((char *)result + v103);
      v97 = v97 - v104 + v105;
LABEL_90:
      if (v97 <= 1)
        goto LABEL_93;
    }
    v123 = 0;
    while (1)
    {
      v124 = (int8x16_t *)((char *)result + v123);
      v125 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v98) & 0xFF00FF00FF00FFLL))), v95);
      v126 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v98)) & 0xFF00FF00FF00FFLL))), v95);
      v127 = vandq_s8(v24, (int8x16_t)vcgtzq_f32(v126));
      v128 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v125)), _Q6, vrev32q_s8(*(int8x16_t *)((char *)result + v123)));
      v129 = vmulq_f32(v126, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v123)), v21), v25));
      v130 = vmulq_f32(v125, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v123)), v21), v25));
      v131 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 3);
      v132 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v129, 3);
      v133 = (float32x4_t)vbslq_s8(v127, _Q6, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v123)));
      v134 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v133, 3));
      v135 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3));
      v136 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v129, v129), 3), v129);
      v137 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v130, v130), 3), v130);
      *v124 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v131), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v130, v130, v128, 3), vaddq_f32(vmulq_laneq_f32(v131, v128, 3), vmlsq_laneq_f32(v128, v128, v130, 3))), v137, v128, 3), v128, v137), (float32x4_t)0), vbicq_s8(v135, (int8x16_t)vceqzq_f32(v130))), vbicq_s8((int8x16_t)v130, v135)), (int8x16_t)v128));
      v124[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v132), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v129, v129, v133, 3), vaddq_f32(vmulq_laneq_f32(v132, v133, 3), vmlsq_laneq_f32(v133, v133, v129, 3))), v136, v133, 3), v133, v136), (float32x4_t)0), vbicq_s8(v134, (int8x16_t)vceqzq_f32(v129))),
                      vbicq_s8((int8x16_t)v129, v134)),
                    (int8x16_t)v133));
      a10 += v28;
      v97 -= 2;
      if (v97 < 2)
        break;
      LOWORD(v98) = *(_WORD *)a10;
      v123 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v123);
        a3 = (int8x16_t *)((char *)a3 + v123);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v123);
    a3 = (int8x16_t *)((char *)a3 + v30 + v123);
LABEL_93:
    for (j = a12 - v96 + v97; j; --j)
    {
      if (*a10)
      {
        v139 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v95);
        v140 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v139)), _Q6, vrev32q_s8(*result));
        v141 = vmulq_f32(v139, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v21), v25));
        v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
        v143 = (int8x16_t)vcgtzq_f32(v142);
        v144 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v141, v141), 3), v141);
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 3)), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v141, v141, v140, 3), vaddq_f32(vmlsq_laneq_f32(v140, v140, v141, 3), vmulq_laneq_f32(v142, v141, 3))), v144, v140, 3), v140, v144), (float32x4_t)0), vbicq_s8(v143, (int8x16_t)vceqzq_f32(v141))),
                        vbicq_s8((int8x16_t)v141, v143)),
                      (int8x16_t)v140));
      }
      v145 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v145 >= a8)
        v146 = -(uint64_t)a7;
      else
        v146 = 0;
      a3 = &v145[v146];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v147 = &a5[a4];
    if ((unint64_t)v147 >= a9)
      v148 = v29;
    else
      v148 = 0;
    v149 = &v147[v148];
    v150 = a8 + 16 * v148 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v149;
      a8 = v150;
      a5 = v149;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)21,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float32x4_t v37;
  int8x16_t v38;
  int8x16_t v39;
  float32x4_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  int8x16_t *v44;
  int8x16_t *v45;
  int8x16_t *v46;
  int8x16_t *v47;
  uint64_t v48;
  int64_t v49;
  unint64_t v50;
  int8x16_t *v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t *v64;
  int8x16_t *v65;
  int8x16_t *v66;
  int8x16_t *v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  int8x16_t *v71;
  float32x4_t v72;
  float32x4_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  unint64_t i;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t v93;
  int8x16_t v94;
  int8x16_t *v95;
  uint64_t v96;
  int8x16_t *v97;
  uint64_t v98;
  int8x16_t *v99;
  uint64_t v100;
  float32x4_t v101;
  int8x16_t v102;
  int8x16_t v103;
  float32x4_t v104;
  unint64_t v105;
  unint64_t v106;
  int v107;
  int8x16_t *v108;
  int8x16_t *v109;
  int8x16_t *v110;
  int8x16_t *v111;
  uint64_t v112;
  int64_t v113;
  unint64_t v114;
  int8x16_t *v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  int8x16_t v124;
  int8x16_t v125;
  int8x16_t v126;
  int8x16_t v127;
  int8x16_t *v128;
  int8x16_t *v129;
  int8x16_t *v130;
  int8x16_t *v131;
  int64_t v132;
  int64_t v133;
  uint64_t v134;
  int8x16_t *v135;
  float32x4_t v136;
  float32x4_t v137;
  int8x16_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  int8x16_t v147;
  int8x16_t v148;
  int8x16_t v149;
  int8x16_t v150;
  unint64_t j;
  float32x4_t v152;
  int8x16_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  int8x16_t v158;
  int8x16_t v159;
  int8x16_t *v160;
  uint64_t v161;
  int8x16_t *v162;
  uint64_t v163;
  int8x16_t *v164;
  uint64_t v165;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = 0x3F0000003F000000;
    v37.i64[1] = 0x3F0000003F000000;
    v38.i64[0] = 0x8000000080000000;
    v38.i64[1] = 0x8000000080000000;
    v39.i64[0] = -1;
    v39.i64[1] = -1;
    v40 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v41 = (a8 - (unint64_t)a3) >> 4;
      if (v41 >= a12)
        v41 = a12;
      v42 = v41;
      if (v41 < 2)
        goto LABEL_43;
      while (1)
      {
        v43 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v64 = (int8x16_t *)&a10[v42];
          v65 = (int8x16_t *)a10;
          do
            v66 = v65++;
          while (v65 <= v64 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v66)) & 0x80) != 0);
          do
          {
            v67 = v66;
            v66 = (int8x16_t *)((char *)v66 + 4);
          }
          while (v66 <= v64 && !v67->i32[0]);
          if (v67 < v64)
          {
            while (!v67->i8[0])
            {
              v67 = (int8x16_t *)((char *)v67 + 1);
              if (v67 >= v64)
              {
                v67 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          v68 = (char *)v67 - a10;
          v69 = ((char *)v67 - a10) * a14;
          a3 += v69;
          result += v69;
          a10 += v69;
          v42 -= v68;
          goto LABEL_40;
        }
        if (v43 != 0xFFFF)
          break;
        v44 = (int8x16_t *)&a10[v42];
        v45 = (int8x16_t *)a10;
        do
          v46 = v45++;
        while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v39)) & 0x80) != 0);
        do
        {
          v47 = v46;
          v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= v44 && v47->i32[0] == -1);
        if (v47 < v44)
        {
          while (v47->u8[0] == 255)
          {
            v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= v44)
            {
              v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        v48 = 0;
        v49 = (char *)v47 - a10;
        v50 = (char *)v47 - a10;
        do
        {
          v51 = (int8x16_t *)((char *)result + v48);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v48), v22), v25);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v48), v22), v25);
          v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v48), v26), v27);
          v55 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v48), v26), v27);
          v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
          v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
          v60 = (int8x16_t)vcgtq_f32(v52, vmulq_laneq_f32(v37, v52, 3));
          v61 = (int8x16_t)vcgtq_f32(v53, vmulq_laneq_f32(v37, v53, 3));
          v62 = vbicq_s8(v38, v61);
          v63 = vbicq_s8(v38, v60);
          *v51 = vbslq_s8((int8x16_t)vcgtzq_f32(v57), vbslq_s8((int8x16_t)vcgtzq_f32(v58), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v55, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v57, v52)), v55), vmlaq_f32(v52, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v58, v55)), v52)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v57, v55, 3), v60)), (int8x16_t)v52), (int8x16_t)v55);
          v51[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v56), vbslq_s8((int8x16_t)vcgtzq_f32(v59), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v54, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v56, v53)), v54), vmlaq_f32(v53, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v59, v54)), v53)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v56, v54, 3), v61)), (int8x16_t)v53), (int8x16_t)v54);
          a10 += v28;
          v50 -= 2;
          v48 += v30;
        }
        while (v50 > 1);
        a3 = (int8x16_t *)((char *)a3 + v48);
        result = (int8x16_t *)((char *)result + v48);
        v42 = v42 - v49 + v50;
LABEL_40:
        if (v42 <= 1)
          goto LABEL_43;
      }
      v70 = 0;
      while (1)
      {
        v71 = (int8x16_t *)((char *)result + v70);
        v72 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v43) & 0xFF00FF00FF00FFLL))), v40);
        v73 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v43)) & 0xFF00FF00FF00FFLL))), v40);
        v74 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v72));
        v75 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v73)), _Q5, *(int8x16_t *)((char *)&result[1] + v70));
        v76 = vmulq_f32(v72, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v70), v22), v25));
        v77 = vmulq_f32(v73, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v70), v22), v25));
        v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        v79 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3);
        v80 = (float32x4_t)vbslq_s8(v74, _Q5, *(int8x16_t *)((char *)result + v70));
        v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 3);
        v83 = (int8x16_t)vcgtq_f32(v76, vmulq_laneq_f32(v37, v76, 3));
        v84 = (int8x16_t)vcgtq_f32(v77, vmulq_laneq_f32(v37, v77, 3));
        v85 = vbicq_s8(v38, v84);
        v86 = vbicq_s8(v38, v83);
        *v71 = vbslq_s8((int8x16_t)vcgtzq_f32(v79), vbslq_s8((int8x16_t)vcgtzq_f32(v81), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v80, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v79, v76)), v80), vmlaq_f32(v76, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v81, v80)), v76)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v79, v80, 3), v83)), (int8x16_t)v76), (int8x16_t)v80);
        v71[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v78), vbslq_s8((int8x16_t)vcgtzq_f32(v82), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v75, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v78, v77)), v75), vmlaq_f32(v77, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v82, v75)), v77)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v78, v75, 3), v84)), (int8x16_t)v77), (int8x16_t)v75);
        a10 += v28;
        v42 -= 2;
        if (v42 < 2)
          break;
        LOWORD(v43) = *(_WORD *)a10;
        v70 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v70);
          a3 = (int8x16_t *)((char *)a3 + v70);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v70);
      a3 = (int8x16_t *)((char *)a3 + v30 + v70);
LABEL_43:
      for (i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          v88 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v40);
          v89 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v88)), _Q5, *result);
          v90 = vmulq_f32(v88, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          v91 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 3);
          v92 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v89, 3);
          v93 = (int8x16_t)vcgtq_f32(v90, vmulq_laneq_f32(v37, v90, 3));
          v94 = vbicq_s8(v38, v93);
          *result = vbslq_s8((int8x16_t)vcgtzq_f32(v91), vbslq_s8((int8x16_t)vcgtzq_f32(v92), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v89, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v91, v90)), v89), vmlaq_f32(v90, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v92, v89)), v90)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v92, v90, 3), v93)), (int8x16_t)v90), (int8x16_t)v89);
        }
        v95 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v95 >= a8)
          v96 = -(uint64_t)a7;
        else
          v96 = 0;
        a3 = &v95[v96];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v97 = &a5[a4];
      if ((unint64_t)v97 >= a9)
        v98 = v29;
      else
        v98 = 0;
      v99 = &v97[v98];
      v100 = a8 + 16 * v98 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v99;
        a8 = v100;
        a5 = v99;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v101.i64[0] = 0x3F0000003F000000;
  v101.i64[1] = 0x3F0000003F000000;
  v102.i64[0] = 0x8000000080000000;
  v102.i64[1] = 0x8000000080000000;
  v103.i64[0] = -1;
  v103.i64[1] = -1;
  v104 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v105 = (a8 - (unint64_t)a3) >> 4;
    if (v105 >= a12)
      v105 = a12;
    v106 = v105;
    if (v105 < 2)
      goto LABEL_93;
    while (1)
    {
      v107 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v128 = (int8x16_t *)&a10[v106];
        v129 = (int8x16_t *)a10;
        do
          v130 = v129++;
        while (v129 <= v128 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v130)) & 0x80) != 0);
        do
        {
          v131 = v130;
          v130 = (int8x16_t *)((char *)v130 + 4);
        }
        while (v130 <= v128 && !v131->i32[0]);
        if (v131 < v128)
        {
          while (!v131->i8[0])
          {
            v131 = (int8x16_t *)((char *)v131 + 1);
            if (v131 >= v128)
            {
              v131 = (int8x16_t *)&a10[v106];
              break;
            }
          }
        }
        v132 = (char *)v131 - a10;
        v133 = ((char *)v131 - a10) * a14;
        a3 += v133;
        result += v133;
        a10 += v133;
        v106 -= v132;
        goto LABEL_90;
      }
      if (v107 != 0xFFFF)
        break;
      v108 = (int8x16_t *)&a10[v106];
      v109 = (int8x16_t *)a10;
      do
        v110 = v109++;
      while (v109 <= v108 && (vminvq_u8((uint8x16_t)vceqq_s8(*v110, v103)) & 0x80) != 0);
      do
      {
        v111 = v110;
        v110 = (int8x16_t *)((char *)v110 + 4);
      }
      while (v110 <= v108 && v111->i32[0] == -1);
      if (v111 < v108)
      {
        while (v111->u8[0] == 255)
        {
          v111 = (int8x16_t *)((char *)v111 + 1);
          if (v111 >= v108)
          {
            v111 = (int8x16_t *)&a10[v106];
            break;
          }
        }
      }
      v112 = 0;
      v113 = (char *)v111 - a10;
      v114 = (char *)v111 - a10;
      do
      {
        v115 = (int8x16_t *)((char *)result + v112);
        v116 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v112)), v22), v25);
        v117 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v112)), v22), v25);
        v118 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v112)), v26), v27);
        v119 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v112)), v26), v27);
        v120 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 3);
        v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3);
        v122 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 3);
        v123 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3);
        v124 = (int8x16_t)vcgtq_f32(v116, vmulq_laneq_f32(v101, v116, 3));
        v125 = (int8x16_t)vcgtq_f32(v117, vmulq_laneq_f32(v101, v117, 3));
        v126 = vbicq_s8(v102, v125);
        v127 = vbicq_s8(v102, v124);
        *v115 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v120), vbslq_s8((int8x16_t)vcgtzq_f32(v123), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v118, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v120, v117)), v118), vmlaq_f32(v117, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v123, v118)), v117)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v120, v118, 3), v125)), (int8x16_t)v117), (int8x16_t)v118));
        v115[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v121), vbslq_s8((int8x16_t)vcgtzq_f32(v122), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v119, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v121, v116)), v119), vmlaq_f32(v116, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v122, v119)), v116)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v121, v119, 3), v124)), (int8x16_t)v116), (int8x16_t)v119));
        a10 += v28;
        v114 -= 2;
        v112 += v30;
      }
      while (v114 > 1);
      a3 = (int8x16_t *)((char *)a3 + v112);
      result = (int8x16_t *)((char *)result + v112);
      v106 = v106 - v113 + v114;
LABEL_90:
      if (v106 <= 1)
        goto LABEL_93;
    }
    v134 = 0;
    while (1)
    {
      v135 = (int8x16_t *)((char *)result + v134);
      v136 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v107)) & 0xFF00FF00FF00FFLL))), v104);
      v137 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v107) & 0xFF00FF00FF00FFLL))), v104);
      v138 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v137));
      v139 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v136)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v134)));
      v140 = vmulq_f32(v136, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v134)), v22), v25));
      v141 = vmulq_f32(v137, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v134)), v22), v25));
      v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 3);
      v143 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
      v144 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3);
      v145 = (float32x4_t)vbslq_s8(v138, _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v134)));
      v146 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v145, 3);
      v147 = (int8x16_t)vcgtq_f32(v140, vmulq_laneq_f32(v101, v140, 3));
      v148 = (int8x16_t)vcgtq_f32(v141, vmulq_laneq_f32(v101, v141, 3));
      v149 = vbicq_s8(v102, v148);
      v150 = vbicq_s8(v102, v147);
      *v135 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v142), vbslq_s8((int8x16_t)vcgtzq_f32(v146), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v145, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v142, v141)), v145), vmlaq_f32(v141, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v146, v145)), v141)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v142, v145, 3), v148)), (int8x16_t)v141), (int8x16_t)v145));
      v135[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v143), vbslq_s8((int8x16_t)vcgtzq_f32(v144), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v139, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v143, v140)), v139), vmlaq_f32(v140, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v144, v139)), v140)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v143, v139, 3), v147)), (int8x16_t)v140), (int8x16_t)v139));
      a10 += v28;
      v106 -= 2;
      if (v106 < 2)
        break;
      LOWORD(v107) = *(_WORD *)a10;
      v134 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v134);
        a3 = (int8x16_t *)((char *)a3 + v134);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v134);
    a3 = (int8x16_t *)((char *)a3 + v30 + v134);
LABEL_93:
    for (j = a12 - v105 + v106; j; --j)
    {
      if (*a10)
      {
        v152 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v104);
        v153 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v152));
        v154 = vmulq_f32(v152, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v155 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 3);
        v156 = (float32x4_t)vbslq_s8(v153, _Q5, vrev32q_s8(*result));
        v157 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v156, 3);
        v158 = (int8x16_t)vcgtq_f32(v154, vmulq_laneq_f32(v101, v154, 3));
        v159 = vbicq_s8(v102, v158);
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v155), vbslq_s8((int8x16_t)vcgtzq_f32(v157), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v156, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v155, v154)), v156), vmlaq_f32(v154, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v157, v156)), v154)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v157, v154, 3), v158)), (int8x16_t)v154), (int8x16_t)v156));
      }
      v160 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v160 >= a8)
        v161 = -(uint64_t)a7;
      else
        v161 = 0;
      a3 = &v160[v161];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v162 = &a5[a4];
    if ((unint64_t)v162 >= a9)
      v163 = v29;
    else
      v163 = 0;
    v164 = &v162[v163];
    v165 = a8 + 16 * v163 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v164;
      a8 = v165;
      a5 = v164;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)20,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int8x16_t v55;
  float32x4_t v56;
  int8x16_t v57;
  int8x16_t v58;
  int8x16_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  int8x16_t *v67;
  int8x16_t *v68;
  int8x16_t *v69;
  int8x16_t *v70;
  int64_t v71;
  int64_t v72;
  uint64_t v73;
  int8x16_t *v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int8x16_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  unint64_t i;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  int8x16_t *v103;
  uint64_t v104;
  int8x16_t *v105;
  uint64_t v106;
  int8x16_t *v107;
  uint64_t v108;
  int8x16_t v109;
  float32x4_t v110;
  unint64_t v111;
  unint64_t v112;
  int v113;
  int8x16_t *v114;
  int8x16_t *v115;
  int8x16_t *v116;
  int8x16_t *v117;
  uint64_t v118;
  int64_t v119;
  unint64_t v120;
  int8x16_t *v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  int8x16_t v127;
  float32x4_t v128;
  int8x16_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  int8x16_t *v137;
  int8x16_t *v138;
  int8x16_t *v139;
  int8x16_t *v140;
  int64_t v141;
  int64_t v142;
  uint64_t v143;
  int8x16_t *v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  int8x16_t v153;
  int8x16_t v154;
  int8x16_t v155;
  int8x16_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  unint64_t j;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  int8x16_t v169;
  int8x16_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  int8x16_t *v174;
  uint64_t v175;
  int8x16_t *v176;
  uint64_t v177;
  int8x16_t *v178;
  uint64_t v179;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v67 = (int8x16_t *)&a10[v40];
          v68 = (int8x16_t *)a10;
          do
            v69 = v68++;
          while (v68 <= v67 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v69)) & 0x80) != 0);
          do
          {
            v70 = v69;
            v69 = (int8x16_t *)((char *)v69 + 4);
          }
          while (v69 <= v67 && !v70->i32[0]);
          if (v70 < v67)
          {
            while (!v70->i8[0])
            {
              v70 = (int8x16_t *)((char *)v70 + 1);
              if (v70 >= v67)
              {
                v70 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v71 = (char *)v70 - a10;
          v72 = ((char *)v70 - a10) * a14;
          a3 += v72;
          result += v72;
          a10 += v72;
          v40 -= v71;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v52 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3);
          v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v55 = (int8x16_t)vcgtzq_f32(v52);
          v56 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          v57 = (int8x16_t)vcgtzq_f32(v53);
          v58 = (int8x16_t)vceqzq_f32(v52);
          v59 = (int8x16_t)vceqzq_f32(v53);
          v60 = vdivq_f32(v50, v52);
          v61 = vaddq_f32(v56, v56);
          v62 = vdivq_f32(v51, v53);
          v63 = vaddq_f32(v54, v54);
          v64 = vmlaq_laneq_f32(vmlsq_f32(v61, v60, v61), v60, v56, 3);
          v65 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v63, v62, v63), v62, v54, 3), v51);
          v66 = vmulq_f32(v64, v50);
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3)), vbslq_s8(v57, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v54, v54, v51, 3), vaddq_f32(vmlsq_laneq_f32(v51, v51, v54, 3), (float32x4_t)vandq_s8((int8x16_t)v65, vbicq_s8((int8x16_t)vcgezq_f32(v65), v59)))), (int8x16_t)v54), (int8x16_t)v51);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3)), vbslq_s8(v55, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v56, v56, v50, 3), vaddq_f32(vmlsq_laneq_f32(v50, v50, v56, 3), (float32x4_t)vandq_s8((int8x16_t)v66, vbicq_s8((int8x16_t)vcgezq_f32(v66), v58)))), (int8x16_t)v56), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v73 = 0;
      while (1)
      {
        v74 = (int8x16_t *)((char *)result + v73);
        v75 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v76 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v77 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v76)), _Q5, *(int8x16_t *)((char *)&result[1] + v73));
        v78 = vmulq_f32(v75, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v73), v22), v25));
        v79 = vmulq_f32(v76, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v73), v22), v25));
        v80 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v75)), _Q5, *(int8x16_t *)((char *)result + v73));
        v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        v83 = (int8x16_t)vcgtzq_f32(v82);
        v84 = (int8x16_t)vcgtzq_f32(v81);
        v85 = (int8x16_t)vceqzq_f32(v82);
        v86 = (int8x16_t)vceqzq_f32(v81);
        v87 = vdivq_f32(v77, v82);
        v88 = vdivq_f32(v80, v81);
        v89 = vaddq_f32(v79, v79);
        v90 = vaddq_f32(v78, v78);
        v91 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v90, v88, v90), v88, v78, 3), v80);
        v92 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v89, v87, v89), v87, v79, 3), v77);
        *v74 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 3)), vbslq_s8(v84, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v78, v78, v80, 3), vaddq_f32(vmlsq_laneq_f32(v80, v80, v78, 3), (float32x4_t)vandq_s8((int8x16_t)v91, vbicq_s8((int8x16_t)vcgezq_f32(v91), v86)))), (int8x16_t)v78), (int8x16_t)v80);
        v74[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3)), vbslq_s8(v83, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v79, v79, v77, 3), vaddq_f32(vmlsq_laneq_f32(v77, v77, v79, 3), (float32x4_t)vandq_s8((int8x16_t)v92, vbicq_s8((int8x16_t)vcgezq_f32(v92), v85)))), (int8x16_t)v79), (int8x16_t)v77);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v73 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v73);
          a3 = (int8x16_t *)((char *)a3 + v73);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v73);
      a3 = (int8x16_t *)((char *)a3 + v30 + v73);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v95 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v94)), _Q5, *result);
          v96 = vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          v97 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3);
          v98 = (int8x16_t)vcgtzq_f32(v97);
          v99 = (int8x16_t)vceqzq_f32(v97);
          v100 = vdivq_f32(v95, v97);
          v101 = vaddq_f32(v96, v96);
          v102 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v101, v100, v101), v100, v96, 3), v95);
          *result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3)), vbslq_s8(v98, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v96, v96, v95, 3), vaddq_f32(vmlsq_laneq_f32(v95, v95, v96, 3), (float32x4_t)vandq_s8((int8x16_t)v102, vbicq_s8((int8x16_t)vcgezq_f32(v102), v99)))), (int8x16_t)v96), (int8x16_t)v95);
        }
        v103 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v103 >= a8)
          v104 = -(uint64_t)a7;
        else
          v104 = 0;
        a3 = &v103[v104];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v105 = &a5[a4];
      if ((unint64_t)v105 >= a9)
        v106 = v29;
      else
        v106 = 0;
      v107 = &v105[v106];
      v108 = a8 + 16 * v106 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v107;
        a8 = v108;
        a5 = v107;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v109.i64[0] = -1;
  v109.i64[1] = -1;
  v110 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v111 = (a8 - (unint64_t)a3) >> 4;
    if (v111 >= a12)
      v111 = a12;
    v112 = v111;
    if (v111 < 2)
      goto LABEL_93;
    while (1)
    {
      v113 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v137 = (int8x16_t *)&a10[v112];
        v138 = (int8x16_t *)a10;
        do
          v139 = v138++;
        while (v138 <= v137 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v139)) & 0x80) != 0);
        do
        {
          v140 = v139;
          v139 = (int8x16_t *)((char *)v139 + 4);
        }
        while (v139 <= v137 && !v140->i32[0]);
        if (v140 < v137)
        {
          while (!v140->i8[0])
          {
            v140 = (int8x16_t *)((char *)v140 + 1);
            if (v140 >= v137)
            {
              v140 = (int8x16_t *)&a10[v112];
              break;
            }
          }
        }
        v141 = (char *)v140 - a10;
        v142 = ((char *)v140 - a10) * a14;
        a3 += v142;
        result += v142;
        a10 += v142;
        v112 -= v141;
        goto LABEL_90;
      }
      if (v113 != 0xFFFF)
        break;
      v114 = (int8x16_t *)&a10[v112];
      v115 = (int8x16_t *)a10;
      do
        v116 = v115++;
      while (v115 <= v114 && (vminvq_u8((uint8x16_t)vceqq_s8(*v116, v109)) & 0x80) != 0);
      do
      {
        v117 = v116;
        v116 = (int8x16_t *)((char *)v116 + 4);
      }
      while (v116 <= v114 && v117->i32[0] == -1);
      if (v117 < v114)
      {
        while (v117->u8[0] == 255)
        {
          v117 = (int8x16_t *)((char *)v117 + 1);
          if (v117 >= v114)
          {
            v117 = (int8x16_t *)&a10[v112];
            break;
          }
        }
      }
      v118 = 0;
      v119 = (char *)v117 - a10;
      v120 = (char *)v117 - a10;
      do
      {
        v121 = (int8x16_t *)((char *)result + v118);
        v122 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v118)), v26), v27);
        v123 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v122, 3);
        v124 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v118)), v26), v27);
        v125 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3);
        v126 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v118)), v22), v25);
        v127 = (int8x16_t)vcgtzq_f32(v123);
        v128 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v118)), v22), v25);
        v129 = (int8x16_t)vceqzq_f32(v123);
        v130 = vdivq_f32(v124, v125);
        v131 = vdivq_f32(v122, v123);
        v132 = vaddq_f32(v126, v126);
        v133 = vaddq_f32(v128, v128);
        v134 = vmlaq_laneq_f32(vmlsq_f32(v133, v131, v133), v131, v128, 3);
        v135 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v132, v130, v132), v130, v126, 3), v124);
        v136 = vmulq_f32(v134, v122);
        *v121 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3)), vbslq_s8(v127, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v128, v128, v122, 3), vaddq_f32(vmlsq_laneq_f32(v122, v122, v128, 3), (float32x4_t)vandq_s8((int8x16_t)v136, vbicq_s8((int8x16_t)vcgezq_f32(v136), v129)))), (int8x16_t)v128), (int8x16_t)v122));
        v121[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v126, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(v125), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v126, v126, v124, 3), vaddq_f32(vmlsq_laneq_f32(v124, v124, v126, 3), (float32x4_t)vandq_s8((int8x16_t)v135, vbicq_s8((int8x16_t)vcgezq_f32(v135), (int8x16_t)vceqzq_f32(v125))))), (int8x16_t)v126), (int8x16_t)v124));
        a10 += v28;
        v120 -= 2;
        v118 += v30;
      }
      while (v120 > 1);
      a3 = (int8x16_t *)((char *)a3 + v118);
      result = (int8x16_t *)((char *)result + v118);
      v112 = v112 - v119 + v120;
LABEL_90:
      if (v112 <= 1)
        goto LABEL_93;
    }
    v143 = 0;
    while (1)
    {
      v144 = (int8x16_t *)((char *)result + v143);
      v145 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v113)) & 0xFF00FF00FF00FFLL))), v110);
      v146 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v113) & 0xFF00FF00FF00FFLL))), v110);
      v147 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v145)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v143)));
      v148 = vmulq_f32(v145, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v143)), v22), v25));
      v149 = vmulq_f32(v146, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v143)), v22), v25));
      v150 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v147, 3);
      v151 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v146)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v143)));
      v152 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v151, 3);
      v153 = (int8x16_t)vcgtzq_f32(v152);
      v154 = (int8x16_t)vcgtzq_f32(v150);
      v155 = (int8x16_t)vceqzq_f32(v152);
      v156 = (int8x16_t)vceqzq_f32(v150);
      v157 = vdivq_f32(v147, v150);
      v158 = vdivq_f32(v151, v152);
      v159 = vaddq_f32(v148, v148);
      v160 = vaddq_f32(v149, v149);
      v161 = vmlaq_laneq_f32(vmlsq_f32(v160, v158, v160), v158, v149, 3);
      v162 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v159, v157, v159), v157, v148, 3), v147);
      v163 = vmulq_f32(v161, v151);
      *v144 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v149, 3)), vbslq_s8(v153, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v149, v149, v151, 3), vaddq_f32(vmlsq_laneq_f32(v151, v151, v149, 3), (float32x4_t)vandq_s8((int8x16_t)v163, vbicq_s8((int8x16_t)vcgezq_f32(v163), v155)))), (int8x16_t)v149), (int8x16_t)v151));
      v144[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v148, 3)), vbslq_s8(v154, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v148, v148, v147, 3), vaddq_f32(vmlsq_laneq_f32(v147, v147, v148, 3), (float32x4_t)vandq_s8((int8x16_t)v162, vbicq_s8((int8x16_t)vcgezq_f32(v162), v156)))), (int8x16_t)v148), (int8x16_t)v147));
      a10 += v28;
      v112 -= 2;
      if (v112 < 2)
        break;
      LOWORD(v113) = *(_WORD *)a10;
      v143 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v143);
        a3 = (int8x16_t *)((char *)a3 + v143);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v143);
    a3 = (int8x16_t *)((char *)a3 + v30 + v143);
LABEL_93:
    for (j = a12 - v111 + v112; j; --j)
    {
      if (*a10)
      {
        v165 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v110);
        v166 = vmulq_f32(v165, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v167 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v165)), _Q5, vrev32q_s8(*result));
        v168 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v167, 3);
        v169 = (int8x16_t)vcgtzq_f32(v168);
        v170 = (int8x16_t)vceqzq_f32(v168);
        v171 = vdivq_f32(v167, v168);
        v172 = vaddq_f32(v166, v166);
        v173 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v172, v171, v172), v171, v166, 3), v167);
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v166, 3)), vbslq_s8(v169, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v166, v166, v167, 3), vaddq_f32(vmlsq_laneq_f32(v167, v167, v166, 3), (float32x4_t)vandq_s8((int8x16_t)v173, vbicq_s8((int8x16_t)vcgezq_f32(v173), v170)))), (int8x16_t)v166), (int8x16_t)v167));
      }
      v174 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v174 >= a8)
        v175 = -(uint64_t)a7;
      else
        v175 = 0;
      a3 = &v174[v175];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v176 = &a5[a4];
    if ((unint64_t)v176 >= a9)
      v177 = v29;
    else
      v177 = 0;
    v178 = &v176[v177];
    v179 = a8 + 16 * v177 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v178;
      a8 = v179;
      a5 = v178;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)22,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t *v60;
  int8x16_t *v61;
  int8x16_t *v62;
  int8x16_t *v63;
  int64_t v64;
  int64_t v65;
  uint64_t v66;
  int8x16_t *v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  unint64_t i;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int8x16_t v86;
  int8x16_t *v87;
  uint64_t v88;
  int8x16_t *v89;
  uint64_t v90;
  int8x16_t *v91;
  uint64_t v92;
  int8x16_t v93;
  float32x4_t v94;
  unint64_t v95;
  unint64_t v96;
  int v97;
  int8x16_t *v98;
  int8x16_t *v99;
  int8x16_t *v100;
  int8x16_t *v101;
  uint64_t v102;
  int64_t v103;
  unint64_t v104;
  int8x16_t *v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  int8x16_t v114;
  int8x16_t v115;
  int8x16_t *v116;
  int8x16_t *v117;
  int8x16_t *v118;
  int8x16_t *v119;
  int64_t v120;
  int64_t v121;
  uint64_t v122;
  int8x16_t *v123;
  float32x4_t v124;
  float32x4_t v125;
  int8x16_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  int8x16_t v135;
  int8x16_t v136;
  unint64_t j;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  int8x16_t v143;
  int8x16_t *v144;
  uint64_t v145;
  int8x16_t *v146;
  uint64_t v147;
  int8x16_t *v148;
  uint64_t v149;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v60 = (int8x16_t *)&a10[v40];
          v61 = (int8x16_t *)a10;
          do
            v62 = v61++;
          while (v61 <= v60 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v62)) & 0x80) != 0);
          do
          {
            v63 = v62;
            v62 = (int8x16_t *)((char *)v62 + 4);
          }
          while (v62 <= v60 && !v63->i32[0]);
          if (v63 < v60)
          {
            while (!v63->i8[0])
            {
              v63 = (int8x16_t *)((char *)v63 + 1);
              if (v63 >= v60)
              {
                v63 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v64 = (char *)v63 - a10;
          v65 = ((char *)v63 - a10) * a14;
          a3 += v65;
          result += v65;
          a10 += v65;
          v40 -= v64;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          v56 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3);
          v58 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v52, v52, v53, 3), vmlsq_laneq_f32(v53, v53, v52, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v52, v53, 3), vmulq_laneq_f32(v53, v52, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
          v59 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v50, v50, v56, 3), vmlsq_laneq_f32(v56, v56, v50, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v50, v56, 3), vmulq_laneq_f32(v56, v50, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
          v59.i32[3] = vaddq_f32(v56, vmlsq_laneq_f32(v51, v57, v50, 3)).i32[3];
          v58.i32[3] = vaddq_f32(v53, vmlsq_laneq_f32(v54, v55, v52, 3)).i32[3];
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32(v55), vbslq_s8((int8x16_t)vcgtzq_f32(v54), v58, (int8x16_t)v53), (int8x16_t)v52);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v57), vbslq_s8((int8x16_t)vcgtzq_f32(v51), v59, (int8x16_t)v56), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v66 = 0;
      while (1)
      {
        v67 = (int8x16_t *)((char *)result + v66);
        v68 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *(int8x16_t *)((char *)&result[1] + v66));
        v71 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v68)), _Q5, *(int8x16_t *)((char *)result + v66));
        v72 = vmulq_f32(v68, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v66), v22), v25));
        v73 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v66), v22), v25));
        v74 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3);
        v75 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3);
        v76 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3);
        v77 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3);
        v78 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v71, v71, v72, 3), vmlsq_laneq_f32(v72, v72, v71, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v71, v72, 3), vmulq_laneq_f32(v72, v71, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        v79 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v70, v70, v73, 3), vmlsq_laneq_f32(v73, v73, v70, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v70, v73, 3), vmulq_laneq_f32(v73, v70, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        v79.i32[3] = vaddq_f32(v73, vmlsq_laneq_f32(v77, v74, v70, 3)).i32[3];
        v78.i32[3] = vaddq_f32(v72, vmlsq_laneq_f32(v76, v75, v71, 3)).i32[3];
        *v67 = vbslq_s8((int8x16_t)vcgtzq_f32(v75), vbslq_s8((int8x16_t)vcgtzq_f32(v76), v78, (int8x16_t)v72), (int8x16_t)v71);
        v67[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v74), vbslq_s8((int8x16_t)vcgtzq_f32(v77), v79, (int8x16_t)v73), (int8x16_t)v70);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v66 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v66);
          a3 = (int8x16_t *)((char *)a3 + v66);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v66);
      a3 = (int8x16_t *)((char *)a3 + v30 + v66);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v81 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v82 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v81)), _Q5, *result);
          v83 = vmulq_f32(v81, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          v84 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 3);
          v85 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v82, 3);
          v86 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v83, v83, v82, 3), vmlsq_laneq_f32(v82, v82, v83, 3)), vabdq_f32(vmulq_laneq_f32(v82, v83, 3), vmulq_laneq_f32(v83, v82, 3)));
          v86.i32[3] = vaddq_f32(v83, vmlsq_laneq_f32(v85, v84, v82, 3)).i32[3];
          *result = vbslq_s8((int8x16_t)vcgtzq_f32(v84), vbslq_s8((int8x16_t)vcgtzq_f32(v85), v86, (int8x16_t)v83), (int8x16_t)v82);
        }
        v87 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v87 >= a8)
          v88 = -(uint64_t)a7;
        else
          v88 = 0;
        a3 = &v87[v88];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v89 = &a5[a4];
      if ((unint64_t)v89 >= a9)
        v90 = v29;
      else
        v90 = 0;
      v91 = &v89[v90];
      v92 = a8 + 16 * v90 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v91;
        a8 = v92;
        a5 = v91;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v93.i64[0] = -1;
  v93.i64[1] = -1;
  v94 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v95 = (a8 - (unint64_t)a3) >> 4;
    if (v95 >= a12)
      v95 = a12;
    v96 = v95;
    if (v95 < 2)
      goto LABEL_93;
    while (1)
    {
      v97 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v116 = (int8x16_t *)&a10[v96];
        v117 = (int8x16_t *)a10;
        do
          v118 = v117++;
        while (v117 <= v116 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v118)) & 0x80) != 0);
        do
        {
          v119 = v118;
          v118 = (int8x16_t *)((char *)v118 + 4);
        }
        while (v118 <= v116 && !v119->i32[0]);
        if (v119 < v116)
        {
          while (!v119->i8[0])
          {
            v119 = (int8x16_t *)((char *)v119 + 1);
            if (v119 >= v116)
            {
              v119 = (int8x16_t *)&a10[v96];
              break;
            }
          }
        }
        v120 = (char *)v119 - a10;
        v121 = ((char *)v119 - a10) * a14;
        a3 += v121;
        result += v121;
        a10 += v121;
        v96 -= v120;
        goto LABEL_90;
      }
      if (v97 != 0xFFFF)
        break;
      v98 = (int8x16_t *)&a10[v96];
      v99 = (int8x16_t *)a10;
      do
        v100 = v99++;
      while (v99 <= v98 && (vminvq_u8((uint8x16_t)vceqq_s8(*v100, v93)) & 0x80) != 0);
      do
      {
        v101 = v100;
        v100 = (int8x16_t *)((char *)v100 + 4);
      }
      while (v100 <= v98 && v101->i32[0] == -1);
      if (v101 < v98)
      {
        while (v101->u8[0] == 255)
        {
          v101 = (int8x16_t *)((char *)v101 + 1);
          if (v101 >= v98)
          {
            v101 = (int8x16_t *)&a10[v96];
            break;
          }
        }
      }
      v102 = 0;
      v103 = (char *)v101 - a10;
      v104 = (char *)v101 - a10;
      do
      {
        v105 = (int8x16_t *)((char *)result + v102);
        v106 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v102)), v26), v27);
        v107 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v102)), v26), v27);
        v108 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3);
        v109 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3);
        v110 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v102)), v22), v25);
        v111 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 3);
        v112 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v102)), v22), v25);
        v113 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3);
        v114 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v107, v107, v110, 3), vmlsq_laneq_f32(v110, v110, v107, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v107, v110, 3), vmulq_laneq_f32(v110, v107, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        v115 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v106, v106, v112, 3), vmlsq_laneq_f32(v112, v112, v106, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v106, v112, 3), vmulq_laneq_f32(v112, v106, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
        v115.i32[3] = vaddq_f32(v112, vmlsq_laneq_f32(v108, v113, v106, 3)).i32[3];
        v114.i32[3] = vaddq_f32(v110, vmlsq_laneq_f32(v109, v111, v107, 3)).i32[3];
        *v105 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v113), vbslq_s8((int8x16_t)vcgtzq_f32(v108), v115, (int8x16_t)v112), (int8x16_t)v106));
        v105[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v111), vbslq_s8((int8x16_t)vcgtzq_f32(v109), v114, (int8x16_t)v110), (int8x16_t)v107));
        a10 += v28;
        v104 -= 2;
        v102 += v30;
      }
      while (v104 > 1);
      a3 = (int8x16_t *)((char *)a3 + v102);
      result = (int8x16_t *)((char *)result + v102);
      v96 = v96 - v103 + v104;
LABEL_90:
      if (v96 <= 1)
        goto LABEL_93;
    }
    v122 = 0;
    while (1)
    {
      v123 = (int8x16_t *)((char *)result + v122);
      v124 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v97)) & 0xFF00FF00FF00FFLL))), v94);
      v125 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v97) & 0xFF00FF00FF00FFLL))), v94);
      v126 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v124));
      v127 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v125)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v122)));
      v128 = vmulq_f32(v124, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v122)), v22), v25));
      v129 = vmulq_f32(v125, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v122)), v22), v25));
      v130 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v129, 3);
      v131 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3);
      v132 = (float32x4_t)vbslq_s8(v126, _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v122)));
      v133 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v132, 3);
      v134 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v127, 3);
      v135 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v132, v132, v128, 3), vmlsq_laneq_f32(v128, v128, v132, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v132, v128, 3), vmulq_laneq_f32(v128, v132, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
      v136 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v127, v127, v129, 3), vmlsq_laneq_f32(v129, v129, v127, 3)), (float32x4_t)(*(_OWORD *)&vsubq_f32(vmulq_laneq_f32(v127, v129, 3), vmulq_laneq_f32(v129, v127, 3)) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)));
      v136.i32[3] = vaddq_f32(v129, vmlsq_laneq_f32(v134, v130, v127, 3)).i32[3];
      v135.i32[3] = vaddq_f32(v128, vmlsq_laneq_f32(v133, v131, v132, 3)).i32[3];
      *v123 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v130), vbslq_s8((int8x16_t)vcgtzq_f32(v134), v136, (int8x16_t)v129), (int8x16_t)v127));
      v123[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v131), vbslq_s8((int8x16_t)vcgtzq_f32(v133), v135, (int8x16_t)v128), (int8x16_t)v132));
      a10 += v28;
      v96 -= 2;
      if (v96 < 2)
        break;
      LOWORD(v97) = *(_WORD *)a10;
      v122 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v122);
        a3 = (int8x16_t *)((char *)a3 + v122);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v122);
    a3 = (int8x16_t *)((char *)a3 + v30 + v122);
LABEL_93:
    for (j = a12 - v95 + v96; j; --j)
    {
      if (*a10)
      {
        v138 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v94);
        v139 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v138)), _Q5, vrev32q_s8(*result));
        v140 = vmulq_f32(v138, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v141 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
        v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3);
        v143 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v140, v140, v139, 3), vmlsq_laneq_f32(v139, v139, v140, 3)), vabdq_f32(vmulq_laneq_f32(v139, v140, 3), vmulq_laneq_f32(v140, v139, 3)));
        v143.i32[3] = vaddq_f32(v140, vmlsq_laneq_f32(v142, v141, v139, 3)).i32[3];
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v141), vbslq_s8((int8x16_t)vcgtzq_f32(v142), v143, (int8x16_t)v140), (int8x16_t)v139));
      }
      v144 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v144 >= a8)
        v145 = -(uint64_t)a7;
      else
        v145 = 0;
      a3 = &v144[v145];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v146 = &a5[a4];
    if ((unint64_t)v146 >= a9)
      v147 = v29;
    else
      v147 = 0;
    v148 = &v146[v147];
    v149 = a8 + 16 * v147 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v148;
      a8 = v149;
      a5 = v148;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)23,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  unsigned int v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  unsigned int v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t v37;
  float32x4_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t *v44;
  int8x16_t *v45;
  uint64_t v46;
  int64_t v47;
  unint64_t v48;
  int8x16_t *v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int8x16_t *v58;
  int8x16_t *v59;
  int64_t v60;
  int64_t v61;
  uint64_t v62;
  int8x16_t *v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  unint64_t i;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t *v77;
  uint64_t v78;
  int8x16_t *v79;
  uint64_t v80;
  int8x16_t *v81;
  uint64_t v82;
  int8x16_t v83;
  float32x4_t v84;
  unint64_t v85;
  unint64_t v86;
  int v87;
  int8x16_t *v88;
  int8x16_t *v89;
  int8x16_t *v90;
  int8x16_t *v91;
  uint64_t v92;
  int64_t v93;
  unint64_t v94;
  int8x16_t *v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  int8x16_t *v102;
  int8x16_t *v103;
  int8x16_t *v104;
  int8x16_t *v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  int8x16_t *v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  unint64_t j;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  int8x16_t *v123;
  uint64_t v124;
  int8x16_t *v125;
  uint64_t v126;
  int8x16_t *v127;
  uint64_t v128;

  if (a16)
    v19 = 0;
  else
    v19 = -1;
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  v22 = vmvnq_s8(v20);
  v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15)
    v24 = 0;
  else
    v24 = -1;
  v21.i32[3] = v24;
  v25 = vandq_s8(v23, (int8x16_t)xmmword_185004D50);
  v26 = vmvnq_s8(v21);
  v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_185004D50);
  v28 = 2 * a14;
  v29 = -(a6 * a4);
  v30 = 32 * a14;
  v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12)
        v39 = a12;
      v40 = v39;
      if (v39 < 2)
        goto LABEL_43;
      while (1)
      {
        v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          v56 = (int8x16_t *)&a10[v40];
          v57 = (int8x16_t *)a10;
          do
            v58 = v57++;
          while (v57 <= v56 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v58)) & 0x80) != 0);
          do
          {
            v59 = v58;
            v58 = (int8x16_t *)((char *)v58 + 4);
          }
          while (v58 <= v56 && !v59->i32[0]);
          if (v59 < v56)
          {
            while (!v59->i8[0])
            {
              v59 = (int8x16_t *)((char *)v59 + 1);
              if (v59 >= v56)
              {
                v59 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          v60 = (char *)v59 - a10;
          v61 = ((char *)v59 - a10) * a14;
          a3 += v61;
          result += v61;
          a10 += v61;
          v40 -= v60;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF)
          break;
        v42 = (int8x16_t *)&a10[v40];
        v43 = (int8x16_t *)a10;
        do
          v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          v45 = v44;
          v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        v46 = 0;
        v47 = (char *)v45 - a10;
        v48 = (char *)v45 - a10;
        do
        {
          v49 = (int8x16_t *)((char *)result + v46);
          v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          v54 = vmlsq_f32(v51, v52, v51);
          v55 = vmlsq_f32(v50, v53, v50);
          v54.i32[3] = v51.i32[3];
          v55.i32[3] = v50.i32[3];
          *v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v52, v51, v52), v54), (int8x16_t)v51), (int8x16_t)v52);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v53, v50, v53), v55), (int8x16_t)v50), (int8x16_t)v53);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        result = (int8x16_t *)((char *)result + v46);
        v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1)
          goto LABEL_43;
      }
      v62 = 0;
      while (1)
      {
        v63 = (int8x16_t *)((char *)result + v62);
        v64 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        v65 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        v66 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v64)), _Q5, *(int8x16_t *)((char *)result + v62));
        v67 = vmulq_f32(v64, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v62), v22), v25));
        v68 = vmulq_f32(v65, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v62), v22), v25));
        v69 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v65)), _Q5, *(int8x16_t *)((char *)&result[1] + v62));
        v70 = vmlsq_f32(v67, v66, v67);
        v71 = vmlsq_f32(v68, v69, v68);
        v70.i32[3] = v67.i32[3];
        v71.i32[3] = v68.i32[3];
        *v63 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), (int8x16_t)vaddq_f32(v70, vmlsq_f32(v66, v67, v66)), (int8x16_t)v67), (int8x16_t)v66);
        v63[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3)), (int8x16_t)vaddq_f32(v71, vmlsq_f32(v69, v68, v69)), (int8x16_t)v68), (int8x16_t)v69);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2)
          break;
        LOWORD(v41) = *(_WORD *)a10;
        v62 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          result = (int8x16_t *)((char *)result + v62);
          a3 = (int8x16_t *)((char *)a3 + v62);
          goto LABEL_40;
        }
      }
      result = (int8x16_t *)((char *)result + v30 + v62);
      a3 = (int8x16_t *)((char *)a3 + v30 + v62);
LABEL_43:
      for (i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          v73 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          v74 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v73)), _Q5, *result);
          v75 = vmulq_f32(v73, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          v76 = vmlsq_f32(v75, v74, v75);
          v76.i32[3] = v75.i32[3];
          *result = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v75)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v74)), 3)), (int8x16_t)vaddq_f32(v76, vmlsq_f32(v74, v75, v74)), (int8x16_t)v75), (int8x16_t)v74);
        }
        v77 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v77 >= a8)
          v78 = -(uint64_t)a7;
        else
          v78 = 0;
        a3 = &v77[v78];
        result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      v79 = &a5[a4];
      if ((unint64_t)v79 >= a9)
        v80 = v29;
      else
        v80 = 0;
      v81 = &v79[v80];
      v82 = a8 + 16 * v80 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v81;
        a8 = v82;
        a5 = v81;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0))
        return result;
    }
  }
  v83.i64[0] = -1;
  v83.i64[1] = -1;
  v84 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    v85 = (a8 - (unint64_t)a3) >> 4;
    if (v85 >= a12)
      v85 = a12;
    v86 = v85;
    if (v85 < 2)
      goto LABEL_93;
    while (1)
    {
      v87 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        v102 = (int8x16_t *)&a10[v86];
        v103 = (int8x16_t *)a10;
        do
          v104 = v103++;
        while (v103 <= v102 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v104)) & 0x80) != 0);
        do
        {
          v105 = v104;
          v104 = (int8x16_t *)((char *)v104 + 4);
        }
        while (v104 <= v102 && !v105->i32[0]);
        if (v105 < v102)
        {
          while (!v105->i8[0])
          {
            v105 = (int8x16_t *)((char *)v105 + 1);
            if (v105 >= v102)
            {
              v105 = (int8x16_t *)&a10[v86];
              break;
            }
          }
        }
        v106 = (char *)v105 - a10;
        v107 = ((char *)v105 - a10) * a14;
        a3 += v107;
        result += v107;
        a10 += v107;
        v86 -= v106;
        goto LABEL_90;
      }
      if (v87 != 0xFFFF)
        break;
      v88 = (int8x16_t *)&a10[v86];
      v89 = (int8x16_t *)a10;
      do
        v90 = v89++;
      while (v89 <= v88 && (vminvq_u8((uint8x16_t)vceqq_s8(*v90, v83)) & 0x80) != 0);
      do
      {
        v91 = v90;
        v90 = (int8x16_t *)((char *)v90 + 4);
      }
      while (v90 <= v88 && v91->i32[0] == -1);
      if (v91 < v88)
      {
        while (v91->u8[0] == 255)
        {
          v91 = (int8x16_t *)((char *)v91 + 1);
          if (v91 >= v88)
          {
            v91 = (int8x16_t *)&a10[v86];
            break;
          }
        }
      }
      v92 = 0;
      v93 = (char *)v91 - a10;
      v94 = (char *)v91 - a10;
      do
      {
        v95 = (int8x16_t *)((char *)result + v92);
        v96 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v92)), v22), v25);
        v97 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v92)), v22), v25);
        v98 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v92)), v26), v27);
        v99 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v92)), v26), v27);
        v100 = vmlsq_f32(v96, v99, v96);
        v101 = vmlsq_f32(v97, v98, v97);
        v101.i32[3] = v97.i32[3];
        v100.i32[3] = v96.i32[3];
        *v95 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v99, v96, v99), v100), (int8x16_t)v96), (int8x16_t)v99));
        v95[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v98, v97, v98), v101), (int8x16_t)v97), (int8x16_t)v98));
        a10 += v28;
        v94 -= 2;
        v92 += v30;
      }
      while (v94 > 1);
      a3 = (int8x16_t *)((char *)a3 + v92);
      result = (int8x16_t *)((char *)result + v92);
      v86 = v86 - v93 + v94;
LABEL_90:
      if (v86 <= 1)
        goto LABEL_93;
    }
    v108 = 0;
    while (1)
    {
      v109 = (int8x16_t *)((char *)result + v108);
      v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(BYTE1(v87)) & 0xFF00FF00FF00FFLL))), v84);
      v111 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v87) & 0xFF00FF00FF00FFLL))), v84);
      v112 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v111)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v108)));
      v113 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v108)));
      v114 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v108)), v22), v25));
      v115 = vmulq_f32(v111, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v108)), v22), v25));
      v116 = vmlsq_f32(v115, v112, v115);
      v117 = vmlsq_f32(v114, v113, v114);
      v117.i32[3] = v114.i32[3];
      v116.i32[3] = v115.i32[3];
      *v109 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v115, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), (int8x16_t)vaddq_f32(v116, vmlsq_f32(v112, v115, v112)), (int8x16_t)v115), (int8x16_t)v112));
      v109[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 3)), (int8x16_t)vaddq_f32(v117, vmlsq_f32(v113, v114, v113)), (int8x16_t)v114), (int8x16_t)v113));
      a10 += v28;
      v86 -= 2;
      if (v86 < 2)
        break;
      LOWORD(v87) = *(_WORD *)a10;
      v108 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        result = (int8x16_t *)((char *)result + v108);
        a3 = (int8x16_t *)((char *)a3 + v108);
        goto LABEL_90;
      }
    }
    result = (int8x16_t *)((char *)result + v30 + v108);
    a3 = (int8x16_t *)((char *)a3 + v30 + v108);
LABEL_93:
    for (j = a12 - v85 + v86; j; --j)
    {
      if (*a10)
      {
        v119 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v84);
        v120 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v119)), _Q5, vrev32q_s8(*result));
        v121 = vmulq_f32(v119, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        v122 = vmlsq_f32(v121, v120, v121);
        v122.i32[3] = v121.i32[3];
        *result = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v121)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v120)), 3)), (int8x16_t)vaddq_f32(v122, vmlsq_f32(v120, v121, v120)), (int8x16_t)v121), (int8x16_t)v120));
      }
      v123 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v123 >= a8)
        v124 = -(uint64_t)a7;
      else
        v124 = 0;
      a3 = &v123[v124];
      result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    v125 = &a5[a4];
    if ((unint64_t)v125 >= a9)
      v126 = v29;
    else
      v126 = 0;
    v127 = &v125[v126];
    v128 = a8 + 16 * v126 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v127;
      a8 = v128;
      a5 = v127;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0)))
      continue;
    return result;
  }
}

uint64_t RGBAf_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL4 v7;
  signed int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  int *v23;
  int v24;
  unint64_t v25;
  void (*v26)(uint64_t, _DWORD *);
  uint64_t v27;
  int v28;
  int v29;
  uint64_t (*v30)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double);
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  _OWORD v36[64];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  memset(v36, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*(_QWORD *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v30, (uint64_t)v36) < 1)
    return 0xFFFFFFFFLL;
  v18 = *(_DWORD *)v6;
  v19 = *(_DWORD *)a3;
  v31 = v19;
  v32 = v18;
  if (v19 != 538981289)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      v23 = RGBF_image_sample;
      v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGBF_image_sample[2 * v20 + 2];
      if (v30)
      {
LABEL_29:
        v31 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v34 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v25) = v22;
          LODWORD(v25) = v22;
          switch((v25 >> 3))
          {
            case 0u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAf_image_mark_RGB32;
              goto LABEL_52;
            case 1u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAf_image_mark_RGB32;
              goto LABEL_54;
            case 2u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAf_image_mark_W8;
              goto LABEL_52;
            case 3u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAf_image_mark_RGB24;
              goto LABEL_52;
            case 4u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAf_image_mark_rgb32;
LABEL_52:
              v27 = (uint64_t)a2;
              v28 = v8;
              v29 = 0;
              break;
            case 5u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAf_image_mark_rgb32;
LABEL_54:
              v27 = (uint64_t)a2;
              v28 = v8;
              v29 = 8;
              break;
            default:
              goto LABEL_37;
          }
          RGBAf_image_mark_image(v27, (uint64_t)&v30, v28, v29, v26);
          return 1;
        }
        goto LABEL_37;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v23 = RGB8_image_sample;
        v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB8_image_sample[2 * v20 + 2];
        if (v30)
        {
          v24 = 4;
LABEL_28:
          v33 = v24;
          goto LABEL_29;
        }
      }
      v23 = RGB16_image_sample;
      v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB16_image_sample[2 * v20 + 2];
      if (v30)
      {
        v24 = 8;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v35 && (~v34 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((v34 & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      RGBAf_mark_inner(*a1, v17);
      return 1;
    }
  }
  v30 = RGBAf_sample_RGBAf_inner;
LABEL_37:
  RGBAf_image_mark((uint64_t)a2, (uint64_t)&v30, v8, v17);
  return 1;
}

uint64_t RGBAf_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9, double a10, int32x4_t a11)
{
  float v11;
  float v12;
  float32x4_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t result;
  float v24;
  unint64_t v30;
  uint64_t v31;
  int v32;
  unsigned __int8 *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  unsigned int v40;
  char v41;
  unsigned __int8 *v42;
  unsigned int v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  unsigned __int8 *v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned __int8 *v52;
  int v53;
  float32_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  unsigned int v61;
  char v62;
  unsigned __int8 *v63;
  unsigned int v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  unsigned int v67;
  unsigned __int8 *v68;
  int v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned __int8 *v73;
  int v74;
  float32x2_t v75;
  float32x4_t v76;
  uint64_t *v77;
  float v78;
  unsigned __int8 *v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned __int8 *v84;
  float32_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  unsigned __int8 *v89;
  float32x2_t v90;
  float32x4_t v91;
  uint64_t v92;

  v11 = *((float *)a2 + 2);
  v12 = *(float *)a2;
  v13 = (float32x4_t *)*((_QWORD *)a2 + 2);
  v14 = *((_QWORD *)a2 + 3) - a5;
  v16 = *((_QWORD *)a2 + 15);
  v15 = *((_QWORD *)a2 + 16);
  v17 = *((_QWORD *)a2 + 7);
  v18 = *((_QWORD *)a2 + 9);
  v19 = *((_QWORD *)a2 + 5) + v18 * a4;
  v20 = *(unsigned __int8 **)(a1 + 32);
  v21 = &v20[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  if (*(_QWORD *)(a1 + 176))
  {
    v22 = *((_QWORD *)a2 + 11);
    result = *((_QWORD *)a2 + 13);
    v24 = fminf(v11, 1.0);
    v92 = v15 + 16 * a3 + 8;
    __asm { FMOV            V2.2S, #1.0 }
    while (1)
    {
      if (((result - v19) | (v19 - v22)) < 0)
      {
        v32 = 0;
        v31 = 0;
      }
      else
      {
        v30 = ((v19 & (unint64_t)~(-1 << v17)) >> (v17 - 4)) & 0xF;
        v31 = v30 - 7 >= 9 ? -v16 : v16;
        v32 = weights_19497[v30] & 0xF;
      }
      v33 = &v20[(v19 >> v17) * v16];
      if (LODWORD(v12) != 1)
        break;
      if (a5 >= 1)
      {
        v34 = (uint64_t *)v92;
        v35 = a5;
        while (1)
        {
          v36 = *(v34 - 1);
          v37 = *v34;
          v38 = &v33[v36];
          if (v21 >= &v33[v36])
            v39 = &v33[v36];
          else
            v39 = v21;
          if (v20 > v39)
            v39 = v20;
          v40 = *v39;
          v41 = v37 & 0xF;
          if ((v37 & 0xF) != 0)
            break;
          if (v32)
          {
            v52 = &v38[v31];
            if (v21 < &v38[v31])
              v52 = v21;
            if (v20 > v52)
              v52 = v20;
            v53 = BLEND8_19499[v32];
            v50 = v40 - ((v53 & v40) >> v32);
            v51 = (v53 & *v52) >> v32;
            goto LABEL_40;
          }
LABEL_41:
          v34 += 2;
          v54 = *(float *)&_blt_float[v40] * v24;
          v13->f32[0] = v54;
          v13->f32[1] = v54;
          v13->f32[2] = v54;
          v13->f32[3] = v24;
          ++v13;
          if (!--v35)
            goto LABEL_79;
        }
        v42 = &v38[v37 >> 4];
        if (v21 < v42)
          v42 = v21;
        if (v20 > v42)
          v42 = v20;
        v43 = *v42;
        if (v32)
        {
          v44 = &v38[v31];
          if (v21 >= v44)
            v45 = v44;
          else
            v45 = v21;
          if (v20 > v45)
            v45 = v20;
          v46 = *v45;
          v47 = &v44[v37 >> 4];
          if (v21 < v47)
            v47 = v21;
          if (v20 > v47)
            v47 = v20;
          v48 = BLEND8_19499[v32];
          v40 = v40 - ((v48 & v40) >> v32) + ((v48 & v46) >> v32);
          v43 = v43 - ((v48 & v43) >> v32) + ((v48 & *v47) >> v32);
        }
        v49 = BLEND8_19499[*v34 & 0xF];
        v50 = v40 - ((v49 & v40) >> v41);
        v51 = (v49 & v43) >> v41;
LABEL_40:
        LOBYTE(v40) = v50 + v51;
        goto LABEL_41;
      }
LABEL_79:
      v13 += v14;
      v19 += v18;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_79;
    v55 = (uint64_t *)v92;
    v56 = a5;
    while (1)
    {
      v57 = *(v55 - 1);
      v58 = *v55;
      v59 = &v33[v57];
      if (v21 >= &v33[v57])
        v60 = &v33[v57];
      else
        v60 = v21;
      if (v20 > v60)
        v60 = v20;
      v61 = *v60;
      v62 = v58 & 0xF;
      if ((v58 & 0xF) != 0)
      {
        v63 = &v59[v58 >> 4];
        if (v21 < v63)
          v63 = v21;
        if (v20 > v63)
          v63 = v20;
        v64 = *v63;
        if (v32)
        {
          v65 = &v59[v31];
          if (v21 >= v65)
            v66 = v65;
          else
            v66 = v21;
          if (v20 > v66)
            v66 = v20;
          v67 = *v66;
          v68 = &v65[v58 >> 4];
          if (v21 < v68)
            v68 = v21;
          if (v20 > v68)
            v68 = v20;
          v69 = BLEND8_19499[v32];
          v61 = v61 - ((v69 & v61) >> v32) + ((v69 & v67) >> v32);
          v64 = v64 - ((v69 & v64) >> v32) + ((v69 & *v68) >> v32);
        }
        v70 = BLEND8_19499[*v55 & 0xF];
        v71 = v61 - ((v70 & v61) >> v62);
        v72 = (v70 & v64) >> v62;
      }
      else
      {
        if (!v32)
          goto LABEL_74;
        v73 = &v59[v31];
        if (v21 < &v59[v31])
          v73 = v21;
        if (v20 > v73)
          v73 = v20;
        v74 = BLEND8_19499[v32];
        v71 = v61 - ((v74 & v61) >> v32);
        v72 = (v74 & *v73) >> v32;
      }
      LOBYTE(v61) = v71 + v72;
LABEL_74:
      v75.i32[1] = HIDWORD(_D2);
      v75.i32[0] = _blt_float[v61];
      *(float32x2_t *)a11.i8 = vmul_n_f32(v75, v24);
      v76 = (float32x4_t)vzip1q_s32(a11, a11);
      v76.i32[2] = a11.i32[0];
      if (*(float *)&a11.i32[1] >= 1.0)
        goto LABEL_77;
      if (*(float *)&a11.i32[1] > 0.0)
      {
        v76 = vmlaq_n_f32(v76, *v13, 1.0 - *(float *)&a11.i32[1]);
LABEL_77:
        *v13 = v76;
      }
      v55 += 2;
      ++v13;
      if (!--v56)
        goto LABEL_79;
    }
  }
  v77 = (uint64_t *)(v15 + 16 * a3);
  result = a5;
  v78 = fminf(v11, 1.0);
  __asm { FMOV            V2.2S, #1.0 }
  do
  {
    v80 = &v20[(v19 >> v17) * v16];
    if (LODWORD(v12) != 1)
    {
      v86 = v77;
      v87 = a5;
      if (a5 < 1)
        goto LABEL_101;
      while (1)
      {
        v88 = *v86;
        v86 += 2;
        v89 = &v80[v88];
        if (v21 < &v80[v88])
          v89 = v21;
        if (v20 > v89)
          v89 = v20;
        v90.i32[1] = HIDWORD(_D2);
        v90.i32[0] = _blt_float[*v89];
        *(float32x2_t *)a11.i8 = vmul_n_f32(v90, v78);
        v91 = (float32x4_t)vzip1q_s32(a11, a11);
        v91.i32[2] = a11.i32[0];
        if (*(float *)&a11.i32[1] >= 1.0)
          goto LABEL_99;
        if (*(float *)&a11.i32[1] > 0.0)
          break;
LABEL_100:
        ++v13;
        if (!--v87)
          goto LABEL_101;
      }
      v91 = vmlaq_n_f32(v91, *v13, 1.0 - *(float *)&a11.i32[1]);
LABEL_99:
      *v13 = v91;
      goto LABEL_100;
    }
    if (a5 >= 1)
    {
      v81 = v77;
      v82 = a5;
      do
      {
        v83 = *v81;
        v81 += 2;
        v84 = &v80[v83];
        if (v21 < &v80[v83])
          v84 = v21;
        if (v20 > v84)
          v84 = v20;
        v85 = *(float *)&_blt_float[*v84] * v78;
        v13->f32[0] = v85;
        v13->f32[1] = v85;
        v13->f32[2] = v85;
        v13->f32[3] = v78;
        ++v13;
        --v82;
      }
      while (v82);
    }
LABEL_101:
    v13 += v14;
    v19 += v18;
    --a6;
  }
  while (a6);
  return result;
}

void RGBAf_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  void *v39;
  int v40;
  int v41;
  int *v42;
  int v43;
  void *v44;
  void *v45;
  int v46;
  int v47;
  uint64_t v48;
  _DWORD v49[4];
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  int v65;
  int v66;
  int v67[4];

  v49[0] = a3;
  v49[1] = a4;
  v49[2] = *(_DWORD *)(a2 + 184);
  v8 = (unint64_t)*(int *)(a1 + 28) >> 4;
  v51 = v8;
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(_DWORD *)(a2 + 20);
  if (v9)
  {
    v11 = HIBYTE(v10);
    v12 = *(int *)(a2 + 24);
    v13 = (uint64_t *)(a2 + 104);
    v14 = (uint64_t *)(a2 + 72);
    v15 = (uint64_t *)(a2 + 88);
  }
  else
  {
    v11 = BYTE2(v10);
    v12 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v13 = (uint64_t *)(a2 + 96);
    v14 = (uint64_t *)(a2 + 64);
    v15 = (uint64_t *)(a2 + 80);
    v9 = *(_QWORD *)(a2 + 112);
  }
  v16 = *v15;
  v17 = *v14;
  v18 = *v13;
  v19 = v11;
  v54 = v11;
  v52 = v18;
  v62 = v12;
  v60 = v16;
  v58 = v17;
  v56 = v9;
  v20 = *(_QWORD *)(a2 + 128);
  v48 = v16;
  if (v20)
  {
    v21 = BYTE2(v10);
    v22 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v23 = (uint64_t *)(a2 + 96);
    v24 = (uint64_t *)(a2 + 64);
    v25 = (uint64_t *)(a2 + 80);
  }
  else
  {
    v21 = HIBYTE(v10);
    v22 = *(int *)(a2 + 24);
    v23 = (uint64_t *)(a2 + 104);
    v24 = (uint64_t *)(a2 + 72);
    v25 = (uint64_t *)(a2 + 88);
    v20 = *(_QWORD *)(a2 + 136);
  }
  v26 = *v25;
  v27 = *v24;
  v28 = *v23;
  v55 = v21;
  v53 = v28;
  v63 = v22;
  v61 = v26;
  v59 = v27;
  v57 = v20;
  v29 = *(unsigned int *)(a1 + 4);
  if ((v29 & 0x80000000) == 0)
  {
    v30 = malloc_type_malloc(16 * v29, 0xF23125EEuLL);
    v64 = v30;
    if (v30)
    {
      if (*(_QWORD *)(a2 + 176))
      {
        if ((_DWORD)v29)
        {
          v32 = v30 + 1;
          v33 = v48 - v18;
          do
          {
            if (((v18 - v17) | v33) < 0)
            {
              v36 = 0;
              v37 = 0;
            }
            else
            {
              v34 = ((v18 & (unint64_t)~(-1 << v19)) >> (v19 - 4)) & 0xF;
              v35 = weights_19497[v34];
              if (v34 - 7 >= 9)
                v36 = -(uint64_t)v12;
              else
                v36 = v12;
              v37 = v35 & 0xF;
            }
            *(v32 - 1) = v12 * (v18 >> v19);
            *v32 = v37 | (16 * v36);
            v32 += 2;
            v18 += v9;
            v33 -= v9;
            --v29;
          }
          while (v29);
        }
      }
      else if ((_DWORD)v29)
      {
        v38 = v30 + 1;
        do
        {
          *(v38 - 1) = v12 * (v18 >> v19);
          *v38 = 0;
          v38 += 2;
          v18 += v9;
          --v29;
        }
        while (v29);
      }
      v39 = v30;
      v40 = *(_DWORD *)(a1 + 4);
      v41 = *(_DWORD *)(a1 + 8);
      v65 = v41;
      v66 = v40;
      v42 = *(int **)(a1 + 136);
      if (v42)
      {
        v43 = *(_DWORD *)(a1 + 104);
        v67[0] = *(_DWORD *)(a1 + 108);
        v67[1] = v43;
        shape_enum_clip_alloc((uint64_t)v30, v31, v42, 1, 1, 1, v43, v67[0], v40, v41);
        v45 = v44;
        if (v44)
          goto LABEL_27;
      }
      v46 = 0;
      v47 = 0;
      v45 = 0;
      *(_QWORD *)v67 = 0;
      while (1)
      {
        v50 = *(_QWORD *)(a1 + 40) + 16 * v8 * (*(int *)(a1 + 16) + (uint64_t)v47) + 16 * (v46 + *(_DWORD *)(a1 + 12));
        a5(a2, v49);
        if (!v45)
          break;
LABEL_27:
        if (!shape_enum_clip_next((uint64_t)v45, &v67[1], v67, &v66, &v65))
        {
          free(v45);
          break;
        }
        v47 = v67[0];
        v46 = v67[1];
        v8 = v51;
      }
      free(v39);
    }
  }
}

_DWORD *RGBAf_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6;
  float v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  _DWORD *result;
  uint64_t v19;
  float v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  unsigned __int8 *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  unsigned int v38;
  unsigned __int8 *v39;
  float v40;
  float v41;
  float v42;
  float v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  unsigned __int8 *v49;
  unsigned int v50;
  unsigned __int8 *v51;
  int v52;
  unsigned __int8 *v53;
  int v54;
  unsigned __int8 *v55;
  unsigned int v56;
  unsigned __int8 *v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  int v65;
  int v66;
  uint64_t *v67;
  float v68;
  unsigned __int8 *v69;
  uint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  unsigned __int8 *v73;
  uint64_t v74;
  uint64_t v75;
  float v76;
  float v77;
  float v78;
  float v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 *v83;
  uint64_t v84;
  uint64_t v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;

  v6 = *((float *)a2 + 2);
  v7 = *(float *)a2;
  v8 = (float *)*((_QWORD *)a2 + 2);
  v9 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 15);
  v11 = *((_QWORD *)a2 + 16);
  v12 = *((_QWORD *)a2 + 7);
  v13 = *((_QWORD *)a2 + 9);
  v14 = *((_QWORD *)a2 + 5) + v13 * a4;
  v15 = *(unsigned __int8 **)(a1 + 32);
  v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v17 = *(_QWORD *)(a1 + 176);
  result = _blt_float;
  if (v17)
  {
    v96 = *((_QWORD *)a2 + 11);
    v19 = *((_QWORD *)a2 + 13);
    v20 = 1.0 - v6;
    v95 = v11 + 16 * a3 + 8;
    do
    {
      if (((v19 - v14) | (v14 - v96)) < 0)
      {
        v22 = 0;
        v23 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v21 - 7 >= 9)
          v22 = -v10;
        else
          v22 = v10;
        v23 = weights_19497[v21] & 0xF;
      }
      v24 = &v15[(v14 >> v12) * v10];
      if (LODWORD(v7) == 1)
      {
        if (a5 >= 1)
        {
          v25 = (uint64_t *)v95;
          v26 = a5;
          do
          {
            v27 = *(v25 - 1);
            v28 = *v25;
            v29 = &v24[v27];
            if (v16 >= &v24[v27])
              v30 = &v24[v27];
            else
              v30 = v16;
            if (v15 > v30)
              v30 = v15;
            v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
            if ((v28 & 0xF) != 0)
            {
              v32 = &v29[v28 >> 4];
              if (v16 < v32)
                v32 = v16;
              if (v15 > v32)
                v32 = v15;
              v33 = (*v32 << 24) | (v32[1] << 16) | (v32[2] << 8);
              if (v23)
              {
                v34 = &v29[v22];
                if (v16 >= &v29[v22])
                  v35 = &v29[v22];
                else
                  v35 = v16;
                if (v15 > v35)
                  v35 = v15;
                v36 = (*v35 << 24) | (v35[1] << 16) | (v35[2] << 8);
                v37 = &v34[v28 >> 4];
                if (v16 < v37)
                  v37 = v16;
                if (v15 > v37)
                  v37 = v15;
                v38 = BLEND8_19499[v23];
                v31 = v31 - ((v38 & v31) >> v23) + ((v38 & v36) >> v23);
                v33 = v33 - ((v38 & v33) >> v23) + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v23);
              }
              v31 = v31
                  - ((BLEND8_19499[*v25 & 0xF] & v31) >> (*v25 & 0xF))
                  + ((BLEND8_19499[*v25 & 0xF] & v33) >> (*v25 & 0xF));
            }
            else if (v23)
            {
              v39 = &v29[v22];
              if (v16 < &v29[v22])
                v39 = v16;
              if (v15 > v39)
                v39 = v15;
              v31 = v31
                  - ((BLEND8_19499[v23] & v31) >> v23)
                  + ((((*v39 << 24) | (v39[1] << 16) | (v39[2] << 8)) & BLEND8_19499[v23]) >> v23);
            }
            v40 = *(float *)&_blt_float[HIBYTE(v31)];
            if (v6 >= 1.0)
            {
              v41 = *(float *)&_blt_float[BYTE2(v31)];
              v42 = *(float *)&_blt_float[BYTE1(v31)];
              v43 = 1.0;
            }
            else
            {
              v40 = v6 * v40;
              v41 = v6 * *(float *)&_blt_float[BYTE2(v31)];
              v42 = v6 * *(float *)&_blt_float[BYTE1(v31)];
              v43 = v6;
            }
            v25 += 2;
            *v8 = v40;
            v8[1] = v41;
            v8[2] = v42;
            v8[3] = v43;
            v8 += 4;
            --v26;
          }
          while (v26);
        }
      }
      else if (a5 >= 1)
      {
        v44 = (uint64_t *)v95;
        v45 = a5;
        do
        {
          v46 = *(v44 - 1);
          v47 = *v44;
          v48 = &v24[v46];
          if (v16 >= &v24[v46])
            v49 = &v24[v46];
          else
            v49 = v16;
          if (v15 > v49)
            v49 = v15;
          v50 = (*v49 << 24) | (v49[1] << 16) | (v49[2] << 8);
          if ((v47 & 0xF) != 0)
          {
            v51 = &v48[v47 >> 4];
            if (v16 < v51)
              v51 = v16;
            if (v15 > v51)
              v51 = v15;
            v52 = (*v51 << 24) | (v51[1] << 16) | (v51[2] << 8);
            if (v23)
            {
              if (v16 >= &v48[v22])
                v53 = &v48[v22];
              else
                v53 = v16;
              if (v15 > v53)
                v53 = v15;
              v54 = (*v53 << 24) | (v53[1] << 16) | (v53[2] << 8);
              v55 = &v48[v22 + (v47 >> 4)];
              if (v16 < v55)
                v55 = v16;
              if (v15 > v55)
                v55 = v15;
              v56 = BLEND8_19499[v23];
              v50 = v50 - ((v56 & v50) >> v23) + ((v56 & v54) >> v23);
              v52 = v52 - ((v56 & v52) >> v23) + ((((*v55 << 24) | (v55[1] << 16) | (v55[2] << 8)) & v56) >> v23);
            }
            v50 = v50
                - ((BLEND8_19499[*v44 & 0xF] & v50) >> (*v44 & 0xF))
                + ((BLEND8_19499[*v44 & 0xF] & v52) >> (*v44 & 0xF));
          }
          else if (v23)
          {
            v57 = &v48[v22];
            if (v16 < &v48[v22])
              v57 = v16;
            if (v15 > v57)
              v57 = v15;
            v50 = v50
                - ((BLEND8_19499[v23] & v50) >> v23)
                + ((((*v57 << 24) | (v57[1] << 16) | (v57[2] << 8)) & BLEND8_19499[v23]) >> v23);
          }
          v58 = *(float *)&_blt_float[HIBYTE(v50)];
          if (v6 >= 1.0)
          {
            v65 = _blt_float[BYTE2(v50)];
            v66 = _blt_float[BYTE1(v50)];
            *v8 = v58;
            *((_DWORD *)v8 + 1) = v65;
            *((_DWORD *)v8 + 2) = v66;
            v8[3] = 1.0;
          }
          else
          {
            v59 = v6 * v58;
            v60 = v6 * *(float *)&_blt_float[BYTE2(v50)];
            v61 = v6 * *(float *)&_blt_float[BYTE1(v50)];
            if (v6 > 0.0)
            {
              v62 = v8[1];
              *v8 = v59 + (float)(*v8 * v20);
              v8[1] = v60 + (float)(v62 * v20);
              v63 = v61 + (float)(v8[2] * v20);
              v64 = v6 + (float)(v8[3] * v20);
              v8[2] = v63;
              v8[3] = v64;
            }
          }
          v44 += 2;
          v8 += 4;
          --v45;
        }
        while (v45);
      }
      v8 += 4 * v9;
      v14 += v13;
      --a6;
    }
    while (a6);
  }
  else
  {
    v67 = (uint64_t *)(v11 + 16 * a3);
    v68 = 1.0 - v6;
    do
    {
      v69 = &v15[(v14 >> v12) * v10];
      if (LODWORD(v7) == 1)
      {
        if (a5 >= 1)
        {
          v70 = v67;
          v71 = a5;
          do
          {
            v72 = *v70;
            v70 += 2;
            v73 = &v69[v72];
            if (v16 < &v69[v72])
              v73 = v16;
            if (v15 > v73)
              v73 = v15;
            v74 = v73[1];
            v75 = v73[2];
            v76 = *(float *)&_blt_float[*v73];
            if (v6 >= 1.0)
            {
              v77 = *(float *)&_blt_float[v74];
              v78 = *(float *)&_blt_float[v75];
              v79 = 1.0;
            }
            else
            {
              v76 = v6 * v76;
              v77 = v6 * *(float *)&_blt_float[v74];
              v78 = v6 * *(float *)&_blt_float[v75];
              v79 = v6;
            }
            *v8 = v76;
            v8[1] = v77;
            v8[2] = v78;
            v8[3] = v79;
            v8 += 4;
            --v71;
          }
          while (v71);
        }
      }
      else
      {
        v80 = v67;
        v81 = a5;
        if (a5 >= 1)
        {
          do
          {
            v82 = *v80;
            v80 += 2;
            v83 = &v69[v82];
            if (v16 < &v69[v82])
              v83 = v16;
            if (v15 > v83)
              v83 = v15;
            v84 = v83[1];
            v85 = v83[2];
            v86 = *(float *)&_blt_float[*v83];
            if (v6 >= 1.0)
            {
              v93 = _blt_float[v84];
              v94 = _blt_float[v85];
              *v8 = v86;
              *((_DWORD *)v8 + 1) = v93;
              *((_DWORD *)v8 + 2) = v94;
              v8[3] = 1.0;
            }
            else
            {
              v87 = v6 * v86;
              v88 = v6 * *(float *)&_blt_float[v84];
              v89 = v6 * *(float *)&_blt_float[v85];
              if (v6 > 0.0)
              {
                v90 = v8[1];
                *v8 = v87 + (float)(*v8 * v68);
                v8[1] = v88 + (float)(v90 * v68);
                v91 = v89 + (float)(v8[2] * v68);
                v92 = v6 + (float)(v8[3] * v68);
                v8[2] = v91;
                v8[3] = v92;
              }
            }
            v8 += 4;
            --v81;
          }
          while (v81);
        }
      }
      v8 += 4 * v9;
      v14 += v13;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t RGBAf_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6;
  int v7;
  unsigned int *v8;
  char v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t result;
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  int v36;
  unsigned int *v37;
  unsigned int v38;
  float v39;
  float v40;
  float v41;
  float v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int *v53;
  int v54;
  unsigned int *v55;
  unsigned int v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  uint64_t *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int *v68;
  unsigned int v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int *v77;
  unsigned int v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  float v89;

  v6 = *((float *)a2 + 2);
  v7 = a2[1];
  v89 = *(float *)a2;
  v8 = *(unsigned int **)(a1 + 32);
  if (*(_QWORD *)(a1 + 40))
    v9 = 0;
  else
    v9 = -1;
  v10 = (float *)*((_QWORD *)a2 + 2);
  v11 = *((_QWORD *)a2 + 3) - a5;
  v13 = *((_QWORD *)a2 + 15);
  v12 = *((_QWORD *)a2 + 16);
  v14 = *((_QWORD *)a2 + 7);
  v15 = *((_QWORD *)a2 + 9);
  v16 = *((_QWORD *)a2 + 5) + v15 * a4;
  v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(_QWORD *)(a1 + 176))
  {
    v88 = *((_QWORD *)a2 + 11);
    v87 = *((_QWORD *)a2 + 13);
    v86 = v12 + 16 * a3 + 8;
    do
    {
      if (((v87 - v16) | (v16 - v88)) < 0)
      {
        v19 = 0;
        v20 = 0;
      }
      else
      {
        v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9)
          v19 = -v13;
        else
          v19 = v13;
        v20 = weights_19497[v18] & 0xF;
      }
      result = v16 >> v14;
      v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          result = v20;
          v23 = (uint64_t *)v86;
          v24 = a5;
          do
          {
            v25 = *(v23 - 1);
            v26 = *v23;
            v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25])
              v28 = (unsigned int *)&v22[v25];
            else
              v28 = v17;
            if (v8 > v28)
              v28 = v8;
            v29 = bswap32(*v28);
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30)
                v30 = v17;
              if (v8 > v30)
                v30 = v8;
              v31 = bswap32(*v30);
              if (v20)
              {
                v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v8 > v33)
                  v33 = v8;
                v34 = bswap32(*v33);
                v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35)
                  v35 = v17;
                if (v8 > v35)
                  v35 = v8;
                v36 = BLEND8_19499[v20];
                v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                v31 = v31 - ((v36 & v31) >> v20) + ((bswap32(*v35) & v36) >> v20);
              }
              v29 = v29
                  - ((BLEND8_19499[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_19499[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19])
                v37 = v17;
              if (v8 > v37)
                v37 = v8;
              v29 = v29 - ((BLEND8_19499[v20] & v29) >> v20) + ((bswap32(*v37) & BLEND8_19499[v20]) >> v20);
            }
            v38 = __ROL4__(v29, v7);
            v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              v40 = *(float *)&_blt_float[BYTE2(v38)];
              v41 = *(float *)&_blt_float[BYTE1(v38)];
              v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              v39 = v6 * v39;
              v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *v10 = v39;
            v10[1] = v40;
            v10[2] = v41;
            v10[3] = v42;
            v10 += 4;
            --v24;
          }
          while (v24);
        }
      }
      else if (a5 >= 1)
      {
        v43 = (uint64_t *)v86;
        result = a5;
        do
        {
          v44 = *(v43 - 1);
          v45 = *v43;
          v46 = &v22[v44];
          if (v17 >= (unsigned int *)&v22[v44])
            v47 = (unsigned int *)&v22[v44];
          else
            v47 = v17;
          if (v8 > v47)
            v47 = v8;
          v48 = bswap32(*v47);
          if ((v45 & 0xF) != 0)
          {
            v49 = (unsigned int *)&v46[v45 >> 4];
            if (v17 < v49)
              v49 = v17;
            if (v8 > v49)
              v49 = v8;
            v50 = bswap32(*v49);
            if (v20)
            {
              if (v17 >= (unsigned int *)&v46[v19])
                v51 = (unsigned int *)&v46[v19];
              else
                v51 = v17;
              if (v8 > v51)
                v51 = v8;
              v52 = bswap32(*v51);
              v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
              if (v17 < v53)
                v53 = v17;
              if (v8 > v53)
                v53 = v8;
              v54 = BLEND8_19499[v20];
              v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
              v50 = v50 - ((v54 & v50) >> v20) + ((bswap32(*v53) & v54) >> v20);
            }
            v48 = v48
                - ((BLEND8_19499[*v43 & 0xF] & v48) >> (*v43 & 0xF))
                + ((BLEND8_19499[*v43 & 0xF] & v50) >> (*v43 & 0xF));
          }
          else if (v20)
          {
            v55 = (unsigned int *)&v46[v19];
            if (v17 < (unsigned int *)&v46[v19])
              v55 = v17;
            if (v8 > v55)
              v55 = v8;
            v48 = v48 - ((BLEND8_19499[v20] & v48) >> v20) + ((bswap32(*v55) & BLEND8_19499[v20]) >> v20);
          }
          v56 = __ROL4__(v48, v7);
          v57 = *(float *)&_blt_float[HIBYTE(v56)];
          if (v6 >= 1.0)
          {
            v58 = *(float *)&_blt_float[BYTE2(v56)];
            v59 = *(float *)&_blt_float[BYTE1(v56)];
            v60 = *(float *)&_blt_float[(v56 | v9)];
          }
          else
          {
            v57 = v6 * v57;
            v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
            v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
            v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
          }
          if (v60 >= 1.0)
          {
            *v10 = v57;
            v10[1] = v58;
            v10[2] = v59;
            v10[3] = v60;
          }
          else if (v60 > 0.0)
          {
            v61 = v10[1];
            *v10 = v57 + (float)(*v10 * (float)(1.0 - v60));
            v10[1] = v58 + (float)(v61 * (float)(1.0 - v60));
            v62 = v59 + (float)(v10[2] * (float)(1.0 - v60));
            v63 = v60 + (float)(v10[3] * (float)(1.0 - v60));
            v10[2] = v62;
            v10[3] = v63;
          }
          v43 += 2;
          v10 += 4;
          --result;
        }
        while (result);
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  else
  {
    v64 = (uint64_t *)(v12 + 16 * a3);
    do
    {
      result = (uint64_t)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          v65 = v64;
          v66 = a5;
          do
          {
            v67 = *v65;
            v65 += 2;
            v68 = (unsigned int *)(result + v67);
            if ((unint64_t)v17 < result + v67)
              v68 = v17;
            if (v8 > v68)
              v68 = v8;
            v69 = __ROL4__(bswap32(*v68), v7);
            v70 = *(float *)&_blt_float[HIBYTE(v69)];
            if (v6 >= 1.0)
            {
              v71 = *(float *)&_blt_float[BYTE2(v69)];
              v72 = *(float *)&_blt_float[BYTE1(v69)];
              v73 = *(float *)&_blt_float[(v69 | v9)];
            }
            else
            {
              v70 = v6 * v70;
              v71 = v6 * *(float *)&_blt_float[BYTE2(v69)];
              v72 = v6 * *(float *)&_blt_float[BYTE1(v69)];
              v73 = v6 * *(float *)&_blt_float[(v69 | v9)];
            }
            *v10 = v70;
            v10[1] = v71;
            v10[2] = v72;
            v10[3] = v73;
            v10 += 4;
            --v66;
          }
          while (v66);
        }
      }
      else
      {
        v74 = v64;
        v75 = a5;
        if (a5 >= 1)
        {
          do
          {
            v76 = *v74;
            v74 += 2;
            v77 = (unsigned int *)(result + v76);
            if ((unint64_t)v17 < result + v76)
              v77 = v17;
            if (v8 > v77)
              v77 = v8;
            v78 = __ROL4__(bswap32(*v77), v7);
            v79 = *(float *)&_blt_float[HIBYTE(v78)];
            if (v6 >= 1.0)
            {
              v80 = *(float *)&_blt_float[BYTE2(v78)];
              v81 = *(float *)&_blt_float[BYTE1(v78)];
              v82 = *(float *)&_blt_float[(v78 | v9)];
            }
            else
            {
              v79 = v6 * v79;
              v80 = v6 * *(float *)&_blt_float[BYTE2(v78)];
              v81 = v6 * *(float *)&_blt_float[BYTE1(v78)];
              v82 = v6 * *(float *)&_blt_float[(v78 | v9)];
            }
            if (v82 >= 1.0)
            {
              *v10 = v79;
              v10[1] = v80;
              v10[2] = v81;
              v10[3] = v82;
            }
            else if (v82 > 0.0)
            {
              v83 = v10[1];
              *v10 = v79 + (float)(*v10 * (float)(1.0 - v82));
              v10[1] = v80 + (float)(v83 * (float)(1.0 - v82));
              v84 = v81 + (float)(v10[2] * (float)(1.0 - v82));
              v85 = v82 + (float)(v10[3] * (float)(1.0 - v82));
              v10[2] = v84;
              v10[3] = v85;
            }
            v10 += 4;
            --v75;
          }
          while (v75);
        }
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t RGBAf_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6;
  int v7;
  unsigned int *v8;
  char v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t result;
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int v38;
  float v39;
  float v40;
  float v41;
  float v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int *v53;
  unsigned int v54;
  unsigned int *v55;
  unsigned int v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  uint64_t *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int *v68;
  unsigned int v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int *v77;
  unsigned int v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  float v89;

  v6 = *((float *)a2 + 2);
  v7 = a2[1];
  v89 = *(float *)a2;
  v8 = *(unsigned int **)(a1 + 32);
  if (*(_QWORD *)(a1 + 40))
    v9 = 0;
  else
    v9 = -1;
  v10 = (float *)*((_QWORD *)a2 + 2);
  v11 = *((_QWORD *)a2 + 3) - a5;
  v13 = *((_QWORD *)a2 + 15);
  v12 = *((_QWORD *)a2 + 16);
  v14 = *((_QWORD *)a2 + 7);
  v15 = *((_QWORD *)a2 + 9);
  v16 = *((_QWORD *)a2 + 5) + v15 * a4;
  v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(_QWORD *)(a1 + 176))
  {
    v88 = *((_QWORD *)a2 + 11);
    v87 = *((_QWORD *)a2 + 13);
    v86 = v12 + 16 * a3 + 8;
    do
    {
      if (((v87 - v16) | (v16 - v88)) < 0)
      {
        v19 = 0;
        v20 = 0;
      }
      else
      {
        v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9)
          v19 = -v13;
        else
          v19 = v13;
        v20 = weights_19497[v18] & 0xF;
      }
      result = v16 >> v14;
      v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          result = v20;
          v23 = (uint64_t *)v86;
          v24 = a5;
          do
          {
            v25 = *(v23 - 1);
            v26 = *v23;
            v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25])
              v28 = (unsigned int *)&v22[v25];
            else
              v28 = v17;
            if (v8 > v28)
              v28 = v8;
            v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30)
                v30 = v17;
              if (v8 > v30)
                v30 = v8;
              v31 = *v30;
              if (v20)
              {
                v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v8 > v33)
                  v33 = v8;
                v34 = *v33;
                v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35)
                  v35 = v17;
                if (v8 > v35)
                  v35 = v8;
                v36 = BLEND8_19499[v20];
                v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                v31 = v31 - ((v36 & v31) >> v20) + ((v36 & *v35) >> v20);
              }
              v29 = v29
                  - ((BLEND8_19499[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_19499[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19])
                v37 = v17;
              if (v8 > v37)
                v37 = v8;
              v29 = v29 - ((BLEND8_19499[v20] & v29) >> v20) + ((BLEND8_19499[v20] & *v37) >> v20);
            }
            v38 = __ROL4__(v29, v7);
            v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              v40 = *(float *)&_blt_float[BYTE2(v38)];
              v41 = *(float *)&_blt_float[BYTE1(v38)];
              v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              v39 = v6 * v39;
              v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *v10 = v39;
            v10[1] = v40;
            v10[2] = v41;
            v10[3] = v42;
            v10 += 4;
            --v24;
          }
          while (v24);
        }
      }
      else if (a5 >= 1)
      {
        v43 = (uint64_t *)v86;
        result = a5;
        do
        {
          v44 = *(v43 - 1);
          v45 = *v43;
          v46 = &v22[v44];
          if (v17 >= (unsigned int *)&v22[v44])
            v47 = (unsigned int *)&v22[v44];
          else
            v47 = v17;
          if (v8 > v47)
            v47 = v8;
          v48 = *v47;
          if ((v45 & 0xF) != 0)
          {
            v49 = (unsigned int *)&v46[v45 >> 4];
            if (v17 < v49)
              v49 = v17;
            if (v8 > v49)
              v49 = v8;
            v50 = *v49;
            if (v20)
            {
              if (v17 >= (unsigned int *)&v46[v19])
                v51 = (unsigned int *)&v46[v19];
              else
                v51 = v17;
              if (v8 > v51)
                v51 = v8;
              v52 = *v51;
              v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
              if (v17 < v53)
                v53 = v17;
              if (v8 > v53)
                v53 = v8;
              v54 = BLEND8_19499[v20];
              v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
              v50 = v50 - ((v54 & v50) >> v20) + ((v54 & *v53) >> v20);
            }
            v48 = v48
                - ((BLEND8_19499[*v43 & 0xF] & v48) >> (*v43 & 0xF))
                + ((BLEND8_19499[*v43 & 0xF] & v50) >> (*v43 & 0xF));
          }
          else if (v20)
          {
            v55 = (unsigned int *)&v46[v19];
            if (v17 < (unsigned int *)&v46[v19])
              v55 = v17;
            if (v8 > v55)
              v55 = v8;
            v48 = v48 - ((BLEND8_19499[v20] & v48) >> v20) + ((BLEND8_19499[v20] & *v55) >> v20);
          }
          v56 = __ROL4__(v48, v7);
          v57 = *(float *)&_blt_float[HIBYTE(v56)];
          if (v6 >= 1.0)
          {
            v58 = *(float *)&_blt_float[BYTE2(v56)];
            v59 = *(float *)&_blt_float[BYTE1(v56)];
            v60 = *(float *)&_blt_float[(v56 | v9)];
          }
          else
          {
            v57 = v6 * v57;
            v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
            v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
            v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
          }
          if (v60 >= 1.0)
          {
            *v10 = v57;
            v10[1] = v58;
            v10[2] = v59;
            v10[3] = v60;
          }
          else if (v60 > 0.0)
          {
            v61 = v10[1];
            *v10 = v57 + (float)(*v10 * (float)(1.0 - v60));
            v10[1] = v58 + (float)(v61 * (float)(1.0 - v60));
            v62 = v59 + (float)(v10[2] * (float)(1.0 - v60));
            v63 = v60 + (float)(v10[3] * (float)(1.0 - v60));
            v10[2] = v62;
            v10[3] = v63;
          }
          v43 += 2;
          v10 += 4;
          --result;
        }
        while (result);
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  else
  {
    v64 = (uint64_t *)(v12 + 16 * a3);
    do
    {
      result = (uint64_t)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          v65 = v64;
          v66 = a5;
          do
          {
            v67 = *v65;
            v65 += 2;
            v68 = (unsigned int *)(result + v67);
            if ((unint64_t)v17 < result + v67)
              v68 = v17;
            if (v8 > v68)
              v68 = v8;
            v69 = __ROL4__(*v68, v7);
            v70 = *(float *)&_blt_float[HIBYTE(v69)];
            if (v6 >= 1.0)
            {
              v71 = *(float *)&_blt_float[BYTE2(v69)];
              v72 = *(float *)&_blt_float[BYTE1(v69)];
              v73 = *(float *)&_blt_float[(v69 | v9)];
            }
            else
            {
              v70 = v6 * v70;
              v71 = v6 * *(float *)&_blt_float[BYTE2(v69)];
              v72 = v6 * *(float *)&_blt_float[BYTE1(v69)];
              v73 = v6 * *(float *)&_blt_float[(v69 | v9)];
            }
            *v10 = v70;
            v10[1] = v71;
            v10[2] = v72;
            v10[3] = v73;
            v10 += 4;
            --v66;
          }
          while (v66);
        }
      }
      else
      {
        v74 = v64;
        v75 = a5;
        if (a5 >= 1)
        {
          do
          {
            v76 = *v74;
            v74 += 2;
            v77 = (unsigned int *)(result + v76);
            if ((unint64_t)v17 < result + v76)
              v77 = v17;
            if (v8 > v77)
              v77 = v8;
            v78 = __ROL4__(*v77, v7);
            v79 = *(float *)&_blt_float[HIBYTE(v78)];
            if (v6 >= 1.0)
            {
              v80 = *(float *)&_blt_float[BYTE2(v78)];
              v81 = *(float *)&_blt_float[BYTE1(v78)];
              v82 = *(float *)&_blt_float[(v78 | v9)];
            }
            else
            {
              v79 = v6 * v79;
              v80 = v6 * *(float *)&_blt_float[BYTE2(v78)];
              v81 = v6 * *(float *)&_blt_float[BYTE1(v78)];
              v82 = v6 * *(float *)&_blt_float[(v78 | v9)];
            }
            if (v82 >= 1.0)
            {
              *v10 = v79;
              v10[1] = v80;
              v10[2] = v81;
              v10[3] = v82;
            }
            else if (v82 > 0.0)
            {
              v83 = v10[1];
              *v10 = v79 + (float)(*v10 * (float)(1.0 - v82));
              v10[1] = v80 + (float)(v83 * (float)(1.0 - v82));
              v84 = v81 + (float)(v10[2] * (float)(1.0 - v82));
              v85 = v82 + (float)(v10[3] * (float)(1.0 - v82));
              v10[2] = v84;
              v10[3] = v85;
            }
            v10 += 4;
            --v75;
          }
          while (v75);
        }
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  return result;
}

void RGBAf_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  void *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  float32x4_t *v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  uint64_t v35;
  unsigned int v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  float32x4_t *v52;
  unsigned __int8 *v53;
  unsigned int v54;
  float v55;
  int v56;
  _BYTE *v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  float *v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  float *v66;
  unint64_t v67;
  unint64_t v68;
  __int128 *v69;
  int v70;
  unsigned __int8 *v71;
  unsigned int v72;
  unsigned __int8 v73;
  unsigned __int8 *v74;
  float32x4_t *v75;
  int v76;
  int v77;
  unsigned int v78;
  float32x4_t v79;
  unsigned __int8 v80;
  unsigned __int8 v81;
  uint64_t v82;
  unsigned __int8 *v83;
  int v84;
  unsigned int v85;
  float32x4_t *v86;
  float v87;
  float v88;
  float32x2_t *v89;
  float v90;
  float v91;
  float32x2_t v92;
  float32x2_t *v93;
  float32_t v94;
  float32x4_t *v95;
  unsigned __int8 v96;
  int v97;
  unsigned __int8 *v98;
  unsigned int v99;
  float32x4_t v100;
  int v101;
  unsigned int v102;
  float32x4_t v103;
  int v104;
  unsigned int v105;
  unsigned int v106;
  float32x4_t v107;
  float *v108;
  int v109;
  unsigned int v110;
  unsigned int v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float *v119;
  int v120;
  unsigned int v121;
  float32x4_t v122;
  float *v123;
  int v124;
  unsigned int v125;
  float32x4_t v126;
  int v127;
  unsigned int v128;
  unsigned int v129;
  float v130;
  float v131;
  float32x4_t v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  float32x4_t v136;
  float *v137;
  int v138;
  unsigned int v139;
  unsigned int v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float *v150;
  int v151;
  unsigned int v152;
  unsigned int v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  int v159;
  unsigned __int8 *v160;
  unsigned int v161;
  unsigned int v162;
  float32x4_t v163;
  int8x16_t v164;
  float v165;
  double v166;
  float v167;
  __int32 v168;
  float *v169;
  int v170;
  unsigned int v171;
  unsigned int v172;
  float v173;
  float v174;
  float32x2_t v175;
  float v176;
  float v177;
  int v183;
  unsigned int v184;
  unsigned int v185;
  float32x4_t v186;
  int8x16_t v187;
  float v188;
  double v189;
  float v190;
  __int32 v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  float32x4_t v195;
  int8x16_t v196;
  float v197;
  double v198;
  float v199;
  __int32 v200;
  int v201;
  unsigned int v202;
  unsigned int v203;
  float32x4_t v204;
  int8x16_t v205;
  float v206;
  double v207;
  float v208;
  __int32 v209;
  int v210;
  unsigned int v211;
  unsigned int v212;
  float32x4_t v213;
  int8x16_t v214;
  float v215;
  double v216;
  float v217;
  __int32 v218;
  int v219;
  unsigned int v220;
  unsigned int v221;
  float32x4_t v222;
  int8x16_t v223;
  float v224;
  double v225;
  float v226;
  __int32 v227;
  int v228;
  unsigned int v229;
  unsigned int v230;
  int8x16_t v231;
  float v232;
  __int32 v233;
  int v234;
  unsigned int v235;
  unsigned int v236;
  float32x4_t v237;
  int8x16_t v238;
  float v239;
  double v240;
  float v241;
  __int32 v242;
  int v243;
  unsigned int v244;
  unsigned int v245;
  float32x4_t v246;
  float v247;
  float v248;
  float32x2_t v249;
  float32x2_t v250;
  float32x2_t v251;
  float32x2_t v252;
  float32x2_t v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float *v259;
  int v260;
  unsigned int v261;
  unsigned int v262;
  float v263;
  float v264;
  float32x2_t v265;
  float v266;
  float v267;
  int v268;
  unsigned int v269;
  unsigned int v270;
  int8x16_t v271;
  float v272;
  float v273;
  __int32 v274;
  __int32 v275;
  int v276;
  unsigned int v277;
  unsigned int v278;
  int8x16_t v279;
  float v280;
  float v281;
  __int32 v282;
  __int32 v283;
  int v284;
  char *v285;
  int v286;
  unsigned __int8 *v287;
  unsigned int v288;
  unsigned int v289;
  float32x4_t v290;
  float v291;
  float v292;
  __int32 v293;
  __int32 v294;
  int v295;
  unsigned int v296;
  unsigned int v297;
  int8x16_t v298;
  float v299;
  float v300;
  __int32 v301;
  __int32 v302;
  float32x4_t v303;
  unsigned __int8 v304;
  float *v305;
  unsigned __int8 *v306;
  int v307;
  float v308;
  float v309;
  float v310;
  float v311;
  float v312;
  unsigned __int8 v313;
  char *v314;
  uint64_t v315;
  uint64_t v316;
  int v317;
  uint64_t v318;
  int v319;
  __int128 v320;
  double v321;
  double v322;
  double v323;
  uint64_t v324;
  unint64_t v325;
  uint64_t v326;
  void *v327;
  uint64_t v328;
  uint64_t v329;
  unsigned int v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  unint64_t v335;
  __n128 v336;
  int *v337;
  char *v338;
  int v339;
  uint64_t v340;
  uint64_t v341;

  v330 = a3;
  v341 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 4);
  v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF)
    return;
  v8 = *(int *)(a1 + 28);
  v9 = *(char **)(a1 + 40);
  v340 = *(_QWORD *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  v336 = a4;
  v337 = *(int **)(a1 + 136);
  v338 = v9;
  v10 = *(_QWORD *)(a2 + 96);
  v332 = *(_QWORD *)(a2 + 104);
  v333 = v10;
  v12 = *(int *)(a1 + 12);
  v11 = *(int *)(a1 + 16);
  v339 = *(_DWORD *)(a1 + 8);
  v13 = *(int *)(a2 + 16);
  v14 = (v13 + 18) * v5;
  if (v14 > 65439)
  {
    v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0xC67F6127uLL);
    v16 = v17;
    v19 = v17;
    if (!v17)
      return;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1, a4);
    v16 = (char *)&v324 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    v19 = 0;
  }
  v327 = v19;
  v20 = v8 >> 4;
  v21 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  v22 = v21 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((_DWORD)v13)
    v23 = 16 * v5;
  else
    v23 = 0;
  v24 = v22 + v23;
  *(_QWORD *)(a2 + 144) = v21;
  *(_QWORD *)(a2 + 152) = v22 + v23;
  *(_QWORD *)(a2 + 160) = v22;
  v25 = (float32x4_t *)&v338[16 * v12 + 16 * v20 * v11];
  v325 = v8 >> 4;
  v326 = (int)v4;
  v335 = v20 - (int)v4;
  v26 = *(int *)(a1 + 104);
  v27 = *(_DWORD *)(a1 + 108);
  v28 = *(unsigned __int8 *)(a1 + 2);
  if (v28 == 6 || v28 == 1)
  {
    v30 = v332;
    v29 = v333;
    if (!v337)
      goto LABEL_417;
    v31 = 0;
    LODWORD(v32) = 0;
    v33 = *(int *)(a1 + 124);
    v34 = (unsigned __int8 *)v337 + v26 + (int)v33 * (uint64_t)v27;
    v35 = v326;
    v331 = v33 - v326;
LABEL_12:
    v36 = v330;
  }
  else
  {
    if (v337)
    {
      shape_enum_clip_alloc((uint64_t)v17, v18, v337, 1, 1, 1, v26, v27, v4, v339);
      if (v314)
      {
        v285 = v314;
        v32 = 0;
        v315 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
        if (!(_DWORD)v13)
          v315 = 16 * v5;
        v35 = v326;
        v331 = -v326;
        v34 = (unsigned __int8 *)(v24 + v315 + 16);
        v30 = v332;
        v29 = v333;
        goto LABEL_425;
      }
      goto LABEL_417;
    }
    v331 = 0;
    v31 = 0;
    v34 = 0;
    LODWORD(v32) = 0;
    v36 = v330;
    v35 = v326;
    v30 = v332;
    v29 = v333;
  }
  v328 = -v35;
  v329 = (v4 - 1) + 1;
  v334 = v36;
  v37 = v31;
  while (2)
  {
    LODWORD(v337) = v32;
    v338 = v37;
    v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2, v29, v30, v4);
    v52 = *(float32x4_t **)(a2 + 160);
    v53 = *(unsigned __int8 **)(a2 + 144);
    v54 = *(_DWORD *)(a2 + 8);
    if (v54 == *(_DWORD *)(a2 + 12))
    {
      v55 = v336.n128_f32[0];
      if (v336.n128_f32[0] < 1.0)
      {
        v56 = v4;
        v57 = *(_BYTE **)(a2 + 144);
        do
        {
          if (*v57)
            *v52 = vmulq_n_f32(*v52, v55);
          ++v57;
          ++v52;
          --v56;
        }
        while (v56);
        v52 += v328;
        v53 += v329 + v328;
      }
    }
    else
    {
      v58 = *(_QWORD *)(a2 + 152);
      v59 = HIWORD(v54) & 0x3F;
      v46 = v336.n128_f64[0];
      if (v59 == 16)
      {
        v61 = 0;
        v62 = &v52->f32[2];
        if (v336.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v61])
            {
              v64 = *(_QWORD *)(v58 + 8 * v61);
              *(v62 - 2) = *(float *)&_blt_float[v64 + 256] + *(float *)&_blt_float[BYTE1(v64) + 512];
              *(v62 - 1) = *(float *)&_blt_float[BYTE2(v64) + 256] + *(float *)&_blt_float[BYTE3(v64) | 0x200];
              *v62 = *(float *)&_blt_float[BYTE4(v64) + 256] + *(float *)&_blt_float[BYTE5(v64) + 512];
              v62[1] = *(float *)&_blt_float[BYTE6(v64) + 256] + *(float *)&_blt_float[HIBYTE(v64) + 512];
            }
            ++v61;
            v62 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v61);
        }
        else
        {
          do
          {
            if (v53[v61])
            {
              v63 = *(_QWORD *)(v58 + 8 * v61);
              *(v62 - 2) = *(float *)&v46
                         * (float)(*(float *)&_blt_float[v63 + 256]
                                 + *(float *)&_blt_float[BYTE1(v63) + 512]);
              *(v62 - 1) = *(float *)&v46
                         * (float)(*(float *)&_blt_float[BYTE2(v63) + 256] + *(float *)&_blt_float[BYTE3(v63) | 0x200]);
              *v62 = *(float *)&v46
                   * (float)(*(float *)&_blt_float[BYTE4(v63) + 256] + *(float *)&_blt_float[BYTE5(v63) + 512]);
              v62[1] = *(float *)&v46
                     * (float)(*(float *)&_blt_float[BYTE6(v63) + 256] + *(float *)&_blt_float[HIBYTE(v63) + 512]);
            }
            ++v61;
            v62 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v61);
        }
      }
      else if (v59 == 32)
      {
        v60 = 0;
        if (v336.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v60])
              v52[v60] = *(float32x4_t *)(v58 + 16 * v60);
            ++v60;
          }
          while ((_DWORD)v4 != (_DWORD)v60);
        }
        else
        {
          do
          {
            if (v53[v60])
              v52[v60] = vmulq_n_f32(*(float32x4_t *)(v58 + 16 * v60), *(float *)&v46);
            ++v60;
          }
          while ((_DWORD)v4 != (_DWORD)v60);
        }
      }
      else
      {
        v65 = 0;
        v66 = &v52->f32[2];
        if (v336.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v65])
            {
              v68 = *(unsigned int *)(v58 + 4 * v65);
              *(v66 - 2) = *(float *)((char *)_blt_float + ((v68 >> 22) & 0x3FC));
              *(v66 - 1) = *(float *)&_blt_float[BYTE2(v68)];
              *v66 = *(float *)&_blt_float[BYTE1(v68)];
              v66[1] = *(float *)&_blt_float[v68];
            }
            ++v65;
            v66 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v65);
        }
        else
        {
          do
          {
            if (v53[v65])
            {
              v67 = *(unsigned int *)(v58 + 4 * v65);
              *(v66 - 2) = *(float *)&v46 * *(float *)((char *)_blt_float + ((v67 >> 22) & 0x3FC));
              *(v66 - 1) = *(float *)&v46 * *(float *)&_blt_float[BYTE2(v67)];
              *v66 = *(float *)&v46 * *(float *)&_blt_float[BYTE1(v67)];
              v66[1] = *(float *)&v46 * *(float *)&_blt_float[v67];
            }
            ++v65;
            v66 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v65);
        }
      }
    }
    v69 = &xmmword_185005000;
    switch(v36)
    {
      case 0u:
        v70 = v4;
        v71 = v34;
        do
        {
          v72 = *v53;
          if (*v53)
          {
            if (v34)
              v72 = (*v71 * v72 + ((*v71 * v72) >> 8) + 1) >> 8;
            if ((_BYTE)v72)
            {
              if (v72 == 255)
              {
                v25->i64[0] = 0;
                v25->i64[1] = 0;
              }
              else
              {
                *v25 = vmulq_n_f32(*v25, (float)((float)v72 * -0.0039216) + 1.0);
              }
            }
          }
          ++v53;
          v71 += v34 != 0;
          ++v25;
          --v70;
        }
        while (v70);
        v34 = &v71[v331];
        goto LABEL_335;
      case 1u:
        v73 = *v53;
        v74 = v53 + 1;
        v75 = v25 - 1;
        v76 = v4;
        if (v34)
        {
          v77 = v339;
          do
          {
            if (v73)
            {
              v78 = ((unsigned __int16)(*v34 * v73 + ((*v34 * v73) >> 8) + 1) >> 8);
              if (v78)
              {
                if (v78 == 255)
                  v79 = *v52;
                else
                  v79 = vmlaq_n_f32(vmulq_n_f32(v75[1], 1.0 - (float)((float)v78 * 0.0039216)), *v52, (float)v78 * 0.0039216);
                v75[1] = v79;
              }
            }
            v80 = *v74++;
            v73 = v80;
            ++v52;
            ++v34;
            ++v75;
            --v76;
          }
          while (v76);
          goto LABEL_83;
        }
        v77 = v339;
        do
        {
          if (v73)
          {
            if (v73 == 255)
              v303 = *v52;
            else
              v303 = vmlaq_n_f32(vmulq_n_f32(v75[1], 1.0 - (float)((float)v73 * 0.0039216)), *v52, (float)v73 * 0.0039216);
            v75[1] = v303;
          }
          v304 = *v74++;
          v73 = v304;
          ++v52;
          ++v75;
          --v76;
        }
        while (v76);
        goto LABEL_412;
      case 2u:
        v81 = *v53;
        if (v34)
        {
          v82 = 0;
          v83 = v53 + 1;
          v84 = v4;
          v77 = v339;
          do
          {
            if (v81)
            {
              v85 = ((unsigned __int16)(*v34 * v81 + ((*v34 * v81) >> 8) + 1) >> 8);
              if ((unsigned __int16)(*v34 * v81 + ((*v34 * v81) >> 8) + 1) >> 8)
              {
                if (v85 == 255)
                {
                  v86 = &v52[v82];
                  v87 = v52[v82].f32[3];
                  if (v87 >= 1.0)
                  {
                    v95 = &v25[v82];
                    v95->i64[0] = v86->i64[0];
                    v95->i32[2] = v86->i32[2];
                    v95->f32[3] = v87;
                  }
                  else if (v87 > 0.0)
                  {
                    v25[v82] = vmlaq_n_f32(v52[v82], v25[v82], 1.0 - v87);
                  }
                }
                else
                {
                  v88 = (float)v85 * 0.0039216;
                  v89 = (float32x2_t *)&v52[v82];
                  v90 = v88 * v52[v82].f32[3];
                  if (v90 > 0.0)
                  {
                    v91 = v88 * v89[1].f32[0];
                    v92 = vmul_n_f32(*v89, v88);
                    v93 = (float32x2_t *)&v25[v82];
                    *v93 = vmla_n_f32(v92, *(float32x2_t *)v25[v82].f32, 1.0 - v90);
                    v92.f32[0] = v91 + (float)(v25[v82].f32[2] * (float)(1.0 - v90));
                    v94 = v90 + (float)(v25[v82].f32[3] * (float)(1.0 - v90));
                    v93[1].i32[0] = v92.i32[0];
                    v93[1].f32[1] = v94;
                  }
                }
              }
            }
            v96 = *v83++;
            v81 = v96;
            ++v34;
            ++v82;
            --v84;
          }
          while (v84);
          v75 = &v25[v82 - 1];
LABEL_83:
          v34 += v331;
LABEL_413:
          v25 = &v75[v335 + 1];
          goto LABEL_364;
        }
        v305 = &v52->f32[2];
        v75 = v25 - 1;
        v306 = v53 + 1;
        v307 = v4;
        v77 = v339;
        while (1)
        {
          if (v81)
          {
            if (v81 == 255)
            {
              v308 = v305[1];
              if (v308 < 1.0)
              {
                if (v308 > 0.0)
                  v75[1] = vmlaq_n_f32(*(float32x4_t *)(v305 - 2), v75[1], 1.0 - v308);
                goto LABEL_411;
              }
              v75[1].i64[0] = *((_QWORD *)v305 - 1);
              v312 = *v305;
              goto LABEL_410;
            }
            v309 = (float)v81 * 0.0039216;
            v310 = v309 * v305[1];
            if (v310 > 0.0)
            {
              v311 = v309 * *v305;
              *(float32x2_t *)v75[1].f32 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)(v305 - 2), v309), *(float32x2_t *)v75[1].f32, 1.0 - v310);
              v312 = v311 + (float)(v75[1].f32[2] * (float)(1.0 - v310));
              v308 = v310 + (float)(v75[1].f32[3] * (float)(1.0 - v310));
LABEL_410:
              v75[1].f32[2] = v312;
              v75[1].f32[3] = v308;
            }
          }
LABEL_411:
          v313 = *v306++;
          v81 = v313;
          v305 += 4;
          ++v75;
          if (!--v307)
          {
LABEL_412:
            v34 = 0;
            goto LABEL_413;
          }
        }
      case 3u:
        v97 = v4;
        v98 = v34;
        do
        {
          v99 = *v53;
          if (*v53)
          {
            if (v34)
              v99 = (*v98 * v99 + ((*v98 * v99) >> 8) + 1) >> 8;
            if ((_BYTE)v99)
            {
              if (v99 == 255)
                v100 = vmulq_n_f32(*v52, v25->f32[3]);
              else
                v100 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v99 * 0.0039216)), *v52, vmuls_lane_f32((float)v99 * 0.0039216, *v25, 3));
              *v25 = v100;
            }
          }
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          --v97;
        }
        while (v97);
        goto LABEL_334;
      case 4u:
        v101 = v4;
        v98 = v34;
        do
        {
          v102 = *v53;
          if (*v53)
          {
            if (v34)
              v102 = (*v98 * v102 + ((*v98 * v102) >> 8) + 1) >> 8;
            if ((_BYTE)v102)
            {
              if (v102 == 255)
                v103 = vmulq_n_f32(*v52, 1.0 - v25->f32[3]);
              else
                v103 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v102 * 0.0039216)), *v52, (float)((float)v102 * 0.0039216)* (float)(1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v25))));
              *v25 = v103;
            }
          }
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          --v101;
        }
        while (v101);
        goto LABEL_334;
      case 5u:
        v104 = v4;
        v98 = v34;
        while (1)
        {
          v105 = *v53;
          if (*v53)
          {
            if (!v34)
              goto LABEL_111;
            v106 = *v98 * v105 + ((*v98 * v105) >> 8) + 1;
            if (BYTE1(v106))
              break;
          }
LABEL_112:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v104)
            goto LABEL_334;
        }
        v105 = v106 >> 8;
LABEL_111:
        v107 = vmulq_n_f32(*v52, (float)v105 * 0.0039216);
        *v25 = vmlaq_laneq_f32(vmulq_n_f32(*v25, 1.0 - v107.f32[3]), v107, *v25, 3);
        goto LABEL_112;
      case 6u:
        v108 = &v52->f32[2];
        v109 = v4;
        v98 = v34;
        while (1)
        {
          v110 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v111 = *v98 * v110 + ((*v98 * v110) >> 8) + 1;
              if (!BYTE1(v111))
                goto LABEL_124;
              v110 = v111 >> 8;
            }
            v112 = v25->f32[3];
            v113 = 1.0 - v112;
            if ((float)(1.0 - v112) >= 1.0)
            {
              v117 = (float)v110 * 0.0039216;
              *(float32x2_t *)v25->f32 = vmul_n_f32(*(float32x2_t *)(v108 - 2), v117);
              v118 = v108[1];
              v25->f32[2] = v117 * *v108;
              v116 = v117 * v118;
              goto LABEL_123;
            }
            if (v113 > 0.0)
            {
              v114 = v113 * (float)((float)v110 * 0.0039216);
              *(float32x2_t *)v25->f32 = vmla_n_f32(*(float32x2_t *)v25->f32, *(float32x2_t *)(v108 - 2), v114);
              v115 = v108[1];
              v25->f32[2] = v25->f32[2] + (float)(*v108 * v114);
              v116 = v112 + (float)(v115 * v114);
LABEL_123:
              v25->f32[3] = v116;
            }
          }
LABEL_124:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v108 += 4;
          if (!--v109)
            goto LABEL_334;
        }
      case 7u:
        v119 = &v52->f32[3];
        v120 = v4;
        v98 = v34;
        do
        {
          v121 = *v53;
          if (*v53)
          {
            if (v34)
              v121 = (*v98 * v121 + ((*v98 * v121) >> 8) + 1) >> 8;
            if ((_BYTE)v121)
            {
              if (v121 == 255)
                v122 = vmulq_n_f32(*v25, *v119);
              else
                v122 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v121 * 0.0039216)), *v25, (float)((float)v121 * 0.0039216) * *v119);
              *v25 = v122;
            }
          }
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v119 += 4;
          --v120;
        }
        while (v120);
        goto LABEL_334;
      case 8u:
        v123 = &v52->f32[3];
        v124 = v4;
        v98 = v34;
        do
        {
          v125 = *v53;
          if (*v53)
          {
            if (v34)
              v125 = (*v98 * v125 + ((*v98 * v125) >> 8) + 1) >> 8;
            if ((_BYTE)v125)
            {
              if (v125 == 255)
                v126 = vmulq_n_f32(*v25, 1.0 - *v123);
              else
                v126 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v125 * 0.0039216)), *v25, (float)((float)v125 * 0.0039216) * (float)(1.0 - *v123));
              *v25 = v126;
            }
          }
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v123 += 4;
          --v124;
        }
        while (v124);
        goto LABEL_334;
      case 9u:
        v127 = v4;
        v98 = v34;
        while (1)
        {
          v128 = *v53;
          if (*v53)
          {
            if (!v34)
              goto LABEL_153;
            v129 = *v98 * v128 + ((*v98 * v128) >> 8) + 1;
            if (BYTE1(v129))
              break;
          }
LABEL_154:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v127)
            goto LABEL_334;
        }
        v128 = v129 >> 8;
LABEL_153:
        v130 = (float)v128 * 0.0039216;
        v131 = 1.0 - v130;
        v132 = vmulq_n_f32(*v52, v130);
        *v25 = vmlaq_n_f32(vmulq_n_f32(*v25, v131 + v132.f32[3]), v132, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v25)));
        goto LABEL_154;
      case 0xAu:
        v133 = v4;
        v98 = v34;
        while (1)
        {
          v134 = *v53;
          if (*v53)
          {
            if (!v34)
              goto LABEL_161;
            v135 = *v98 * v134 + ((*v98 * v134) >> 8) + 1;
            if (BYTE1(v135))
              break;
          }
LABEL_162:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v133)
            goto LABEL_334;
        }
        v134 = v135 >> 8;
LABEL_161:
        v136 = vmulq_n_f32(*v52, (float)v134 * 0.0039216);
        *v25 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - v136.f32[3]), v136, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned __int128 *)v25)));
        goto LABEL_162;
      case 0xBu:
        v137 = &v52->f32[2];
        v138 = v4;
        v98 = v34;
        while (1)
        {
          v139 = *v53;
          if (*v53)
          {
            if (!v34)
              goto LABEL_169;
            v140 = *v98 * v139 + ((*v98 * v139) >> 8) + 1;
            if (BYTE1(v140))
              break;
          }
LABEL_177:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v137 += 4;
          if (!--v138)
            goto LABEL_334;
        }
        v139 = v140 >> 8;
LABEL_169:
        v141 = (float)v139 * 0.0039216;
        v142 = *(v137 - 2) * v141;
        v143 = v141 * v137[1];
        if (v340)
        {
          v144 = v25->f32[3];
          v145 = (float)(v143 - v142) + (float)(v144 - v25->f32[0]);
          v146 = 1.0;
          if ((float)(v143 + v144) <= 1.0)
            v146 = v143 + v144;
        }
        else
        {
          v144 = 1.0;
          v145 = (float)(v143 - v142) + (float)(1.0 - v25->f32[0]);
          if ((float)(v143 + 1.0) <= 1.0)
            v146 = v143 + 1.0;
          else
            v146 = 1.0;
        }
        v147 = (float)(v143 - (float)(*(v137 - 1) * v141)) + (float)(v144 - v25->f32[1]);
        v148 = v141 * *v137;
        v25->f32[0] = v146 - v145;
        v149 = (float)(v143 - v148) + (float)(v144 - v25->f32[2]);
        v25->f32[1] = v146 - v147;
        v25->f32[2] = v146 - v149;
        v25->f32[3] = v146;
        goto LABEL_177;
      case 0xCu:
        v150 = &v52->f32[3];
        v151 = v4;
        v98 = v34;
        while (1)
        {
          v152 = *v53;
          if (*v53)
          {
            if (!v34)
              goto LABEL_184;
            v153 = *v98 * v152 + ((*v98 * v152) >> 8) + 1;
            if (BYTE1(v153))
              break;
          }
LABEL_187:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v150 += 4;
          if (!--v151)
            goto LABEL_334;
        }
        v152 = v153 >> 8;
LABEL_184:
        v154 = (float)v152 * 0.0039216;
        v155 = v154 * *(v150 - 1);
        v156 = v154 * *v150;
        *(float32x2_t *)v25->f32 = vadd_f32(vmul_n_f32(*(float32x2_t *)(v150 - 3), v154), *(float32x2_t *)v25->f32);
        v157 = v156 + v25->f32[3];
        v158 = v155 + v25->f32[2];
        if (v157 > 1.0)
          v157 = 1.0;
        v25->f32[2] = v158;
        v25->f32[3] = v157;
        goto LABEL_187;
      case 0xDu:
        v332 = v30;
        v333 = v29;
        v159 = v4;
        v160 = v34;
        while (1)
        {
          v161 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v162 = *v160 * v161 + ((*v160 * v161) >> 8) + 1;
              if (!BYTE1(v162))
                goto LABEL_200;
              v161 = v162 >> 8;
            }
            v163 = *v52;
            v164 = (int8x16_t)vmulq_n_f32(*v52, (float)v161 * *((float *)v69 + 159));
            if (*(float *)&v164.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v165 = 1.0;
LABEL_199:
                v163.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v166 = vextq_s8(v164, v164, 4uLL).u64[0];
                v167 = PDAmultiplyPDA(v25->f32[0], *(double *)v163.i64, v46, v47, v165, *(double *)v164.i64, v166, v51, *(float *)v164.i32, COERCE_DOUBLE(__PAIR64__(v164.u32[3], HIDWORD(v166))), *(float *)&v164.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v167;
                v25->i32[1] = v168;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_200;
              }
              LODWORD(v47) = v25->i32[3];
              v165 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_199;
              *v25 = (float32x4_t)v164;
            }
          }
LABEL_200:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v159)
            goto LABEL_361;
        }
      case 0xEu:
        v169 = &v52->f32[2];
        v170 = v4;
        v98 = v34;
        while (1)
        {
          v171 = *v53;
          if (*v53)
          {
            if (!v34)
              goto LABEL_207;
            v172 = *v98 * v171 + ((*v98 * v171) >> 8) + 1;
            if (BYTE1(v172))
              break;
          }
LABEL_213:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v169 += 4;
          if (!--v170)
            goto LABEL_334;
        }
        v171 = v172 >> 8;
LABEL_207:
        v173 = (float)v171 * 0.0039216;
        v174 = v173 * v169[1];
        if (v174 > 0.0)
        {
          v175 = vmul_n_f32(*(float32x2_t *)(v169 - 2), v173);
          v176 = v173 * *v169;
          v177 = 1.0;
          if (v340 && (v177 = v25->f32[3], v177 <= 0.0))
          {
            *(float32x2_t *)v25->f32 = v175;
          }
          else
          {
            v176 = v25->f32[2] + (float)(v176 * (float)(1.0 - v25->f32[2]));
            __asm { FMOV            V6.2S, #1.0 }
            *(float32x2_t *)v25->f32 = vmla_f32(*(float32x2_t *)v25->f32, vsub_f32(_D6, *(float32x2_t *)v25->f32), v175);
            v174 = (float)(v174 + v177) - (float)(v177 * v174);
          }
          v25->f32[2] = v176;
          v25->f32[3] = v174;
        }
        goto LABEL_213;
      case 0xFu:
        v332 = v30;
        v333 = v29;
        v183 = v4;
        v160 = v34;
        while (1)
        {
          v184 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v185 = *v160 * v184 + ((*v160 * v184) >> 8) + 1;
              if (!BYTE1(v185))
                goto LABEL_226;
              v184 = v185 >> 8;
            }
            v186 = *v52;
            v187 = (int8x16_t)vmulq_n_f32(*v52, (float)v184 * *((float *)v69 + 159));
            if (*(float *)&v187.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v188 = 1.0;
LABEL_225:
                v186.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v189 = vextq_s8(v187, v187, 4uLL).u64[0];
                v190 = PDAoverlayPDA(v25->f32[0], *(double *)v186.i64, v46, v47, v188, *(double *)v187.i64, v189, v51, *(float *)v187.i32, COERCE_DOUBLE(__PAIR64__(v187.u32[3], HIDWORD(v189))), *(float *)&v187.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v190;
                v25->i32[1] = v191;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_226;
              }
              LODWORD(v47) = v25->i32[3];
              v188 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_225;
              *v25 = (float32x4_t)v187;
            }
          }
LABEL_226:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v183)
            goto LABEL_361;
        }
      case 0x10u:
        v332 = v30;
        v333 = v29;
        v192 = v4;
        v160 = v34;
        while (1)
        {
          v193 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v194 = *v160 * v193 + ((*v160 * v193) >> 8) + 1;
              if (!BYTE1(v194))
                goto LABEL_239;
              v193 = v194 >> 8;
            }
            v195 = *v52;
            v196 = (int8x16_t)vmulq_n_f32(*v52, (float)v193 * *((float *)v69 + 159));
            if (*(float *)&v196.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v197 = 1.0;
LABEL_238:
                v195.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v198 = vextq_s8(v196, v196, 4uLL).u64[0];
                v199 = PDAdarkenPDA(v25->f32[0], *(double *)v195.i64, v46, v47, v197, *(double *)v196.i64, v198, v51, *(float *)v196.i32, COERCE_DOUBLE(__PAIR64__(v196.u32[3], HIDWORD(v198))), *(float *)&v196.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v199;
                v25->i32[1] = v200;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_239;
              }
              LODWORD(v47) = v25->i32[3];
              v197 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_238;
              *v25 = (float32x4_t)v196;
            }
          }
LABEL_239:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v192)
            goto LABEL_361;
        }
      case 0x11u:
        v332 = v30;
        v333 = v29;
        v201 = v4;
        v160 = v34;
        while (1)
        {
          v202 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v203 = *v160 * v202 + ((*v160 * v202) >> 8) + 1;
              if (!BYTE1(v203))
                goto LABEL_252;
              v202 = v203 >> 8;
            }
            v204 = *v52;
            v205 = (int8x16_t)vmulq_n_f32(*v52, (float)v202 * *((float *)v69 + 159));
            if (*(float *)&v205.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v206 = 1.0;
LABEL_251:
                v204.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v207 = vextq_s8(v205, v205, 4uLL).u64[0];
                v208 = PDAlightenPDA(v25->f32[0], *(double *)v204.i64, v46, v47, v206, *(double *)v205.i64, v207, v51, *(float *)v205.i32, COERCE_DOUBLE(__PAIR64__(v205.u32[3], HIDWORD(v207))), *(float *)&v205.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v208;
                v25->i32[1] = v209;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_252;
              }
              LODWORD(v47) = v25->i32[3];
              v206 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_251;
              *v25 = (float32x4_t)v205;
            }
          }
LABEL_252:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v201)
            goto LABEL_361;
        }
      case 0x12u:
        v332 = v30;
        v333 = v29;
        v210 = v4;
        v160 = v34;
        while (1)
        {
          v211 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v212 = *v160 * v211 + ((*v160 * v211) >> 8) + 1;
              if (!BYTE1(v212))
                goto LABEL_265;
              v211 = v212 >> 8;
            }
            v213 = *v52;
            v214 = (int8x16_t)vmulq_n_f32(*v52, (float)v211 * *((float *)v69 + 159));
            if (*(float *)&v214.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v215 = 1.0;
LABEL_264:
                v213.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v216 = vextq_s8(v214, v214, 4uLL).u64[0];
                v217 = PDAcolordodgePDA(v25->f32[0], *(double *)v213.i64, v46, v47, v215, *(double *)v214.i64, v216, v51, *(float *)v214.i32, COERCE_DOUBLE(__PAIR64__(v214.u32[3], HIDWORD(v216))), *(float *)&v214.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v217;
                v25->i32[1] = v218;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_265;
              }
              LODWORD(v47) = v25->i32[3];
              v215 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_264;
              *v25 = (float32x4_t)v214;
            }
          }
LABEL_265:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v210)
            goto LABEL_361;
        }
      case 0x13u:
        v332 = v30;
        v333 = v29;
        v219 = v4;
        v160 = v34;
        while (1)
        {
          v220 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v221 = *v160 * v220 + ((*v160 * v220) >> 8) + 1;
              if (!BYTE1(v221))
                goto LABEL_278;
              v220 = v221 >> 8;
            }
            v222 = *v52;
            v223 = (int8x16_t)vmulq_n_f32(*v52, (float)v220 * *((float *)v69 + 159));
            if (*(float *)&v223.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v224 = 1.0;
LABEL_277:
                v222.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v225 = vextq_s8(v223, v223, 4uLL).u64[0];
                v226 = PDAcolorburnPDA(v25->f32[0], *(double *)v222.i64, v46, v47, v224, *(double *)v223.i64, v225, v51, *(float *)v223.i32, COERCE_DOUBLE(__PAIR64__(v223.u32[3], HIDWORD(v225))), *(float *)&v223.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v226;
                v25->i32[1] = v227;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_278;
              }
              LODWORD(v47) = v25->i32[3];
              v224 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_277;
              *v25 = (float32x4_t)v223;
            }
          }
LABEL_278:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v219)
            goto LABEL_361;
        }
      case 0x14u:
        v332 = v30;
        v333 = v29;
        v228 = v4;
        v160 = v34;
        while (1)
        {
          v229 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v230 = *v160 * v229 + ((*v160 * v229) >> 8) + 1;
              if (!BYTE1(v230))
                goto LABEL_291;
              v229 = v230 >> 8;
            }
            v231 = (int8x16_t)vmulq_n_f32(*v52, (float)v229 * *((float *)v69 + 159));
            if (*(float *)&v231.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                LODWORD(v48) = 1.0;
LABEL_290:
                LODWORD(v46) = v25->i32[2];
                DWORD2(v320) = v231.i32[3];
                *(_QWORD *)&v320 = vextq_s8(v231, v231, 4uLL).u64[0];
                v232 = PDAsoftlightPDA(v25->f32[0], v25->f32[1], v46, *(int32x2_t *)&v47, v48, *(double *)v231.i64, *(double *)&v320, v51, v38, v39, v40, v41, v42, v43, v44, v45, *(float *)v231.i32, v320, *(uint64_t *)((char *)&v320 + 4),
                         *(float *)&v231.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v232;
                v25->i32[1] = v233;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_291;
              }
              LODWORD(v47) = v25->i32[3];
              LODWORD(v48) = LODWORD(v47);
              if (*(float *)&v47 > 0.0)
                goto LABEL_290;
              *v25 = (float32x4_t)v231;
            }
          }
LABEL_291:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v228)
            goto LABEL_361;
        }
      case 0x15u:
        v332 = v30;
        v333 = v29;
        v234 = v4;
        v160 = v34;
        while (1)
        {
          v235 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v236 = *v160 * v235 + ((*v160 * v235) >> 8) + 1;
              if (!BYTE1(v236))
                goto LABEL_304;
              v235 = v236 >> 8;
            }
            v237 = *v52;
            v238 = (int8x16_t)vmulq_n_f32(*v52, (float)v235 * *((float *)v69 + 159));
            if (*(float *)&v238.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v239 = 1.0;
LABEL_303:
                v237.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(_QWORD *)&v240 = vextq_s8(v238, v238, 4uLL).u64[0];
                v241 = PDAhardlightPDA(v25->f32[0], *(double *)v237.i64, v46, v47, v239, *(double *)v238.i64, v240, v51, *(float *)v238.i32, COERCE_DOUBLE(__PAIR64__(v238.u32[3], HIDWORD(v240))), *(float *)&v238.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v241;
                v25->i32[1] = v242;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_304;
              }
              LODWORD(v47) = v25->i32[3];
              v239 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_303;
              *v25 = (float32x4_t)v238;
            }
          }
LABEL_304:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v234)
            goto LABEL_361;
        }
      case 0x16u:
        v243 = v4;
        v98 = v34;
        while (1)
        {
          v244 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v245 = *v98 * v244 + ((*v98 * v244) >> 8) + 1;
              if (!BYTE1(v245))
                goto LABEL_319;
              v244 = v245 >> 8;
            }
            v246 = vmulq_n_f32(*v52, (float)v244 * 0.0039216);
            if (v246.f32[3] > 0.0)
            {
              if (!v340)
              {
                v247 = 1.0;
LABEL_316:
                v248 = v25->f32[2];
                v249 = vmul_laneq_f32(*(float32x2_t *)v25->f32, v246, 3);
                v250 = vmul_n_f32(*(float32x2_t *)v246.f32, v247);
                v251 = vsub_f32(vadd_f32(*(float32x2_t *)v25->f32, *(float32x2_t *)v246.f32), v249);
                v252 = vsub_f32(v249, v250);
                v253 = vadd_f32(vsub_f32(v251, v250), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v252), (int8x8_t)vneg_f32(v252), (int8x8_t)v252));
                v254 = v248 + v246.f32[2];
                v255 = v248 * v246.f32[3];
                v256 = vmuls_lane_f32(v247, v246, 2);
                v257 = v254 - v255;
                v258 = v255 - v256;
                v246.f32[0] = v257 - v256;
                if (v258 < 0.0)
                  v258 = -v258;
                *(float32x2_t *)v25->f32 = v253;
                v25->f32[2] = v246.f32[0] + v258;
                v25->f32[3] = (float)(v247 + v246.f32[3]) - (float)(v247 * v246.f32[3]);
                goto LABEL_319;
              }
              v247 = v25->f32[3];
              if (v247 > 0.0)
                goto LABEL_316;
              *v25 = v246;
            }
          }
LABEL_319:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v243)
            goto LABEL_334;
        }
      case 0x17u:
        v259 = &v52->f32[2];
        v260 = v4;
        v98 = v34;
        do
        {
          v261 = *v53;
          if (!*v53)
            goto LABEL_333;
          if (v34)
          {
            v262 = *v98 * v261 + ((*v98 * v261) >> 8) + 1;
            if (!BYTE1(v262))
              goto LABEL_333;
            v261 = v262 >> 8;
          }
          v263 = (float)v261 * 0.0039216;
          v264 = v263 * v259[1];
          if (v264 > 0.0)
          {
            v265 = vmul_n_f32(*(float32x2_t *)(v259 - 2), v263);
            v266 = v263 * *v259;
            if (v340)
            {
              v267 = v25->f32[3];
              if (v267 <= 0.0)
              {
                *(float32x2_t *)v25->f32 = v265;
LABEL_332:
                v25->f32[2] = v266;
                v25->f32[3] = v264;
                goto LABEL_333;
              }
            }
            else
            {
              v267 = 1.0;
            }
            v266 = (float)(v266 + v25->f32[2]) + (float)((float)(v266 * v25->f32[2]) * -2.0);
            *(float32x2_t *)v25->f32 = vmla_f32(vadd_f32(v265, *(float32x2_t *)v25->f32), (float32x2_t)0xC0000000C0000000, vmul_f32(v265, *(float32x2_t *)v25->f32));
            v264 = (float)(v264 + v267) - (float)(v267 * v264);
            goto LABEL_332;
          }
LABEL_333:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v259 += 4;
          --v260;
        }
        while (v260);
LABEL_334:
        v34 = &v98[v331];
LABEL_335:
        v25 += v335;
LABEL_363:
        v77 = v339;
LABEL_364:
        v284 = v77 - 1;
        if (!v284)
        {
          v31 = v338;
          goto LABEL_415;
        }
        v339 = v284;
        v37 = 0;
        v32 = ((_DWORD)v337 + 1);
        v29 += *(_QWORD *)(a2 + 128);
        v30 += *(_QWORD *)(a2 + 136);
        v285 = v338;
        if (!v338)
          continue;
        v35 = v326;
LABEL_425:
        v31 = v285;
        do
        {
          while (1)
          {
            v316 = *((unsigned int *)v34 - 4);
            v317 = v316 - v32;
            if ((int)v316 <= (int)v32)
              break;
            v339 -= v317;
            if (v339 < 1)
              goto LABEL_415;
            v29 += *(_QWORD *)(a2 + 128) * v317;
            v30 += *(_QWORD *)(a2 + 136) * v317;
            v25 += v325 * v317;
            v32 = v316;
          }
          if ((int)v32 < *((_DWORD *)v34 - 3) + (int)v316)
            goto LABEL_12;
          v318 = v32;
          v319 = shape_enum_clip_scan((uint64_t)v31, (_DWORD *)v34 - 4);
          v32 = v318;
        }
        while (v319);
LABEL_415:
        if (v31)
          free(v31);
LABEL_417:
        if (v327)
          free(v327);
        return;
      case 0x18u:
        v332 = v30;
        v333 = v29;
        v268 = v4;
        v160 = v34;
        while (1)
        {
          v269 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v270 = *v160 * v269 + ((*v160 * v269) >> 8) + 1;
              if (!BYTE1(v270))
                goto LABEL_347;
              v269 = v270 >> 8;
            }
            v271 = (int8x16_t)vmulq_n_f32(*v52, (float)v269 * *((float *)v69 + 159));
            if (*(float *)&v271.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v272 = 1.0;
LABEL_346:
                *(_QWORD *)&v321 = vextq_s8(v271, v271, 4uLL).u64[0];
                v273 = PDAhuePDA(v25->f32[0], v25->f32[1], v25->f32[2], v47, v272, *(double *)v271.i64, v321, v51, *(float *)v271.i32, *(float *)&v321, *((float *)&v321 + 1), *(float *)&v271.i32[3], *(float *)&v271.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v273;
                v25->i32[1] = v274;
                v25->i32[2] = v275;
                v25->i32[3] = LODWORD(v47);
                goto LABEL_347;
              }
              LODWORD(v47) = v25->i32[3];
              v272 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_346;
              *v25 = (float32x4_t)v271;
            }
          }
LABEL_347:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v268)
            goto LABEL_361;
        }
      case 0x19u:
        v332 = v30;
        v333 = v29;
        v276 = v4;
        v160 = v34;
        while (1)
        {
          v277 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v278 = *v160 * v277 + ((*v160 * v277) >> 8) + 1;
              if (!BYTE1(v278))
                goto LABEL_360;
              v277 = v278 >> 8;
            }
            v279 = (int8x16_t)vmulq_n_f32(*v52, (float)v277 * *((float *)v69 + 159));
            if (*(float *)&v279.i32[3] > 0.0)
            {
              if (!v340)
              {
                LODWORD(v47) = v25->i32[3];
                v280 = 1.0;
LABEL_359:
                *(_QWORD *)&v322 = vextq_s8(v279, v279, 4uLL).u64[0];
                v281 = PDAsaturationPDA(v25->f32[0], v25->f32[1], v25->f32[2], v47, v280, *(double *)v279.i64, v322, v51, *(float *)v279.i32, *(float *)&v322, *((float *)&v322 + 1), *(float *)&v279.i32[3], *(float *)&v279.i32[3]);
                v69 = &xmmword_185005000;
                v25->f32[0] = v281;
                v25->i32[1] = v282;
                v25->i32[2] = v283;
                v25->i32[3] = LODWORD(v47);
                goto LABEL_360;
              }
              LODWORD(v47) = v25->i32[3];
              v280 = *(float *)&v47;
              if (*(float *)&v47 > 0.0)
                goto LABEL_359;
              *v25 = (float32x4_t)v279;
            }
          }
LABEL_360:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v276)
          {
LABEL_361:
            v34 = &v160[v331];
LABEL_362:
            v25 += v335;
            v36 = v330;
            v30 = v332;
            v29 = v333;
            goto LABEL_363;
          }
        }
      case 0x1Au:
        v332 = v30;
        v333 = v29;
        v286 = v4;
        v287 = v34;
        while (1)
        {
          v288 = *v53;
          if (*v53)
          {
            if (v34)
            {
              v289 = *v287 * v288 + ((*v287 * v288) >> 8) + 1;
              if (!BYTE1(v289))
                goto LABEL_378;
              v288 = v289 >> 8;
            }
            v290 = vmulq_n_f32(*v52, (float)v288 * *((float *)v69 + 159));
            LODWORD(v47) = v290.i32[3];
            if (v290.f32[3] > 0.0)
            {
              if (!v340)
              {
                v291 = v25->f32[3];
                LODWORD(v49) = 1.0;
LABEL_377:
                LODWORD(v50) = v25->i32[2];
                v292 = PDAluminosityPDA(v290.f32[0], v290.f32[1], v290.f32[2], v47, v290.f32[3], v49, v50, v51, COERCE_FLOAT(v25->i64[0]), COERCE_FLOAT(HIDWORD(v25->i64[0])), *(float *)&v50, v291, *(float *)&v49);
                v69 = &xmmword_185005000;
                v25->f32[0] = v292;
                v25->i32[1] = v293;
                v25->i32[2] = v294;
                v25->i32[3] = LODWORD(v47);
                goto LABEL_378;
              }
              v291 = v25->f32[3];
              *(float *)&v49 = v291;
              if (v291 > 0.0)
                goto LABEL_377;
              *v25 = v290;
            }
          }
LABEL_378:
          ++v53;
          ++v52;
          v287 += v34 != 0;
          ++v25;
          if (!--v286)
            goto LABEL_392;
        }
      case 0x1Bu:
        v332 = v30;
        v333 = v29;
        v287 = v34;
        v295 = v4;
        break;
      default:
        goto LABEL_363;
    }
    break;
  }
  while (1)
  {
    v296 = *v53;
    if (*v53)
    {
      if (v34)
      {
        v297 = *v287 * v296 + ((*v287 * v296) >> 8) + 1;
        if (!BYTE1(v297))
          goto LABEL_391;
        v296 = v297 >> 8;
      }
      v298 = (int8x16_t)vmulq_n_f32(*v52, (float)v296 * *((float *)v69 + 159));
      if (*(float *)&v298.i32[3] > 0.0)
      {
        if (!v340)
        {
          LODWORD(v47) = v25->i32[3];
          v299 = 1.0;
LABEL_390:
          *(_QWORD *)&v323 = vextq_s8(v298, v298, 4uLL).u64[0];
          v300 = PDAluminosityPDA(v25->f32[0], v25->f32[1], v25->f32[2], v47, v299, *(double *)v298.i64, v323, v51, *(float *)v298.i32, *(float *)&v323, *((float *)&v323 + 1), *(float *)&v298.i32[3], *(float *)&v298.i32[3]);
          v69 = &xmmword_185005000;
          v25->f32[0] = v300;
          v25->i32[1] = v301;
          v25->i32[2] = v302;
          v25->i32[3] = LODWORD(v47);
          goto LABEL_391;
        }
        LODWORD(v47) = v25->i32[3];
        v299 = *(float *)&v47;
        if (*(float *)&v47 > 0.0)
          goto LABEL_390;
        *v25 = (float32x4_t)v298;
      }
    }
LABEL_391:
    ++v53;
    ++v52;
    v287 += v34 != 0;
    ++v25;
    if (!--v295)
    {
LABEL_392:
      v34 = &v287[v331];
      goto LABEL_362;
    }
  }
}

uint64_t RGBAf_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  _BOOL8 v8;
  signed int v9;
  __n128 v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  _BYTE v18[36];
  char v19;
  _QWORD v20[483];

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E0C80C00];
  v7 = *(int **)v2;
  v8 = !*((_QWORD *)v3 + 12) && !*(_QWORD *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v9 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) != 0x3000000)
  {
    if (v13)
      goto LABEL_22;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(v5 + 16))
  {
    v12 = RGBAf_shade_radial_RGB;
  }
  else if (*(_QWORD *)(v5 + 24))
  {
    v12 = RGBAf_shade_conic_RGB;
  }
  else if (v16 < 2)
  {
    v12 = RGBAf_shade_axial_RGB;
  }
  else
  {
    v12 = RGBAf_shade_custom_RGB;
  }
  v13 = v12;
LABEL_22:
  v14 = *v7;
  v15 = v14;
  RGBAf_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17))
    free(v17);
  return 1;
}

void RGBAf_shade_radial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int32x2_t v4;
  float *v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  float v20;
  float v21;
  float v22;
  float v23;
  char *v24;
  float32x2_t *v25;
  uint64_t v26;
  float32x2_t *v27;
  float *v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float v32;
  int v33;
  int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float *i;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  BOOL v47;
  float v48;
  uint64_t v50;
  float v51;
  int v52;
  float v53;
  float32x2_t *v54;
  float v55;
  float32x2_t v56;
  float v57;
  char v58;
  float v59;
  float v60;
  float v61;
  float32x2_t *v62;
  uint64_t v63;
  int v64;
  float v69;
  float v70;
  float v71;
  float v73;
  float v74;
  float v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v79;
  float v80;
  float v81;
  float32x2_t v82;
  float v83;
  uint64_t v84;
  float32x2_t v85;
  float32x2_t *v86;
  float32x2_t v87;
  float v88;
  uint64_t v89;
  float v90;
  float v91;
  float32x2_t v92;
  float32x2_t *v93;
  float v94;
  float v95;
  char v96;
  char v97;
  float32x2_t *v98;
  float v99;
  float v100;
  float v101;
  uint64_t v102;
  float32x2_t *v103;
  float v104;
  float32x2_t *v105;
  float v106;
  float v107;
  float v108;
  float32x2_t v109;
  int v110;

  v6 = *(float **)(a1 + 400);
  v7 = *(float *)(a1 + 280);
  v8 = *(float *)(a1 + 284);
  v9 = *(float **)(a1 + 272);
  v10 = v9[1];
  v11 = v10 * (float)a2;
  v12 = v10 * (float)a3;
  v13 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v12) + (float)(v7 * v11));
  v14 = *(float *)(a1 + 300) + (float)((float)(v12 * *(float *)(a1 + 292)) + (float)(v8 * v11));
  v15 = *(float *)(a1 + 336);
  v16 = *(float *)(a1 + 344);
  v17 = *(float *)(a1 + 304);
  v18 = *(float *)(a1 + 308);
  v19 = *(unsigned int *)(a1 + 324);
  v20 = v6[2];
  v21 = v6[4];
  v22 = v6[5];
  v23 = v6[7];
  v26 = a1 + 144;
  v24 = *(char **)(a1 + 144);
  v25 = *(float32x2_t **)(v26 + 8);
  v27 = *(float32x2_t **)(a1 + 384);
  v28 = *(float **)(a1 + 392);
  if (!v28)
    v28 = v9;
  v29 = *(_QWORD *)(a1 + 32);
  v30 = *(_QWORD *)(a1 + 40);
  if (v30)
    v9 = *(float **)(a1 + 40);
  if (v20 != 0.0 || v23 != 0.0 || v8 != 0.0)
  {
    v34 = *(_DWORD *)(a1 + 320);
    v35 = v6[3];
    v36 = v6[8];
    v37 = -v6[6];
    v38 = v18 - v17;
    for (i = (float *)&v25[1] + 1; ; i += 4)
    {
      v40 = v37 + (float)((float)(v13 + v13) * v20);
      v41 = (float)((float)(v14 * v14) + (float)(v13 * v13)) - v23;
      if (v22 == 0.0)
      {
        v48 = v41 / v40;
      }
      else
      {
        v42 = (float)((float)(v22 * -4.0) * v41) + (float)(v40 * v40);
        if (v42 < 0.0)
          goto LABEL_48;
        v43 = sqrtf(v42);
        v44 = v36 * (float)(v40 - v43);
        v45 = v40 + v43;
        v46 = v36 * v45;
        v47 = (float)(v36 * v45) <= v44;
        if ((float)(v36 * v45) <= v44)
          v48 = v36 * v45;
        else
          v48 = v44;
        if (v47)
          v46 = v44;
        if (v46 < 0.0)
        {
          _NF = v46 < v35;
LABEL_29:
          LODWORD(v50) = v34;
          if (_NF)
            goto LABEL_48;
LABEL_30:
          if ((v50 & 0x80000000) == 0)
            goto LABEL_42;
          goto LABEL_48;
        }
        if (v46 <= 1.0)
        {
          v51 = v17 + (float)(v46 * v38);
          goto LABEL_41;
        }
        if ((v19 & 0x80000000) == 0)
        {
          LODWORD(v50) = v19;
          if (v46 <= v21)
          {
LABEL_42:
            v52 = 3 * v50;
            v50 = v50;
            if (!v30)
              v50 = 0;
            v53 = v9[v50];
            v54 = (float32x2_t *)(v29 + 4 * v52);
            if (v30)
              v55 = v53;
            else
              v55 = 1.0;
            v56 = vmul_n_f32(*v54, v55);
            v57 = v55 * v54[1].f32[0];
            goto LABEL_50;
          }
        }
      }
      if (v48 < 0.0)
      {
        _NF = v48 < v35;
        goto LABEL_29;
      }
      if (v48 > 1.0)
      {
        LODWORD(v50) = v19;
        if (v48 > v21)
          goto LABEL_48;
        goto LABEL_30;
      }
      v51 = v17 + (float)(v48 * v38);
LABEL_41:
      LODWORD(v50) = (int)(float)(v16 * (float)(v51 - v15));
      if ((v50 & 0x80000000) == 0)
        goto LABEL_42;
LABEL_48:
      if (!v27)
      {
        v58 = 0;
        goto LABEL_52;
      }
      v53 = *v28;
      v56 = vmul_n_f32(*v27, *v28);
      v57 = *v28 * v27[1].f32[0];
LABEL_50:
      *(float32x2_t *)(i - 3) = v56;
      *(i - 1) = v57;
      *i = v53;
      v58 = -1;
LABEL_52:
      v13 = v7 + v13;
      v14 = v8 + v14;
      *v24++ = v58;
      if (!--a4)
        return;
    }
  }
  v31 = v14 * v14;
  v32 = -v22;
  if (v31 <= (float)-v22)
  {
    v59 = fabsf(v6[8]);
    v60 = v22 * -4.0;
    v61 = v18 - v17;
    v62 = (float32x2_t *)(v29 + 12 * (int)v19);
    if (v30)
      v63 = v19;
    else
      v63 = 0;
    v64 = a4 + 2;
    __asm { FMOV            V19.2S, #1.0 }
    while (1)
    {
      v69 = v31 + (float)(v13 * v13);
      v70 = v7 + v13;
      v71 = v31 + (float)(v70 * v70);
      if (v69 > v32 && v71 > v32)
      {
        if ((v19 & 0x80000000) != 0)
        {
          if (!v27)
          {
            v97 = 0;
            v96 = 0;
            goto LABEL_92;
          }
          v80 = *v28;
          v82 = vmul_n_f32(*v27, *v28);
          v83 = *v28 * v27[1].f32[0];
        }
        else
        {
          v80 = v9[v63];
          if (v30)
            v81 = v9[v63];
          else
            v81 = 1.0;
          v82 = vmul_n_f32(*v62, v81);
          v83 = v81 * v62[1].f32[0];
        }
        *v25 = v82;
        v25[1].f32[0] = v83;
        v25[1].f32[1] = v80;
        goto LABEL_90;
      }
      v73 = sqrtf(v60 * v71);
      v74 = v59 * sqrtf(v60 * v69);
      v75 = v59 * v73;
      v76 = (int)(float)(v16 * (float)((float)(v17 + (float)(v74 * v61)) - v15));
      v77 = (int)(float)(v16 * (float)((float)(v17 + (float)((float)(v59 * v73) * v61)) - v15));
      if (v74 <= 1.0 && v75 <= 1.0)
      {
        v84 = (int)v76;
        if (!v30)
          v84 = 0;
        *(float *)v4.i32 = v9[v84];
        v85 = (float32x2_t)vbsl_s8((int8x8_t)vceqd_s64(v30, 0), _D19, (int8x8_t)vdup_lane_s32(v4, 0));
        v86 = (float32x2_t *)(v29 + 12 * (_DWORD)v76);
        v87 = *v86;
        v88 = v86[1].f32[0];
        v89 = (int)v77;
        if (v30)
          v90 = v9[v84];
        else
          v90 = 1.0;
        v91 = v88 * v90;
        v92 = vmul_f32(v87, v85);
        v93 = (float32x2_t *)(v29 + 12 * (_DWORD)v77);
        if (!v30)
          v89 = 0;
        v80 = v9[v89];
        v94 = v93[1].f32[0];
        if (v30)
          v95 = v9[v89];
        else
          v95 = 1.0;
        v82 = vmul_n_f32(*v93, v95);
        *v25 = v92;
        v83 = v95 * v94;
        v25[1].f32[0] = v91;
        v25[1].i32[1] = v4.i32[0];
LABEL_90:
        v96 = -1;
        goto LABEL_91;
      }
      if (v74 <= 1.0)
      {
        if ((v76 & 0x80000000) == 0)
        {
          v79 = 3 * (int)v76;
          if (!v30)
            v76 = 0;
LABEL_97:
          v98 = (float32x2_t *)(v29 + 4 * v79);
          v99 = v9[v76];
          if (v30)
            v100 = v9[v76];
          else
            v100 = 1.0;
          v4 = (int32x2_t)vmul_n_f32(*v98, v100);
          v101 = v100 * v98[1].f32[0];
          goto LABEL_103;
        }
      }
      else if (v74 <= v21)
      {
        v76 = v63;
        v79 = 3 * (int)v19;
        if ((v19 & 0x80000000) == 0)
          goto LABEL_97;
      }
      if (!v27)
      {
        v96 = 0;
        goto LABEL_104;
      }
      v99 = *v28;
      v4 = (int32x2_t)vmul_n_f32(*v27, *v28);
      v101 = *v28 * v27[1].f32[0];
LABEL_103:
      *v25 = (float32x2_t)v4;
      v96 = -1;
      v25[1].f32[0] = v101;
      v25[1].f32[1] = v99;
LABEL_104:
      if (v75 <= 1.0)
      {
        if ((v77 & 0x80000000) != 0)
          goto LABEL_115;
        v102 = 3 * (int)v77;
        if (!v30)
          v77 = 0;
      }
      else if (v75 > v21 || (v77 = v63, v102 = 3 * (int)v19, (v19 & 0x80000000) != 0))
      {
LABEL_115:
        if (!v27)
        {
          v97 = 0;
          goto LABEL_92;
        }
        v80 = *v28;
        v82 = vmul_n_f32(*v27, *v28);
        v83 = *v28 * v27[1].f32[0];
        goto LABEL_91;
      }
      v103 = (float32x2_t *)(v29 + 4 * v102);
      v80 = v9[v77];
      if (v30)
        v104 = v9[v77];
      else
        v104 = 1.0;
      v82 = vmul_n_f32(*v103, v104);
      v83 = v104 * v103[1].f32[0];
LABEL_91:
      v25[2] = v82;
      v97 = -1;
      v25[3].f32[0] = v83;
      v25[3].f32[1] = v80;
LABEL_92:
      v13 = v7 + v70;
      v25 += 4;
      *v24 = v96;
      v24[1] = v97;
      v24 += 2;
      v64 -= 2;
      if (v64 <= 2)
        return;
    }
  }
  if (v27 || (v19 & 0x80000000) == 0)
  {
    if ((v19 & 0x80000000) != 0)
    {
      v106 = *v28;
      v109 = vmul_n_f32(*v27, *v28);
      v108 = *v28 * v27[1].f32[0];
    }
    else
    {
      v105 = (float32x2_t *)(v29 + 12 * (_DWORD)v19);
      if (!v30)
        v19 = 0;
      v106 = v9[v19];
      v107 = 1.0;
      if (v30)
        v107 = v9[v19];
      v108 = v107 * v105[1].f32[0];
      v109 = vmul_n_f32(*v105, v107);
    }
    v110 = a4 + 4;
    do
    {
      *v25 = v109;
      v25[1].f32[0] = v108;
      v25[1].f32[1] = v106;
      v25[2] = v109;
      v25[3].f32[0] = v108;
      v25[3].f32[1] = v106;
      v25[4] = v109;
      v25[5].f32[0] = v108;
      v25[5].f32[1] = v106;
      v25[6] = v109;
      v110 -= 4;
      v25[7].f32[0] = v108;
      v25[7].f32[1] = v106;
      v25 += 8;
      *(_DWORD *)v24 = -1;
      v24 += 4;
    }
    while (v110 > 4);
  }
  else
  {
    if (a4 >= 4)
      v33 = 4;
    else
      v33 = a4;
    bzero(v24, ((a4 - v33 + 3) & 0xFFFFFFFC) + 4);
  }
}

void RGBAf_shade_conic_RGB(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7;
  float v8;
  float v9;
  float v10;
  float32x2_t *v11;
  _BYTE *v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  uint64_t v18;
  float v19;
  unsigned int v20;
  float v21;
  uint64_t v22;
  float32x2_t *v23;
  float v24;
  float v25;
  float32x2_t *v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float v30;
  float v31;
  __n128 v32;

  v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a2));
  v8 = a1[42].f32[0];
  v9 = a1[43].f32[0];
  v10 = a1[38].f32[0];
  v12 = (_BYTE *)a1[18];
  v11 = (float32x2_t *)a1[19];
  v13 = a1[4];
  v14 = a1[5];
  if (v14)
    v15 = a1[5];
  else
    v15 = a1[34];
  v16 = a1[38].f32[1] - v10;
  do
  {
    v32 = a6;
    v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    LODWORD(v18) = vcvtms_s32_f32(v17);
    v19 = ceilf(v17);
    v20 = vcvtms_s32_f32(v9 + v17);
    if (v17 < 0.0)
      LODWORD(v18) = v20;
    v21 = ceilf(v17 - v9);
    if (v17 > v9)
      v19 = v21;
    LODWORD(v22) = (int)v19;
    v23 = (float32x2_t *)(*(_QWORD *)&v13 + 12 * (_DWORD)v18);
    v18 = (int)v18;
    if (!*(_QWORD *)&v14)
      v18 = 0;
    v24 = *(float *)(*(_QWORD *)&v15 + 4 * v18);
    v25 = v23[1].f32[0];
    v26 = (float32x2_t *)(*(_QWORD *)&v13 + 12 * (_DWORD)v22);
    v22 = (int)v22;
    if (!*(_QWORD *)&v14)
      v22 = 0;
    v27 = *(float *)(*(_QWORD *)&v15 + 4 * v22);
    v28 = *v23;
    v29 = *v26;
    v30 = v26[1].f32[0];
    if (v14)
    {
      v28 = vmul_n_f32(v28, v24);
      v25 = v24 * v25;
      v29 = vmul_n_f32(v29, v27);
      v30 = v27 * v30;
    }
    a6.n128_u64[1] = v32.n128_u64[1];
    v31 = v17 - (float)(int)floorf(v17);
    *v11 = vmla_n_f32(v28, vsub_f32(v29, v28), v31);
    v11[1].f32[0] = v25 + (float)(v31 * (float)(v30 - v25));
    v11[1].f32[1] = v24 + (float)(v31 * (float)(v27 - v24));
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v32.n128_u64[0]);
    *v12++ = -1;
    v11 += 2;
    --a4;
  }
  while (a4);
}

uint64_t RGBAf_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float32x2_t v10;
  float32x4_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  char *v16;
  float32x2_t *v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  float *v23;
  float32x4_t v24;
  float v25;
  float32x2_t v26;
  float v27;
  int v28;
  float v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  float32x2_t *v33;
  float v34;
  char v35;

  v6 = *(_QWORD *)(result + 272);
  v7 = *(float *)(v6 + 4);
  v8 = v7 * (float)a2;
  v9 = v7 * (float)a3;
  v10 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), v9), v10, v8));
  v11 = *(float32x4_t *)(result + 304);
  v12 = *(float *)(result + 336);
  v13 = *(float *)(result + 348);
  v14 = *(float *)(result + 344);
  v15 = *(float *)(result + 356);
  v16 = *(char **)(result + 144);
  v17 = *(float32x2_t **)(result + 384);
  v18 = *(float **)(result + 392);
  if (!v18)
    v18 = *(float **)(result + 272);
  v19 = *(_QWORD *)(result + 32);
  v20 = *(_QWORD *)(result + 40);
  if (v20)
    v21 = *(_DWORD *)(result + 48);
  else
    v21 = 0;
  if (v20)
    v6 = *(_QWORD *)(result + 40);
  v22 = 3 * *(_DWORD *)(result + 48);
  v23 = (float *)(*(_QWORD *)(result + 152) + 12);
  do
  {
    v24 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v11, v24))), vmovn_s32(vcgtq_f32(v24, v11))), 0xFuLL))) & 1) == 0)
    {
      v28 = (int)(float)(v15 * (float)(*(float *)&a6.i32[1] - v13));
      v29 = v14 * (float)(*(float *)a6.i32 - v12);
      v30 = v19 + 4 * v22 * v28;
      v31 = 3 * (int)v29;
      v32 = v6 + 4 * v21 * v28;
      result = (int)v29;
      if (!v20)
        result = 0;
      v25 = *(float *)(v32 + 4 * result);
      v33 = (float32x2_t *)(v30 + 4 * v31);
      if (v20)
        v34 = v25;
      else
        v34 = 1.0;
      v26 = vmul_n_f32(*v33, v34);
      v27 = v34 * v33[1].f32[0];
      goto LABEL_18;
    }
    if (v17)
    {
      v25 = *v18;
      v26 = vmul_n_f32(*v17, *v18);
      v27 = *v18 * v17[1].f32[0];
LABEL_18:
      *(float32x2_t *)(v23 - 3) = v26;
      *(v23 - 1) = v27;
      *v23 = v25;
      v35 = -1;
      goto LABEL_20;
    }
    v35 = 0;
LABEL_20:
    *(float32x2_t *)a6.i8 = vadd_f32(v10, *(float32x2_t *)a6.i8);
    *v16++ = v35;
    v23 += 4;
    --a4;
  }
  while (a4);
  return result;
}

void RGBAf_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  int v13;
  _DWORD *v14;
  float32x2_t *v15;
  uint64_t v16;
  float32x2_t *v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  int v22;
  float *i;
  uint64_t v24;
  int v25;
  float v26;
  float32x2_t *v27;
  float v28;
  float32x2_t v29;
  float v30;
  char v31;
  float32x2_t *v32;
  float v33;
  float v34;
  float32x2_t v35;
  float v36;
  int v37;

  v5 = *(float *)(a1 + 280);
  v6 = *(float **)(a1 + 272);
  v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  v8 = *(float *)(a1 + 336);
  v9 = *(float *)(a1 + 344);
  v10 = *(float *)(a1 + 304);
  v11 = *(float *)(a1 + 308);
  LODWORD(v12) = *(_DWORD *)(a1 + 320);
  v13 = *(_DWORD *)(a1 + 324);
  v16 = a1 + 144;
  v14 = *(_DWORD **)(a1 + 144);
  v15 = *(float32x2_t **)(v16 + 8);
  v17 = *(float32x2_t **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v18 = *(float **)(a1 + 392);
  else
    v18 = v6;
  v20 = *(_QWORD *)(a1 + 32);
  v19 = *(_QWORD *)(a1 + 40);
  if (v19)
    v21 = *(float **)(a1 + 40);
  else
    v21 = v6;
  if (v5 != 0.0)
  {
    for (i = (float *)&v15[1] + 1; ; i += 4)
    {
      LODWORD(v24) = v12;
      if (v7 >= v10)
      {
        LODWORD(v24) = v13;
        if (v7 <= v11)
          LODWORD(v24) = (int)(float)(v9 * (float)(v7 - v8));
      }
      if ((v24 & 0x80000000) != 0)
      {
        if (!v17)
        {
          v31 = 0;
          goto LABEL_31;
        }
        v26 = *v18;
        v29 = vmul_n_f32(*v17, *v18);
        v30 = *v18 * v17[1].f32[0];
      }
      else
      {
        v25 = 3 * v24;
        v24 = v24;
        if (!v19)
          v24 = 0;
        v26 = v21[v24];
        v27 = (float32x2_t *)(v20 + 4 * v25);
        if (v19)
          v28 = v26;
        else
          v28 = 1.0;
        v29 = vmul_n_f32(*v27, v28);
        v30 = v28 * v27[1].f32[0];
      }
      *(float32x2_t *)(i - 3) = v29;
      *(i - 1) = v30;
      *i = v26;
      v31 = -1;
LABEL_31:
      v7 = v5 + v7;
      *(_BYTE *)v14 = v31;
      v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4)
        return;
    }
  }
  if (v7 >= v10)
  {
    LODWORD(v12) = v13;
    if (v7 <= v11)
      LODWORD(v12) = (int)(float)(v9 * (float)(v7 - v8));
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      v33 = *v18;
      v35 = vmul_n_f32(*v17, *v18);
      v36 = *v18 * v17[1].f32[0];
    }
    else
    {
      v32 = (float32x2_t *)(v20 + 12 * (_DWORD)v12);
      v12 = v12;
      if (!v19)
        v12 = 0;
      v33 = v21[v12];
      v34 = 1.0;
      if (v19)
        v34 = v21[v12];
      v35 = vmul_n_f32(*v32, v34);
      v36 = v34 * v32[1].f32[0];
    }
    v37 = a4 + 4;
    do
    {
      *v15 = v35;
      v15[1].f32[0] = v36;
      v15[1].f32[1] = v33;
      v15[2] = v35;
      v15[3].f32[0] = v36;
      v15[3].f32[1] = v33;
      v15[4] = v35;
      v15[5].f32[0] = v36;
      v15[5].f32[1] = v33;
      v15[6] = v35;
      v37 -= 4;
      v15[7].f32[0] = v36;
      v15[7].f32[1] = v33;
      v15 += 8;
      *v14++ = -1;
    }
    while (v37 > 4);
  }
  else
  {
    if (a4 >= 4)
      v22 = 4;
    else
      v22 = a4;
    bzero(v14, ((a4 - v22 + 3) & 0xFFFFFFFC) + 4);
  }
}

int8x16_t *RGBAF_pattern(uint64_t a1, int8x16_t *a2, unsigned int a3, int a4, uint64_t a5, float a6, double a7, double a8, double a9, double a10, int8x16_t a11)
{
  unsigned __int32 *v14;
  int8x16_t *v15;
  float v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  int8x16_t *v20;
  unint64_t v22;
  double v23;

  v14 = *(unsigned __int32 **)(*(_QWORD *)a1 + 64);
  a11.i32[0] = *v14;
  LODWORD(a10) = v14[1];
  if (a2 && a3 > 0xF
    || (v22 = a11.i64[0],
        v23 = a10,
        v15 = (int8x16_t *)malloc_type_malloc(0x40uLL, 0x705560E0uLL),
        a11.i64[0] = v22,
        a10 = v23,
        (a2 = v15) != 0))
  {
    if (*(float *)a11.i32 <= a6)
      v16 = a6;
    else
      v16 = *(float *)a11.i32;
    if (*(float *)&a10 < a6)
      v16 = *(float *)&a10;
    if (a5)
      v17 = a4;
    else
      v17 = 0;
    switch(v17)
    {
      case 1:
        *(float *)a11.i32 = v16 * *(float *)a5;
        break;
      case 4:
        LODWORD(a7) = *(_DWORD *)(a5 + 16);
        *(float *)a11.i32 = v16 * (float)((float)(*(float *)&a10 - *(float *)a5) - *(float *)&a7);
        v18 = vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a10, 0), *(float32x2_t *)(a5 + 4)), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0));
        goto LABEL_19;
      case 3:
        *(float *)a11.i32 = v16 * *(float *)a5;
        v18 = *(float32x2_t *)(a5 + 4);
LABEL_19:
        v19 = vmul_n_f32(v18, v16);
        goto LABEL_20;
    }
    v19 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a11.i8, 0);
LABEL_20:
    *a2 = (int8x16_t)xmmword_185004D40;
    a2[1].i32[2] = 0;
    a2[1].i64[0] = 1;
    a11.i32[1] = v19.i32[0];
    a11.i64[1] = __PAIR64__(LODWORD(v16), v19.u32[1]);
    a2[3] = vrev32q_s8(a11);
    if (v16 >= *(float *)&a10)
      v20 = 0;
    else
      v20 = a2 + 3;
    a2[2].i64[0] = (uint64_t)a2[3].i64;
    a2[2].i64[1] = (uint64_t)v20;
  }
  return a2;
}

uint64_t RGBAF_mark(uint64_t a1, __n128 a2)
{
  return RGBAF_mark_inner(*(_QWORD *)(*(_QWORD *)a1 + 56), a2);
}

uint64_t RGBAF_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  __n128 v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint16x4_t *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  float32x4_t v30;
  float v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  _BYTE *v35;
  _BYTE *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  unsigned int v49;
  size_t v50;
  _BYTE *v51;
  uint64_t v52;
  BOOL v53;
  unint64_t v54;
  unint64_t v55;
  int8x16_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int8x16_t v63;
  int8x16_t v64;
  __n128 v65;
  double v66;
  double v67;
  double v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  int v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unsigned int v90;
  float v91;
  float32x4_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  float v100;
  unsigned int v101;
  float32x4_t v102;
  unsigned int v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  float v112;
  unsigned int v113;
  float32x4_t v114;
  unsigned int v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  int v123;
  int v124;
  float32x4_t v125;
  float32x4_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  float v135;
  float v136;
  float v137;
  unsigned int v138;
  unsigned int v139;
  int8x8_t v140;
  unsigned int v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  uint64_t v147;
  int v148;
  int v149;
  float v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  unint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  float v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  int v166;
  int v167;
  float32x4_t v168;
  float32x4_t v169;
  unint64_t v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t v173;
  unint64_t v174;
  uint64_t v175;
  int v176;
  int v177;
  float32x4_t v178;
  float32x4_t v179;
  unint64_t v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t v183;
  unint64_t v184;
  uint64_t v185;
  int v186;
  int v187;
  float v188;
  float32x2_t v189;
  float32x2_t v190;
  float v191;
  float v192;
  float32x2_t v193;
  float v194;
  int8x16_t v195;
  unint64_t v196;
  uint64_t v197;
  unint64_t v198;
  uint64_t v199;
  unint64_t v200;
  uint64_t v201;
  int v202;
  int v203;
  float v204;
  float v205;
  int8x16_t v206;
  float v207;
  unint64_t v208;
  uint64_t v209;
  unint64_t v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  int v214;
  int v215;
  float v216;
  int v217;
  int8x8_t v218;
  __int128 v219;
  int8x16_t v220;
  __int32 v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  uint64_t v225;
  unint64_t v226;
  uint64_t v227;
  int v228;
  int v234;
  float v235;
  float v236;
  float v237;
  unsigned int v238;
  unsigned int v239;
  float32x2_t v240;
  unsigned int v241;
  unint64_t v242;
  uint64_t v243;
  unint64_t v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  int v248;
  int v249;
  float v250;
  int v251;
  int8x8_t v252;
  __int128 v253;
  int8x16_t v254;
  __int32 v255;
  unint64_t v256;
  uint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  int v262;
  int v263;
  float v264;
  int v265;
  int8x8_t v266;
  __int128 v267;
  int8x16_t v268;
  __int32 v269;
  unint64_t v270;
  uint64_t v271;
  unint64_t v272;
  uint64_t v273;
  unint64_t v274;
  uint64_t v275;
  int v276;
  int v277;
  float v278;
  int v279;
  int8x8_t v280;
  __int128 v281;
  int8x16_t v282;
  __int32 v283;
  unint64_t v284;
  uint64_t v285;
  unint64_t v286;
  uint64_t v287;
  unint64_t v288;
  uint64_t v289;
  int v290;
  int v291;
  float v292;
  int v293;
  int8x8_t v294;
  __int128 v295;
  int8x16_t v296;
  __int32 v297;
  unint64_t v298;
  uint64_t v299;
  unint64_t v300;
  uint64_t v301;
  unint64_t v302;
  uint64_t v303;
  int v304;
  int v305;
  float v306;
  int v307;
  int8x8_t v308;
  __int128 v309;
  int8x16_t v310;
  __int32 v311;
  unint64_t v312;
  uint64_t v313;
  unint64_t v314;
  uint64_t v315;
  unint64_t v316;
  uint64_t v317;
  int v318;
  int v319;
  int v320;
  int8x8_t v321;
  int8x16_t v322;
  __int32 v323;
  unint64_t v324;
  uint64_t v325;
  unint64_t v326;
  uint64_t v327;
  unint64_t v328;
  uint64_t v329;
  int v330;
  int v331;
  float v332;
  int v333;
  int8x8_t v334;
  __int128 v335;
  int8x16_t v336;
  __int32 v337;
  unint64_t v338;
  uint64_t v339;
  unint64_t v340;
  uint64_t v341;
  unint64_t v342;
  uint64_t v343;
  int v344;
  int v345;
  float v346;
  float v347;
  float v348;
  float32x2_t v349;
  float32x4_t v350;
  float32x2_t v351;
  float32x2_t v352;
  float32x2_t v353;
  float32x2_t v354;
  float32x2_t v355;
  int8x16_t v356;
  float v357;
  float v358;
  int v359;
  unint64_t v360;
  uint64_t v361;
  unint64_t v362;
  uint64_t v363;
  unint64_t v364;
  uint64_t v365;
  int v366;
  int v367;
  float v368;
  float v369;
  float v370;
  float v371;
  unsigned int v372;
  unsigned int v373;
  float32x2_t v374;
  float32x2_t v375;
  unsigned int v376;
  unint64_t v377;
  uint64_t v378;
  unint64_t v379;
  uint64_t v380;
  unint64_t v381;
  uint64_t v382;
  int v383;
  int v384;
  float v385;
  int v386;
  int8x8_t v387;
  int8x16_t v388;
  __int32 v389;
  unsigned int v390;
  unint64_t v391;
  uint64_t v392;
  unint64_t v393;
  uint64_t v394;
  unint64_t v395;
  uint64_t v396;
  int v397;
  int v398;
  float v399;
  int v400;
  int8x8_t v401;
  int8x16_t v402;
  __int32 v403;
  unsigned int v404;
  unint64_t v405;
  uint64_t v406;
  unint64_t v407;
  uint64_t v408;
  unint64_t v409;
  uint64_t v410;
  int v411;
  int v412;
  float v413;
  int v414;
  int8x16_t v415;
  int8x16_t v416;
  __int32 v417;
  unsigned int v418;
  unint64_t v419;
  uint64_t v420;
  unint64_t v421;
  uint64_t v422;
  unint64_t v423;
  uint64_t v424;
  int v425;
  int v426;
  float v427;
  int v428;
  int8x8_t v429;
  int8x16_t v430;
  __int32 v431;
  unsigned int v432;
  unint64_t v433;
  uint64_t v434;
  unint64_t v435;
  uint64_t v436;
  unint64_t v437;
  uint64_t v438;
  uint8x8_t v439;
  uint64_t v440;
  int v441;
  int v442;
  unint64_t v443;
  uint64_t v444;
  unint64_t v445;
  uint64_t v446;
  unint64_t v447;
  uint64_t v448;
  int v449;
  int v450;
  int v451;
  unint64_t v452;
  uint64_t v453;
  unint64_t v454;
  uint64_t v455;
  unint64_t v456;
  uint64_t v457;
  int v458;
  int v459;
  int v460;
  unint64_t v461;
  uint64_t v462;
  unint64_t v463;
  uint64_t v464;
  unint64_t v465;
  uint64_t v466;
  unint64_t v467;
  int v468;
  uint64_t v469;
  char *v470;
  unint64_t v471;
  uint64_t v472;
  unint64_t v473;
  int v474;
  unsigned int v475;
  int v476;
  uint64_t v477;
  float32x4_t v478;
  int v479;
  unsigned int v480;
  int8x16_t v481;
  int8x16_t v482;
  int v483;
  unsigned int v484;
  int v485;
  int v486;
  float v487;
  int8x16_t v488;
  int v489;
  int v490;
  float v491;
  int8x16_t v492;
  int v493;
  int v494;
  float32x4_t v495;
  int v496;
  int v497;
  float v498;
  float v499;
  unsigned int v500;
  unsigned int v501;
  int v502;
  int v503;
  int v504;
  int v505;
  int v506;
  int v507;
  float32x4_t v508;
  int v509;
  int v510;
  float32x4_t v511;
  float32x2_t v512;
  int v513;
  int v514;
  float v515;
  float32x2_t v516;
  float v517;
  int8x16_t v518;
  int v519;
  int v520;
  float v521;
  float v522;
  int8x16_t v523;
  __int32 v524;
  int v525;
  int v526;
  float v527;
  int8x16_t v528;
  int8x8_t v529;
  int8x16_t v530;
  int v531;
  int8x16_t v533;
  int v534;
  float v535;
  int8x16_t v536;
  float v537;
  float32x4_t v538;
  float32x4_t v539;
  float32x4_t v540;
  __int32 v541;
  int v542;
  int v543;
  float v544;
  int8x16_t v545;
  int8x8_t v546;
  int8x16_t v547;
  __int32 v548;
  int v549;
  int v550;
  float v551;
  int8x16_t v552;
  int8x8_t v553;
  int8x16_t v554;
  __int32 v555;
  int v556;
  int v557;
  float v558;
  int8x16_t v559;
  int8x8_t v560;
  int8x16_t v561;
  __int32 v562;
  int v563;
  int v564;
  float v565;
  int8x16_t v566;
  int8x8_t v567;
  int8x16_t v568;
  __int32 v569;
  int v570;
  int v571;
  float v572;
  int8x16_t v573;
  int8x8_t v574;
  int8x16_t v575;
  unsigned int v576;
  __int32 v577;
  int v578;
  int v579;
  int8x16_t v580;
  int8x8_t v581;
  int8x16_t v582;
  __int32 v583;
  __int32 v584;
  int v585;
  int v586;
  float v587;
  int8x16_t v588;
  int8x8_t v589;
  int8x16_t v590;
  int v591;
  int v592;
  float v593;
  int8x16_t v594;
  float v595;
  float32x2_t v596;
  float32x2_t v597;
  float32x2_t v598;
  float32x2_t v599;
  float32x2_t v600;
  float32x2_t v601;
  int8x16_t v602;
  float v603;
  float32x2_t v604;
  int v605;
  int v606;
  float v607;
  float v608;
  float32x2_t v609;
  float32x2_t v610;
  float v611;
  float v612;
  int v613;
  int v614;
  float v615;
  int8x16_t v616;
  int8x8_t v617;
  int8x16_t v618;
  __int32 v619;
  unsigned int v620;
  float v621;
  float v622;
  int v623;
  int v624;
  float v625;
  int8x16_t v626;
  int8x8_t v627;
  int8x16_t v628;
  __int32 v629;
  unsigned int v630;
  float v631;
  float v632;
  int v633;
  int v634;
  float v635;
  float v636;
  int8x16_t v637;
  int8x16_t v638;
  __int32 v639;
  unsigned int v640;
  float v641;
  float v642;
  int v643;
  int v644;
  float v645;
  int8x16_t v646;
  int8x8_t v647;
  int8x16_t v648;
  __int32 v649;
  unsigned int v650;
  int8x16_t v651;
  int8x16_t v652;
  int8x16_t v653;
  int8x16_t v654;
  int8x16_t v655;
  int8x16_t v656;
  int8x16_t v657;
  int8x16_t v658;
  int8x16_t v659;
  int8x16_t v660;
  double v661;
  int8x16_t v662;
  int8x8_t v663;
  int v664;
  int v665;
  int v666;
  uint64_t v667;
  unint64_t v668;
  unint64_t v669;
  int v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  unint64_t v674;
  unint64_t v675;
  int v676;
  int v677;
  int v678;
  int v679;
  int v680;
  int v681;
  int v682;
  int v683;
  int v684;
  int v685;
  int v686;
  int v687;
  int v688;
  uint64_t v689;
  unint64_t v690;
  float32x4_t v691;
  unint64_t v692;
  int8x16_t v693;
  unint64_t v694;
  uint64_t v695;
  int v696[4];
  __int128 v697;
  __int128 v698;
  __int128 v699;
  __int128 v700;
  __int128 v701;
  __int128 v702;
  __int128 v703;
  __int128 v704;
  __int128 v705;
  _DWORD v706[1024];
  uint64_t v707;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v707 = *MEMORY[0x1E0C80C00];
  v17 = *(_QWORD *)(v3 + 96);
  v18 = *(_QWORD *)(v3 + 48);
  v19 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v17 == 0) + 4 * (v18 == 0));
  if ((int)v19 > 27)
    return 0xFFFFFFFFLL;
  v21 = v3;
  v22 = *(unsigned int *)(v3 + 4);
  v23 = v22 - 1;
  if ((int)v22 < 1)
    return 0;
  v24 = *(_DWORD *)(v3 + 8);
  v25 = (v24 - 1);
  if (v24 < 1)
    return 0;
  v26 = *(uint16x4_t **)(v3 + 136);
  v667 = v3;
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v26)
  {
    v28 = *(_DWORD *)v3 & 0xFF00;
    if (v28 == 1024)
    {
      v706[0] = *(_DWORD *)(v3 + 4);
      v696[0] = v24;
      v29 = *(_QWORD *)(v3 + 40);
      v693 = *(int8x16_t *)*(_QWORD *)(v3 + 88);
      v30 = (float32x4_t)vrev32q_s8(v693);
      v31 = v30.f32[3];
      *(float *)v12.i32 = 1.0 - v30.f32[3];
      v675 = *(int *)(v3 + 28);
      v32 = v675 >> 4;
      v33 = *(int *)(v3 + 12) + (v675 >> 4) * *(int *)(v3 + 16);
      v34 = v29 + 16 * v33;
      v689 = v12.i64[0];
      v691 = v30;
      if (v26)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v26, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v22, v24);
        v36 = v35;
        if (v35)
          goto LABEL_895;
        return 1;
      }
      v36 = 0;
      v56 = (int8x16_t *)(v29 + 16 * v33);
LABEL_635:
      v473 = v32 - (int)v22;
      v474 = v22;
      switch((int)v19)
      {
        case 0:
          v475 = v696[0];
          v476 = 16 * v22;
          goto LABEL_898;
        case 1:
          v477 = *(_QWORD *)(v667 + 88);
          if (v477)
          {
            CGSFillDRAM64(v56, v675 & 0xFFFFFFF0, 16 * v22, v696[0], v477, 16, 16, 1, 0, 0);
            if (v36)
              goto LABEL_894;
          }
          else
          {
            v476 = 16 * v22;
            v475 = v696[0];
LABEL_898:
            CGBlt_fillBytes(v476, v475, 0, v56->i8, v675 & 0xFFFFFFF0);
            if (v36)
              goto LABEL_894;
          }
          return 1;
        case 2:
          v478 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.i8, 0);
          v479 = v696[0];
          do
          {
            if ((int)v22 < 4)
            {
              v483 = v22;
            }
            else
            {
              v480 = (v22 >> 2) + 1;
              do
              {
                v481 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v478, (float32x4_t)vrev32q_s8(v56[1])));
                *v56 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v478, (float32x4_t)vrev32q_s8(*v56)));
                v56[1] = v481;
                v482 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v478, (float32x4_t)vrev32q_s8(v56[3])));
                v56[2] = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v478, (float32x4_t)vrev32q_s8(v56[2])));
                v56[3] = v482;
                v56 += 4;
                --v480;
              }
              while (v480 > 1);
              v483 = v22 & 3;
            }
            if (v483 >= 1)
            {
              v484 = v483 + 1;
              do
              {
                *v56 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v478, (float32x4_t)vrev32q_s8(*v56)));
                ++v56;
                --v484;
              }
              while (v484 > 1);
            }
            v56 += v473;
            --v479;
          }
          while (v479);
          goto LABEL_892;
        case 3:
          v485 = v696[0];
          do
          {
            v486 = v22;
            do
            {
              v487 = COERCE_FLOAT(bswap32(v56->u32[3]));
              if (v487 <= 0.0)
              {
                v56->i64[0] = 0;
                v56->i64[1] = 0;
              }
              else
              {
                if (v487 >= 1.0)
                  v488 = v693;
                else
                  v488 = vrev32q_s8((int8x16_t)vmulq_n_f32(v30, v487));
                *v56 = v488;
              }
              ++v56;
              --v486;
            }
            while (v486);
            v56 += v473;
            --v485;
          }
          while (v485);
          goto LABEL_892;
        case 4:
          v489 = v696[0];
          do
          {
            v490 = v22;
            do
            {
              v491 = 1.0 - COERCE_FLOAT(bswap32(v56->u32[3]));
              if (v491 <= 0.0)
              {
                v56->i64[0] = 0;
                v56->i64[1] = 0;
              }
              else
              {
                if (v491 >= 1.0)
                  v492 = v693;
                else
                  v492 = vrev32q_s8((int8x16_t)vmulq_n_f32(v30, v491));
                *v56 = v492;
              }
              ++v56;
              --v490;
            }
            while (v490);
            v56 += v473;
            --v489;
          }
          while (v489);
          goto LABEL_892;
        case 5:
          v493 = v696[0];
          do
          {
            v494 = v22;
            do
            {
              v495 = (float32x4_t)vrev32q_s8(*v56);
              *v56++ = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v495, *(float *)v12.i32), v30, v495, 3));
              --v494;
            }
            while (v494);
            v56 += v473;
            --v493;
          }
          while (v493);
          goto LABEL_892;
        case 6:
          v496 = v696[0];
          while (1)
          {
            v497 = v22;
            do
            {
              v498 = COERCE_FLOAT(bswap32(v56->u32[3]));
              v499 = 1.0 - v498;
              if ((float)(1.0 - v498) >= 1.0)
              {
                v56->i64[0] = v693.i64[0];
                v56->i32[2] = v693.i32[2];
                v501 = v693.u32[3];
              }
              else
              {
                if (v499 <= 0.0)
                  goto LABEL_685;
                v500 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v56->u32[2])) + (float)(v30.f32[2] * v499)));
                v501 = bswap32(COERCE_UNSIGNED_INT(v498 + (float)(v31 * v499)));
                *(int8x8_t *)v56->i8 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v56->i8), *(float32x2_t *)v30.f32, v499));
                v56->i32[2] = v500;
              }
              v56->i32[3] = v501;
LABEL_685:
              ++v56;
              --v497;
            }
            while (v497);
            v56 += v473;
            if (!--v496)
              goto LABEL_892;
          }
        case 7:
          v502 = v696[0];
          do
          {
            v503 = v22;
            do
            {
              *v56 = vrev32q_s8((int8x16_t)vmulq_laneq_f32((float32x4_t)vrev32q_s8(*v56), v30, 3));
              ++v56;
              --v503;
            }
            while (v503);
            v56 += v473;
            --v502;
          }
          while (v502);
          goto LABEL_892;
        case 8:
          v504 = v696[0];
          do
          {
            v505 = v22;
            do
            {
              *v56 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v56), *(float *)v12.i32));
              ++v56;
              --v505;
            }
            while (v505);
            v56 += v473;
            --v504;
          }
          while (v504);
          goto LABEL_892;
        case 9:
          v506 = v696[0];
          do
          {
            v507 = v22;
            do
            {
              v508 = (float32x4_t)vrev32q_s8(*v56);
              *v56++ = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_laneq_f32(v508, v30, 3), v30, 1.0 - v508.f32[3]));
              --v507;
            }
            while (v507);
            v56 += v473;
            --v506;
          }
          while (v506);
          goto LABEL_892;
        case 10:
          v509 = v696[0];
          do
          {
            v510 = v22;
            do
            {
              v511 = (float32x4_t)vrev32q_s8(*v56);
              *v56++ = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v511, *(float *)v12.i32), v30, 1.0 - v511.f32[3]));
              --v510;
            }
            while (v510);
            v56 += v473;
            --v509;
          }
          while (v509);
          goto LABEL_892;
        case 11:
          v512 = vsub_f32((float32x2_t)vdup_laneq_s32((int32x4_t)v30, 3), *(float32x2_t *)v30.f32);
          v513 = v696[0];
          do
          {
            v514 = v22;
            do
            {
              if (v18)
                v12.i32[0] = bswap32(v56->u32[3]);
              else
                v12.i32[0] = 1.0;
              v515 = *(float *)v12.i32 + v31;
              v516 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 0), (float32x2_t)vrev32_s8(*(int8x8_t *)v56->i8));
              v517 = (float)(v31 - v30.f32[2]) + (float)(*(float *)v12.i32 - COERCE_FLOAT(bswap32(v56->u32[2])));
              if (v515 <= 1.0)
                *(float *)&v14 = v515;
              else
                *(float *)&v14 = 1.0;
              *(float32x2_t *)v518.i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v14, 0), vadd_f32(v512, v516));
              *(float *)&v518.i32[2] = *(float *)&v14 - v517;
              v518.i32[3] = LODWORD(v14);
              v12 = vrev32q_s8(v518);
              *v56++ = v12;
              --v514;
            }
            while (v514);
            v56 += v473;
            --v513;
          }
          while (v513);
          goto LABEL_892;
        case 12:
          v519 = v696[0];
          do
          {
            v520 = v22;
            do
            {
              v521 = COERCE_FLOAT(bswap32(v56->u32[2]));
              v522 = v31 + COERCE_FLOAT(bswap32(v56->u32[3]));
              *(float32x2_t *)v523.i8 = vadd_f32(*(float32x2_t *)v30.f32, (float32x2_t)vrev32_s8(*(int8x8_t *)v56->i8));
              if (v522 > 1.0)
                v522 = 1.0;
              v523.i64[1] = __PAIR64__(LODWORD(v522), v30.f32[2] + v521);
              *v56++ = vrev32q_s8(v523);
              --v520;
            }
            while (v520);
            v56 += v473;
            --v519;
          }
          while (v519);
          goto LABEL_892;
        case 13:
          if (v31 <= 0.0)
            goto LABEL_893;
          v524 = v30.i32[2];
          v525 = v696[0];
          while (1)
          {
            v526 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v527 = 1.0;
LABEL_733:
                v529 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v529.i32[1];
                *(float *)v530.i32 = PDAmultiplyPDA(*(float *)v529.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v527, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v524)), v31);
                v30.i32[0] = v691.i32[0];
                v530.i32[1] = v10.i32[0];
                v530.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v528 = vrev32q_s8(v530);
                goto LABEL_734;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v527 = *(float *)v12.i32;
              v528 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_733;
LABEL_734:
              *v56++ = v528;
              --v526;
            }
            while (v526);
            v56 += v473;
            --v525;
            LODWORD(v22) = v474;
            if (!v525)
              goto LABEL_892;
          }
        case 14:
          if (v31 <= 0.0)
            goto LABEL_893;
          v531 = v696[0];
          __asm { FMOV            V0.2S, #1.0 }
          v533 = vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL);
          while (1)
          {
            v534 = v22;
            do
            {
              if (!v18)
              {
                v535 = 1.0;
LABEL_744:
                LODWORD(v537) = bswap32(v56->u32[2]);
                *(int8x8_t *)v538.f32 = vrev32_s8(*(int8x8_t *)v56->i8);
                *(float32x2_t *)v539.f32 = vsub_f32(_D0, *(float32x2_t *)v538.f32);
                v540 = v30;
                v540.f32[3] = -v535;
                v539.i32[3] = v533.i32[1];
                v539.f32[2] = 1.0 - v537;
                v538.i64[1] = __PAIR64__(v535 + v31, LODWORD(v537));
                v536 = vrev32q_s8((int8x16_t)vmlaq_f32(v538, v539, v540));
                goto LABEL_745;
              }
              v535 = COERCE_FLOAT(bswap32(v56->u32[3]));
              v536 = v693;
              if (v535 > 0.0)
                goto LABEL_744;
LABEL_745:
              *v56++ = v536;
              --v534;
            }
            while (v534);
            v56 += v473;
            if (!--v531)
              goto LABEL_892;
          }
        case 15:
          if (v31 <= 0.0)
            goto LABEL_893;
          v541 = v30.i32[2];
          v542 = v696[0];
          while (1)
          {
            v543 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v544 = 1.0;
LABEL_755:
                v546 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v546.i32[1];
                *(float *)v547.i32 = PDAoverlayPDA(*(float *)v546.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v544, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v541)), v31);
                v30.i32[0] = v691.i32[0];
                v547.i32[1] = v10.i32[0];
                v547.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v545 = vrev32q_s8(v547);
                goto LABEL_756;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v544 = *(float *)v12.i32;
              v545 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_755;
LABEL_756:
              *v56++ = v545;
              --v543;
            }
            while (v543);
            v56 += v473;
            --v542;
            LODWORD(v22) = v474;
            if (!v542)
              goto LABEL_892;
          }
        case 16:
          if (v31 <= 0.0)
            goto LABEL_893;
          v548 = v30.i32[2];
          v549 = v696[0];
          while (1)
          {
            v550 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v551 = 1.0;
LABEL_766:
                v553 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v553.i32[1];
                *(float *)v554.i32 = PDAdarkenPDA(*(float *)v553.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v551, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v548)), v31);
                v30.i32[0] = v691.i32[0];
                v554.i32[1] = v10.i32[0];
                v554.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v552 = vrev32q_s8(v554);
                goto LABEL_767;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v551 = *(float *)v12.i32;
              v552 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_766;
LABEL_767:
              *v56++ = v552;
              --v550;
            }
            while (v550);
            v56 += v473;
            --v549;
            LODWORD(v22) = v474;
            if (!v549)
              goto LABEL_892;
          }
        case 17:
          if (v31 <= 0.0)
            goto LABEL_893;
          v555 = v30.i32[2];
          v556 = v696[0];
          while (1)
          {
            v557 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v558 = 1.0;
LABEL_777:
                v560 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v560.i32[1];
                *(float *)v561.i32 = PDAlightenPDA(*(float *)v560.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v558, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v555)), v31);
                v30.i32[0] = v691.i32[0];
                v561.i32[1] = v10.i32[0];
                v561.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v559 = vrev32q_s8(v561);
                goto LABEL_778;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v558 = *(float *)v12.i32;
              v559 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_777;
LABEL_778:
              *v56++ = v559;
              --v557;
            }
            while (v557);
            v56 += v473;
            --v556;
            LODWORD(v22) = v474;
            if (!v556)
              goto LABEL_892;
          }
        case 18:
          if (v31 <= 0.0)
            goto LABEL_893;
          v562 = v30.i32[2];
          v563 = v696[0];
          while (1)
          {
            v564 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v565 = 1.0;
LABEL_788:
                v567 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v567.i32[1];
                *(float *)v568.i32 = PDAcolordodgePDA(*(float *)v567.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v565, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v562)), v31);
                v30.i32[0] = v691.i32[0];
                v568.i32[1] = v10.i32[0];
                v568.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v566 = vrev32q_s8(v568);
                goto LABEL_789;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v565 = *(float *)v12.i32;
              v566 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_788;
LABEL_789:
              *v56++ = v566;
              --v564;
            }
            while (v564);
            v56 += v473;
            --v563;
            LODWORD(v22) = v474;
            if (!v563)
              goto LABEL_892;
          }
        case 19:
          if (v31 <= 0.0)
            goto LABEL_893;
          v569 = v30.i32[2];
          v570 = v696[0];
          while (1)
          {
            v571 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v572 = 1.0;
LABEL_799:
                v574 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v574.i32[1];
                *(float *)v575.i32 = PDAcolorburnPDA(*(float *)v574.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v572, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v569)), v31);
                v30.i32[0] = v691.i32[0];
                v575.i32[1] = v10.i32[0];
                v575.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v573 = vrev32q_s8(v575);
                goto LABEL_800;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v572 = *(float *)v12.i32;
              v573 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_799;
LABEL_800:
              *v56++ = v573;
              --v571;
            }
            while (v571);
            v56 += v473;
            --v570;
            LODWORD(v22) = v474;
            if (!v570)
              goto LABEL_892;
          }
        case 20:
          if (v31 <= 0.0)
            goto LABEL_893;
          v576 = v30.u32[1];
          v577 = v30.i32[2];
          v578 = v696[0];
          while (1)
          {
            v579 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v13.n128_u32[0] = 1.0;
LABEL_810:
                v581 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                *(float *)v582.i32 = PDAsoftlightPDA(*(float *)v581.i32, *(float *)&v581.i32[1], *(double *)v11.i64, *(int32x2_t *)v12.i8, v13.n128_f64[0], v14, v15, v16, v2, v3, (uint64_t)v26, v4, v5, v6, v7, v8, v30.f32[0], v576, __SPAIR64__(LODWORD(v31), v577),
                                       v31);
                v30.i32[0] = v691.i32[0];
                v582.i32[1] = v583;
                v582.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v580 = vrev32q_s8(v582);
                goto LABEL_811;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v13.n128_u32[0] = v12.i32[0];
              v580 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_810;
LABEL_811:
              *v56++ = v580;
              --v579;
            }
            while (v579);
            v56 += v473;
            --v578;
            LODWORD(v22) = v474;
            if (!v578)
              goto LABEL_892;
          }
        case 21:
          if (v31 <= 0.0)
            goto LABEL_893;
          v584 = v30.i32[2];
          v585 = v696[0];
          while (1)
          {
            v586 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v587 = 1.0;
LABEL_821:
                v589 = vrev32_s8(*(int8x8_t *)v56->i8);
                v11.i32[0] = bswap32(v56->u32[2]);
                v10.i32[0] = v589.i32[1];
                *(float *)v590.i32 = PDAhardlightPDA(*(float *)v589.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v587, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v584)), v31);
                v30.i32[0] = v691.i32[0];
                v590.i32[1] = v10.i32[0];
                v590.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                v588 = vrev32q_s8(v590);
                goto LABEL_822;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v587 = *(float *)v12.i32;
              v588 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_821;
LABEL_822:
              *v56++ = v588;
              --v586;
            }
            while (v586);
            v56 += v473;
            --v585;
            LODWORD(v22) = v474;
            if (!v585)
              goto LABEL_892;
          }
        case 22:
          if (v31 <= 0.0)
            goto LABEL_893;
          v591 = v696[0];
          while (1)
          {
            v592 = v22;
            do
            {
              if (v18)
              {
                v593 = COERCE_FLOAT(bswap32(v56->u32[3]));
                v594 = v693;
                if (v593 <= 0.0)
                  goto LABEL_835;
              }
              else
              {
                v593 = 1.0;
              }
              v595 = COERCE_FLOAT(bswap32(v56->u32[2]));
              v596 = (float32x2_t)vrev32_s8(*(int8x8_t *)v56->i8);
              v597 = vadd_f32(*(float32x2_t *)v30.f32, v596);
              v598 = vmul_laneq_f32(v596, v30, 3);
              v599 = vmul_n_f32(*(float32x2_t *)v30.f32, v593);
              v600 = vsub_f32(v597, v598);
              v601 = vsub_f32(v598, v599);
              *(float32x2_t *)v602.i8 = vadd_f32(vsub_f32(v600, v599), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v601), (int8x8_t)vneg_f32(v601), (int8x8_t)v601));
              v603 = (float)(v31 * v595) - (float)(v30.f32[2] * v593);
              if (v603 < 0.0)
                v603 = -v603;
              v602.i64[1] = __PAIR64__((float)(v593 + v31) - (float)(v593 * v31), (float)((float)((float)(v30.f32[2] + v595) - (float)(v31 * v595))- (float)(v30.f32[2] * v593))+ v603);
              v594 = vrev32q_s8(v602);
LABEL_835:
              *v56++ = v594;
              --v592;
            }
            while (v592);
            v56 += v473;
            if (!--v591)
              goto LABEL_892;
          }
        case 23:
          if (v31 <= 0.0)
            goto LABEL_893;
          v604 = (float32x2_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL).u64[0];
          v605 = v696[0];
          while (1)
          {
            v606 = v22;
            do
            {
              if (v18)
              {
                LODWORD(v607) = bswap32(v56->u32[3]);
                if (v607 <= 0.0)
                {
                  *v56 = v693;
                  goto LABEL_846;
                }
              }
              else
              {
                v607 = 1.0;
              }
              LODWORD(v608) = bswap32(v56->u32[2]);
              v609.f32[0] = -(float)(v608 * v30.f32[2]);
              v610 = (float32x2_t)vrev32_s8(*(int8x8_t *)v56->i8);
              v609.f32[1] = -v607;
              *(int8x8_t *)v56->i8 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v30.f32, v610), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v30.f32, v610)));
              v56->u64[1] = (unint64_t)vrev32_s8((int8x8_t)vmla_f32(vadd_f32(v604, (float32x2_t)__PAIR64__(LODWORD(v607), LODWORD(v608))), (float32x2_t)__PAIR64__(v604.u32[1], 2.0), v609));
LABEL_846:
              ++v56;
              --v606;
            }
            while (v606);
            v56 += v473;
            if (!--v605)
              goto LABEL_892;
          }
        case 24:
          if (v31 <= 0.0)
            goto LABEL_893;
          v611 = v30.f32[1];
          v612 = v30.f32[2];
          v613 = v696[0];
          while (1)
          {
            v614 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v615 = 1.0;
LABEL_856:
                v617 = vrev32_s8(*(int8x8_t *)v56->i8);
                *(float *)v618.i32 = PDAhuePDA(*(float *)v617.i32, *(float *)&v617.i32[1], COERCE_FLOAT(bswap32(v56->u32[2])), *(double *)v12.i64, v615, v14, v15, v16, v30.f32[0], v611, v612, v31, v31);
                v30.i32[0] = v691.i32[0];
                v618.i32[1] = v619;
                v618.i64[1] = __PAIR64__(v12.u32[0], v620);
                v616 = vrev32q_s8(v618);
                goto LABEL_857;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v615 = *(float *)v12.i32;
              v616 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_856;
LABEL_857:
              *v56++ = v616;
              --v614;
            }
            while (v614);
            v56 += v473;
            --v613;
            LODWORD(v22) = v474;
            if (!v613)
              goto LABEL_892;
          }
        case 25:
          if (v31 <= 0.0)
            goto LABEL_893;
          v621 = v30.f32[1];
          v622 = v30.f32[2];
          v623 = v696[0];
          while (1)
          {
            v624 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v56->u32[3]);
                v625 = 1.0;
LABEL_867:
                v627 = vrev32_s8(*(int8x8_t *)v56->i8);
                *(float *)v628.i32 = PDAsaturationPDA(*(float *)v627.i32, *(float *)&v627.i32[1], COERCE_FLOAT(bswap32(v56->u32[2])), *(double *)v12.i64, v625, v14, v15, v16, v30.f32[0], v621, v622, v31, v31);
                v30.i32[0] = v691.i32[0];
                v628.i32[1] = v629;
                v628.i64[1] = __PAIR64__(v12.u32[0], v630);
                v626 = vrev32q_s8(v628);
                goto LABEL_868;
              }
              v12.i32[0] = bswap32(v56->u32[3]);
              v625 = *(float *)v12.i32;
              v626 = v693;
              if (*(float *)v12.i32 > 0.0)
                goto LABEL_867;
LABEL_868:
              *v56++ = v626;
              --v624;
            }
            while (v624);
            v56 += v473;
            --v623;
            LODWORD(v22) = v474;
            if (!v623)
              goto LABEL_892;
          }
        case 26:
          if (v31 <= 0.0)
            goto LABEL_893;
          v631 = v30.f32[1];
          v632 = v30.f32[2];
          v633 = v696[0];
          while (1)
          {
            v634 = v22;
            do
            {
              if (!v18)
              {
                v635 = COERCE_FLOAT(bswap32(v56->u32[3]));
                v636 = 1.0;
LABEL_878:
                v663 = vrev32_s8(*(int8x8_t *)v56->i8);
                *(float *)v12.i32 = v31;
                *(float *)v638.i32 = PDAluminosityPDA(v30.f32[0], v631, v632, *(double *)v12.i64, v31, v14, v15, v16, *(float *)v663.i32, *(float *)&v663.i32[1], COERCE_FLOAT(bswap32(v56->u32[2])), v635, v636);
                v30.i32[0] = v691.i32[0];
                v638.i32[1] = v639;
                v638.i64[1] = __PAIR64__(v12.u32[0], v640);
                v637 = vrev32q_s8(v638);
                goto LABEL_879;
              }
              v635 = COERCE_FLOAT(bswap32(v56->u32[3]));
              v636 = v635;
              v637 = v693;
              if (v635 > 0.0)
                goto LABEL_878;
LABEL_879:
              *v56++ = v637;
              --v634;
            }
            while (v634);
            v56 += v473;
            --v633;
            LODWORD(v22) = v474;
            if (!v633)
              goto LABEL_892;
          }
        case 27:
          if (v31 <= 0.0)
            goto LABEL_893;
          v641 = v30.f32[1];
          v642 = v30.f32[2];
          v643 = v696[0];
          break;
        default:
          goto LABEL_893;
      }
LABEL_884:
      v644 = v22;
      while (1)
      {
        if (v18)
        {
          v12.i32[0] = bswap32(v56->u32[3]);
          v645 = *(float *)v12.i32;
          v646 = v693;
          if (*(float *)v12.i32 <= 0.0)
            goto LABEL_890;
        }
        else
        {
          v12.i32[0] = bswap32(v56->u32[3]);
          v645 = 1.0;
        }
        v647 = vrev32_s8(*(int8x8_t *)v56->i8);
        *(float *)v648.i32 = PDAluminosityPDA(*(float *)v647.i32, *(float *)&v647.i32[1], COERCE_FLOAT(bswap32(v56->u32[2])), *(double *)v12.i64, v645, v14, v15, v16, v30.f32[0], v641, v642, v31, v31);
        v30.i32[0] = v691.i32[0];
        v648.i32[1] = v649;
        v648.i64[1] = __PAIR64__(v12.u32[0], v650);
        v646 = vrev32q_s8(v648);
LABEL_890:
        *v56++ = v646;
        if (!--v644)
        {
          v56 += v473;
          --v643;
          LODWORD(v22) = v474;
          if (!v643)
          {
LABEL_892:
            v696[0] = 0;
LABEL_893:
            if (!v36)
              return 1;
LABEL_894:
            v695 = 0;
LABEL_895:
            v2 = shape_enum_clip_next((uint64_t)v36, (int *)&v695 + 1, &v695, v706, v696);
            if (!(_DWORD)v2)
              goto LABEL_47;
            v56 = (int8x16_t *)(v34 + 16 * v32 * (int)v695 + 16 * SHIDWORD(v695));
            LODWORD(v22) = v706[0];
            v12.i64[0] = v689;
            v30 = v691;
            goto LABEL_635;
          }
          goto LABEL_884;
        }
      }
    }
    v706[0] = *(_DWORD *)(v3 + 4);
    v696[0] = v24;
    v37 = *(_QWORD *)(v3 + 88);
    v38 = (unint64_t)*(int *)(v3 + 28) >> 4;
    v39 = *(_QWORD *)(v3 + 40) + 16 * (*(int *)(v3 + 12) + v38 * *(int *)(v3 + 16));
    v40 = *(unsigned int *)(v3 + 104);
    v41 = *(unsigned int *)(v3 + 108);
    v42 = *(_DWORD *)(v3 + 56);
    v43 = *(_DWORD *)(v3 + 60);
    v44 = (unint64_t)*(int *)(v3 + 76) >> 4;
    v664 = v19;
    if (v28 != 256)
    {
      LODWORD(v674) = *(_DWORD *)(v3 + 64);
      v671 = *(int *)(v3 + 68);
      v692 = v37 + 16 * v44 * v671;
      v53 = v17 != 0;
      if (v26)
      {
        v694 = (unint64_t)*(int *)(v3 + 76) >> 4;
        v665 = *(_DWORD *)(v3 + 60);
        v666 = *(_DWORD *)(v3 + 56);
        LODWORD(v4) = 1;
        v54 = *(_QWORD *)(v3 + 88);
        v55 = v54;
LABEL_43:
        v670 = v4;
        shape_enum_clip_alloc(v2, v3, (int *)v26, v4, v38, 1, v40, v41, v22, v24);
        v80 = v79;
        if (!v79)
          return 1;
        while (2)
        {
          v2 = shape_enum_clip_next(v80, (int *)&v695 + 1, &v695, v706, v696);
          if (!(_DWORD)v2)
          {
            v81 = (void *)v80;
LABEL_626:
            free(v81);
            return 1;
          }
          v672 = v37;
          v673 = v80;
          if (v692)
          {
            v77 = v39 + 16 * v38 * (int)v695 + 16 * SHIDWORD(v695);
            v467 = v37 + 16 * v694 * (((int)v695 + *(_DWORD *)(v21 + 60)) % (int)v671);
            v54 = v467 + 16 * ((HIDWORD(v695) + *(_DWORD *)(v21 + 56)) % (int)v674);
            v55 = v467 + 16 * (int)v674;
            v37 = v54;
            v688 = v706[0];
            v468 = v706[0];
            v665 = ((int)v695 + *(_DWORD *)(v21 + 60)) % (int)v671;
            v666 = (HIDWORD(v695) + *(_DWORD *)(v21 + 56)) % (int)v674;
          }
          else
          {
            v688 = v706[0];
            v468 = v706[0] * v670;
            v77 = v39 + 16 * v38 * (int)v695 + 16 * HIDWORD(v695) * v670;
            v37 += 16 * (int)v695 * (int)v674 + 16 * HIDWORD(v695) * v670;
            v694 = (int)v674 - v706[0] * v670;
          }
          v690 = v38 - v468;
LABEL_48:
          switch((int)v19)
          {
            case 0:
              v82 = v77 - 16 * (v688 - 1);
              v83 = v690 + v688;
              if (v670 < 0)
                v83 = v690 - v688;
              else
                v82 = v77;
              v84 = (char *)(v82 + 16 * ((v83 * (v696[0] - 1)) & (v83 >> 63)));
              if (v83 < 0)
                v83 = -v83;
              CGBlt_fillBytes(16 * v688, v696[0], 0, v84, 16 * v83);
              goto LABEL_617;
            case 1:
              v85 = *(unsigned __int8 *)(v21 + 1);
              if (v85 == 2)
              {
                if (v688 >= 2 && (16 * v674) <= 0x40)
                {
                  LODWORD(v9) = 16 * v674;
                  v439 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v9);
                  v439.i16[0] = vaddlv_u8(v439);
                  if (v439.i32[0] <= 1u)
                  {
                    v37 = v672;
                    CGSFillDRAM64((_BYTE *)v77, 16 * (v688 + v690), 16 * v688, v696[0], v672, 16 * v694, 16 * v674, v671, 16 * v666, v665);
                    goto LABEL_618;
                  }
                }
LABEL_574:
                v440 = 16 * v670;
                if (v18 == 0 || v53)
                {
                  v441 = v696[0];
                  do
                  {
                    v442 = v688;
                    do
                    {
                      *(_OWORD *)v77 = *(_OWORD *)v37;
                      v443 = v37 + 16 * v670;
                      if (v443 >= v55)
                        v444 = -(uint64_t)(int)v674;
                      else
                        v444 = 0;
                      v37 = v443 + 16 * v444;
                      v77 += v440;
                      --v442;
                    }
                    while (v442);
                    v77 += 16 * v690;
                    v445 = v54 + 16 * v694;
                    if (v445 >= v692)
                      v446 = -(uint64_t)(v694 * (int)v671);
                    else
                      v446 = 0;
                    v447 = v445 + 16 * v446;
                    v448 = v55 + 16 * v446 + 16 * v694;
                    if (v692)
                    {
                      v55 = v448;
                      v54 = v447;
                      v37 = v447;
                    }
                    else
                    {
                      v37 += 16 * v694;
                    }
                    --v441;
                  }
                  while (v441);
                }
                else
                {
                  v449 = v696[0];
                  do
                  {
                    v450 = v688;
                    do
                    {
                      v451 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v451;
                      *(_DWORD *)(v77 + 12) = 32831;
                      v452 = v37 + 16 * v670;
                      if (v452 >= v55)
                        v453 = -(uint64_t)(int)v674;
                      else
                        v453 = 0;
                      v37 = v452 + 16 * v453;
                      v77 += v440;
                      --v450;
                    }
                    while (v450);
                    v77 += 16 * v690;
                    v454 = v54 + 16 * v694;
                    if (v454 >= v692)
                      v455 = -(uint64_t)(v694 * (int)v671);
                    else
                      v455 = 0;
                    v456 = v454 + 16 * v455;
                    v457 = v55 + 16 * v455 + 16 * v694;
                    if (v692)
                    {
                      v55 = v457;
                      v54 = v456;
                      v37 = v456;
                    }
                    else
                    {
                      v37 += 16 * v694;
                    }
                    --v449;
                  }
                  while (v449);
                }
                goto LABEL_616;
              }
              if (v85 != 1)
                goto LABEL_574;
              if (v18 == 0 || v53)
              {
                if (v670 < 0)
                {
                  v86 = v694 - v688;
                  v37 -= 16 * (v688 - 1);
                  v87 = v690 - v688;
                  v77 -= 16 * (v688 - 1);
                }
                else
                {
                  v86 = v694 + v688;
                  v87 = v690 + v688;
                }
                v469 = v696[0] - 1;
                v470 = (char *)(v37 + 16 * ((v86 * v469) & (v86 >> 63)));
                if (v86 >= 0)
                  v471 = v86;
                else
                  v471 = -v86;
                if (v87 >= 0)
                  LODWORD(v472) = v87;
                else
                  v472 = -v87;
                v694 = v471;
                CGBlt_copyBytes(16 * v688, v696[0], v470, (char *)(v77 + 16 * ((v87 * v469) & (v87 >> 63))), 16 * v471, 16 * v472);
                goto LABEL_617;
              }
              v458 = v696[0];
              do
              {
                v459 = v688;
                do
                {
                  v460 = *(_DWORD *)(v37 + 8);
                  *(_QWORD *)v77 = *(_QWORD *)v37;
                  *(_DWORD *)(v77 + 8) = v460;
                  *(_DWORD *)(v77 + 12) = 32831;
                  v461 = v37 + 16 * v670;
                  if (v461 >= v55)
                    v462 = -(uint64_t)(int)v674;
                  else
                    v462 = 0;
                  v37 = v461 + 16 * v462;
                  v77 += 16 * v670;
                  --v459;
                }
                while (v459);
                v77 += 16 * v690;
                v463 = v54 + 16 * v694;
                if (v463 >= v692)
                  v464 = -(uint64_t)(v694 * (int)v671);
                else
                  v464 = 0;
                v465 = v463 + 16 * v464;
                v466 = v55 + 16 * v464 + 16 * v694;
                if (v692)
                {
                  v55 = v466;
                  v54 = v465;
                  v37 = v465;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v458;
              }
              while (v458);
LABEL_616:
              v696[0] = 0;
LABEL_617:
              v37 = v672;
LABEL_618:
              v80 = v673;
              if (!v673)
                return 1;
              v695 = 0;
              continue;
            case 2:
              v88 = v696[0];
              do
              {
                v89 = v688;
                do
                {
                  v90 = *(_DWORD *)(v37 + 12);
                  LODWORD(v91) = bswap32(v90);
                  if (v91 >= 1.0)
                  {
                    *(_QWORD *)v77 = *(_QWORD *)v37;
                    *(_DWORD *)(v77 + 8) = *(_DWORD *)(v37 + 8);
                    *(_DWORD *)(v77 + 12) = v90;
                  }
                  else if (v91 > 0.0)
                  {
                    *(int8x8_t *)v92.f32 = vrev32_s8(*(int8x8_t *)v37);
                    v92.i64[1] = __PAIR64__(LODWORD(v91), bswap32(*(_DWORD *)(v37 + 8)));
                    *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v92, (float32x4_t)vrev32q_s8(*(int8x16_t *)v77), 1.0 - v91));
                  }
                  v93 = v37 + 16 * v670;
                  if (v93 >= v55)
                    v94 = -(uint64_t)(int)v674;
                  else
                    v94 = 0;
                  v37 = v93 + 16 * v94;
                  v77 += 16 * v670;
                  --v89;
                }
                while (v89);
                v77 += 16 * v690;
                v95 = v54 + 16 * v694;
                if (v95 >= v692)
                  v96 = -(uint64_t)(v694 * (int)v671);
                else
                  v96 = 0;
                v97 = v95 + 16 * v96;
                v98 = v55 + 16 * v96 + 16 * v694;
                if (v692)
                {
                  v55 = v98;
                  v54 = v97;
                  v37 = v97;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v88;
              }
              while (v88);
              goto LABEL_616;
            case 3:
              do
              {
                v99 = v706[0];
                do
                {
                  v100 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12)));
                  if (v100 <= 0.0)
                  {
                    *(_QWORD *)v77 = 0;
                    *(_QWORD *)(v77 + 8) = 0;
                  }
                  else if (v100 >= 1.0)
                  {
                    if (v53)
                      v103 = bswap32(*(_DWORD *)(v37 + 12));
                    else
                      v103 = 1065353216;
                    v104 = *(_QWORD *)(v37 + 4);
                    *(_DWORD *)v77 = *(_DWORD *)v37;
                    *(_QWORD *)(v77 + 4) = v104;
                    *(_DWORD *)(v77 + 12) = bswap32(v103);
                  }
                  else
                  {
                    v101 = 1.0;
                    if (v53)
                      v101 = bswap32(*(_DWORD *)(v37 + 12));
                    *(int8x8_t *)v102.f32 = vrev32_s8(*(int8x8_t *)v37);
                    v102.i64[1] = __PAIR64__(v101, bswap32(*(_DWORD *)(v37 + 8)));
                    *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmulq_n_f32(v102, v100));
                  }
                  v105 = v37 + 16 * v670;
                  if (v105 >= v55)
                    v106 = -(uint64_t)(int)v674;
                  else
                    v106 = 0;
                  v37 = v105 + 16 * v106;
                  v77 += 16 * v670;
                  --v99;
                }
                while (v99);
                v77 += 16 * v690;
                v107 = v54 + 16 * v694;
                if (v107 >= v692)
                  v108 = -(uint64_t)(v694 * (int)v671);
                else
                  v108 = 0;
                v109 = v107 + 16 * v108;
                v110 = v55 + 16 * v108 + 16 * v694;
                if (v692)
                {
                  v55 = v110;
                  v54 = v109;
                  v37 = v109;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v696[0];
              }
              while (v696[0]);
              goto LABEL_617;
            case 4:
              do
              {
                v111 = v706[0];
                do
                {
                  v112 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12)));
                  if (v112 <= 0.0)
                  {
                    *(_QWORD *)v77 = 0;
                    *(_QWORD *)(v77 + 8) = 0;
                  }
                  else if (v112 >= 1.0)
                  {
                    if (v53)
                      v115 = bswap32(*(_DWORD *)(v37 + 12));
                    else
                      v115 = 1065353216;
                    v116 = *(_QWORD *)(v37 + 4);
                    *(_DWORD *)v77 = *(_DWORD *)v37;
                    *(_QWORD *)(v77 + 4) = v116;
                    *(_DWORD *)(v77 + 12) = bswap32(v115);
                  }
                  else
                  {
                    v113 = 1.0;
                    if (v53)
                      v113 = bswap32(*(_DWORD *)(v37 + 12));
                    *(int8x8_t *)v114.f32 = vrev32_s8(*(int8x8_t *)v37);
                    v114.i64[1] = __PAIR64__(v113, bswap32(*(_DWORD *)(v37 + 8)));
                    *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmulq_n_f32(v114, v112));
                  }
                  v117 = v37 + 16 * v670;
                  if (v117 >= v55)
                    v118 = -(uint64_t)(int)v674;
                  else
                    v118 = 0;
                  v37 = v117 + 16 * v118;
                  v77 += 16 * v670;
                  --v111;
                }
                while (v111);
                v77 += 16 * v690;
                v119 = v54 + 16 * v694;
                if (v119 >= v692)
                  v120 = -(uint64_t)(v694 * (int)v671);
                else
                  v120 = 0;
                v121 = v119 + 16 * v120;
                v122 = v55 + 16 * v120 + 16 * v694;
                if (v692)
                {
                  v55 = v122;
                  v54 = v121;
                  v37 = v121;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v696[0];
              }
              while (v696[0]);
              goto LABEL_617;
            case 5:
              v123 = v696[0];
              do
              {
                v124 = v688;
                do
                {
                  v125 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                  v126 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v77);
                  *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v126, 1.0 - v125.f32[3]), v125, v126, 3));
                  v127 = v37 + 16 * v670;
                  if (v127 >= v55)
                    v128 = -(uint64_t)(int)v674;
                  else
                    v128 = 0;
                  v37 = v127 + 16 * v128;
                  v77 += 16 * v670;
                  --v124;
                }
                while (v124);
                v77 += 16 * v690;
                v129 = v54 + 16 * v694;
                if (v129 >= v692)
                  v130 = -(uint64_t)(v694 * (int)v671);
                else
                  v130 = 0;
                v131 = v129 + 16 * v130;
                v132 = v55 + 16 * v130 + 16 * v694;
                if (v692)
                {
                  v55 = v132;
                  v54 = v131;
                  v37 = v131;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v123;
              }
              while (v123);
              goto LABEL_616;
            case 6:
              v133 = v696[0];
              while (1)
              {
                v134 = v688;
                do
                {
                  v135 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12)));
                  v136 = 1.0 - v135;
                  if ((float)(1.0 - v135) >= 1.0)
                  {
                    if (v53)
                      v141 = bswap32(*(_DWORD *)(v37 + 12));
                    else
                      v141 = 1065353216;
                    v140 = *(int8x8_t *)v37;
                    v138 = *(_DWORD *)(v37 + 8);
                    v139 = bswap32(v141);
                  }
                  else
                  {
                    if (v136 <= 0.0)
                      goto LABEL_150;
                    v137 = 1.0;
                    if (v53)
                      v137 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                    v138 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8)))+ (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8))) * v136)));
                    v139 = bswap32(COERCE_UNSIGNED_INT(v135 + (float)(v137 * v136)));
                    v140 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v77), (float32x2_t)vrev32_s8(*(int8x8_t *)v37), v136));
                  }
                  *(int8x8_t *)v77 = v140;
                  *(_DWORD *)(v77 + 8) = v138;
                  *(_DWORD *)(v77 + 12) = v139;
LABEL_150:
                  v142 = v37 + 16 * v670;
                  if (v142 >= v55)
                    v143 = -(uint64_t)(int)v674;
                  else
                    v143 = 0;
                  v37 = v142 + 16 * v143;
                  v77 += 16 * v670;
                  --v134;
                }
                while (v134);
                v77 += 16 * v690;
                v144 = v54 + 16 * v694;
                if (v144 >= v692)
                  v145 = -(uint64_t)(v694 * (int)v671);
                else
                  v145 = 0;
                v146 = v144 + 16 * v145;
                v147 = v55 + 16 * v145 + 16 * v694;
                if (v692)
                {
                  v55 = v147;
                  v54 = v146;
                  v37 = v146;
                }
                else
                {
                  v37 += 16 * v694;
                }
                if (!--v133)
                  goto LABEL_616;
              }
            case 7:
              v148 = v696[0];
              do
              {
                v149 = v688;
                do
                {
                  v150 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                  if (v150 <= 0.0)
                  {
                    *(_QWORD *)v77 = 0;
                    *(_QWORD *)(v77 + 8) = 0;
                  }
                  else if (v150 < 1.0)
                  {
                    *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v77), v150));
                  }
                  v151 = v37 + 16 * v670;
                  if (v151 >= v55)
                    v152 = -(uint64_t)(int)v674;
                  else
                    v152 = 0;
                  v37 = v151 + 16 * v152;
                  v77 += 16 * v670;
                  --v149;
                }
                while (v149);
                v77 += 16 * v690;
                v153 = v54 + 16 * v694;
                if (v153 >= v692)
                  v154 = -(uint64_t)(v694 * (int)v671);
                else
                  v154 = 0;
                v155 = v153 + 16 * v154;
                v156 = v55 + 16 * v154 + 16 * v694;
                if (v692)
                {
                  v55 = v156;
                  v54 = v155;
                  v37 = v155;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v148;
              }
              while (v148);
              goto LABEL_616;
            case 8:
              v157 = v696[0];
              do
              {
                v158 = v688;
                do
                {
                  v159 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                  if (v159 <= 0.0)
                  {
                    *(_QWORD *)v77 = 0;
                    *(_QWORD *)(v77 + 8) = 0;
                  }
                  else if (v159 < 1.0)
                  {
                    *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v77), v159));
                  }
                  v160 = v37 + 16 * v670;
                  if (v160 >= v55)
                    v161 = -(uint64_t)(int)v674;
                  else
                    v161 = 0;
                  v37 = v160 + 16 * v161;
                  v77 += 16 * v670;
                  --v158;
                }
                while (v158);
                v77 += 16 * v690;
                v162 = v54 + 16 * v694;
                if (v162 >= v692)
                  v163 = -(uint64_t)(v694 * (int)v671);
                else
                  v163 = 0;
                v164 = v162 + 16 * v163;
                v165 = v55 + 16 * v163 + 16 * v694;
                if (v692)
                {
                  v55 = v165;
                  v54 = v164;
                  v37 = v164;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v157;
              }
              while (v157);
              goto LABEL_616;
            case 9:
              v166 = v696[0];
              do
              {
                v167 = v688;
                do
                {
                  v168 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                  v169 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v77);
                  *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_laneq_f32(v169, v168, 3), v168, 1.0 - v169.f32[3]));
                  v170 = v37 + 16 * v670;
                  if (v170 >= v55)
                    v171 = -(uint64_t)(int)v674;
                  else
                    v171 = 0;
                  v37 = v170 + 16 * v171;
                  v77 += 16 * v670;
                  --v167;
                }
                while (v167);
                v77 += 16 * v690;
                v172 = v54 + 16 * v694;
                if (v172 >= v692)
                  v173 = -(uint64_t)(v694 * (int)v671);
                else
                  v173 = 0;
                v174 = v172 + 16 * v173;
                v175 = v55 + 16 * v173 + 16 * v694;
                if (v692)
                {
                  v55 = v175;
                  v54 = v174;
                  v37 = v174;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v166;
              }
              while (v166);
              goto LABEL_616;
            case 10:
              v176 = v696[0];
              do
              {
                v177 = v688;
                do
                {
                  v178 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                  v179 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v77);
                  *(int8x16_t *)v77 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v179, 1.0 - v178.f32[3]), v178, 1.0 - v179.f32[3]));
                  v180 = v37 + 16 * v670;
                  if (v180 >= v55)
                    v181 = -(uint64_t)(int)v674;
                  else
                    v181 = 0;
                  v37 = v180 + 16 * v181;
                  v77 += 16 * v670;
                  --v177;
                }
                while (v177);
                v77 += 16 * v690;
                v182 = v54 + 16 * v694;
                if (v182 >= v692)
                  v183 = -(uint64_t)(v694 * (int)v671);
                else
                  v183 = 0;
                v184 = v182 + 16 * v183;
                v185 = v55 + 16 * v183 + 16 * v694;
                if (v692)
                {
                  v55 = v185;
                  v54 = v184;
                  v37 = v184;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v176;
              }
              while (v176);
              goto LABEL_616;
            case 11:
              v186 = v696[0];
              do
              {
                v187 = v688;
                do
                {
                  if (v18)
                    v10.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                  else
                    v10.i32[0] = 1.0;
                  v188 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8)));
                  v189 = (float32x2_t)vrev32_s8(*(int8x8_t *)v77);
                  v190 = (float32x2_t)vrev32_s8(*(int8x8_t *)v37);
                  v191 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)));
                  LODWORD(v15) = bswap32(*(_DWORD *)(v37 + 12));
                  if (!v53)
                    *(float *)&v15 = 1.0;
                  v192 = *(float *)&v15 + *(float *)v10.i32;
                  v193 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 0), v189);
                  v194 = (float)(*(float *)&v15 - v191) + (float)(*(float *)v10.i32 - v188);
                  if (v192 <= 1.0)
                    *(float *)v11.i32 = v192;
                  else
                    *(float *)v11.i32 = 1.0;
                  *(float32x2_t *)v195.i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 0), vadd_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v15, 0), v190), v193));
                  *(float *)&v195.i32[2] = *(float *)v11.i32 - v194;
                  v195.i32[3] = v11.i32[0];
                  v10 = vrev32q_s8(v195);
                  *(int8x16_t *)v77 = v10;
                  v196 = v37 + 16 * v670;
                  if (v196 >= v55)
                    v197 = -(uint64_t)(int)v674;
                  else
                    v197 = 0;
                  v37 = v196 + 16 * v197;
                  v77 += 16 * v670;
                  --v187;
                }
                while (v187);
                v77 += 16 * v690;
                v198 = v54 + 16 * v694;
                if (v198 >= v692)
                  v199 = -(uint64_t)(v694 * (int)v671);
                else
                  v199 = 0;
                v200 = v198 + 16 * v199;
                v201 = v55 + 16 * v199 + 16 * v694;
                if (v692)
                {
                  v55 = v201;
                  v54 = v200;
                  v37 = v200;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v186;
              }
              while (v186);
              goto LABEL_616;
            case 12:
              v202 = v696[0];
              do
              {
                v203 = v688;
                do
                {
                  v204 = 1.0;
                  if (v53)
                    v204 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                  v205 = v204 + COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12)));
                  *(float32x2_t *)v206.i8 = vadd_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v77), (float32x2_t)vrev32_s8(*(int8x8_t *)v37));
                  v207 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8))) + COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)));
                  if (v205 > 1.0)
                    v205 = 1.0;
                  v206.i64[1] = __PAIR64__(LODWORD(v205), LODWORD(v207));
                  *(int8x16_t *)v77 = vrev32q_s8(v206);
                  v208 = v37 + 16 * v670;
                  if (v208 >= v55)
                    v209 = -(uint64_t)(int)v674;
                  else
                    v209 = 0;
                  v37 = v208 + 16 * v209;
                  v77 += 16 * v670;
                  --v203;
                }
                while (v203);
                v77 += 16 * v690;
                v210 = v54 + 16 * v694;
                if (v210 >= v692)
                  v211 = -(uint64_t)(v694 * (int)v671);
                else
                  v211 = 0;
                v212 = v210 + 16 * v211;
                v213 = v55 + 16 * v211 + 16 * v694;
                if (v692)
                {
                  v55 = v213;
                  v54 = v212;
                  v37 = v212;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v202;
              }
              while (v202);
              goto LABEL_616;
            case 13:
              v668 = v38;
              v669 = v39;
              v214 = v696[0];
              while (1)
              {
                v676 = v214;
                v215 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_275;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v216 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v217 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v217;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_275;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v216 = 1.0;
                  }
                  v218 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v219 = *(_OWORD *)v37;
                  LODWORD(v219) = v218.i32[1];
                  v651 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v220.i32 = PDAmultiplyPDA(*(float *)v218.i32, *(double *)&v219, *(double *)v11.i64, *(double *)v12.i64, v216, v14, *(double *)v651.i64, v16, *(float *)v651.i32, *(double *)&v651.i64[1], *(float *)&v14);
                  v220.i32[1] = v221;
                  v220.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v220);
LABEL_275:
                  v222 = v37 + 16 * v670;
                  if (v222 >= v55)
                    v223 = -(uint64_t)(int)v674;
                  else
                    v223 = 0;
                  v37 = v222 + 16 * v223;
                  v77 += 16 * v670;
                  --v215;
                }
                while (v215);
                v77 += 16 * v690;
                v224 = v54 + 16 * v694;
                v225 = -(uint64_t)(v694 * (int)v671);
                if (v224 < v692)
                  v225 = 0;
                v226 = v224 + 16 * v225;
                v227 = v55 + 16 * v225 + 16 * v694;
                if (v692)
                {
                  v55 = v227;
                  v54 = v226;
                  v37 = v226;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v214 = v676 - 1;
                if (v676 == 1)
                  goto LABEL_569;
              }
            case 14:
              v228 = v696[0];
              __asm { FMOV            V1.2S, #1.0 }
              do
              {
                v234 = v688;
                do
                {
                  v235 = 1.0;
                  v236 = 1.0;
                  if (!v53 || (v236 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12))), v236 > 0.0))
                  {
                    if (v18 && (v235 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12))), v235 <= 0.0))
                    {
                      v238 = *(_DWORD *)(v37 + 8);
                      v241 = bswap32(LODWORD(v236));
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                    }
                    else
                    {
                      v237 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8)));
                      v238 = bswap32(COERCE_UNSIGNED_INT(v237 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)))
                                                                      * (float)(1.0 - v237))));
                      *(float *)&v239 = (float)(v236 + v235) - (float)(v235 * v236);
                      v240 = (float32x2_t)vrev32_s8(*(int8x8_t *)v77);
                      *(int8x8_t *)v77 = vrev32_s8((int8x8_t)vmla_f32(v240, vsub_f32(_D1, v240), (float32x2_t)vrev32_s8(*(int8x8_t *)v37)));
                      v241 = bswap32(v239);
                    }
                    *(_DWORD *)(v77 + 8) = v238;
                    *(_DWORD *)(v77 + 12) = v241;
                  }
                  v242 = v37 + 16 * v670;
                  if (v242 >= v55)
                    v243 = -(uint64_t)(int)v674;
                  else
                    v243 = 0;
                  v37 = v242 + 16 * v243;
                  v77 += 16 * v670;
                  --v234;
                }
                while (v234);
                v77 += 16 * v690;
                v244 = v54 + 16 * v694;
                if (v244 >= v692)
                  v245 = -(uint64_t)(v694 * (int)v671);
                else
                  v245 = 0;
                v246 = v244 + 16 * v245;
                v247 = v55 + 16 * v245 + 16 * v694;
                if (v692)
                {
                  v55 = v247;
                  v54 = v246;
                  v37 = v246;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v228;
              }
              while (v228);
              goto LABEL_616;
            case 15:
              v668 = v38;
              v669 = v39;
              v248 = v696[0];
              while (1)
              {
                v677 = v248;
                v249 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_316;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v250 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v251 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v251;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_316;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v250 = 1.0;
                  }
                  v252 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v253 = *(_OWORD *)v37;
                  LODWORD(v253) = v252.i32[1];
                  v652 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v254.i32 = PDAoverlayPDA(*(float *)v252.i32, *(double *)&v253, *(double *)v11.i64, *(double *)v12.i64, v250, v14, *(double *)v652.i64, v16, *(float *)v652.i32, *(double *)&v652.i64[1], *(float *)&v14);
                  v254.i32[1] = v255;
                  v254.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v254);
LABEL_316:
                  v256 = v37 + 16 * v670;
                  if (v256 >= v55)
                    v257 = -(uint64_t)(int)v674;
                  else
                    v257 = 0;
                  v37 = v256 + 16 * v257;
                  v77 += 16 * v670;
                  --v249;
                }
                while (v249);
                v77 += 16 * v690;
                v258 = v54 + 16 * v694;
                v259 = -(uint64_t)(v694 * (int)v671);
                if (v258 < v692)
                  v259 = 0;
                v260 = v258 + 16 * v259;
                v261 = v55 + 16 * v259 + 16 * v694;
                if (v692)
                {
                  v55 = v261;
                  v54 = v260;
                  v37 = v260;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v248 = v677 - 1;
                if (v677 == 1)
                  goto LABEL_569;
              }
            case 16:
              v668 = v38;
              v669 = v39;
              v262 = v696[0];
              while (1)
              {
                v678 = v262;
                v263 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_336;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v264 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v265 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v265;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_336;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v264 = 1.0;
                  }
                  v266 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v267 = *(_OWORD *)v37;
                  LODWORD(v267) = v266.i32[1];
                  v653 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v268.i32 = PDAdarkenPDA(*(float *)v266.i32, *(double *)&v267, *(double *)v11.i64, *(double *)v12.i64, v264, v14, *(double *)v653.i64, v16, *(float *)v653.i32, *(double *)&v653.i64[1], *(float *)&v14);
                  v268.i32[1] = v269;
                  v268.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v268);
LABEL_336:
                  v270 = v37 + 16 * v670;
                  if (v270 >= v55)
                    v271 = -(uint64_t)(int)v674;
                  else
                    v271 = 0;
                  v37 = v270 + 16 * v271;
                  v77 += 16 * v670;
                  --v263;
                }
                while (v263);
                v77 += 16 * v690;
                v272 = v54 + 16 * v694;
                v273 = -(uint64_t)(v694 * (int)v671);
                if (v272 < v692)
                  v273 = 0;
                v274 = v272 + 16 * v273;
                v275 = v55 + 16 * v273 + 16 * v694;
                if (v692)
                {
                  v55 = v275;
                  v54 = v274;
                  v37 = v274;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v262 = v678 - 1;
                if (v678 == 1)
                  goto LABEL_569;
              }
            case 17:
              v668 = v38;
              v669 = v39;
              v276 = v696[0];
              while (1)
              {
                v679 = v276;
                v277 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_356;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v278 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v279 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v279;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_356;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v278 = 1.0;
                  }
                  v280 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v281 = *(_OWORD *)v37;
                  LODWORD(v281) = v280.i32[1];
                  v654 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v282.i32 = PDAlightenPDA(*(float *)v280.i32, *(double *)&v281, *(double *)v11.i64, *(double *)v12.i64, v278, v14, *(double *)v654.i64, v16, *(float *)v654.i32, *(double *)&v654.i64[1], *(float *)&v14);
                  v282.i32[1] = v283;
                  v282.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v282);
LABEL_356:
                  v284 = v37 + 16 * v670;
                  if (v284 >= v55)
                    v285 = -(uint64_t)(int)v674;
                  else
                    v285 = 0;
                  v37 = v284 + 16 * v285;
                  v77 += 16 * v670;
                  --v277;
                }
                while (v277);
                v77 += 16 * v690;
                v286 = v54 + 16 * v694;
                v287 = -(uint64_t)(v694 * (int)v671);
                if (v286 < v692)
                  v287 = 0;
                v288 = v286 + 16 * v287;
                v289 = v55 + 16 * v287 + 16 * v694;
                if (v692)
                {
                  v55 = v289;
                  v54 = v288;
                  v37 = v288;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v276 = v679 - 1;
                if (v679 == 1)
                  goto LABEL_569;
              }
            case 18:
              v668 = v38;
              v669 = v39;
              v290 = v696[0];
              while (1)
              {
                v680 = v290;
                v291 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_376;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v292 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v293 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v293;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_376;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v292 = 1.0;
                  }
                  v294 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v295 = *(_OWORD *)v37;
                  LODWORD(v295) = v294.i32[1];
                  v655 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v296.i32 = PDAcolordodgePDA(*(float *)v294.i32, *(double *)&v295, *(double *)v11.i64, *(double *)v12.i64, v292, v14, *(double *)v655.i64, v16, *(float *)v655.i32, *(double *)&v655.i64[1], *(float *)&v14);
                  v296.i32[1] = v297;
                  v296.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v296);
LABEL_376:
                  v298 = v37 + 16 * v670;
                  if (v298 >= v55)
                    v299 = -(uint64_t)(int)v674;
                  else
                    v299 = 0;
                  v37 = v298 + 16 * v299;
                  v77 += 16 * v670;
                  --v291;
                }
                while (v291);
                v77 += 16 * v690;
                v300 = v54 + 16 * v694;
                v301 = -(uint64_t)(v694 * (int)v671);
                if (v300 < v692)
                  v301 = 0;
                v302 = v300 + 16 * v301;
                v303 = v55 + 16 * v301 + 16 * v694;
                if (v692)
                {
                  v55 = v303;
                  v54 = v302;
                  v37 = v302;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v290 = v680 - 1;
                if (v680 == 1)
                  goto LABEL_569;
              }
            case 19:
              v668 = v38;
              v669 = v39;
              v304 = v696[0];
              while (1)
              {
                v681 = v304;
                v305 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_396;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v306 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v307 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v307;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_396;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v306 = 1.0;
                  }
                  v308 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v309 = *(_OWORD *)v37;
                  LODWORD(v309) = v308.i32[1];
                  v656 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v310.i32 = PDAcolorburnPDA(*(float *)v308.i32, *(double *)&v309, *(double *)v11.i64, *(double *)v12.i64, v306, v14, *(double *)v656.i64, v16, *(float *)v656.i32, *(double *)&v656.i64[1], *(float *)&v14);
                  v310.i32[1] = v311;
                  v310.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v310);
LABEL_396:
                  v312 = v37 + 16 * v670;
                  if (v312 >= v55)
                    v313 = -(uint64_t)(int)v674;
                  else
                    v313 = 0;
                  v37 = v312 + 16 * v313;
                  v77 += 16 * v670;
                  --v305;
                }
                while (v305);
                v77 += 16 * v690;
                v314 = v54 + 16 * v694;
                v315 = -(uint64_t)(v694 * (int)v671);
                if (v314 < v692)
                  v315 = 0;
                v316 = v314 + 16 * v315;
                v317 = v55 + 16 * v315 + 16 * v694;
                if (v692)
                {
                  v55 = v317;
                  v54 = v316;
                  v37 = v316;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v304 = v681 - 1;
                if (v681 == 1)
                  goto LABEL_569;
              }
            case 20:
              v668 = v38;
              v669 = v39;
              v318 = v696[0];
              while (1)
              {
                v682 = v318;
                v319 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_416;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v13.n128_u32[0] = v12.i32[0];
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v320 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v320;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_416;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v13.n128_u32[0] = 1.0;
                  }
                  v321 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v657 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v322.i32 = PDAsoftlightPDA(*(float *)v321.i32, *(float *)&v321.i32[1], *(double *)v11.i64, *(int32x2_t *)v12.i8, v13.n128_f64[0], v14, *(double *)v657.i64, v16, v2, v3, (uint64_t)v26, v4, v5, v6, v40, v41, *(float *)v657.i32, v657.u32[1], v657.i64[1],
                                         *(float *)&v14);
                  v322.i32[1] = v323;
                  v322.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v322);
LABEL_416:
                  v324 = v37 + 16 * v670;
                  if (v324 >= v55)
                    v325 = -(uint64_t)(int)v674;
                  else
                    v325 = 0;
                  v37 = v324 + 16 * v325;
                  v77 += 16 * v670;
                  --v319;
                }
                while (v319);
                v77 += 16 * v690;
                v326 = v54 + 16 * v694;
                v327 = -(uint64_t)(v694 * (int)v671);
                if (v326 < v692)
                  v327 = 0;
                v328 = v326 + 16 * v327;
                v329 = v55 + 16 * v327 + 16 * v694;
                if (v692)
                {
                  v55 = v329;
                  v54 = v328;
                  v37 = v328;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v318 = v682 - 1;
                if (v682 == 1)
                  goto LABEL_569;
              }
            case 21:
              v668 = v38;
              v669 = v39;
              v330 = v696[0];
              while (1)
              {
                v683 = v330;
                v331 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_436;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v332 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v333 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v333;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_436;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v332 = 1.0;
                  }
                  v334 = vrev32_s8(*(int8x8_t *)v77);
                  v11.i32[0] = bswap32(*(_DWORD *)(v77 + 8));
                  v335 = *(_OWORD *)v37;
                  LODWORD(v335) = v334.i32[1];
                  v658 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v336.i32 = PDAhardlightPDA(*(float *)v334.i32, *(double *)&v335, *(double *)v11.i64, *(double *)v12.i64, v332, v14, *(double *)v658.i64, v16, *(float *)v658.i32, *(double *)&v658.i64[1], *(float *)&v14);
                  v336.i32[1] = v337;
                  v336.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)v77 = vrev32q_s8(v336);
LABEL_436:
                  v338 = v37 + 16 * v670;
                  if (v338 >= v55)
                    v339 = -(uint64_t)(int)v674;
                  else
                    v339 = 0;
                  v37 = v338 + 16 * v339;
                  v77 += 16 * v670;
                  --v331;
                }
                while (v331);
                v77 += 16 * v690;
                v340 = v54 + 16 * v694;
                v341 = -(uint64_t)(v694 * (int)v671);
                if (v340 < v692)
                  v341 = 0;
                v342 = v340 + 16 * v341;
                v343 = v55 + 16 * v341 + 16 * v694;
                if (v692)
                {
                  v55 = v343;
                  v54 = v342;
                  v37 = v342;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v330 = v683 - 1;
                if (v683 == 1)
                  goto LABEL_569;
              }
            case 22:
              v344 = v696[0];
              do
              {
                v345 = v688;
                do
                {
                  v346 = 1.0;
                  v347 = 1.0;
                  if (!v53 || (v347 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12))), v347 > 0.0))
                  {
                    if (v18 && (v346 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12))), v346 <= 0.0))
                    {
                      v359 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v359;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v347));
                    }
                    else
                    {
                      v348 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8)));
                      v349 = (float32x2_t)vrev32_s8(*(int8x8_t *)v77);
                      v350 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                      v351 = vadd_f32(*(float32x2_t *)v350.f32, v349);
                      v352 = vmul_n_f32(v349, v347);
                      v353 = vmul_n_f32(*(float32x2_t *)v350.f32, v346);
                      v354 = vsub_f32(v351, v352);
                      v355 = vsub_f32(v352, v353);
                      *(float32x2_t *)v356.i8 = vadd_f32(vsub_f32(v354, v353), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v355), (int8x8_t)vneg_f32(v355), (int8x8_t)v355));
                      v350.f32[0] = vmuls_lane_f32(v346, v350, 2);
                      v357 = (float)(v347 * v348) - v350.f32[0];
                      v358 = (float)((float)(v350.f32[2] + v348) - (float)(v347 * v348)) - v350.f32[0];
                      if (v357 < 0.0)
                        v357 = -v357;
                      *(float *)&v356.i32[2] = v358 + v357;
                      *(float *)&v356.i32[3] = (float)(v346 + v347) - (float)(v346 * v347);
                      *(int8x16_t *)v77 = vrev32q_s8(v356);
                    }
                  }
                  v360 = v37 + 16 * v670;
                  if (v360 >= v55)
                    v361 = -(uint64_t)(int)v674;
                  else
                    v361 = 0;
                  v37 = v360 + 16 * v361;
                  v77 += 16 * v670;
                  --v345;
                }
                while (v345);
                v77 += 16 * v690;
                v362 = v54 + 16 * v694;
                if (v362 >= v692)
                  v363 = -(uint64_t)(v694 * (int)v671);
                else
                  v363 = 0;
                v364 = v362 + 16 * v363;
                v365 = v55 + 16 * v363 + 16 * v694;
                if (v692)
                {
                  v55 = v365;
                  v54 = v364;
                  v37 = v364;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v344;
              }
              while (v344);
              goto LABEL_616;
            case 23:
              v366 = v696[0];
              do
              {
                v367 = v688;
                do
                {
                  v368 = 1.0;
                  v369 = 1.0;
                  if (!v53 || (v369 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12))), v369 > 0.0))
                  {
                    if (v18 && (v368 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 12))), v368 <= 0.0))
                    {
                      v372 = *(_DWORD *)(v37 + 8);
                      v376 = bswap32(LODWORD(v369));
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                    }
                    else
                    {
                      v370 = COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8)));
                      v371 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)));
                      v372 = bswap32(COERCE_UNSIGNED_INT((float)(v370 + v371) + (float)((float)(v370 * v371) * -2.0)));
                      *(float *)&v373 = (float)(v369 + v368) - (float)(v368 * v369);
                      v374 = (float32x2_t)vrev32_s8(*(int8x8_t *)v77);
                      v375 = (float32x2_t)vrev32_s8(*(int8x8_t *)v37);
                      *(int8x8_t *)v77 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(v374, v375), (float32x2_t)0xC0000000C0000000, vmul_f32(v374, v375)));
                      v376 = bswap32(v373);
                    }
                    *(_DWORD *)(v77 + 8) = v372;
                    *(_DWORD *)(v77 + 12) = v376;
                  }
                  v377 = v37 + 16 * v670;
                  if (v377 >= v55)
                    v378 = -(uint64_t)(int)v674;
                  else
                    v378 = 0;
                  v37 = v377 + 16 * v378;
                  v77 += 16 * v670;
                  --v367;
                }
                while (v367);
                v77 += 16 * v690;
                v379 = v54 + 16 * v694;
                if (v379 >= v692)
                  v380 = -(uint64_t)(v694 * (int)v671);
                else
                  v380 = 0;
                v381 = v379 + 16 * v380;
                v382 = v55 + 16 * v380 + 16 * v694;
                if (v692)
                {
                  v55 = v382;
                  v54 = v381;
                  v37 = v381;
                }
                else
                {
                  v37 += 16 * v694;
                }
                --v366;
              }
              while (v366);
              goto LABEL_616;
            case 24:
              v668 = v38;
              v669 = v39;
              v383 = v696[0];
              while (1)
              {
                v684 = v383;
                v384 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_499;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v385 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v386 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v386;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_499;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v385 = 1.0;
                  }
                  v387 = vrev32_s8(*(int8x8_t *)v77);
                  v659 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v388.i32 = PDAhuePDA(*(float *)v387.i32, *(float *)&v387.i32[1], COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8))), *(double *)v12.i64, v385, v14, *(double *)v659.i64, v16, *(float *)v659.i32, *(float *)&v659.i32[1], *(float *)&v659.i32[2], *(float *)&v659.i32[3], *(float *)&v14);
                  v388.i32[1] = v389;
                  v388.i64[1] = __PAIR64__(v12.u32[0], v390);
                  *(int8x16_t *)v77 = vrev32q_s8(v388);
LABEL_499:
                  v391 = v37 + 16 * v670;
                  if (v391 >= v55)
                    v392 = -(uint64_t)(int)v674;
                  else
                    v392 = 0;
                  v37 = v391 + 16 * v392;
                  v77 += 16 * v670;
                  --v384;
                }
                while (v384);
                v77 += 16 * v690;
                v393 = v54 + 16 * v694;
                v394 = -(uint64_t)(v694 * (int)v671);
                if (v393 < v692)
                  v394 = 0;
                v395 = v393 + 16 * v394;
                v396 = v55 + 16 * v394 + 16 * v694;
                if (v692)
                {
                  v55 = v396;
                  v54 = v395;
                  v37 = v395;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v383 = v684 - 1;
                if (v684 == 1)
                  goto LABEL_569;
              }
            case 25:
              v668 = v38;
              v669 = v39;
              v397 = v696[0];
              while (1)
              {
                v685 = v397;
                v398 = v688;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v53)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0)
                      goto LABEL_519;
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v399 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      v400 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v400;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_519;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
                    v399 = 1.0;
                  }
                  v401 = vrev32_s8(*(int8x8_t *)v77);
                  v660 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v402.i32 = PDAsaturationPDA(*(float *)v401.i32, *(float *)&v401.i32[1], COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8))), *(double *)v12.i64, v399, v14, *(double *)v660.i64, v16, *(float *)v660.i32, *(float *)&v660.i32[1], *(float *)&v660.i32[2], *(float *)&v660.i32[3], *(float *)&v14);
                  v402.i32[1] = v403;
                  v402.i64[1] = __PAIR64__(v12.u32[0], v404);
                  *(int8x16_t *)v77 = vrev32q_s8(v402);
LABEL_519:
                  v405 = v37 + 16 * v670;
                  if (v405 >= v55)
                    v406 = -(uint64_t)(int)v674;
                  else
                    v406 = 0;
                  v37 = v405 + 16 * v406;
                  v77 += 16 * v670;
                  --v398;
                }
                while (v398);
                v77 += 16 * v690;
                v407 = v54 + 16 * v694;
                v408 = -(uint64_t)(v694 * (int)v671);
                if (v407 < v692)
                  v408 = 0;
                v409 = v407 + 16 * v408;
                v410 = v55 + 16 * v408 + 16 * v694;
                if (v692)
                {
                  v55 = v410;
                  v54 = v409;
                  v37 = v409;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v397 = v685 - 1;
                if (v685 == 1)
                  goto LABEL_569;
              }
            case 26:
              v668 = v38;
              v669 = v39;
              v411 = v696[0];
              while (1)
              {
                v686 = v411;
                v412 = v688;
                do
                {
                  v413 = 1.0;
                  if (v53)
                  {
                    v413 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                    if (v413 <= 0.0)
                      goto LABEL_539;
                  }
                  if (v18)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v77 + 12));
                    LODWORD(v15) = LODWORD(v14);
                    if (*(float *)&v14 <= 0.0)
                    {
                      v414 = *(_DWORD *)(v37 + 8);
                      *(_QWORD *)v77 = *(_QWORD *)v37;
                      *(_DWORD *)(v77 + 8) = v414;
                      *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v413));
                      goto LABEL_539;
                    }
                  }
                  else
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v77 + 12));
                    LODWORD(v15) = 1.0;
                  }
                  v415 = vrev32q_s8(*(int8x16_t *)v37);
                  v12.i32[0] = v415.i32[3];
                  v661 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v77));
                  *(float *)v416.i32 = PDAluminosityPDA(*(float *)v415.i32, *(float *)&v415.i32[1], *(float *)&v415.i32[2], *(double *)v12.i64, v413, v14, v15, v661, *(float *)&v661, *((float *)&v661 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8))), *(float *)&v14, *(float *)&v15);
                  v416.i32[1] = v417;
                  v416.i64[1] = __PAIR64__(v12.u32[0], v418);
                  *(int8x16_t *)v77 = vrev32q_s8(v416);
LABEL_539:
                  v419 = v37 + 16 * v670;
                  if (v419 >= v55)
                    v420 = -(uint64_t)(int)v674;
                  else
                    v420 = 0;
                  v37 = v419 + 16 * v420;
                  v77 += 16 * v670;
                  --v412;
                }
                while (v412);
                v77 += 16 * v690;
                v421 = v54 + 16 * v694;
                v422 = -(uint64_t)(v694 * (int)v671);
                if (v421 < v692)
                  v422 = 0;
                v423 = v421 + 16 * v422;
                v424 = v55 + 16 * v422 + 16 * v694;
                if (v692)
                {
                  v55 = v424;
                  v54 = v423;
                  v37 = v423;
                }
                else
                {
                  v37 += 16 * v694;
                }
                v411 = v686 - 1;
                if (v686 == 1)
                  goto LABEL_569;
              }
            case 27:
              v668 = v38;
              v669 = v39;
              v425 = v696[0];
              break;
            default:
              goto LABEL_617;
          }
          break;
        }
LABEL_551:
        v687 = v425;
        v426 = v688;
        while (1)
        {
          LODWORD(v14) = 1.0;
          if (!v53 || (LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12)), *(float *)&v14 > 0.0))
          {
            if (!v18)
            {
              v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
              v427 = 1.0;
LABEL_558:
              v429 = vrev32_s8(*(int8x8_t *)v77);
              v662 = vrev32q_s8(*(int8x16_t *)v37);
              *(float *)v430.i32 = PDAluminosityPDA(*(float *)v429.i32, *(float *)&v429.i32[1], COERCE_FLOAT(bswap32(*(_DWORD *)(v77 + 8))), *(double *)v12.i64, v427, v14, *(double *)v662.i64, v16, *(float *)v662.i32, *(float *)&v662.i32[1], *(float *)&v662.i32[2], *(float *)&v662.i32[3], *(float *)&v14);
              v430.i32[1] = v431;
              v430.i64[1] = __PAIR64__(v12.u32[0], v432);
              *(int8x16_t *)v77 = vrev32q_s8(v430);
              goto LABEL_559;
            }
            v12.i32[0] = bswap32(*(_DWORD *)(v77 + 12));
            v427 = *(float *)v12.i32;
            if (*(float *)v12.i32 > 0.0)
              goto LABEL_558;
            v428 = *(_DWORD *)(v37 + 8);
            *(_QWORD *)v77 = *(_QWORD *)v37;
            *(_DWORD *)(v77 + 8) = v428;
            *(_DWORD *)(v77 + 12) = bswap32(LODWORD(v14));
          }
LABEL_559:
          v433 = v37 + 16 * v670;
          if (v433 >= v55)
            v434 = -(uint64_t)(int)v674;
          else
            v434 = 0;
          v37 = v433 + 16 * v434;
          v77 += 16 * v670;
          if (!--v426)
          {
            v77 += 16 * v690;
            v435 = v54 + 16 * v694;
            v436 = -(uint64_t)(v694 * (int)v671);
            if (v435 < v692)
              v436 = 0;
            v437 = v435 + 16 * v436;
            v438 = v55 + 16 * v436 + 16 * v694;
            if (v692)
            {
              v55 = v438;
              v54 = v437;
              v37 = v437;
            }
            else
            {
              v37 += 16 * v694;
            }
            v425 = v687 - 1;
            if (v687 == 1)
            {
LABEL_569:
              v696[0] = 0;
              LODWORD(v19) = v664;
              v21 = v667;
              v38 = v668;
              v39 = v669;
              goto LABEL_617;
            }
            goto LABEL_551;
          }
        }
      }
      v688 = v22;
      v690 = v38 - v22;
      if (v37)
      {
        v672 = *(_QWORD *)(v3 + 88);
        v673 = 0;
        v75 = v42 % (int)v674;
        v694 = (unint64_t)*(int *)(v3 + 76) >> 4;
        v76 = v37 + 16 * v44 * (v43 % (int)v671);
        v54 = v76 + 16 * v75;
        v55 = v76 + 16 * (int)v674;
        v670 = 1;
        v37 = v54;
        v77 = *(_QWORD *)(v3 + 40) + 16 * (*(int *)(v3 + 12) + v38 * *(int *)(v3 + 16));
        v665 = v43 % (int)v671;
        v666 = v75;
        goto LABEL_48;
      }
      v665 = *(_DWORD *)(v3 + 60);
      v666 = *(_DWORD *)(v3 + 56);
      v55 = 0;
      v670 = 1;
      v78 = v22;
LABEL_46:
      v672 = v37;
      v673 = 0;
      v692 = 0;
      v54 = 0;
      v694 = v44 - v78;
      v77 = v39;
      goto LABEL_48;
    }
    v37 += 16 * (v42 + v44 * v43);
    if (v44 == v38)
    {
      if ((uint64_t)(v39 - v37) < 1)
        goto LABEL_20;
      if (v22 < (v39 - v37) >> 4)
      {
        v45 = v38 * v25;
        v46 = v37 + 16 * v38 * v25;
        if (v39 <= v46 + 16 * (unint64_t)v23)
        {
          v39 += 16 * v45;
          v38 = -(uint64_t)v38;
          v4 = 1;
          v37 = v46;
          goto LABEL_40;
        }
LABEL_20:
        v4 = 1;
LABEL_40:
        v674 = v38;
        goto LABEL_41;
      }
      v39 += 16 * v23;
      v4 = 0xFFFFFFFFLL;
      v674 = (unint64_t)*(int *)(v3 + 28) >> 4;
      v37 += 16 * v23;
    }
    else
    {
      v4 = 1;
      v674 = (unint64_t)*(int *)(v3 + 76) >> 4;
    }
LABEL_41:
    v53 = v17 != 0;
    v665 = *(_DWORD *)(v3 + 60);
    v666 = *(_DWORD *)(v3 + 56);
    if (v26)
    {
      LODWORD(v671) = 0;
      v54 = 0;
      v692 = 0;
      v55 = -1;
      v694 = v674;
      goto LABEL_43;
    }
    v670 = v4;
    LODWORD(v671) = 0;
    v78 = (int)v4 * (int)v22;
    v688 = v22;
    v690 = v38 - v78;
    v55 = -1;
    v44 = v674;
    goto LABEL_46;
  }
  v27 = *(unsigned int *)(v3 + 128);
  if ((v27 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      RGBAF_mark_constmask(v3, v19, (uint64_t)v26, v4, v5, v6, v27, v8, v9, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v13, v14, v15, v16);
    else
      RGBAF_mark_pixelmask(v3, v19, v9, *(double *)v10.i64, v11, v12, v13.n128_f64[0], v14, v15, v16);
    return 1;
  }
  v47 = *(_DWORD *)(v3 + 112);
  v48 = *(_DWORD *)(v3 + 116);
  v49 = (v47 + 15) & 0xFFFFFFF0;
  v50 = v49 * v48;
  if ((int)v50 <= 4096)
  {
    v36 = v706;
    v52 = v3;
    goto LABEL_29;
  }
  v51 = malloc_type_malloc(v50, 0x5EE44C10uLL);
  if (v51)
  {
    v36 = v51;
    v52 = v667;
    v26 = *(uint16x4_t **)(v667 + 136);
    LODWORD(v27) = *(_DWORD *)(v667 + 128);
LABEL_29:
    CGSConvertBitsToMask(v26, *(_DWORD *)(v52 + 124), v36, v49, v47, v48, v27);
    v69 = *(_OWORD *)(v52 + 112);
    v702 = *(_OWORD *)(v52 + 96);
    v703 = v69;
    v70 = *(_OWORD *)(v52 + 144);
    v704 = *(_OWORD *)(v52 + 128);
    v705 = v70;
    v71 = *(_OWORD *)(v52 + 48);
    v698 = *(_OWORD *)(v52 + 32);
    v699 = v71;
    v72 = *(_OWORD *)(v52 + 80);
    v700 = *(_OWORD *)(v52 + 64);
    v701 = v72;
    v73 = *(_OWORD *)v52;
    v74 = *(_OWORD *)(v52 + 16);
    *(_OWORD *)v696 = *(_OWORD *)v52;
    v697 = v74;
    HIDWORD(v703) = (v47 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v704 + 1) = v36;
    if (BYTE1(v696[0]) << 8 == 1024)
      RGBAF_mark_constmask((uint64_t)v696, v19, v57, v58, v59, v60, v61, v62, *(double *)&v73, *(double *)&v74, *(double *)v63.i64, *(double *)v64.i64, v65, v66, v67, v68);
    else
      RGBAF_mark_pixelmask((uint64_t)v696, v19, *(double *)&v73, *(double *)&v74, v63, v64, v65.n128_f64[0], v66, v67, v68);
    if (v36 == (_BYTE *)v706)
      return 1;
LABEL_47:
    v81 = v36;
    goto LABEL_626;
  }
  return 1;
}

void RGBAF_mark_constmask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, __n128 a13, double a14, double a15, double a16)
{
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int8x16_t v20;
  float32x4_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  unsigned int v44;
  int v45;
  int v46;
  unsigned int v47;
  unint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  float32x4_t v53;
  unint64_t v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x16_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  unsigned int v64;
  float32x4_t v65;
  int v66;
  int v67;
  unsigned int v68;
  int8x16_t v69;
  float32x4_t v70;
  int v71;
  unsigned int v72;
  int8x16_t v73;
  float32x4_t v74;
  int v75;
  float32x4_t v76;
  float32x4_t v77;
  int v78;
  unsigned int v79;
  float v80;
  float v81;
  float v82;
  unsigned int v83;
  unsigned int v84;
  int8x8_t v85;
  float v86;
  int v87;
  unsigned int v88;
  int8x16_t v89;
  int v90;
  unsigned int v91;
  int8x16_t v92;
  int v93;
  float v94;
  float v95;
  float32x4_t v96;
  float32x4_t v97;
  int v98;
  float32x4_t v99;
  float32x4_t v100;
  int v101;
  float32x2_t v102;
  float v103;
  float32x2_t v104;
  float v105;
  float32x2_t v106;
  float v107;
  int8x16_t v108;
  int v109;
  float v110;
  float v111;
  float v112;
  int8x16_t v113;
  float v114;
  int v115;
  int8x16_t v116;
  float v117;
  double v118;
  double v119;
  double v120;
  __int32 v121;
  float32x2_t v122;
  int v128;
  float v129;
  float32x2_t v130;
  int8x16_t v131;
  float v132;
  float v133;
  unsigned int v134;
  unsigned int v135;
  float32x2_t v136;
  int v137;
  int8x16_t v138;
  float v139;
  double v140;
  double v141;
  double v142;
  __int32 v143;
  int v144;
  int8x16_t v145;
  float v146;
  double v147;
  double v148;
  double v149;
  __int32 v150;
  int v151;
  int8x16_t v152;
  float v153;
  double v154;
  double v155;
  double v156;
  __int32 v157;
  int v158;
  int8x16_t v159;
  float v160;
  double v161;
  double v162;
  double v163;
  __int32 v164;
  int v165;
  int8x16_t v166;
  float v167;
  double v168;
  double v169;
  double v170;
  __int32 v171;
  int v172;
  int8x16_t v173;
  double v174;
  __int32 v175;
  int v176;
  int8x16_t v177;
  float v178;
  double v179;
  double v180;
  double v181;
  __int32 v182;
  int v183;
  float32x4_t v184;
  float v185;
  float v186;
  float32x2_t v187;
  float32x2_t v188;
  float32x2_t v189;
  float32x2_t v190;
  float32x2_t v191;
  float32x2_t v192;
  float32x4_t v193;
  float v194;
  float32x2_t v195;
  int v196;
  float v197;
  float32x2_t v198;
  int8x16_t v199;
  float v200;
  float v201;
  float32x2_t v202;
  float32_t v203;
  float32x2_t v204;
  float32x2_t v205;
  int v206;
  int8x16_t v207;
  float v208;
  double v209;
  __int32 v210;
  unsigned int v211;
  int v212;
  int8x16_t v213;
  float v214;
  double v215;
  __int32 v216;
  unsigned int v217;
  int v218;
  int8x16_t v219;
  float v220;
  __int32 v221;
  unsigned int v222;
  int v223;
  int8x16_t v224;
  float v225;
  double v226;
  __int32 v227;
  unsigned int v228;
  double v229;
  __int128 v230;
  double v231;
  double v232;
  double v233;
  float32x4_t v234;

  v16 = *(_QWORD *)(a1 + 136);
  if (v16)
  {
    v18 = *(_DWORD *)(a1 + 4);
    v17 = *(_DWORD *)(a1 + 8);
    v19 = *(_QWORD *)(a1 + 48);
    v20 = *(int8x16_t *)*(_QWORD *)(a1 + 88);
    v21 = (float32x4_t)vrev32q_s8(v20);
    v22 = (unint64_t)*(int *)(a1 + 28) >> 4;
    v23 = *(_QWORD *)(a1 + 40) + 16 * (*(int *)(a1 + 12) + v22 * *(int *)(a1 + 16));
    v24 = *(int *)(a1 + 124);
    v25 = v16 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v24;
    v26 = v24 - v18;
    v27 = v22 - v18;
    v234 = v21;
    switch((int)a2)
    {
      case 0:
        do
        {
          v28 = v18;
          do
          {
            v29 = *(unsigned __int8 *)v25;
            if (*(_BYTE *)v25)
            {
              if (v29 == 255)
              {
                *(_QWORD *)v23 = 0;
                *(_QWORD *)(v23 + 8) = 0;
              }
              else
              {
                *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), (float)(v29 ^ 0xFFu) * 0.0039216));
              }
            }
            ++v25;
            v23 += 16;
            --v28;
          }
          while (v28);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 1:
        v30 = -1;
        v31 = v25 & 3;
        if ((v25 & 3) != 0)
        {
          v18 += v31;
          v30 = -1 << (8 * v31);
          v32 = v25 & 3;
          v25 &= 0xFFFFFFFFFFFFFFFCLL;
          v23 -= 16 * v32;
        }
        v33 = ((_BYTE)v18 + (_BYTE)v25) & 3;
        if ((((_BYTE)v18 + (_BYTE)v25) & 3) != 0)
        {
          v34 = 4 - v33;
          v31 += v34;
          v35 = 0xFFFFFFFF >> (8 * v34);
          if (v18 >= 4)
            v33 = 0xFFFFFFFF >> (8 * v34);
          else
            v33 = 0;
          if (v18 >= 4)
            v35 = -1;
          v30 &= v35;
        }
        v36 = v26 - v31;
        v37 = v27 - v31;
        do
        {
          v38 = *(_DWORD *)v25 & v30;
          v39 = v18 >> 2;
          v40 = v33;
          if (!v38)
            goto LABEL_40;
LABEL_22:
          if (v38 == -1)
          {
            *(int8x16_t *)v23 = v20;
            *(int8x16_t *)(v23 + 16) = v20;
            *(int8x16_t *)(v23 + 32) = v20;
LABEL_37:
            *(int8x16_t *)(v23 + 48) = v20;
            goto LABEL_40;
          }
          while (1)
          {
            if ((_BYTE)v38)
            {
              v41 = v20;
              if (v38 != 255)
                v41 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)v38 * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)v23), 1.0 - (float)((float)v38 * 0.0039216)));
              *(int8x16_t *)v23 = v41;
            }
            if (BYTE1(v38))
            {
              v42 = v20;
              if (BYTE1(v38) != 255)
                v42 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)BYTE1(v38) * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 16)), 1.0 - (float)((float)BYTE1(v38) * 0.0039216)));
              *(int8x16_t *)(v23 + 16) = v42;
            }
            if (BYTE2(v38))
            {
              v43 = v20;
              if (BYTE2(v38) != 255)
                v43 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)BYTE2(v38) * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 32)), 1.0 - (float)((float)BYTE2(v38) * 0.0039216)));
              *(int8x16_t *)(v23 + 32) = v43;
            }
            v44 = HIBYTE(v38);
            if (v44 == 255)
              goto LABEL_37;
            if (v44)
              *(int8x16_t *)(v23 + 48) = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)v44 * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 48)), 1.0 - (float)((float)v44 * 0.0039216)));
LABEL_40:
            while (1)
            {
              v45 = v39;
              v23 += 64;
              --v39;
              v25 += 4;
              if (v45 < 2)
                break;
              v38 = *(_DWORD *)v25;
              if (*(_DWORD *)v25)
                goto LABEL_22;
            }
            if (!v40)
              break;
            v40 = 0;
            v38 = *(_DWORD *)v25 & v33;
          }
          v25 += v36;
          v23 += 16 * v37;
          --v17;
        }
        while (v17);
        return;
      case 2:
        v46 = -1;
        v47 = v25 & 3;
        if ((v25 & 3) != 0)
        {
          v18 += v47;
          v46 = -1 << (8 * v47);
          v48 = v25 & 3;
          v25 &= 0xFFFFFFFFFFFFFFFCLL;
          v23 -= 16 * v48;
        }
        v49 = ((_BYTE)v18 + (_BYTE)v25) & 3;
        if ((((_BYTE)v18 + (_BYTE)v25) & 3) != 0)
        {
          v50 = 4 - v49;
          v47 += v50;
          v51 = 0xFFFFFFFF >> (8 * v50);
          if (v18 >= 4)
            v49 = 0xFFFFFFFF >> (8 * v50);
          else
            v49 = 0;
          if (v18 >= 4)
            v51 = -1;
          v46 &= v51;
        }
        v52 = v26 - v47;
        *(float *)v20.i32 = 1.0 - v21.f32[3];
        v53 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.i8, 0);
        v54 = v27 - v47;
        while (1)
        {
          v55 = *(_DWORD *)v25 & v46;
          v56 = v18 >> 2;
          v57 = v49;
          if (!v55)
            goto LABEL_69;
LABEL_58:
          if (v55 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v55)
            {
              v61 = vmulq_n_f32(v21, (float)v55 * 0.0039216);
              *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v61, (float32x4_t)vrev32q_s8(*(int8x16_t *)v23), 1.0 - v61.f32[3]));
            }
            if ((v55 & 0xFF00) != 0)
            {
              v62 = vmulq_n_f32(v21, (float)BYTE1(v55) * 0.0039216);
              *(int8x16_t *)(v23 + 16) = vrev32q_s8((int8x16_t)vmlaq_n_f32(v62, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 16)), 1.0 - v62.f32[3]));
            }
            if ((v55 & 0xFF0000) != 0)
            {
              v63 = vmulq_n_f32(v21, (float)BYTE2(v55) * 0.0039216);
              *(int8x16_t *)(v23 + 32) = vrev32q_s8((int8x16_t)vmlaq_n_f32(v63, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 32)), 1.0 - v63.f32[3]));
            }
            v64 = HIBYTE(v55);
            if (v64)
            {
              v65 = vmulq_n_f32(v21, (float)v64 * 0.0039216);
              v60 = (int8x16_t)vmlaq_n_f32(v65, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 48)), 1.0 - v65.f32[3]);
              goto LABEL_68;
            }
LABEL_69:
            while (1)
            {
              v66 = v56;
              v23 += 64;
              --v56;
              v25 += 4;
              if (v66 < 2)
                break;
              v55 = *(_DWORD *)v25;
              if (*(_DWORD *)v25)
                goto LABEL_58;
            }
            if (!v57)
              break;
            v57 = 0;
            v55 = *(_DWORD *)v25 & v49;
          }
          v25 += v52;
          v23 += 16 * v54;
          if (!--v17)
            return;
        }
        v58 = vrev32q_s8((int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 16))));
        *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(*(int8x16_t *)v23)));
        *(int8x16_t *)(v23 + 16) = v58;
        v59 = *(int8x16_t *)(v23 + 48);
        *(int8x16_t *)(v23 + 32) = vrev32q_s8((int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 32))));
        v60 = (int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(v59));
LABEL_68:
        *(_DWORD *)(v23 + 48) = bswap32(v60.u32[0]);
        *(int8x8_t *)(v23 + 52) = vrev32_s8(vext_s8(*(int8x8_t *)v60.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), 4uLL));
        *(_DWORD *)(v23 + 60) = bswap32(v60.u32[3]);
        goto LABEL_69;
      case 3:
        do
        {
          v67 = v18;
          do
          {
            v68 = *(unsigned __int8 *)v25;
            if (*(_BYTE *)v25)
            {
              if (v68 == 255)
              {
                v69 = (int8x16_t)vmulq_n_f32(v21, COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12))));
              }
              else
              {
                v70 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
                v69 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, vmuls_lane_f32((float)v68 * 0.0039216, v70, 3)), v70, 1.0 - (float)((float)v68 * 0.0039216));
              }
              *(int8x16_t *)v23 = vrev32q_s8(v69);
            }
            ++v25;
            v23 += 16;
            --v67;
          }
          while (v67);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 4:
        do
        {
          v71 = v18;
          do
          {
            v72 = *(unsigned __int8 *)v25;
            if (*(_BYTE *)v25)
            {
              if (v72 == 255)
              {
                v73 = (int8x16_t)vmulq_n_f32(v21, 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12))));
              }
              else
              {
                v74 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
                v73 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)((float)v72 * 0.0039216) * (float)(1.0 - v74.f32[3])), v74, 1.0 - (float)((float)v72 * 0.0039216));
              }
              *(int8x16_t *)v23 = vrev32q_s8(v73);
            }
            ++v25;
            v23 += 16;
            --v71;
          }
          while (v71);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 5:
        do
        {
          v75 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v76 = vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
              *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v77, 1.0 - v76.f32[3]), v76, v77, 3));
            }
            ++v25;
            v23 += 16;
            --v75;
          }
          while (v75);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 6:
        while (1)
        {
          v78 = v18;
          do
          {
            v79 = *(unsigned __int8 *)v25;
            if (!*(_BYTE *)v25)
              goto LABEL_107;
            v80 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
            v81 = 1.0 - v80;
            if ((float)(1.0 - v80) >= 1.0)
            {
              v86 = (float)v79 * 0.0039216;
              v83 = bswap32(COERCE_UNSIGNED_INT(v86 * v21.f32[2]));
              v84 = bswap32(COERCE_UNSIGNED_INT(v86 * v21.f32[3]));
              v85 = vrev32_s8((int8x8_t)vmul_n_f32(*(float32x2_t *)v21.f32, v86));
            }
            else
            {
              if (v81 <= 0.0)
                goto LABEL_107;
              v82 = (float)v79 * 0.0039216;
              v83 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))) + (float)((float)(v82 * v21.f32[2]) * v81)));
              v84 = bswap32(COERCE_UNSIGNED_INT(v80 + (float)((float)(v82 * v21.f32[3]) * v81)));
              v85 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v23), vmul_n_f32(*(float32x2_t *)v21.f32, v82), v81));
            }
            *(int8x8_t *)v23 = v85;
            *(_DWORD *)(v23 + 8) = v83;
            *(_DWORD *)(v23 + 12) = v84;
LABEL_107:
            ++v25;
            v23 += 16;
            --v78;
          }
          while (v78);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 7:
        do
        {
          v87 = v18;
          do
          {
            v88 = *(unsigned __int8 *)v25;
            if (*(_BYTE *)v25)
            {
              if (v88 == 255)
                v89 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), v21, 3);
              else
                v89 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), (float)((float)((float)v88 * 0.0039216) * v21.f32[3])+ (float)(1.0 - (float)((float)v88 * 0.0039216)));
              *(int8x16_t *)v23 = vrev32q_s8(v89);
            }
            ++v25;
            v23 += 16;
            --v87;
          }
          while (v87);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 8:
        do
        {
          v90 = v18;
          do
          {
            v91 = *(unsigned __int8 *)v25;
            if (*(_BYTE *)v25)
            {
              if (v91 == 255)
                v92 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), 1.0 - v21.f32[3]);
              else
                v92 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), (float)((float)((float)v91 * -0.0039216) * v21.f32[3]) + 1.0);
              *(int8x16_t *)v23 = vrev32q_s8(v92);
            }
            ++v25;
            v23 += 16;
            --v90;
          }
          while (v90);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 9:
        do
        {
          v93 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v94 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              v95 = 1.0 - v94;
              v96 = vmulq_n_f32(v21, v94);
              v97 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
              *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v97, v95 + v96.f32[3]), v96, 1.0 - v97.f32[3]));
            }
            ++v25;
            v23 += 16;
            --v93;
          }
          while (v93);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 10:
        do
        {
          v98 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v99 = vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              v100 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
              *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v100, 1.0 - v99.f32[3]), v99, 1.0 - v100.f32[3]));
            }
            ++v25;
            v23 += 16;
            --v98;
          }
          while (v98);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 11:
        do
        {
          v101 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              if (v19)
                a13.n128_u32[0] = bswap32(*(_DWORD *)(v23 + 12));
              else
                a13.n128_u32[0] = 1.0;
              *(float *)&a14 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              v102 = vmul_n_f32(*(float32x2_t *)v21.f32, *(float *)&a14);
              v103 = *(float *)&a14 * v21.f32[2];
              *(float *)&a14 = *(float *)&a14 * v21.f32[3];
              v104 = vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)a13.n128_u64[0], 0), (float32x2_t)vrev32_s8(*(int8x8_t *)v23));
              v105 = *(float *)&a14 + a13.n128_f32[0];
              v106 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a14, 0), v102);
              v107 = (float)(*(float *)&a14 - v103)
                   + (float)(a13.n128_f32[0] - COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))));
              if (v105 <= 1.0)
                *(float *)&a14 = v105;
              else
                *(float *)&a14 = 1.0;
              *(float32x2_t *)v108.i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a14, 0), vadd_f32(v106, v104));
              *(float *)&v108.i32[2] = *(float *)&a14 - v107;
              v108.i32[3] = LODWORD(a14);
              a13 = (__n128)vrev32q_s8(v108);
              *(__n128 *)v23 = a13;
            }
            ++v25;
            v23 += 16;
            --v101;
          }
          while (v101);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 12:
        do
        {
          v109 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v110 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              v111 = v110 * v21.f32[2];
              v112 = (float)(v110 * v21.f32[3]) + COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
              *(float32x2_t *)v113.i8 = vadd_f32(vmul_n_f32(*(float32x2_t *)v21.f32, v110), (float32x2_t)vrev32_s8(*(int8x8_t *)v23));
              v114 = v111 + COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8)));
              if (v112 > 1.0)
                v112 = 1.0;
              v113.i64[1] = __PAIR64__(LODWORD(v112), LODWORD(v114));
              *(int8x16_t *)v23 = vrev32q_s8(v113);
            }
            ++v25;
            v23 += 16;
            --v109;
          }
          while (v109);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 13:
        while (1)
        {
          v115 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v116 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v116.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v117 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_168;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v117 = 1.0;
                }
                v118 = *(double *)v23;
                v119 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v118) = HIDWORD(v119);
                *(_QWORD *)&v120 = vextq_s8(v116, v116, 4uLL).u64[0];
                *(float *)v116.i32 = PDAmultiplyPDA(*(float *)&v119, v118, a11, a12, v117, v119, v120, a16, *(float *)v116.i32, COERCE_DOUBLE(__PAIR64__(v116.u32[3], HIDWORD(v120))), *(float *)&v116.i32[3]);
                v21 = v234;
                v116.i32[1] = v121;
                v116.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_168:
                *(int8x16_t *)v23 = vrev32q_s8(v116);
              }
            }
            ++v25;
            v23 += 16;
            --v115;
          }
          while (v115);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 14:
        v122 = (float32x2_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL).u64[0];
        __asm { FMOV            V3.2S, #1.0 }
        while (1)
        {
          v128 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v129 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              v130 = vmul_n_f32(v122, v129);
              if (v130.f32[1] > 0.0)
              {
                *(float32x2_t *)v131.i8 = vmul_n_f32(*(float32x2_t *)v21.f32, v129);
                if (v19)
                {
                  v132 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  if (v132 <= 0.0)
                  {
                    v131.u64[1] = (unint64_t)v130;
                    *(int8x16_t *)v23 = vrev32q_s8(v131);
                    goto LABEL_181;
                  }
                }
                else
                {
                  v132 = 1.0;
                }
                v133 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8)));
                v134 = bswap32(COERCE_UNSIGNED_INT(vmlas_n_f32(v133, 1.0 - v133, v130.f32[0])));
                *(float *)&v135 = (float)(v130.f32[1] + v132) - (float)(v132 * v130.f32[1]);
                v136 = (float32x2_t)vrev32_s8(*(int8x8_t *)v23);
                *(int8x8_t *)v23 = vrev32_s8((int8x8_t)vmla_f32(v136, vsub_f32(_D3, v136), *(float32x2_t *)v131.i8));
                *(_DWORD *)(v23 + 8) = v134;
                *(_DWORD *)(v23 + 12) = bswap32(v135);
              }
            }
LABEL_181:
            ++v25;
            v23 += 16;
            --v128;
          }
          while (v128);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 15:
        while (1)
        {
          v137 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v138 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v138.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v139 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_192;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v139 = 1.0;
                }
                v140 = *(double *)v23;
                v141 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v140) = HIDWORD(v141);
                *(_QWORD *)&v142 = vextq_s8(v138, v138, 4uLL).u64[0];
                *(float *)v138.i32 = PDAoverlayPDA(*(float *)&v141, v140, a11, a12, v139, v141, v142, a16, *(float *)v138.i32, COERCE_DOUBLE(__PAIR64__(v138.u32[3], HIDWORD(v142))), *(float *)&v138.i32[3]);
                v21 = v234;
                v138.i32[1] = v143;
                v138.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_192:
                *(int8x16_t *)v23 = vrev32q_s8(v138);
              }
            }
            ++v25;
            v23 += 16;
            --v137;
          }
          while (v137);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 16:
        while (1)
        {
          v144 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v145 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v145.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v146 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_204;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v146 = 1.0;
                }
                v147 = *(double *)v23;
                v148 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v147) = HIDWORD(v148);
                *(_QWORD *)&v149 = vextq_s8(v145, v145, 4uLL).u64[0];
                *(float *)v145.i32 = PDAdarkenPDA(*(float *)&v148, v147, a11, a12, v146, v148, v149, a16, *(float *)v145.i32, COERCE_DOUBLE(__PAIR64__(v145.u32[3], HIDWORD(v149))), *(float *)&v145.i32[3]);
                v21 = v234;
                v145.i32[1] = v150;
                v145.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_204:
                *(int8x16_t *)v23 = vrev32q_s8(v145);
              }
            }
            ++v25;
            v23 += 16;
            --v144;
          }
          while (v144);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 17:
        while (1)
        {
          v151 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v152 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v152.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v153 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_216;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v153 = 1.0;
                }
                v154 = *(double *)v23;
                v155 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v154) = HIDWORD(v155);
                *(_QWORD *)&v156 = vextq_s8(v152, v152, 4uLL).u64[0];
                *(float *)v152.i32 = PDAlightenPDA(*(float *)&v155, v154, a11, a12, v153, v155, v156, a16, *(float *)v152.i32, COERCE_DOUBLE(__PAIR64__(v152.u32[3], HIDWORD(v156))), *(float *)&v152.i32[3]);
                v21 = v234;
                v152.i32[1] = v157;
                v152.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_216:
                *(int8x16_t *)v23 = vrev32q_s8(v152);
              }
            }
            ++v25;
            v23 += 16;
            --v151;
          }
          while (v151);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 18:
        while (1)
        {
          v158 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v159 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v159.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v160 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_228;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v160 = 1.0;
                }
                v161 = *(double *)v23;
                v162 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v161) = HIDWORD(v162);
                *(_QWORD *)&v163 = vextq_s8(v159, v159, 4uLL).u64[0];
                *(float *)v159.i32 = PDAcolordodgePDA(*(float *)&v162, v161, a11, a12, v160, v162, v163, a16, *(float *)v159.i32, COERCE_DOUBLE(__PAIR64__(v159.u32[3], HIDWORD(v163))), *(float *)&v159.i32[3]);
                v21 = v234;
                v159.i32[1] = v164;
                v159.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_228:
                *(int8x16_t *)v23 = vrev32q_s8(v159);
              }
            }
            ++v25;
            v23 += 16;
            --v158;
          }
          while (v158);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 19:
        while (1)
        {
          v165 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v166 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v166.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v167 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_240;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v167 = 1.0;
                }
                v168 = *(double *)v23;
                v169 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v168) = HIDWORD(v169);
                *(_QWORD *)&v170 = vextq_s8(v166, v166, 4uLL).u64[0];
                *(float *)v166.i32 = PDAcolorburnPDA(*(float *)&v169, v168, a11, a12, v167, v169, v170, a16, *(float *)v166.i32, COERCE_DOUBLE(__PAIR64__(v166.u32[3], HIDWORD(v170))), *(float *)&v166.i32[3]);
                v21 = v234;
                v166.i32[1] = v171;
                v166.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_240:
                *(int8x16_t *)v23 = vrev32q_s8(v166);
              }
            }
            ++v25;
            v23 += 16;
            --v165;
          }
          while (v165);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 20:
        while (1)
        {
          v172 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v173 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v173.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  a13.n128_u32[0] = LODWORD(a12);
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_252;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  a13.n128_u32[0] = 1.0;
                }
                v174 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                DWORD2(v230) = v173.i32[3];
                *(_QWORD *)&v230 = vextq_s8(v173, v173, 4uLL).u64[0];
                *(float *)v173.i32 = PDAsoftlightPDA(*(float *)&v174, *((float *)&v174 + 1), a11, *(int32x2_t *)&a12, a13.n128_f64[0], v174, *(double *)&v230, a16, a1, a2, a3, a4, a5, a6, a7, a8, *(float *)v173.i32, v230, *(uint64_t *)((char *)&v230 + 4),
                                       *(float *)&v173.i32[3]);
                v21 = v234;
                v173.i32[1] = v175;
                v173.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_252:
                *(int8x16_t *)v23 = vrev32q_s8(v173);
              }
            }
            ++v25;
            v23 += 16;
            --v172;
          }
          while (v172);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 21:
        while (1)
        {
          v176 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v177 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v177.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v178 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_264;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v178 = 1.0;
                }
                v179 = *(double *)v23;
                v180 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v179) = HIDWORD(v180);
                *(_QWORD *)&v181 = vextq_s8(v177, v177, 4uLL).u64[0];
                *(float *)v177.i32 = PDAhardlightPDA(*(float *)&v180, v179, a11, a12, v178, v180, v181, a16, *(float *)v177.i32, COERCE_DOUBLE(__PAIR64__(v177.u32[3], HIDWORD(v181))), *(float *)&v177.i32[3]);
                v21 = v234;
                v177.i32[1] = v182;
                v177.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_264:
                *(int8x16_t *)v23 = vrev32q_s8(v177);
              }
            }
            ++v25;
            v23 += 16;
            --v176;
          }
          while (v176);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 22:
        while (1)
        {
          v183 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v184 = vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (v184.f32[3] > 0.0)
              {
                if (v19)
                {
                  v185 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  if (v185 <= 0.0)
                  {
LABEL_278:
                    *(int8x16_t *)v23 = vrev32q_s8((int8x16_t)v184);
                    goto LABEL_279;
                  }
                }
                else
                {
                  v185 = 1.0;
                }
                v186 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8)));
                v187 = (float32x2_t)vrev32_s8(*(int8x8_t *)v23);
                v188 = vadd_f32(*(float32x2_t *)v184.f32, v187);
                v189 = vmul_laneq_f32(v187, v184, 3);
                v190 = vmul_n_f32(*(float32x2_t *)v184.f32, v185);
                v191 = vsub_f32(v188, v189);
                v192 = vsub_f32(v189, v190);
                v184.f32[0] = vmuls_lane_f32(v185, v184, 2);
                *(float32x2_t *)v193.f32 = vadd_f32(vsub_f32(v191, v190), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v192), (int8x8_t)vneg_f32(v192), (int8x8_t)v192));
                v194 = (float)(v184.f32[3] * v186) - v184.f32[0];
                v184.f32[0] = (float)((float)(v184.f32[2] + v186) - (float)(v184.f32[3] * v186)) - v184.f32[0];
                if (v194 < 0.0)
                  v194 = -v194;
                v193.i64[1] = __PAIR64__((float)(v185 + v184.f32[3]) - (float)(v185 * v184.f32[3]), v184.f32[0] + v194);
                v184 = v193;
                goto LABEL_278;
              }
            }
LABEL_279:
            ++v25;
            v23 += 16;
            --v183;
          }
          while (v183);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 23:
        v195 = (float32x2_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL).u64[0];
        while (1)
        {
          v196 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v197 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              v198 = vmul_n_f32(v195, v197);
              if (v198.f32[1] > 0.0)
              {
                *(float32x2_t *)v199.i8 = vmul_n_f32(*(float32x2_t *)v21.f32, v197);
                if (v19)
                {
                  LODWORD(v200) = bswap32(*(_DWORD *)(v23 + 12));
                  if (v200 <= 0.0)
                  {
                    v199.u64[1] = (unint64_t)v198;
                    *(int8x16_t *)v23 = vrev32q_s8(v199);
                    goto LABEL_291;
                  }
                }
                else
                {
                  v200 = 1.0;
                }
                LODWORD(v201) = bswap32(*(_DWORD *)(v23 + 8));
                v202.f32[0] = (float)-v201 * v198.f32[0];
                v203 = -v200;
                v204 = (float32x2_t)vrev32_s8(*(int8x8_t *)v23);
                v205 = vadd_f32(v198, (float32x2_t)__PAIR64__(LODWORD(v200), LODWORD(v201)));
                v202.f32[1] = v203;
                v198.i32[0] = 2.0;
                *(int8x8_t *)v23 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v199.i8, v204), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v199.i8, v204)));
                *(int8x8_t *)(v23 + 8) = vrev32_s8((int8x8_t)vmla_f32(v205, v198, v202));
              }
            }
LABEL_291:
            ++v25;
            v23 += 16;
            --v196;
          }
          while (v196);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 24:
        while (1)
        {
          v206 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v207 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v207.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v208 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_302;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v208 = 1.0;
                }
                v209 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                *(_QWORD *)&v231 = vextq_s8(v207, v207, 4uLL).u64[0];
                *(float *)v207.i32 = PDAhuePDA(*(float *)&v209, *((float *)&v209 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), a12, v208, v209, v231, a16, *(float *)v207.i32, *(float *)&v231, *((float *)&v231 + 1), *(float *)&v207.i32[3], *(float *)&v207.i32[3]);
                v21 = v234;
                v207.i32[1] = v210;
                v207.i64[1] = __PAIR64__(LODWORD(a12), v211);
LABEL_302:
                *(int8x16_t *)v23 = vrev32q_s8(v207);
              }
            }
            ++v25;
            v23 += 16;
            --v206;
          }
          while (v206);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 25:
        while (1)
        {
          v212 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v213 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v213.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v214 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                    goto LABEL_314;
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  v214 = 1.0;
                }
                v215 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                *(_QWORD *)&v232 = vextq_s8(v213, v213, 4uLL).u64[0];
                *(float *)v213.i32 = PDAsaturationPDA(*(float *)&v215, *((float *)&v215 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), a12, v214, v215, v232, a16, *(float *)v213.i32, *(float *)&v232, *((float *)&v232 + 1), *(float *)&v213.i32[3], *(float *)&v213.i32[3]);
                v21 = v234;
                v213.i32[1] = v216;
                v213.i64[1] = __PAIR64__(LODWORD(a12), v217);
LABEL_314:
                *(int8x16_t *)v23 = vrev32q_s8(v213);
              }
            }
            ++v25;
            v23 += 16;
            --v212;
          }
          while (v212);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 26:
        while (1)
        {
          v218 = v18;
          do
          {
            if (*(_BYTE *)v25)
            {
              v219 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              LODWORD(a12) = v219.i32[3];
              if (*(float *)&v219.i32[3] > 0.0)
              {
                if (v19)
                {
                  v220 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  *(float *)&a14 = v220;
                  if (v220 <= 0.0)
                    goto LABEL_326;
                }
                else
                {
                  v220 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  LODWORD(a14) = 1.0;
                }
                v229 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                *(float *)v219.i32 = PDAluminosityPDA(*(float *)v219.i32, *(float *)&v219.i32[1], *(float *)&v219.i32[2], a12, *(float *)&v219.i32[3], a14, v229, a16, *(float *)&v229, *((float *)&v229 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), v220, *(float *)&a14);
                v21 = v234;
                v219.i32[1] = v221;
                v219.i64[1] = __PAIR64__(LODWORD(a12), v222);
LABEL_326:
                *(int8x16_t *)v23 = vrev32q_s8(v219);
              }
            }
            ++v25;
            v23 += 16;
            --v218;
          }
          while (v218);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17)
            return;
        }
      case 27:
        break;
      default:
        return;
    }
LABEL_330:
    v223 = v18;
    while (1)
    {
      if (!*(_BYTE *)v25)
        goto LABEL_339;
      v224 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
      if (*(float *)&v224.i32[3] <= 0.0)
        goto LABEL_339;
      if (v19)
      {
        LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
        v225 = *(float *)&a12;
        if (*(float *)&a12 <= 0.0)
          goto LABEL_338;
      }
      else
      {
        LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
        v225 = 1.0;
      }
      v226 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
      *(_QWORD *)&v233 = vextq_s8(v224, v224, 4uLL).u64[0];
      *(float *)v224.i32 = PDAluminosityPDA(*(float *)&v226, *((float *)&v226 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), a12, v225, v226, v233, a16, *(float *)v224.i32, *(float *)&v233, *((float *)&v233 + 1), *(float *)&v224.i32[3], *(float *)&v224.i32[3]);
      v21 = v234;
      v224.i32[1] = v227;
      v224.i64[1] = __PAIR64__(LODWORD(a12), v228);
LABEL_338:
      *(int8x16_t *)v23 = vrev32q_s8(v224);
LABEL_339:
      ++v25;
      v23 += 16;
      if (!--v223)
      {
        v25 += v26;
        v23 += 16 * v27;
        if (!--v17)
          return;
        goto LABEL_330;
      }
    }
  }
}

void RGBAF_mark_pixelmask(uint64_t a1, uint64_t a2, double a3, double a4, int8x16_t a5, int8x16_t a6, double a7, double a8, double a9, double a10)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int8x16_t *v17;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x16_t *v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  _BOOL4 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  unsigned int v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  int8x16_t v49;
  int8x16_t *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int8x16_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  float v61;
  float v62;
  float32x4_t v63;
  float v64;
  float v65;
  int8x16_t *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int8x16_t *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  float32x4_t v77;
  int8x16_t v78;
  unsigned int v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  int8x16_t *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  float32x4_t v93;
  int8x16_t v94;
  unsigned int v95;
  float32x4_t v96;
  float32x4_t v97;
  int8x16_t *v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int8x16_t *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  unsigned int v107;
  int8x16_t v108;
  float32x4_t v109;
  int8x16_t *v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  int8x16_t *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  float v119;
  float v120;
  float32x4_t v121;
  float32x4_t v122;
  int8x16_t *v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  int8x16_t *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  float v132;
  float v133;
  float v134;
  float32x2_t v135;
  float32x2_t v136;
  float v137;
  float v138;
  float32x2_t v139;
  float v140;
  int8x16_t *v141;
  uint64_t v142;
  unint64_t v143;
  uint64_t v144;
  int8x16_t *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  float v155;
  int8x16_t v156;
  float v157;
  int8x16_t *v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  int8x16_t *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  int v171;
  float v172;
  float v173;
  float v174;
  int8x16_t v175;
  float v176;
  float v177;
  float v178;
  unsigned int v179;
  float32x2_t v180;
  int8x16_t *v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  int8x16_t *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int v190;
  unsigned int v191;
  int8x16_t v192;
  float v193;
  float v194;
  double v195;
  double v196;
  double v197;
  __int32 v198;
  int8x16_t *v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t v202;
  int8x16_t *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  int v208;
  unsigned int v209;
  int8x16_t v210;
  float v211;
  float v212;
  double v213;
  double v214;
  double v215;
  __int32 v216;
  int8x16_t *v217;
  uint64_t v218;
  unint64_t v219;
  uint64_t v220;
  int8x16_t *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  int v226;
  unsigned int v227;
  int8x16_t v228;
  float v229;
  float v230;
  double v231;
  __int32 v232;
  unsigned int v233;
  int8x16_t *v234;
  uint64_t v235;
  unint64_t v236;
  uint64_t v237;
  int8x16_t *v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  int v243;
  unsigned int v244;
  int8x16_t v245;
  float v246;
  float v247;
  double v248;
  __int32 v249;
  unsigned int v250;
  int8x16_t *v251;
  uint64_t v252;
  unint64_t v253;
  uint64_t v254;
  int8x16_t *v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  int v260;
  unsigned int v261;
  int8x16_t v262;
  float v263;
  float v264;
  double v265;
  __int32 v266;
  unsigned int v267;
  int8x16_t *v268;
  uint64_t v269;
  unint64_t v270;
  uint64_t v271;
  int8x16_t *v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  int v276;
  float32x4_t v277;
  float32x4_t v278;
  int8x16_t *v279;
  uint64_t v280;
  unint64_t v281;
  uint64_t v282;
  int8x16_t *v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  int v287;
  unsigned int v288;
  float v289;
  float v290;
  float v291;
  float v292;
  unsigned int v293;
  unsigned int v294;
  int8x8_t v295;
  float v296;
  float v297;
  int8x16_t *v298;
  uint64_t v299;
  unint64_t v300;
  uint64_t v301;
  int8x16_t *v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  int v306;
  unsigned int v307;
  float32x4_t v308;
  float v309;
  int8x16_t *v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t v313;
  int8x16_t *v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  int v318;
  float32x4_t v319;
  float32x4_t v320;
  int8x16_t *v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  int8x16_t *v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  int v330;
  unsigned int v331;
  int8x16_t v332;
  float v333;
  float v334;
  double v335;
  double v336;
  double v337;
  __int32 v338;
  int8x16_t *v339;
  uint64_t v340;
  unint64_t v341;
  uint64_t v342;
  int8x16_t *v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  int v348;
  unsigned int v349;
  int8x16_t v350;
  float v351;
  float v352;
  double v353;
  double v354;
  double v355;
  __int32 v356;
  int8x16_t *v357;
  uint64_t v358;
  unint64_t v359;
  uint64_t v360;
  int8x16_t *v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  int v366;
  unsigned int v367;
  int8x16_t v368;
  float v369;
  float v370;
  double v371;
  double v372;
  double v373;
  __int32 v374;
  int8x16_t *v375;
  uint64_t v376;
  unint64_t v377;
  uint64_t v378;
  int8x16_t *v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  int v384;
  unsigned int v385;
  int8x16_t v386;
  float v387;
  float v388;
  double v389;
  double v390;
  double v391;
  __int32 v392;
  int8x16_t *v393;
  uint64_t v394;
  unint64_t v395;
  uint64_t v396;
  int8x16_t *v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  int v402;
  unsigned int v403;
  int8x16_t v404;
  float v405;
  double v406;
  __int32 v407;
  int8x16_t *v408;
  uint64_t v409;
  unint64_t v410;
  uint64_t v411;
  int8x16_t *v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  int v417;
  unsigned int v418;
  int8x16_t v419;
  float v420;
  float v421;
  double v422;
  double v423;
  double v424;
  __int32 v425;
  int8x16_t *v426;
  uint64_t v427;
  unint64_t v428;
  uint64_t v429;
  int8x16_t *v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  int v434;
  float v435;
  float32x4_t v436;
  float v437;
  int8x16_t v438;
  float v439;
  float32x2_t v440;
  float32x2_t v441;
  float32x2_t v442;
  float32x2_t v443;
  float32x2_t v444;
  float32x2_t v445;
  float v446;
  int8x16_t *v447;
  uint64_t v448;
  unint64_t v449;
  uint64_t v450;
  int8x16_t *v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  int v455;
  float v456;
  float v457;
  float v458;
  int8x16_t v459;
  float v460;
  float v461;
  float v462;
  unsigned int v463;
  float32x2_t v464;
  int8x16_t *v465;
  uint64_t v466;
  unint64_t v467;
  uint64_t v468;
  int8x16_t *v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  int v474;
  unsigned int v475;
  int8x16_t v476;
  float v477;
  __int32 v478;
  unsigned int v479;
  int8x16_t *v480;
  uint64_t v481;
  unint64_t v482;
  uint64_t v483;
  int8x16_t *v484;
  uint64_t v485;
  int v486;
  unsigned int v487;
  __int32 v488;
  float v489;
  float32x4_t v490;
  int8x16_t *v491;
  uint64_t v492;
  unint64_t v493;
  uint64_t v494;
  int8x16_t *v495;
  uint64_t v496;
  double v497;
  double v498;
  double v499;
  double v500;
  __int128 v501;
  float v502;
  float v503;
  float v504;
  float v505;
  float v506;
  float v507;
  float v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  unint64_t v521;
  int v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  int v539;
  int v540;
  int v541;
  int v542;
  int v543;
  int v544;
  int v545;
  int v546;
  int v547;
  int v548;
  int v549;
  int v550;

  v10 = *(_QWORD *)(a1 + 136);
  if (!v10)
    return;
  v11 = *(unsigned int *)(a1 + 4);
  v12 = *(unsigned int *)(a1 + 8);
  v13 = (int)v11;
  v14 = *(_QWORD *)(a1 + 88);
  v15 = *(_QWORD *)(a1 + 96);
  v16 = (unint64_t)*(int *)(a1 + 28) >> 4;
  v17 = (int8x16_t *)(*(_QWORD *)(a1 + 40) + 16 * (*(int *)(a1 + 12) + v16 * *(int *)(a1 + 16)));
  v18 = *(int *)(a1 + 124);
  v19 = (_BYTE *)(v10 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v18);
  v20 = *(int *)(a1 + 56);
  v21 = *(int *)(a1 + 60);
  v22 = *(int *)(a1 + 76);
  if (*(unsigned __int8 *)(a1 + 1) << 8 == 256)
  {
    v23 = v22 >> 4;
    v24 = (int8x16_t *)(v14 + 16 * (v20 + (v22 >> 4) * v21));
    if (v22 >> 4 != v16)
    {
      v26 = 1;
LABEL_14:
      v27 = 0;
      v13 = v26 * (int)v11;
      v29 = v15 != 0;
      v30 = v18 - v13;
      v31 = v16 - v13;
      v37 = -1;
      v28 = v23;
      goto LABEL_15;
    }
    if ((char *)v17 - (char *)v24 >= 1)
    {
      if ((int)v11 >= (uint64_t)((unint64_t)((char *)v17 - (char *)v24) >> 4))
      {
        v17 += (int)v11 - 1;
        v24 += (int)v11 - 1;
        v19 += (int)v11 - 1;
        v26 = -1;
        goto LABEL_13;
      }
      v25 = (int)v12 - 1;
      if (v17 <= &v24[v16 * v25 - 1 + (int)v11])
      {
        v17 += v16 * v25;
        v23 = -(uint64_t)v16;
        v19 += v18 * v25;
        v18 = -v18;
        v26 = 1;
        v24 += v16 * v25;
        v16 = -(uint64_t)v16;
        goto LABEL_14;
      }
    }
    v26 = 1;
LABEL_13:
    v23 = (unint64_t)*(int *)(a1 + 28) >> 4;
    goto LABEL_14;
  }
  v28 = *(_DWORD *)(a1 + 64);
  v27 = *(_DWORD *)(a1 + 68);
  v23 = v22 >> 4;
  v29 = v15 != 0;
  v30 = v18 - (int)v11;
  v31 = v16 - (int)v11;
  if (v14)
  {
    v32 = 0;
    v33 = (int)v21 % v27;
    v34 = v14 + 16 * v23 * v27;
    v35 = v14 + 16 * v23 * v33;
    v36 = v35 + 16 * ((int)v20 % v28);
    v37 = v35 + 16 * v28;
    v26 = 1;
    v24 = (int8x16_t *)v36;
    goto LABEL_16;
  }
  v24 = 0;
  v37 = 0;
  v26 = 1;
LABEL_15:
  v34 = 0;
  v36 = 0;
  v23 -= v13;
  v32 = 1;
LABEL_16:
  v38 = *(_QWORD *)(a1 + 48);
  v525 = v30;
  v526 = *(unsigned int *)(a1 + 4);
  v523 = v31;
  v524 = v23;
  v522 = v32;
  v521 = v34;
  switch((int)a2)
  {
    case 0:
      v39 = v26;
      v40 = 16 * v26;
      do
      {
        v41 = v11;
        do
        {
          v42 = *v19;
          if (*v19)
          {
            if (v42 == 255)
            {
              v17->i64[0] = 0;
              v17->i64[1] = 0;
            }
            else
            {
              *v17 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v17), (float)((float)v42 * -0.0039216) + 1.0));
            }
          }
          v19 += v39;
          v17 = (int8x16_t *)((char *)v17 + v40);
          --v41;
        }
        while (v41);
        v19 += v30;
        v17 += v31;
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 1:
      if (v38)
        v43 = v29;
      else
        v43 = 1;
      v44 = -(uint64_t)v28;
      v45 = -(v23 * v27);
      v46 = 16 * v26;
      if ((v43 & 1) != 0)
      {
        do
        {
          v47 = v11;
          do
          {
            v48 = *v19;
            if (*v19)
            {
              if (v48 == 255)
                v49 = *v24;
              else
                v49 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32((float32x4_t)vrev32q_s8(*v17), 1.0 - (float)((float)v48 * 0.0039216)), (float32x4_t)vrev32q_s8(*v24), (float)v48 * 0.0039216));
              *v17 = v49;
            }
            v19 += v26;
            v50 = &v24[v26];
            if ((unint64_t)v50 >= v37)
              v51 = v44;
            else
              v51 = 0;
            v24 = &v50[v51];
            v17 = (int8x16_t *)((char *)v17 + v46);
            --v47;
          }
          while (v47);
          v19 += v30;
          v17 += v31;
          v52 = v36 + 16 * v23;
          if (v52 >= v34)
            v53 = v45;
          else
            v53 = 0;
          v54 = (int8x16_t *)(v52 + 16 * v53);
          v55 = v37 + 16 * v53 + 16 * v23;
          if ((_DWORD)v32)
          {
            v24 += v23;
          }
          else
          {
            v37 = v55;
            v36 = (uint64_t)v54;
            v24 = v54;
          }
          LODWORD(v12) = v12 - 1;
        }
        while ((_DWORD)v12);
      }
      else
      {
        do
        {
          v486 = v11;
          do
          {
            v487 = *v19;
            if (*v19)
            {
              if (v487 == 255)
              {
                v488 = v24->i32[2];
                v17->i64[0] = v24->i64[0];
                v17->i32[2] = v488;
                v17->i32[3] = 32831;
              }
              else
              {
                v489 = (float)v487 * 0.0039216;
                *(float32x2_t *)v490.f32 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v489);
                v490.f32[2] = v489 * COERCE_FLOAT(bswap32(v24->u32[2]));
                v490.f32[3] = v489;
                *v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v490, (float32x4_t)vrev32q_s8(*v17), 1.0 - v489));
              }
            }
            v19 += v26;
            v491 = &v24[v26];
            if ((unint64_t)v491 >= v37)
              v492 = v44;
            else
              v492 = 0;
            v24 = &v491[v492];
            v17 = (int8x16_t *)((char *)v17 + v46);
            --v486;
          }
          while (v486);
          v19 += v30;
          v17 += v31;
          v493 = v36 + 16 * v23;
          if (v493 >= v34)
            v494 = v45;
          else
            v494 = 0;
          v495 = (int8x16_t *)(v493 + 16 * v494);
          v496 = v37 + 16 * v494 + 16 * v23;
          if ((_DWORD)v32)
          {
            v24 += v23;
          }
          else
          {
            v37 = v496;
            v36 = (uint64_t)v495;
            v24 = v495;
          }
          LODWORD(v12) = v12 - 1;
        }
        while ((_DWORD)v12);
      }
      return;
    case 2:
      v56 = -(uint64_t)v28;
      v57 = -(v23 * v27);
      while (1)
      {
        v58 = v11;
        do
        {
          v59 = *v19;
          if (!*v19)
            goto LABEL_60;
          if (v59 != 255)
          {
            v65 = (float)v59 * 0.0039216;
            v62 = v65 * COERCE_FLOAT(bswap32(v24->u32[3]));
            if (v62 <= 0.0)
              goto LABEL_60;
            v64 = v65 * COERCE_FLOAT(bswap32(v24->u32[2]));
            *(float32x2_t *)v63.f32 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v65);
            goto LABEL_58;
          }
          v60 = v24->u32[3];
          v61 = COERCE_FLOAT(bswap32(v60));
          v62 = v61;
          if (v61 < 1.0)
          {
            if (v61 <= 0.0)
              goto LABEL_60;
            *(int8x8_t *)v63.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
            LODWORD(v64) = bswap32(v24->u32[2]);
LABEL_58:
            v63.i64[1] = __PAIR64__(LODWORD(v62), LODWORD(v64));
            *v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v63, (float32x4_t)vrev32q_s8(*v17), 1.0 - v62));
            goto LABEL_60;
          }
          v17->i64[0] = v24->i64[0];
          v17->i32[2] = v24->i32[2];
          v17->i32[3] = v60;
LABEL_60:
          v19 += v26;
          v66 = &v24[v26];
          if ((unint64_t)v66 >= v37)
            v67 = v56;
          else
            v67 = 0;
          v24 = &v66[v67];
          v17 += v26;
          --v58;
        }
        while (v58);
        v19 += v30;
        v17 += v31;
        v68 = v36 + 16 * v23;
        if (v68 >= v34)
          v69 = v57;
        else
          v69 = 0;
        v70 = (int8x16_t *)(v68 + 16 * v69);
        v71 = v37 + 16 * v69 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v71;
          v36 = (uint64_t)v70;
          v24 = v70;
        }
        LODWORD(v12) = v12 - 1;
        if (!(_DWORD)v12)
          return;
      }
    case 3:
      v72 = -(uint64_t)v28;
      v73 = -(v23 * v27);
      do
      {
        v74 = v11;
        do
        {
          v75 = *v19;
          if (*v19)
          {
            if (v75 == 255)
            {
              v76 = 1.0;
              if (v29)
                v76 = bswap32(v24->u32[3]);
              *(int8x8_t *)v77.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v77.i64[1] = __PAIR64__(v76, bswap32(v24->u32[2]));
              v78 = (int8x16_t)vmulq_n_f32(v77, COERCE_FLOAT(bswap32(v17->u32[3])));
            }
            else
            {
              v79 = 1.0;
              if (v29)
                v79 = bswap32(v24->u32[3]);
              v80 = (float32x4_t)vrev32q_s8(*v17);
              *(int8x8_t *)v81.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v81.i64[1] = __PAIR64__(v79, bswap32(v24->u32[2]));
              v78 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v81, vmuls_lane_f32((float)v75 * 0.0039216, v80, 3)), v80, 1.0 - (float)((float)v75 * 0.0039216));
            }
            *v17 = vrev32q_s8(v78);
          }
          v19 += v26;
          v82 = &v24[v26];
          if ((unint64_t)v82 >= v37)
            v83 = v72;
          else
            v83 = 0;
          v24 = &v82[v83];
          v17 += v26;
          --v74;
        }
        while (v74);
        v19 += v30;
        v17 += v31;
        v84 = v36 + 16 * v23;
        if (v84 >= v34)
          v85 = v73;
        else
          v85 = 0;
        v86 = (int8x16_t *)(v84 + 16 * v85);
        v87 = v37 + 16 * v85 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v87;
          v36 = (uint64_t)v86;
          v24 = v86;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 4:
      v88 = -(uint64_t)v28;
      v89 = -(v23 * v27);
      do
      {
        v90 = v11;
        do
        {
          v91 = *v19;
          if (*v19)
          {
            if (v91 == 255)
            {
              v92 = 1.0;
              if (v29)
                v92 = bswap32(v24->u32[3]);
              *(int8x8_t *)v93.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v93.i64[1] = __PAIR64__(v92, bswap32(v24->u32[2]));
              v94 = (int8x16_t)vmulq_n_f32(v93, 1.0 - COERCE_FLOAT(bswap32(v17->u32[3])));
            }
            else
            {
              v95 = 1.0;
              if (v29)
                v95 = bswap32(v24->u32[3]);
              v96 = (float32x4_t)vrev32q_s8(*v17);
              *(int8x8_t *)v97.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v97.i64[1] = __PAIR64__(v95, bswap32(v24->u32[2]));
              v94 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v97, (float)((float)v91 * 0.0039216) * (float)(1.0 - v96.f32[3])), v96, 1.0 - (float)((float)v91 * 0.0039216));
            }
            *v17 = vrev32q_s8(v94);
          }
          v19 += v26;
          v98 = &v24[v26];
          if ((unint64_t)v98 >= v37)
            v99 = v88;
          else
            v99 = 0;
          v24 = &v98[v99];
          v17 += v26;
          --v90;
        }
        while (v90);
        v19 += v30;
        v17 += v31;
        v100 = v36 + 16 * v23;
        if (v100 >= v34)
          v101 = v89;
        else
          v101 = 0;
        v102 = (int8x16_t *)(v100 + 16 * v101);
        v103 = v37 + 16 * v101 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v103;
          v36 = (uint64_t)v102;
          v24 = v102;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 5:
      v274 = -(uint64_t)v28;
      v275 = -(v23 * v27);
      do
      {
        v276 = v11;
        do
        {
          if (*v19)
          {
            v277 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)*v19 * 0.0039216);
            v278 = (float32x4_t)vrev32q_s8(*v17);
            *v17 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v278, 1.0 - v277.f32[3]), v277, v278, 3));
          }
          v19 += v26;
          v279 = &v24[v26];
          if ((unint64_t)v279 >= v37)
            v280 = v274;
          else
            v280 = 0;
          v24 = &v279[v280];
          v17 += v26;
          --v276;
        }
        while (v276);
        v19 += v30;
        v17 += v31;
        v281 = v36 + 16 * v23;
        if (v281 >= v34)
          v282 = v275;
        else
          v282 = 0;
        v283 = (int8x16_t *)(v281 + 16 * v282);
        v284 = v37 + 16 * v282 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v284;
          v36 = (uint64_t)v283;
          v24 = v283;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 6:
      v285 = -(uint64_t)v28;
      v286 = -(v23 * v27);
      while (1)
      {
        v287 = v11;
        do
        {
          v288 = *v19;
          if (!*v19)
            goto LABEL_368;
          v289 = COERCE_FLOAT(bswap32(v17->u32[3]));
          v290 = 1.0 - v289;
          if ((float)(1.0 - v289) >= 1.0)
          {
            v296 = 1.0;
            if (v29)
              v296 = COERCE_FLOAT(bswap32(v24->u32[3]));
            v297 = (float)v288 * 0.0039216;
            v293 = bswap32(COERCE_UNSIGNED_INT(v297 * COERCE_FLOAT(bswap32(v24->u32[2]))));
            v294 = bswap32(COERCE_UNSIGNED_INT(v297 * v296));
            v295 = vrev32_s8((int8x8_t)vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v297));
          }
          else
          {
            if (v290 <= 0.0)
              goto LABEL_368;
            v291 = 1.0;
            if (v29)
              v291 = COERCE_FLOAT(bswap32(v24->u32[3]));
            v292 = (float)((float)v288 * 0.0039216) * v290;
            v293 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v17->u32[2])) + (float)(COERCE_FLOAT(bswap32(v24->u32[2]))
                                                                                          * v292)));
            v294 = bswap32(COERCE_UNSIGNED_INT(v289 + (float)(v291 * v292)));
            v295 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8), (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v292));
          }
          *(int8x8_t *)v17->i8 = v295;
          v17->i32[2] = v293;
          v17->i32[3] = v294;
LABEL_368:
          v19 += v26;
          v298 = &v24[v26];
          if ((unint64_t)v298 >= v37)
            v299 = v285;
          else
            v299 = 0;
          v24 = &v298[v299];
          v17 += v26;
          --v287;
        }
        while (v287);
        v19 += v30;
        v17 += v31;
        v300 = v36 + 16 * v23;
        if (v300 >= v34)
          v301 = v286;
        else
          v301 = 0;
        v302 = (int8x16_t *)(v300 + 16 * v301);
        v303 = v37 + 16 * v301 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v303;
          v36 = (uint64_t)v302;
          v24 = v302;
        }
        LODWORD(v12) = v12 - 1;
        if (!(_DWORD)v12)
          return;
      }
    case 7:
      v104 = -(uint64_t)v28;
      v105 = -(v23 * v27);
      do
      {
        v106 = v11;
        do
        {
          v107 = *v19;
          if (*v19)
          {
            if (v107 == 255)
            {
              v108 = (int8x16_t)vmulq_f32((float32x4_t)vdupq_n_s32(bswap32(v24->u32[3])), (float32x4_t)vrev32q_s8(*v17));
            }
            else
            {
              v109 = (float32x4_t)vrev32q_s8(*v17);
              v108 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v109, 1.0 - (float)((float)v107 * 0.0039216)), v109, (float)((float)v107 * 0.0039216) * COERCE_FLOAT(bswap32(v24->u32[3])));
            }
            *v17 = vrev32q_s8(v108);
          }
          v19 += v26;
          v110 = &v24[v26];
          if ((unint64_t)v110 >= v37)
            v111 = v104;
          else
            v111 = 0;
          v24 = &v110[v111];
          v17 += v26;
          --v106;
        }
        while (v106);
        v19 += v30;
        v17 += v31;
        v112 = v36 + 16 * v23;
        if (v112 >= v34)
          v113 = v105;
        else
          v113 = 0;
        v114 = (int8x16_t *)(v112 + 16 * v113);
        v115 = v37 + 16 * v113 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v115;
          v36 = (uint64_t)v114;
          v24 = v114;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 8:
      v304 = -(uint64_t)v28;
      v305 = -(v23 * v27);
      do
      {
        v306 = v11;
        do
        {
          v307 = *v19;
          if (*v19)
          {
            v308 = (float32x4_t)vrev32q_s8(*v17);
            if (v307 == 255)
              v309 = COERCE_FLOAT(bswap32(v24->u32[3]));
            else
              v309 = (float)((float)v307 * 0.0039216) * COERCE_FLOAT(bswap32(v24->u32[3]));
            *v17 = vrev32q_s8((int8x16_t)vmulq_n_f32(v308, 1.0 - v309));
          }
          v19 += v26;
          v310 = &v24[v26];
          if ((unint64_t)v310 >= v37)
            v311 = v304;
          else
            v311 = 0;
          v24 = &v310[v311];
          v17 += v26;
          --v306;
        }
        while (v306);
        v19 += v30;
        v17 += v31;
        v312 = v36 + 16 * v23;
        if (v312 >= v34)
          v313 = v305;
        else
          v313 = 0;
        v314 = (int8x16_t *)(v312 + 16 * v313);
        v315 = v37 + 16 * v313 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v315;
          v36 = (uint64_t)v314;
          v24 = v314;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 9:
      v116 = -(uint64_t)v28;
      v117 = -(v23 * v27);
      do
      {
        v118 = v11;
        do
        {
          if (*v19)
          {
            v119 = (float)*v19 * 0.0039216;
            v120 = 1.0 - v119;
            v121 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), v119);
            v122 = (float32x4_t)vrev32q_s8(*v17);
            *v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v122, v120 + v121.f32[3]), v121, 1.0 - v122.f32[3]));
          }
          v19 += v26;
          v123 = &v24[v26];
          if ((unint64_t)v123 >= v37)
            v124 = v116;
          else
            v124 = 0;
          v24 = &v123[v124];
          v17 += v26;
          --v118;
        }
        while (v118);
        v19 += v30;
        v17 += v31;
        v125 = v36 + 16 * v23;
        if (v125 >= v34)
          v126 = v117;
        else
          v126 = 0;
        v127 = (int8x16_t *)(v125 + 16 * v126);
        v128 = v37 + 16 * v126 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v128;
          v36 = (uint64_t)v127;
          v24 = v127;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 10:
      v316 = -(uint64_t)v28;
      v317 = -(v23 * v27);
      do
      {
        v318 = v11;
        do
        {
          if (*v19)
          {
            v319 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)*v19 * 0.0039216);
            v320 = (float32x4_t)vrev32q_s8(*v17);
            *v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v320, 1.0 - v319.f32[3]), v319, 1.0 - v320.f32[3]));
          }
          v19 += v26;
          v321 = &v24[v26];
          if ((unint64_t)v321 >= v37)
            v322 = v316;
          else
            v322 = 0;
          v24 = &v321[v322];
          v17 += v26;
          --v318;
        }
        while (v318);
        v19 += v30;
        v17 += v31;
        v323 = v36 + 16 * v23;
        if (v323 >= v34)
          v324 = v317;
        else
          v324 = 0;
        v325 = (int8x16_t *)(v323 + 16 * v324);
        v326 = v37 + 16 * v324 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v326;
          v36 = (uint64_t)v325;
          v24 = v325;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 11:
      v129 = -(uint64_t)v28;
      v130 = -(v23 * v27);
      do
      {
        v131 = v11;
        do
        {
          if (*v19)
          {
            if (v38)
              a5.i32[0] = bswap32(v17->u32[3]);
            else
              a5.i32[0] = 1.0;
            v132 = (float)*v19 * 0.0039216;
            v133 = COERCE_FLOAT(bswap32(v24->u32[3]));
            v134 = v132 * COERCE_FLOAT(bswap32(v24->u32[2]));
            v135 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v132);
            v136 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
            v137 = COERCE_FLOAT(bswap32(v17->u32[2]));
            if (!v29)
              v133 = 1.0;
            *(float *)a6.i32 = v132 * v133;
            v138 = *(float *)a6.i32 + *(float *)a5.i32;
            v139 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)a5.i8, 0), v136);
            v140 = (float)(*(float *)a6.i32 - v134) + (float)(*(float *)a5.i32 - v137);
            if (v138 <= 1.0)
              *(float *)&a7 = v138;
            else
              *(float *)&a7 = 1.0;
            *(float32x2_t *)a6.i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0), vadd_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)a6.i8, 0), v135), v139));
            *(float *)&a6.i32[2] = *(float *)&a7 - v140;
            a6.i32[3] = LODWORD(a7);
            a5 = vrev32q_s8(a6);
            *v17 = a5;
          }
          v19 += v26;
          v141 = &v24[v26];
          if ((unint64_t)v141 >= v37)
            v142 = v129;
          else
            v142 = 0;
          v24 = &v141[v142];
          v17 += v26;
          --v131;
        }
        while (v131);
        v19 += v30;
        v17 += v31;
        v143 = v36 + 16 * v23;
        if (v143 >= v34)
          v144 = v130;
        else
          v144 = 0;
        v145 = (int8x16_t *)(v143 + 16 * v144);
        v146 = v37 + 16 * v144 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v146;
          v36 = (uint64_t)v145;
          v24 = v145;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 12:
      v147 = -(uint64_t)v28;
      v148 = -(v23 * v27);
      do
      {
        v149 = v11;
        do
        {
          if (*v19)
          {
            v150 = (float)*v19 * 0.0039216;
            v151 = COERCE_FLOAT(bswap32(v24->u32[3]));
            v152 = v150 * COERCE_FLOAT(bswap32(v24->u32[2]));
            v153 = COERCE_FLOAT(bswap32(v17->u32[2]));
            v154 = COERCE_FLOAT(bswap32(v17->u32[3]));
            if (!v29)
              v151 = 1.0;
            v155 = (float)(v150 * v151) + v154;
            *(float32x2_t *)v156.i8 = vadd_f32(vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v150), (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8));
            v157 = v152 + v153;
            if (v155 > 1.0)
              v155 = 1.0;
            v156.i64[1] = __PAIR64__(LODWORD(v155), LODWORD(v157));
            *v17 = vrev32q_s8(v156);
          }
          v19 += v26;
          v158 = &v24[v26];
          if ((unint64_t)v158 >= v37)
            v159 = v147;
          else
            v159 = 0;
          v24 = &v158[v159];
          v17 += v26;
          --v149;
        }
        while (v149);
        v19 += v30;
        v17 += v31;
        v160 = v36 + 16 * v23;
        if (v160 >= v34)
          v161 = v148;
        else
          v161 = 0;
        v162 = (int8x16_t *)(v160 + 16 * v161);
        v163 = v37 + 16 * v161 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v163;
          v36 = (uint64_t)v162;
          v24 = v162;
        }
        LODWORD(v12) = v12 - 1;
      }
      while ((_DWORD)v12);
      return;
    case 13:
      v327 = v26;
      v328 = -(uint64_t)v28;
      v514 = -(v23 * v27);
      v329 = 16 * v26;
      while (1)
      {
        v532 = v36;
        v544 = v12;
        v330 = v11;
        do
        {
          v331 = *v19;
          if (*v19)
          {
            v332 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v331 * 0.0039216);
            LODWORD(a10) = v332.i32[3];
            v333 = v29 ? *(float *)&v332.i32[3] : (float)v331 * 0.0039216;
            if (v333 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v334 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v332.i32[3] = v333;
LABEL_427:
                  *v17 = vrev32q_s8(v332);
                  goto LABEL_428;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v334 = 1.0;
              }
              v335 = *(double *)v17->i64;
              v336 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v335) = HIDWORD(v336);
              v504 = v333;
              *(_QWORD *)&v337 = vextq_s8(v332, v332, 4uLL).u64[0];
              *(float *)v332.i32 = PDAmultiplyPDA(*(float *)&v336, v335, *(double *)a5.i64, *(double *)a6.i64, v334, v336, v337, a10, *(float *)v332.i32, COERCE_DOUBLE(__PAIR64__(v332.u32[3], HIDWORD(v337))), v504);
              v332.i32[1] = v338;
              v332.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_427;
            }
          }
LABEL_428:
          v19 += v327;
          v339 = &v24[v327];
          if ((unint64_t)v339 >= v37)
            v340 = v328;
          else
            v340 = 0;
          v24 = &v339[v340];
          v17 = (int8x16_t *)((char *)v17 + v329);
          --v330;
        }
        while (v330);
        v19 += v525;
        v17 += v523;
        v36 = v532;
        v341 = v532 + 16 * v524;
        v342 = v514;
        if (v341 < v521)
          v342 = 0;
        v343 = (int8x16_t *)(v341 + 16 * v342);
        v344 = v37 + 16 * v342 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v344;
          v36 = (uint64_t)v343;
          v24 = v343;
        }
        LODWORD(v12) = v544 - 1;
        LODWORD(v11) = v526;
        if (v544 == 1)
          return;
      }
    case 14:
      v164 = -(uint64_t)v28;
      v165 = -(v23 * v27);
      __asm { FMOV            V2.2S, #1.0 }
      while (1)
      {
        v171 = v11;
        do
        {
          if (*v19)
          {
            v172 = (float)*v19 * 0.0039216;
            v173 = COERCE_FLOAT(bswap32(v24->u32[3]));
            if (!v29)
              v173 = 1.0;
            v174 = v172 * v173;
            if (v174 > 0.0)
            {
              *(float32x2_t *)v175.i8 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v172);
              v176 = v172 * COERCE_FLOAT(bswap32(v24->u32[2]));
              if (v38)
              {
                v177 = COERCE_FLOAT(bswap32(v17->u32[3]));
                if (v177 <= 0.0)
                {
                  v175.i64[1] = __PAIR64__(LODWORD(v174), LODWORD(v176));
                  *v17 = vrev32q_s8(v175);
                  goto LABEL_208;
                }
              }
              else
              {
                v177 = 1.0;
              }
              v178 = COERCE_FLOAT(bswap32(v17->u32[2]));
              *(float *)&v179 = (float)(v174 + v177) - (float)(v177 * v174);
              v180 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
              *(int8x8_t *)v17->i8 = vrev32_s8((int8x8_t)vmla_f32(v180, vsub_f32(_D2, v180), *(float32x2_t *)v175.i8));
              v17->i32[2] = bswap32(COERCE_UNSIGNED_INT(v178 + (float)(v176 * (float)(1.0 - v178))));
              v17->i32[3] = bswap32(v179);
            }
          }
LABEL_208:
          v19 += v26;
          v181 = &v24[v26];
          if ((unint64_t)v181 >= v37)
            v182 = v164;
          else
            v182 = 0;
          v24 = &v181[v182];
          v17 += v26;
          --v171;
        }
        while (v171);
        v19 += v30;
        v17 += v31;
        v183 = v36 + 16 * v23;
        if (v183 >= v34)
          v184 = v165;
        else
          v184 = 0;
        v185 = (int8x16_t *)(v183 + 16 * v184);
        v186 = v37 + 16 * v184 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v186;
          v36 = (uint64_t)v185;
          v24 = v185;
        }
        LODWORD(v12) = v12 - 1;
        if (!(_DWORD)v12)
          return;
      }
    case 15:
      v187 = v26;
      v188 = -(uint64_t)v28;
      v509 = -(v23 * v27);
      v189 = 16 * v26;
      while (1)
      {
        v527 = v36;
        v539 = v12;
        v190 = v11;
        do
        {
          v191 = *v19;
          if (*v19)
          {
            v192 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v191 * 0.0039216);
            LODWORD(a10) = v192.i32[3];
            v193 = v29 ? *(float *)&v192.i32[3] : (float)v191 * 0.0039216;
            if (v193 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v194 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v192.i32[3] = v193;
LABEL_232:
                  *v17 = vrev32q_s8(v192);
                  goto LABEL_233;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v194 = 1.0;
              }
              v195 = *(double *)v17->i64;
              v196 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v195) = HIDWORD(v196);
              v502 = v193;
              *(_QWORD *)&v197 = vextq_s8(v192, v192, 4uLL).u64[0];
              *(float *)v192.i32 = PDAoverlayPDA(*(float *)&v196, v195, *(double *)a5.i64, *(double *)a6.i64, v194, v196, v197, a10, *(float *)v192.i32, COERCE_DOUBLE(__PAIR64__(v192.u32[3], HIDWORD(v197))), v502);
              v192.i32[1] = v198;
              v192.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_232;
            }
          }
LABEL_233:
          v19 += v187;
          v199 = &v24[v187];
          if ((unint64_t)v199 >= v37)
            v200 = v188;
          else
            v200 = 0;
          v24 = &v199[v200];
          v17 = (int8x16_t *)((char *)v17 + v189);
          --v190;
        }
        while (v190);
        v19 += v525;
        v17 += v523;
        v36 = v527;
        v201 = v527 + 16 * v524;
        v202 = v509;
        if (v201 < v521)
          v202 = 0;
        v203 = (int8x16_t *)(v201 + 16 * v202);
        v204 = v37 + 16 * v202 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v204;
          v36 = (uint64_t)v203;
          v24 = v203;
        }
        LODWORD(v12) = v539 - 1;
        LODWORD(v11) = v526;
        if (v539 == 1)
          return;
      }
    case 16:
      v205 = v26;
      v206 = -(uint64_t)v28;
      v510 = -(v23 * v27);
      v207 = 16 * v26;
      while (1)
      {
        v528 = v36;
        v540 = v12;
        v208 = v11;
        do
        {
          v209 = *v19;
          if (*v19)
          {
            v210 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v209 * 0.0039216);
            LODWORD(a10) = v210.i32[3];
            v211 = v29 ? *(float *)&v210.i32[3] : (float)v209 * 0.0039216;
            if (v211 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v212 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v210.i32[3] = v211;
LABEL_256:
                  *v17 = vrev32q_s8(v210);
                  goto LABEL_257;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v212 = 1.0;
              }
              v213 = *(double *)v17->i64;
              v214 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v213) = HIDWORD(v214);
              v503 = v211;
              *(_QWORD *)&v215 = vextq_s8(v210, v210, 4uLL).u64[0];
              *(float *)v210.i32 = PDAdarkenPDA(*(float *)&v214, v213, *(double *)a5.i64, *(double *)a6.i64, v212, v214, v215, a10, *(float *)v210.i32, COERCE_DOUBLE(__PAIR64__(v210.u32[3], HIDWORD(v215))), v503);
              v210.i32[1] = v216;
              v210.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_256;
            }
          }
LABEL_257:
          v19 += v205;
          v217 = &v24[v205];
          if ((unint64_t)v217 >= v37)
            v218 = v206;
          else
            v218 = 0;
          v24 = &v217[v218];
          v17 = (int8x16_t *)((char *)v17 + v207);
          --v208;
        }
        while (v208);
        v19 += v525;
        v17 += v523;
        v36 = v528;
        v219 = v528 + 16 * v524;
        v220 = v510;
        if (v219 < v521)
          v220 = 0;
        v221 = (int8x16_t *)(v219 + 16 * v220);
        v222 = v37 + 16 * v220 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v222;
          v36 = (uint64_t)v221;
          v24 = v221;
        }
        LODWORD(v12) = v540 - 1;
        LODWORD(v11) = v526;
        if (v540 == 1)
          return;
      }
    case 17:
      v345 = v26;
      v346 = -(uint64_t)v28;
      v515 = -(v23 * v27);
      v347 = 16 * v26;
      while (1)
      {
        v533 = v36;
        v545 = v12;
        v348 = v11;
        do
        {
          v349 = *v19;
          if (*v19)
          {
            v350 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v349 * 0.0039216);
            LODWORD(a10) = v350.i32[3];
            v351 = v29 ? *(float *)&v350.i32[3] : (float)v349 * 0.0039216;
            if (v351 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v352 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v350.i32[3] = v351;
LABEL_451:
                  *v17 = vrev32q_s8(v350);
                  goto LABEL_452;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v352 = 1.0;
              }
              v353 = *(double *)v17->i64;
              v354 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v353) = HIDWORD(v354);
              v505 = v351;
              *(_QWORD *)&v355 = vextq_s8(v350, v350, 4uLL).u64[0];
              *(float *)v350.i32 = PDAlightenPDA(*(float *)&v354, v353, *(double *)a5.i64, *(double *)a6.i64, v352, v354, v355, a10, *(float *)v350.i32, COERCE_DOUBLE(__PAIR64__(v350.u32[3], HIDWORD(v355))), v505);
              v350.i32[1] = v356;
              v350.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_451;
            }
          }
LABEL_452:
          v19 += v345;
          v357 = &v24[v345];
          if ((unint64_t)v357 >= v37)
            v358 = v346;
          else
            v358 = 0;
          v24 = &v357[v358];
          v17 = (int8x16_t *)((char *)v17 + v347);
          --v348;
        }
        while (v348);
        v19 += v525;
        v17 += v523;
        v36 = v533;
        v359 = v533 + 16 * v524;
        v360 = v515;
        if (v359 < v521)
          v360 = 0;
        v361 = (int8x16_t *)(v359 + 16 * v360);
        v362 = v37 + 16 * v360 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v362;
          v36 = (uint64_t)v361;
          v24 = v361;
        }
        LODWORD(v12) = v545 - 1;
        LODWORD(v11) = v526;
        if (v545 == 1)
          return;
      }
    case 18:
      v363 = v26;
      v364 = -(uint64_t)v28;
      v516 = -(v23 * v27);
      v365 = 16 * v26;
      while (1)
      {
        v534 = v36;
        v546 = v12;
        v366 = v11;
        do
        {
          v367 = *v19;
          if (*v19)
          {
            v368 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v367 * 0.0039216);
            LODWORD(a10) = v368.i32[3];
            v369 = v29 ? *(float *)&v368.i32[3] : (float)v367 * 0.0039216;
            if (v369 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v370 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v368.i32[3] = v369;
LABEL_475:
                  *v17 = vrev32q_s8(v368);
                  goto LABEL_476;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v370 = 1.0;
              }
              v371 = *(double *)v17->i64;
              v372 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v371) = HIDWORD(v372);
              v506 = v369;
              *(_QWORD *)&v373 = vextq_s8(v368, v368, 4uLL).u64[0];
              *(float *)v368.i32 = PDAcolordodgePDA(*(float *)&v372, v371, *(double *)a5.i64, *(double *)a6.i64, v370, v372, v373, a10, *(float *)v368.i32, COERCE_DOUBLE(__PAIR64__(v368.u32[3], HIDWORD(v373))), v506);
              v368.i32[1] = v374;
              v368.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_475;
            }
          }
LABEL_476:
          v19 += v363;
          v375 = &v24[v363];
          if ((unint64_t)v375 >= v37)
            v376 = v364;
          else
            v376 = 0;
          v24 = &v375[v376];
          v17 = (int8x16_t *)((char *)v17 + v365);
          --v366;
        }
        while (v366);
        v19 += v525;
        v17 += v523;
        v36 = v534;
        v377 = v534 + 16 * v524;
        v378 = v516;
        if (v377 < v521)
          v378 = 0;
        v379 = (int8x16_t *)(v377 + 16 * v378);
        v380 = v37 + 16 * v378 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v380;
          v36 = (uint64_t)v379;
          v24 = v379;
        }
        LODWORD(v12) = v546 - 1;
        LODWORD(v11) = v526;
        if (v546 == 1)
          return;
      }
    case 19:
      v381 = v26;
      v382 = -(uint64_t)v28;
      v517 = -(v23 * v27);
      v383 = 16 * v26;
      while (1)
      {
        v535 = v36;
        v547 = v12;
        v384 = v11;
        do
        {
          v385 = *v19;
          if (*v19)
          {
            v386 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v385 * 0.0039216);
            LODWORD(a10) = v386.i32[3];
            v387 = v29 ? *(float *)&v386.i32[3] : (float)v385 * 0.0039216;
            if (v387 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v388 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v386.i32[3] = v387;
LABEL_499:
                  *v17 = vrev32q_s8(v386);
                  goto LABEL_500;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v388 = 1.0;
              }
              v389 = *(double *)v17->i64;
              v390 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v389) = HIDWORD(v390);
              v507 = v387;
              *(_QWORD *)&v391 = vextq_s8(v386, v386, 4uLL).u64[0];
              *(float *)v386.i32 = PDAcolorburnPDA(*(float *)&v390, v389, *(double *)a5.i64, *(double *)a6.i64, v388, v390, v391, a10, *(float *)v386.i32, COERCE_DOUBLE(__PAIR64__(v386.u32[3], HIDWORD(v391))), v507);
              v386.i32[1] = v392;
              v386.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_499;
            }
          }
LABEL_500:
          v19 += v381;
          v393 = &v24[v381];
          if ((unint64_t)v393 >= v37)
            v394 = v382;
          else
            v394 = 0;
          v24 = &v393[v394];
          v17 = (int8x16_t *)((char *)v17 + v383);
          --v384;
        }
        while (v384);
        v19 += v525;
        v17 += v523;
        v36 = v535;
        v395 = v535 + 16 * v524;
        v396 = v517;
        if (v395 < v521)
          v396 = 0;
        v397 = (int8x16_t *)(v395 + 16 * v396);
        v398 = v37 + 16 * v396 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v398;
          v36 = (uint64_t)v397;
          v24 = v397;
        }
        LODWORD(v12) = v547 - 1;
        LODWORD(v11) = v526;
        if (v547 == 1)
          return;
      }
    case 20:
      v399 = v26;
      v400 = -(uint64_t)v28;
      v518 = -(v23 * v27);
      v401 = 16 * v26;
      while (1)
      {
        v536 = v36;
        v548 = v12;
        v402 = v11;
        do
        {
          v403 = *v19;
          if (*v19)
          {
            v404 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v403 * 0.0039216);
            LODWORD(a10) = v404.i32[3];
            v405 = v29 ? *(float *)&v404.i32[3] : (float)v403 * 0.0039216;
            if (v405 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                LODWORD(a7) = a6.i32[0];
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v404.i32[3] = v405;
LABEL_523:
                  *v17 = vrev32q_s8(v404);
                  goto LABEL_524;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                LODWORD(a7) = 1.0;
              }
              v406 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              DWORD2(v501) = v404.i32[3];
              *(_QWORD *)&v501 = vextq_s8(v404, v404, 4uLL).u64[0];
              *(float *)v404.i32 = PDAsoftlightPDA(*(float *)&v406, *((float *)&v406 + 1), *(double *)a5.i64, *(int32x2_t *)a6.i8, a7, v406, *(double *)&v501, a10, a1, a2, v23, v11, v12, v31, v32, v36, *(float *)v404.i32, v501, *(uint64_t *)((char *)&v501 + 4),
                                     v405);
              v404.i32[1] = v407;
              v404.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_523;
            }
          }
LABEL_524:
          v19 += v399;
          v408 = &v24[v399];
          if ((unint64_t)v408 >= v37)
            v409 = v400;
          else
            v409 = 0;
          v24 = &v408[v409];
          v17 = (int8x16_t *)((char *)v17 + v401);
          --v402;
        }
        while (v402);
        v19 += v525;
        v17 += v523;
        v36 = v536;
        v410 = v536 + 16 * v524;
        v411 = v518;
        if (v410 < v521)
          v411 = 0;
        v412 = (int8x16_t *)(v410 + 16 * v411);
        v413 = v37 + 16 * v411 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v413;
          v36 = (uint64_t)v412;
          v24 = v412;
        }
        v12 = (v548 - 1);
        v11 = v526;
        if (v548 == 1)
          return;
      }
    case 21:
      v414 = v26;
      v415 = -(uint64_t)v28;
      v519 = -(v23 * v27);
      v416 = 16 * v26;
      while (1)
      {
        v537 = v36;
        v549 = v12;
        v417 = v11;
        do
        {
          v418 = *v19;
          if (*v19)
          {
            v419 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v418 * 0.0039216);
            LODWORD(a10) = v419.i32[3];
            v420 = v29 ? *(float *)&v419.i32[3] : (float)v418 * 0.0039216;
            if (v420 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v421 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v419.i32[3] = v420;
LABEL_547:
                  *v17 = vrev32q_s8(v419);
                  goto LABEL_548;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v421 = 1.0;
              }
              v422 = *(double *)v17->i64;
              v423 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v422) = HIDWORD(v423);
              v508 = v420;
              *(_QWORD *)&v424 = vextq_s8(v419, v419, 4uLL).u64[0];
              *(float *)v419.i32 = PDAhardlightPDA(*(float *)&v423, v422, *(double *)a5.i64, *(double *)a6.i64, v421, v423, v424, a10, *(float *)v419.i32, COERCE_DOUBLE(__PAIR64__(v419.u32[3], HIDWORD(v424))), v508);
              v419.i32[1] = v425;
              v419.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_547;
            }
          }
LABEL_548:
          v19 += v414;
          v426 = &v24[v414];
          if ((unint64_t)v426 >= v37)
            v427 = v415;
          else
            v427 = 0;
          v24 = &v426[v427];
          v17 = (int8x16_t *)((char *)v17 + v416);
          --v417;
        }
        while (v417);
        v19 += v525;
        v17 += v523;
        v36 = v537;
        v428 = v537 + 16 * v524;
        v429 = v519;
        if (v428 < v521)
          v429 = 0;
        v430 = (int8x16_t *)(v428 + 16 * v429);
        v431 = v37 + 16 * v429 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v431;
          v36 = (uint64_t)v430;
          v24 = v430;
        }
        LODWORD(v12) = v549 - 1;
        LODWORD(v11) = v526;
        if (v549 == 1)
          return;
      }
    case 22:
      v432 = -(uint64_t)v28;
      v433 = -(v23 * v27);
      while (1)
      {
        v434 = v11;
        do
        {
          if (*v19)
          {
            v435 = (float)*v19 * 0.0039216;
            v436 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), v435);
            if (v29)
              v435 = v436.f32[3];
            if (v435 > 0.0)
            {
              if (v38)
              {
                v437 = COERCE_FLOAT(bswap32(v17->u32[3]));
                if (v437 <= 0.0)
                {
                  v436.f32[3] = v435;
                  v438 = (int8x16_t)v436;
LABEL_572:
                  *v17 = vrev32q_s8(v438);
                  goto LABEL_573;
                }
              }
              else
              {
                v437 = 1.0;
              }
              v439 = COERCE_FLOAT(bswap32(v17->u32[2]));
              v440 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
              v441 = vadd_f32(*(float32x2_t *)v436.f32, v440);
              v442 = vmul_n_f32(v440, v435);
              v443 = vmul_n_f32(*(float32x2_t *)v436.f32, v437);
              v444 = vsub_f32(v441, v442);
              v445 = vsub_f32(v442, v443);
              *(float32x2_t *)v438.i8 = vadd_f32(vsub_f32(v444, v443), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v445), (int8x8_t)vneg_f32(v445), (int8x8_t)v445));
              v436.f32[0] = vmuls_lane_f32(v437, v436, 2);
              v446 = (float)(v435 * v439) - v436.f32[0];
              v436.f32[0] = (float)((float)(v436.f32[2] + v439) - (float)(v435 * v439)) - v436.f32[0];
              if (v446 < 0.0)
                v446 = -v446;
              *(float *)&v438.i32[2] = v436.f32[0] + v446;
              *(float *)&v438.i32[3] = (float)(v437 + v435) - (float)(v437 * v435);
              goto LABEL_572;
            }
          }
LABEL_573:
          v19 += v26;
          v447 = &v24[v26];
          if ((unint64_t)v447 >= v37)
            v448 = v432;
          else
            v448 = 0;
          v24 = &v447[v448];
          v17 += v26;
          --v434;
        }
        while (v434);
        v19 += v30;
        v17 += v31;
        v449 = v36 + 16 * v23;
        if (v449 >= v34)
          v450 = v433;
        else
          v450 = 0;
        v451 = (int8x16_t *)(v449 + 16 * v450);
        v452 = v37 + 16 * v450 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v452;
          v36 = (uint64_t)v451;
          v24 = v451;
        }
        LODWORD(v12) = v12 - 1;
        if (!(_DWORD)v12)
          return;
      }
    case 23:
      v453 = -(uint64_t)v28;
      v454 = -(v23 * v27);
      while (1)
      {
        v455 = v11;
        do
        {
          if (*v19)
          {
            v456 = (float)*v19 * 0.0039216;
            v457 = COERCE_FLOAT(bswap32(v24->u32[3]));
            if (!v29)
              v457 = 1.0;
            v458 = v456 * v457;
            if (v458 > 0.0)
            {
              *(float32x2_t *)v459.i8 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v456);
              v460 = v456 * COERCE_FLOAT(bswap32(v24->u32[2]));
              if (v38)
              {
                v461 = COERCE_FLOAT(bswap32(v17->u32[3]));
                if (v461 <= 0.0)
                {
                  v459.i64[1] = __PAIR64__(LODWORD(v458), LODWORD(v460));
                  *v17 = vrev32q_s8(v459);
                  goto LABEL_596;
                }
              }
              else
              {
                v461 = 1.0;
              }
              v462 = COERCE_FLOAT(bswap32(v17->u32[2]));
              *(float *)&v463 = (float)(v458 + v461) - (float)(v461 * v458);
              v464 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
              *(int8x8_t *)v17->i8 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v459.i8, v464), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v459.i8, v464)));
              v17->i32[2] = bswap32(COERCE_UNSIGNED_INT((float)(v460 + v462) + (float)((float)(v460 * v462) * -2.0)));
              v17->i32[3] = bswap32(v463);
            }
          }
LABEL_596:
          v19 += v26;
          v465 = &v24[v26];
          if ((unint64_t)v465 >= v37)
            v466 = v453;
          else
            v466 = 0;
          v24 = &v465[v466];
          v17 += v26;
          --v455;
        }
        while (v455);
        v19 += v30;
        v17 += v31;
        v467 = v36 + 16 * v23;
        if (v467 >= v34)
          v468 = v454;
        else
          v468 = 0;
        v469 = (int8x16_t *)(v467 + 16 * v468);
        v470 = v37 + 16 * v468 + 16 * v23;
        if ((_DWORD)v32)
        {
          v24 += v23;
        }
        else
        {
          v37 = v470;
          v36 = (uint64_t)v469;
          v24 = v469;
        }
        LODWORD(v12) = v12 - 1;
        if (!(_DWORD)v12)
          return;
      }
    case 24:
      v223 = v26;
      v224 = -(uint64_t)v28;
      v511 = -(v23 * v27);
      v225 = 16 * v26;
      while (1)
      {
        v529 = v36;
        v541 = v12;
        v226 = v11;
        do
        {
          v227 = *v19;
          if (*v19)
          {
            v228 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v227 * 0.0039216);
            LODWORD(a10) = v228.i32[3];
            v229 = v29 ? *(float *)&v228.i32[3] : (float)v227 * 0.0039216;
            if (v229 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v230 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v228.i32[3] = v229;
LABEL_280:
                  *v17 = vrev32q_s8(v228);
                  goto LABEL_281;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v230 = 1.0;
              }
              v231 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              *(_QWORD *)&v498 = vextq_s8(v228, v228, 4uLL).u64[0];
              *(float *)v228.i32 = PDAhuePDA(*(float *)&v231, *((float *)&v231 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(double *)a6.i64, v230, v231, v498, a10, *(float *)v228.i32, *(float *)&v498, *((float *)&v498 + 1), *(float *)&v228.i32[3], v229);
              v228.i32[1] = v232;
              v228.i64[1] = __PAIR64__(a6.u32[0], v233);
              goto LABEL_280;
            }
          }
LABEL_281:
          v19 += v223;
          v234 = &v24[v223];
          if ((unint64_t)v234 >= v37)
            v235 = v224;
          else
            v235 = 0;
          v24 = &v234[v235];
          v17 = (int8x16_t *)((char *)v17 + v225);
          --v226;
        }
        while (v226);
        v19 += v525;
        v17 += v523;
        v36 = v529;
        v236 = v529 + 16 * v524;
        v237 = v511;
        if (v236 < v521)
          v237 = 0;
        v238 = (int8x16_t *)(v236 + 16 * v237);
        v239 = v37 + 16 * v237 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v239;
          v36 = (uint64_t)v238;
          v24 = v238;
        }
        LODWORD(v12) = v541 - 1;
        LODWORD(v11) = v526;
        if (v541 == 1)
          return;
      }
    case 25:
      v240 = v26;
      v241 = -(uint64_t)v28;
      v512 = -(v23 * v27);
      v242 = 16 * v26;
      while (1)
      {
        v530 = v36;
        v542 = v12;
        v243 = v11;
        do
        {
          v244 = *v19;
          if (*v19)
          {
            v245 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v244 * 0.0039216);
            LODWORD(a10) = v245.i32[3];
            v246 = v29 ? *(float *)&v245.i32[3] : (float)v244 * 0.0039216;
            if (v246 > 0.0)
            {
              if (v38)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v247 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v245.i32[3] = v246;
LABEL_304:
                  *v17 = vrev32q_s8(v245);
                  goto LABEL_305;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                v247 = 1.0;
              }
              v248 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              *(_QWORD *)&v499 = vextq_s8(v245, v245, 4uLL).u64[0];
              *(float *)v245.i32 = PDAsaturationPDA(*(float *)&v248, *((float *)&v248 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(double *)a6.i64, v247, v248, v499, a10, *(float *)v245.i32, *(float *)&v499, *((float *)&v499 + 1), *(float *)&v245.i32[3], v246);
              v245.i32[1] = v249;
              v245.i64[1] = __PAIR64__(a6.u32[0], v250);
              goto LABEL_304;
            }
          }
LABEL_305:
          v19 += v240;
          v251 = &v24[v240];
          if ((unint64_t)v251 >= v37)
            v252 = v241;
          else
            v252 = 0;
          v24 = &v251[v252];
          v17 = (int8x16_t *)((char *)v17 + v242);
          --v243;
        }
        while (v243);
        v19 += v525;
        v17 += v523;
        v36 = v530;
        v253 = v530 + 16 * v524;
        v254 = v512;
        if (v253 < v521)
          v254 = 0;
        v255 = (int8x16_t *)(v253 + 16 * v254);
        v256 = v37 + 16 * v254 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v256;
          v36 = (uint64_t)v255;
          v24 = v255;
        }
        LODWORD(v12) = v542 - 1;
        LODWORD(v11) = v526;
        if (v542 == 1)
          return;
      }
    case 26:
      v471 = v26;
      v472 = -(uint64_t)v28;
      v520 = -(v23 * v27);
      v473 = 16 * v26;
      while (1)
      {
        v538 = v36;
        v550 = v12;
        v474 = v11;
        do
        {
          v475 = *v19;
          if (*v19)
          {
            v476 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v475 * 0.0039216);
            a6.i32[0] = v476.i32[3];
            v477 = v29 ? *(float *)&v476.i32[3] : (float)v475 * 0.0039216;
            if (v477 > 0.0)
            {
              if (v38)
              {
                LODWORD(a8) = bswap32(v17->u32[3]);
                LODWORD(a9) = LODWORD(a8);
                if (*(float *)&a8 <= 0.0)
                {
                  *(float *)&v476.i32[3] = v477;
LABEL_620:
                  *v17 = vrev32q_s8(v476);
                  goto LABEL_621;
                }
              }
              else
              {
                LODWORD(a8) = bswap32(v17->u32[3]);
                LODWORD(a9) = 1.0;
              }
              v497 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              *(float *)v476.i32 = PDAluminosityPDA(*(float *)v476.i32, *(float *)&v476.i32[1], *(float *)&v476.i32[2], *(double *)a6.i64, v477, a8, a9, v497, *(float *)&v497, *((float *)&v497 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(float *)&a8, *(float *)&a9);
              v476.i32[1] = v478;
              v476.i64[1] = __PAIR64__(a6.u32[0], v479);
              goto LABEL_620;
            }
          }
LABEL_621:
          v19 += v471;
          v480 = &v24[v471];
          if ((unint64_t)v480 >= v37)
            v481 = v472;
          else
            v481 = 0;
          v24 = &v480[v481];
          v17 = (int8x16_t *)((char *)v17 + v473);
          --v474;
        }
        while (v474);
        v19 += v525;
        v17 += v523;
        v36 = v538;
        v482 = v538 + 16 * v524;
        v483 = v520;
        if (v482 < v521)
          v483 = 0;
        v484 = (int8x16_t *)(v482 + 16 * v483);
        v485 = v37 + 16 * v483 + 16 * v524;
        if (v522)
        {
          v24 += v524;
        }
        else
        {
          v37 = v485;
          v36 = (uint64_t)v484;
          v24 = v484;
        }
        LODWORD(v12) = v550 - 1;
        LODWORD(v11) = v526;
        if (v550 == 1)
          return;
      }
    case 27:
      v257 = v26;
      v258 = -(uint64_t)v28;
      v513 = -(v23 * v27);
      v259 = 16 * v26;
      break;
    default:
      return;
  }
  do
  {
    v531 = v36;
    v543 = v12;
    v260 = v11;
    do
    {
      v261 = *v19;
      if (*v19)
      {
        v262 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v261 * 0.0039216);
        LODWORD(a10) = v262.i32[3];
        v263 = v29 ? *(float *)&v262.i32[3] : (float)v261 * 0.0039216;
        if (v263 > 0.0)
        {
          if (v38)
          {
            a6.i32[0] = bswap32(v17->u32[3]);
            v264 = *(float *)a6.i32;
            if (*(float *)a6.i32 <= 0.0)
            {
              *(float *)&v262.i32[3] = v263;
LABEL_328:
              *v17 = vrev32q_s8(v262);
              goto LABEL_329;
            }
          }
          else
          {
            a6.i32[0] = bswap32(v17->u32[3]);
            v264 = 1.0;
          }
          v265 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
          *(_QWORD *)&v500 = vextq_s8(v262, v262, 4uLL).u64[0];
          *(float *)v262.i32 = PDAluminosityPDA(*(float *)&v265, *((float *)&v265 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(double *)a6.i64, v264, v265, v500, a10, *(float *)v262.i32, *(float *)&v500, *((float *)&v500 + 1), *(float *)&v262.i32[3], v263);
          v262.i32[1] = v266;
          v262.i64[1] = __PAIR64__(a6.u32[0], v267);
          goto LABEL_328;
        }
      }
LABEL_329:
      v19 += v257;
      v268 = &v24[v257];
      if ((unint64_t)v268 >= v37)
        v269 = v258;
      else
        v269 = 0;
      v24 = &v268[v269];
      v17 = (int8x16_t *)((char *)v17 + v259);
      --v260;
    }
    while (v260);
    v19 += v525;
    v17 += v523;
    v36 = v531;
    v270 = v531 + 16 * v524;
    v271 = v513;
    if (v270 < v521)
      v271 = 0;
    v272 = (int8x16_t *)(v270 + 16 * v271);
    v273 = v37 + 16 * v271 + 16 * v524;
    if (v522)
    {
      v24 += v524;
    }
    else
    {
      v37 = v273;
      v36 = (uint64_t)v272;
      v24 = v272;
    }
    LODWORD(v12) = v543 - 1;
    LODWORD(v11) = v526;
  }
  while (v543 != 1);
}

uint64_t RGBAF_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  int *v6;
  _BOOL4 v7;
  signed int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  int *v23;
  int v24;
  unint64_t v25;
  void (*v26)(uint64_t, _DWORD *);
  uint64_t v27;
  int v28;
  int v29;
  uint64_t (*v30)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double);
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  _OWORD v36[64];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v6 = (int *)*a1;
  memset(v36, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*((_QWORD *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v30, (uint64_t)v36) < 1)
    return 0xFFFFFFFFLL;
  v18 = *v6;
  v19 = *(_DWORD *)a3;
  v31 = v19;
  v32 = v18;
  if (v19 != 538981257)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      v23 = RGBF_image_sample;
      v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGBF_image_sample[2 * v20 + 2];
      if (v30)
      {
LABEL_29:
        v31 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v34 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v25) = v22;
          LODWORD(v25) = v22;
          switch((v25 >> 3))
          {
            case 0u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAF_image_mark_RGB32;
              goto LABEL_52;
            case 1u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAF_image_mark_RGB32;
              goto LABEL_54;
            case 2u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAF_image_mark_W8;
              goto LABEL_52;
            case 3u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAF_image_mark_RGB24;
              goto LABEL_52;
            case 4u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAF_image_mark_rgb32;
LABEL_52:
              v27 = (uint64_t)a2;
              v28 = v8;
              v29 = 0;
              break;
            case 5u:
              v31 = *(_DWORD *)a3;
              v26 = (void (*)(uint64_t, _DWORD *))RGBAF_image_mark_rgb32;
LABEL_54:
              v27 = (uint64_t)a2;
              v28 = v8;
              v29 = 8;
              break;
            default:
              goto LABEL_37;
          }
          RGBAF_image_mark_image(v27, (uint64_t)&v30, v28, v29, v26);
          return 1;
        }
        goto LABEL_37;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v23 = RGB8_image_sample;
        v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB8_image_sample[2 * v20 + 2];
        if (v30)
        {
          v24 = 4;
LABEL_28:
          v33 = v24;
          goto LABEL_29;
        }
      }
      v23 = RGB16_image_sample;
      v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB16_image_sample[2 * v20 + 2];
      if (v30)
      {
        v24 = 8;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v35 && (~v34 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((v34 & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      RGBAF_mark_inner(*(_QWORD *)(*a1 + 56), v17);
      return 1;
    }
  }
  v30 = RGBAf_sample_RGBAF_inner;
LABEL_37:
  RGBAF_image_mark((uint64_t)a2, (uint64_t)&v30, v8, v17);
  return 1;
}

uint64_t RGBAF_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, int32x4_t _Q2, double a10, int8x16_t a11)
{
  float v11;
  float v12;
  int8x16_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t result;
  float v24;
  unint64_t v29;
  uint64_t v30;
  int v31;
  unsigned __int8 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  unsigned int v39;
  char v40;
  unsigned __int8 *v41;
  unsigned int v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  unsigned int v45;
  unsigned __int8 *v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned __int8 *v51;
  int v52;
  int32x4_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  unsigned int v60;
  char v61;
  unsigned __int8 *v62;
  unsigned int v63;
  unsigned __int8 *v64;
  unsigned __int8 *v65;
  unsigned int v66;
  unsigned __int8 *v67;
  int v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned __int8 *v72;
  int v73;
  int32x4_t v74;
  float32x4_t v75;
  int32x4_t v76;
  uint64_t *v77;
  float v78;
  unsigned __int8 *v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 *v83;
  int32x4_t v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  unsigned __int8 *v88;
  int32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  uint64_t v92;

  v11 = *((float *)a2 + 2);
  v12 = *(float *)a2;
  v13 = (int8x16_t *)*((_QWORD *)a2 + 2);
  v14 = *((_QWORD *)a2 + 3) - a5;
  v16 = *((_QWORD *)a2 + 15);
  v15 = *((_QWORD *)a2 + 16);
  v17 = *((_QWORD *)a2 + 7);
  v18 = *((_QWORD *)a2 + 9);
  v19 = *((_QWORD *)a2 + 5) + v18 * a4;
  v20 = *(unsigned __int8 **)(a1 + 32);
  v21 = &v20[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  if (*(_QWORD *)(a1 + 176))
  {
    v22 = *((_QWORD *)a2 + 11);
    result = *((_QWORD *)a2 + 13);
    v24 = fminf(v11, 1.0);
    v92 = v15 + 16 * a3 + 8;
    __asm { FMOV            V2.2S, #1.0 }
    while (1)
    {
      if (((result - v19) | (v19 - v22)) < 0)
      {
        v31 = 0;
        v30 = 0;
      }
      else
      {
        v29 = ((v19 & (unint64_t)~(-1 << v17)) >> (v17 - 4)) & 0xF;
        v30 = v29 - 7 >= 9 ? -v16 : v16;
        v31 = weights_19497[v29] & 0xF;
      }
      v32 = &v20[(v19 >> v17) * v16];
      if (LODWORD(v12) != 1)
        break;
      if (a5 >= 1)
      {
        v33 = (uint64_t *)v92;
        v34 = a5;
        while (1)
        {
          v35 = *(v33 - 1);
          v36 = *v33;
          v37 = &v32[v35];
          if (v21 >= &v32[v35])
            v38 = &v32[v35];
          else
            v38 = v21;
          if (v20 > v38)
            v38 = v20;
          v39 = *v38;
          v40 = v36 & 0xF;
          if ((v36 & 0xF) != 0)
            break;
          if (v31)
          {
            v51 = &v37[v30];
            if (v21 < &v37[v30])
              v51 = v21;
            if (v20 > v51)
              v51 = v20;
            v52 = BLEND8_19499[v31];
            v49 = v39 - ((v52 & v39) >> v31);
            v50 = (v52 & *v51) >> v31;
            goto LABEL_40;
          }
LABEL_41:
          v33 += 2;
          v53 = _Q2;
          v53.i32[0] = _blt_float[v39];
          *(int8x8_t *)v53.i8 = vrev32_s8((int8x8_t)vmul_n_f32(*(float32x2_t *)v53.i8, v24));
          a11 = (int8x16_t)vzip1q_s32(v53, v53);
          a11.i32[2] = v53.i32[0];
          *v13++ = a11;
          if (!--v34)
            goto LABEL_80;
        }
        v41 = &v37[v36 >> 4];
        if (v21 < v41)
          v41 = v21;
        if (v20 > v41)
          v41 = v20;
        v42 = *v41;
        if (v31)
        {
          v43 = &v37[v30];
          if (v21 >= v43)
            v44 = v43;
          else
            v44 = v21;
          if (v20 > v44)
            v44 = v20;
          v45 = *v44;
          v46 = &v43[v36 >> 4];
          if (v21 < v46)
            v46 = v21;
          if (v20 > v46)
            v46 = v20;
          v47 = BLEND8_19499[v31];
          v39 = v39 - ((v47 & v39) >> v31) + ((v47 & v45) >> v31);
          v42 = v42 - ((v47 & v42) >> v31) + ((v47 & *v46) >> v31);
        }
        v48 = BLEND8_19499[*v33 & 0xF];
        v49 = v39 - ((v48 & v39) >> v40);
        v50 = (v48 & v42) >> v40;
LABEL_40:
        LOBYTE(v39) = v49 + v50;
        goto LABEL_41;
      }
LABEL_80:
      v13 += v14;
      v19 += v18;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_80;
    v54 = (uint64_t *)v92;
    v55 = a5;
    while (1)
    {
      v56 = *(v54 - 1);
      v57 = *v54;
      v58 = &v32[v56];
      if (v21 >= &v32[v56])
        v59 = &v32[v56];
      else
        v59 = v21;
      if (v20 > v59)
        v59 = v20;
      v60 = *v59;
      v61 = v57 & 0xF;
      if ((v57 & 0xF) != 0)
      {
        v62 = &v58[v57 >> 4];
        if (v21 < v62)
          v62 = v21;
        if (v20 > v62)
          v62 = v20;
        v63 = *v62;
        if (v31)
        {
          v64 = &v58[v30];
          if (v21 >= v64)
            v65 = v64;
          else
            v65 = v21;
          if (v20 > v65)
            v65 = v20;
          v66 = *v65;
          v67 = &v64[v57 >> 4];
          if (v21 < v67)
            v67 = v21;
          if (v20 > v67)
            v67 = v20;
          v68 = BLEND8_19499[v31];
          v60 = v60 - ((v68 & v60) >> v31) + ((v68 & v66) >> v31);
          v63 = v63 - ((v68 & v63) >> v31) + ((v68 & *v67) >> v31);
        }
        v69 = BLEND8_19499[*v54 & 0xF];
        v70 = v60 - ((v69 & v60) >> v61);
        v71 = (v69 & v63) >> v61;
      }
      else
      {
        if (!v31)
          goto LABEL_74;
        v72 = &v58[v30];
        if (v21 < &v58[v30])
          v72 = v21;
        if (v20 > v72)
          v72 = v20;
        v73 = BLEND8_19499[v31];
        v70 = v60 - ((v73 & v60) >> v31);
        v71 = (v73 & *v72) >> v31;
      }
      LOBYTE(v60) = v70 + v71;
LABEL_74:
      v74 = _Q2;
      v74.i32[0] = _blt_float[v60];
      *(float32x2_t *)v74.i8 = vmul_n_f32(*(float32x2_t *)v74.i8, v24);
      if (*(float *)&v74.i32[1] >= 1.0)
      {
        *(int8x8_t *)a11.i8 = vrev32_s8(*(int8x8_t *)v74.i8);
        v76 = vzip1q_s32((int32x4_t)a11, (int32x4_t)a11);
        v76.i32[2] = a11.i32[0];
        goto LABEL_78;
      }
      if (*(float *)&v74.i32[1] > 0.0)
      {
        v75 = (float32x4_t)vzip1q_s32(v74, v74);
        v75.i32[2] = v74.i32[0];
        a11 = vrev32q_s8(*v13);
        v76 = (int32x4_t)vrev32q_s8((int8x16_t)vmlaq_n_f32(v75, (float32x4_t)a11, 1.0 - *(float *)&v74.i32[1]));
LABEL_78:
        *v13 = (int8x16_t)v76;
      }
      v54 += 2;
      ++v13;
      if (!--v55)
        goto LABEL_80;
    }
  }
  v77 = (uint64_t *)(v15 + 16 * a3);
  result = a5;
  v78 = fminf(v11, 1.0);
  __asm { FMOV            V2.2S, #1.0 }
  do
  {
    v79 = &v20[(v19 >> v17) * v16];
    if (LODWORD(v12) != 1)
    {
      v85 = v77;
      v86 = a5;
      if (a5 < 1)
        goto LABEL_103;
      while (1)
      {
        v87 = *v85;
        v85 += 2;
        v88 = &v79[v87];
        if (v21 < &v79[v87])
          v88 = v21;
        if (v20 > v88)
          v88 = v20;
        v89 = _Q2;
        v89.i32[0] = _blt_float[*v88];
        *(float32x2_t *)v89.i8 = vmul_n_f32(*(float32x2_t *)v89.i8, v78);
        if (*(float *)&v89.i32[1] >= 1.0)
          break;
        if (*(float *)&v89.i32[1] > 0.0)
        {
          v90 = (float32x4_t)vzip1q_s32(v89, v89);
          v90.i32[2] = v89.i32[0];
          a11 = vrev32q_s8(*v13);
          v91 = (int32x4_t)vrev32q_s8((int8x16_t)vmlaq_n_f32(v90, (float32x4_t)a11, 1.0 - *(float *)&v89.i32[1]));
LABEL_101:
          *v13 = (int8x16_t)v91;
        }
        ++v13;
        if (!--v86)
          goto LABEL_103;
      }
      *(int8x8_t *)a11.i8 = vrev32_s8(*(int8x8_t *)v89.i8);
      v91 = vzip1q_s32((int32x4_t)a11, (int32x4_t)a11);
      v91.i32[2] = a11.i32[0];
      goto LABEL_101;
    }
    if (a5 >= 1)
    {
      v80 = v77;
      v81 = a5;
      do
      {
        v82 = *v80;
        v80 += 2;
        v83 = &v79[v82];
        if (v21 < &v79[v82])
          v83 = v21;
        if (v20 > v83)
          v83 = v20;
        v84 = _Q2;
        v84.i32[0] = _blt_float[*v83];
        *(int8x8_t *)v84.i8 = vrev32_s8((int8x8_t)vmul_n_f32(*(float32x2_t *)v84.i8, v78));
        a11 = (int8x16_t)vzip1q_s32(v84, v84);
        a11.i32[2] = v84.i32[0];
        *v13++ = a11;
        --v81;
      }
      while (v81);
    }
LABEL_103:
    v13 += v14;
    v19 += v18;
    --a6;
  }
  while (a6);
  return result;
}

void RGBAF_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  char v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  void *v39;
  int v40;
  int v41;
  int *v42;
  int v43;
  void *v44;
  void *v45;
  int v46;
  int v47;
  uint64_t v48;
  _DWORD v49[4];
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  int v65;
  int v66;
  int v67[4];

  v49[0] = a3;
  v49[1] = a4;
  v49[2] = *(_DWORD *)(a2 + 184);
  v8 = (unint64_t)*(int *)(a1 + 28) >> 4;
  v51 = v8;
  v9 = *(_QWORD *)(a2 + 120);
  v10 = *(_DWORD *)(a2 + 20);
  if (v9)
  {
    v11 = HIBYTE(v10);
    v12 = *(int *)(a2 + 24);
    v13 = (uint64_t *)(a2 + 104);
    v14 = (uint64_t *)(a2 + 72);
    v15 = (uint64_t *)(a2 + 88);
  }
  else
  {
    v11 = BYTE2(v10);
    v12 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v13 = (uint64_t *)(a2 + 96);
    v14 = (uint64_t *)(a2 + 64);
    v15 = (uint64_t *)(a2 + 80);
    v9 = *(_QWORD *)(a2 + 112);
  }
  v16 = *v15;
  v17 = *v14;
  v18 = *v13;
  v19 = v11;
  v54 = v11;
  v52 = v18;
  v62 = v12;
  v60 = v16;
  v58 = v17;
  v56 = v9;
  v20 = *(_QWORD *)(a2 + 128);
  v48 = v16;
  if (v20)
  {
    v21 = BYTE2(v10);
    v22 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v23 = (uint64_t *)(a2 + 96);
    v24 = (uint64_t *)(a2 + 64);
    v25 = (uint64_t *)(a2 + 80);
  }
  else
  {
    v21 = HIBYTE(v10);
    v22 = *(int *)(a2 + 24);
    v23 = (uint64_t *)(a2 + 104);
    v24 = (uint64_t *)(a2 + 72);
    v25 = (uint64_t *)(a2 + 88);
    v20 = *(_QWORD *)(a2 + 136);
  }
  v26 = *v25;
  v27 = *v24;
  v28 = *v23;
  v55 = v21;
  v53 = v28;
  v63 = v22;
  v61 = v26;
  v59 = v27;
  v57 = v20;
  v29 = *(unsigned int *)(a1 + 4);
  if ((v29 & 0x80000000) == 0)
  {
    v30 = malloc_type_malloc(16 * v29, 0x47853941uLL);
    v64 = v30;
    if (v30)
    {
      if (*(_QWORD *)(a2 + 176))
      {
        if ((_DWORD)v29)
        {
          v32 = v30 + 1;
          v33 = v48 - v18;
          do
          {
            if (((v18 - v17) | v33) < 0)
            {
              v36 = 0;
              v37 = 0;
            }
            else
            {
              v34 = ((v18 & (unint64_t)~(-1 << v19)) >> (v19 - 4)) & 0xF;
              v35 = weights_19497[v34];
              if (v34 - 7 >= 9)
                v36 = -(uint64_t)v12;
              else
                v36 = v12;
              v37 = v35 & 0xF;
            }
            *(v32 - 1) = v12 * (v18 >> v19);
            *v32 = v37 | (16 * v36);
            v32 += 2;
            v18 += v9;
            v33 -= v9;
            --v29;
          }
          while (v29);
        }
      }
      else if ((_DWORD)v29)
      {
        v38 = v30 + 1;
        do
        {
          *(v38 - 1) = v12 * (v18 >> v19);
          *v38 = 0;
          v38 += 2;
          v18 += v9;
          --v29;
        }
        while (v29);
      }
      v39 = v30;
      v40 = *(_DWORD *)(a1 + 4);
      v41 = *(_DWORD *)(a1 + 8);
      v65 = v41;
      v66 = v40;
      v42 = *(int **)(a1 + 136);
      if (v42)
      {
        v43 = *(_DWORD *)(a1 + 104);
        v67[0] = *(_DWORD *)(a1 + 108);
        v67[1] = v43;
        shape_enum_clip_alloc((uint64_t)v30, v31, v42, 1, 1, 1, v43, v67[0], v40, v41);
        v45 = v44;
        if (v44)
          goto LABEL_27;
      }
      v46 = 0;
      v47 = 0;
      v45 = 0;
      *(_QWORD *)v67 = 0;
      while (1)
      {
        v50 = *(_QWORD *)(a1 + 40) + 16 * v8 * (*(int *)(a1 + 16) + (uint64_t)v47) + 16 * (v46 + *(_DWORD *)(a1 + 12));
        a5(a2, v49);
        if (!v45)
          break;
LABEL_27:
        if (!shape_enum_clip_next((uint64_t)v45, &v67[1], v67, &v66, &v65))
        {
          free(v45);
          break;
        }
        v47 = v67[0];
        v46 = v67[1];
        v8 = v51;
      }
      free(v39);
    }
  }
}

_DWORD *RGBAF_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9)
{
  float v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  _DWORD *result;
  uint64_t v22;
  float32x4_t v23;
  unint64_t v29;
  uint64_t v30;
  int v31;
  unsigned __int8 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  unsigned int v39;
  unsigned __int8 *v40;
  int v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  int v44;
  unsigned __int8 *v45;
  unsigned int v46;
  unsigned __int8 *v47;
  float v48;
  float v49;
  int8x8_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  unsigned int v57;
  unsigned __int8 *v58;
  int v59;
  unsigned __int8 *v60;
  int v61;
  unsigned __int8 *v62;
  unsigned int v63;
  unsigned __int8 *v64;
  float32x2_t v65;
  float32x4_t v66;
  int8x8_t v67;
  uint64_t *v68;
  float32x4_t v69;
  unsigned __int8 *v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int8 *v75;
  uint64_t v76;
  uint64_t v77;
  float v78;
  float v79;
  int8x8_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned __int8 *v84;
  uint64_t v85;
  float32x2_t v86;
  float32x4_t v87;
  int8x8_t v88;
  uint64_t v89;
  uint64_t v90;

  LODWORD(v9) = a2[2];
  v10 = *a2;
  v11 = *((_QWORD *)a2 + 2);
  v12 = *((_QWORD *)a2 + 3) - a5;
  v13 = *((_QWORD *)a2 + 15);
  v14 = *((_QWORD *)a2 + 16);
  v15 = *((_QWORD *)a2 + 7);
  v16 = *((_QWORD *)a2 + 9);
  v17 = *((_QWORD *)a2 + 5) + v16 * a4;
  v18 = *(unsigned __int8 **)(a1 + 32);
  v19 = &v18[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v20 = *(_QWORD *)(a1 + 176);
  result = _blt_float;
  if (v20)
  {
    v90 = *((_QWORD *)a2 + 11);
    v22 = *((_QWORD *)a2 + 13);
    *(float *)&a9 = 1.0 - v9;
    v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    v89 = v14 + 16 * a3 + 8;
    __asm { FMOV            V3.2S, #1.0 }
    do
    {
      if (((v22 - v17) | (v17 - v90)) < 0)
      {
        v31 = 0;
        v30 = 0;
      }
      else
      {
        v29 = ((v17 & (unint64_t)~(-1 << v15)) >> (v15 - 4)) & 0xF;
        if (v29 - 7 >= 9)
          v30 = -v13;
        else
          v30 = v13;
        v31 = weights_19497[v29] & 0xF;
      }
      v32 = &v18[(v17 >> v15) * v13];
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          v33 = (uint64_t *)v89;
          v34 = a5;
          do
          {
            v35 = *(v33 - 1);
            v36 = *v33;
            v37 = &v32[v35];
            if (v19 >= &v32[v35])
              v38 = &v32[v35];
            else
              v38 = v19;
            if (v18 > v38)
              v38 = v18;
            v39 = (*v38 << 24) | (v38[1] << 16) | (v38[2] << 8);
            if ((v36 & 0xF) != 0)
            {
              v40 = &v37[v36 >> 4];
              if (v19 < v40)
                v40 = v19;
              if (v18 > v40)
                v40 = v18;
              v41 = (*v40 << 24) | (v40[1] << 16) | (v40[2] << 8);
              if (v31)
              {
                v42 = &v37[v30];
                if (v19 >= &v37[v30])
                  v43 = &v37[v30];
                else
                  v43 = v19;
                if (v18 > v43)
                  v43 = v18;
                v44 = (*v43 << 24) | (v43[1] << 16) | (v43[2] << 8);
                v45 = &v42[v36 >> 4];
                if (v19 < v45)
                  v45 = v19;
                if (v18 > v45)
                  v45 = v18;
                v46 = BLEND8_19499[v31];
                v39 = v39 - ((v46 & v39) >> v31) + ((v46 & v44) >> v31);
                v41 = v41 - ((v46 & v41) >> v31) + ((((*v45 << 24) | (v45[1] << 16) | (v45[2] << 8)) & v46) >> v31);
              }
              v39 = v39
                  - ((BLEND8_19499[*v33 & 0xF] & v39) >> (*v33 & 0xF))
                  + ((BLEND8_19499[*v33 & 0xF] & v41) >> (*v33 & 0xF));
            }
            else if (v31)
            {
              v47 = &v37[v30];
              if (v19 < &v37[v30])
                v47 = v19;
              if (v18 > v47)
                v47 = v18;
              v39 = v39
                  - ((BLEND8_19499[v31] & v39) >> v31)
                  + ((((*v47 << 24) | (v47[1] << 16) | (v47[2] << 8)) & BLEND8_19499[v31]) >> v31);
            }
            v48 = *(float *)&_blt_float[HIBYTE(v39)];
            if (v9 >= 1.0)
            {
              v49 = *(float *)&_blt_float[BYTE2(v39)];
              v50.i32[1] = HIDWORD(_D3);
              v50.i32[0] = _blt_float[BYTE1(v39)];
            }
            else
            {
              v48 = v9 * v48;
              v49 = v9 * *(float *)&_blt_float[BYTE2(v39)];
              *(float *)v50.i32 = v9 * *(float *)&_blt_float[BYTE1(v39)];
              *(float *)&v50.i32[1] = v9;
            }
            v33 += 2;
            *(_DWORD *)v11 = bswap32(LODWORD(v48));
            *(_DWORD *)(v11 + 4) = bswap32(LODWORD(v49));
            *(int8x8_t *)(v11 + 8) = vrev32_s8(v50);
            v11 += 16;
            --v34;
          }
          while (v34);
        }
      }
      else if (a5 >= 1)
      {
        v51 = (uint64_t *)v89;
        v52 = a5;
        do
        {
          v53 = *(v51 - 1);
          v54 = *v51;
          v55 = &v32[v53];
          if (v19 >= &v32[v53])
            v56 = &v32[v53];
          else
            v56 = v19;
          if (v18 > v56)
            v56 = v18;
          v57 = (*v56 << 24) | (v56[1] << 16) | (v56[2] << 8);
          if ((v54 & 0xF) != 0)
          {
            v58 = &v55[v54 >> 4];
            if (v19 < v58)
              v58 = v19;
            if (v18 > v58)
              v58 = v18;
            v59 = (*v58 << 24) | (v58[1] << 16) | (v58[2] << 8);
            if (v31)
            {
              if (v19 >= &v55[v30])
                v60 = &v55[v30];
              else
                v60 = v19;
              if (v18 > v60)
                v60 = v18;
              v61 = (*v60 << 24) | (v60[1] << 16) | (v60[2] << 8);
              v62 = &v55[v30 + (v54 >> 4)];
              if (v19 < v62)
                v62 = v19;
              if (v18 > v62)
                v62 = v18;
              v63 = BLEND8_19499[v31];
              v57 = v57 - ((v63 & v57) >> v31) + ((v63 & v61) >> v31);
              v59 = v59 - ((v63 & v59) >> v31) + ((((*v62 << 24) | (v62[1] << 16) | (v62[2] << 8)) & v63) >> v31);
            }
            v57 = v57
                - ((BLEND8_19499[*v51 & 0xF] & v57) >> (*v51 & 0xF))
                + ((BLEND8_19499[*v51 & 0xF] & v59) >> (*v51 & 0xF));
          }
          else if (v31)
          {
            v64 = &v55[v30];
            if (v19 < &v55[v30])
              v64 = v19;
            if (v18 > v64)
              v64 = v18;
            v57 = v57
                - ((BLEND8_19499[v31] & v57) >> v31)
                + ((((*v64 << 24) | (v64[1] << 16) | (v64[2] << 8)) & BLEND8_19499[v31]) >> v31);
          }
          v65.i32[0] = _blt_float[HIBYTE(v57)];
          if (v9 >= 1.0)
          {
            v67.i32[1] = HIDWORD(_D3);
            v67.i32[0] = _blt_float[BYTE1(v57)];
            v65.i32[1] = _blt_float[BYTE2(v57)];
            *(int8x8_t *)v11 = vrev32_s8((int8x8_t)v65);
            *(int8x8_t *)(v11 + 8) = vrev32_s8(v67);
          }
          else
          {
            v65.i32[1] = _blt_float[BYTE2(v57)];
            *(float32x2_t *)v66.f32 = vmul_n_f32(v65, v9);
            if (v9 > 0.0)
            {
              v66.i64[1] = __PAIR64__(LODWORD(v9), v9 * *(float *)&_blt_float[BYTE1(v57)]);
              *(int8x16_t *)v11 = vrev32q_s8((int8x16_t)vmlaq_f32(v66, v23, (float32x4_t)vrev32q_s8(*(int8x16_t *)v11)));
            }
          }
          v51 += 2;
          v11 += 16;
          --v52;
        }
        while (v52);
      }
      v11 += 16 * v12;
      v17 += v16;
      --a6;
    }
    while (a6);
  }
  else
  {
    v68 = (uint64_t *)(v14 + 16 * a3);
    *(float *)&a9 = 1.0 - v9;
    v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    __asm { FMOV            V3.2S, #1.0 }
    do
    {
      v71 = &v18[(v17 >> v15) * v13];
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          v72 = v68;
          v73 = a5;
          do
          {
            v74 = *v72;
            v72 += 2;
            v75 = &v71[v74];
            if (v19 < &v71[v74])
              v75 = v19;
            if (v18 > v75)
              v75 = v18;
            v76 = v75[1];
            v77 = v75[2];
            v78 = *(float *)&_blt_float[*v75];
            if (v9 >= 1.0)
            {
              v79 = *(float *)&_blt_float[v76];
              v80.i32[1] = HIDWORD(_D3);
              v80.i32[0] = _blt_float[v77];
            }
            else
            {
              v78 = v9 * v78;
              v79 = v9 * *(float *)&_blt_float[v76];
              *(float *)v80.i32 = v9 * *(float *)&_blt_float[v77];
              *(float *)&v80.i32[1] = v9;
            }
            *(_DWORD *)v11 = bswap32(LODWORD(v78));
            *(_DWORD *)(v11 + 4) = bswap32(LODWORD(v79));
            *(int8x8_t *)(v11 + 8) = vrev32_s8(v80);
            v11 += 16;
            --v73;
          }
          while (v73);
        }
      }
      else
      {
        v81 = v68;
        v82 = a5;
        if (a5 >= 1)
        {
          do
          {
            v83 = *v81;
            v81 += 2;
            v84 = &v71[v83];
            if (v19 < &v71[v83])
              v84 = v19;
            if (v18 > v84)
              v84 = v18;
            v85 = v84[2];
            v86.i32[0] = _blt_float[*v84];
            if (v9 >= 1.0)
            {
              v88.i32[1] = HIDWORD(_D3);
              v88.i32[0] = _blt_float[v85];
              v86.i32[1] = _blt_float[v84[1]];
              *(int8x8_t *)v11 = vrev32_s8((int8x8_t)v86);
              *(int8x8_t *)(v11 + 8) = vrev32_s8(v88);
            }
            else
            {
              v86.i32[1] = _blt_float[v84[1]];
              *(float32x2_t *)v87.f32 = vmul_n_f32(v86, v9);
              if (v9 > 0.0)
              {
                v87.i64[1] = __PAIR64__(LODWORD(v9), v9 * *(float *)&_blt_float[v85]);
                *(int8x16_t *)v11 = vrev32q_s8((int8x16_t)vmlaq_f32(v87, v69, (float32x4_t)vrev32q_s8(*(int8x16_t *)v11)));
              }
            }
            v11 += 16;
            --v82;
          }
          while (v82);
        }
      }
      v11 += 16 * v12;
      v17 += v16;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t RGBAF_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6;
  int v7;
  unsigned int *v8;
  char v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t result;
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  int v36;
  unsigned int *v37;
  unsigned int v38;
  float v39;
  float v40;
  float v41;
  float v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int *v53;
  int v54;
  unsigned int *v55;
  unsigned int v56;
  float v57;
  float v58;
  float v59;
  float v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int *v65;
  unsigned int v66;
  float v67;
  float v68;
  float v69;
  float v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  unsigned int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float v82;

  v6 = *((float *)a2 + 2);
  v7 = a2[1];
  v82 = *(float *)a2;
  v8 = *(unsigned int **)(a1 + 32);
  if (*(_QWORD *)(a1 + 40))
    v9 = 0;
  else
    v9 = -1;
  v10 = (unsigned int *)*((_QWORD *)a2 + 2);
  v11 = *((_QWORD *)a2 + 3) - a5;
  v13 = *((_QWORD *)a2 + 15);
  v12 = *((_QWORD *)a2 + 16);
  v14 = *((_QWORD *)a2 + 7);
  v15 = *((_QWORD *)a2 + 9);
  v16 = *((_QWORD *)a2 + 5) + v15 * a4;
  v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(_QWORD *)(a1 + 176))
  {
    v81 = *((_QWORD *)a2 + 11);
    v80 = *((_QWORD *)a2 + 13);
    v79 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v80 - v16) | (v16 - v81)) < 0)
      {
        v20 = 0;
        v19 = 0;
      }
      else
      {
        v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9)
          v19 = -v13;
        else
          v19 = v13;
        v20 = weights_19497[v18] & 0xF;
      }
      result = v16 >> v14;
      v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v82) == 1)
      {
        if (a5 >= 1)
        {
          result = v20;
          v23 = (uint64_t *)v79;
          v24 = a5;
          do
          {
            v25 = *(v23 - 1);
            v26 = *v23;
            v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25])
              v28 = (unsigned int *)&v22[v25];
            else
              v28 = v17;
            if (v8 > v28)
              v28 = v8;
            v29 = bswap32(*v28);
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30)
                v30 = v17;
              if (v8 > v30)
                v30 = v8;
              v31 = bswap32(*v30);
              if (v20)
              {
                v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v8 > v33)
                  v33 = v8;
                v34 = bswap32(*v33);
                v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35)
                  v35 = v17;
                if (v8 > v35)
                  v35 = v8;
                v36 = BLEND8_19499[v20];
                v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                v31 = v31 - ((v36 & v31) >> v20) + ((bswap32(*v35) & v36) >> v20);
              }
              v29 = v29
                  - ((BLEND8_19499[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_19499[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19])
                v37 = v17;
              if (v8 > v37)
                v37 = v8;
              v29 = v29 - ((BLEND8_19499[v20] & v29) >> v20) + ((bswap32(*v37) & BLEND8_19499[v20]) >> v20);
            }
            v38 = __ROL4__(v29, v7);
            v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              v40 = *(float *)&_blt_float[BYTE2(v38)];
              v41 = *(float *)&_blt_float[BYTE1(v38)];
              v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              v39 = v6 * v39;
              v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *v10 = bswap32(LODWORD(v39));
            v10[1] = bswap32(LODWORD(v40));
            v10[2] = bswap32(LODWORD(v41));
            v10[3] = bswap32(LODWORD(v42));
            v10 += 4;
            --v24;
          }
          while (v24);
        }
        goto LABEL_86;
      }
      if (a5 >= 1)
        break;
LABEL_86:
      v10 += 4 * v11;
      v16 += v15;
      if (!--a6)
        return result;
    }
    v43 = (uint64_t *)v79;
    result = a5;
    while (1)
    {
      v44 = *(v43 - 1);
      v45 = *v43;
      v46 = &v22[v44];
      if (v17 >= (unsigned int *)&v22[v44])
        v47 = (unsigned int *)&v22[v44];
      else
        v47 = v17;
      if (v8 > v47)
        v47 = v8;
      v48 = bswap32(*v47);
      if ((v45 & 0xF) != 0)
      {
        v49 = (unsigned int *)&v46[v45 >> 4];
        if (v17 < v49)
          v49 = v17;
        if (v8 > v49)
          v49 = v8;
        v50 = bswap32(*v49);
        if (v20)
        {
          if (v17 >= (unsigned int *)&v46[v19])
            v51 = (unsigned int *)&v46[v19];
          else
            v51 = v17;
          if (v8 > v51)
            v51 = v8;
          v52 = bswap32(*v51);
          v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
          if (v17 < v53)
            v53 = v17;
          if (v8 > v53)
            v53 = v8;
          v54 = BLEND8_19499[v20];
          v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
          v50 = v50 - ((v54 & v50) >> v20) + ((bswap32(*v53) & v54) >> v20);
        }
        v48 = v48
            - ((BLEND8_19499[*v43 & 0xF] & v48) >> (*v43 & 0xF))
            + ((BLEND8_19499[*v43 & 0xF] & v50) >> (*v43 & 0xF));
      }
      else if (v20)
      {
        v55 = (unsigned int *)&v46[v19];
        if (v17 < (unsigned int *)&v46[v19])
          v55 = v17;
        if (v8 > v55)
          v55 = v8;
        v48 = v48 - ((BLEND8_19499[v20] & v48) >> v20) + ((bswap32(*v55) & BLEND8_19499[v20]) >> v20);
      }
      v56 = __ROL4__(v48, v7);
      v57 = *(float *)&_blt_float[HIBYTE(v56)];
      if (v6 >= 1.0)
      {
        v58 = *(float *)&_blt_float[BYTE2(v56)];
        v59 = *(float *)&_blt_float[BYTE1(v56)];
        v60 = *(float *)&_blt_float[(v56 | v9)];
      }
      else
      {
        v57 = v6 * v57;
        v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
        v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
        v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
      }
      if (v60 >= 1.0)
        goto LABEL_84;
      if (v60 > 0.0)
        break;
LABEL_85:
      v43 += 2;
      v10 += 4;
      if (!--result)
        goto LABEL_86;
    }
    v57 = v57 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v60));
    v58 = v58 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v60));
    v59 = v59 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v60));
    v60 = v60 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v60));
LABEL_84:
    *v10 = bswap32(LODWORD(v57));
    v10[1] = bswap32(LODWORD(v58));
    v10[2] = bswap32(LODWORD(v59));
    v10[3] = bswap32(LODWORD(v60));
    goto LABEL_85;
  }
  v61 = v12 + 16 * a3;
  result = 32;
  do
  {
    v62 = (char *)v8 + (v16 >> v14) * v13;
    if (LODWORD(v82) != 1)
    {
      result = v61;
      v71 = a5;
      if (a5 < 1)
        goto LABEL_114;
      while (1)
      {
        v72 = *(_QWORD *)result;
        result += 16;
        v73 = (unsigned int *)&v62[v72];
        if (v17 < (unsigned int *)&v62[v72])
          v73 = v17;
        if (v8 > v73)
          v73 = v8;
        v74 = __ROL4__(bswap32(*v73), v7);
        v75 = *(float *)&_blt_float[HIBYTE(v74)];
        if (v6 >= 1.0)
        {
          v76 = *(float *)&_blt_float[BYTE2(v74)];
          v77 = *(float *)&_blt_float[BYTE1(v74)];
          v78 = *(float *)&_blt_float[(v74 | v9)];
        }
        else
        {
          v75 = v6 * v75;
          v76 = v6 * *(float *)&_blt_float[BYTE2(v74)];
          v77 = v6 * *(float *)&_blt_float[BYTE1(v74)];
          v78 = v6 * *(float *)&_blt_float[(v74 | v9)];
        }
        if (v78 >= 1.0)
          goto LABEL_112;
        if (v78 > 0.0)
          break;
LABEL_113:
        v10 += 4;
        if (!--v71)
          goto LABEL_114;
      }
      v75 = v75 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v78));
      v76 = v76 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v78));
      v77 = v77 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v78));
      v78 = v78 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v78));
LABEL_112:
      *v10 = bswap32(LODWORD(v75));
      v10[1] = bswap32(LODWORD(v76));
      v10[2] = bswap32(LODWORD(v77));
      v10[3] = bswap32(LODWORD(v78));
      goto LABEL_113;
    }
    if (a5 >= 1)
    {
      result = v61;
      v63 = a5;
      do
      {
        v64 = *(_QWORD *)result;
        result += 16;
        v65 = (unsigned int *)&v62[v64];
        if (v17 < (unsigned int *)&v62[v64])
          v65 = v17;
        if (v8 > v65)
          v65 = v8;
        v66 = __ROL4__(bswap32(*v65), v7);
        v67 = *(float *)&_blt_float[HIBYTE(v66)];
        if (v6 >= 1.0)
        {
          v68 = *(float *)&_blt_float[BYTE2(v66)];
          v69 = *(float *)&_blt_float[BYTE1(v66)];
          v70 = *(float *)&_blt_float[(v66 | v9)];
        }
        else
        {
          v67 = v6 * v67;
          v68 = v6 * *(float *)&_blt_float[BYTE2(v66)];
          v69 = v6 * *(float *)&_blt_float[BYTE1(v66)];
          v70 = v6 * *(float *)&_blt_float[(v66 | v9)];
        }
        *v10 = bswap32(LODWORD(v67));
        v10[1] = bswap32(LODWORD(v68));
        v10[2] = bswap32(LODWORD(v69));
        v10[3] = bswap32(LODWORD(v70));
        v10 += 4;
        --v63;
      }
      while (v63);
    }
LABEL_114:
    v10 += 4 * v11;
    v16 += v15;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t RGBAF_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6;
  int v7;
  unsigned int *v8;
  char v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t result;
  char *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int v38;
  float v39;
  float v40;
  float v41;
  float v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned int *v53;
  unsigned int v54;
  unsigned int *v55;
  unsigned int v56;
  float v57;
  float v58;
  float v59;
  float v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int *v65;
  unsigned int v66;
  float v67;
  float v68;
  float v69;
  float v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  unsigned int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float v82;

  v6 = *((float *)a2 + 2);
  v7 = a2[1];
  v82 = *(float *)a2;
  v8 = *(unsigned int **)(a1 + 32);
  if (*(_QWORD *)(a1 + 40))
    v9 = 0;
  else
    v9 = -1;
  v10 = (unsigned int *)*((_QWORD *)a2 + 2);
  v11 = *((_QWORD *)a2 + 3) - a5;
  v13 = *((_QWORD *)a2 + 15);
  v12 = *((_QWORD *)a2 + 16);
  v14 = *((_QWORD *)a2 + 7);
  v15 = *((_QWORD *)a2 + 9);
  v16 = *((_QWORD *)a2 + 5) + v15 * a4;
  v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(_QWORD *)(a1 + 176))
  {
    v81 = *((_QWORD *)a2 + 11);
    v80 = *((_QWORD *)a2 + 13);
    v79 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v80 - v16) | (v16 - v81)) < 0)
      {
        v20 = 0;
        v19 = 0;
      }
      else
      {
        v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9)
          v19 = -v13;
        else
          v19 = v13;
        v20 = weights_19497[v18] & 0xF;
      }
      result = v16 >> v14;
      v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v82) == 1)
      {
        if (a5 >= 1)
        {
          result = v20;
          v23 = (uint64_t *)v79;
          v24 = a5;
          do
          {
            v25 = *(v23 - 1);
            v26 = *v23;
            v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25])
              v28 = (unsigned int *)&v22[v25];
            else
              v28 = v17;
            if (v8 > v28)
              v28 = v8;
            v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30)
                v30 = v17;
              if (v8 > v30)
                v30 = v8;
              v31 = *v30;
              if (v20)
              {
                v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32)
                  v33 = v32;
                else
                  v33 = v17;
                if (v8 > v33)
                  v33 = v8;
                v34 = *v33;
                v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35)
                  v35 = v17;
                if (v8 > v35)
                  v35 = v8;
                v36 = BLEND8_19499[v20];
                v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                v31 = v31 - ((v36 & v31) >> v20) + ((v36 & *v35) >> v20);
              }
              v29 = v29
                  - ((BLEND8_19499[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_19499[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19])
                v37 = v17;
              if (v8 > v37)
                v37 = v8;
              v29 = v29 - ((BLEND8_19499[v20] & v29) >> v20) + ((BLEND8_19499[v20] & *v37) >> v20);
            }
            v38 = __ROL4__(v29, v7);
            v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              v40 = *(float *)&_blt_float[BYTE2(v38)];
              v41 = *(float *)&_blt_float[BYTE1(v38)];
              v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              v39 = v6 * v39;
              v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *v10 = bswap32(LODWORD(v39));
            v10[1] = bswap32(LODWORD(v40));
            v10[2] = bswap32(LODWORD(v41));
            v10[3] = bswap32(LODWORD(v42));
            v10 += 4;
            --v24;
          }
          while (v24);
        }
        goto LABEL_86;
      }
      if (a5 >= 1)
        break;
LABEL_86:
      v10 += 4 * v11;
      v16 += v15;
      if (!--a6)
        return result;
    }
    v43 = (uint64_t *)v79;
    result = a5;
    while (1)
    {
      v44 = *(v43 - 1);
      v45 = *v43;
      v46 = &v22[v44];
      if (v17 >= (unsigned int *)&v22[v44])
        v47 = (unsigned int *)&v22[v44];
      else
        v47 = v17;
      if (v8 > v47)
        v47 = v8;
      v48 = *v47;
      if ((v45 & 0xF) != 0)
      {
        v49 = (unsigned int *)&v46[v45 >> 4];
        if (v17 < v49)
          v49 = v17;
        if (v8 > v49)
          v49 = v8;
        v50 = *v49;
        if (v20)
        {
          if (v17 >= (unsigned int *)&v46[v19])
            v51 = (unsigned int *)&v46[v19];
          else
            v51 = v17;
          if (v8 > v51)
            v51 = v8;
          v52 = *v51;
          v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
          if (v17 < v53)
            v53 = v17;
          if (v8 > v53)
            v53 = v8;
          v54 = BLEND8_19499[v20];
          v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
          v50 = v50 - ((v54 & v50) >> v20) + ((v54 & *v53) >> v20);
        }
        v48 = v48
            - ((BLEND8_19499[*v43 & 0xF] & v48) >> (*v43 & 0xF))
            + ((BLEND8_19499[*v43 & 0xF] & v50) >> (*v43 & 0xF));
      }
      else if (v20)
      {
        v55 = (unsigned int *)&v46[v19];
        if (v17 < (unsigned int *)&v46[v19])
          v55 = v17;
        if (v8 > v55)
          v55 = v8;
        v48 = v48 - ((BLEND8_19499[v20] & v48) >> v20) + ((BLEND8_19499[v20] & *v55) >> v20);
      }
      v56 = __ROL4__(v48, v7);
      v57 = *(float *)&_blt_float[HIBYTE(v56)];
      if (v6 >= 1.0)
      {
        v58 = *(float *)&_blt_float[BYTE2(v56)];
        v59 = *(float *)&_blt_float[BYTE1(v56)];
        v60 = *(float *)&_blt_float[(v56 | v9)];
      }
      else
      {
        v57 = v6 * v57;
        v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
        v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
        v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
      }
      if (v60 >= 1.0)
        goto LABEL_84;
      if (v60 > 0.0)
        break;
LABEL_85:
      v43 += 2;
      v10 += 4;
      if (!--result)
        goto LABEL_86;
    }
    v57 = v57 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v60));
    v58 = v58 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v60));
    v59 = v59 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v60));
    v60 = v60 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v60));
LABEL_84:
    *v10 = bswap32(LODWORD(v57));
    v10[1] = bswap32(LODWORD(v58));
    v10[2] = bswap32(LODWORD(v59));
    v10[3] = bswap32(LODWORD(v60));
    goto LABEL_85;
  }
  v61 = v12 + 16 * a3;
  result = 32;
  do
  {
    v62 = (char *)v8 + (v16 >> v14) * v13;
    if (LODWORD(v82) != 1)
    {
      result = v61;
      v71 = a5;
      if (a5 < 1)
        goto LABEL_114;
      while (1)
      {
        v72 = *(_QWORD *)result;
        result += 16;
        v73 = (unsigned int *)&v62[v72];
        if (v17 < (unsigned int *)&v62[v72])
          v73 = v17;
        if (v8 > v73)
          v73 = v8;
        v74 = __ROL4__(*v73, v7);
        v75 = *(float *)&_blt_float[HIBYTE(v74)];
        if (v6 >= 1.0)
        {
          v76 = *(float *)&_blt_float[BYTE2(v74)];
          v77 = *(float *)&_blt_float[BYTE1(v74)];
          v78 = *(float *)&_blt_float[(v74 | v9)];
        }
        else
        {
          v75 = v6 * v75;
          v76 = v6 * *(float *)&_blt_float[BYTE2(v74)];
          v77 = v6 * *(float *)&_blt_float[BYTE1(v74)];
          v78 = v6 * *(float *)&_blt_float[(v74 | v9)];
        }
        if (v78 >= 1.0)
          goto LABEL_112;
        if (v78 > 0.0)
          break;
LABEL_113:
        v10 += 4;
        if (!--v71)
          goto LABEL_114;
      }
      v75 = v75 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v78));
      v76 = v76 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v78));
      v77 = v77 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v78));
      v78 = v78 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v78));
LABEL_112:
      *v10 = bswap32(LODWORD(v75));
      v10[1] = bswap32(LODWORD(v76));
      v10[2] = bswap32(LODWORD(v77));
      v10[3] = bswap32(LODWORD(v78));
      goto LABEL_113;
    }
    if (a5 >= 1)
    {
      result = v61;
      v63 = a5;
      do
      {
        v64 = *(_QWORD *)result;
        result += 16;
        v65 = (unsigned int *)&v62[v64];
        if (v17 < (unsigned int *)&v62[v64])
          v65 = v17;
        if (v8 > v65)
          v65 = v8;
        v66 = __ROL4__(*v65, v7);
        v67 = *(float *)&_blt_float[HIBYTE(v66)];
        if (v6 >= 1.0)
        {
          v68 = *(float *)&_blt_float[BYTE2(v66)];
          v69 = *(float *)&_blt_float[BYTE1(v66)];
          v70 = *(float *)&_blt_float[(v66 | v9)];
        }
        else
        {
          v67 = v6 * v67;
          v68 = v6 * *(float *)&_blt_float[BYTE2(v66)];
          v69 = v6 * *(float *)&_blt_float[BYTE1(v66)];
          v70 = v6 * *(float *)&_blt_float[(v66 | v9)];
        }
        *v10 = bswap32(LODWORD(v67));
        v10[1] = bswap32(LODWORD(v68));
        v10[2] = bswap32(LODWORD(v69));
        v10[3] = bswap32(LODWORD(v70));
        v10 += 4;
        --v63;
      }
      while (v63);
    }
LABEL_114:
    v10 += 4 * v11;
    v16 += v15;
    --a6;
  }
  while (a6);
  return result;
}

void RGBAF_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  void *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int8x16_t *v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;
  unsigned int v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  float32x4_t v45;
  int32x2_t v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  float32x4_t *v52;
  unsigned __int8 *v53;
  unsigned int v54;
  int v55;
  _BYTE *v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  float *v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  float *v65;
  unint64_t v66;
  unint64_t v67;
  __int128 *v68;
  int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unsigned __int8 v72;
  unsigned __int8 *v73;
  int8x16_t *v74;
  int v75;
  int v76;
  unsigned int v77;
  int8x16_t v78;
  unsigned __int8 v79;
  unsigned __int8 v80;
  uint64_t v81;
  unsigned __int8 *v82;
  int v83;
  unsigned int v84;
  int8x8_t *v85;
  float v86;
  int8x16_t v87;
  float v88;
  float32x2_t *v89;
  float v90;
  unsigned int v91;
  float32x4_t v92;
  unsigned int v93;
  unsigned int v94;
  int8x8_t v95;
  int8x8_t *v96;
  unsigned __int8 v97;
  int v98;
  unsigned __int8 *v99;
  unsigned int v100;
  int8x16_t v101;
  float32x4_t v102;
  int v103;
  unsigned int v104;
  int8x16_t v105;
  float32x4_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  float32x4_t v110;
  float32x4_t v111;
  float *v112;
  int v113;
  unsigned int v114;
  unsigned int v115;
  float v116;
  float v117;
  float v118;
  unsigned int v119;
  unsigned int v120;
  int8x8_t v121;
  float v122;
  float *v123;
  int v124;
  unsigned int v125;
  int8x16_t v126;
  float32x4_t v127;
  float *v128;
  int v129;
  unsigned int v130;
  int8x16_t v131;
  float32x4_t v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  float v136;
  float v137;
  float32x4_t v138;
  float32x4_t v139;
  int v140;
  unsigned int v141;
  unsigned int v142;
  float32x4_t v143;
  float32x4_t v144;
  float *v145;
  int v146;
  unsigned int v147;
  unsigned int v148;
  float v149;
  float v150;
  float32x2_t v151;
  float v152;
  float32x2_t v153;
  float v154;
  int8x16_t v155;
  float *v156;
  int v157;
  unsigned int v158;
  unsigned int v159;
  float v160;
  float v161;
  float v162;
  int8x16_t v163;
  float v164;
  int v165;
  unsigned __int8 *v166;
  unsigned int v167;
  unsigned int v168;
  int8x16_t v169;
  float v170;
  double v171;
  double v172;
  double v173;
  __int32 v174;
  float32x2_t *v175;
  int v176;
  unsigned int v177;
  unsigned int v178;
  float v179;
  float32x2_t v180;
  int8x16_t v181;
  float v182;
  float v183;
  unsigned int v184;
  unsigned int v185;
  float32x2_t v186;
  int v192;
  unsigned int v193;
  unsigned int v194;
  int8x16_t v195;
  float v196;
  double v197;
  double v198;
  double v199;
  __int32 v200;
  int v201;
  unsigned int v202;
  unsigned int v203;
  int8x16_t v204;
  float v205;
  double v206;
  double v207;
  double v208;
  __int32 v209;
  int v210;
  unsigned int v211;
  unsigned int v212;
  int8x16_t v213;
  float v214;
  double v215;
  double v216;
  double v217;
  __int32 v218;
  int v219;
  unsigned int v220;
  unsigned int v221;
  int8x16_t v222;
  float v223;
  double v224;
  double v225;
  double v226;
  __int32 v227;
  int v228;
  unsigned int v229;
  unsigned int v230;
  int8x16_t v231;
  float v232;
  double v233;
  double v234;
  double v235;
  __int32 v236;
  int v237;
  unsigned int v238;
  unsigned int v239;
  int8x16_t v240;
  double v241;
  __int32 v242;
  int v243;
  unsigned int v244;
  unsigned int v245;
  int8x16_t v246;
  float v247;
  double v248;
  double v249;
  double v250;
  __int32 v251;
  int v252;
  unsigned int v253;
  unsigned int v254;
  float32x4_t v255;
  float v256;
  float v257;
  float32x2_t v258;
  float32x2_t v259;
  float32x2_t v260;
  float32x2_t v261;
  float32x2_t v262;
  float32x2_t v263;
  float32x4_t v264;
  float v265;
  float32x2_t *v266;
  int v267;
  unsigned int v268;
  unsigned int v269;
  float v270;
  float32x2_t v271;
  int8x16_t v272;
  float v273;
  float v274;
  unsigned int v275;
  unsigned int v276;
  float32x2_t v277;
  int v278;
  unsigned int v279;
  unsigned int v280;
  int8x16_t v281;
  float v282;
  double v283;
  __int32 v284;
  unsigned int v285;
  int v286;
  unsigned int v287;
  unsigned int v288;
  int8x16_t v289;
  float v290;
  double v291;
  __int32 v292;
  unsigned int v293;
  int v294;
  char *v295;
  int v296;
  unsigned __int8 *v297;
  unsigned int v298;
  unsigned int v299;
  int8x16_t v300;
  float v301;
  __int32 v302;
  unsigned int v303;
  int v304;
  unsigned int v305;
  unsigned int v306;
  int8x16_t v307;
  float v308;
  double v309;
  __int32 v310;
  unsigned int v311;
  int8x16_t v312;
  unsigned __int8 v313;
  uint64_t *v314;
  unsigned __int8 *v315;
  int v316;
  float v317;
  int8x16_t v318;
  float v319;
  float v320;
  unsigned int v321;
  float32x4_t v322;
  unsigned int v323;
  unsigned __int8 v324;
  char *v325;
  uint64_t v326;
  uint64_t v327;
  int v328;
  uint64_t v329;
  int v330;
  double v331;
  __int128 v332;
  double v333;
  double v334;
  double v335;
  uint64_t v336;
  unint64_t v337;
  uint64_t v338;
  void *v339;
  uint64_t v340;
  uint64_t v341;
  unsigned int v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  unint64_t v347;
  __n128 v348;
  int *v349;
  char *v350;
  int v351;
  uint64_t v352;
  uint64_t v353;

  v342 = a3;
  v353 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 4);
  v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF)
    return;
  v8 = *(int *)(a1 + 28);
  v9 = *(char **)(a1 + 40);
  v352 = *(_QWORD *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  v348 = a4;
  v349 = *(int **)(a1 + 136);
  v350 = v9;
  v344 = *(_QWORD *)(a2 + 96);
  v346 = *(_QWORD *)(a2 + 104);
  v11 = *(int *)(a1 + 12);
  v10 = *(int *)(a1 + 16);
  v351 = *(_DWORD *)(a1 + 8);
  v12 = *(int *)(a2 + 16);
  v13 = (v12 + 18) * v5;
  if (v13 > 65439)
  {
    v16 = (char *)malloc_type_calloc(1uLL, v13 + 96, 0xBBC8A413uLL);
    v15 = v16;
    v18 = v16;
    if (!v16)
      return;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1, a4);
    v15 = (char *)&v336 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v15, v14);
    v18 = 0;
  }
  v339 = v18;
  v19 = v8 >> 4;
  v20 = (unint64_t)(v15 + 15) & 0xFFFFFFFFFFFFFFF0;
  v21 = v20 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((_DWORD)v12)
    v22 = 16 * v5;
  else
    v22 = 0;
  v23 = v21 + v22;
  *(_QWORD *)(a2 + 144) = v20;
  *(_QWORD *)(a2 + 152) = v21 + v22;
  *(_QWORD *)(a2 + 160) = v21;
  v24 = (int8x16_t *)&v350[16 * v11 + 16 * v19 * v10];
  v337 = v8 >> 4;
  v338 = (int)v4;
  v347 = v19 - (int)v4;
  v25 = *(int *)(a1 + 104);
  v26 = *(_DWORD *)(a1 + 108);
  v27 = *(unsigned __int8 *)(a1 + 2);
  if (v27 == 6 || v27 == 1)
  {
    v28 = v344;
    v29 = v346;
    if (!v349)
      goto LABEL_426;
    v30 = 0;
    LODWORD(v31) = 0;
    v32 = *(int *)(a1 + 124);
    v33 = (unsigned __int8 *)v349 + v25 + (int)v32 * (uint64_t)v26;
    v34 = v338;
    v343 = v32 - v338;
LABEL_12:
    v35 = v342;
  }
  else
  {
    v29 = v346;
    if (v349)
    {
      shape_enum_clip_alloc((uint64_t)v16, v17, v349, 1, 1, 1, v25, v26, v4, v351);
      if (v325)
      {
        v295 = v325;
        v31 = 0;
        v326 = (int)((v12 * v5 + 15) & 0xFFFFFFF0);
        if (!(_DWORD)v12)
          v326 = 16 * v5;
        v34 = v338;
        v343 = -v338;
        v33 = (unsigned __int8 *)(v23 + v326 + 16);
        v28 = v344;
        goto LABEL_434;
      }
      goto LABEL_426;
    }
    v343 = 0;
    v30 = 0;
    v33 = 0;
    LODWORD(v31) = 0;
    v35 = v342;
    v34 = v338;
    v28 = v344;
  }
  v340 = -v34;
  v341 = (v4 - 1) + 1;
  v345 = v35;
  v36 = v30;
  while (2)
  {
    LODWORD(v349) = v31;
    v350 = v36;
    v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2, v28, v29, v4);
    v52 = *(float32x4_t **)(a2 + 160);
    v53 = *(unsigned __int8 **)(a2 + 144);
    v54 = *(_DWORD *)(a2 + 8);
    if (v54 == *(_DWORD *)(a2 + 12))
    {
      v46 = (int32x2_t)v348.n128_u64[0];
      if (v348.n128_f32[0] < 1.0)
      {
        v55 = v4;
        v56 = *(_BYTE **)(a2 + 144);
        do
        {
          if (*v56)
          {
            v45 = vmulq_n_f32(*v52, *(float *)v46.i32);
            *v52 = v45;
          }
          ++v56;
          ++v52;
          --v55;
        }
        while (v55);
        v52 += v340;
        v53 += v341 + v340;
      }
    }
    else
    {
      v57 = *(_QWORD *)(a2 + 152);
      v58 = HIWORD(v54) & 0x3F;
      v47 = v348.n128_f64[0];
      if (v58 == 16)
      {
        v60 = 0;
        v61 = &v52->f32[2];
        if (v348.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v60])
            {
              v63 = *(_QWORD *)(v57 + 8 * v60);
              *(v61 - 2) = *(float *)&_blt_float[v63 + 256] + *(float *)&_blt_float[BYTE1(v63) + 512];
              *(v61 - 1) = *(float *)&_blt_float[BYTE2(v63) + 256] + *(float *)&_blt_float[BYTE3(v63) | 0x200];
              *v61 = *(float *)&_blt_float[BYTE4(v63) + 256] + *(float *)&_blt_float[BYTE5(v63) + 512];
              v61[1] = *(float *)&_blt_float[BYTE6(v63) + 256] + *(float *)&_blt_float[HIBYTE(v63) + 512];
            }
            ++v60;
            v61 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v60);
        }
        else
        {
          do
          {
            if (v53[v60])
            {
              v62 = *(_QWORD *)(v57 + 8 * v60);
              *(v61 - 2) = *(float *)&v47
                         * (float)(*(float *)&_blt_float[v62 + 256]
                                 + *(float *)&_blt_float[BYTE1(v62) + 512]);
              *(v61 - 1) = *(float *)&v47
                         * (float)(*(float *)&_blt_float[BYTE2(v62) + 256] + *(float *)&_blt_float[BYTE3(v62) | 0x200]);
              *v61 = *(float *)&v47
                   * (float)(*(float *)&_blt_float[BYTE4(v62) + 256] + *(float *)&_blt_float[BYTE5(v62) + 512]);
              v61[1] = *(float *)&v47
                     * (float)(*(float *)&_blt_float[BYTE6(v62) + 256] + *(float *)&_blt_float[HIBYTE(v62) + 512]);
            }
            ++v60;
            v61 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v60);
        }
      }
      else if (v58 == 32)
      {
        v59 = 0;
        if (v348.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v59])
            {
              v45 = *(float32x4_t *)(v57 + 16 * v59);
              v52[v59] = v45;
            }
            ++v59;
          }
          while ((_DWORD)v4 != (_DWORD)v59);
        }
        else
        {
          do
          {
            if (v53[v59])
            {
              v45 = vmulq_n_f32(*(float32x4_t *)(v57 + 16 * v59), *(float *)&v47);
              v52[v59] = v45;
            }
            ++v59;
          }
          while ((_DWORD)v4 != (_DWORD)v59);
        }
      }
      else
      {
        v64 = 0;
        v65 = &v52->f32[2];
        if (v348.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v64])
            {
              v67 = *(unsigned int *)(v57 + 4 * v64);
              *(v65 - 2) = *(float *)((char *)_blt_float + ((v67 >> 22) & 0x3FC));
              *(v65 - 1) = *(float *)&_blt_float[BYTE2(v67)];
              *v65 = *(float *)&_blt_float[BYTE1(v67)];
              v65[1] = *(float *)&_blt_float[v67];
            }
            ++v64;
            v65 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v64);
        }
        else
        {
          do
          {
            if (v53[v64])
            {
              v66 = *(unsigned int *)(v57 + 4 * v64);
              *(v65 - 2) = *(float *)&v47 * *(float *)((char *)_blt_float + ((v66 >> 22) & 0x3FC));
              *(v65 - 1) = *(float *)&v47 * *(float *)&_blt_float[BYTE2(v66)];
              *v65 = *(float *)&v47 * *(float *)&_blt_float[BYTE1(v66)];
              v65[1] = *(float *)&v47 * *(float *)&_blt_float[v66];
            }
            ++v64;
            v65 += 4;
          }
          while ((_DWORD)v4 != (_DWORD)v64);
        }
      }
    }
    v68 = &xmmword_185005000;
    switch(v35)
    {
      case 0u:
        v69 = v4;
        v70 = v33;
        do
        {
          v71 = *v53;
          if (*v53)
          {
            if (v33)
              v71 = (*v70 * v71 + ((*v70 * v71) >> 8) + 1) >> 8;
            if ((_BYTE)v71)
            {
              if (v71 == 255)
              {
                v24->i64[0] = 0;
                v24->i64[1] = 0;
              }
              else
              {
                *v24 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)((float)v71 * -0.0039216) + 1.0));
              }
            }
          }
          ++v53;
          v70 += v33 != 0;
          ++v24;
          --v69;
        }
        while (v69);
        v33 = &v70[v343];
        goto LABEL_340;
      case 1u:
        v72 = *v53;
        v73 = v53 + 1;
        v74 = v24 - 1;
        v75 = v4;
        if (v33)
        {
          v76 = v351;
          do
          {
            if (v72)
            {
              v77 = ((unsigned __int16)(*v33 * v72 + ((*v33 * v72) >> 8) + 1) >> 8);
              if (v77)
              {
                if (v77 == 255)
                  v78 = *(int8x16_t *)v52;
                else
                  v78 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32((float32x4_t)vrev32q_s8(v74[1]), 1.0 - (float)((float)v77 * 0.0039216)), *v52, (float)v77 * 0.0039216);
                v74[1] = vrev32q_s8(v78);
              }
            }
            v79 = *v73++;
            v72 = v79;
            ++v52;
            ++v33;
            ++v74;
            --v75;
          }
          while (v75);
          goto LABEL_84;
        }
        v76 = v351;
        do
        {
          if (v72)
          {
            if (v72 == 255)
              v312 = *(int8x16_t *)v52;
            else
              v312 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32((float32x4_t)vrev32q_s8(v74[1]), 1.0 - (float)((float)v72 * 0.0039216)), *v52, (float)v72 * 0.0039216);
            v74[1] = vrev32q_s8(v312);
          }
          v313 = *v73++;
          v72 = v313;
          ++v52;
          ++v74;
          --v75;
        }
        while (v75);
        goto LABEL_421;
      case 2u:
        v80 = *v53;
        if (!v33)
        {
          v74 = v24 - 1;
          v314 = &v52->i64[1];
          v315 = v53 + 1;
          v316 = v4;
          v76 = v351;
          while (1)
          {
            if (v80)
            {
              if (v80 == 255)
              {
                v317 = *((float *)v314 + 1);
                if (v317 >= 1.0)
                {
                  v323 = bswap32(*(_DWORD *)v314);
                  *(int8x8_t *)v74[1].i8 = vrev32_s8((int8x8_t)*(v314 - 1));
                  v74[1].i32[2] = v323;
                  v74[1].i32[3] = bswap32(LODWORD(v317));
                  goto LABEL_420;
                }
                if (v317 > 0.0)
                {
                  v318 = (int8x16_t)vmlaq_n_f32(*(float32x4_t *)(v314 - 1), (float32x4_t)vrev32q_s8(v74[1]), 1.0 - v317);
LABEL_418:
                  v74[1] = vrev32q_s8(v318);
                }
              }
              else
              {
                v319 = (float)v80 * 0.0039216;
                v320 = v319 * *((float *)v314 + 1);
                if (v320 > 0.0)
                {
                  *(float *)&v321 = v319 * *(float *)v314;
                  *(float32x2_t *)v322.f32 = vmul_n_f32((float32x2_t)*(v314 - 1), v319);
                  v322.i64[1] = __PAIR64__(LODWORD(v320), v321);
                  v318 = (int8x16_t)vmlaq_n_f32(v322, (float32x4_t)vrev32q_s8(v74[1]), 1.0 - v320);
                  goto LABEL_418;
                }
              }
            }
LABEL_420:
            v324 = *v315++;
            v80 = v324;
            ++v74;
            v314 += 2;
            if (!--v316)
            {
LABEL_421:
              v33 = 0;
              goto LABEL_422;
            }
          }
        }
        v81 = 0;
        v82 = v53 + 1;
        v83 = v4;
        v76 = v351;
        do
        {
          if (v80)
          {
            v84 = ((unsigned __int16)(*v33 * v80 + ((*v33 * v80) >> 8) + 1) >> 8);
            if ((unsigned __int16)(*v33 * v80 + ((*v33 * v80) >> 8) + 1) >> 8)
            {
              if (v84 != 255)
              {
                v88 = (float)v84 * 0.0039216;
                v89 = (float32x2_t *)&v52[v81];
                v90 = v88 * v52[v81].f32[3];
                if (v90 <= 0.0)
                  goto LABEL_82;
                *(float *)&v91 = v88 * v89[1].f32[0];
                *(float32x2_t *)v92.f32 = vmul_n_f32(*v89, v88);
                v92.i64[1] = __PAIR64__(LODWORD(v90), v91);
                v87 = (int8x16_t)vmlaq_n_f32(v92, (float32x4_t)vrev32q_s8(v24[v81]), 1.0 - v90);
                goto LABEL_80;
              }
              v85 = (int8x8_t *)&v52[v81];
              v86 = v52[v81].f32[3];
              if (v86 < 1.0)
              {
                if (v86 <= 0.0)
                  goto LABEL_82;
                v87 = (int8x16_t)vmlaq_n_f32(v52[v81], (float32x4_t)vrev32q_s8(v24[v81]), 1.0 - v86);
LABEL_80:
                v24[v81] = vrev32q_s8(v87);
                goto LABEL_82;
              }
              v93 = bswap32(v85[1].u32[0]);
              v94 = bswap32(LODWORD(v86));
              v95 = vrev32_s8(*v85);
              v96 = (int8x8_t *)&v24[v81];
              *v96 = v95;
              v96[1].i32[0] = v93;
              v96[1].i32[1] = v94;
            }
          }
LABEL_82:
          v97 = *v82++;
          v80 = v97;
          ++v33;
          ++v81;
          --v83;
        }
        while (v83);
        v74 = &v24[v81 - 1];
LABEL_84:
        v33 += v343;
LABEL_422:
        v24 = &v74[v347 + 1];
LABEL_371:
        v294 = v76 - 1;
        if (!v294)
        {
          v30 = v350;
          goto LABEL_424;
        }
        v351 = v294;
        v36 = 0;
        v31 = ((_DWORD)v349 + 1);
        v28 += *(_QWORD *)(a2 + 128);
        v29 += *(_QWORD *)(a2 + 136);
        v295 = v350;
        if (!v350)
          continue;
        v34 = v338;
LABEL_434:
        v30 = v295;
        do
        {
          while (1)
          {
            v327 = *((unsigned int *)v33 - 4);
            v328 = v327 - v31;
            if ((int)v327 <= (int)v31)
              break;
            v351 -= v328;
            if (v351 < 1)
              goto LABEL_424;
            v28 += *(_QWORD *)(a2 + 128) * v328;
            v29 += *(_QWORD *)(a2 + 136) * v328;
            v24 += v337 * v328;
            v31 = v327;
          }
          if ((int)v31 < *((_DWORD *)v33 - 3) + (int)v327)
            goto LABEL_12;
          v329 = v31;
          v330 = shape_enum_clip_scan((uint64_t)v30, (_DWORD *)v33 - 4);
          v31 = v329;
        }
        while (v330);
LABEL_424:
        if (v30)
          free(v30);
LABEL_426:
        if (v339)
          free(v339);
        return;
      case 3u:
        v98 = v4;
        v99 = v33;
        do
        {
          v100 = *v53;
          if (*v53)
          {
            if (v33)
              v100 = (*v99 * v100 + ((*v99 * v100) >> 8) + 1) >> 8;
            if ((_BYTE)v100)
            {
              if (v100 == 255)
              {
                v101 = (int8x16_t)vmulq_n_f32(*v52, COERCE_FLOAT(bswap32(v24->u32[3])));
              }
              else
              {
                v102 = (float32x4_t)vrev32q_s8(*v24);
                v101 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v102, 1.0 - (float)((float)v100 * 0.0039216)), *v52, vmuls_lane_f32((float)v100 * 0.0039216, v102, 3));
              }
              *v24 = vrev32q_s8(v101);
            }
          }
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          --v98;
        }
        while (v98);
        goto LABEL_339;
      case 4u:
        v103 = v4;
        v99 = v33;
        do
        {
          v104 = *v53;
          if (*v53)
          {
            if (v33)
              v104 = (*v99 * v104 + ((*v99 * v104) >> 8) + 1) >> 8;
            if ((_BYTE)v104)
            {
              if (v104 == 255)
              {
                v105 = (int8x16_t)vmulq_n_f32(*v52, 1.0 - COERCE_FLOAT(bswap32(v24->u32[3])));
              }
              else
              {
                v106 = (float32x4_t)vrev32q_s8(*v24);
                v105 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v106, 1.0 - (float)((float)v104 * 0.0039216)), *v52, (float)((float)v104 * 0.0039216) * (float)(1.0 - v106.f32[3]));
              }
              *v24 = vrev32q_s8(v105);
            }
          }
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          --v103;
        }
        while (v103);
        goto LABEL_339;
      case 5u:
        v107 = v4;
        v99 = v33;
        while (1)
        {
          v108 = *v53;
          if (*v53)
          {
            if (!v33)
              goto LABEL_112;
            v109 = *v99 * v108 + ((*v99 * v108) >> 8) + 1;
            if (BYTE1(v109))
              break;
          }
LABEL_113:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v107)
            goto LABEL_339;
        }
        v108 = v109 >> 8;
LABEL_112:
        v110 = vmulq_n_f32(*v52, (float)v108 * 0.0039216);
        v111 = (float32x4_t)vrev32q_s8(*v24);
        *v24 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v111, 1.0 - v110.f32[3]), v110, v111, 3));
        goto LABEL_113;
      case 6u:
        v112 = &v52->f32[3];
        v113 = v4;
        v99 = v33;
        while (1)
        {
          v114 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v115 = *v99 * v114 + ((*v99 * v114) >> 8) + 1;
              if (!BYTE1(v115))
                goto LABEL_125;
              v114 = v115 >> 8;
            }
            v116 = COERCE_FLOAT(bswap32(v24->u32[3]));
            v117 = 1.0 - v116;
            if ((float)(1.0 - v116) >= 1.0)
            {
              v122 = (float)v114 * 0.0039216;
              v119 = bswap32(COERCE_UNSIGNED_INT(v122 * *(v112 - 1)));
              v120 = bswap32(COERCE_UNSIGNED_INT(v122 * *v112));
              v121 = (int8x8_t)vmul_n_f32(*(float32x2_t *)(v112 - 3), v122);
              goto LABEL_124;
            }
            if (v117 > 0.0)
            {
              v118 = (float)((float)v114 * 0.0039216) * v117;
              v119 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v24->u32[2])) + (float)(*(v112 - 1) * v118)));
              v120 = bswap32(COERCE_UNSIGNED_INT(v116 + (float)(*v112 * v118)));
              v121 = (int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), *(float32x2_t *)(v112 - 3), v118);
LABEL_124:
              *(int8x8_t *)v24->i8 = vrev32_s8(v121);
              v24->i32[2] = v119;
              v24->i32[3] = v120;
            }
          }
LABEL_125:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v112 += 4;
          if (!--v113)
            goto LABEL_339;
        }
      case 7u:
        v123 = &v52->f32[3];
        v124 = v4;
        v99 = v33;
        do
        {
          v125 = *v53;
          if (*v53)
          {
            if (v33)
              v125 = (*v99 * v125 + ((*v99 * v125) >> 8) + 1) >> 8;
            if ((_BYTE)v125)
            {
              if (v125 == 255)
              {
                v126 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), *v123);
              }
              else
              {
                v127 = (float32x4_t)vrev32q_s8(*v24);
                v126 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v127, 1.0 - (float)((float)v125 * 0.0039216)), v127, (float)((float)v125 * 0.0039216) * *v123);
              }
              *v24 = vrev32q_s8(v126);
            }
          }
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v123 += 4;
          --v124;
        }
        while (v124);
        goto LABEL_339;
      case 8u:
        v128 = &v52->f32[3];
        v129 = v4;
        v99 = v33;
        do
        {
          v130 = *v53;
          if (*v53)
          {
            if (v33)
              v130 = (*v99 * v130 + ((*v99 * v130) >> 8) + 1) >> 8;
            if ((_BYTE)v130)
            {
              if (v130 == 255)
              {
                v131 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), 1.0 - *v128);
              }
              else
              {
                v132 = (float32x4_t)vrev32q_s8(*v24);
                v131 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v132, 1.0 - (float)((float)v130 * 0.0039216)), v132, (float)((float)v130 * 0.0039216) * (float)(1.0 - *v128));
              }
              *v24 = vrev32q_s8(v131);
            }
          }
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v128 += 4;
          --v129;
        }
        while (v129);
        goto LABEL_339;
      case 9u:
        v133 = v4;
        v99 = v33;
        while (1)
        {
          v134 = *v53;
          if (*v53)
          {
            if (!v33)
              goto LABEL_154;
            v135 = *v99 * v134 + ((*v99 * v134) >> 8) + 1;
            if (BYTE1(v135))
              break;
          }
LABEL_155:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v133)
            goto LABEL_339;
        }
        v134 = v135 >> 8;
LABEL_154:
        v136 = (float)v134 * 0.0039216;
        v137 = 1.0 - v136;
        v138 = vmulq_n_f32(*v52, v136);
        v139 = (float32x4_t)vrev32q_s8(*v24);
        *v24 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v139, v137 + v138.f32[3]), v138, 1.0 - v139.f32[3]));
        goto LABEL_155;
      case 0xAu:
        v140 = v4;
        v99 = v33;
        while (1)
        {
          v141 = *v53;
          if (*v53)
          {
            if (!v33)
              goto LABEL_162;
            v142 = *v99 * v141 + ((*v99 * v141) >> 8) + 1;
            if (BYTE1(v142))
              break;
          }
LABEL_163:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v140)
            goto LABEL_339;
        }
        v141 = v142 >> 8;
LABEL_162:
        v143 = vmulq_n_f32(*v52, (float)v141 * 0.0039216);
        v144 = (float32x4_t)vrev32q_s8(*v24);
        *v24 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v144, 1.0 - v143.f32[3]), v143, 1.0 - v144.f32[3]));
        goto LABEL_163;
      case 0xBu:
        v145 = &v52->f32[3];
        v146 = v4;
        v99 = v33;
        while (1)
        {
          v147 = *v53;
          if (*v53)
          {
            if (!v33)
              goto LABEL_170;
            v148 = *v99 * v147 + ((*v99 * v147) >> 8) + 1;
            if (BYTE1(v148))
              break;
          }
LABEL_175:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v145 += 4;
          if (!--v146)
            goto LABEL_339;
        }
        v147 = v148 >> 8;
LABEL_170:
        v45.i32[0] = 1.0;
        v46.i32[0] = 1.0;
        if (v352)
          v46.i32[0] = bswap32(v24->u32[3]);
        v149 = (float)v147 * 0.0039216;
        v150 = v149 * *(v145 - 1);
        *(float *)&v49 = v149 * *v145;
        v151 = vsub_f32((float32x2_t)vdup_lane_s32(v46, 0), (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8));
        v152 = *(float *)&v49 + *(float *)v46.i32;
        v153 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v49, 0), vmul_n_f32(*(float32x2_t *)(v145 - 3), v149));
        v154 = (float)(*(float *)&v49 - v150) + (float)(*(float *)v46.i32 - COERCE_FLOAT(bswap32(v24->u32[2])));
        if (v152 <= 1.0)
          v45.f32[0] = v152;
        *(float32x2_t *)v155.i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v45.f32, 0), vadd_f32(v153, v151));
        v155.i64[1] = __PAIR64__(v45.u32[0], v45.f32[0] - v154);
        v45 = (float32x4_t)vrev32q_s8(v155);
        *v24 = (int8x16_t)v45;
        goto LABEL_175;
      case 0xCu:
        v156 = &v52->f32[3];
        v157 = v4;
        v99 = v33;
        while (1)
        {
          v158 = *v53;
          if (*v53)
          {
            if (!v33)
              goto LABEL_182;
            v159 = *v99 * v158 + ((*v99 * v158) >> 8) + 1;
            if (BYTE1(v159))
              break;
          }
LABEL_185:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v156 += 4;
          if (!--v157)
            goto LABEL_339;
        }
        v158 = v159 >> 8;
LABEL_182:
        v160 = (float)v158 * 0.0039216;
        v161 = v160 * *(v156 - 1);
        v162 = (float)(v160 * *v156) + COERCE_FLOAT(bswap32(v24->u32[3]));
        *(float32x2_t *)v163.i8 = vadd_f32(vmul_n_f32(*(float32x2_t *)(v156 - 3), v160), (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8));
        v164 = v161 + COERCE_FLOAT(bswap32(v24->u32[2]));
        if (v162 > 1.0)
          v162 = 1.0;
        v163.i64[1] = __PAIR64__(LODWORD(v162), LODWORD(v164));
        *v24 = vrev32q_s8(v163);
        goto LABEL_185;
      case 0xDu:
        v346 = v29;
        v344 = v28;
        v165 = v4;
        v166 = v33;
        while (1)
        {
          v167 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v168 = *v166 * v167 + ((*v166 * v167) >> 8) + 1;
              if (!BYTE1(v168))
                goto LABEL_199;
              v167 = v168 >> 8;
            }
            v169 = (int8x16_t)vmulq_n_f32(*v52, (float)v167 * *((float *)v68 + 159));
            if (*(float *)&v169.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v170 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_198;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v170 = 1.0;
              }
              v171 = *(double *)v24->i64;
              v172 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v171) = HIDWORD(v172);
              *(_QWORD *)&v173 = vextq_s8(v169, v169, 4uLL).u64[0];
              *(float *)v169.i32 = PDAmultiplyPDA(*(float *)&v172, v171, v47, v48, v170, v172, v173, v51, *(float *)v169.i32, COERCE_DOUBLE(__PAIR64__(v169.u32[3], HIDWORD(v173))), *(float *)&v169.i32[3]);
              v68 = &xmmword_185005000;
              v169.i32[1] = v174;
              v169.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_198:
              *v24 = vrev32q_s8(v169);
            }
          }
LABEL_199:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v165)
            goto LABEL_368;
        }
      case 0xEu:
        v175 = (float32x2_t *)&v52->u32[2];
        v176 = v4;
        v99 = v33;
        while (1)
        {
          v177 = *v53;
          if (*v53)
          {
            if (!v33)
              goto LABEL_206;
            v178 = *v99 * v177 + ((*v99 * v177) >> 8) + 1;
            if (BYTE1(v178))
              break;
          }
LABEL_211:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v175 += 2;
          if (!--v176)
            goto LABEL_339;
        }
        v177 = v178 >> 8;
LABEL_206:
        v179 = (float)v177 * 0.0039216;
        v180 = vmul_n_f32(*v175, v179);
        if (v180.f32[1] > 0.0)
        {
          *(float32x2_t *)v181.i8 = vmul_n_f32(v175[-1], v179);
          v182 = 1.0;
          if (v352 && (v182 = COERCE_FLOAT(bswap32(v24->u32[3])), v182 <= 0.0))
          {
            v181.u64[1] = (unint64_t)v180;
            *v24 = vrev32q_s8(v181);
          }
          else
          {
            v183 = COERCE_FLOAT(bswap32(v24->u32[2]));
            *(float *)&v184 = vmlas_n_f32(v183, 1.0 - v183, v180.f32[0]);
            *(float *)&v185 = (float)(v180.f32[1] + v182) - (float)(v182 * v180.f32[1]);
            v186 = (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8);
            __asm { FMOV            V2.2S, #1.0 }
            *(int8x8_t *)v24->i8 = vrev32_s8((int8x8_t)vmla_f32(v186, vsub_f32(_D2, v186), *(float32x2_t *)v181.i8));
            v24->i32[2] = bswap32(v184);
            v24->i32[3] = bswap32(v185);
          }
        }
        goto LABEL_211;
      case 0xFu:
        v346 = v29;
        v344 = v28;
        v192 = v4;
        v166 = v33;
        while (1)
        {
          v193 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v194 = *v166 * v193 + ((*v166 * v193) >> 8) + 1;
              if (!BYTE1(v194))
                goto LABEL_225;
              v193 = v194 >> 8;
            }
            v195 = (int8x16_t)vmulq_n_f32(*v52, (float)v193 * *((float *)v68 + 159));
            if (*(float *)&v195.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v196 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_224;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v196 = 1.0;
              }
              v197 = *(double *)v24->i64;
              v198 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v197) = HIDWORD(v198);
              *(_QWORD *)&v199 = vextq_s8(v195, v195, 4uLL).u64[0];
              *(float *)v195.i32 = PDAoverlayPDA(*(float *)&v198, v197, v47, v48, v196, v198, v199, v51, *(float *)v195.i32, COERCE_DOUBLE(__PAIR64__(v195.u32[3], HIDWORD(v199))), *(float *)&v195.i32[3]);
              v68 = &xmmword_185005000;
              v195.i32[1] = v200;
              v195.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_224:
              *v24 = vrev32q_s8(v195);
            }
          }
LABEL_225:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v192)
            goto LABEL_368;
        }
      case 0x10u:
        v346 = v29;
        v344 = v28;
        v201 = v4;
        v166 = v33;
        while (1)
        {
          v202 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v203 = *v166 * v202 + ((*v166 * v202) >> 8) + 1;
              if (!BYTE1(v203))
                goto LABEL_239;
              v202 = v203 >> 8;
            }
            v204 = (int8x16_t)vmulq_n_f32(*v52, (float)v202 * *((float *)v68 + 159));
            if (*(float *)&v204.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v205 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_238;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v205 = 1.0;
              }
              v206 = *(double *)v24->i64;
              v207 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v206) = HIDWORD(v207);
              *(_QWORD *)&v208 = vextq_s8(v204, v204, 4uLL).u64[0];
              *(float *)v204.i32 = PDAdarkenPDA(*(float *)&v207, v206, v47, v48, v205, v207, v208, v51, *(float *)v204.i32, COERCE_DOUBLE(__PAIR64__(v204.u32[3], HIDWORD(v208))), *(float *)&v204.i32[3]);
              v68 = &xmmword_185005000;
              v204.i32[1] = v209;
              v204.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_238:
              *v24 = vrev32q_s8(v204);
            }
          }
LABEL_239:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v201)
            goto LABEL_368;
        }
      case 0x11u:
        v346 = v29;
        v344 = v28;
        v210 = v4;
        v166 = v33;
        while (1)
        {
          v211 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v212 = *v166 * v211 + ((*v166 * v211) >> 8) + 1;
              if (!BYTE1(v212))
                goto LABEL_253;
              v211 = v212 >> 8;
            }
            v213 = (int8x16_t)vmulq_n_f32(*v52, (float)v211 * *((float *)v68 + 159));
            if (*(float *)&v213.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v214 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_252;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v214 = 1.0;
              }
              v215 = *(double *)v24->i64;
              v216 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v215) = HIDWORD(v216);
              *(_QWORD *)&v217 = vextq_s8(v213, v213, 4uLL).u64[0];
              *(float *)v213.i32 = PDAlightenPDA(*(float *)&v216, v215, v47, v48, v214, v216, v217, v51, *(float *)v213.i32, COERCE_DOUBLE(__PAIR64__(v213.u32[3], HIDWORD(v217))), *(float *)&v213.i32[3]);
              v68 = &xmmword_185005000;
              v213.i32[1] = v218;
              v213.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_252:
              *v24 = vrev32q_s8(v213);
            }
          }
LABEL_253:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v210)
            goto LABEL_368;
        }
      case 0x12u:
        v346 = v29;
        v344 = v28;
        v219 = v4;
        v166 = v33;
        while (1)
        {
          v220 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v221 = *v166 * v220 + ((*v166 * v220) >> 8) + 1;
              if (!BYTE1(v221))
                goto LABEL_267;
              v220 = v221 >> 8;
            }
            v222 = (int8x16_t)vmulq_n_f32(*v52, (float)v220 * *((float *)v68 + 159));
            if (*(float *)&v222.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v223 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_266;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v223 = 1.0;
              }
              v224 = *(double *)v24->i64;
              v225 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v224) = HIDWORD(v225);
              *(_QWORD *)&v226 = vextq_s8(v222, v222, 4uLL).u64[0];
              *(float *)v222.i32 = PDAcolordodgePDA(*(float *)&v225, v224, v47, v48, v223, v225, v226, v51, *(float *)v222.i32, COERCE_DOUBLE(__PAIR64__(v222.u32[3], HIDWORD(v226))), *(float *)&v222.i32[3]);
              v68 = &xmmword_185005000;
              v222.i32[1] = v227;
              v222.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_266:
              *v24 = vrev32q_s8(v222);
            }
          }
LABEL_267:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v219)
            goto LABEL_368;
        }
      case 0x13u:
        v346 = v29;
        v344 = v28;
        v228 = v4;
        v166 = v33;
        while (1)
        {
          v229 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v230 = *v166 * v229 + ((*v166 * v229) >> 8) + 1;
              if (!BYTE1(v230))
                goto LABEL_281;
              v229 = v230 >> 8;
            }
            v231 = (int8x16_t)vmulq_n_f32(*v52, (float)v229 * *((float *)v68 + 159));
            if (*(float *)&v231.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v232 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_280;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v232 = 1.0;
              }
              v233 = *(double *)v24->i64;
              v234 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v233) = HIDWORD(v234);
              *(_QWORD *)&v235 = vextq_s8(v231, v231, 4uLL).u64[0];
              *(float *)v231.i32 = PDAcolorburnPDA(*(float *)&v234, v233, v47, v48, v232, v234, v235, v51, *(float *)v231.i32, COERCE_DOUBLE(__PAIR64__(v231.u32[3], HIDWORD(v235))), *(float *)&v231.i32[3]);
              v68 = &xmmword_185005000;
              v231.i32[1] = v236;
              v231.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_280:
              *v24 = vrev32q_s8(v231);
            }
          }
LABEL_281:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v228)
            goto LABEL_368;
        }
      case 0x14u:
        v346 = v29;
        v344 = v28;
        v237 = v4;
        v166 = v33;
        while (1)
        {
          v238 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v239 = *v166 * v238 + ((*v166 * v238) >> 8) + 1;
              if (!BYTE1(v239))
                goto LABEL_295;
              v238 = v239 >> 8;
            }
            v240 = (int8x16_t)vmulq_n_f32(*v52, (float)v238 * *((float *)v68 + 159));
            if (*(float *)&v240.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                LODWORD(v49) = LODWORD(v48);
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_294;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                LODWORD(v49) = 1.0;
              }
              v241 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              DWORD2(v332) = v240.i32[3];
              *(_QWORD *)&v332 = vextq_s8(v240, v240, 4uLL).u64[0];
              *(float *)v240.i32 = PDAsoftlightPDA(*(float *)&v241, *((float *)&v241 + 1), v47, *(int32x2_t *)&v48, v49, v241, *(double *)&v332, v51, v37, v38, v39, v40, v41, v42, v43, v44, *(float *)v240.i32, v332, *(uint64_t *)((char *)&v332 + 4),
                                     *(float *)&v240.i32[3]);
              v68 = &xmmword_185005000;
              v240.i32[1] = v242;
              v240.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_294:
              *v24 = vrev32q_s8(v240);
            }
          }
LABEL_295:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v237)
            goto LABEL_368;
        }
      case 0x15u:
        v346 = v29;
        v344 = v28;
        v243 = v4;
        v166 = v33;
        while (1)
        {
          v244 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v245 = *v166 * v244 + ((*v166 * v244) >> 8) + 1;
              if (!BYTE1(v245))
                goto LABEL_309;
              v244 = v245 >> 8;
            }
            v246 = (int8x16_t)vmulq_n_f32(*v52, (float)v244 * *((float *)v68 + 159));
            if (*(float *)&v246.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v247 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_308;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v247 = 1.0;
              }
              v248 = *(double *)v24->i64;
              v249 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v248) = HIDWORD(v249);
              *(_QWORD *)&v250 = vextq_s8(v246, v246, 4uLL).u64[0];
              *(float *)v246.i32 = PDAhardlightPDA(*(float *)&v249, v248, v47, v48, v247, v249, v250, v51, *(float *)v246.i32, COERCE_DOUBLE(__PAIR64__(v246.u32[3], HIDWORD(v250))), *(float *)&v246.i32[3]);
              v68 = &xmmword_185005000;
              v246.i32[1] = v251;
              v246.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_308:
              *v24 = vrev32q_s8(v246);
            }
          }
LABEL_309:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v243)
            goto LABEL_368;
        }
      case 0x16u:
        v252 = v4;
        v99 = v33;
        while (1)
        {
          v253 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v254 = *v99 * v253 + ((*v99 * v253) >> 8) + 1;
              if (!BYTE1(v254))
                goto LABEL_325;
              v253 = v254 >> 8;
            }
            v255 = vmulq_n_f32(*v52, (float)v253 * 0.0039216);
            if (v255.f32[3] > 0.0)
            {
              if (v352)
              {
                v256 = COERCE_FLOAT(bswap32(v24->u32[3]));
                if (v256 <= 0.0)
                {
LABEL_324:
                  *v24 = vrev32q_s8((int8x16_t)v255);
                  goto LABEL_325;
                }
              }
              else
              {
                v256 = 1.0;
              }
              v257 = COERCE_FLOAT(bswap32(v24->u32[2]));
              v258 = (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8);
              v259 = vadd_f32(*(float32x2_t *)v255.f32, v258);
              v260 = vmul_laneq_f32(v258, v255, 3);
              v261 = vmul_n_f32(*(float32x2_t *)v255.f32, v256);
              v262 = vsub_f32(v259, v260);
              v263 = vsub_f32(v260, v261);
              v255.f32[0] = vmuls_lane_f32(v256, v255, 2);
              *(float32x2_t *)v264.f32 = vadd_f32(vsub_f32(v262, v261), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v263), (int8x8_t)vneg_f32(v263), (int8x8_t)v263));
              v265 = (float)(v255.f32[3] * v257) - v255.f32[0];
              v255.f32[0] = (float)((float)(v255.f32[2] + v257) - (float)(v255.f32[3] * v257)) - v255.f32[0];
              if (v265 < 0.0)
                v265 = -v265;
              v264.i64[1] = __PAIR64__((float)(v256 + v255.f32[3]) - (float)(v256 * v255.f32[3]), v255.f32[0] + v265);
              v255 = v264;
              goto LABEL_324;
            }
          }
LABEL_325:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v252)
            goto LABEL_339;
        }
      case 0x17u:
        v266 = (float32x2_t *)&v52->u32[2];
        v267 = v4;
        v99 = v33;
        while (1)
        {
          v268 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v269 = *v99 * v268 + ((*v99 * v268) >> 8) + 1;
              if (!BYTE1(v269))
                goto LABEL_338;
              v268 = v269 >> 8;
            }
            v270 = (float)v268 * 0.0039216;
            v271 = vmul_n_f32(*v266, v270);
            if (v271.f32[1] > 0.0)
            {
              *(float32x2_t *)v272.i8 = vmul_n_f32(v266[-1], v270);
              if (!v352)
              {
                v273 = 1.0;
LABEL_337:
                v274 = COERCE_FLOAT(bswap32(v24->u32[2]));
                v275 = bswap32(COERCE_UNSIGNED_INT((float)(v271.f32[0] + v274) + (float)((float)(v274 * v271.f32[0])
                                                                                       * -2.0)));
                *(float *)&v276 = (float)(v271.f32[1] + v273) - (float)(v273 * v271.f32[1]);
                v277 = (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8);
                *(int8x8_t *)v24->i8 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v272.i8, v277), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v272.i8, v277)));
                v24->i32[2] = v275;
                v24->i32[3] = bswap32(v276);
                goto LABEL_338;
              }
              v273 = COERCE_FLOAT(bswap32(v24->u32[3]));
              if (v273 > 0.0)
                goto LABEL_337;
              v272.u64[1] = (unint64_t)v271;
              *v24 = vrev32q_s8(v272);
            }
          }
LABEL_338:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v266 += 2;
          if (!--v267)
          {
LABEL_339:
            v33 = &v99[v343];
LABEL_340:
            v24 += v347;
            goto LABEL_370;
          }
        }
      case 0x18u:
        v346 = v29;
        v344 = v28;
        v278 = v4;
        v166 = v33;
        while (1)
        {
          v279 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v280 = *v166 * v279 + ((*v166 * v279) >> 8) + 1;
              if (!BYTE1(v280))
                goto LABEL_353;
              v279 = v280 >> 8;
            }
            v281 = (int8x16_t)vmulq_n_f32(*v52, (float)v279 * *((float *)v68 + 159));
            if (*(float *)&v281.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v282 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_352;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v282 = 1.0;
              }
              v283 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              *(_QWORD *)&v333 = vextq_s8(v281, v281, 4uLL).u64[0];
              *(float *)v281.i32 = PDAhuePDA(*(float *)&v283, *((float *)&v283 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v48, v282, v283, v333, v51, *(float *)v281.i32, *(float *)&v333, *((float *)&v333 + 1), *(float *)&v281.i32[3], *(float *)&v281.i32[3]);
              v68 = &xmmword_185005000;
              v281.i32[1] = v284;
              v281.i64[1] = __PAIR64__(LODWORD(v48), v285);
LABEL_352:
              *v24 = vrev32q_s8(v281);
            }
          }
LABEL_353:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v278)
            goto LABEL_368;
        }
      case 0x19u:
        v346 = v29;
        v344 = v28;
        v286 = v4;
        v166 = v33;
        while (1)
        {
          v287 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v288 = *v166 * v287 + ((*v166 * v287) >> 8) + 1;
              if (!BYTE1(v288))
                goto LABEL_367;
              v287 = v288 >> 8;
            }
            v289 = (int8x16_t)vmulq_n_f32(*v52, (float)v287 * *((float *)v68 + 159));
            if (*(float *)&v289.i32[3] > 0.0)
            {
              if (v352)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v290 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0)
                  goto LABEL_366;
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                v290 = 1.0;
              }
              v291 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              *(_QWORD *)&v334 = vextq_s8(v289, v289, 4uLL).u64[0];
              *(float *)v289.i32 = PDAsaturationPDA(*(float *)&v291, *((float *)&v291 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v48, v290, v291, v334, v51, *(float *)v289.i32, *(float *)&v334, *((float *)&v334 + 1), *(float *)&v289.i32[3], *(float *)&v289.i32[3]);
              v68 = &xmmword_185005000;
              v289.i32[1] = v292;
              v289.i64[1] = __PAIR64__(LODWORD(v48), v293);
LABEL_366:
              *v24 = vrev32q_s8(v289);
            }
          }
LABEL_367:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v286)
          {
LABEL_368:
            v33 = &v166[v343];
LABEL_369:
            v29 = v346;
            v24 += v347;
            v35 = v342;
            v28 = v344;
LABEL_370:
            v76 = v351;
            goto LABEL_371;
          }
        }
      case 0x1Au:
        v346 = v29;
        v344 = v28;
        v296 = v4;
        v297 = v33;
        while (1)
        {
          v298 = *v53;
          if (*v53)
          {
            if (v33)
            {
              v299 = *v297 * v298 + ((*v297 * v298) >> 8) + 1;
              if (!BYTE1(v299))
                goto LABEL_386;
              v298 = v299 >> 8;
            }
            v300 = (int8x16_t)vmulq_n_f32(*v52, (float)v298 * *((float *)v68 + 159));
            LODWORD(v48) = v300.i32[3];
            if (*(float *)&v300.i32[3] > 0.0)
            {
              if (v352)
              {
                v301 = COERCE_FLOAT(bswap32(v24->u32[3]));
                *(float *)&v50 = v301;
                if (v301 <= 0.0)
                  goto LABEL_385;
              }
              else
              {
                v301 = COERCE_FLOAT(bswap32(v24->u32[3]));
                LODWORD(v50) = 1.0;
              }
              v331 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              *(float *)v300.i32 = PDAluminosityPDA(*(float *)v300.i32, *(float *)&v300.i32[1], *(float *)&v300.i32[2], v48, *(float *)&v300.i32[3], v50, v331, v51, *(float *)&v331, *((float *)&v331 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v301, *(float *)&v50);
              v68 = &xmmword_185005000;
              v300.i32[1] = v302;
              v300.i64[1] = __PAIR64__(LODWORD(v48), v303);
LABEL_385:
              *v24 = vrev32q_s8(v300);
            }
          }
LABEL_386:
          ++v53;
          ++v52;
          v297 += v33 != 0;
          ++v24;
          if (!--v296)
            goto LABEL_401;
        }
      case 0x1Bu:
        v346 = v29;
        v344 = v28;
        v297 = v33;
        v304 = v4;
        break;
      default:
        goto LABEL_370;
    }
    break;
  }
  while (1)
  {
    v305 = *v53;
    if (*v53)
    {
      if (v33)
      {
        v306 = *v297 * v305 + ((*v297 * v305) >> 8) + 1;
        if (!BYTE1(v306))
          goto LABEL_400;
        v305 = v306 >> 8;
      }
      v307 = (int8x16_t)vmulq_n_f32(*v52, (float)v305 * *((float *)v68 + 159));
      if (*(float *)&v307.i32[3] > 0.0)
      {
        if (v352)
        {
          LODWORD(v48) = bswap32(v24->u32[3]);
          v308 = *(float *)&v48;
          if (*(float *)&v48 <= 0.0)
            goto LABEL_399;
        }
        else
        {
          LODWORD(v48) = bswap32(v24->u32[3]);
          v308 = 1.0;
        }
        v309 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
        *(_QWORD *)&v335 = vextq_s8(v307, v307, 4uLL).u64[0];
        *(float *)v307.i32 = PDAluminosityPDA(*(float *)&v309, *((float *)&v309 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v48, v308, v309, v335, v51, *(float *)v307.i32, *(float *)&v335, *((float *)&v335 + 1), *(float *)&v307.i32[3], *(float *)&v307.i32[3]);
        v68 = &xmmword_185005000;
        v307.i32[1] = v310;
        v307.i64[1] = __PAIR64__(LODWORD(v48), v311);
LABEL_399:
        *v24 = vrev32q_s8(v307);
      }
    }
LABEL_400:
    ++v53;
    ++v52;
    v297 += v33 != 0;
    ++v24;
    if (!--v304)
    {
LABEL_401:
      v33 = &v297[v343];
      goto LABEL_369;
    }
  }
}

uint64_t RGBAF_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  _BOOL8 v8;
  signed int v9;
  __n128 v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  _BYTE v18[36];
  char v19;
  _QWORD v20[483];

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E0C80C00];
  v7 = *(int **)v2;
  v8 = !*((_QWORD *)v3 + 12) && !*(_QWORD *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v9 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) != 0x3000000)
  {
    if (v13)
      goto LABEL_22;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(v5 + 16))
  {
    v12 = RGBAf_shade_radial_RGB;
  }
  else if (*(_QWORD *)(v5 + 24))
  {
    v12 = RGBAf_shade_conic_RGB;
  }
  else if (v16 < 2)
  {
    v12 = RGBAf_shade_axial_RGB;
  }
  else
  {
    v12 = RGBAf_shade_custom_RGB;
  }
  v13 = v12;
LABEL_22:
  v14 = *v7;
  v15 = v14;
  RGBAF_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17))
    free(v17);
  return 1;
}

char *CGSConvertARGB8888toMask(char *result, int a2, _BYTE *a3, int a4, int a5, int a6)
{
  _BYTE *v6;
  int v7;
  char *v8;
  unsigned int v9;
  char v10;
  char v11;
  char v12;
  char v13;
  unsigned int v14;
  char v15;

  if (a6 >= 1)
  {
    do
    {
      v6 = a3;
      v7 = a5;
      v8 = result;
      if (a5 >= 4)
      {
        do
        {
          v9 = v7;
          v10 = *v8;
          v11 = v8[4];
          v12 = v8[8];
          v13 = v8[12];
          v8 += 16;
          v7 -= 4;
          *v6 = v10;
          v6[1] = v11;
          v6[2] = v12;
          v6[3] = v13;
          v6 += 4;
        }
        while (v9 > 7);
      }
      if (v7 >= 1)
      {
        v14 = v7 + 1;
        do
        {
          v15 = *v8;
          v8 += 4;
          *v6++ = v15;
          --v14;
        }
        while (v14 > 1);
      }
      result += a2;
      a3 += a4;
    }
    while (a6-- > 1);
  }
  return result;
}

_BYTE *CGSConvertRGBA8888toMask(_BYTE *result, int a2, _BYTE *a3, int a4, int a5, int a6)
{
  _BYTE *v6;
  int v7;
  _BYTE *v8;
  char v9;
  char v10;
  char v11;
  char v12;
  BOOL v13;
  char *v14;
  unsigned int v15;
  char v16;

  if (a6 >= 1)
  {
    do
    {
      v6 = a3;
      v7 = a5;
      v8 = result;
      if (a5 >= 4)
      {
        do
        {
          v9 = v8[3];
          v10 = v8[7];
          v11 = v8[11];
          v12 = v8[15];
          v8 += 16;
          *v6 = v9;
          v6[1] = v10;
          v6[2] = v11;
          v6[3] = v12;
          v6 += 4;
          v13 = v7 > 7;
          v7 -= 4;
        }
        while (v13);
      }
      if (v7 >= 1)
      {
        v14 = v8 + 3;
        v15 = v7 + 1;
        do
        {
          v16 = *v14;
          v14 += 4;
          *v6++ = v16;
          --v15;
        }
        while (v15 > 1);
      }
      result += a2;
      a3 += a4;
      v13 = a6-- <= 1;
    }
    while (!v13);
  }
  return result;
}

uint16x4_t *CGSConvertBitsToMask(uint16x4_t *result, int a2, _BYTE *a3, int a4, int a5, int a6, int a7)
{
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int32x4_t v11;
  int16x8_t v12;
  int v13;
  __int32 v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint32x4_t v20;
  int v21;
  uint16x4_t v22;
  uint16x4_t v23;
  int16x8_t v24;
  int v25;
  unsigned int v26;

  if (a7 > 15)
  {
    if (a7 == 16)
    {
      v20.i64[0] = 0x1000000010;
      v20.i64[1] = 0x1000000010;
      do
      {
        if (a5 >= 4)
        {
          v21 = a5 >> 2;
          do
          {
            v22 = *result++;
            v23 = (uint16x4_t)vand_s8((int8x8_t)vshr_n_u16(v22, 2uLL), (int8x8_t)0xF800F800F800F8);
            v24 = (int16x8_t)vmull_u16((uint16x4_t)vmovn_s32((int32x4_t)vaddw_u16(v20, v23)), v23);
            *(uint16x4_t *)v24.i8 = vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v24), 8uLL);
            *(_DWORD *)a3 = vmovn_s16(v24).u32[0];
            a3 += 4;
            --v21;
          }
          while (v21);
        }
        if ((a5 & 3) != 0)
        {
          v25 = a5 & 3;
          do
          {
            v26 = result->u16[0];
            result = (uint16x4_t *)((char *)result + 2);
            *a3++ = (unsigned __int16)((((v26 >> 2) & 0xF8) + 16) * ((v26 >> 2) & 0xF8)) >> 8;
            --v25;
          }
          while (v25);
        }
        result = (uint16x4_t *)((char *)result + a2 - (uint64_t)(2 * a5));
        a3 += a4 - (uint64_t)a5;
        --a6;
      }
      while (a6);
    }
    else if (a7 == 32)
    {
      do
      {
        if (a5 >= 4)
        {
          v10 = a5 >> 2;
          do
          {
            v11 = *(int32x4_t *)result->i8;
            result += 2;
            v12.i64[1] = v11.i64[1];
            *(int16x4_t *)v12.i8 = vmovn_s32(v11);
            *(_DWORD *)a3 = vmovn_s16(v12).u32[0];
            a3 += 4;
            --v10;
          }
          while (v10);
        }
        if ((a5 & 3) != 0)
        {
          v13 = a5 & 3;
          do
          {
            v14 = result->i32[0];
            result = (uint16x4_t *)((char *)result + 4);
            *a3++ = v14;
            --v13;
          }
          while (v13);
        }
        result = (uint16x4_t *)((char *)result + a2 - (uint64_t)(4 * a5));
        a3 += a4 - (uint64_t)a5;
        --a6;
      }
      while (a6);
    }
  }
  else if (a7 == 1)
  {
    v15 = a5 + 3;
    do
    {
      if (v15 >= 8)
      {
        v16 = (int)v15 >> 3;
        do
        {
          v17 = result->u8[0];
          result = (uint16x4_t *)((char *)result + 1);
          v18 = _LUT[v17 & 0xF];
          *(_DWORD *)a3 = *(_DWORD *)((char *)_LUT + (((unint64_t)v17 >> 2) & 0x3C));
          *((_DWORD *)a3 + 1) = v18;
          a3 += 8;
          --v16;
        }
        while (v16);
      }
      if ((v15 & 4) != 0)
      {
        v19 = result->u8[0];
        result = (uint16x4_t *)((char *)result + 1);
        *(_DWORD *)a3 = *(_DWORD *)((char *)_LUT + (((unint64_t)v19 >> 2) & 0x3C));
        a3 += 4;
      }
      result = (uint16x4_t *)((char *)result + a2 - (uint64_t)((int)((v15 & 0xFFFFFFFC) + 7) >> 3));
      a3 += a4 - (v15 & 0xFFFFFFFFFFFFFFFCLL);
      --a6;
    }
    while (a6);
  }
  else if (a7 == 4)
  {
    do
    {
      if (a5 >= 2)
      {
        v7 = a5 >> 1;
        do
        {
          v8 = result->u8[0];
          result = (uint16x4_t *)((char *)result + 1);
          a3[1] = v8 & 0xF | (16 * v8);
          *a3 = v8 & 0xF0 | (v8 >> 4);
          a3 += 2;
          --v7;
        }
        while (v7);
      }
      if ((a5 & 1) != 0)
      {
        v9 = result->u8[0];
        result = (uint16x4_t *)((char *)result + 1);
        *a3++ = v9 & 0xF0 | (v9 >> 4);
      }
      result = (uint16x4_t *)((char *)result + a2 - (uint64_t)((a5 + 1) >> 1));
      a3 += a4 - (uint64_t)a5;
      --a6;
    }
    while (a6);
  }
  return result;
}

char *cg_function_type3_create(CGPDFDictionary *a1)
{
  char *result;
  uint64_t v3;
  const CGFloat *v4;
  uint64_t v5;
  uint64_t *v6;
  unint64_t v7;
  size_t v8;
  uint64_t Function;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  unint64_t v16;
  double *v17;
  double v18;
  double *v19;
  unint64_t v20;
  double v21;
  BOOL v22;
  void *v23;
  CGPDFArrayRef array;
  CGPDFObjectRef value;

  result = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0x10800402B99548FuLL);
  if (!result)
    return result;
  v3 = (uint64_t)result;
  v4 = (const CGFloat *)(result + 8);
  if (!CGPDFDictionaryGetNumbers(a1, "Domain", (uint64_t)(result + 8), (CGPDFArray *)2))
  {
LABEL_46:
    goto LABEL_47;
  }
  array = 0;
  value = 0;
  *(_QWORD *)v3 = 1;
  if (!CGPDFDictionaryGetArray(a1, "Functions", &array))
  {
    goto LABEL_47;
  }
  if (!array)
  {
    *(_QWORD *)(v3 + 40) = 0;
    goto LABEL_20;
  }
  v5 = *((_QWORD *)array + 2);
  *(_QWORD *)(v3 + 40) = v5;
  if (!v5)
  {
LABEL_20:
    goto LABEL_47;
  }
  v6 = (uint64_t *)malloc_type_calloc(1uLL, 8 * v5, 0x2004093837F09uLL);
  *(_QWORD *)(v3 + 48) = v6;
  if (!v6)
  {
LABEL_47:
    type3_release(v3);
    return 0;
  }
  v7 = *(_QWORD *)(v3 + 40);
  if (v7)
  {
    v8 = 0;
    while (CGPDFArrayGetObject(array, v8, &value))
    {
      if (value && *((_DWORD *)value + 2) == 8 && *((CGPDFDictionary **)value + 4) == a1)
        Function = 0;
      else
        Function = CGPDFFunctionCreateFunction();
      *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8 * v8) = Function;
      v6 = *(uint64_t **)(v3 + 48);
      if (!v6[v8])
        goto LABEL_47;
      ++v8;
      v7 = *(_QWORD *)(v3 + 40);
      if (v8 >= v7)
      {
        if (v7 >= 2 && *(double *)(v3 + 8) >= *(double *)(v3 + 16))
          goto LABEL_46;
        goto LABEL_23;
      }
    }
    goto LABEL_20;
  }
LABEL_23:
  v10 = *v6;
  if (*v6)
    v10 = *(_QWORD *)(v10 + 48);
  *(_QWORD *)(v3 + 24) = v10;
  if (v7 >= 2)
  {
    v11 = v6 + 1;
    v12 = v7 - 1;
    do
    {
      v13 = *v11;
      if (*v11)
        v13 = *(_QWORD *)(v13 + 48);
      if (v10 != v13)
        goto LABEL_20;
      ++v11;
    }
    while (--v12);
  }
  if (v7)
  {
    while (*v6 && *(_QWORD *)(*v6 + 32) == 1)
    {
      ++v6;
      if (!--v7)
        goto LABEL_35;
    }
    goto LABEL_20;
  }
LABEL_35:
  v14 = malloc_type_malloc(16 * v10, 0x100004000313F17uLL);
  *(_QWORD *)(v3 + 32) = v14;
  if (!v14)
    goto LABEL_47;
  if (!CGPDFDictionaryGetNumbers(a1, "Range", (uint64_t)v14, (CGPDFArray *)(2 * *(_QWORD *)(v3 + 24))))
  {
    free(*(void **)(v3 + 32));
    *(_QWORD *)(v3 + 32) = 0;
  }
  v15 = malloc_type_malloc(8 * *(_QWORD *)(v3 + 40) - 8, 0x100004000313F17uLL);
  *(_QWORD *)(v3 + 56) = v15;
  if (!v15)
    goto LABEL_47;
  if (!CGPDFDictionaryGetNumbers(a1, "Bounds", (uint64_t)v15, (CGPDFArray *)(*(_QWORD *)(v3 + 40) - 1)))
  {
    goto LABEL_47;
  }
  v16 = *(_QWORD *)(v3 + 40);
  if (v16 >= 2)
  {
    v17 = *(double **)(v3 + 56);
    v18 = *v17;
    if (*(double *)(v3 + 8) > *v17)
      goto LABEL_51;
    v19 = v17 + 1;
    v20 = v16 - 2;
    while (v20)
    {
      v21 = *v19++;
      --v20;
      v22 = v18 <= v21;
      v18 = v21;
      if (!v22)
        goto LABEL_51;
    }
    if (v17[v16 - 2] > *(double *)(v3 + 16))
    {
LABEL_51:
      goto LABEL_47;
    }
  }
  v23 = malloc_type_malloc(16 * v16, 0x100004000313F17uLL);
  *(_QWORD *)(v3 + 64) = v23;
  if (!v23)
    goto LABEL_47;
  if (!CGPDFDictionaryGetNumbers(a1, "Encode", (uint64_t)v23, (CGPDFArray *)(2 * *(_QWORD *)(v3 + 40))))
  {
    goto LABEL_47;
  }
  result = (char *)CGFunctionCreate((void *)v3, *(_QWORD *)v3, v4, *(_QWORD *)(v3 + 24), *(const CGFloat **)(v3 + 32), &type3_callbacks);
  if (!result)
  {
    pdf_error("unable to create Type 3 function.");
    goto LABEL_47;
  }
  return result;
}

void type3_release(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  unint64_t i;
  const void *v5;

  if (a1)
  {
    free(*(void **)(a1 + 32));
    free(*(void **)(a1 + 56));
    free(*(void **)(a1 + 64));
    v2 = *(void **)(a1 + 48);
    if (v2)
    {
      v3 = *(_QWORD *)(a1 + 40);
      if (v3)
      {
        for (i = 0; i < v3; ++i)
        {
          v5 = *(const void **)(*(_QWORD *)(a1 + 48) + 8 * i);
          if (v5)
          {
            CFRelease(v5);
            v3 = *(_QWORD *)(a1 + 40);
          }
        }
        v2 = *(void **)(a1 + 48);
      }
      free(v2);
    }
    free((void *)a1);
  }
}

uint64_t type3_evaluate(uint64_t result, double *a2, double *a3)
{
  double v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  double *v7;
  double v8;
  double v9;
  double v10;
  uint64_t v11;
  double *v12;
  double v13;
  double *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;

  if (result)
  {
    v3 = *a2;
    v4 = *(_QWORD *)(result + 40);
    if (v4 == 1)
    {
      v19 = **(double **)(result + 64)
          + (v3 - *(double *)(result + 8))
          * (*(double *)(*(_QWORD *)(result + 64) + 8) - **(double **)(result + 64))
          / (*(double *)(result + 16) - *(double *)(result + 8));
      v5 = *(uint64_t **)(result + 48);
    }
    else
    {
      v6 = 0;
      v7 = *(double **)(result + 56);
      while (1)
      {
        v8 = v7[v6];
        if (v3 < v8)
          break;
        if (v4 - 1 == ++v6)
        {
          v9 = v7[v4 - 2];
          v10 = *(double *)(result + 16);
          v11 = *(_QWORD *)(result + 64);
          if (v9 == v10)
            v19 = *(double *)(v11 + 16 * v4 - 16);
          else
            v19 = *(double *)(v11 + 16 * v4 - 16)
                + (v3 - v9) * (*(double *)(v11 + 16 * v4 - 8) - *(double *)(v11 + 16 * v4 - 16)) / (v10 - v9);
          v6 = v4 - 1;
          goto LABEL_15;
        }
      }
      v12 = *(double **)(result + 64);
      if (v6)
      {
        v13 = v7[v6 - 1];
        v14 = &v12[2 * v6];
        v15 = *v14;
        v16 = (v3 - v13) * (v14[1] - *v14);
        v17 = v8 - v13;
      }
      else
      {
        v18 = *(double *)(result + 8);
        v15 = *v12;
        v16 = (v3 - v18) * (v12[1] - *v12);
        v17 = *v7 - v18;
      }
      v19 = v15 + v16 / v17;
LABEL_15:
      v5 = (uint64_t *)(*(_QWORD *)(result + 48) + 8 * v6);
    }
    return CGFunctionEvaluate(*v5, (char *)&v19, a3);
  }
  return result;
}

double *CGContainerCreateWithRect(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  double *result;

  if (_block_invoke_once_6280 != -1)
    dispatch_once(&_block_invoke_once_6280, &__block_literal_global_4_6281);
  result = (double *)CGTypeCreateInstance(CGContainerGetTypeID_container_type_id, 32, a7, a8, a9, a10, a11, a12);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

BOOL container_equal(uint64_t a1, uint64_t a2)
{
  return CGRectEqualToRect(*(CGRect *)(a1 + 16), *(CGRect *)(a2 + 16));
}

uint64_t container_hash()
{
  return 0;
}

uint64_t CGContainerGetTypeID()
{
  if (_block_invoke_once_6280 != -1)
    dispatch_once(&_block_invoke_once_6280, &__block_literal_global_4_6281);
  return CGContainerGetTypeID_container_type_id;
}

BOOL CGContainerGetRect(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  if (a1 && a2)
  {
    v2 = *(_OWORD *)(a1 + 32);
    *a2 = *(_OWORD *)(a1 + 16);
    a2[1] = v2;
  }
  return a1 != 0;
}

void FontDescriptor::FontDescriptor(FontDescriptor *this, const PDFFont *a2, int a3)
{
  int v6;
  _BYTE *font_info;
  _BYTE *v8;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = PDFXRefTableAddObject(*(_QWORD **)(**((_QWORD **)a2 + 1) + 464));
  if (a3)
    v6 = 32;
  else
    v6 = 4;
  *((_DWORD *)this + 4) = v6;
  font_info = get_font_info(*((_QWORD **)a2 + 2));
  if (font_info && font_info[48])
    *((_DWORD *)this + 4) |= 1u;
  v8 = get_font_info(*((_QWORD **)a2 + 2));
  if (v8)
  {
    if (v8[49])
      *((_DWORD *)this + 4) |= 0x40u;
  }
}

_BYTE *FontDescriptor::emit_definition(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _BYTE v86[32];
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;

  v11 = **(_QWORD **)(*a1 + 8);
  PDFDocumentBeginObject(v11, a1[1], a3, a4, a5, a6, a7, a8);
  PDFDocumentPrintf(v11, (uint64_t)"<<", v12, v13, v14, v15, v16, v17, v83);
  PDFDocumentPrintf(v11, (uint64_t)"/Type /FontDescriptor", v18, v19, v20, v21, v22, v23, v84);
  if (*(char *)(a2 + 23) >= 0)
    v30 = a2;
  else
    v30 = *(_QWORD *)a2;
  PDFDocumentPrintf(v11, (uint64_t)"/FontName /%N", v24, v25, v26, v27, v28, v29, v30);
  PDFDocumentPrintf(v11, (uint64_t)"/Flags %d", v31, v32, v33, v34, v35, v36, *((unsigned int *)a1 + 4));
  if (CGFontGetDescriptor(*(_QWORD **)(*a1 + 16), (uint64_t)v86))
  {
    PDFDocumentPrintf(v11, (uint64_t)"/FontBBox %r", v37, v38, v39, v40, v41, v42, (uint64_t)v86);
    PDFDocumentPrintf(v11, (uint64_t)"/ItalicAngle %f", v44, v45, v46, v47, v48, v49, v90);
    PDFDocumentPrintf(v11, (uint64_t)"/Ascent %f", v50, v51, v52, v53, v54, v55, v87);
    PDFDocumentPrintf(v11, (uint64_t)"/Descent %f", v56, v57, v58, v59, v60, v61, v88);
    PDFDocumentPrintf(v11, (uint64_t)"/CapHeight %f", v62, v63, v64, v65, v66, v67, v89);
    PDFDocumentPrintf(v11, (uint64_t)"/StemV %f", v68, v69, v70, v71, v72, v73, v91);
    if (*(double *)&v96 != 0.0)
      PDFDocumentPrintf(v11, (uint64_t)"/Leading %f", v37, v38, v39, v40, v41, v42, v96);
    if (*(double *)&v97 != 0.0)
      PDFDocumentPrintf(v11, (uint64_t)"/XHeight %f", v37, v38, v39, v40, v41, v42, v97);
    if (*(double *)&v92 != 0.0)
      PDFDocumentPrintf(v11, (uint64_t)"/StemH %f", v37, v38, v39, v40, v41, v42, v92);
    if (*(double *)&v93 != 0.0)
      PDFDocumentPrintf(v11, (uint64_t)"/AvgWidth %f", v37, v38, v39, v40, v41, v42, v93);
    if (*(double *)&v94 != 0.0)
      PDFDocumentPrintf(v11, (uint64_t)"/MaxWidth %f", v37, v38, v39, v40, v41, v42, v94);
    v43.n128_u64[0] = v95;
    if (*(double *)&v95 != 0.0)
      PDFDocumentPrintf(v11, (uint64_t)"/MissingWidth %f", v37, v38, v39, v40, v41, v42, v95);
  }
  if (a3)
  {
    v74 = (*(uint64_t (**)(_QWORD, __n128))(*(_QWORD *)*a1 + 16))(*a1, v43) - 1;
    if (v74 <= 4)
      PDFDocumentPrintReference(v11, (uint64_t)off_1E16461F8[v74], a3, v38, v39, v40, v41, v42);
  }
  PDFDocumentPrintf(v11, (uint64_t)">>", v37, v38, v39, v40, v41, v42, v85);
  return PDFDocumentEndObject(v11, v75, v76, v77, v78, v79, v80, v81);
}

_QWORD *CGPDFDecryptorCreate(_QWORD *result, int a2, const void *a3, size_t a4)
{
  int v6;
  const void *v7;
  size_t v8;
  _QWORD *v9;
  _QWORD *RC4;
  void *v11;
  _QWORD *v12;

  if (result)
  {
    v6 = a2;
    v7 = result;
    if ((a2 & 0xFFFFFFFE) == 2)
      v8 = 4144;
    else
      v8 = 48;
    v9 = malloc_type_calloc(1uLL, v8, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (!v9)
      return 0;
    CFRetain(v7);
    *v9 = v7;
    if (!a3)
      v6 = 0;
    if ((v6 - 2) < 2)
    {
      v12 = pdf_aes_create((uint64_t)a3, a4);
      v9[2] = v12;
      if (!v12)
        goto LABEL_18;
      *((_BYTE *)v9 + 32) = 0;
      v9[5] = 0;
      v11 = decryptor_aes_refill;
    }
    else
    {
      if (v6)
      {
        if (v6 == 1)
        {
          RC4 = CGCryptorCreateRC4(a3, a4);
          v9[3] = RC4;
          if (RC4)
          {
            v11 = decryptor_rc4_refill;
            goto LABEL_16;
          }
        }
LABEL_18:
        decryptor_finalize((uint64_t)v9);
        return 0;
      }
      v11 = decryptor_identity_refill;
    }
LABEL_16:
    *((_DWORD *)v9 + 2) = v6;
    result = CGPDFSourceCreateInternal(0x1000uLL);
    if (result)
    {
      *((_BYTE *)result + 209) = 1;
      result[6] = decryptor_rewind;
      result[7] = v11;
      *((_OWORD *)result + 4) = xmmword_1E1646230;
      result[10] = v9;
      return result;
    }
    goto LABEL_18;
  }
  return result;
}

void decryptor_finalize(uint64_t a1)
{
  int v2;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 8);
    if ((v2 - 2) >= 2)
    {
      if (v2 == 1)
        CGCryptorRelease(*(_QWORD *)(a1 + 24));
    }
    else
    {
      pdf_aes_free(*(_QWORD **)(a1 + 16));
    }
    if (*(_QWORD *)a1)
      CFRelease(*(CFTypeRef *)a1);
    free((void *)a1);
  }
}

size_t decryptor_aes_refill(uint64_t a1, char *dataOut, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  BOOL v24;
  size_t v25;
  __int128 __dst;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a3 <= 0xFFF)
    _CGHandleAssert("decryptor_aes_refill", 160, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Security/CGPDFDecryptor.c", "buffer_size >= AES_BUFFER_SIZE", "buffer size (%lu) too big", a6, a7, a8, a3);
  if (!*(_BYTE *)(a1 + 32))
  {
    v9 = *(_QWORD *)(a1 + 40);
    if (!v9)
    {
      if ((unint64_t)CGPDFSourceRead(*(_QWORD *)a1, (uint64_t)&__dst, 0x10uLL, a4, a5, a6, a7, a8) < 0x10)
      {
        v9 = 0;
        goto LABEL_13;
      }
      v11 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)(v11 + 40) = __dst;
      CCCryptorReset(*(CCCryptorRef *)(v11 + 56), (const void *)(v11 + 40));
      v9 = CGPDFSourceRead(*(_QWORD *)a1, a1 + 48, 0x1000uLL, v12, v13, v14, v15, v16);
      *(_QWORD *)(a1 + 40) = v9;
    }
    pdf_aes_process_buffer(*(_QWORD *)(a1 + 16), (const void *)(a1 + 48), dataOut, v9);
    v22 = CGPDFSourceRead(*(_QWORD *)a1, a1 + 48, 0x1000uLL, v17, v18, v19, v20, v21);
    *(_QWORD *)(a1 + 40) = v22;
    if (v22)
      return v9;
    if (v9)
    {
      v23 = dataOut[v9 - 1];
      v24 = v9 >= v23;
      v25 = v9 - v23;
      if (v24)
        v9 = v25;
      else
        pdf_error("invalid AES padding.");
    }
LABEL_13:
    *(_BYTE *)(a1 + 32) = 1;
    return v9;
  }
  return 0;
}

uint64_t decryptor_identity_refill(uint64_t *a1, uint64_t a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CGPDFSourceRead(*a1, a2, a3, a4, a5, a6, a7, a8);
}

size_t decryptor_rc4_refill(uint64_t *a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10;

  v10 = CGPDFSourceRead(*a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10)
    CGCryptorProcessBytes(a1[3], a2, v10, a2, v10, 0);
  return v10;
}

uint64_t decryptor_rewind(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  result = CGPDFSourceRewind(*(_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
  v17 = *(_DWORD *)(a1 + 8);
  if ((v17 - 2) >= 2)
  {
    if (v17 == 1)
      return CGCryptorReset(*(CCCryptorRef **)(a1 + 24), v10, v11, v12, v13, v14, v15, v16);
  }
  else
  {
    result = pdf_aes_reset(*(_QWORD **)(a1 + 16));
    *(_BYTE *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t bits_per_component_type(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char vars0;

  v8 = a1 - 1;
  if ((a1 - 1) >= 5 || ((0x1Bu >> v8) & 1) == 0)
    _CGHandleAssert("bits_per_component_type", 66, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", a6, a7, a8, vars0);
  return qword_184F7D668[v8];
}

void upscale_provider_release_info(uint64_t a1)
{
  vImageConverter *v2;
  void *v3;

  if (!*(_BYTE *)(a1 + 8))
    CGDataProviderUnlock(*(_QWORD *)a1);
  CGDataProviderRelease(*(CGDataProviderRef *)a1);
  v2 = *(vImageConverter **)(a1 + 136);
  if (v2)
    vImageConverter_Release(v2);
  v3 = *(void **)(a1 + 144);
  if (v3)
    free(v3);
  free((void *)a1);
}

unint64_t upscale_provider_get_bytes_at_position(uint64_t a1, _BYTE *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!*(_BYTE *)(a1 + 8))
    _CGHandleAssert("upscale_provider_get_bytes_at_position", 1196, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "info->src_provider_uses_random_access == true", "", a6, a7, a8, vars0);
  return upscale_provider_get_bytes_at_position_inner(a1, a2, a3, a4, 0, a6, a7, a8);
}

uint64_t upscale_provider_retain_data(uint64_t *a1)
{
  CGDataProviderRetainBytePtr(*a1);
  return CGDataProviderRetainData(*a1);
}

uint64_t upscale_provider_release_data(uint64_t *a1)
{
  CGDataProviderReleaseBytePtr(*a1);
  return CGDataProviderReleaseData(*a1);
}

uint64_t upscale_provider_get_bytes_per_row_count(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t upscale_provider_get_work_buffer_size(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

unint64_t upscale_provider_get_bytes_at_position_inner(uint64_t a1, _BYTE *a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  vImagePixelCount v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  size_t BytesAtPositionInternal;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  size_t v34;
  int v35;
  unint64_t v36;
  unsigned __int8 *v37;
  unint64_t v38;
  int v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unsigned int v44;
  int v45;
  unint64_t v46;
  int v47;
  int v48;
  int v49;
  vImagePixelCount v50;
  unsigned int v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unsigned int v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unsigned int v60;
  uint64_t i;
  unsigned int v62;
  int v63;
  BOOL v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  unsigned int v68;
  int v69;
  uint64_t j;
  unsigned int v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  unsigned int v76;
  int v77;
  uint64_t k;
  unint64_t v79;
  unsigned int v80;
  int v81;
  char v82;
  unsigned int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  uint64_t m;
  unsigned int v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  unsigned int v93;
  unsigned int v94;
  char v95;
  BOOL v96;
  vImagePixelCount v97;
  unsigned int v98;
  unsigned int v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unsigned int v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unsigned int v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unsigned int v111;
  uint64_t n;
  unsigned int v113;
  int v114;
  char v115;
  unsigned int v116;
  unint64_t v117;
  int v118;
  unsigned int v119;
  double v120;
  float v121;
  uint64_t v122;
  double v123;
  unsigned int v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  unsigned int v129;
  double v130;
  float v131;
  BOOL v132;
  int v133;
  vImagePixelCount v134;
  unsigned int v135;
  unsigned int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unsigned int v142;
  int v143;
  int v144;
  unint64_t v145;
  unint64_t v146;
  unsigned int v147;
  uint64_t v148;
  uint64_t v149;
  unsigned int v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  unsigned int v155;
  unsigned int v156;
  BOOL v157;
  vImagePixelCount v158;
  unsigned int v159;
  unint64_t v160;
  vImagePixelCount v161;
  unsigned int v162;
  BOOL v163;
  vImagePixelCount v164;
  unsigned int v165;
  unint64_t v166;
  vImagePixelCount v167;
  unsigned int v168;
  __int16 v169;
  vImagePixelCount v170;
  unsigned int v171;
  vImagePixelCount v172;
  unsigned int v173;
  vImagePixelCount v174;
  unsigned int v175;
  char v177;
  vImage_Buffer dest;
  vImage_Buffer src;

  if ((a3 & 0x8000000000000000) != 0)
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1103, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "pos >= 0", "position %lld", a6, a7, a8, a3);
  v10 = *(_QWORD *)(a1 + 40);
  if (v10 <= 7)
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1108, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "dst_pixel_size != 0", "zero pixel size", a6, a7, a8, v177);
  v17 = destination_position_to_source_position(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 96), a3, a7, a8);
  if (v17 >= 0x7FFFFFFF)
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1121, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_pos >= 0 && src_byte_pos < INT_MAX", "positions %lld", v14, v15, v16, v17);
  v18 = *(_QWORD *)(a1 + 80);
  v19 = 8 * a4 / v10;
  if (!a3)
    goto LABEL_8;
  v20 = *(_QWORD *)(a1 + 40);
  if (!*(_QWORD *)(a1 + 96))
  {
    v20 = 8 * a3 * v18 / v20;
    goto LABEL_10;
  }
  v21 = a3 % *(_QWORD *)(a1 + 48);
  if (!v21)
  {
LABEL_8:
    v22 = 0;
    goto LABEL_11;
  }
  LOBYTE(v20) = 8 * v21 / v20 * v18;
LABEL_10:
  v22 = v20 & 7;
LABEL_11:
  v23 = (v18 * v19 + 7) >> 3;
  if (v23 > *(_QWORD *)(a1 + 152))
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1135, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "bytes_to_read <= info->work_buffer_size", "%s: bytes_to_read %zd > work_buffer_size %zd", v14, v15, v16, (char)"upscale_provider_get_bytes_at_position_inner");
  v24 = *(_QWORD **)a1;
  bzero(*(void **)(a1 + 144), v23);
  v29 = *(char **)(a1 + 144);
  if (*(_BYTE *)(a1 + 8))
    BytesAtPositionInternal = CGDataProviderDirectGetBytesAtPositionInternal(v24, v29, v17, v23, v25, v26, v27, v28);
  else
    BytesAtPositionInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v24, (uint64_t)v29, v23);
  v34 = BytesAtPositionInternal;
  if (BytesAtPositionInternal != v23)
    v19 = 8 * BytesAtPositionInternal / *(_QWORD *)(a1 + 80);
  v35 = *(_DWORD *)(a1 + 32);
  v36 = *(_QWORD *)(a1 + 88);
  v37 = *(unsigned __int8 **)(a1 + 144);
  if (*(_BYTE *)(a1 + 9))
  {
    v38 = *(_QWORD *)(a1 + 80);
    v39 = *(_DWORD *)(a1 + 120);
    v40 = *(unsigned __int8 *)(a1 + 160);
    if (v35 != 4)
    {
      if (v35 != 2)
      {
        if (v35 != 1)
          _CGHandleAssert("expand_components_without_scaling", 1070, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", v31, v32, v33, v177);
        if (v39)
          _CGHandleAssert("expand_packed_to_8bit", 923, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
        if (v38 / v36 * v36 != v38)
          _CGHandleAssert("expand_packed_to_8bit", 926, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu bpc %zu bpp %zu", v31, v32, v33, v38 / v36);
        v41 = v38 / v36 * v19;
        if (v22)
        {
          LODWORD(v42) = 0;
          v43 = 0;
          do
          {
            if (!(_DWORD)v42)
            {
              v44 = *v37++;
              v43 = v44 | (v43 << 8);
              LODWORD(v42) = 8;
            }
            LODWORD(v42) = v42 - 1;
            --v22;
          }
          while (v22);
          if (!v41)
            goto LABEL_292;
        }
        else
        {
          v43 = 0;
          LODWORD(v42) = 0;
          if (!v41)
            goto LABEL_292;
        }
        for (i = 0; i != v41; ++i)
        {
          if (v36 <= 0x18)
          {
            v65 = 0;
            v66 = v42;
            v67 = v36;
          }
          else
          {
            if (v42 > 0x17)
            {
              v63 = v42;
            }
            else
            {
              do
              {
                v62 = *v37++;
                v43 = v62 | (v43 << 8);
                v63 = v42 + 8;
                v64 = v42 >= 0x10;
                LODWORD(v42) = v42 + 8;
              }
              while (!v64);
            }
            v66 = (v63 - 24);
            v65 = ((v43 >> (v63 - 24)) & 0xFFFFFF) << (v36 - 24);
            LODWORD(v42) = v66;
            v67 = v36 - 24;
          }
          if (v67 > v66)
          {
            do
            {
              v68 = *v37++;
              v43 = v68 | (v43 << 8);
              v42 = (v42 + 8);
            }
            while (v67 > v42);
          }
          LODWORD(v42) = v42 - v67;
          v69 = (v43 >> v42) & ~(-1 << v67) | v65;
          if (v40)
            v69 = (int)(*(double *)(a1 + 168)
                      + (double)v69
                      * ((*(double *)(a1 + 176) - *(double *)(a1 + 168))
                       / (double)((2 << (v36 - 1)) - 1))
                      + 0.5);
          a2[i] = v69;
        }
        goto LABEL_292;
      }
      if (v39)
        _CGHandleAssert("expand_packed_to_16bit_integer", 954, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
      if (v38 / v36 * v36 != v38)
        _CGHandleAssert("expand_packed_to_16bit_integer", 957, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  sbc %zu  bpp %zu", v31, v32, v33, v38 / v36);
      v57 = v38 / v36 * v19;
      if (v22)
      {
        LODWORD(v58) = 0;
        v59 = 0;
        do
        {
          if (!(_DWORD)v58)
          {
            v60 = *v37++;
            v59 = v60 | (v59 << 8);
            LODWORD(v58) = 8;
          }
          LODWORD(v58) = v58 - 1;
          --v22;
        }
        while (v22);
        if (!v57)
          goto LABEL_292;
      }
      else
      {
        v59 = 0;
        LODWORD(v58) = 0;
        if (!v57)
          goto LABEL_292;
      }
      for (j = 0; j != v57; ++j)
      {
        if (v36 <= 0x18)
        {
          v73 = 0;
          v74 = v58;
          v75 = v36;
        }
        else
        {
          if (v58 > 0x17)
          {
            v72 = v58;
          }
          else
          {
            do
            {
              v71 = *v37++;
              v59 = v71 | (v59 << 8);
              v72 = v58 + 8;
              v64 = v58 >= 0x10;
              LODWORD(v58) = v58 + 8;
            }
            while (!v64);
          }
          v74 = (v72 - 24);
          v73 = ((v59 >> (v72 - 24)) & 0xFFFFFF) << (v36 - 24);
          LODWORD(v58) = v74;
          v75 = v36 - 24;
        }
        if (v75 > v74)
        {
          do
          {
            v76 = *v37++;
            v59 = v76 | (v59 << 8);
            v58 = (v58 + 8);
          }
          while (v75 > v58);
        }
        LODWORD(v58) = v58 - v75;
        v77 = (v59 >> v58) & ~(-1 << v75) | v73;
        if (v40)
          v77 = (int)(*(double *)(a1 + 168)
                    + (double)(unsigned __int16)v77
                    * ((*(double *)(a1 + 176) - *(double *)(a1 + 168))
                     / (double)((2 << (v36 - 1)) - 1))
                    + 0.5);
        *(_WORD *)&a2[2 * j] = v77;
      }
      goto LABEL_292;
    }
    if (v39)
      _CGHandleAssert("expand_components_without_scaling", 1058, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
    if (v36 - 33 <= 0xFFFFFFFFFFFFFFEFLL)
      _CGHandleAssert("expand_packed_to_32bit", 986, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 16 && src_bits_per_component < 33", "bpc %zu", v31, v32, v33, *(_QWORD *)(a1 + 88));
    if (v38 / v36 * v36 != v38)
      _CGHandleAssert("expand_packed_to_32bit", 989, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  sbc %zu  bpp %zu", v31, v32, v33, v38 / v36);
    v53 = v38 / v36 * v19;
    if (v22)
    {
      LODWORD(v54) = 0;
      v55 = 0;
      do
      {
        if (!(_DWORD)v54)
        {
          v56 = *v37++;
          v55 = v56 | (v55 << 8);
          LODWORD(v54) = 8;
        }
        LODWORD(v54) = v54 - 1;
        --v22;
      }
      while (v22);
    }
    else
    {
      v55 = 0;
      LODWORD(v54) = 0;
    }
    if (v36 == 32 && *(_DWORD *)(a1 + 124) == 0x2000)
    {
      if (v53)
      {
        for (k = 0; k != v53; ++k)
        {
          v79 = v55;
          if (v54 > 0x17)
          {
            v81 = v54;
          }
          else
          {
            do
            {
              v80 = *v37++;
              v79 = v80 | (v79 << 8);
              v81 = v54 + 8;
              v64 = v54 >= 0x10;
              LODWORD(v54) = v54 + 8;
            }
            while (!v64);
          }
          v82 = v81 - 24;
          if ((v81 - 24) > 7)
          {
            v55 = v79;
            v84 = v81 - 24;
          }
          else
          {
            v83 = *v37++;
            v55 = v83 | (v79 << 8);
            v84 = v81 - 16;
          }
          v85 = (v79 >> v82) << 8;
          LODWORD(v54) = v84 - 8;
          v86 = bswap32((v55 >> (v84 - 8)) | v85);
          if (v40)
            v86 = (*(double *)(a1 + 168)
                               + 0.5
                               - (double)v86 * (*(double *)(a1 + 176) - *(double *)(a1 + 168)));
          *(float *)&a2[4 * k] = (float)v86;
        }
      }
    }
    else if (v53)
    {
      for (m = 0; m != v53; ++m)
      {
        if (v36 <= 0x18)
        {
          v90 = 0;
          v91 = v54;
          v92 = v36;
        }
        else
        {
          if (v54 > 0x17)
          {
            v89 = v54;
          }
          else
          {
            do
            {
              v88 = *v37++;
              v55 = v88 | (v55 << 8);
              v89 = v54 + 8;
              v64 = v54 >= 0x10;
              LODWORD(v54) = v54 + 8;
            }
            while (!v64);
          }
          v91 = (v89 - 24);
          v90 = ((v55 >> (v89 - 24)) & 0xFFFFFF) << (v36 - 24);
          LODWORD(v54) = v91;
          v92 = v36 - 24;
        }
        if (v92 > v91)
        {
          do
          {
            v93 = *v37++;
            v55 = v93 | (v55 << 8);
            v54 = (v54 + 8);
          }
          while (v92 > v54);
        }
        LODWORD(v54) = v54 - v92;
        v94 = (v55 >> v54) & ~(-1 << v92) | v90;
        if (v40)
          v94 = (*(double *)(a1 + 168)
                             + (double)v94
                             * ((*(double *)(a1 + 176) - *(double *)(a1 + 168))
                              / (double)((2 << (v36 - 1)) - 1))
                             + 0.5);
        *(float *)&a2[4 * m] = (float)v94;
      }
    }
  }
  else
  {
    v45 = v35 - 1;
    if ((v35 - 1) >= 5 || ((0x1Bu >> v45) & 1) == 0)
      _CGHandleAssert("bytes_per_component_type", 87, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", v31, v32, v33, v177);
    v46 = *(_QWORD *)(a1 + 80);
    v47 = *(_DWORD *)(a1 + 120);
    v48 = *(_DWORD *)(a1 + 124);
    v49 = *(_DWORD *)(a1 + 128);
    if (v36 <= 0xC && ((1 << v36) & 0x1016) != 0 && !v22)
    {
      upscale_using_vImage(a2, v37, *(_QWORD *)(a1 + 72) * v19, qword_184F7D690[v45] * *(_QWORD *)(a1 + 72) * v19, (v46 * v19 + 7) >> 3, *(vImageConverterRef *)(a1 + 136));
      goto LABEL_292;
    }
    switch(v45)
    {
      case 0:
        if (v36 - 8 <= 0xFFFFFFFFFFFFFFF8)
          _CGHandleAssert("upscale_to_8bit", 435, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 0 && src_bits_per_component < 8", "bpc = %zu", v31, v32, v33, *(_QWORD *)(a1 + 88));
        if (v36 != 5)
          goto LABEL_159;
        if (v47 == 0x10000)
        {
          if (v46 != 16)
            _CGHandleAssert("upscale_555_RGB_to_8bit", 339, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 16", "src bpp %lu", v31, v32, v33, *(_QWORD *)(a1 + 80));
          if ((v49 - 7) <= 0xFFFFFFFB)
            _CGHandleAssert("upscale_555_RGB_to_8bit", 344, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_alpha_info == kCGImageAlphaLast || src_alpha_info == kCGImageAlphaNoneSkipLast || src_alpha_info == kCGImageAlphaFirst || src_alpha_info == kCGImageAlphaNoneSkipFirst", "src alpha info %u", v31, v32, v33, *(_DWORD *)(a1 + 128));
          if (v48 && v48 != 4096 && v48 != 12288)
            _CGHandleAssert("upscale_555_RGB_to_8bit", 351, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_order == kCGImageByteOrderDefault || src_byte_order == kCGImageByteOrder16Little|| src_byte_order == kCGImageByteOrder16Big", "byte order = %u", v31, v32, v33, *(_DWORD *)(a1 + 124));
          v156 = v49 & 0xFFFFFFFD;
          v157 = (v49 & 0xFFFFFFFD) != 4;
          if (v48 == 4096 || (v49 & 0xFFFFFFFD) != 4)
          {
            v163 = v48 != 4096;
            if (v48 != 4096)
              v157 = 1;
            if (v157)
            {
              if (v48 == 4096 || v156 == 4)
              {
                if (!v19)
                  v163 = 1;
                if (!v163 && v156 != 4)
                {
                  v174 = v19;
                  do
                  {
                    v175 = *(unsigned __int16 *)v37;
                    v37 += 2;
                    *a2 = expand_5_to_8bpc_table[(unint64_t)v175 >> 11];
                    a2[1] = expand_5_to_8bpc_table[((unint64_t)v175 >> 6) & 0x1F];
                    a2[2] = expand_5_to_8bpc_table[((unint64_t)v175 >> 1) & 0x1F];
                    a2[3] = expand_1_to_8bpc_table[v175 & 1];
                    a2 += 4;
                    --v174;
                  }
                  while (v174);
                }
              }
              else if (v19)
              {
                v164 = v19;
                do
                {
                  v165 = *(unsigned __int16 *)v37;
                  v37 += 2;
                  v166 = bswap32(v165);
                  *a2 = expand_5_to_8bpc_table[(unint64_t)WORD1(v166) >> 11];
                  a2[1] = expand_5_to_8bpc_table[(v166 >> 22) & 0x1F];
                  a2[2] = expand_5_to_8bpc_table[(v166 >> 17) & 0x1F];
                  a2[3] = expand_1_to_8bpc_table[BYTE2(v166) & 1];
                  a2 += 4;
                  --v164;
                }
                while (v164);
              }
            }
            else if (v19)
            {
              v172 = v19;
              do
              {
                v173 = *(unsigned __int16 *)v37;
                v37 += 2;
                *a2 = expand_1_to_8bpc_table[(unint64_t)v173 >> 15];
                a2[1] = expand_5_to_8bpc_table[((unint64_t)v173 >> 10) & 0x1F];
                a2[2] = expand_5_to_8bpc_table[((unint64_t)v173 >> 5) & 0x1F];
                a2[3] = expand_5_to_8bpc_table[v173 & 0x1F];
                a2 += 4;
                --v172;
              }
              while (v172);
            }
          }
          else if (v19)
          {
            v158 = v19;
            do
            {
              v159 = *(unsigned __int16 *)v37;
              v37 += 2;
              v160 = bswap32(v159);
              *a2 = expand_1_to_8bpc_table[(unint64_t)WORD1(v160) >> 15];
              a2[1] = expand_5_to_8bpc_table[(v160 >> 26) & 0x1F];
              a2[2] = expand_5_to_8bpc_table[(v160 >> 21) & 0x1F];
              a2[3] = expand_5_to_8bpc_table[BYTE2(v160) & 0x1F];
              a2 += 4;
              --v158;
            }
            while (v158);
          }
        }
        else
        {
          if (v47 == 0x20000)
          {
            if (v46 != 16)
              _CGHandleAssert("upscale_565_RGB_to_8bit", 410, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 16", "src bpp %zu", v31, v32, v33, *(_QWORD *)(a1 + 80));
            if (v48)
            {
              if (v48 == 4096)
              {
                if (v19)
                {
                  v170 = v19;
                  do
                  {
                    v171 = *(unsigned __int16 *)v37;
                    v37 += 2;
                    *a2 = expand_5_to_8bpc_table[(unint64_t)v171 >> 11];
                    a2[1] = expand_6_to_8bpc_table[((unint64_t)v171 >> 5) & 0x3F];
                    a2[2] = expand_5_to_8bpc_table[v171 & 0x1F];
                    a2 += 3;
                    --v170;
                  }
                  while (v170);
                }
                break;
              }
              if (v48 != 12288)
                _CGHandleAssert("upscale_565_RGB_to_8bit", 413, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_order == kCGImageByteOrderDefault || src_byte_order == kCGImageByteOrder16Little|| src_byte_order == kCGImageByteOrder16Big", "src byte order %u", v31, v32, v33, *(_DWORD *)(a1 + 124));
            }
            if (v19)
            {
              v50 = v19;
              do
              {
                v51 = *(unsigned __int16 *)v37;
                v37 += 2;
                v52 = bswap32(v51);
                *a2 = expand_5_to_8bpc_table[(unint64_t)WORD1(v52) >> 11];
                a2[1] = expand_6_to_8bpc_table[(v52 >> 21) & 0x3F];
                a2[2] = expand_5_to_8bpc_table[BYTE2(v52) & 0x1F];
                a2 += 3;
                --v50;
              }
              while (v50);
            }
            break;
          }
LABEL_159:
          if (v47)
            _CGHandleAssert("upscale_packed_to_8bit", 203, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %d", v31, v32, v33, *(_DWORD *)(a1 + 120));
          if (v46 / v36 * v36 != v46)
            _CGHandleAssert("upscale_packed_to_8bit", 206, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %lu bpc %lu bpp %lu", v31, v32, v33, v46 / v36);
          v104 = v46 / v36 * v19;
          if (v22)
          {
            LODWORD(v105) = 0;
            v106 = 0;
            do
            {
              if (!(_DWORD)v105)
              {
                v107 = *v37++;
                v106 = v107 | (v106 << 8);
                LODWORD(v105) = 8;
              }
              LODWORD(v105) = v105 - 1;
              --v22;
            }
            while (v22);
          }
          else
          {
            v106 = 0;
            LODWORD(v105) = 0;
          }
          if (v104)
          {
            v140 = 0;
            v141 = (uint64_t)*(&off_1E1646240 + v36 - 1);
            do
            {
              if (v36 <= 0x18)
              {
                LOBYTE(v144) = 0;
                v145 = v105;
                v146 = v36;
              }
              else
              {
                if (v105 > 0x17)
                {
                  v143 = v105;
                }
                else
                {
                  do
                  {
                    v142 = *v37++;
                    v106 = v142 | (v106 << 8);
                    v143 = v105 + 8;
                    v64 = v105 >= 0x10;
                    LODWORD(v105) = v105 + 8;
                  }
                  while (!v64);
                }
                v145 = (v143 - 24);
                v144 = ((v106 >> (v143 - 24)) & 0xFFFFFF) << (v36 - 24);
                LODWORD(v105) = v145;
                v146 = v36 - 24;
              }
              if (v146 > v145)
              {
                do
                {
                  v147 = *v37++;
                  v106 = v147 | (v106 << 8);
                  v105 = (v105 + 8);
                }
                while (v146 > v105);
              }
              LODWORD(v105) = v105 - v146;
              a2[v140++] = *(_BYTE *)(v141 + ((v106 >> v105) & ~(-1 << v146) | v144));
            }
            while (v140 != v104);
          }
        }
        break;
      case 1:
        if (v36 - 16 <= 0xFFFFFFFFFFFFFFF8)
          _CGHandleAssert("upscale_to_16bit", 687, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 8 && src_bits_per_component < 16", "bpc %zu", v31, v32, v33, *(_QWORD *)(a1 + 88));
        if (v36 == 10 && v47 == 196608)
        {
          if (v46 != 32)
            _CGHandleAssert("upscale_101010_RGB_to_16bit", 621, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 32", "bpp %zu", v31, v32, v33, *(_QWORD *)(a1 + 80));
          v95 = v49 - 1;
          if ((v49 - 1) >= 6)
            _CGHandleAssert("upscale_101010_RGB_to_16bit", 628, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_alpha_info == kCGImageAlphaLast || src_alpha_info == kCGImageAlphaNoneSkipLast || src_alpha_info == kCGImageAlphaPremultipliedLast || src_alpha_info == kCGImageAlphaFirst || src_alpha_info == kCGImageAlphaNoneSkipFirst || src_alpha_info == kCGImageAlphaPremultipliedFirst", "alpha info = %u", v31, v32, v33, *(_DWORD *)(a1 + 128));
          if (v48 && v48 != 0x2000 && v48 != 0x4000)
            _CGHandleAssert("upscale_101010_RGB_to_16bit", 636, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_order == kCGImageByteOrderDefault || src_byte_order == kCGImageByteOrder32Little|| src_byte_order == kCGImageByteOrder32Big", "byte order %u", v31, v32, v33, *(_DWORD *)(a1 + 124));
          v96 = (v95 & 1) == 0;
          if (v48 == 0x2000 || (((_BYTE)v49 - 1) & 1) == 0)
          {
            v132 = v48 != 0x2000;
            if (v48 != 0x2000)
              v96 = 1;
            if (v96)
            {
              v133 = v95 & 1;
              if (v48 == 0x2000 || v133)
              {
                if (!v19)
                  v132 = 1;
                if (!v132 && !v133)
                {
                  v167 = v19;
                  do
                  {
                    v168 = *(_DWORD *)v37;
                    v37 += 4;
                    v169 = expand_2_to_16bpc_table[v168 & 3];
                    *(_WORD *)a2 = (0x400FC3F0FC3F10 * ((unint64_t)v168 >> 22) + 0x800000000000) >> 48;
                    *((_WORD *)a2 + 1) = (0x400FC3F0FC3F10 * (((unint64_t)v168 >> 12) & 0x3FF)
                                        + 0x800000000000) >> 48;
                    *((_WORD *)a2 + 2) = (0x400FC3F0FC3F10 * (((unint64_t)v168 >> 2) & 0x3FF) + 0x800000000000) >> 48;
                    *((_WORD *)a2 + 3) = v169;
                    a2 += 8;
                    --v167;
                  }
                  while (v167);
                }
              }
              else if (v19)
              {
                v134 = v19;
                do
                {
                  v135 = *(_DWORD *)v37;
                  v37 += 4;
                  v136 = bswap32(v135);
                  v137 = v136 >> 22;
                  v138 = (v136 >> 12) & 0x3FF;
                  v139 = (v136 >> 2) & 0x3FF;
                  LOWORD(v136) = expand_2_to_16bpc_table[v136 & 3];
                  *(_WORD *)a2 = (unint64_t)(0x400FC3F0FC3F10 * v137 + 0x800000000000) >> 48;
                  *((_WORD *)a2 + 1) = (unint64_t)(0x400FC3F0FC3F10 * v138 + 0x800000000000) >> 48;
                  *((_WORD *)a2 + 2) = (unint64_t)(0x400FC3F0FC3F10 * v139 + 0x800000000000) >> 48;
                  *((_WORD *)a2 + 3) = v136;
                  a2 += 8;
                  --v134;
                }
                while (v134);
              }
            }
            else if (v19)
            {
              v161 = v19;
              do
              {
                v162 = *(_DWORD *)v37;
                v37 += 4;
                *(_WORD *)a2 = *(_WORD *)((char *)expand_2_to_16bpc_table + (((unint64_t)v162 >> 29) & 6));
                *((_WORD *)a2 + 1) = (0x400FC3F0FC3F10 * (((unint64_t)v162 >> 20) & 0x3FF) + 0x800000000000) >> 48;
                *((_WORD *)a2 + 2) = (0x400FC3F0FC3F10 * (((unint64_t)v162 >> 10) & 0x3FF) + 0x800000000000) >> 48;
                *((_WORD *)a2 + 3) = (0x400FC3F0FC3F10 * (unint64_t)(v162 & 0x3FF) + 0x800000000000) >> 48;
                a2 += 8;
                --v161;
              }
              while (v161);
            }
          }
          else if (v19)
          {
            v97 = v19;
            do
            {
              v98 = *(_DWORD *)v37;
              v37 += 4;
              v99 = bswap32(v98);
              *(_WORD *)a2 = expand_2_to_16bpc_table[v99 >> 30];
              *((_WORD *)a2 + 1) = (0x400FC3F0FC3F10 * (unint64_t)((v99 >> 20) & 0x3FF) + 0x800000000000) >> 48;
              *((_WORD *)a2 + 2) = (0x400FC3F0FC3F10 * (unint64_t)((v99 >> 10) & 0x3FF) + 0x800000000000) >> 48;
              *((_WORD *)a2 + 3) = (0x400FC3F0FC3F10 * (unint64_t)(v99 & 0x3FF) + 0x800000000000) >> 48;
              a2 += 8;
              --v97;
            }
            while (v97);
          }
        }
        else
        {
          if (v47)
            _CGHandleAssert("upscale_packed_to_16bit", 660, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
          if (v46 / v36 * v36 != v46)
            _CGHandleAssert("upscale_packed_to_16bit", 663, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  bpc %zu  bpp %zu", v31, v32, v33, v46 / v36);
          v108 = v46 / v36 * v19;
          if (v22)
          {
            LODWORD(v109) = 0;
            v110 = 0;
            do
            {
              if (!(_DWORD)v109)
              {
                v111 = *v37++;
                v110 = v111 | (v110 << 8);
                LODWORD(v109) = 8;
              }
              LODWORD(v109) = v109 - 1;
              --v22;
            }
            while (v22);
          }
          else
          {
            v110 = 0;
            LODWORD(v109) = 0;
          }
          if (v108)
          {
            v148 = 0;
            v149 = rescale_to_16bit_kScaleTable[v36];
            do
            {
              if (v36 <= 0x18)
              {
                LOWORD(v152) = 0;
                v153 = v109;
                v154 = v36;
              }
              else
              {
                if (v109 > 0x17)
                {
                  v151 = v109;
                }
                else
                {
                  do
                  {
                    v150 = *v37++;
                    v110 = v150 | (v110 << 8);
                    v151 = v109 + 8;
                    v64 = v109 >= 0x10;
                    LODWORD(v109) = v109 + 8;
                  }
                  while (!v64);
                }
                v153 = (v151 - 24);
                v152 = ((v110 >> (v151 - 24)) & 0xFFFFFF) << (v36 - 24);
                LODWORD(v109) = v153;
                v154 = v36 - 24;
              }
              if (v154 > v153)
              {
                do
                {
                  v155 = *v37++;
                  v110 = v155 | (v110 << 8);
                  v109 = (v109 + 8);
                }
                while (v154 > v109);
              }
              LODWORD(v109) = v109 - v154;
              *(_WORD *)&a2[2 * v148++] = (v149
                                         * ((v110 >> v109) & (unsigned __int16)~(-1 << v154) | (unsigned __int16)v152)
                                         + 0x800000000000) >> 48;
            }
            while (v148 != v108);
          }
        }
        break;
      case 3:
        if (v47)
          _CGHandleAssert("upscale_components_internal", 840, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
        if (v36 - 33 <= 0xFFFFFFFFFFFFFFEFLL)
          _CGHandleAssert("upscale_to_32bit", 762, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 16 && src_bits_per_component < 33", "bpc %zu", v31, v32, v33, *(_QWORD *)(a1 + 88));
        if (v46 / v36 * v36 != v46)
          _CGHandleAssert("upscale_to_32bit", 765, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  bpc %zu  bpp %zu", v31, v32, v33, v46 / v36);
        v100 = v46 / v36 * v19;
        if (v22)
        {
          LODWORD(v101) = 0;
          v102 = 0;
          do
          {
            if (!(_DWORD)v101)
            {
              v103 = *v37++;
              v102 = v103 | (v102 << 8);
              LODWORD(v101) = 8;
            }
            LODWORD(v101) = v101 - 1;
            --v22;
          }
          while (v22);
        }
        else
        {
          v102 = 0;
          LODWORD(v101) = 0;
        }
        if (v36 == 32 && v48 == 0x2000)
        {
          if (v100)
          {
            for (n = 0; n != v100; ++n)
            {
              if (v101 > 0x17)
              {
                v114 = v101;
              }
              else
              {
                do
                {
                  v113 = *v37++;
                  v102 = v113 | (v102 << 8);
                  v114 = v101 + 8;
                  v64 = v101 >= 0x10;
                  LODWORD(v101) = v101 + 8;
                }
                while (!v64);
              }
              v115 = v114 - 24;
              if ((v114 - 24) > 7)
              {
                v117 = v102;
                v118 = v114 - 24;
              }
              else
              {
                v116 = *v37++;
                v117 = v116 | (v102 << 8);
                v118 = v114 - 16;
              }
              v119 = (v102 >> v115) << 8;
              LODWORD(v101) = v118 - 8;
              v120 = (double)bswap32((v117 >> (v118 - 8)) | v119) / 4294967300.0;
              if (v120 > 1.0)
                v120 = 1.0;
              v121 = v120;
              *(float *)&a2[4 * n] = v121;
              v102 = v117;
            }
          }
        }
        else if (v100)
        {
          v122 = 0;
          v123 = rescale_to_float_max_per_component[v36 - 17];
          do
          {
            if (v36 <= 0x18)
            {
              v126 = 0;
              v127 = v101;
              v128 = v36;
            }
            else
            {
              if (v101 > 0x17)
              {
                v125 = v101;
              }
              else
              {
                do
                {
                  v124 = *v37++;
                  v102 = v124 | (v102 << 8);
                  v125 = v101 + 8;
                  v64 = v101 >= 0x10;
                  LODWORD(v101) = v101 + 8;
                }
                while (!v64);
              }
              v127 = (v125 - 24);
              v126 = ((v102 >> (v125 - 24)) & 0xFFFFFF) << (v36 - 24);
              LODWORD(v101) = v127;
              v128 = v36 - 24;
            }
            if (v128 > v127)
            {
              do
              {
                v129 = *v37++;
                v102 = v129 | (v102 << 8);
                v101 = (v101 + 8);
              }
              while (v128 > v101);
            }
            LODWORD(v101) = v101 - v128;
            v130 = (double)((v102 >> v101) & ~(-1 << v128) | v126) / v123;
            if (v130 > 1.0)
              v130 = 1.0;
            v131 = v130;
            *(float *)&a2[4 * v122++] = v131;
          }
          while (v122 != v100);
        }
        break;
      case 4:
        if (v47 != 0x40000)
          _CGHandleAssert("upscale_components_internal", 832, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatRGBCIF10", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
        if (v36 != 10)
          _CGHandleAssert("convert_CIF10_to_fp16", 717, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component == 10", "bpc %zu", v31, v32, v33, *(_QWORD *)(a1 + 88));
        if (v46 != 32)
          _CGHandleAssert("convert_CIF10_to_fp16", 718, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 32", "bpp %zu", v31, v32, v33, *(_QWORD *)(a1 + 80));
        src.data = *(void **)(a1 + 144);
        src.height = 1;
        src.width = v19;
        src.rowBytes = 4 * v19;
        dest.data = a2;
        dest.height = 1;
        dest.width = v19;
        dest.rowBytes = 8 * v19;
        vImageConvert_XRGB2101010ToARGB16F(&src, 1.0, &dest, 384, 895, 0, 0x810u);
        break;
      default:
        _CGHandleAssert("upscale_components_internal", 850, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", v31, v32, v33, v177);
    }
  }
LABEL_292:
  if (v34 < v23)
    a4 = (v19 * *(_QWORD *)(a1 + 40) + 7) >> 3;
  if (a5)
  {
    *(_QWORD *)(a1 + 112) += v34;
    *(_QWORD *)(a1 + 64) += a4;
  }
  return a4;
}

void upscale_using_vImage(void *a1, void *a2, vImagePixelCount a3, size_t a4, size_t a5, vImageConverterRef converter)
{
  vImage_Error v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __n128 v15;
  size_t v16;
  uint64_t v17;
  char *v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  vImage_Error v29;
  uint64_t v30;
  vImage_Buffer dests;
  vImage_Buffer srcs;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  srcs.data = a2;
  srcs.height = 1;
  srcs.width = a3;
  srcs.rowBytes = a5;
  dests.data = a1;
  dests.height = 1;
  dests.width = a3;
  dests.rowBytes = a4;
  v7 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0x80u);
  if (v7 < 0)
  {
    v19 = "vImageConvert_AnyToAny failed to return vImage buffer size %s";
LABEL_14:
    CGPostError((uint64_t)v19, v8, v9, v10, v11, v12, v13, v14, (char)"upscale_using_vImage");
    return;
  }
  if (!v7)
  {
    if (!vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0))
      return;
    goto LABEL_13;
  }
  v16 = MEMORY[0x1E0C80A78](v7, v15);
  v18 = (char *)&v30 - v17;
  if (v16 <= 0x400)
  {
    if (!vImageConvert_AnyToAny(converter, &srcs, &dests, (char *)&v30 - v17, 0))
      return;
LABEL_13:
    v19 = "%s : vImageConvert_AnyToAny failed to convert data";
    goto LABEL_14;
  }
  v20 = (char *)malloc_type_malloc(v16, 0x34DD0371uLL);
  if (!v20)
  {
    CGPostError((uint64_t)"vImageConvert_AnyToAny could not allocate buffer %s", v21, v22, v23, v24, v25, v26, v27, (char)"upscale_using_vImage");
    v19 = "%s : vImageConvert_AnyToAny failed to convert data";
    goto LABEL_14;
  }
  v28 = v20;
  v29 = vImageConvert_AnyToAny(converter, &srcs, &dests, v20, 0);
  if (v28 != v18)
    free(v28);
  if (v29)
    goto LABEL_13;
}

unint64_t upscale_provider_get_bytes(uint64_t a1, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (*(_BYTE *)(a1 + 8))
    _CGHandleAssert("upscale_provider_get_bytes", 1204, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "info->src_provider_uses_random_access == false", "", a6, a7, a8, vars0);
  return upscale_provider_get_bytes_at_position_inner(a1, a2, 0, a3, 1, a6, a7, a8);
}

unint64_t upscale_provider_skip_forward(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v8 = a2;
  if ((a2 & 0x8000000000000000) != 0)
    _CGHandleAssert("upscale_provider_skip_forward", 1214, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "count >= 0", "count %lld", a6, a7, a8, a2);
  v10 = *(_QWORD *)a1;
  v11 = byte_count_to_byte_count(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 96), a2, a8);
  v12 = CGDataProviderSkipForwardInternal(v10, v11);
  v16 = v12;
  if (v12 < 0)
    _CGHandleAssert("upscale_provider_skip_forward", 1227, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "skipped >= 0", "skipped %lld", v13, v14, v15, v12);
  if (v12 != v11)
    v8 = byte_count_to_byte_count(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v12, v15);
  *(_QWORD *)(a1 + 112) += v16;
  *(_QWORD *)(a1 + 64) += v8;
  return v8;
}

_QWORD *upscale_provider_rewind(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t (*v10)(_QWORD);
  char v11;

  v8 = *result;
  if (!*result)
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, v11);
  if ((*(_DWORD *)(v8 + 20) | 2) != 3)
    _CGHandleAssert("upscale_provider_rewind", 1260, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", a6, a7, a8, v11);
  v9 = result;
  v10 = *(uint64_t (**)(_QWORD))(v8 + 64);
  if (v10)
    result = (_QWORD *)v10(*(_QWORD *)(v8 + 24));
  *(_BYTE *)(v8 + 261) = 0;
  v9[8] = 0;
  v9[14] = 0;
  return result;
}

uint64_t upscale_provider_lock(uint64_t *a1)
{
  return CGDataProviderLock(*a1);
}

uint64_t upscale_provider_unlock(uint64_t *a1)
{
  return CGDataProviderUnlock(*a1);
}

uint64_t readingOrder(void *a1, void *a2, double *a3)
{
  double v4;
  CGFloat v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  _BOOL4 v19;
  double v20;
  double v21;
  _BOOL4 v22;
  double y;
  double height;
  double v25;
  double v26;
  CGFloat rect;
  double rect_8;
  double rect_16;
  CGFloat rect_24;
  double v32;
  CGRect v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;

  v32 = *a3;
  objc_msgSend(a1, "bounds");
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  objc_msgSend(a2, "bounds");
  rect_24 = v12;
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v19 = v11 < 0.0 || v9 < 0.0;
  v20 = v7;
  v21 = v11;
  if (v19)
  {
    v33.origin.x = v5;
    v33.origin.y = v7;
    v33.size.width = v9;
    v33.size.height = v11;
    *(CGRect *)(&v20 - 1) = CGRectStandardize(v33);
  }
  rect_8 = v21;
  rect_16 = v20;
  rect = v5;
  v22 = v18 < 0.0 || v16 < 0.0;
  y = v14;
  height = v18;
  if (v22)
  {
    v36.origin.x = rect_24;
    v36.origin.y = v14;
    v36.size.width = v16;
    v36.size.height = v18;
    v37 = CGRectStandardize(v36);
    y = v37.origin.y;
    height = v37.size.height;
    if (!v19)
    {
LABEL_11:
      if (!v22)
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  else if (!v19)
  {
    goto LABEL_11;
  }
  v38.origin.x = rect;
  v38.origin.y = v7;
  v38.size.width = v9;
  v38.size.height = v11;
  v39 = CGRectStandardize(v38);
  v7 = v39.origin.y;
  if (v22)
  {
LABEL_12:
    v34.origin.x = rect_24;
    v34.origin.y = v14;
    v34.size.width = v16;
    v34.size.height = v18;
    v35 = CGRectStandardize(v34);
    v14 = v35.origin.y;
  }
LABEL_13:
  v25 = rect_16 + rect_8 + v7 * v32;
  v26 = y + height + v14 * v32;
  if (v25 > v26)
    return -1;
  else
    return v25 < v26;
}

uint64_t path_iterator_release(uint64_t this)
{
  if (this)
    return path_iterator::release(this);
  return this;
}

uint64_t path_iterator_create(uint64_t a1, _OWORD *a2, unsigned int *a3)
{
  uint64_t result;
  __int128 v7;
  unsigned int v8;

  result = operator new();
  *(_QWORD *)(result + 8) = a1;
  v7 = a2[1];
  *(_OWORD *)(result + 16) = *a2;
  *(_OWORD *)(result + 32) = v7;
  if (a3)
  {
    do
      v8 = __ldxr(a3);
    while (__stxr(v8 + 1, a3));
  }
  *(_QWORD *)(result + 48) = a3;
  *(_DWORD *)result = 1;
  return result;
}

_QWORD *path_iterator_begin(_QWORD *result, uint64_t a2)
{
  uint64_t (*v2)(_QWORD, uint64_t, _QWORD);

  if (result)
  {
    v2 = (uint64_t (*)(_QWORD, uint64_t, _QWORD))result[2];
    if (v2)
      return (_QWORD *)v2(result[1], a2, result[6]);
  }
  return result;
}

uint64_t path_iterator_call(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(a1 + 24))(*(_QWORD *)(a1 + 8), a2, a3, *(_QWORD *)(a1 + 48));
}

uint64_t path_iterator_move_to_point(uint64_t result, double a2, double a3)
{
  _QWORD v3[2];

  *(double *)v3 = a2;
  *(double *)&v3[1] = a3;
  if (result)
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD *, _QWORD))(result + 24))(*(_QWORD *)(result + 8), 0, v3, *(_QWORD *)(result + 48));
  return result;
}

uint64_t path_iterator_add_line_to_point(uint64_t result, double a2, double a3)
{
  _QWORD v3[2];

  *(double *)v3 = a2;
  *(double *)&v3[1] = a3;
  if (result)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD *, _QWORD))(result + 24))(*(_QWORD *)(result + 8), 1, v3, *(_QWORD *)(result + 48));
  return result;
}

uint64_t path_iterator_add_quad_curve_to_point(uint64_t result, double a2, double a3, double a4, double a5)
{
  _QWORD v5[5];

  v5[4] = *MEMORY[0x1E0C80C00];
  if (result)
  {
    *(double *)v5 = a2;
    *(double *)&v5[1] = a3;
    *(double *)&v5[2] = a4;
    *(double *)&v5[3] = a5;
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD *, _QWORD))(result + 24))(*(_QWORD *)(result + 8), 2, v5, *(_QWORD *)(result + 48));
  }
  return result;
}

uint64_t path_iterator_add_curve_to_point(uint64_t result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  _QWORD v7[7];

  v7[6] = *MEMORY[0x1E0C80C00];
  if (result)
  {
    *(double *)v7 = a2;
    *(double *)&v7[1] = a3;
    *(double *)&v7[2] = a4;
    *(double *)&v7[3] = a5;
    *(double *)&v7[4] = a6;
    *(double *)&v7[5] = a7;
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD *, _QWORD))(result + 24))(*(_QWORD *)(result + 8), 3, v7, *(_QWORD *)(result + 48));
  }
  return result;
}

uint64_t path_iterator_close_subpath(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(result + 24))(*(_QWORD *)(result + 8), 4, 0, *(_QWORD *)(result + 48));
  return result;
}

_QWORD *path_iterator_end(_QWORD *result)
{
  uint64_t (*v1)(_QWORD, _QWORD);

  if (result)
  {
    v1 = (uint64_t (*)(_QWORD, _QWORD))result[4];
    if (v1)
      return (_QWORD *)v1(result[1], result[6]);
  }
  return result;
}

void pdf_page_release(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  if (a1)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 56));
    v2 = *(const void **)(a1 + 24);
    if (v2)
      CFRelease(v2);
    free(*(void **)(a1 + 64));
    CGPropertiesRelease(*(_QWORD *)(a1 + 72));
    v3 = *(const void **)(a1 + 80);
    if (v3)
      CFRelease(v3);
    v4 = *(const void **)(a1 + 96);
    if (v4)
      CFRelease(v4);
    v5 = *(const void **)(a1 + 104);
    if (v5)
      CFRelease(v5);
    free((void *)a1);
  }
}

uint64_t pdf_page_get_thumbnail(uint64_t a1)
{
  uint64_t result;
  CGImage *v3;
  CGImage *v4;
  CGPDFStreamRef value;

  result = *(_QWORD *)(a1 + 80);
  if (!result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    if (*(_QWORD *)(a1 + 80)
      || (value = 0, CGPDFDictionaryGetStream(*(CGPDFDictionaryRef *)(a1 + 16), "Thumb", &value))
      && (v3 = (CGImage *)CGPDFImageCreate((uint64_t)value)) != 0
      && (v4 = v3,
          *(_QWORD *)(a1 + 80) = CGPDFImageCreateImageForRenderingSize(v3, 0, 0.0, 0.0),
          CFRelease(v4),
          *(_QWORD *)(a1 + 80)))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      return *(_QWORD *)(a1 + 80);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      return 0;
    }
  }
  return result;
}

const void *pdf_page_copy_background_color_hint(uint64_t a1)
{
  os_unfair_lock_s *v2;
  const void *v3;

  v2 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v3 = *(const void **)(a1 + 104);
  if (v3)
    CFRetain(v3);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t GRAYA8_sample_RGBA32_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  int v9;
  unsigned int v10;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unsigned int v81;
  uint64_t v82;
  unsigned int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  unsigned int v87;
  int v88;
  unint64_t v89;
  unsigned int v90;
  unsigned int v91;
  int v92;
  int v93;
  int v94;
  char v95;
  unsigned int v96;
  unsigned __int8 v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  int v111;
  int v112;
  unsigned int v113;
  unsigned int v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  int v127;
  int v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  unsigned int v143;
  unsigned int v144;
  int v145;
  unsigned int v146;
  int v147;
  unsigned int v148;
  int v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;

  v8 = *(_DWORD *)(result + 8);
  v9 = v8 >> 6;
  if ((v9 - 3) <= 0xFFFFFFFD)
    _CGHandleAssert("GRAYA8_sample_RGBA32_inner", 9121, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "skip == FIRST_SKIP || skip == LAST_SKIP", "invalid skip code %d", a6, a7, a8, v8 >> 6);
  v10 = (v8 >> 4) & 3;
  if (v10 >= 2)
    _CGHandleAssert("GRAYA8_sample_RGBA32_inner", 9122, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "reverse == NO_REVERSE || reverse == PIXEL_REVERSE", "invalid reverse code %d", a6, a7, a8, v10);
  if (v9 == 2 && v10 == 0)
  {
    v161 = 1;
    v162 = 0;
    v163 = 2;
    v159 = 3;
  }
  else if (v9 == 1 && v10 == 0)
  {
    v159 = 0;
    v162 = 1;
    v161 = 2;
    v163 = 3;
  }
  else
  {
    v15 = (v9 == 2) & (v10 == 1);
    v14 = (_DWORD)v15 == 0;
    v163 = v15;
    v16 = 3;
    if (!v14)
      v16 = 0;
    v159 = v16;
    if (v14)
      v17 = 1;
    else
      v17 = 2;
    v18 = 2;
    if (!v14)
      v18 = 3;
    v161 = v17;
    v162 = v18;
  }
  v19 = *(_DWORD *)(result + 24);
  v20 = *(_QWORD *)(result + 112);
  v21 = *(_QWORD *)(result + 48);
  v22 = *(_QWORD *)(result + 56);
  if (v21)
  {
    v158 = *(_QWORD *)(result + 112);
    if (v20 > v21)
      v158 = v20 % v21;
  }
  else
  {
    v158 = 0;
  }
  v23 = *(_QWORD *)(result + 176);
  v24 = *(_QWORD *)(result + 120);
  v160 = *(_QWORD *)(result + 32);
  if (v22)
  {
    v157 = *(_QWORD *)(result + 120);
    if (v24 > v22)
      v157 = v24 % v22;
  }
  else
  {
    v157 = 0;
  }
  v152 = *(_QWORD *)(result + 80);
  v150 = *(_DWORD *)(result + 188);
  v156 = *(_QWORD *)(result + 152) - 2;
  v154 = *(_QWORD *)(result + 88);
  v155 = *(_QWORD *)(result + 144) - 1;
  v25 = *(_QWORD *)(result + 40);
  v26 = v160 + (4 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v19) - 4;
  v153 = *(_QWORD *)(result + 72);
  v151 = *(_QWORD *)(result + 64);
  while (1)
  {
    if (a3 >= v153)
    {
      if (a3 <= v154)
      {
        v35 = 0;
        v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        v37 = 0x3FFFFFFF;
        v38 = a3;
        v39 = v151;
      }
      else
      {
        v31 = *(_QWORD *)(result + 216);
        v32 = *(_QWORD *)(result + 224) + v154;
        v33 = v32 - a3 + (v31 >> 1);
        if (v33 < 1)
          goto LABEL_70;
        if (v33 >= v31)
          LODWORD(v34) = 0x3FFFFFFF;
        else
          v34 = (unint64_t)(*(_QWORD *)(result + 232) * v33) >> 32;
        v39 = v151;
        v37 = v150 | v34;
        v38 = v32 - 0x1000000;
        v35 = a3 - (v32 - 0x1000000);
        v36 = 448;
      }
    }
    else
    {
      v27 = *(_QWORD *)(result + 216);
      v28 = v153 - *(_QWORD *)(result + 224);
      v29 = a3 - v28 + (v27 >> 1);
      if (v29 < 1)
        goto LABEL_70;
      if (v29 >= v27)
        LODWORD(v30) = 0x3FFFFFFF;
      else
        v30 = (unint64_t)(*(_QWORD *)(result + 232) * v29) >> 32;
      v39 = v151;
      v37 = v150 | v30;
      v38 = v28 + 0x1000000;
      v35 = a3 - (v28 + 0x1000000);
      v36 = 512;
    }
    if (a2 >= v39)
    {
      if (a2 <= v152)
      {
        v44 = 0;
        v45 = ((unint64_t)a2 >> 26) & 0x3C;
        v43 = a2;
      }
      else
      {
        v46 = *(_QWORD *)(result + 192);
        v47 = *(_QWORD *)(result + 200) + v152;
        v48 = v47 - a2 + (v46 >> 1);
        if (v48 < 1)
          goto LABEL_70;
        if (v48 < v46)
          v37 = ((v37 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v48) >> 32) >> 15)) | v150;
        v43 = v47 - 0x1000000;
        v44 = a2 - (v47 - 0x1000000);
        v45 = 28;
      }
    }
    else
    {
      v40 = *(_QWORD *)(result + 192);
      v41 = v39 - *(_QWORD *)(result + 200);
      v42 = a2 - v41 + (v40 >> 1);
      if (v42 < 1)
        goto LABEL_70;
      if (v42 < v40)
        v37 = ((v37 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v150;
      v43 = v41 + 0x1000000;
      v44 = a2 - (v41 + 0x1000000);
      v45 = 32;
    }
    if (v37 >= 0x400000)
      break;
LABEL_70:
    v59 = a4 - 1;
    a2 += v20;
    a3 += v24;
    *(_BYTE *)++v155 = 0;
    v156 += 2;
LABEL_71:
    a4 = v59;
    if (!v59)
      return result;
  }
  if (v21)
  {
    v49 = (v22 & ((v38 % v22) >> 63)) + v38 % v22;
    v50 = (v21 & ((v43 % v21) >> 63)) + v43 % v21;
    if (v49 >= v22)
      v51 = v22;
    else
      v51 = 0;
    v38 = v49 - v51;
    if (v50 >= v21)
      v52 = v21;
    else
      v52 = 0;
    v43 = v50 - v52;
    v35 += v38;
    v44 += v43;
  }
  v53 = v160 + SHIDWORD(v38) * (uint64_t)v19;
  v54 = v43 >> 32;
  v55 = v53 + 4 * v54;
  v56 = *(_QWORD *)(result + 32);
  if (v26 >= v55)
    v57 = v53 + 4 * v54;
  else
    v57 = v26;
  if (v57 < v56)
    v57 = *(_QWORD *)(result + 32);
  if (v25)
    v58 = *(unsigned __int8 *)(v57 + v159);
  else
    v58 = 255;
  v60 = *(unsigned __int8 *)(v57 + v162);
  v61 = *(unsigned __int8 *)(v57 + v161);
  v62 = *(unsigned __int8 *)(v57 + v163);
  if (v23)
  {
    v63 = *(_DWORD *)(v23 + (v45 | v36));
LABEL_77:
    v64 = v63 & 0xF;
    v65 = v63 >> 8;
    v66 = HIBYTE(v63) & 3;
    switch(v64)
    {
      case 1:
        LODWORD(v101) = SBYTE1(v63);
        if (v21)
        {
          v102 = v65 << 56;
          v103 = v35 + (v102 >> 24);
          v104 = v22 & (v103 >> 63);
          if (v104 + v103 >= v22)
            v105 = v22;
          else
            v105 = 0;
          v101 = (v104 + (v102 >> 24) - v105) >> 32;
        }
        v106 = v55 + (int)v101 * (uint64_t)v19;
        if (v26 < v106)
          v106 = v26;
        if (v106 >= v56)
          v107 = v106;
        else
          v107 = v56;
        v108 = *(unsigned __int8 *)(v107 + v162);
        v109 = *(unsigned __int8 *)(v107 + v161);
        v110 = *(unsigned __int8 *)(v107 + v163);
        v62 = 255;
        if (v25)
          v62 = *(unsigned __int8 *)(v107 + v159);
        v111 = interpolate_rgba[4 * v66 + 3];
        v112 = interpolate_rgba[4 * v111 + 3];
        LOBYTE(v111) = v111 + 1;
        v60 -= (v112 & v60) >> v111;
        v113 = v61 - ((v112 & v61) >> v111);
        v58 -= (v112 & v58) >> v111;
        v114 = (v112 & v108) >> v111;
        v115 = (v112 & v109) >> v111;
        v116 = (v112 & v110) >> v111;
        v117 = (v112 & v62) >> v111;
        LOBYTE(v60) = v60 + v114;
        LOBYTE(v61) = v113 + v115;
        LOBYTE(v62) = v60 + v116;
        LOWORD(v58) = v58 + v117;
        break;
      case 2:
        v118 = SBYTE2(v63);
        if (v21)
        {
          v119 = v44 + ((uint64_t)SBYTE2(v63) << 32);
          v120 = v21 & (v119 >> 63);
          if (v120 + v119 >= v21)
            v121 = v21;
          else
            v121 = 0;
          v118 = (v120 + ((uint64_t)((unint64_t)HIWORD(v63) << 56) >> 24) - v121) >> 32;
        }
        v122 = v55 + 4 * v118;
        if (v26 < v122)
          v122 = v26;
        if (v122 >= v56)
          v123 = v122;
        else
          v123 = v56;
        v124 = *(unsigned __int8 *)(v123 + v162);
        v125 = *(unsigned __int8 *)(v123 + v161);
        v126 = *(unsigned __int8 *)(v123 + v163);
        v127 = 255;
        if (v25)
          v127 = *(unsigned __int8 *)(v123 + v159);
        v128 = (v63 >> 28) & 3;
        v129 = interpolate_rgba[4 * v128 + 3];
        LOBYTE(v128) = v128 + 1;
        v60 = v60 - ((v129 & v60) >> v128) + ((v129 & v124) >> v128);
        v61 = v61 - ((v129 & v61) >> v128) + ((v129 & v125) >> v128);
        v62 = v60 + ((v129 & v126) >> v128);
        v58 = v58 - ((v129 & v58) >> v128) + ((v129 & v127) >> v128);
        break;
      case 3:
        LODWORD(v67) = SBYTE1(v63);
        v68 = SBYTE2(v63);
        if (v21)
        {
          v69 = v65 << 56;
          v70 = (unint64_t)HIWORD(v63) << 56;
          v71 = v35 + (v69 >> 24);
          v72 = v44 + (v70 >> 24);
          v73 = v22 & (v71 >> 63);
          v74 = v21 & (v72 >> 63);
          v75 = v74 + v72;
          if (v73 + v71 >= v22)
            v76 = v22;
          else
            v76 = 0;
          if (v75 >= v21)
            v77 = v21;
          else
            v77 = 0;
          v67 = (v73 + (v69 >> 24) - v76) >> 32;
          v68 = (v74 + (v70 >> 24) - v77) >> 32;
        }
        v78 = (int)v67 * (uint64_t)v19;
        v79 = v55 + 4 * v68;
        if (v26 < v79)
          v79 = v26;
        if (v79 >= v56)
          v80 = v79;
        else
          v80 = v56;
        v81 = *(unsigned __int8 *)(v80 + v162);
        v82 = 4 * v68;
        v83 = *(unsigned __int8 *)(v80 + v161);
        v148 = *(unsigned __int8 *)(v80 + v163);
        v84 = 255;
        if (v25)
          v84 = *(unsigned __int8 *)(v80 + v159);
        v149 = v84;
        v85 = v55 + v78;
        if (v26 >= v85)
          v86 = v85;
        else
          v86 = v26;
        if (v86 < v56)
          v86 = v56;
        v87 = *(unsigned __int8 *)(v86 + v162);
        v143 = *(unsigned __int8 *)(v86 + v161);
        v146 = *(unsigned __int8 *)(v86 + v163);
        v88 = 255;
        if (v25)
          v88 = *(unsigned __int8 *)(v86 + v159);
        v147 = v88;
        v89 = v85 + v82;
        if (v26 < v85 + v82)
          v89 = v26;
        if (v89 < v56)
          v89 = v56;
        v90 = *(unsigned __int8 *)(v89 + v162);
        v91 = *(unsigned __int8 *)(v89 + v161);
        v144 = *(unsigned __int8 *)(v89 + v163);
        v92 = 255;
        if (v25)
          v92 = *(unsigned __int8 *)(v89 + v159);
        v145 = v92;
        v93 = (v63 >> 28) & 3;
        v94 = interpolate_rgba[4 * v66 + 3];
        v95 = v66 + 1;
        v96 = v60 - ((v94 & v60) >> v95) + ((v94 & v87) >> v95);
        v97 = interpolate_rgba[4 * v93 + 3];
        v60 = v96
            - ((v96 & v97) >> (v93 + 1))
            + (((v81 - ((v94 & v81) >> v95) + ((v94 & v90) >> v95)) & v97) >> (v93 + 1));
        v98 = v61 - ((v94 & v61) >> v95) + ((v94 & v143) >> v95);
        v61 = v98
            - ((v98 & v97) >> (v93 + 1))
            + (((v83 - ((v94 & v83) >> v95) + ((v94 & v91) >> v95)) & v97) >> (v93 + 1));
        v99 = v62 - ((v94 & v62) >> v95) + ((v94 & v146) >> v95);
        v62 = v99
            - ((v99 & v97) >> (v93 + 1))
            + (((v148 - ((v94 & v148) >> v95) + ((v94 & v144) >> v95)) & v97) >> (v93 + 1));
        v100 = v58 - ((v94 & v58) >> v95) + ((v94 & v147) >> v95);
        v58 = v100
            - ((v100 & v97) >> (v93 + 1))
            + (((v149 - ((v94 & v149) >> v95) + ((v94 & v145) >> v95)) & v97) >> (v93 + 1));
        break;
    }
  }
  v130 = 0;
  v131 = 0;
  a3 += v24;
  v132 = v154 - a3;
  a2 += v20;
  v133 = v152 - a2;
  while (1)
  {
    *(_WORD *)(v156 + 2 + 2 * v131) = ((2 * v60
                                      + v62
                                      + 5 * v61) >> 3) | ((_WORD)v58 << 8);
    *(_BYTE *)(v155 + 1 + v131) = v37 >> 22;
    if (a4 - 1 == (_DWORD)v131)
      return result;
    if ((v132 | v133 | (a3 - v153) | (a2 - v151)) < 0)
    {
      v155 += v131 + 1;
      v156 = v156 - v130 + 2;
      v59 = ~(_DWORD)v131 + a4;
      goto LABEL_71;
    }
    if (v21)
    {
      v134 = (v22 & ((v35 + v157) >> 63)) + v35 + v157;
      v135 = (v21 & ((v44 + v158) >> 63)) + v44 + v158;
      if (v134 >= v22)
        v136 = v22;
      else
        v136 = 0;
      v137 = v134 - v136;
      if (v135 >= v21)
        v138 = v21;
      else
        v138 = 0;
      v44 = v135 - v138;
      v35 = v137;
      v139 = v135 - v138;
    }
    else
    {
      HIDWORD(v137) = HIDWORD(a3);
      v139 = a2;
    }
    v140 = v160 + SHIDWORD(v137) * (uint64_t)v19;
    v141 = v139 >> 32;
    v55 = v140 + 4 * v141;
    v56 = *(_QWORD *)(result + 32);
    if (v26 >= v55)
      v142 = v140 + 4 * v141;
    else
      v142 = v26;
    if (v142 < v56)
      v142 = *(_QWORD *)(result + 32);
    if (v25)
      v58 = *(unsigned __int8 *)(v142 + v159);
    else
      v58 = 255;
    v60 = *(unsigned __int8 *)(v142 + v162);
    v61 = *(unsigned __int8 *)(v142 + v161);
    v62 = *(unsigned __int8 *)(v142 + v163);
    if (v23)
    {
      v63 = *(_DWORD *)(v23 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v63 & 0xF) != 0)
      {
        v155 += v131 + 1;
        v156 = v156 - v130 + 2;
        a4 += ~(_DWORD)v131;
        v37 = -1;
        goto LABEL_77;
      }
    }
    ++v131;
    v130 -= 2;
    a3 += v24;
    v132 -= v24;
    a2 += v20;
    v133 -= v20;
    v37 = -1;
  }
}

void GRAYa8_sample_RGB48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_RGB48", 11451, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_rgb48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_rgb48", 11456, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBA64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_RGBA64", 11461, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_rgba64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_rgba64", 11466, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_WF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_WF", 11471, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_Wf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_Wf", 11476, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_RGBF", 11481, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_RGBf", 11486, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_RGBAF", 11491, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_RGBAf", 11496, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_CMYKF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_CMYKF", 11501, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_CMYKf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("GRAYa8_sample_CMYKf", 11506, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

uint64_t PDAmultiplyPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4;

  v4 = a3 * (a2 ^ 0xFF);
  if (a2 == 255)
    v4 = 0;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v4 + ((a4 ^ 0xFF) + a3) * a1 + ((v4 + ((a4 ^ 0xFF) + a3) * a1) >> 8) + 1) >> 8);
}

uint64_t PDAoverlayPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4;

  if (a1 < (a2 + 1) >> 1)
    v4 = (a4 ^ 0xFF) * a1 + (2 * a1 + (a2 ^ 0xFF)) * a3;
  else
    v4 = a3 * (a2 + 255) - (a4 * a2 + 2 * a1 * a3) + (a4 + 255) * a1;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v4 + (v4 >> 8) + 1) >> 8);
}

uint64_t PDAlightenPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4;
  int v5;
  int v6;

  v4 = a1 * a4;
  if (a3 * a2 > v4)
    v4 = a3 * a2;
  v5 = (a4 ^ 0xFF) * a1;
  if (a4 == 255)
    v5 = 0;
  v6 = a3 * (a2 ^ 0xFF);
  if (a2 == 255)
    v6 = 0;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6 + v5 + v4 + ((v6 + v5 + v4) >> 8) + 1) >> 8);
}

uint64_t PDAdarkenPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4;
  int v5;
  int v6;

  v4 = a1 * a4;
  if (a3 * a2 < v4)
    v4 = a3 * a2;
  v5 = (a4 ^ 0xFF) * a1;
  if (a4 == 255)
    v5 = 0;
  v6 = a3 * (a2 ^ 0xFF);
  if (a2 == 255)
    v6 = 0;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6 + v5 + v4 + ((v6 + v5 + v4) >> 8) + 1) >> 8);
}

uint64_t PDAcolordodgePDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (a1)
  {
    if (a4 == a3)
      v4 = 65025;
    else
      v4 = a1 * a4 * a4 / (a4 - a3);
  }
  else
  {
    v4 = 0;
  }
  v5 = a3 * (a2 ^ 0xFF);
  if (a2 == 1)
    v5 = 0;
  v6 = v5 + (a4 ^ 0xFF) * a1 + v4;
  v7 = 255 * (a4 + a2) - a4 * a2;
  if (v6 >= v7)
    v6 = 255 * (a4 + a2) - a4 * a2;
  return (v7 + (v7 >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6
                                                                                              + (v6 >> 8)
                                                                                              + 1) >> 8);
}

uint64_t PDAcolorburnPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4;
  unsigned int v5;

  v4 = a3 * (a2 ^ 0xFF);
  if (a2 == 255)
    v4 = 0;
  v5 = a4 * a2 + (a4 ^ 0xFF) * a1 + v4;
  if (a2 != a1)
  {
    if (a3)
      v5 = (v5 - (a2 - a1) * a4 * a4 / a3) & ~((int)(v5 - (a2 - a1) * a4 * a4 / a3) >> 31);
    else
      v5 = 0;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v5 + (v5 >> 8) + 1) >> 8);
}

uint64_t PDAhardlightPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4;
  unsigned int v5;

  v4 = 2 * a1;
  v5 = a3 * (a2 + 255) - (a4 * a2 + v4 * a3) + (a4 + 255) * a1;
  if (a3 <= (a4 + 1) >> 1)
    v5 = (a4 ^ 0xFF) * a1 + (v4 + (a2 ^ 0xFF)) * a3;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v5 + (v5 >> 8) + 1) >> 8);
}

uint64_t PDAsoftlightPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  v4 = 2 * a1 * a3 - a1 * a1 * (2 * a3 - a4) / a2;
  v5 = v4 & ~(v4 >> 31);
  v6 = (a4 ^ 0xFF) * a1;
  if (a4 == 255)
    v6 = 0;
  v7 = a3 * (a2 ^ 0xFF);
  if (a2 == 255)
    v7 = 0;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6 + v7 + v5 + ((v6 + v7 + v5) >> 8) + 1) >> 8);
}

uint64_t PDAdifferencePDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;
  int v9;

  v4 = a1 * a4;
  v5 = a3 * a2;
  v7 = v4 - v5;
  v6 = v4 - v5 < 0;
  v8 = 255 * (a3 + a1) - v4 - v5;
  if (v6)
    v9 = -v7;
  else
    v9 = v7;
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v8 + v9 + ((v8 + v9) >> 8) + 1) >> 8);
}

uint64_t PDAhuePDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4;
  int v5;
  int v6;

  v4 = a1;
  if (a4 == 255)
  {
    v5 = 0;
  }
  else
  {
    v4 = (a1 * a4 + ((a1 * a4) >> 8) + 1) >> 8;
    v5 = (a4 ^ 0xFF) * a1;
  }
  v6 = (a2 ^ 0xFF) * a3;
  if (a2 == 255)
    v6 = 0;
  return (a4 + a2 - a4 * a2 + ((a4 + a2 - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v5 + v4 + v6 + ((v5 + v4 + v6) >> 8) + 1) >> 8);
}

uint64_t GRAYa8_mark_pixelmask(uint64_t result, int a2)
{
  unint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  _BOOL4 v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned __int8 *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unsigned __int8 *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned __int8 *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unsigned __int8 *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  int v70;
  unsigned int v71;
  int v72;
  _BYTE *v73;
  unsigned int v74;
  unsigned __int8 *v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unsigned __int8 *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 *v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  int v92;
  _BYTE *v93;
  unsigned int v94;
  unsigned __int8 *v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unsigned __int8 *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  _BYTE *v107;
  unsigned __int8 *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unsigned __int8 *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  int v120;
  int v121;
  unsigned __int8 *v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unsigned __int8 *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  int v131;
  int v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  unsigned __int8 *v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  unsigned __int8 *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  int v145;
  unsigned int v146;
  unsigned int v147;
  int v148;
  unsigned __int8 *v149;
  uint64_t v150;
  unint64_t v151;
  uint64_t v152;
  unsigned __int8 *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  int v162;
  unsigned __int8 *v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  unsigned __int8 *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  int v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  int v177;
  unsigned __int8 *v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  unsigned __int8 *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  int v188;
  unsigned int v189;
  unsigned int v190;
  unsigned int v191;
  int v192;
  unsigned __int8 *v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  unsigned __int8 *v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  int v202;
  int v203;
  unsigned int v204;
  unsigned int v205;
  unsigned int v206;
  int v207;
  unsigned __int8 *v208;
  uint64_t v209;
  unint64_t v210;
  uint64_t v211;
  unsigned __int8 *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  int v217;
  int v218;
  unsigned int v219;
  unsigned int v220;
  unsigned int v221;
  int v222;
  unsigned __int8 *v223;
  uint64_t v224;
  unint64_t v225;
  uint64_t v226;
  unsigned __int8 *v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  int v232;
  int v233;
  unsigned int v234;
  unsigned int v235;
  unsigned int v236;
  int v237;
  unsigned __int8 *v238;
  uint64_t v239;
  unint64_t v240;
  uint64_t v241;
  unsigned __int8 *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  int v246;
  int v247;
  unsigned int v248;
  unsigned int v249;
  int v250;
  unsigned __int8 *v251;
  uint64_t v252;
  unint64_t v253;
  uint64_t v254;
  unsigned __int8 *v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  int v259;
  int v260;
  int v261;
  int v262;
  unsigned int v263;
  int v264;
  unsigned int v265;
  unsigned __int8 *v266;
  uint64_t v267;
  unint64_t v268;
  uint64_t v269;
  unsigned __int8 *v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  int v274;
  int v275;
  int v276;
  unsigned int v277;
  _BYTE *v278;
  unsigned __int8 *v279;
  uint64_t v280;
  unint64_t v281;
  uint64_t v282;
  unsigned __int8 *v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  int v287;
  int v288;
  unsigned int v289;
  unsigned int v290;
  int v291;
  unsigned __int8 *v292;
  uint64_t v293;
  unint64_t v294;
  uint64_t v295;
  unsigned __int8 *v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  int v301;
  int v302;
  unsigned int v303;
  unsigned int v304;
  unsigned int v305;
  int v306;
  unsigned __int8 *v307;
  uint64_t v308;
  unint64_t v309;
  uint64_t v310;
  unsigned __int8 *v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  int v316;
  int v317;
  unsigned int v318;
  unsigned int v319;
  unsigned int v320;
  int v321;
  unsigned __int8 *v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  unsigned __int8 *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  int v331;
  int v332;
  unsigned int v333;
  unsigned int v334;
  unsigned int v335;
  int v336;
  unsigned __int8 *v337;
  uint64_t v338;
  unint64_t v339;
  uint64_t v340;
  unsigned __int8 *v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  int v346;
  int v347;
  unsigned int v348;
  unsigned int v349;
  unsigned int v350;
  int v351;
  unsigned __int8 *v352;
  uint64_t v353;
  unint64_t v354;
  uint64_t v355;
  unsigned __int8 *v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  int v361;
  int v362;
  unsigned int v363;
  unsigned int v364;
  unsigned int v365;
  int v366;
  unsigned __int8 *v367;
  uint64_t v368;
  uint64_t v369;
  unint64_t v370;
  unsigned __int8 *v371;
  unint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  int v376;
  int v377;
  unsigned int v378;
  unsigned int v379;
  unsigned int v380;
  int v381;
  unsigned __int8 *v382;
  uint64_t v383;
  unint64_t v384;
  uint64_t v385;
  unsigned __int8 *v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  int v391;
  int v392;
  unsigned int v393;
  unsigned int v394;
  unsigned int v395;
  int v396;
  unsigned __int8 *v397;
  uint64_t v398;
  unint64_t v399;
  uint64_t v400;
  unsigned __int8 *v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  int v405;
  int v406;
  unsigned int v407;
  unsigned int v408;
  int v409;
  int v410;
  unsigned __int8 *v411;
  uint64_t v412;
  unint64_t v413;
  uint64_t v414;
  unsigned __int8 *v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  int v420;
  int v421;
  unsigned int v422;
  unsigned int v423;
  unsigned int v424;
  int v425;
  unsigned __int8 *v426;
  uint64_t v427;
  unint64_t v428;
  uint64_t v429;
  unsigned __int8 *v430;
  uint64_t v431;
  int v432;
  int v433;
  unsigned int v434;
  int v435;
  unsigned __int8 *v436;
  uint64_t v437;
  unint64_t v438;
  uint64_t v439;
  unsigned __int8 *v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  unint64_t v455;
  int v456;
  unint64_t v457;
  uint64_t v458;
  uint64_t v459;
  int v460;
  unsigned __int8 *v461;
  unsigned __int8 *v462;
  unsigned __int8 *v463;
  unsigned __int8 *v464;
  unsigned __int8 *v465;
  unsigned __int8 *v466;
  unsigned __int8 *v467;
  unsigned __int8 *v468;
  unsigned __int8 *v469;
  unsigned __int8 *v470;
  unsigned __int8 *v471;
  unsigned __int8 *v472;
  unsigned __int8 *v473;
  int v474;
  int v475;
  int v476;
  int v477;
  int v478;
  int v479;
  int v480;
  int v481;
  int v482;
  int v483;
  int v484;
  int v485;
  int v486;
  _BOOL4 v487;
  uint64_t v488;

  v3 = *(_QWORD *)(result + 136);
  if (!v3)
    return result;
  v4 = *(_DWORD *)(result + 4);
  v5 = *(_DWORD *)(result + 8);
  v6 = v4;
  v488 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 88);
  v8 = *(_QWORD *)(result + 96);
  v9 = (unint64_t)*(int *)(result + 28) >> 1;
  v10 = (unsigned __int8 *)(*(_QWORD *)(result + 40) + 2 * (*(int *)(result + 12) + v9 * *(int *)(result + 16)));
  v11 = *(int *)(result + 124);
  v12 = (_BYTE *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v11);
  v13 = *(int *)(result + 56);
  v14 = *(int *)(result + 60);
  v15 = *(int *)(result + 76);
  if (*(unsigned __int8 *)(result + 1) << 8 == 256)
  {
    v16 = v15 >> 1;
    v17 = (unsigned __int8 *)(v7 + 2 * (v13 + (v15 >> 1) * v14));
    if (v15 >> 1 != v9)
    {
      v19 = 1;
LABEL_14:
      v20 = 0;
      v6 = v19 * v4;
      v22 = v8 != 0;
      v23 = v11 - v6;
      v24 = v9 - v6;
      v29 = -1;
      v21 = v16;
      goto LABEL_15;
    }
    if (v10 - v17 >= 1)
    {
      if (v4 >= (uint64_t)((unint64_t)(v10 - v17) >> 1))
      {
        v10 += 2 * v4 - 2;
        v17 += 2 * v4 - 2;
        v12 += v4 - 1;
        v19 = -1;
        goto LABEL_13;
      }
      v18 = v5 - 1;
      if (v10 <= &v17[2 * v9 * v18 - 2 + 2 * v4])
      {
        v10 += 2 * v9 * v18;
        v16 = -(uint64_t)v9;
        v12 += v11 * v18;
        v11 = -v11;
        v19 = 1;
        v17 += 2 * v9 * v18;
        v9 = -(uint64_t)v9;
        goto LABEL_14;
      }
    }
    v19 = 1;
LABEL_13:
    v16 = (unint64_t)*(int *)(result + 28) >> 1;
    goto LABEL_14;
  }
  v21 = *(_DWORD *)(result + 64);
  v20 = *(_DWORD *)(result + 68);
  v16 = v15 >> 1;
  v22 = v8 != 0;
  v23 = v11 - v4;
  v24 = v9 - v4;
  if (v7)
  {
    v25 = 0;
    v26 = v7 + 2 * v16 * v20;
    v27 = v7 + 2 * v16 * ((int)v14 % v20);
    v28 = (unsigned __int8 *)(v27 + 2 * ((int)v13 % v21));
    v29 = v27 + 2 * v21;
    v19 = 1;
    v17 = v28;
    goto LABEL_16;
  }
  v17 = 0;
  v29 = 0;
  v19 = 1;
LABEL_15:
  v26 = 0;
  v28 = 0;
  v16 -= v6;
  v25 = 1;
LABEL_16:
  v459 = v23;
  v460 = *(_DWORD *)(result + 4);
  v457 = v24;
  v458 = v16;
  v456 = v25;
  v455 = v26;
  v487 = v22;
  switch(a2)
  {
    case 0:
      v30 = v19;
      v31 = 2 * v19;
      do
      {
        v32 = v4;
        do
        {
          v33 = *v12;
          if (*v12)
          {
            if (v33 == 255)
            {
              *(_WORD *)v10 = 0;
            }
            else
            {
              v34 = v33 ^ 0xFF;
              *v10 = (unsigned __int16)(*v10 * (_WORD)v34 + ((*v10 * v34) >> 8) + 1) >> 8;
              v10[1] = (unsigned __int16)(v10[1] * (_WORD)v34 + ((v10[1] * v34) >> 8) + 1) >> 8;
            }
          }
          v12 += v30;
          v10 += v31;
          --v32;
        }
        while (v32);
        v12 += v23;
        v10 += 2 * v24;
        --v5;
      }
      while (v5);
      return result;
    case 1:
      if (v488)
        v35 = v22;
      else
        v35 = 1;
      v36 = -(uint64_t)v21;
      v37 = -(v16 * v20);
      v38 = 2 * v19;
      if ((v35 & 1) != 0)
      {
        do
        {
          v39 = v4;
          do
          {
            v40 = *v12;
            if (*v12)
            {
              if (v40 == 255)
              {
                *(_WORD *)v10 = *(_WORD *)v17;
              }
              else
              {
                v41 = *v17 * v40 + *v10 * (v40 ^ 0xFF);
                *v10 = (unsigned __int16)(v41 + (v41 >> 8) + 1) >> 8;
                v10[1] = (unsigned __int16)(v17[1] * (_WORD)v40
                                          + v10[1] * (v40 ^ 0xFF)
                                          + ((v17[1] * v40 + v10[1] * (v40 ^ 0xFFu)) >> 8)
                                          + 1) >> 8;
              }
            }
            v12 += v19;
            v42 = &v17[2 * v19];
            if ((unint64_t)v42 >= v29)
              v43 = v36;
            else
              v43 = 0;
            v17 = &v42[2 * v43];
            v10 += v38;
            --v39;
          }
          while (v39);
          v12 += v23;
          v10 += 2 * v24;
          v44 = (unint64_t)&v28[2 * v16];
          if (v44 >= v26)
            v45 = v37;
          else
            v45 = 0;
          v46 = (unsigned __int8 *)(v44 + 2 * v45);
          v47 = v29 + 2 * v45 + 2 * v16;
          if (v25)
          {
            v17 += 2 * v16;
          }
          else
          {
            v29 = v47;
            v28 = v46;
            v17 = v46;
          }
          --v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v432 = v4;
          do
          {
            v433 = *v12;
            if (*v12)
            {
              if (v433 == 255)
              {
                *v10 = *v17;
                v10[1] = -1;
              }
              else
              {
                v434 = *v10 * (v433 ^ 0xFF) + *v17 * v433;
                *v10 = (unsigned __int16)(v434 + (v434 >> 8) + 1) >> 8;
                v435 = v10[1] * (v433 ^ 0xFF) - v433;
                v10[1] = (unsigned __int16)(v435 + ((_WORD)v433 << 8) + ((v435 + (v433 << 8)) >> 8) + 1) >> 8;
              }
            }
            v12 += v19;
            v436 = &v17[2 * v19];
            if ((unint64_t)v436 >= v29)
              v437 = v36;
            else
              v437 = 0;
            v17 = &v436[2 * v437];
            v10 += v38;
            --v432;
          }
          while (v432);
          v12 += v23;
          v10 += 2 * v24;
          v438 = (unint64_t)&v28[2 * v16];
          if (v438 >= v26)
            v439 = v37;
          else
            v439 = 0;
          v440 = (unsigned __int8 *)(v438 + 2 * v439);
          v441 = v29 + 2 * v439 + 2 * v16;
          if (v25)
          {
            v17 += 2 * v16;
          }
          else
          {
            v29 = v441;
            v28 = v440;
            v17 = v440;
          }
          --v5;
        }
        while (v5);
      }
      return result;
    case 2:
      v48 = -(uint64_t)v21;
      v49 = -(v16 * v20);
      while (1)
      {
        v50 = v4;
        do
        {
          v51 = *v12;
          if (!*v12)
            goto LABEL_59;
          if (v51 == 255)
          {
            v52 = v17[1];
            if (!v17[1])
              goto LABEL_59;
            if (v52 == 255)
            {
              *v10 = *v17;
              v10[1] = -1;
              goto LABEL_59;
            }
            *v10 = *v17 + ((unsigned __int16)(*v10 * (v52 ^ 0xFF) + ((*v10 * (v52 ^ 0xFFu)) >> 8) + 1) >> 8);
            v54 = v52 + ((v10[1] * (v52 ^ 0xFF) + ((v10[1] * (v52 ^ 0xFFu)) >> 8) + 1) >> 8);
          }
          else
          {
            v53 = v17[1] * v51 + ((v17[1] * v51) >> 8) + 1;
            if (!BYTE1(v53))
              goto LABEL_59;
            *v10 = ((unsigned __int16)(((v53 >> 8) ^ 0xFF) * *v10 + ((((v53 >> 8) ^ 0xFF) * *v10) >> 8) + 1) >> 8)
                 + ((unsigned __int16)(*v17 * (_WORD)v51 + ((*v17 * v51) >> 8) + 1) >> 8);
            v54 = ((((v53 >> 8) ^ 0xFF) * v10[1] + ((((v53 >> 8) ^ 0xFF) * v10[1]) >> 8) + 1) >> 8) + (v53 >> 8);
          }
          v10[1] = v54;
LABEL_59:
          v12 += v19;
          v55 = &v17[2 * v19];
          if ((unint64_t)v55 >= v29)
            v56 = v48;
          else
            v56 = 0;
          v17 = &v55[2 * v56];
          v10 += 2 * v19;
          --v50;
        }
        while (v50);
        v12 += v23;
        v10 += 2 * v24;
        v57 = (unint64_t)&v28[2 * v16];
        if (v57 >= v26)
          v58 = v49;
        else
          v58 = 0;
        v59 = (unsigned __int8 *)(v57 + 2 * v58);
        v60 = v29 + 2 * v58 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v60;
          v28 = v59;
          v17 = v59;
        }
        if (!--v5)
          return result;
      }
    case 3:
      v61 = -(uint64_t)v21;
      v62 = -(v16 * v20);
      do
      {
        v63 = v10 + 1;
        v64 = v4;
        do
        {
          v65 = *v12;
          if (*v12)
          {
            if (v65 == 255)
            {
              v66 = *v63;
              *(v63 - 1) = (unsigned __int16)(v66 * *v17 + ((v66 * *v17) >> 8) + 1) >> 8;
              if (v22)
                v67 = v17[1];
              else
                v67 = 255;
              v73 = v10 + 1;
              v74 = v67 * v66;
            }
            else
            {
              result = *v17;
              v68 = *v63;
              v69 = (v68 * v65 + ((v68 * v65) >> 8) + 1) >> 8;
              v70 = v65 ^ 0xFF;
              v71 = *(v63 - 1) * v70 + v69 * result;
              *(v63 - 1) = (unsigned __int16)(v71 + (v71 >> 8) + 1) >> 8;
              if (v22)
                v72 = v17[1];
              else
                v72 = 255;
              v74 = v68 * v70 + v69 * v72;
              v73 = v63;
            }
            *v73 = (unsigned __int16)(v74 + (v74 >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          v75 = &v17[2 * v19];
          if ((unint64_t)v75 >= v29)
            v76 = v61;
          else
            v76 = 0;
          v17 = &v75[2 * v76];
          v63 += 2 * v19;
          --v64;
        }
        while (v64);
        v12 += v23;
        v10 = &v63[2 * v24 - 1];
        v77 = (unint64_t)&v28[2 * v16];
        if (v77 >= v26)
          v78 = v62;
        else
          v78 = 0;
        v79 = (unsigned __int8 *)(v77 + 2 * v78);
        v80 = v29 + 2 * v78 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v80;
          v28 = v79;
          v17 = v79;
        }
        --v5;
      }
      while (v5);
      return result;
    case 4:
      v81 = -(uint64_t)v21;
      v82 = -(v16 * v20);
      do
      {
        v83 = v10 + 1;
        v84 = v4;
        do
        {
          v85 = *v12;
          if (*v12)
          {
            if (v85 == 255)
            {
              v86 = *v83 ^ 0xFF;
              *(v83 - 1) = (unsigned __int16)((*v83 ^ 0xFF) * *v17 + ((v86 * *v17) >> 8) + 1) >> 8;
              if (v22)
                v87 = v17[1];
              else
                v87 = 255;
              v93 = v10 + 1;
              v94 = v87 * v86;
            }
            else
            {
              result = *v17;
              v88 = *v83;
              v89 = ((v88 ^ 0xFF) * v85 + (((v88 ^ 0xFFu) * v85) >> 8) + 1) >> 8;
              v90 = v85 ^ 0xFF;
              v91 = *(v83 - 1) * v90 + v89 * result;
              *(v83 - 1) = (unsigned __int16)(v91 + (v91 >> 8) + 1) >> 8;
              if (v22)
                v92 = v17[1];
              else
                v92 = 255;
              v94 = v88 * v90 + v89 * v92;
              v93 = v83;
            }
            *v93 = (unsigned __int16)(v94 + (v94 >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          v95 = &v17[2 * v19];
          if ((unint64_t)v95 >= v29)
            v96 = v81;
          else
            v96 = 0;
          v17 = &v95[2 * v96];
          v83 += 2 * v19;
          --v84;
        }
        while (v84);
        v12 += v23;
        v10 = &v83[2 * v24 - 1];
        v97 = (unint64_t)&v28[2 * v16];
        if (v97 >= v26)
          v98 = v82;
        else
          v98 = 0;
        v99 = (unsigned __int8 *)(v97 + 2 * v98);
        v100 = v29 + 2 * v98 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v100;
          v28 = v99;
          v17 = v99;
        }
        --v5;
      }
      while (v5);
      return result;
    case 5:
      v244 = -(uint64_t)v21;
      v245 = -(v16 * v20);
      do
      {
        v246 = v4;
        do
        {
          v247 = *v12;
          if (*v12)
          {
            v248 = (*v17 * v247 + ((*v17 * v247) >> 8) + 1) >> 8;
            v249 = v17[1] * v247 + ((v17[1] * v247) >> 8) + 1;
            v250 = v10[1];
            *v10 = (unsigned __int16)(v248 * v250
                                    + ((v249 >> 8) ^ 0xFF) * *v10
                                    + ((v248 * v250 + ((v249 >> 8) ^ 0xFF) * *v10) >> 8)
                                    + 1) >> 8;
            v10[1] = (unsigned __int16)((((v249 >> 8) ^ 0xFF) + (v249 >> 8)) * v250
                                      + (((((v249 >> 8) ^ 0xFF) + (v249 >> 8)) * v250) >> 8)
                                      + 1) >> 8;
          }
          v12 += v19;
          v251 = &v17[2 * v19];
          if ((unint64_t)v251 >= v29)
            v252 = v244;
          else
            v252 = 0;
          v17 = &v251[2 * v252];
          v10 += 2 * v19;
          --v246;
        }
        while (v246);
        v12 += v23;
        v10 += 2 * v24;
        v253 = (unint64_t)&v28[2 * v16];
        if (v253 >= v26)
          v254 = v245;
        else
          v254 = 0;
        v255 = (unsigned __int8 *)(v253 + 2 * v254);
        v256 = v29 + 2 * v254 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v256;
          v28 = v255;
          v17 = v255;
        }
        --v5;
      }
      while (v5);
      return result;
    case 6:
      v257 = -(uint64_t)v21;
      v258 = -(v16 * v20);
      do
      {
        v259 = v4;
        do
        {
          v260 = *v12;
          if (*v12)
          {
            v261 = v10[1];
            if ((_BYTE)v261 != 0xFF)
            {
              if (~(_BYTE)v261 == 255)
              {
                *v10 = (unsigned __int16)(*v17 * (_WORD)v260 + ((*v17 * v260) >> 8) + 1) >> 8;
                if (v22)
                  v262 = v17[1];
                else
                  v262 = 255;
                v265 = (v262 * v260 + ((v262 * v260) >> 8) + 1) >> 8;
              }
              else
              {
                result = *v17;
                v263 = (~(_BYTE)v261 * v260
                      + ((~(_BYTE)v261 * v260) >> 8)
                      + 1) >> 8;
                *v10 += (unsigned __int16)(v263 * result + ((v263 * result) >> 8) + 1) >> 8;
                if (v22)
                  v264 = v17[1];
                else
                  v264 = 255;
                v265 = v261 + ((v263 * v264 + ((v263 * v264) >> 8) + 1) >> 8);
              }
              v10[1] = v265;
            }
          }
          v12 += v19;
          v266 = &v17[2 * v19];
          if ((unint64_t)v266 >= v29)
            v267 = v257;
          else
            v267 = 0;
          v17 = &v266[2 * v267];
          v10 += 2 * v19;
          --v259;
        }
        while (v259);
        v12 += v23;
        v10 += 2 * v24;
        v268 = (unint64_t)&v28[2 * v16];
        if (v268 >= v26)
          v269 = v258;
        else
          v269 = 0;
        v270 = (unsigned __int8 *)(v268 + 2 * v269);
        v271 = v29 + 2 * v269 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v271;
          v28 = v270;
          v17 = v270;
        }
        --v5;
      }
      while (v5);
      return result;
    case 7:
      v101 = -(uint64_t)v21;
      v102 = -(v16 * v20);
      do
      {
        v103 = v4;
        do
        {
          v104 = *v12;
          if (*v12)
          {
            if (v104 == 255)
            {
              v105 = v17[1];
              *v10 = (unsigned __int16)(v105 * *v10 + ((v105 * *v10) >> 8) + 1) >> 8;
              v107 = v10 + 1;
              v106 = v10[1];
            }
            else
            {
              v106 = (v104 ^ 0xFF) + ((v17[1] * v104 + ((v17[1] * v104) >> 8) + 1) >> 8);
              *v10 = (unsigned __int16)(v106 * *v10 + ((v106 * *v10) >> 8) + 1) >> 8;
              v107 = v10 + 1;
              v105 = v10[1];
            }
            *v107 = (unsigned __int16)(v106 * v105 + ((v106 * v105) >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          v108 = &v17[2 * v19];
          if ((unint64_t)v108 >= v29)
            v109 = v101;
          else
            v109 = 0;
          v17 = &v108[2 * v109];
          --v103;
        }
        while (v103);
        v12 += v23;
        v10 += 2 * v24;
        v110 = (unint64_t)&v28[2 * v16];
        if (v110 >= v26)
          v111 = v102;
        else
          v111 = 0;
        v112 = (unsigned __int8 *)(v110 + 2 * v111);
        v113 = v29 + 2 * v111 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v113;
          v28 = v112;
          v17 = v112;
        }
        --v5;
      }
      while (v5);
      return result;
    case 8:
      v272 = -(uint64_t)v21;
      v273 = -(v16 * v20);
      do
      {
        v274 = v4;
        do
        {
          v275 = *v12;
          if (*v12)
          {
            if (v275 == 255)
            {
              v276 = v17[1] ^ 0xFF;
              *v10 = (unsigned __int16)(v276 * *v10 + ((v276 * *v10) >> 8) + 1) >> 8;
              v278 = v10 + 1;
              v277 = v10[1];
            }
            else
            {
              v277 = ((v17[1] * v275 + ((v17[1] * v275) >> 8) + 1) >> 8) ^ 0xFF;
              *v10 = (unsigned __int16)(v277 * *v10 + ((v277 * *v10) >> 8) + 1) >> 8;
              v278 = v10 + 1;
              v276 = v10[1];
            }
            *v278 = (unsigned __int16)(v277 * v276 + ((v277 * v276) >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          v279 = &v17[2 * v19];
          if ((unint64_t)v279 >= v29)
            v280 = v272;
          else
            v280 = 0;
          v17 = &v279[2 * v280];
          --v274;
        }
        while (v274);
        v12 += v23;
        v10 += 2 * v24;
        v281 = (unint64_t)&v28[2 * v16];
        if (v281 >= v26)
          v282 = v273;
        else
          v282 = 0;
        v283 = (unsigned __int8 *)(v281 + 2 * v282);
        v284 = v29 + 2 * v282 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v284;
          v28 = v283;
          v17 = v283;
        }
        --v5;
      }
      while (v5);
      return result;
    case 9:
      v114 = -(uint64_t)v21;
      v115 = -(v16 * v20);
      do
      {
        v116 = v4;
        do
        {
          v117 = *v12;
          if (*v12)
          {
            v118 = (*v17 * v117 + ((*v17 * v117) >> 8) + 1) >> 8;
            v119 = v17[1] * v117 + ((v17[1] * v117) >> 8) + 1;
            v120 = v10[1];
            result = *v10;
            v121 = (~(_BYTE)v117 + BYTE1(v119));
            *v10 = (unsigned __int16)(v118 * (v120 ^ 0xFF)
                                    + v121 * result
                                    + ((v118 * (v120 ^ 0xFF) + v121 * (_DWORD)result) >> 8)
                                    + 1) >> 8;
            v10[1] = (unsigned __int16)((v119 >> 8) * (v120 ^ 0xFF)
                                      + v121 * v120
                                      + (((v119 >> 8) * (v120 ^ 0xFF) + v121 * v120) >> 8)
                                      + 1) >> 8;
          }
          v12 += v19;
          v122 = &v17[2 * v19];
          if ((unint64_t)v122 >= v29)
            v123 = v114;
          else
            v123 = 0;
          v17 = &v122[2 * v123];
          v10 += 2 * v19;
          --v116;
        }
        while (v116);
        v12 += v23;
        v10 += 2 * v24;
        v124 = (unint64_t)&v28[2 * v16];
        if (v124 >= v26)
          v125 = v115;
        else
          v125 = 0;
        v126 = (unsigned __int8 *)(v124 + 2 * v125);
        v127 = v29 + 2 * v125 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v127;
          v28 = v126;
          v17 = v126;
        }
        --v5;
      }
      while (v5);
      return result;
    case 10:
      v285 = -(uint64_t)v21;
      v286 = -(v16 * v20);
      do
      {
        v287 = v4;
        do
        {
          v288 = *v12;
          if (*v12)
          {
            v289 = (*v17 * v288 + ((*v17 * v288) >> 8) + 1) >> 8;
            v290 = (v17[1] * v288 + ((v17[1] * v288) >> 8) + 1) >> 8;
            v291 = v10[1];
            result = v291 ^ 0xFFu;
            *v10 = (unsigned __int16)(v289 * (v291 ^ 0xFF)
                                    + (v290 ^ 0xFF) * *v10
                                    + ((v289 * (v291 ^ 0xFF) + (v290 ^ 0xFF) * *v10) >> 8)
                                    + 1) >> 8;
            v10[1] = (unsigned __int16)(v290 * (v291 ^ 0xFF)
                                      + (v290 ^ 0xFF) * v291
                                      + ((v290 * (v291 ^ 0xFF) + (v290 ^ 0xFF) * v291) >> 8)
                                      + 1) >> 8;
          }
          v12 += v19;
          v292 = &v17[2 * v19];
          if ((unint64_t)v292 >= v29)
            v293 = v285;
          else
            v293 = 0;
          v17 = &v292[2 * v293];
          v10 += 2 * v19;
          --v287;
        }
        while (v287);
        v12 += v23;
        v10 += 2 * v24;
        v294 = (unint64_t)&v28[2 * v16];
        if (v294 >= v26)
          v295 = v286;
        else
          v295 = 0;
        v296 = (unsigned __int8 *)(v294 + 2 * v295);
        v297 = v29 + 2 * v295 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v297;
          v28 = v296;
          v17 = v296;
        }
        --v5;
      }
      while (v5);
      return result;
    case 11:
      v128 = -(uint64_t)v21;
      v129 = -(v16 * v20);
      do
      {
        v130 = v4;
        do
        {
          v131 = *v12;
          if (*v12)
          {
            if (v488)
              v132 = v10[1];
            else
              v132 = 255;
            v133 = *v17 * v131 + ((*v17 * v131) >> 8) + 1;
            result = *v10;
            if (v22)
              LOBYTE(v131) = (unsigned __int16)(v17[1] * (_WORD)v131 + ((v17[1] * v131) >> 8) + 1) >> 8;
            v134 = ((v131 - BYTE1(v133)) | (v131 << 16))
                 + (v132 - result)
                 + (v132 << 16);
            v135 = (255 * ((v134 >> 8) & 0x10001)) | v134;
            *v10 = BYTE2(v135) - v135;
            v10[1] = BYTE2(v135);
          }
          v12 += v19;
          v136 = &v17[2 * v19];
          if ((unint64_t)v136 >= v29)
            v137 = v128;
          else
            v137 = 0;
          v17 = &v136[2 * v137];
          v10 += 2 * v19;
          --v130;
        }
        while (v130);
        v12 += v23;
        v10 += 2 * v24;
        v138 = (unint64_t)&v28[2 * v16];
        if (v138 >= v26)
          v139 = v129;
        else
          v139 = 0;
        v140 = (unsigned __int8 *)(v138 + 2 * v139);
        v141 = v29 + 2 * v139 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v141;
          v28 = v140;
          v17 = v140;
        }
        --v5;
      }
      while (v5);
      return result;
    case 12:
      v142 = -(uint64_t)v21;
      v143 = -(v16 * v20);
      do
      {
        v144 = v4;
        do
        {
          v145 = *v12;
          if (*v12)
          {
            v146 = (*v17 * v145 + ((*v17 * v145) >> 8) + 1) >> 8;
            if (v22)
              LOBYTE(v145) = (unsigned __int16)(v17[1] * (_WORD)v145 + ((v17[1] * v145) >> 8) + 1) >> 8;
            v147 = ((v146 + *(_WORD *)v10) | (*(unsigned __int16 *)v10 << 8) & 0xFF0000)
                 + (v145 << 16);
            v148 = (255 * ((v147 >> 8) & 0x10001)) | v147;
            *v10 = v148;
            v10[1] = BYTE2(v148);
          }
          v12 += v19;
          v149 = &v17[2 * v19];
          if ((unint64_t)v149 >= v29)
            v150 = v142;
          else
            v150 = 0;
          v17 = &v149[2 * v150];
          v10 += 2 * v19;
          --v144;
        }
        while (v144);
        v12 += v23;
        v10 += 2 * v24;
        v151 = (unint64_t)&v28[2 * v16];
        if (v151 >= v26)
          v152 = v143;
        else
          v152 = 0;
        v153 = (unsigned __int8 *)(v151 + 2 * v152);
        v154 = v29 + 2 * v152 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v154;
          v28 = v153;
          v17 = v153;
        }
        --v5;
      }
      while (v5);
      return result;
    case 13:
      v298 = v19;
      v299 = -(uint64_t)v21;
      v447 = -(v16 * v20);
      v300 = 2 * v19;
      while (1)
      {
        v466 = v28;
        v479 = v5;
        v301 = v4;
        do
        {
          v302 = *v12;
          if (*v12)
          {
            v303 = v17[1] * v302 + ((v17[1] * v302) >> 8) + 1;
            v304 = v303 >> 8;
            if (!v22)
              LOBYTE(v304) = *v12;
            if ((_BYTE)v304)
            {
              v305 = (*v17 * v302 + ((*v17 * v302) >> 8) + 1) >> 8;
              if (v488)
              {
                v306 = v10[1];
                if (!v10[1])
                {
                  *v10 = v305;
                  v10[1] = v304;
                  goto LABEL_417;
                }
              }
              else
              {
                v306 = 255;
              }
              v2 = v2 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v26 = v26 & 0xFFFFFFFFFFFF0000 | v303 & 0xFF00 | v305;
              result = PDAmultiplyPDA(v2, v306, v26, v304);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_417:
          v12 += v298;
          v307 = &v17[2 * v298];
          if ((unint64_t)v307 >= v29)
            v308 = v299;
          else
            v308 = 0;
          v17 = &v307[2 * v308];
          v10 += v300;
          --v301;
        }
        while (v301);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v466;
        v309 = (unint64_t)&v466[2 * v458];
        v310 = v447;
        if (v309 < v455)
          v310 = 0;
        v311 = (unsigned __int8 *)(v309 + 2 * v310);
        v312 = v29 + 2 * v310 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v312;
          v28 = v311;
          v17 = v311;
        }
        v5 = v479 - 1;
        v4 = v460;
        if (v479 == 1)
          return result;
      }
    case 14:
      v155 = -(uint64_t)v21;
      v156 = -(v16 * v20);
      while (1)
      {
        v157 = v4;
        do
        {
          v158 = *v12;
          if (*v12)
          {
            v159 = (v17[1] * v158 + ((v17[1] * v158) >> 8) + 1) >> 8;
            if (!v22)
              LOBYTE(v159) = *v12;
            if ((_BYTE)v159)
            {
              v160 = (*v17 * v158 + ((*v17 * v158) >> 8) + 1) >> 8;
              if (v488)
              {
                v161 = v10[1];
                if (!v10[1])
                  goto LABEL_206;
              }
              else
              {
                v161 = 255;
              }
              v162 = *v10;
              result = v162 ^ 0xFFu;
              v160 = ((_DWORD)result * v160
                    - v162
                    + (v162 << 8)
                    + ((result * v160 - v162 + (v162 << 8)) >> 8)
                    + 1) >> 8;
              v159 = (255 * (v161 + v159)
                    - v161 * v159
                    + ((255 * (v161 + v159) - v161 * v159) >> 8)
                    + 1) >> 8;
LABEL_206:
              *v10 = v160;
              v10[1] = v159;
            }
          }
          v12 += v19;
          v163 = &v17[2 * v19];
          if ((unint64_t)v163 >= v29)
            v164 = v155;
          else
            v164 = 0;
          v17 = &v163[2 * v164];
          v10 += 2 * v19;
          --v157;
        }
        while (v157);
        v12 += v23;
        v10 += 2 * v24;
        v165 = (unint64_t)&v28[2 * v16];
        if (v165 >= v26)
          v166 = v156;
        else
          v166 = 0;
        v167 = (unsigned __int8 *)(v165 + 2 * v166);
        v168 = v29 + 2 * v166 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v168;
          v28 = v167;
          v17 = v167;
        }
        if (!--v5)
          return result;
      }
    case 15:
      v169 = v19;
      v170 = -(uint64_t)v21;
      v442 = -(v16 * v20);
      v171 = 2 * v19;
      while (1)
      {
        v461 = v28;
        v474 = v5;
        v172 = v4;
        do
        {
          v173 = *v12;
          if (*v12)
          {
            v174 = v17[1] * v173 + ((v17[1] * v173) >> 8) + 1;
            v175 = v174 >> 8;
            if (!v22)
              LOBYTE(v175) = *v12;
            if ((_BYTE)v175)
            {
              v176 = (*v17 * v173 + ((*v17 * v173) >> 8) + 1) >> 8;
              if (v488)
              {
                v177 = v10[1];
                if (!v10[1])
                {
                  *v10 = v176;
                  v10[1] = v175;
                  goto LABEL_230;
                }
              }
              else
              {
                v177 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v174 & 0xFF00 | v176;
              result = PDAoverlayPDA(v26, v177, v2, v175);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_230:
          v12 += v169;
          v178 = &v17[2 * v169];
          if ((unint64_t)v178 >= v29)
            v179 = v170;
          else
            v179 = 0;
          v17 = &v178[2 * v179];
          v10 += v171;
          --v172;
        }
        while (v172);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v461;
        v180 = (unint64_t)&v461[2 * v458];
        v181 = v442;
        if (v180 < v455)
          v181 = 0;
        v182 = (unsigned __int8 *)(v180 + 2 * v181);
        v183 = v29 + 2 * v181 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v183;
          v28 = v182;
          v17 = v182;
        }
        v5 = v474 - 1;
        v4 = v460;
        if (v474 == 1)
          return result;
      }
    case 16:
      v184 = v19;
      v185 = -(uint64_t)v21;
      v443 = -(v16 * v20);
      v186 = 2 * v19;
      while (1)
      {
        v462 = v28;
        v475 = v5;
        v187 = v4;
        do
        {
          v188 = *v12;
          if (*v12)
          {
            v189 = v17[1] * v188 + ((v17[1] * v188) >> 8) + 1;
            v190 = v189 >> 8;
            if (!v22)
              LOBYTE(v190) = *v12;
            if ((_BYTE)v190)
            {
              v191 = (*v17 * v188 + ((*v17 * v188) >> 8) + 1) >> 8;
              if (v488)
              {
                v192 = v10[1];
                if (!v10[1])
                {
                  *v10 = v191;
                  v10[1] = v190;
                  goto LABEL_252;
                }
              }
              else
              {
                v192 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v189 & 0xFF00 | v191;
              result = PDAdarkenPDA(v26, v192, v2, v190);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_252:
          v12 += v184;
          v193 = &v17[2 * v184];
          if ((unint64_t)v193 >= v29)
            v194 = v185;
          else
            v194 = 0;
          v17 = &v193[2 * v194];
          v10 += v186;
          --v187;
        }
        while (v187);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v462;
        v195 = (unint64_t)&v462[2 * v458];
        v196 = v443;
        if (v195 < v455)
          v196 = 0;
        v197 = (unsigned __int8 *)(v195 + 2 * v196);
        v198 = v29 + 2 * v196 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v198;
          v28 = v197;
          v17 = v197;
        }
        v5 = v475 - 1;
        v4 = v460;
        if (v475 == 1)
          return result;
      }
    case 17:
      v313 = v19;
      v314 = -(uint64_t)v21;
      v448 = -(v16 * v20);
      v315 = 2 * v19;
      while (1)
      {
        v467 = v28;
        v480 = v5;
        v316 = v4;
        do
        {
          v317 = *v12;
          if (*v12)
          {
            v318 = v17[1] * v317 + ((v17[1] * v317) >> 8) + 1;
            v319 = v318 >> 8;
            if (!v22)
              LOBYTE(v319) = *v12;
            if ((_BYTE)v319)
            {
              v320 = (*v17 * v317 + ((*v17 * v317) >> 8) + 1) >> 8;
              if (v488)
              {
                v321 = v10[1];
                if (!v10[1])
                {
                  *v10 = v320;
                  v10[1] = v319;
                  goto LABEL_439;
                }
              }
              else
              {
                v321 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v318 & 0xFF00 | v320;
              result = PDAlightenPDA(v26, v321, v2, v319);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_439:
          v12 += v313;
          v322 = &v17[2 * v313];
          if ((unint64_t)v322 >= v29)
            v323 = v314;
          else
            v323 = 0;
          v17 = &v322[2 * v323];
          v10 += v315;
          --v316;
        }
        while (v316);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v467;
        v324 = (unint64_t)&v467[2 * v458];
        v325 = v448;
        if (v324 < v455)
          v325 = 0;
        v326 = (unsigned __int8 *)(v324 + 2 * v325);
        v327 = v29 + 2 * v325 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v327;
          v28 = v326;
          v17 = v326;
        }
        v5 = v480 - 1;
        v4 = v460;
        if (v480 == 1)
          return result;
      }
    case 18:
      v328 = v19;
      v329 = -(uint64_t)v21;
      v449 = -(v16 * v20);
      v330 = 2 * v19;
      while (1)
      {
        v468 = v28;
        v481 = v5;
        v331 = v4;
        do
        {
          v332 = *v12;
          if (*v12)
          {
            v333 = v17[1] * v332 + ((v17[1] * v332) >> 8) + 1;
            v334 = v333 >> 8;
            if (!v22)
              LOBYTE(v334) = *v12;
            if ((_BYTE)v334)
            {
              v335 = (*v17 * v332 + ((*v17 * v332) >> 8) + 1) >> 8;
              if (v488)
              {
                v336 = v10[1];
                if (!v10[1])
                {
                  *v10 = v335;
                  v10[1] = v334;
                  goto LABEL_461;
                }
              }
              else
              {
                v336 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v333 & 0xFF00 | v335;
              result = PDAcolordodgePDA(v26, v336, v2, v334);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_461:
          v12 += v328;
          v337 = &v17[2 * v328];
          if ((unint64_t)v337 >= v29)
            v338 = v329;
          else
            v338 = 0;
          v17 = &v337[2 * v338];
          v10 += v330;
          --v331;
        }
        while (v331);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v468;
        v339 = (unint64_t)&v468[2 * v458];
        v340 = v449;
        if (v339 < v455)
          v340 = 0;
        v341 = (unsigned __int8 *)(v339 + 2 * v340);
        v342 = v29 + 2 * v340 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v342;
          v28 = v341;
          v17 = v341;
        }
        v5 = v481 - 1;
        v4 = v460;
        if (v481 == 1)
          return result;
      }
    case 19:
      v343 = v19;
      v344 = -(uint64_t)v21;
      v450 = -(v16 * v20);
      v345 = 2 * v19;
      while (1)
      {
        v469 = v28;
        v482 = v5;
        v346 = v4;
        do
        {
          v347 = *v12;
          if (*v12)
          {
            v348 = v17[1] * v347 + ((v17[1] * v347) >> 8) + 1;
            v349 = v348 >> 8;
            if (!v22)
              LOBYTE(v349) = *v12;
            if ((_BYTE)v349)
            {
              v350 = (*v17 * v347 + ((*v17 * v347) >> 8) + 1) >> 8;
              if (v488)
              {
                v351 = v10[1];
                if (!v10[1])
                {
                  *v10 = v350;
                  v10[1] = v349;
                  goto LABEL_483;
                }
              }
              else
              {
                v351 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v348 & 0xFF00 | v350;
              result = PDAcolorburnPDA(v26, v351, v2, v349);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_483:
          v12 += v343;
          v352 = &v17[2 * v343];
          if ((unint64_t)v352 >= v29)
            v353 = v344;
          else
            v353 = 0;
          v17 = &v352[2 * v353];
          v10 += v345;
          --v346;
        }
        while (v346);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v469;
        v354 = (unint64_t)&v469[2 * v458];
        v355 = v450;
        if (v354 < v455)
          v355 = 0;
        v356 = (unsigned __int8 *)(v354 + 2 * v355);
        v357 = v29 + 2 * v355 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v357;
          v28 = v356;
          v17 = v356;
        }
        v5 = v482 - 1;
        v4 = v460;
        if (v482 == 1)
          return result;
      }
    case 20:
      v358 = v19;
      v359 = -(uint64_t)v21;
      v451 = -(v16 * v20);
      v360 = 2 * v19;
      while (1)
      {
        v470 = v28;
        v483 = v5;
        v361 = v4;
        do
        {
          v362 = *v12;
          if (*v12)
          {
            v363 = v17[1] * v362 + ((v17[1] * v362) >> 8) + 1;
            v364 = v363 >> 8;
            if (!v22)
              LOBYTE(v364) = *v12;
            if ((_BYTE)v364)
            {
              v365 = (*v17 * v362 + ((*v17 * v362) >> 8) + 1) >> 8;
              if (v488)
              {
                v366 = v10[1];
                if (!v10[1])
                {
                  *v10 = v365;
                  v10[1] = v364;
                  goto LABEL_505;
                }
              }
              else
              {
                v366 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v363 & 0xFF00 | v365;
              result = PDAsoftlightPDA(v26, v366, v2, v364);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_505:
          v12 += v358;
          v367 = &v17[2 * v358];
          if ((unint64_t)v367 >= v29)
            v368 = v359;
          else
            v368 = 0;
          v17 = &v367[2 * v368];
          v10 += v360;
          --v361;
        }
        while (v361);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v470;
        v369 = v451;
        if ((unint64_t)v470 < v455)
          v369 = 0;
        v370 = v29 + 2 * v369;
        v371 = &v470[2 * v369];
        v372 = v370 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v372;
          v28 = v371;
          v17 = v371;
        }
        v5 = v483 - 1;
        v4 = v460;
        if (v483 == 1)
          return result;
      }
    case 21:
      v373 = v19;
      v374 = -(uint64_t)v21;
      v452 = -(v16 * v20);
      v375 = 2 * v19;
      while (1)
      {
        v471 = v28;
        v484 = v5;
        v376 = v4;
        do
        {
          v377 = *v12;
          if (*v12)
          {
            v378 = v17[1] * v377 + ((v17[1] * v377) >> 8) + 1;
            v379 = v378 >> 8;
            if (!v22)
              LOBYTE(v379) = *v12;
            if ((_BYTE)v379)
            {
              v380 = (*v17 * v377 + ((*v17 * v377) >> 8) + 1) >> 8;
              if (v488)
              {
                v381 = v10[1];
                if (!v10[1])
                {
                  *v10 = v380;
                  v10[1] = v379;
                  goto LABEL_527;
                }
              }
              else
              {
                v381 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v378 & 0xFF00 | v380;
              result = PDAhardlightPDA(v26, v381, v2, v379);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_527:
          v12 += v373;
          v382 = &v17[2 * v373];
          if ((unint64_t)v382 >= v29)
            v383 = v374;
          else
            v383 = 0;
          v17 = &v382[2 * v383];
          v10 += v375;
          --v376;
        }
        while (v376);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v471;
        v384 = (unint64_t)&v471[2 * v458];
        v385 = v452;
        if (v384 < v455)
          v385 = 0;
        v386 = (unsigned __int8 *)(v384 + 2 * v385);
        v387 = v29 + 2 * v385 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v387;
          v28 = v386;
          v17 = v386;
        }
        v5 = v484 - 1;
        v4 = v460;
        if (v484 == 1)
          return result;
      }
    case 22:
      v388 = v19;
      v389 = -(uint64_t)v21;
      v453 = -(v16 * v20);
      v390 = 2 * v19;
      while (1)
      {
        v472 = v28;
        v485 = v5;
        v391 = v4;
        do
        {
          v392 = *v12;
          if (*v12)
          {
            v393 = v17[1] * v392 + ((v17[1] * v392) >> 8) + 1;
            v394 = v393 >> 8;
            if (!v22)
              LOBYTE(v394) = *v12;
            if ((_BYTE)v394)
            {
              v395 = (*v17 * v392 + ((*v17 * v392) >> 8) + 1) >> 8;
              if (v488)
              {
                v396 = v10[1];
                if (!v10[1])
                {
                  *v10 = v395;
                  v10[1] = v394;
                  goto LABEL_549;
                }
              }
              else
              {
                v396 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v393 & 0xFF00 | v395;
              result = PDAdifferencePDA(v26, v396, v2, v394);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_549:
          v12 += v388;
          v397 = &v17[2 * v388];
          if ((unint64_t)v397 >= v29)
            v398 = v389;
          else
            v398 = 0;
          v17 = &v397[2 * v398];
          v10 += v390;
          --v391;
        }
        while (v391);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v472;
        v399 = (unint64_t)&v472[2 * v458];
        v400 = v453;
        if (v399 < v455)
          v400 = 0;
        v401 = (unsigned __int8 *)(v399 + 2 * v400);
        v402 = v29 + 2 * v400 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v402;
          v28 = v401;
          v17 = v401;
        }
        v5 = v485 - 1;
        v4 = v460;
        if (v485 == 1)
          return result;
      }
    case 23:
      v403 = -(uint64_t)v21;
      v404 = -(v16 * v20);
      while (1)
      {
        v405 = v4;
        do
        {
          v406 = *v12;
          if (*v12)
          {
            v407 = (v17[1] * v406 + ((v17[1] * v406) >> 8) + 1) >> 8;
            if (!v22)
              LOBYTE(v407) = *v12;
            if ((_BYTE)v407)
            {
              v408 = (*v17 * v406 + ((*v17 * v406) >> 8) + 1) >> 8;
              if (v488)
              {
                v409 = v10[1];
                if (!v10[1])
                  goto LABEL_571;
              }
              else
              {
                v409 = 255;
              }
              v410 = *v10;
              result = 255 * (v408 + v410);
              v408 = ((_DWORD)result - 2 * v408 * v410 + ((result - 2 * v408 * v410) >> 8) + 1) >> 8;
              v407 = (255 * (v409 + v407)
                    - v409 * v407
                    + ((255 * (v409 + v407) - v409 * v407) >> 8)
                    + 1) >> 8;
LABEL_571:
              *v10 = v408;
              v10[1] = v407;
            }
          }
          v12 += v19;
          v411 = &v17[2 * v19];
          if ((unint64_t)v411 >= v29)
            v412 = v403;
          else
            v412 = 0;
          v17 = &v411[2 * v412];
          v10 += 2 * v19;
          --v405;
        }
        while (v405);
        v12 += v23;
        v10 += 2 * v24;
        v413 = (unint64_t)&v28[2 * v16];
        if (v413 >= v26)
          v414 = v404;
        else
          v414 = 0;
        v415 = (unsigned __int8 *)(v413 + 2 * v414);
        v416 = v29 + 2 * v414 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          v29 = v416;
          v28 = v415;
          v17 = v415;
        }
        if (!--v5)
          return result;
      }
    case 24:
      v199 = v19;
      v200 = -(uint64_t)v21;
      v444 = -(v16 * v20);
      v201 = 2 * v19;
      while (1)
      {
        v463 = v28;
        v476 = v5;
        v202 = v4;
        do
        {
          v203 = *v12;
          if (*v12)
          {
            v204 = v17[1] * v203 + ((v17[1] * v203) >> 8) + 1;
            v205 = v204 >> 8;
            if (!v22)
              LOBYTE(v205) = *v12;
            if ((_BYTE)v205)
            {
              v206 = (*v17 * v203 + ((*v17 * v203) >> 8) + 1) >> 8;
              if (v488)
              {
                v207 = v10[1];
                if (!v10[1])
                {
                  *v10 = v206;
                  v10[1] = v205;
                  goto LABEL_274;
                }
              }
              else
              {
                v207 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v204 & 0xFF00 | v206;
              result = PDAhuePDA(v26, v207, v2, v205);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_274:
          v12 += v199;
          v208 = &v17[2 * v199];
          if ((unint64_t)v208 >= v29)
            v209 = v200;
          else
            v209 = 0;
          v17 = &v208[2 * v209];
          v10 += v201;
          --v202;
        }
        while (v202);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v463;
        v210 = (unint64_t)&v463[2 * v458];
        v211 = v444;
        if (v210 < v455)
          v211 = 0;
        v212 = (unsigned __int8 *)(v210 + 2 * v211);
        v213 = v29 + 2 * v211 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v213;
          v28 = v212;
          v17 = v212;
        }
        v5 = v476 - 1;
        v4 = v460;
        if (v476 == 1)
          return result;
      }
    case 25:
      v214 = v19;
      v215 = -(uint64_t)v21;
      v445 = -(v16 * v20);
      v216 = 2 * v19;
      while (1)
      {
        v464 = v28;
        v477 = v5;
        v217 = v4;
        do
        {
          v218 = *v12;
          if (*v12)
          {
            v219 = v17[1] * v218 + ((v17[1] * v218) >> 8) + 1;
            v220 = v219 >> 8;
            if (!v22)
              LOBYTE(v220) = *v12;
            if ((_BYTE)v220)
            {
              v221 = (*v17 * v218 + ((*v17 * v218) >> 8) + 1) >> 8;
              if (v488)
              {
                v222 = v10[1];
                if (!v10[1])
                {
                  *v10 = v221;
                  v10[1] = v220;
                  goto LABEL_296;
                }
              }
              else
              {
                v222 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | v219 & 0xFF00 | v221;
              result = PDAhuePDA(v26, v222, v2, v220);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_296:
          v12 += v214;
          v223 = &v17[2 * v214];
          if ((unint64_t)v223 >= v29)
            v224 = v215;
          else
            v224 = 0;
          v17 = &v223[2 * v224];
          v10 += v216;
          --v217;
        }
        while (v217);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v464;
        v225 = (unint64_t)&v464[2 * v458];
        v226 = v445;
        if (v225 < v455)
          v226 = 0;
        v227 = (unsigned __int8 *)(v225 + 2 * v226);
        v228 = v29 + 2 * v226 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v228;
          v28 = v227;
          v17 = v227;
        }
        v5 = v477 - 1;
        v4 = v460;
        if (v477 == 1)
          return result;
      }
    case 26:
      v417 = v19;
      v418 = -(uint64_t)v21;
      v454 = -(v16 * v20);
      v419 = 2 * v19;
      while (1)
      {
        v473 = v28;
        v486 = v5;
        v420 = v4;
        do
        {
          v421 = *v12;
          if (*v12)
          {
            v422 = v17[1] * v421 + ((v17[1] * v421) >> 8) + 1;
            v423 = v422 >> 8;
            if (!v22)
              LOBYTE(v423) = *v12;
            if ((_BYTE)v423)
            {
              v424 = (*v17 * v421 + ((*v17 * v421) >> 8) + 1) >> 8;
              if (v488)
              {
                v425 = v10[1];
                if (!v10[1])
                {
                  *v10 = v424;
                  v10[1] = v423;
                  goto LABEL_595;
                }
              }
              else
              {
                v425 = 255;
              }
              v26 = v26 & 0xFFFFFFFFFFFF0000 | v422 & 0xFF00 | v424;
              v2 = v2 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              result = PDAhuePDA(v26, v423, v2, v425);
              v22 = v487;
              *(_WORD *)v10 = result;
            }
          }
LABEL_595:
          v12 += v417;
          v426 = &v17[2 * v417];
          if ((unint64_t)v426 >= v29)
            v427 = v418;
          else
            v427 = 0;
          v17 = &v426[2 * v427];
          v10 += v419;
          --v420;
        }
        while (v420);
        v12 += v459;
        v10 += 2 * v457;
        v28 = v473;
        v428 = (unint64_t)&v473[2 * v458];
        v429 = v454;
        if (v428 < v455)
          v429 = 0;
        v430 = (unsigned __int8 *)(v428 + 2 * v429);
        v431 = v29 + 2 * v429 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          v29 = v431;
          v28 = v430;
          v17 = v430;
        }
        v5 = v486 - 1;
        v4 = v460;
        if (v486 == 1)
          return result;
      }
    case 27:
      v229 = v19;
      v230 = -(uint64_t)v21;
      v446 = -(v16 * v20);
      v231 = 2 * v19;
      break;
    default:
      return result;
  }
  do
  {
    v465 = v28;
    v478 = v5;
    v232 = v4;
    do
    {
      v233 = *v12;
      if (*v12)
      {
        v234 = v17[1] * v233 + ((v17[1] * v233) >> 8) + 1;
        v235 = v234 >> 8;
        if (!v22)
          LOBYTE(v235) = *v12;
        if ((_BYTE)v235)
        {
          v236 = (*v17 * v233 + ((*v17 * v233) >> 8) + 1) >> 8;
          if (v488)
          {
            v237 = v10[1];
            if (!v10[1])
            {
              *v10 = v236;
              v10[1] = v235;
              goto LABEL_318;
            }
          }
          else
          {
            v237 = 255;
          }
          v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
          v2 = v2 & 0xFFFFFFFFFFFF0000 | v234 & 0xFF00 | v236;
          result = PDAhuePDA(v26, v237, v2, v235);
          v22 = v487;
          *(_WORD *)v10 = result;
        }
      }
LABEL_318:
      v12 += v229;
      v238 = &v17[2 * v229];
      if ((unint64_t)v238 >= v29)
        v239 = v230;
      else
        v239 = 0;
      v17 = &v238[2 * v239];
      v10 += v231;
      --v232;
    }
    while (v232);
    v12 += v459;
    v10 += 2 * v457;
    v28 = v465;
    v240 = (unint64_t)&v465[2 * v458];
    v241 = v446;
    if (v240 < v455)
      v241 = 0;
    v242 = (unsigned __int8 *)(v240 + 2 * v241);
    v243 = v29 + 2 * v241 + 2 * v458;
    if (v456)
    {
      v17 += 2 * v458;
    }
    else
    {
      v29 = v243;
      v28 = v242;
      v17 = v242;
    }
    v5 = v478 - 1;
    v4 = v460;
  }
  while (v478 != 1);
  return result;
}

uint64_t GRAYA8_sample_W8_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  unint64_t v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  int v45;
  int32x2_t v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int8x8_t v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unint64_t v53;
  unsigned __int8 *v54;
  __int32 v55;
  unsigned __int8 *v56;
  __int32 v57;
  int32x2_t v58;
  int v59;
  __int8 *v60;
  unint64_t v61;
  unint64_t v62;
  __int8 *v63;
  __int8 *v64;
  unsigned int v65;
  int8x8_t v66;
  uint32x2_t v67;
  int32x2_t v68;
  int32x2_t v69;
  int32x2_t v70;
  int8x8_t v71;
  int32x2_t v72;
  int8x8_t v73;
  int8x8_t v74;
  uint32x2_t v75;
  int32x2_t v76;
  int32x2_t v77;
  unsigned __int8 *v78;
  unsigned int v79;
  int v80;
  __int8 *v81;
  int8x8_t v82;
  uint32x2_t v83;
  int32x2_t v84;
  unsigned __int8 *v85;
  __int8 *v86;
  unsigned int v87;
  uint32x2_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned __int8 *v95;
  unsigned __int8 *v96;
  unsigned __int8 *v97;
  unint64_t v98;
  int v99;
  unsigned int v100;
  uint64_t v101;
  unsigned __int8 *v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v104 = *(_QWORD *)(result + 80);
  v106 = *(_QWORD *)(result + 88);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 2;
  v12 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_DWORD *)(result + 260) - 1;
  v14 = *(unsigned int *)(result + 256);
  v15 = v4 + v14 + (v13 * v6);
  v16 = (__int8 *)(v5 + v14 + (v13 * v7));
  v17 = (unsigned __int8 *)(v15 - 1);
  v103 = *(_DWORD *)(result + 188);
  v102 = (unsigned __int8 *)(v15 - 4);
  v105 = *(_QWORD *)(result + 64);
  v107 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v107)
      {
        if (a3 <= v106)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v106;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_39;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v27 = v103 | v25;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v107 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_39;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v27 = v103 | v21;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v105)
        break;
      v29 = *(_QWORD *)(result + 192);
      v30 = v105 - *(_QWORD *)(result + 200);
      v31 = a2 - v30 + (v29 >> 1);
      if (v31 >= 1)
      {
        if (v31 < v29)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v31) >> 32) >> 15)) | v103;
        v32 = v30 + 0x1000000;
        v33 = 32;
        goto LABEL_26;
      }
LABEL_39:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 2;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v104)
    {
      v33 = ((unint64_t)a2 >> 26) & 0x3C;
      v32 = a2;
      goto LABEL_26;
    }
    v34 = *(_QWORD *)(result + 192);
    v35 = *(_QWORD *)(result + 200) + v104;
    v36 = v35 - a2 + (v34 >> 1);
    if (v36 < 1)
      goto LABEL_39;
    if (v36 < v34)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v103;
    v32 = v35 - 0x1000000;
    v33 = 28;
LABEL_26:
    if (v27 < 0x400000)
      goto LABEL_39;
    v37 = v28 >> 32;
    v38 = v4 + SHIDWORD(v28) * (uint64_t)v6;
    v39 = v38 + (v32 >> 32);
    v40 = *(unsigned __int8 **)(result + 32);
    if ((unint64_t)v17 >= v39)
      v41 = (unsigned __int8 *)(v38 + (v32 >> 32));
    else
      v41 = v17;
    if (v41 < v40)
      v41 = *(unsigned __int8 **)(result + 32);
    if (v5)
    {
      v42 = v5 + (int)v37 * (uint64_t)v7 + (v32 >> 32);
      v43 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v42)
        v44 = (unsigned __int8 *)v42;
      else
        v44 = (unsigned __int8 *)v16;
      if (v44 >= v43)
        v43 = v44;
      v45 = *v43;
    }
    else
    {
      v42 = 0;
      v45 = 255;
    }
    v46.i32[0] = *v41;
    v46.i32[1] = v45;
    if (!v8)
      goto LABEL_101;
    v47 = *(_DWORD *)(v8 + (v33 | v26));
LABEL_45:
    v48 = v47 & 0xF;
    v49 = HIBYTE(v47) & 3;
    v50 = vand_s8((int8x8_t)v46, (int8x8_t)0xFF000000FFLL);
    switch(v48)
    {
      case 1:
        v78 = (unsigned __int8 *)(v39 + SBYTE1(v47) * (uint64_t)v6);
        if (v102 < v78)
          v78 = v102;
        if (v78 < v40)
          v78 = v40;
        v79 = *v78;
        v80 = 255;
        if (v5)
        {
          v81 = (__int8 *)(v42 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v81)
            v81 = v16;
          if ((unint64_t)v81 < *(_QWORD *)(result + 40))
            v81 = *(__int8 **)(result + 40);
          v80 = *v81;
        }
        v82 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v49 + 1]);
        v83 = (uint32x2_t)vand_s8(v82, v50);
        v84 = vdup_n_s32(v49 + 1);
LABEL_99:
        v88 = (uint32x2_t)vneg_s32(v84);
        v76 = vsub_s32(v46, (int32x2_t)vshl_u32(v83, v88));
        v77 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v82, (int8x8_t)__PAIR64__(v80, v79)), v88);
LABEL_100:
        v46 = vadd_s32(v76, v77);
        break;
      case 2:
        v85 = (unsigned __int8 *)(v39 + SBYTE2(v47));
        if (v17 < v85)
          v85 = v17;
        if (v85 < v40)
          v85 = v40;
        v79 = *v85;
        v80 = 255;
        if (v5)
        {
          v86 = (__int8 *)(v42 + SBYTE2(v47));
          if (v16 < v86)
            v86 = v16;
          if ((unint64_t)v86 < *(_QWORD *)(result + 40))
            v86 = *(__int8 **)(result + 40);
          v80 = *v86;
        }
        v87 = (v47 >> 28) & 3;
        v82 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v87 + 1]);
        v83 = (uint32x2_t)vand_s8(v82, v50);
        v84 = vdup_n_s32(v87 + 1);
        goto LABEL_99;
      case 3:
        v51 = (unsigned __int8 *)(v39 + SBYTE2(v47));
        if (v17 < v51)
          v51 = v17;
        if (v51 < v40)
          v51 = v40;
        v52 = *v51;
        v53 = v39 + SBYTE1(v47) * (uint64_t)v6;
        if ((unint64_t)v17 >= v53)
          v54 = (unsigned __int8 *)(v39 + SBYTE1(v47) * (uint64_t)v6);
        else
          v54 = v17;
        if (v54 < v40)
          v54 = v40;
        v55 = *v54;
        v56 = (unsigned __int8 *)(v53 + SBYTE2(v47));
        if (v17 < v56)
          v56 = v17;
        if (v56 < v40)
          v56 = v40;
        v57 = *v56;
        v58 = (int32x2_t)0xFF000000FFLL;
        v59 = 255;
        if (v5)
        {
          v60 = (__int8 *)(v42 + SBYTE2(v47));
          v61 = *(_QWORD *)(result + 40);
          if (v16 < v60)
            v60 = v16;
          if ((unint64_t)v60 < v61)
            v60 = *(__int8 **)(result + 40);
          v59 = *v60;
          v62 = v42 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v62)
            v63 = (__int8 *)(v42 + SBYTE1(v47) * (uint64_t)v7);
          else
            v63 = v16;
          if ((unint64_t)v63 < v61)
            v63 = *(__int8 **)(result + 40);
          v64 = (__int8 *)(v62 + SBYTE2(v47));
          if (v16 < v64)
            v64 = v16;
          if ((unint64_t)v64 < v61)
            v64 = *(__int8 **)(result + 40);
          v58.i8[0] = *v63;
          v58.i8[4] = *v64;
        }
        v65 = (v47 >> 28) & 3;
        v66 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v49 + 1]);
        v67 = (uint32x2_t)vneg_s32(vdup_n_s32(v49 + 1));
        v68 = vsub_s32(v46, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v66, v50), v67));
        v69 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v66, (int8x8_t)__PAIR64__(v59, v52)), v67);
        v70 = vsub_s32((int32x2_t)__PAIR64__(v59, v52), v69);
        v69.i32[0] = v55;
        v71 = vand_s8(v66, (int8x8_t)0xFF000000FFLL);
        v72 = vadd_s32(v68, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v71, (int8x8_t)vzip1_s32(v69, v58)), v67));
        v58.i32[0] = v57;
        v73 = (int8x8_t)vadd_s32(v70, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v71, (int8x8_t)v58), v67));
        v74 = vand_s8((int8x8_t)vdup_n_s32(interpolate_graya[2 * v65 + 1]), (int8x8_t)0xFF000000FFLL);
        v75 = (uint32x2_t)vneg_s32(vdup_n_s32(v65 + 1));
        v76 = vsub_s32(v72, (int32x2_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v72, v74), v75));
        v77 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v73, v74), v75);
        goto LABEL_100;
    }
LABEL_101:
    *(_BYTE *)(v11 + 2) = v46.i8[0];
    v11 += 2;
    *(_BYTE *)(v11 + 1) = v46.i8[4];
    *(_BYTE *)(v12 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v89 = 0;
    v90 = a4 - 1;
    a2 += v10;
    v91 = v104 - a2;
    a3 += v9;
    v92 = v106 - a3;
    --a4;
    while (1)
    {
      v93 = v12 + v89 + 1;
      if ((v92 | v91 | (a3 - v107) | (a2 - v105)) < 0)
        break;
      v94 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      v39 = v94 + (a2 >> 32);
      v40 = *(unsigned __int8 **)(result + 32);
      if ((unint64_t)v17 >= v39)
        v95 = (unsigned __int8 *)(v94 + (a2 >> 32));
      else
        v95 = v17;
      if (v95 >= v40)
        v96 = v95;
      else
        v96 = *(unsigned __int8 **)(result + 32);
      if (v5)
      {
        v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        v97 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v42)
          v98 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        else
          v98 = (unint64_t)v16;
        if (v98 >= (unint64_t)v97)
          v97 = (unsigned __int8 *)v98;
        v99 = *v97;
      }
      else
      {
        v99 = 255;
      }
      v100 = *v96;
      if (v8)
      {
        v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          v46 = (int32x2_t)__PAIR64__(v99, v100);
          v27 = -1;
          v12 = v93;
          goto LABEL_45;
        }
      }
      --a4;
      *(_BYTE *)(v11 + 2) = v100;
      v11 += 2;
      *(_BYTE *)(v11 + 1) = v99;
      v101 = v12 + v89++;
      a2 += v10;
      *(_BYTE *)(v101 + 2) = -1;
      v91 -= v10;
      a3 += v9;
      v92 -= v9;
      if (v90 == (_DWORD)v89)
        return result;
    }
    v12 += v89 + 1;
  }
  while (a4);
  return result;
}

void GRAYA8_shade_radial_Gray(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  char *v18;
  _BYTE *v19;
  float *v20;
  float *v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float v25;
  int v26;
  unsigned int v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  BOOL v36;
  float v37;
  BOOL v38;
  unsigned int v39;
  float v40;
  uint64_t v41;
  float v42;
  float v43;
  float v44;
  char v45;
  float v46;
  uint64_t v47;
  int v48;
  float v49;
  float v50;
  float v51;
  float v53;
  float v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v58;
  float v59;
  float v60;
  float v61;
  uint64_t v62;
  float v63;
  float v64;
  uint64_t v65;
  float v66;
  float v67;
  float v68;
  _BYTE *v69;
  char v70;
  float v71;
  float v72;
  float v73;
  uint64_t v74;
  float v75;
  float v76;
  float v77;
  char v78;
  uint64_t v79;
  float v80;
  float v81;
  float v82;
  int v83;
  float v84;
  float v85;
  uint64_t v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  uint64_t v94;

  v4 = a4;
  v5 = *(float **)(a1 + 400);
  v6 = *(float *)(a1 + 280);
  v7 = *(float *)(a1 + 284);
  v8 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v9 = v8 * (float)a2;
  v10 = v8 * (float)a3;
  v11 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v10) + (float)(v6 * v9));
  v12 = *(float *)(a1 + 300) + (float)((float)(v10 * *(float *)(a1 + 292)) + (float)(v7 * v9));
  v90 = *(float *)(a1 + 344);
  v91 = *(float *)(a1 + 336);
  v92 = *(float *)(a1 + 304);
  v13 = *(float *)(a1 + 308);
  v14 = *(unsigned int *)(a1 + 324);
  v15 = v5[2];
  v16 = v5[5];
  v87 = v5[4];
  v17 = v5[7];
  v18 = *(char **)(a1 + 144);
  v19 = *(_BYTE **)(a1 + 152);
  v20 = *(float **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v21 = *(float **)(a1 + 392);
  else
    v21 = *(float **)(a1 + 272);
  v22 = *(_QWORD *)(a1 + 40);
  v94 = *(_QWORD *)(a1 + 32);
  if (v22)
    v23 = *(_QWORD *)(a1 + 40);
  else
    v23 = *(_QWORD *)(a1 + 272);
  if (v15 != 0.0 || v17 != 0.0 || v7 != 0.0)
  {
    v27 = *(_DWORD *)(a1 + 320);
    v88 = v5[3];
    v28 = -v5[6];
    v84 = v13 - v92;
    v85 = v5[8];
    while (1)
    {
      v29 = v28 + (float)((float)(v11 + v11) * v15);
      v30 = (float)((float)(v12 * v12) + (float)(v11 * v11)) - v17;
      if (v16 == 0.0)
      {
        v37 = v30 / v29;
      }
      else
      {
        v31 = (float)((float)(v16 * -4.0) * v30) + (float)(v29 * v29);
        if (v31 < 0.0)
          goto LABEL_49;
        v32 = sqrtf(v31);
        v33 = v85 * (float)(v29 - v32);
        v34 = v29 + v32;
        v35 = v85 * v34;
        v36 = (float)(v85 * v34) <= v33;
        if ((float)(v85 * v34) <= v33)
          v37 = v85 * v34;
        else
          v37 = v33;
        if (v36)
          v35 = v33;
        if (v35 < 0.0)
        {
          v38 = v35 < v88;
LABEL_31:
          v39 = v27;
          if (v38)
            goto LABEL_49;
LABEL_32:
          if ((v39 & 0x80000000) == 0)
            goto LABEL_44;
          goto LABEL_49;
        }
        if (v35 <= 1.0)
        {
          v40 = v92 + (float)(v35 * v84);
          goto LABEL_43;
        }
        if ((v14 & 0x80000000) == 0)
        {
          v39 = v14;
          if (v35 <= v87)
          {
LABEL_44:
            v41 = v39;
            if (!v22)
              v41 = 0;
            v42 = *(float *)(v23 + 4 * v41);
            v43 = 1.0;
            if (v22)
              v43 = *(float *)(v23 + 4 * v41);
            v44 = *(float *)(v94 + 4 * v39) * v43;
            goto LABEL_51;
          }
        }
      }
      if (v37 < 0.0)
      {
        v38 = v37 < v88;
        goto LABEL_31;
      }
      if (v37 > 1.0)
      {
        v39 = v14;
        if (v37 > v87)
          goto LABEL_49;
        goto LABEL_32;
      }
      v40 = v92 + (float)(v37 * v84);
LABEL_43:
      v39 = (int)(float)(v90 * (float)(v40 - v91));
      if ((v39 & 0x80000000) == 0)
        goto LABEL_44;
LABEL_49:
      if (!v20)
      {
        v45 = 0;
        goto LABEL_53;
      }
      v42 = *v21;
      v44 = *v21 * *v20;
LABEL_51:
      SHADE(v19, v44, v42);
      v45 = -1;
LABEL_53:
      v11 = v6 + v11;
      v12 = v7 + v12;
      v19 += 2;
      *v18++ = v45;
      if (!--v4)
        return;
    }
  }
  v24 = v12 * v12;
  v25 = -v16;
  if ((float)(v12 * v12) <= (float)-v16)
  {
    v93 = fabsf(v5[8]);
    v89 = v16 * -4.0;
    v46 = v13 - v92;
    if (v22)
      v47 = *(unsigned int *)(a1 + 324);
    else
      v47 = 0;
    v86 = v47;
    v48 = a4 + 2;
    while (1)
    {
      v49 = v24 + (float)(v11 * v11);
      v50 = v6 + v11;
      v51 = v24 + (float)(v50 * v50);
      if (v49 <= v25 || v51 <= v25)
      {
        v53 = v93 * sqrtf(v89 * v49);
        v54 = v93 * sqrtf(v89 * v51);
        v55 = (int)(float)(v90 * (float)((float)(v92 + (float)(v53 * v46)) - v91));
        v56 = (int)(float)(v90 * (float)((float)(v92 + (float)(v54 * v46)) - v91));
        if (v53 > 1.0 || v54 > 1.0)
        {
          if (v53 <= 1.0)
          {
            if ((v55 & 0x80000000) != 0)
              goto LABEL_100;
            if (v22)
              v58 = (int)(float)(v90 * (float)((float)(v92 + (float)(v53 * v46)) - v91));
            else
              v58 = 0;
          }
          else if (v53 > v87 || (v58 = v86, v55 = v14, (v14 & 0x80000000) != 0))
          {
LABEL_100:
            if (v20)
            {
              v71 = *v21;
              v73 = *v21 * *v20;
              goto LABEL_102;
            }
            v70 = 0;
LABEL_103:
            if (v54 <= 1.0)
            {
              if ((v56 & 0x80000000) != 0)
                goto LABEL_115;
              if (v22)
                v74 = (int)(float)(v90 * (float)((float)(v92 + (float)(v54 * v46)) - v91));
              else
                v74 = 0;
            }
            else if (v54 > v87 || (v74 = v86, v56 = v14, (v14 & 0x80000000) != 0))
            {
LABEL_115:
              if (!v20)
                goto LABEL_122;
              v75 = *v21;
              v77 = *v21 * *v20;
              goto LABEL_117;
            }
            v75 = *(float *)(v23 + 4 * v74);
            if (v22)
              v76 = *(float *)(v23 + 4 * v74);
            else
              v76 = 1.0;
            v77 = *(float *)(v94 + 4 * v56) * v76;
LABEL_117:
            SHADE(v19 + 2, v77, v75);
            goto LABEL_118;
          }
          v71 = *(float *)(v23 + 4 * v58);
          if (v22)
            v72 = *(float *)(v23 + 4 * v58);
          else
            v72 = 1.0;
          v73 = *(float *)(v94 + 4 * v55) * v72;
LABEL_102:
          SHADE(v19, v73, v71);
          v70 = -1;
          goto LABEL_103;
        }
        v62 = (int)v55;
        if (!v22)
          v62 = 0;
        v63 = *(float *)(v23 + 4 * v62);
        v64 = *(float *)(v94 + 4 * (int)v55);
        v65 = (int)v56;
        if (v22)
          v66 = *(float *)(v23 + 4 * v62);
        else
          v66 = 1.0;
        v67 = v64 * v66;
        if (!v22)
          v65 = 0;
        v59 = *(float *)(v23 + 4 * v65);
        if (v22)
          v68 = *(float *)(v23 + 4 * v65);
        else
          v68 = 1.0;
        v61 = *(float *)(v94 + 4 * (int)v56) * v68;
        v69 = v19;
      }
      else
      {
        if ((v14 & 0x80000000) != 0)
        {
          if (!v20)
          {
            v70 = 0;
LABEL_122:
            v78 = 0;
            goto LABEL_119;
          }
          v59 = *v21;
          v61 = *v21 * *v20;
        }
        else
        {
          v59 = *(float *)(v23 + 4 * v86);
          if (v22)
            v60 = *(float *)(v23 + 4 * v86);
          else
            v60 = 1.0;
          v61 = *(float *)(v94 + 4 * v14) * v60;
        }
        v69 = v19;
        v67 = v61;
        v63 = v59;
      }
      SHADE(v69, v67, v63);
      SHADE(v19 + 2, v61, v59);
      v70 = -1;
LABEL_118:
      v78 = -1;
LABEL_119:
      v11 = v6 + v50;
      v19 += 4;
      *v18 = v70;
      v18[1] = v78;
      v18 += 2;
      v48 -= 2;
      if (v48 <= 2)
        return;
    }
  }
  if (v20 || (v14 & 0x80000000) == 0)
  {
    if ((v14 & 0x80000000) != 0)
    {
      v80 = *v21;
      v82 = *v21 * *v20;
    }
    else
    {
      if (v22)
        v79 = *(unsigned int *)(a1 + 324);
      else
        v79 = 0;
      v80 = *(float *)(v23 + 4 * v79);
      v81 = 1.0;
      if (v22)
        v81 = *(float *)(v23 + 4 * v79);
      v82 = *(float *)(v94 + 4 * v14) * v81;
    }
    v83 = a4 + 4;
    do
    {
      SHADE(v19, v82, v80);
      SHADE(v19 + 2, v82, v80);
      SHADE(v19 + 4, v82, v80);
      SHADE(v19 + 6, v82, v80);
      *(_DWORD *)v18 = -1;
      v18 += 4;
      v83 -= 4;
      v19 += 8;
    }
    while (v83 > 4);
  }
  else
  {
    if (a4 >= 4)
      v26 = 4;
    else
      v26 = a4;
    bzero(*(void **)(a1 + 144), ((a4 - v26 + 3) & 0xFFFFFFFC) + 4);
  }
}

void GRAYA8_shade_conic_Gray(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7;
  float v8;
  float v9;
  float v10;
  _BYTE *v11;
  _BYTE *v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  signed int v18;
  float v19;
  unsigned int v20;
  float v21;
  float v22;
  float v23;
  int v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  float v28;
  float v29;
  float v30;
  __n128 v31;

  v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a2));
  v8 = a1[42].f32[0];
  v9 = a1[43].f32[0];
  v10 = a1[38].f32[0];
  v12 = (_BYTE *)a1[18];
  v11 = (_BYTE *)a1[19];
  v13 = a1[4];
  v14 = a1[5];
  if (v14)
    v15 = a1[5];
  else
    v15 = a1[34];
  v16 = a1[38].f32[1] - v10;
  do
  {
    v31 = a6;
    v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    v18 = vcvtms_s32_f32(v17);
    v19 = ceilf(v17);
    v20 = vcvtms_s32_f32(v9 + v17);
    v21 = v17 - (float)(int)floorf(v17);
    if (v17 < 0.0)
      v18 = v20;
    v22 = ceilf(v17 - v9);
    if (v17 <= v9)
      v23 = v19;
    else
      v23 = v22;
    v24 = (int)v23;
    v25 = v18;
    if (!*(_QWORD *)&v14)
      v25 = 0;
    v26 = *(float *)(*(_QWORD *)&v13 + 4 * v18);
    v27 = v24;
    if (v14)
    {
      v28 = *(float *)(*(_QWORD *)&v15 + 4 * v25);
    }
    else
    {
      v27 = 0;
      v28 = 1.0;
    }
    v29 = v26 * v28;
    if (v14)
      v30 = *(float *)(*(_QWORD *)&v15 + 4 * v27);
    else
      v30 = 1.0;
    SHADE(v11, v29 + (float)(v21 * (float)((float)(*(float *)(*(_QWORD *)&v13 + 4 * v24) * v30) - v29)), *(float *)(*(_QWORD *)&v15 + 4 * v25)+ (float)(v21 * (float)(*(float *)(*(_QWORD *)&v15 + 4 * v27) - *(float *)(*(_QWORD *)&v15 + 4 * v25))));
    a6.n128_u64[1] = v31.n128_u64[1];
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v31.n128_u64[0]);
    v11 += 2;
    *v12++ = -1;
    --a4;
  }
  while (a4);
}

void GRAYA8_shade_custom_Gray(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, int32x4_t a7)
{
  float32x2_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  _BYTE *v13;
  char *v14;
  float *v15;
  float *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  float32x4_t v22;
  float v23;
  float v24;
  _BYTE *v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  char v32;
  float32x4_t v33;
  int32x4_t v34;

  v8 = *(float32x2_t *)(a1 + 280);
  *(float32x2_t *)a7.i8 = vadd_f32(*(float32x2_t *)(a1 + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(a1 + 288), *(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a3), v8, *(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a2));
  v33 = *(float32x4_t *)(a1 + 304);
  v9 = *(float *)(a1 + 336);
  v10 = *(float *)(a1 + 348);
  v11 = *(float *)(a1 + 344);
  v12 = *(float *)(a1 + 356);
  v14 = *(char **)(a1 + 144);
  v13 = *(_BYTE **)(a1 + 152);
  v15 = *(float **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v16 = *(float **)(a1 + 392);
  else
    v16 = *(float **)(a1 + 272);
  v17 = *(_QWORD *)(a1 + 32);
  v18 = *(_QWORD *)(a1 + 40);
  if (v18)
    v19 = *(_DWORD *)(a1 + 48);
  else
    v19 = 0;
  if (v18)
    v20 = *(_QWORD *)(a1 + 40);
  else
    v20 = *(_QWORD *)(a1 + 272);
  v21 = 3 * *(_DWORD *)(a1 + 48);
  do
  {
    v22 = (float32x4_t)vzip1q_s32(a7, a7);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v33, v22))), vmovn_s32(vcgtq_f32(v22, v33))), 0xFuLL))) & 1) == 0)
    {
      v26 = (int)(float)(v12 * (float)(*(float *)&a7.i32[1] - v10));
      v27 = (int)(float)(v11 * (float)(*(float *)a7.i32 - v9));
      v28 = v17 + 4 * v21 * v26;
      v29 = v27;
      v30 = v20 + 4 * v19 * v26;
      if (!v18)
        v29 = 0;
      v23 = *(float *)(v30 + 4 * v29);
      v34 = a7;
      if (v18)
        v31 = *(float *)(v30 + 4 * v29);
      else
        v31 = 1.0;
      v24 = *(float *)(v28 + 4 * v27) * v31;
      v25 = v13;
      goto LABEL_20;
    }
    if (v15)
    {
      v23 = *v16;
      v24 = *v16 * *v15;
      v25 = v13;
      v34 = a7;
LABEL_20:
      SHADE(v25, v24, v23);
      a7 = v34;
      v32 = -1;
      goto LABEL_22;
    }
    v32 = 0;
LABEL_22:
    *(float32x2_t *)a7.i8 = vadd_f32(v8, *(float32x2_t *)a7.i8);
    v13 += 2;
    *v14++ = v32;
    --a4;
  }
  while (a4);
}

uint64_t GRAYA8_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, int8x8_t a7, double a8, int8x8_t a9, int8x8_t a10, uint32x2_t a11)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int8 *v44;
  __int8 *v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int8x8_t v50;
  int v51;
  uint64_t v52;
  __int8 *v53;
  __int8 *v54;
  unint64_t v55;
  __int8 *v56;
  __int8 *v57;
  __int8 *v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  int8x8_t v63;
  uint32x2_t v64;
  int32x2_t v65;
  int8x8_t v66;
  unsigned int v67;
  __int8 *v68;
  unsigned int v69;
  __int8 *v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  __int8 *v79;
  int v80;
  uint64_t v81;
  uint64_t v82;

  v11 = *(_QWORD *)(result + 32);
  v12 = *(_DWORD *)(result + 24);
  v13 = *(_QWORD *)(result + 176);
  v14 = *(_QWORD *)(result + 72);
  v15 = *(_QWORD *)(result + 88);
  v81 = *(_QWORD *)(result + 64);
  v82 = *(_QWORD *)(result + 80);
  v16 = *(_QWORD *)(result + 112);
  v17 = *(_QWORD *)(result + 120);
  v80 = *(_DWORD *)(result + 188);
  v18 = *(_QWORD *)(result + 152) - 2;
  v19 = *(_QWORD *)(result + 144) - 1;
  v20 = v11 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v12) - 3;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v14)
    {
      if ((uint64_t)a3 <= v15)
      {
        v29 = (a3 >> 22) & 0x3C0;
        v30 = 0x3FFFFFFF;
        HIDWORD(v31) = HIDWORD(a3);
        v32 = v81;
      }
      else
      {
        v25 = *(_QWORD *)(result + 216);
        v26 = *(_QWORD *)(result + 224) + v15;
        v27 = v26 - a3 + (v25 >> 1);
        if (v27 < 1)
          goto LABEL_34;
        if (v27 >= v25)
          LODWORD(v28) = 0x3FFFFFFF;
        else
          v28 = (unint64_t)(*(_QWORD *)(result + 232) * v27) >> 32;
        v32 = v81;
        v30 = v28 | v80;
        v31 = v26 - 0x1000000;
        v29 = 448;
      }
    }
    else
    {
      v21 = *(_QWORD *)(result + 216);
      v22 = v14 - *(_QWORD *)(result + 224);
      v23 = a3 - v22 + (v21 >> 1);
      if (v23 < 1)
        goto LABEL_34;
      if (v23 >= v21)
        LODWORD(v24) = 0x3FFFFFFF;
      else
        v24 = (unint64_t)(*(_QWORD *)(result + 232) * v23) >> 32;
      v32 = v81;
      v30 = v24 | v80;
      v31 = v22 + 0x1000000;
      v29 = 512;
    }
    if (a2 >= v32)
      break;
    v33 = *(_QWORD *)(result + 192);
    v34 = v32 - *(_QWORD *)(result + 200);
    v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v80;
      v36 = v34 + 0x1000000;
      v37 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v16;
    a3 += v17;
    v18 += 2;
    *(_BYTE *)++v19 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v82)
  {
    v37 = ((unint64_t)a2 >> 26) & 0x3C;
    v36 = a2;
    goto LABEL_26;
  }
  v38 = *(_QWORD *)(result + 192);
  v39 = *(_QWORD *)(result + 200) + v82;
  v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1)
    goto LABEL_34;
  if (v40 < v38)
    v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v80;
  v36 = v39 - 0x1000000;
  v37 = 28;
LABEL_26:
  if (v30 < 0x400000)
    goto LABEL_34;
  v41 = v11 + SHIDWORD(v31) * (uint64_t)v12;
  v42 = 3 * (v36 >> 32);
  v43 = v41 + v42;
  v44 = *(__int8 **)(result + 32);
  if (v20 >= v41 + v42)
    v45 = (__int8 *)(v41 + v42);
  else
    v45 = (__int8 *)v20;
  if (v45 < v44)
    v45 = *(__int8 **)(result + 32);
  a7.i8[0] = *v45;
  a7.i8[4] = v45[1];
  v46 = v45[2];
  if (!v13)
    goto LABEL_66;
  v47 = *(_DWORD *)(v13 + (v37 | v29));
LABEL_37:
  v48 = v47 & 0xF;
  v49 = HIBYTE(v47) & 3;
  v50 = vand_s8(a7, (int8x8_t)0xFF000000FFLL);
  if (v48 == 1)
  {
    v68 = (__int8 *)(v43 + SBYTE1(v47) * (uint64_t)v12);
    if (v20 < (unint64_t)v68)
      v68 = (__int8 *)v20;
    if (v68 < v44)
      v68 = v44;
    v69 = interpolate_rgba[4 * interpolate_rgba[4 * v49 + 3] + 3];
    a9.i8[0] = *v68;
    a9.i8[4] = v68[1];
    a10 = (int8x8_t)vdup_n_s32(v69);
    a11 = (uint32x2_t)vneg_s32(vdup_n_s32(interpolate_rgba[4 * v49 + 3] + 1));
    a7 = (int8x8_t)vadd_s32(vsub_s32((int32x2_t)a7, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(a10, v50), a11)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(vand_s8(a10, (int8x8_t)0xFF000000FFLL), a9), a11));
    LOBYTE(v46) = a7.i8[0] + ((v69 & v68[2]) >> (interpolate_rgba[4 * v49 + 3] + 1));
    goto LABEL_66;
  }
  if (v48 == 2)
  {
    v70 = (__int8 *)(v43 + 3 * SBYTE2(v47));
    if (v20 < (unint64_t)v70)
      v70 = (__int8 *)v20;
    if (v70 < v44)
      v70 = v44;
    v71 = (v47 >> 28) & 3;
    v72 = interpolate_rgba[4 * v71++ + 3];
    a9.i8[0] = *v70;
    a9.i8[4] = v70[1];
    a10 = (int8x8_t)vdup_n_s32(v72);
    a11 = (uint32x2_t)vneg_s32(vdup_n_s32(v71));
    a7 = (int8x8_t)vadd_s32(vsub_s32((int32x2_t)a7, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(a10, v50), a11)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(vand_s8(a10, (int8x8_t)0xFF000000FFLL), a9), a11));
    LOBYTE(v46) = a7.i8[0] + ((v72 & v70[2]) >> v71);
LABEL_66:
    LOWORD(v51) = 255;
    goto LABEL_67;
  }
  LOWORD(v51) = 255;
  if (v48 == 3)
  {
    v52 = 3 * SBYTE2(v47);
    v53 = (__int8 *)(v43 + v52);
    if (v20 < v43 + v52)
      v53 = (__int8 *)v20;
    if (v53 >= v44)
      v54 = v53;
    else
      v54 = v44;
    v55 = v43 + SBYTE1(v47) * (uint64_t)v12;
    if (v20 >= v55)
      v56 = (__int8 *)(v43 + SBYTE1(v47) * (uint64_t)v12);
    else
      v56 = (__int8 *)v20;
    if (v56 >= v44)
      v57 = v56;
    else
      v57 = v44;
    v58 = (__int8 *)(v55 + v52);
    if (v20 < (unint64_t)v58)
      v58 = (__int8 *)v20;
    if (v58 >= v44)
      v44 = v58;
    v59 = (v47 >> 28) & 3;
    v60 = interpolate_rgba[4 * v49 + 3];
    v61 = interpolate_rgba[4 * v59 + 3];
    v62 = v49 + 1;
    v50.i8[0] = *v44;
    v50.i8[4] = v44[1];
    v63 = (int8x8_t)vdup_n_s32(v60);
    a10.i8[0] = *v54;
    a10.i8[4] = v54[1];
    a11.i8[0] = *v57;
    a11.i8[4] = v57[1];
    v64 = (uint32x2_t)vneg_s32(vdup_n_s32(v62));
    v65 = vadd_s32(vsub_s32((int32x2_t)a7, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, a7), v64)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, (int8x8_t)a11), v64));
    v66 = (int8x8_t)vadd_s32(vsub_s32((int32x2_t)a10, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, a10), v64)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, v50), v64));
    a9 = (int8x8_t)vdup_n_s32(v61);
    a11 = (uint32x2_t)vneg_s32(vdup_n_s32(v59 + 1));
    a10 = (int8x8_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v65, a9), a11);
    a7 = (int8x8_t)vadd_s32(vsub_s32(v65, (int32x2_t)a10), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v66, a9), a11));
    v67 = v46 - ((v60 & v46) >> v62) + ((v60 & v57[2]) >> v62);
    v46 = v67
        - ((v67 & v61) >> (v59 + 1))
        + (((v54[2]
           - ((v60 & v54[2]) >> v62)
           + ((v60 & v44[2]) >> v62)) & v61) >> (v59 + 1));
    v51 = ((v61 >> (v59 + 1)) ^ 0xFF) + (v61 >> (v59 + 1));
  }
LABEL_67:
  v73 = 0;
  v74 = 0;
  a3 += v17;
  v75 = v15 - a3;
  a2 += v16;
  v76 = v82 - a2;
  while (1)
  {
    a7 = (int8x8_t)vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), (int32x2_t)0x500000002);
    *(_WORD *)(v18 + 2 + 2 * v74) = ((a7.i32[0] + v46 + a7.i32[1]) >> 3) & 0x1FF | ((_WORD)v51 << 8);
    *(_BYTE *)(v19 + 1 + v74) = v30 >> 22;
    if (a4 - 1 == (_DWORD)v74)
      return result;
    if (((v75 | v76 | (a3 - v14) | (a2 - v81)) & 0x8000000000000000) != 0)
    {
      v19 += v74 + 1;
      v18 = v18 - v73 + 2;
      a4 += ~(_DWORD)v74;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v77 = v11 + SHIDWORD(a3) * (uint64_t)v12;
    v78 = 3 * (a2 >> 32);
    v43 = v77 + v78;
    v44 = *(__int8 **)(result + 32);
    if (v20 >= v77 + v78)
      v79 = (__int8 *)(v77 + v78);
    else
      v79 = (__int8 *)v20;
    if (v79 < v44)
      v79 = *(__int8 **)(result + 32);
    a7.i8[0] = *v79;
    a7.i8[4] = v79[1];
    v46 = v79[2];
    if (v13)
    {
      v47 = *(_DWORD *)(v13 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        v19 += v74 + 1;
        v18 = v18 - v73 + 2;
        a4 += ~(_DWORD)v74;
        v30 = -1;
        goto LABEL_37;
      }
    }
    ++v74;
    v73 -= 2;
    a3 += v17;
    v75 -= v17;
    a2 += v16;
    v76 -= v16;
    v30 = -1;
    LOWORD(v51) = 255;
  }
}

uint64_t GRAYA8_sample_CMYK32_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  int64_t v61;
  unint64_t v62;
  unint64_t v63;
  unsigned int v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unsigned int v68;
  unint64_t v69;
  unsigned int v70;
  int v71;
  int v72;
  int v73;
  unsigned __int8 *v74;
  unint64_t v75;
  unint64_t v76;
  unsigned __int8 *v77;
  unsigned __int8 *v78;
  uint64_t v79;
  int v80;
  unsigned __int8 v81;
  unsigned int v82;
  char v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  unint64_t v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  unsigned __int8 *v92;
  int v93;
  char v94;
  unsigned int v95;
  int64_t v96;
  unint64_t v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  unsigned int v101;
  int v102;
  unsigned __int8 *v103;
  int v104;
  char v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  unint64_t v112;
  unsigned __int8 *v113;
  unint64_t v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  uint64_t v127;
  int v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  int v137;
  uint64_t v138;

  v8 = (*(_DWORD *)(result + 8) >> 4) & 3;
  if (v8 >= 2)
    _CGHandleAssert("GRAYA8_sample_CMYK32_inner", 9662, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "reverse == NO_REVERSE || reverse == PIXEL_REVERSE", "reverse = %d", a6, a7, a8, v8);
  v9 = v8 == 0;
  v10 = 3;
  if (v8)
    v11 = 0;
  else
    v11 = 3;
  v12 = 1;
  if (v9)
    v13 = 2;
  else
    v13 = 1;
  if (v9)
    v10 = 0;
  else
    v12 = 2;
  v138 = v10;
  v14 = *(_QWORD *)(result + 40);
  v15 = *(_QWORD *)(result + 176);
  v130 = *(_QWORD *)(result + 80);
  v132 = *(_QWORD *)(result + 88);
  v16 = *(_QWORD *)(result + 112);
  v17 = *(_QWORD *)(result + 120);
  v134 = *(_QWORD *)(result + 152) - 2;
  v133 = *(_QWORD *)(result + 144) - 1;
  v18 = *(_DWORD *)(result + 260) - 1;
  v136 = *(_QWORD *)(result + 32);
  v137 = *(_DWORD *)(result + 24);
  v19 = *(unsigned int *)(result + 256);
  v135 = *(_DWORD *)(result + 28);
  v126 = *(_DWORD *)(result + 188);
  v20 = (unsigned __int8 *)(v14 + v19 + (v18 * v135));
  v21 = v136 + (4 * v19) + (v18 * v137) - 4;
  v131 = *(_QWORD *)(result + 72);
  v127 = *(_QWORD *)(result + 64);
  while (1)
  {
    if (a3 >= v131)
    {
      if (a3 <= v132)
      {
        v31 = ((unint64_t)a3 >> 22) & 0x3C0;
        v32 = 0x3FFFFFFF;
        v33 = a3;
        v25 = a4;
        v34 = v127;
      }
      else
      {
        v27 = *(_QWORD *)(result + 216);
        v28 = *(_QWORD *)(result + 224) + v132;
        v29 = v28 - a3 + (v27 >> 1);
        v25 = a4;
        if (v29 < 1)
          goto LABEL_49;
        if (v29 >= v27)
          LODWORD(v30) = 0x3FFFFFFF;
        else
          v30 = (unint64_t)(*(_QWORD *)(result + 232) * v29) >> 32;
        v34 = v127;
        v32 = v126 | v30;
        v33 = v28 - 0x1000000;
        v31 = 448;
      }
    }
    else
    {
      v22 = *(_QWORD *)(result + 216);
      v23 = v131 - *(_QWORD *)(result + 224);
      v24 = a3 - v23 + (v22 >> 1);
      v25 = a4;
      if (v24 < 1)
        goto LABEL_49;
      if (v24 >= v22)
        LODWORD(v26) = 0x3FFFFFFF;
      else
        v26 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
      v34 = v127;
      v32 = v126 | v26;
      v33 = v23 + 0x1000000;
      v31 = 512;
    }
    if (a2 >= v34)
    {
      if (a2 <= v130)
      {
        v39 = ((unint64_t)a2 >> 26) & 0x3C;
        v38 = a2;
      }
      else
      {
        v40 = *(_QWORD *)(result + 192);
        v41 = *(_QWORD *)(result + 200) + v130;
        v42 = v41 - a2 + (v40 >> 1);
        if (v42 < 1)
          goto LABEL_49;
        if (v42 < v40)
          v32 = ((v32 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v126;
        v38 = v41 - 0x1000000;
        v39 = 28;
      }
    }
    else
    {
      v35 = *(_QWORD *)(result + 192);
      v36 = v34 - *(_QWORD *)(result + 200);
      v37 = a2 - v36 + (v35 >> 1);
      if (v37 < 1)
        goto LABEL_49;
      if (v37 < v35)
        v32 = ((v32 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v37) >> 32) >> 15)) | v126;
      v38 = v36 + 0x1000000;
      v39 = 32;
    }
    if (v32 >= 0x400000)
      break;
LABEL_49:
    v53 = v25 - 1;
    a2 += v16;
    a3 += v17;
    v134 += 2;
    *(_BYTE *)++v133 = 0;
LABEL_50:
    a4 = v53;
    if (!v53)
      return result;
  }
  v43 = v33 >> 32;
  v44 = v38 >> 32;
  v45 = v136 + SHIDWORD(v33) * (uint64_t)v137;
  v46 = v45 + 4 * v44;
  v47 = *(_QWORD *)(result + 32);
  if (v21 >= v46)
    v48 = v45 + 4 * v44;
  else
    v48 = v21;
  if (v48 < v47)
    v48 = *(_QWORD *)(result + 32);
  if (v14)
  {
    v49 = v14 + (int)v43 * (uint64_t)v135 + v44;
    v50 = *(unsigned __int8 **)(result + 40);
    if ((unint64_t)v20 >= v49)
      v51 = (unsigned __int8 *)v49;
    else
      v51 = v20;
    if (v51 >= v50)
      v50 = v51;
    v52 = *v50;
  }
  else
  {
    v49 = 0;
    v52 = 255;
  }
  v54 = *(unsigned __int8 *)(v48 + v138);
  v55 = *(unsigned __int8 *)(v48 + v12);
  v56 = *(unsigned __int8 *)(v48 + v13);
  v57 = *(unsigned __int8 *)(v48 + v11);
  if (v15)
  {
    v58 = *(_DWORD *)(v15 + (v39 | v31));
LABEL_56:
    v59 = v58 & 0xF;
    v60 = (v58 >> 28) & 3;
    switch(v59)
    {
      case 1:
        v86 = SBYTE1(v58);
        v87 = v46 + SBYTE1(v58) * (uint64_t)v137;
        if (v21 < v87)
          v87 = v21;
        if (v87 < v47)
          v87 = v47;
        v88 = *(unsigned __int8 *)(v87 + v13);
        v89 = *(unsigned __int8 *)(v87 + v12);
        v90 = *(unsigned __int8 *)(v87 + v11);
        v91 = 255;
        if (v14)
        {
          v92 = (unsigned __int8 *)(v49 + v86 * (uint64_t)v135);
          if (v20 < v92)
            v92 = v20;
          if ((unint64_t)v92 < *(_QWORD *)(result + 40))
            v92 = *(unsigned __int8 **)(result + 40);
          v91 = *v92;
        }
        v93 = interpolate_cmyka8[(v60 | (4 * v60)) + 4];
        v94 = v60 + 1;
        v95 = (v93 & v88) >> v94;
        v54 = v54 - ((v93 & v54) >> v94) + v95;
        v55 = v55 - ((v93 & v55) >> v94) + ((v93 & v89) >> v94);
        v56 = v56 - ((v93 & v56) >> v94) + v95;
        v57 = v57 - ((v93 & v57) >> v94) + ((v93 & v90) >> v94);
        v52 = v52 - ((v93 & v52) >> v94) + ((v93 & v91) >> v94);
        break;
      case 2:
        v96 = (unint64_t)HIWORD(v58) << 56;
        v97 = v46 + (v96 >> 54);
        if (v21 < v97)
          v97 = v21;
        if (v97 < v47)
          v97 = v47;
        v98 = *(unsigned __int8 *)(v97 + v138);
        v99 = *(unsigned __int8 *)(v97 + v12);
        v100 = *(unsigned __int8 *)(v97 + v13);
        v101 = *(unsigned __int8 *)(v97 + v11);
        v102 = 255;
        if (v14)
        {
          v103 = (unsigned __int8 *)(v49 + (v96 >> 56));
          if (v20 < v103)
            v103 = v20;
          if ((unint64_t)v103 < *(_QWORD *)(result + 40))
            v103 = *(unsigned __int8 **)(result + 40);
          v102 = *v103;
        }
        v104 = interpolate_cmyka8[(v60 | (4 * v60)) + 4];
        v105 = v60 + 1;
        v54 = v54 - ((v104 & v54) >> v105) + ((v104 & v98) >> v105);
        v55 = v55 - ((v104 & v55) >> v105) + ((v104 & v99) >> v105);
        v56 = v56 - ((v104 & v56) >> v105) + ((v104 & v100) >> v105);
        v57 = v57 - ((v104 & v57) >> v105) + ((v104 & v101) >> v105);
        v52 = v52 - ((v104 & v52) >> v105) + ((v104 & v102) >> v105);
        break;
      case 3:
        v128 = v25;
        v61 = (unint64_t)HIWORD(v58) << 56;
        v62 = v46 + (v61 >> 54);
        if (v21 < v62)
          v62 = v21;
        if (v62 >= v47)
          v63 = v62;
        else
          v63 = v47;
        v64 = *(unsigned __int8 *)(v63 + v138);
        v119 = *(unsigned __int8 *)(v63 + v12);
        v122 = *(unsigned __int8 *)(v63 + v13);
        v125 = *(unsigned __int8 *)(v63 + v11);
        v65 = v46 + SBYTE1(v58) * (uint64_t)v137;
        if (v21 >= v65)
          v66 = v46 + SBYTE1(v58) * (uint64_t)v137;
        else
          v66 = v21;
        if (v66 >= v47)
          v67 = v66;
        else
          v67 = v47;
        v115 = *(unsigned __int8 *)(v67 + v138);
        v117 = *(unsigned __int8 *)(v67 + v12);
        v121 = *(unsigned __int8 *)(v67 + v13);
        v68 = *(unsigned __int8 *)(v67 + v11);
        v69 = v65 + (v61 >> 54);
        if (v21 < v69)
          v69 = v21;
        if (v69 < v47)
          v69 = v47;
        v70 = *(unsigned __int8 *)(v69 + v138);
        v116 = *(unsigned __int8 *)(v69 + v12);
        v120 = *(unsigned __int8 *)(v69 + v13);
        v123 = *(unsigned __int8 *)(v69 + v11);
        v124 = v68;
        v71 = 255;
        v72 = 255;
        v73 = 255;
        if (v14)
        {
          v74 = (unsigned __int8 *)(v49 + SBYTE2(v58));
          v75 = *(_QWORD *)(result + 40);
          if (v20 < v74)
            v74 = v20;
          if ((unint64_t)v74 < v75)
            v74 = *(unsigned __int8 **)(result + 40);
          v71 = *v74;
          v76 = v49 + SBYTE1(v58) * (uint64_t)v135;
          if ((unint64_t)v20 >= v76)
            v77 = (unsigned __int8 *)(v49 + SBYTE1(v58) * (uint64_t)v135);
          else
            v77 = v20;
          if ((unint64_t)v77 < v75)
            v77 = *(unsigned __int8 **)(result + 40);
          v72 = *v77;
          v78 = (unsigned __int8 *)(v76 + SBYTE2(v58));
          if (v20 < v78)
            v78 = v20;
          if ((unint64_t)v78 < v75)
            v78 = *(unsigned __int8 **)(result + 40);
          v73 = *v78;
        }
        v118 = v73;
        v79 = HIBYTE(v58) & 3;
        v80 = interpolate_cmyka8[(v79 | (4 * v79)) + 4];
        LOBYTE(v79) = v79 + 1;
        v81 = interpolate_cmyka8[(v60 | (4 * v60)) + 4];
        v82 = v54 - ((v80 & v54) >> v79) + ((v80 & v115) >> v79);
        v83 = v60 + 1;
        v54 = v82
            - ((v82 & v81) >> v83)
            + (((v64 - ((v80 & v64) >> v79) + ((v80 & v70) >> v79)) & v81) >> v83);
        v55 = v55
            - ((v80 & v55) >> v79)
            + ((v80 & v117) >> v79)
            - (((v55 - ((v80 & v55) >> v79) + ((v80 & v117) >> v79)) & v81) >> v83)
            + (((v119 - ((v80 & v119) >> v79) + ((v80 & v116) >> v79)) & v81) >> v83);
        v56 = v56
            - ((v80 & v56) >> v79)
            + ((v80 & v121) >> v79)
            - (((v56 - ((v80 & v56) >> v79) + ((v80 & v121) >> v79)) & v81) >> v83)
            + (((v122 - ((v80 & v122) >> v79) + ((v80 & v120) >> v79)) & v81) >> v83);
        v84 = v57 - ((v80 & v57) >> v79) + ((v80 & v124) >> v79);
        v57 = v84
            - ((v84 & v81) >> v83)
            + (((v125 - ((v80 & v125) >> v79) + ((v80 & v123) >> v79)) & v81) >> v83);
        v85 = v52 - ((v80 & v52) >> v79) + ((v80 & v72) >> v79);
        v52 = v85
            - ((v85 & v81) >> v83)
            + (((v71 - ((v80 & v71) >> v79) + ((v80 & v118) >> v79)) & v81) >> v83);
        v25 = v128;
        break;
    }
  }
  v106 = 0;
  v107 = 0;
  v129 = v25;
  v108 = v25 - 1;
  a3 += v17;
  v109 = v132 - a3;
  a2 += v16;
  v110 = v130 - a2;
  while (1)
  {
    v111 = (v52 - (v55 + v57)) & ~((v52
                                                                                     - (v55
                                                                                      + v57)) >> 31);
    *(_WORD *)(v134 + 2 + 2 * v107) = ((unsigned __int16)(((v52
                                                          - (v56
                                                           + v57)) & ~(unsigned __int16)((v52 - (v56 + v57)) >> 31))
                                                        + v111
                                                        + 2
                                                        * ((v52
                                                          - (v54
                                                           + v57)) & ~(unsigned __int16)((v52 - (v54 + v57)) >> 31))
                                                        + 4 * v111) >> 3) | ((_WORD)v52 << 8);
    *(_BYTE *)(v133 + 1 + v107) = v32 >> 22;
    if (v108 == (_DWORD)v107)
      return result;
    if ((v109 | v110 | (a3 - v131) | (a2 - v127)) < 0)
    {
      v133 += v107 + 1;
      v134 = v134 - v106 + 2;
      v53 = ~(_DWORD)v107 + v129;
      goto LABEL_50;
    }
    v46 = v136 + SHIDWORD(a3) * (uint64_t)v137 + 4 * (a2 >> 32);
    v47 = *(_QWORD *)(result + 32);
    if (v21 >= v46)
      v112 = v136 + SHIDWORD(a3) * (uint64_t)v137 + 4 * (a2 >> 32);
    else
      v112 = v21;
    if (v112 < v47)
      v112 = *(_QWORD *)(result + 32);
    if (v14)
    {
      v49 = v14 + SHIDWORD(a3) * (uint64_t)v135 + (a2 >> 32);
      v113 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v20 >= v49)
        v114 = v14 + SHIDWORD(a3) * (uint64_t)v135 + (a2 >> 32);
      else
        v114 = (unint64_t)v20;
      if (v114 >= (unint64_t)v113)
        v113 = (unsigned __int8 *)v114;
      v52 = *v113;
    }
    else
    {
      v52 = 255;
    }
    v54 = *(unsigned __int8 *)(v112 + v138);
    v55 = *(unsigned __int8 *)(v112 + v12);
    v56 = *(unsigned __int8 *)(v112 + v13);
    v57 = *(unsigned __int8 *)(v112 + v11);
    if (v15)
    {
      v58 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v58 & 0xF) != 0)
      {
        v133 += v107 + 1;
        v134 = v134 - v106 + 2;
        v25 = ~(_DWORD)v107 + v129;
        v32 = -1;
        goto LABEL_56;
      }
    }
    ++v107;
    v106 -= 2;
    a3 += v17;
    v109 -= v17;
    a2 += v16;
    v110 -= v16;
    v32 = -1;
  }
}

void CoonsMeshFree(void **a1)
{
  free(a1[1]);
  free(a1[3]);
  free(a1[5]);
  free(a1);
}

_OWORD *AllocateCoonsMeshTriangle(uint64_t a1)
{
  int v2;
  _OWORD *result;
  __int128 v4;
  unsigned int v5;
  int v6;
  __int128 v7;

  v2 = *(_DWORD *)(a1 + 64);
  if (v2 == -1)
  {
    v5 = *(_DWORD *)(a1 + 48);
    v6 = *(_DWORD *)(a1 + 52);
    result = *(_OWORD **)(a1 + 40);
    if (v5 == v6)
    {
      result = malloc_type_realloc(result, 48 * (v5 + 50), 0x1000040EED21634uLL);
      *(_QWORD *)(a1 + 40) = result;
      if (!result)
        return result;
      v5 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 52) += 50;
    }
    *(_DWORD *)(a1 + 48) = v5 + 1;
    result += 3 * v5;
    *((_QWORD *)result + 4) = -1;
    *(_QWORD *)&v7 = -1;
    *((_QWORD *)&v7 + 1) = -1;
    *result = v7;
    result[1] = v7;
  }
  else
  {
    result = (_OWORD *)(*(_QWORD *)(a1 + 40) + 48 * v2);
    *(_DWORD *)(a1 + 64) = *((_DWORD *)result + 9);
    *(_QWORD *)&v4 = -1;
    *((_QWORD *)&v4 + 1) = -1;
    *result = v4;
    result[1] = v4;
    *((_QWORD *)result + 4) = -1;
  }
  *((_DWORD *)result + 10) = 1;
  *((_DWORD *)result + 11) = 0;
  return result;
}

_QWORD *AllocateCoonsMeshEdge(uint64_t a1)
{
  int v2;
  _QWORD *result;
  unsigned int v4;
  int v5;

  v2 = *(_DWORD *)(a1 + 68);
  if (v2 == -1)
  {
    v4 = *(_DWORD *)(a1 + 32);
    v5 = *(_DWORD *)(a1 + 36);
    result = *(_QWORD **)(a1 + 24);
    if (v4 == v5)
    {
      result = malloc_type_realloc(result, 20 * (v4 + 50), 0x1000040A86A77D5uLL);
      *(_QWORD *)(a1 + 24) = result;
      if (!result)
        return result;
      v4 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 36) += 50;
    }
    *(_DWORD *)(a1 + 32) = v4 + 1;
    result = (_QWORD *)((char *)result + 20 * v4);
  }
  else
  {
    result = (_QWORD *)(*(_QWORD *)(a1 + 24) + 20 * v2);
    *(_DWORD *)(a1 + 68) = *((_DWORD *)result + 4);
  }
  *result = -1;
  result[1] = -1;
  *((_DWORD *)result + 4) = -1;
  return result;
}

BOOL TriangleGreater(uint64_t a1, int *a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;

  v3 = a1 + 72 * *a2;
  v4 = a1 + 72 * a2[1];
  v5 = a1 + 72 * a2[2];
  v6 = (*(double *)(v3 + 24) + *(double *)(v4 + 24) + *(double *)(v5 + 24)) * 0.333330005;
  v7 = a1 + 72 * *a3;
  v8 = a1 + 72 * a3[1];
  v9 = a1 + 72 * a3[2];
  v10 = (*(double *)(v7 + 24) + *(double *)(v8 + 24) + *(double *)(v9 + 24)) * 0.333330005;
  if (v10 < v6)
    return 1;
  if (v10 <= v6)
    return (*(double *)(v7 + 16) + *(double *)(v8 + 16) + *(double *)(v9 + 16)) * 0.333330005 < (*(double *)(v3 + 16)
                                                                                               + *(double *)(v4 + 16)
                                                                                               + *(double *)(v5 + 16))
                                                                                              * 0.333330005;
  return 0;
}

char *CGBacktraceCreate(uint64_t a1)
{
  int v2;
  unint64_t v3;
  size_t v4;
  char *v5;
  BOOL v6;
  unsigned int v7;
  unint64_t v8;
  Dl_info v11;
  char __str[128];
  void *v13[130];

  v13[128] = *(void **)MEMORY[0x1E0C80C00];
  bzero(v13, 0x400uLL);
  memset(&v11, 0, sizeof(v11));
  v2 = backtrace(v13, 128);
  if (a1)
    v3 = a1 + 1;
  else
    v3 = v2;
  if (v3 >= v2)
    v4 = v2;
  else
    v4 = v3;
  v5 = (char *)malloc_type_calloc(0x81uLL, v4, 0x48329A03uLL);
  if (v5)
    v6 = v4 >= 3;
  else
    v6 = 0;
  if (v6)
  {
    v7 = 3;
    v8 = 2;
    do
    {
      if (dladdr(v13[v8], &v11))
        snprintf(__str, 0x80uLL, "%1.*s<%s+%ld>");
      else
        snprintf(__str, 0x80uLL, "%1.*s%8lx");
      strcat(v5, __str);
      if (v4 - 2 > v8)
        *(_WORD *)&v5[strlen(v5)] = 10;
      v8 = v7;
    }
    while (v4 > v7++);
  }
  return v5;
}

void CGTextClippingRelease(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;
  _QWORD *v4;
  const void *v5;

  if (a1)
  {
    do
    {
      v2 = __ldxr(a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, a1));
    if (!v3)
    {
      while (1)
      {
        v4 = (_QWORD *)*((_QWORD *)a1 + 1);
        if (!v4)
          break;
        *((_QWORD *)a1 + 1) = *v4;
        v5 = (const void *)v4[1];
        if (v5)
          CFRelease(v5);
        free(v4);
      }
      free(a1);
    }
  }
}

uint64_t CGTextClippingEqualToTextClipping(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t *v4;
  uint64_t *v5;
  _BOOL4 v6;
  _BOOL4 v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v22;
  double *v23;
  double *v24;

  if (a1 == a2)
    return 1;
  result = 1;
  if (a1 && a2)
  {
    v4 = *(uint64_t **)(a2 + 8);
    v5 = *(uint64_t **)(a1 + 8);
    v6 = v5 != 0;
    v7 = v4 != 0;
    if (v5 && v4)
    {
      while (1)
      {
        v8 = v5[1];
        if (v8)
        {
          v11 = *(_DWORD *)(v8 + 24);
          v10 = (unsigned int *)(v8 + 24);
          v9 = v11;
          if (!v11)
          {
            do
              v12 = __ldxr((unsigned int *)&get_identifier_identifier);
            while (__stxr(v12 + 1, (unsigned int *)&get_identifier_identifier));
            v13 = ~v12;
            while (!__ldxr(v10))
            {
              if (!__stxr(v13, v10))
                goto LABEL_15;
            }
            __clrex();
LABEL_15:
            v9 = *v10;
          }
        }
        else
        {
          v9 = 0;
        }
        v15 = v4[1];
        if (v15)
        {
          v18 = *(_DWORD *)(v15 + 24);
          v16 = (unsigned int *)(v15 + 24);
          v17 = v18;
          if (!v18)
          {
            do
              v19 = __ldxr((unsigned int *)&get_identifier_identifier);
            while (__stxr(v19 + 1, (unsigned int *)&get_identifier_identifier));
            v20 = ~v19;
            while (!__ldxr(v16))
            {
              if (!__stxr(v20, v16))
                goto LABEL_25;
            }
            __clrex();
LABEL_25:
            v17 = *v16;
          }
        }
        else
        {
          v17 = 0;
        }
        if (v9 != v17
          || *((double *)v5 + 2) == *((double *)v4 + 2)
          && (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(v5 + 3), *(float64x2_t *)(v4 + 3)), (int32x4_t)vceqq_f64(*(float64x2_t *)(v5 + 5), *(float64x2_t *)(v4 + 5)))), 0xFuLL))) & 1) != 0&& *((double *)v5 + 7) == *((double *)v4 + 7))
        {
          return 0;
        }
        v22 = v5[8];
        if (v22 != v4[8])
          return 0;
        if (v22)
        {
          v23 = (double *)(v5 + 11);
          v24 = (double *)(v4 + 11);
          while (*(unsigned __int16 *)v23 == *(unsigned __int16 *)v24)
          {
            if (*(v23 - 2) != *(v24 - 2) || *(v23 - 1) != *(v24 - 1))
              break;
            v23 += 3;
            v24 += 3;
            if (!--v22)
              goto LABEL_40;
          }
          return 0;
        }
LABEL_40:
        v4 = (uint64_t *)*v4;
        v5 = (uint64_t *)*v5;
        v6 = v5 != 0;
        v7 = v4 != 0;
        if (!v5 || !v4)
          return !v6 && !v7;
      }
    }
    else
    {
      return !v6 && !v7;
    }
  }
  return result;
}

_QWORD *CGTextClippingCreateCopyByApplyingTransform(uint64_t a1, float64x2_t *a2)
{
  _QWORD *v4;
  double *i;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  _QWORD *v9;
  uint64_t v10;
  float64x2_t *v11;
  double *v12;
  CGAffineTransform v14;

  v4 = malloc_type_malloc(0x18uLL, 0x2062DE7BuLL);
  *(_DWORD *)v4 = 1;
  v4[1] = 0;
  v4[2] = 0;
  if (!a2)
    a2 = (float64x2_t *)&CGAffineTransformIdentity;
  for (i = *(double **)(a1 + 8); i; i = *(double **)i)
  {
    *(_OWORD *)&v14.tx = 0uLL;
    v6 = *a2;
    *(float64x2_t *)&v14.c = a2[1];
    v7 = vaddq_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v14.c, i[7]), v6, i[6]), (float64x2_t)0);
    v8 = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v14.c, i[5]), v6, i[4]);
    *(float64x2_t *)&v14.a = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v14.c, i[3]), v6, i[2]);
    *(float64x2_t *)&v14.c = v8;
    *(float64x2_t *)&v14.tx = v7;
    v9 = add_glyph_clip((uint64_t)v4, *((const void **)i + 1), &v14, *((_QWORD *)i + 8));
    if (v9)
    {
      v10 = *((_QWORD *)i + 8);
      if (v10)
      {
        v11 = (float64x2_t *)(v9 + 11);
        v12 = i + 11;
        do
        {
          LOWORD(v11->f64[0]) = *(_WORD *)v12;
          v11[-1] = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_n_f64(a2[1], *(v12 - 1)), *a2, *(v12 - 2)));
          v11 = (float64x2_t *)((char *)v11 + 24);
          v12 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return v4;
}

_QWORD *add_glyph_clip(uint64_t a1, const void *a2, const CGAffineTransform *a3, uint64_t a4)
{
  _QWORD *v8;
  const CGAffineTransform *v9;
  __int128 v10;
  __int128 v11;
  _QWORD *v12;

  v8 = malloc_type_calloc(1uLL, 24 * a4 + 72, 0x64A29F66uLL);
  if (v8)
  {
    if (a2)
      CFRetain(a2);
    v8[1] = a2;
    v9 = &CGAffineTransformIdentity;
    if (a3)
      v9 = a3;
    v10 = *(_OWORD *)&v9->a;
    v11 = *(_OWORD *)&v9->tx;
    *((_OWORD *)v8 + 2) = *(_OWORD *)&v9->c;
    *((_OWORD *)v8 + 3) = v11;
    *((_OWORD *)v8 + 1) = v10;
    v8[8] = a4;
    v12 = (_QWORD *)(a1 + 8);
    if (*(_QWORD *)(a1 + 8))
      v12 = *(_QWORD **)(a1 + 16);
    *v12 = v8;
    *(_QWORD *)(a1 + 16) = v8;
  }
  return v8;
}

double CGTextClippingAppendGlyphs(uint64_t a1, const void *a2, const CGAffineTransform *a3, __int16 *a4, __int128 *a5, uint64_t a6)
{
  __int16 *v6;
  __int128 *v7;
  uint64_t v8;
  _QWORD *v9;
  double result;
  _WORD *v11;
  __int16 v12;
  __int128 v13;

  if (a1)
  {
    if (a2)
    {
      v6 = a4;
      if (a4)
      {
        v7 = a5;
        if (a5)
        {
          v8 = a6;
          v9 = add_glyph_clip(a1, a2, a3, a6);
          if (v9)
          {
            v11 = v9 + 11;
            do
            {
              v12 = *v6++;
              *v11 = v12;
              v13 = *v7++;
              result = *(double *)&v13;
              *((_OWORD *)v11 - 1) = v13;
              v11 += 12;
              --v8;
            }
            while (v8);
          }
        }
      }
    }
  }
  return result;
}

CGPath *CGTextClippingCreatePath(uint64_t a1)
{
  CGPath *Mutable;
  double *v3;
  _DWORD *font_info;
  int v5;
  unint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double *v26;
  uint64_t v27;
  const CGPath *v28;
  CGFloat v29;
  CGFloat v30;
  CGAffineTransform v32;

  Mutable = CGPathCreateMutable();
  if (Mutable)
  {
    v3 = *(double **)(a1 + 8);
    if (v3)
    {
      memset(&v32, 0, sizeof(v32));
      do
      {
        font_info = get_font_info(*((_QWORD **)v3 + 1));
        if (font_info)
          v5 = font_info[2];
        else
          v5 = 0;
        if (*((_QWORD *)v3 + 8))
        {
          v6 = 0;
          v8 = v3[4];
          v7 = v3[5];
          v9 = v7 * 0.0;
          v11 = v3[2];
          v10 = v3[3];
          v12 = v7 * 0.0 + v10 * 0.0 + v3[7];
          v13 = v8 * 0.0;
          v14 = v3[6] + v8 * 0.0 + v11 * 0.0;
          v15 = 1.0 / (double)v5;
          v16 = v15 * v7 + v10 * 0.0;
          v17 = v15 * v8 + v11 * 0.0;
          v18 = v9 + v15 * v10;
          v19 = v13 + v15 * v11;
          v20 = v19 + v18 * 0.0;
          v21 = v18 + v19 * 0.0;
          v22 = v17 + v16 * 0.0;
          v23 = v16 + v17 * 0.0;
          v24 = v14 + v12 * 0.0;
          v25 = v12 + v14 * 0.0;
          v26 = v3 + 11;
          do
          {
            v27 = *((_QWORD *)v3 + 1);
            if (v27)
              v28 = (const CGPath *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(v27 + 16) + 400))(*(_QWORD *)(v27 + 112), 0, *(unsigned __int16 *)v26);
            else
              v28 = 0;
            v29 = *(v26 - 2) + v24;
            v30 = v25 + *(v26 - 1);
            v32.a = v20;
            v32.b = v21;
            v32.c = v22;
            v32.d = v23;
            v32.tx = v29;
            v32.ty = v30;
            CGPathAddPath(Mutable, &v32, v28);
            if (v28)
              CFRelease(v28);
            ++v6;
            v26 += 3;
          }
          while (v6 < *((_QWORD *)v3 + 8));
        }
        v3 = *(double **)v3;
      }
      while (v3);
    }
  }
  return Mutable;
}

size_t data_get_bytes_at_position(uint64_t a1, void *__dst, uint64_t a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  uint64_t v9;

  if (a3 < 0)
    _CGHandleAssert("data_get_bytes_at_position", 64, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderData.c", "offset >= 0", "offset %lld", a6, a7, a8, a3);
  v8 = a4;
  if ((uint64_t)(a4 + a3) >= 1)
  {
    v9 = *(_QWORD *)(a1 + 8);
    if (v9 > a3)
    {
      if (a4 + a3 > v9)
        v8 = v9 - a3;
      memcpy(__dst, (const void *)(*(_QWORD *)(a1 + 16) + a3), v8);
    }
  }
  return v8;
}

CGDataProviderRef CGDataProviderCreateWithDataNoCopy(uint64_t a1, const void *a2, size_t a3, uint64_t a4)
{
  _QWORD *v7;
  const __CFAllocator *v8;
  const __CFData *v9;
  CGDataProviderRef v10;
  CFAllocatorContext v12;

  check_clients_buffer("CGDataProviderCreateWithDataNoCopy", a2, a3);
  v7 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
  *v7 = 0;
  v7[1] = a3;
  v7[2] = a2;
  v7[3] = a4;
  v12.version = 0;
  memset(&v12.retain, 0, 40);
  v12.info = v7;
  v12.deallocate = (CFAllocatorDeallocateCallBack)no_copy_deallocator_deallocate;
  v12.preferredSize = 0;
  v8 = CFAllocatorCreate(0, &v12);
  v9 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)a2, a3, v8);
  if (v8)
    CFRelease(v8);
  if (!v9)
    return 0;
  v10 = CGDataProviderCreateWithCFData(v9);
  CFRelease(v9);
  return v10;
}

void no_copy_deallocator_deallocate(uint64_t a1, _QWORD *a2)
{
  void (*v3)(_QWORD, uint64_t, _QWORD);

  v3 = (void (*)(_QWORD, uint64_t, _QWORD))a2[3];
  if (v3)
    v3(*a2, a1, a2[1]);
  free(a2);
}

size_t cf_get_bytes_at_position(const __CFData *a1, void *a2, uint64_t a3, size_t a4)
{
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  if (a3 < 0)
    _CGHandleAssert("cf_get_bytes_at_position", 292, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderData.c", "offset >= 0", "offset %lld", v10, v11, v12, a3);
  if ((uint64_t)(a4 + a3) >= 1 && Length > a3)
  {
    if ((uint64_t)(a4 + a3) > Length)
      a4 = Length - a3;
    memcpy(a2, &BytePtr[a3], a4);
  }
  return a4;
}

__CFData *CGDataProviderCopyPixelData(CFIndex *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v6;
  CFIndex v7;
  uint64_t v8;
  const UInt8 *v9;
  const __CFAllocator *v10;
  __CFData *Mutable;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  char *MutableBytePtr;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v25;
  uint64_t v26;
  _BOOL4 v27;
  uint64_t v28;
  int64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  CFIndex v37;
  unint64_t v38;
  uint64_t Bytes;
  uint64_t v40;
  int64_t v41;
  BOOL v42;
  uint64_t v43;
  UInt8 *v44;
  CFAllocatorContext context;
  CFRange v46;
  CFRange v47;

  v6 = (unint64_t)(a4 * a2 + 7) >> 3;
  v7 = v6 * a3;
  if (a5 != v6)
  {
    v14 = CGAccessSessionCreate((CGDataProvider *)a1);
    if (v14)
    {
      v18 = a5 - v6;
      if (a5 <= v6)
        _CGHandleAssert("CGDataProviderCopyPixelData", 778, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderData.c", "bytes_per_row > pixel_bytes_per_row", "bpr %zu  pbpr %zu", v15, v16, v17, a5);
      v19 = v14;
      Mutable = CFDataCreateMutable(0, 0);
      if (CGCFDataIncreaseLength(Mutable, v7))
      {
        MutableBytePtr = (char *)CFDataGetMutableBytePtr(Mutable);
        CGAccessSessionGetChunksAtPosition(v19, 0, v6, v18, a3, MutableBytePtr, 0, v21);
        CFDataGetLength(Mutable);
        v22 = v19;
LABEL_9:
        CGAccessSessionRelease(v22);
        return Mutable;
      }
      CFRelease(Mutable);
      v23 = v19;
      goto LABEL_11;
    }
    return 0;
  }
  if (!a1)
    return 0;
  v8 = CGDataProviderRetainBytePtr((uint64_t)a1);
  if (!v8)
  {
    v25 = CGAccessSessionCreate((CGDataProvider *)a1);
    CGDataProviderReleaseBytePtr((uint64_t)a1);
    if (!v25)
      return 0;
    if (*v25)
    {
      v26 = *(_QWORD *)(*v25 + 32);
      v27 = v7 == 0;
      v28 = v26;
      if (v26 != -1)
      {
LABEL_20:
        if (v27)
          v29 = v28;
        else
          v29 = v7;
        Mutable = CFDataCreateMutable(0, 0);
        if ((CGCFDataIncreaseLength(Mutable, v29) & 1) != 0)
        {
          v30 = (char *)CFDataGetMutableBytePtr(Mutable);
          v36 = 0;
          v37 = 0;
          v38 = v7 - 1;
          while (1)
          {
            Bytes = CGAccessSessionGetBytes(v25, v30, v29, v31, v32, v33, v34, v35);
            if (!Bytes)
              break;
            v40 = Bytes;
            v41 = v29 - Bytes;
            if (v29 <= Bytes)
            {
              if (Bytes == v26)
                goto LABEL_51;
            }
            else
            {
              v46.location = CFDataGetLength(Mutable) - v41;
              v46.length = v41;
              CFDataDeleteBytes(Mutable, v46);
            }
            v42 = v29 == v40 && v37 <= v29;
            v43 = 2 * v29;
            if (!v42)
              v43 = v40;
            if (v43 >= 0x4000000)
              v43 = 0x4000000;
            if (v43 <= 0x4000)
              v37 = 0x4000;
            else
              v37 = v43;
            if ((CGCFDataIncreaseLength(Mutable, v37) & 1) == 0)
            {
              CGAccessSessionRelease(v25);
              CFRelease(Mutable);
              return 0;
            }
            v36 += v40;
            v44 = CFDataGetMutableBytePtr(Mutable);
            if (v44)
            {
              v30 = (char *)&v44[v36];
            }
            else
            {
              CFRelease(Mutable);
              Mutable = 0;
              v30 = 0;
            }
            v29 = v37;
            if (v38 < v36)
              goto LABEL_51;
          }
          if (CGAccessSessionHasError((CFTypeRef *)v25) || !v36)
          {
            CFRelease(Mutable);
            Mutable = 0;
          }
          else
          {
            v47.location = CFDataGetLength(Mutable) - v29;
            v47.length = v29;
            CFDataDeleteBytes(Mutable, v47);
          }
LABEL_51:
          v22 = v25;
          goto LABEL_9;
        }
        CFRelease(Mutable);
        v23 = v25;
LABEL_11:
        CGAccessSessionRelease(v23);
        return 0;
      }
    }
    else
    {
      v27 = v7 == 0;
      v26 = -1;
    }
    v28 = 0x10000;
    goto LABEL_20;
  }
  v9 = (const UInt8 *)v8;
  CGDataProviderRetainBytePtr((uint64_t)a1);
  context.version = 0;
  memset(&context.retain, 0, 40);
  context.info = a1;
  context.deallocate = (CFAllocatorDeallocateCallBack)provider_allocator_deallocate;
  context.preferredSize = 0;
  v10 = CFAllocatorCreate(0, &context);
  Mutable = CFDataCreateWithBytesNoCopy(0, v9, a1[4], v10);
  CGDataProviderReleaseBytePtr((uint64_t)a1);
  CFRelease(v10);
  return Mutable;
}

double CGGStateGetClipRect(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void CGGStateClipToOwnedPath(uint64_t *a1, CGPathRef path, int a3)
{
  __int16 v3;
  char *v6;
  char *v7;
  char v8;
  char *v9;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  char *v15;
  CGRect v16;

  if (path)
  {
    v3 = a3;
    if (a3 == 2)
    {
      v6 = CGClipStrokeCreateWithGState((uint64_t)a1);
      if (v6)
      {
        v7 = v6;
        v8 = v6[67];
        v9 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
        if (v9)
        {
          v10 = v9;
          *(_DWORD *)v9 = 1;
          do
          {
            v11 = __ldxr((unsigned int *)&CGClipCreate_identifier);
            v12 = v11 + 1;
          }
          while (__stxr(v12, (unsigned int *)&CGClipCreate_identifier));
          *((_DWORD *)v9 + 1) = v12;
          *((_WORD *)v9 + 4) = 514;
          v9[10] = v8;
          *((_QWORD *)v9 + 4) = *((_QWORD *)v7 + 11);
          *((_QWORD *)v9 + 2) = v7;
          *((_QWORD *)v9 + 3) = path;
          goto LABEL_14;
        }
      }
      goto LABEL_15;
    }
    v13 = *(_QWORD *)(a1[18] + 8);
    v14 = *(_DWORD *)(a1[15] + 4);
    memset(&v16, 0, sizeof(v16));
    if (CGPathIsRect(path, &v16))
    {
      CFRelease(path);
      v10 = (char *)CGClipCreateWithRect(0, HIBYTE(v14) & 1, v16.origin.x, v16.origin.y, v16.size.width, v16.size.height);
      if (!v10)
        goto LABEL_15;
    }
    else
    {
      v15 = (char *)CGClipCreate(v3, HIBYTE(v14) & 1);
      if (!v15)
      {
LABEL_15:
        CFRelease(path);
        return;
      }
      v10 = v15;
      *((_QWORD *)v15 + 4) = v13;
      *((_QWORD *)v15 + 3) = path;
    }
LABEL_14:
    maybeCopyClipState((uint64_t)a1);
    CGClipStackAddClip(a1[14], (uint64_t)v10);
    CGClipRelease(v10);
  }
}

void CGGStateClipToTextClipping(uint64_t a1, uint64_t a2)
{
  unsigned int *CopyByApplyingTransform;
  unsigned int *v4;
  unsigned int *v5;
  char *v6;

  CopyByApplyingTransform = (unsigned int *)CGTextClippingCreateCopyByApplyingTransform(a2, (float64x2_t *)(a1 + 24));
  if (CopyByApplyingTransform)
  {
    v4 = CopyByApplyingTransform;
    v5 = CGClipCreateWithTextClipping(CopyByApplyingTransform);
    if (v5)
    {
      v6 = (char *)v5;
      maybeCopyClipState(a1);
      CGClipStackAddClip(*(_QWORD *)(a1 + 112), (uint64_t)v6);
      CGClipRelease(v6);
    }
    CGTextClippingRelease(v4);
  }
}

double CGGStateGetClipBoundingBox(uint64_t a1)
{
  double *v1;

  v1 = *(double **)(a1 + 112);
  if (v1)
    return CGClipStackGetBounds(v1);
  else
    return -8.98846567e307;
}

void CGSConvertAlphaByteInterleved(int a1, int a2, int a3, int a4, unsigned __int8 *a5, _BYTE *a6, int a7, int a8, int a9, unsigned __int8 *a10, _BYTE *a11, int a12, int a13, int a14)
{
  _BYTE *v14;
  _WORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t v24;
  _BYTE *v25;
  unsigned __int8 *v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  __int16 v33;
  BOOL v34;
  int v35;
  uint64_t v36;
  unsigned __int8 v37;
  int v38;
  uint64_t v39;
  unsigned __int8 v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  _WORD *v56;
  size_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;

  v14 = a6;
  v17 = &inverted_8bit_alpha;
  if (a1 >= 0)
    v17 = 0;
  v56 = v17;
  if (a9 < 1)
  {
    if (a9 < 0)
      v18 = a4 + 1;
    else
      v18 = 1;
    if (a9 < 0)
      v19 = a4 + 1;
    else
      v19 = a4;
    if (a9 < 0)
      ++a5;
  }
  else
  {
    v14 = &a6[a4];
    v18 = a4 + 1;
    v19 = v18;
  }
  v20 = a4;
  v21 = 1;
  v22 = a4 + 1;
  if (a14 >= 0)
  {
    v23 = a10;
  }
  else
  {
    v20 = v22;
    v21 = v22;
    v23 = a10 + 1;
  }
  if (a14 >= 1)
    v24 = v22;
  else
    v24 = v20;
  if (a14 < 1)
  {
    v25 = a11;
  }
  else
  {
    v21 = v22;
    v25 = &a11[a4];
  }
  if (a14 >= 1)
    v26 = a10;
  else
    v26 = v23;
  if (a4 != 3)
  {
    v62 = (a4 - 1);
    v57 = a4;
    v61 = a4 - 2;
    v53 = a7 - (int)v19 * (uint64_t)a2;
    v54 = a2;
    v51 = a12 - (int)v24 * (uint64_t)a2;
    v52 = a8 - (int)v18 * (uint64_t)a2;
    v50 = a13 - (int)v21 * (uint64_t)a2;
    v59 = a4;
    v60 = v21;
    v58 = v19;
    while (1)
    {
      v55 = a3;
      if (a2 >= 1)
        break;
LABEL_76:
      a3 = v55 - 1;
      a2 = v54;
      a5 += v53;
      v14 += v52;
      v26 += v51;
      v25 += v50;
      if (v55 <= 1)
        return;
    }
    v35 = a2;
    while (1)
    {
      v36 = *v14;
      if ((_DWORD)v36 == 255)
      {
        v37 = a5[(int)v62];
        if (a4 < 2)
        {
          v40 = a5[(int)v62];
        }
        else
        {
          v38 = v61;
          v39 = v62;
          do
          {
            v40 = a5[v38];
            v26[v39] = v37;
            --v38;
            v37 = v40;
            v34 = v39-- <= 1;
          }
          while (!v34);
        }
      }
      else
      {
        if (!*v14)
        {
          if (a4 >= 1)
          {
            bzero(v26, v57);
            a4 = v59;
            v21 = v60;
            v19 = v58;
          }
          goto LABEL_74;
        }
        v41 = a5[(int)v62];
        if (a1)
        {
          if (a1 < 1)
          {
            v47 = v56[v36];
            if (a4 > 1)
            {
              v48 = v62;
              do
              {
                v49 = v41 * v47;
                v34 = v48 <= 1;
                LOWORD(v41) = a5[(v48 - 1)];
                v26[v48--] = HIBYTE(v49);
              }
              while (!v34);
            }
            LOWORD(v44) = v41 * v47;
          }
          else
          {
            if (a4 >= 2)
            {
              v42 = v62;
              do
              {
                v43 = v41 * v36;
                v34 = v42 <= 1;
                v41 = a5[(v42 - 1)];
                v26[v42--] = (unsigned __int16)(v43 + (v43 >> 8) + 1) >> 8;
              }
              while (!v34);
            }
            v44 = v41 * v36 + ((v41 * v36) >> 8) + 1;
          }
          *v26 = BYTE1(v44);
          goto LABEL_74;
        }
        if (a4 < 2)
        {
          v40 = a5[(int)v62];
        }
        else
        {
          v45 = v61;
          v46 = v62;
          do
          {
            v40 = a5[v45];
            v26[v46] = v41;
            --v45;
            LOBYTE(v41) = v40;
            v34 = v46-- <= 1;
          }
          while (!v34);
        }
      }
      *v26 = v40;
LABEL_74:
      v14 += v18;
      a5 += v19;
      *v25 = v36;
      v26 += v24;
      v25 += v21;
      v34 = v35-- <= 1;
      if (v34)
        goto LABEL_76;
    }
  }
  do
  {
    if (a2 >= 1)
    {
      v27 = a2 + 1;
      do
      {
        v28 = *v14;
        if (*v14)
        {
          if ((_DWORD)v28 == 255 || !a1)
          {
            *(_WORD *)v26 = *(_WORD *)a5;
            LOBYTE(v31) = a5[2];
          }
          else
          {
            if (a1 < 1)
            {
              v32 = (unsigned __int16)v56[v28];
              v33 = a5[1] * (_WORD)v32;
              *v26 = (unsigned __int16)(*a5 * (_WORD)v32) >> 8;
              v26[1] = HIBYTE(v33);
              v30 = a5[2] * v32;
            }
            else
            {
              v29 = a5[1] * (_DWORD)v28 + ((a5[1] * v28) >> 8) + 1;
              *v26 = (unsigned __int16)(*a5 * (_WORD)v28 + ((*a5 * v28) >> 8) + 1) >> 8;
              v26[1] = BYTE1(v29);
              v30 = a5[2] * (_DWORD)v28 + ((a5[2] * v28) >> 8) + 1;
            }
            v31 = v30 >> 8;
          }
        }
        else
        {
          LOBYTE(v31) = 0;
          *(_WORD *)v26 = 0;
        }
        v14 += v18;
        v26[2] = v31;
        a5 += v19;
        *v25 = v28;
        v26 += v24;
        v25 += v21;
        --v27;
      }
      while (v27 > 1);
    }
    a5 += a7 - (int)v19 * (uint64_t)a2;
    v14 += a8 - (int)v18 * (uint64_t)a2;
    v26 += a12 - (int)v24 * (uint64_t)a2;
    v25 += a13 - (int)v21 * (uint64_t)a2;
    v34 = a3-- <= 1;
  }
  while (!v34);
}

void CGSConvertAlphaByteMeshed(int a1, int a2, int a3, int a4, uint64_t *a5, int a6, _BYTE **a7, int a8, int a9)
{
  int v10;
  _WORD *v12;
  int v13;
  int v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  char v24;
  BOOL v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  _WORD *v38;
  int v39;
  size_t v40;
  int v41;

  v10 = a2;
  v12 = &inverted_8bit_alpha;
  if (a1 >= 0)
    v12 = 0;
  v38 = v12;
  v13 = (a4 + 1) * a2;
  v36 = a6 - (uint64_t)v13;
  v35 = a8 - (uint64_t)v13;
  if (a9 <= 0)
    v14 = -1;
  else
    v14 = a4;
  if (v14 >= 1)
    v15 = *a7;
  else
    v15 = *a7 + 1;
  v16 = v14;
  if (v14 >= 1)
    v17 = *a5;
  else
    v17 = *a5 + 1;
  v18 = (a4 - 1);
  v19 = a4 + 1;
  v40 = a4;
  v41 = a4 - 2;
  do
  {
    v39 = a3;
    if (v10 >= 1)
    {
      do
      {
        v20 = *(unsigned __int8 *)(v17 + v16);
        if ((_DWORD)v20 == 255)
        {
          v21 = *(_BYTE *)(v17 + (int)v18);
          if (a4 < 2)
          {
            v24 = *(_BYTE *)(v17 + (int)v18);
          }
          else
          {
            v22 = v41;
            v23 = v18;
            do
            {
              v24 = *(_BYTE *)(v17 + v22);
              v15[v23] = v21;
              --v22;
              v21 = v24;
              v25 = v23-- <= 1;
            }
            while (!v25);
          }
        }
        else
        {
          if (!*(_BYTE *)(v17 + v16))
          {
            if (a4 >= 1)
              bzero(v15, v40);
            goto LABEL_44;
          }
          v26 = *(unsigned __int8 *)(v17 + (int)v18);
          if (a1)
          {
            if (a1 < 1)
            {
              v32 = v38[v20];
              if (a4 > 1)
              {
                v33 = v18;
                do
                {
                  v34 = v26 * v32;
                  v25 = v33 <= 1;
                  LOWORD(v26) = *(unsigned __int8 *)(v17 + (v33 - 1));
                  v15[v33--] = HIBYTE(v34);
                }
                while (!v25);
              }
              LOWORD(v29) = v26 * v32;
            }
            else
            {
              if (a4 >= 2)
              {
                v27 = v18;
                do
                {
                  v28 = v26 * v20;
                  v25 = v27 <= 1;
                  v26 = *(unsigned __int8 *)(v17 + (v27 - 1));
                  v15[v27--] = (unsigned __int16)(v28 + (v28 >> 8) + 1) >> 8;
                }
                while (!v25);
              }
              v29 = v26 * v20 + ((v26 * v20) >> 8) + 1;
            }
            *v15 = BYTE1(v29);
            goto LABEL_44;
          }
          if (a4 < 2)
          {
            v24 = *(_BYTE *)(v17 + (int)v18);
          }
          else
          {
            v30 = v41;
            v31 = v18;
            do
            {
              v24 = *(_BYTE *)(v17 + v30);
              v15[v31] = v26;
              --v30;
              LOBYTE(v26) = v24;
              v25 = v31-- <= 1;
            }
            while (!v25);
          }
        }
        *v15 = v24;
LABEL_44:
        v17 += v19;
        v15[v16] = v20;
        v15 += v19;
        v25 = v10-- <= 1;
      }
      while (!v25);
    }
    a3 = v39 - 1;
    v17 += v36;
    v15 += v35;
    v10 = a2;
  }
  while (v39 > 1);
}

uint64_t CGSConvertAlphaByteMeshedXXXX(uint64_t result, int a2, int a3, unsigned int *a4, int a5, unsigned int *a6, int a7, int a8)
{
  _WORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int *v21;
  unsigned int *v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int *v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  BOOL v29;
  int v30;
  unsigned int *v31;
  unsigned int *v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  unsigned int *v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  unsigned int *v68;
  int v69;
  unsigned int v70;
  uint64_t v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;

  v8 = &inverted_8bit_alpha;
  if ((int)result >= 0)
    v8 = 0;
  v9 = a5;
  v10 = a7;
  if (a8 <= 0)
  {
    do
    {
      v30 = a2;
      v31 = a6;
      v32 = a4;
      if (a2 >= 4)
      {
        v33 = 0;
        v30 = a2;
        do
        {
          v34 = v30;
          v35 = &a4[v33];
          v36 = a4[v33];
          v37 = a4[v33 + 1];
          if ((_DWORD)result)
          {
            v38 = a4[v33 + 1];
            if ((a4[v33 + 1] & v36) != 0xFF)
            {
              if (a4[v33])
              {
                if (a4[v33] != 255)
                {
                  v39 = a4[v33];
                  if ((int)result < 1)
                  {
                    v47 = (unsigned __int16)v8[v39];
                    v48 = v36 >> 8;
                    v43 = ((BYTE1(v36) * v47) | (((v36 >> 8) & 0xFF0000) * v47)) & 0xFF00FF00;
                    v42 = ((v48 & 0xFF00) * v47) & 0xFF0000 | v39;
                  }
                  else
                  {
                    v40 = ((v36 >> 8) & 0xFF00FF) * v39;
                    v41 = (v36 & 0xFF0000 | 0xFF) * v39;
                    v42 = (v40 + 65537 + ((v40 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    v43 = ((v41 + 65537 + ((v41 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  v36 = v43 | v42;
                }
              }
              else
              {
                v36 = 0;
              }
              if (a4[v33 + 1])
              {
                if (a4[v33 + 1] != 255)
                {
                  if ((int)result < 1)
                  {
                    v53 = (unsigned __int16)v8[v38];
                    v54 = v37 >> 8;
                    v52 = ((BYTE1(v37) * v53) | (((v37 >> 8) & 0xFF0000) * v53)) & 0xFF00FF00;
                    v51 = ((v54 & 0xFF00) * v53) & 0xFF0000 | v38;
                  }
                  else
                  {
                    v49 = ((v37 >> 8) & 0xFF00FF) * v38;
                    v50 = (v37 & 0xFF0000 | 0xFF) * v38;
                    v51 = (v49 + 65537 + ((v49 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    v52 = ((v50 + 65537 + ((v50 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  v37 = v52 | v51;
                }
              }
              else
              {
                v37 = 0;
              }
            }
            v55 = &a6[v33];
            *v55 = v36;
            v55[1] = v37;
            v45 = a4[v33 + 2];
            v46 = a4[v33 + 3];
            v56 = v46;
            if ((v46 & v45) != 0xFF)
            {
              if (a4[v33 + 2])
              {
                if (a4[v33 + 2] != 255)
                {
                  v57 = a4[v33 + 2];
                  if ((int)result < 1)
                  {
                    v62 = (unsigned __int16)v8[v57];
                    v63 = v45 >> 8;
                    v61 = ((BYTE1(v45) * v62) | (((v45 >> 8) & 0xFF0000) * v62)) & 0xFF00FF00;
                    v60 = ((v63 & 0xFF00) * v62) & 0xFF0000 | v57;
                  }
                  else
                  {
                    v58 = ((v45 >> 8) & 0xFF00FF) * v57;
                    v59 = (v45 & 0xFF0000 | 0xFF) * v57;
                    v60 = (v58 + 65537 + ((v58 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    v61 = ((v59 + 65537 + ((v59 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  v45 = v61 | v60;
                }
              }
              else
              {
                v45 = 0;
              }
              if ((_BYTE)v46)
              {
                if (v46 != 255)
                {
                  if ((int)result < 1)
                  {
                    v66 = (unsigned __int16)v8[v46];
                    v67 = v46 >> 8;
                    v65 = ((BYTE1(v46) * v66) | (((v46 >> 8) & 0xFF0000) * v66)) & 0xFF00FF00;
                    v64 = ((v67 & 0xFF00) * v66) & 0xFF0000 | v56;
                  }
                  else
                  {
                    v64 = (((v46 >> 8) & 0xFF00FF) * v46
                         + 65537
                         + (((((v46 >> 8) & 0xFF00FF) * v46) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    v65 = (((v46 & 0xFF0000 | 0xFF) * v46
                          + 65537
                          + ((((v46 & 0xFF0000 | 0xFF) * v46) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  v46 = v65 | v64;
                }
              }
              else
              {
                v46 = 0;
              }
            }
          }
          else
          {
            v44 = &a6[v33];
            *v44 = v36;
            v44[1] = v37;
            v45 = v35[2];
            v46 = v35[3];
          }
          v68 = &a6[v33];
          v68[2] = v45;
          v68[3] = v46;
          v30 = v34 - 4;
          v33 += 4;
        }
        while (v34 > 7);
        v32 = &a4[v33];
        v31 = &a6[v33];
      }
      if (v30 >= 1)
      {
        v69 = v30 + 1;
        do
        {
          v70 = *v32;
          if ((_DWORD)result)
          {
            if (*v32)
            {
              if (*v32 != 255)
              {
                v71 = *v32;
                if ((int)result < 1)
                {
                  v76 = (unsigned __int16)v8[v71];
                  v77 = v70 >> 8;
                  v75 = ((BYTE1(v70) * v76) | (((v70 >> 8) & 0xFF0000) * v76)) & 0xFF00FF00;
                  v74 = ((v77 & 0xFF00) * v76) & 0xFF0000 | v71;
                }
                else
                {
                  v72 = ((v70 >> 8) & 0xFF00FF) * v71;
                  v73 = (v70 & 0xFF0000 | 0xFF) * v71;
                  v74 = (v72 + 65537 + ((v72 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  v75 = ((v73 + 65537 + ((v73 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                v70 = v75 | v74;
              }
            }
            else
            {
              v70 = 0;
            }
          }
          *v31++ = v70;
          ++v32;
          --v69;
        }
        while (v69 > 1);
      }
      a4 = (unsigned int *)((char *)a4 + v9);
      a6 = (unsigned int *)((char *)a6 + v10);
      v29 = a3-- <= 1;
    }
    while (!v29);
  }
  else
  {
    do
    {
      v11 = a2;
      v12 = a6;
      v13 = a4;
      if (a2 >= 4)
      {
        v14 = 0;
        v11 = a2;
        do
        {
          v15 = v11;
          v16 = &a4[v14];
          v17 = a4[v14];
          v18 = a4[v14 + 1];
          if ((_DWORD)result)
          {
            v19 = v17 >> 24;
            v20 = v18 >> 24;
            if ((HIBYTE(a4[v14 + 1]) & HIBYTE(a4[v14])) != 0xFF)
            {
              if ((_DWORD)v19 != 255)
              {
                if (BYTE3(v17))
                {
                  if ((int)result < 1)
                    LODWORD(v17) = (BYTE1(v17) * v8[v19]) & 0xFF00 | v17 & 0xFF000000 | (((v17 >> 8) & 0xFF00)
                                                                                       * (unsigned __int16)v8[v19]) & 0xFF0000 | ((unsigned __int16)(v17 * v8[v19]) >> 8);
                  else
                    LODWORD(v17) = ((BYTE1(v17) | 0xFF0000) * v19
                                  + 65537
                                  + ((((BYTE1(v17) | 0xFF0000) * v19) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v17 & 0xFF00FF) * v19 + 65537 + ((((v17 & 0xFF00FF) * v19) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v17) = 0;
                }
              }
              if ((_DWORD)v20 != 255)
              {
                if (BYTE3(v18))
                {
                  if ((int)result < 1)
                    LODWORD(v18) = (BYTE1(v18) * v8[v20]) & 0xFF00 | v18 & 0xFF000000 | (((v18 >> 8) & 0xFF00)
                                                                                       * (unsigned __int16)v8[v20]) & 0xFF0000 | ((unsigned __int16)(v18 * v8[v20]) >> 8);
                  else
                    LODWORD(v18) = ((BYTE1(v18) | 0xFF0000) * v20
                                  + 65537
                                  + ((((BYTE1(v18) | 0xFF0000) * v20) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v18 & 0xFF00FF) * v20 + 65537 + ((((v18 & 0xFF00FF) * v20) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v18) = 0;
                }
              }
            }
            v22 = &a6[v14];
            *v22 = v17;
            v22[1] = v18;
            v17 = a4[v14 + 2];
            v18 = a4[v14 + 3];
            v23 = v17 >> 24;
            v24 = v18 >> 24;
            if ((HIBYTE(a4[v14 + 3]) & HIBYTE(a4[v14 + 2])) != 0xFF)
            {
              if ((_DWORD)v23 != 255)
              {
                if (BYTE3(v17))
                {
                  if ((int)result < 1)
                    LODWORD(v17) = (BYTE1(v17) * v8[v23]) & 0xFF00 | v17 & 0xFF000000 | (((v17 >> 8) & 0xFF00)
                                                                                       * (unsigned __int16)v8[v23]) & 0xFF0000 | ((unsigned __int16)(v17 * v8[v23]) >> 8);
                  else
                    LODWORD(v17) = ((BYTE1(v17) | 0xFF0000) * v23
                                  + 65537
                                  + ((((BYTE1(v17) | 0xFF0000) * v23) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v17 & 0xFF00FF) * v23 + 65537 + ((((v17 & 0xFF00FF) * v23) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v17) = 0;
                }
              }
              if ((_DWORD)v24 != 255)
              {
                if (BYTE3(v18))
                {
                  if ((int)result < 1)
                    LODWORD(v18) = (BYTE1(v18) * v8[v24]) & 0xFF00 | v18 & 0xFF000000 | (((v18 >> 8) & 0xFF00)
                                                                                       * (unsigned __int16)v8[v24]) & 0xFF0000 | ((unsigned __int16)(v18 * v8[v24]) >> 8);
                  else
                    LODWORD(v18) = ((BYTE1(v18) | 0xFF0000) * v24
                                  + 65537
                                  + ((((BYTE1(v18) | 0xFF0000) * v24) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v18 & 0xFF00FF) * v24 + 65537 + ((((v18 & 0xFF00FF) * v24) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v18) = 0;
                }
              }
            }
          }
          else
          {
            v21 = &a6[v14];
            *v21 = v17;
            v21[1] = v18;
            LODWORD(v17) = v16[2];
            LODWORD(v18) = v16[3];
          }
          v25 = &a6[v14];
          v25[2] = v17;
          v25[3] = v18;
          v11 = v15 - 4;
          v14 += 4;
        }
        while (v15 > 7);
        v13 = &a4[v14];
        v12 = &a6[v14];
      }
      if (v11 >= 1)
      {
        v26 = v11 + 1;
        do
        {
          v27 = *v13;
          if ((_DWORD)result)
          {
            v28 = v27 >> 24;
            if (HIBYTE(*v13) != 255)
            {
              if (BYTE3(v27))
              {
                if ((int)result < 1)
                  LODWORD(v27) = (BYTE1(v27) * v8[v28]) & 0xFF00 | v27 & 0xFF000000 | (((v27 >> 8) & 0xFF00)
                                                                                     * (unsigned __int16)v8[v28]) & 0xFF0000 | ((unsigned __int16)(v27 * v8[v28]) >> 8);
                else
                  LODWORD(v27) = ((BYTE1(v27) | 0xFF0000) * v28
                                + 65537
                                + ((((BYTE1(v27) | 0xFF0000) * v28) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v27 & 0xFF00FF) * v28 + 65537 + ((((v27 & 0xFF00FF) * v28) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
              }
              else
              {
                LODWORD(v27) = 0;
              }
            }
          }
          *v12++ = v27;
          ++v13;
          --v26;
        }
        while (v26 > 1);
      }
      a4 = (unsigned int *)((char *)a4 + v9);
      a6 = (unsigned int *)((char *)a6 + v10);
      v29 = a3-- <= 1;
    }
    while (!v29);
  }
  return result;
}

void CGSConvertAlphaWordInterleved(int a1, int a2, int a3, uint64_t a4, unsigned __int16 *a5, _WORD *a6, int a7, int a8, int a9, unsigned __int16 *a10, _WORD *a11, int a12, int a13, int a14)
{
  _WORD *v14;
  unsigned __int16 *v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _WORD *v28;
  unsigned __int16 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 v46;
  int v47;
  uint64_t v48;
  unsigned __int16 v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;

  v14 = a6;
  v15 = a5;
  if (a9 < 1)
  {
    if (a9 < 0)
      v17 = (int)a4 + 1;
    else
      v17 = 1;
    if (a9 < 0)
      v18 = (int)a4 + 1;
    else
      v18 = (int)a4;
    if (a9 < 0)
      v15 = a5 + 1;
  }
  else
  {
    v14 = &a6[(int)a4];
    v17 = (int)a4 + 1;
    v18 = v17;
  }
  v19 = 2 * a2;
  v20 = a7 - v19 * v18;
  v21 = a8 - v19 * v17;
  v22 = (int)a4;
  v23 = a10 + 1;
  v24 = a4 + 1;
  v25 = (int)a4 + 1;
  if (a14 >= 0)
    v25 = 1;
  else
    v22 = v24;
  if (a14 >= 0)
    v23 = a10;
  if (a14 >= 1)
    v26 = v24;
  else
    v26 = v22;
  if (a14 >= 1)
    v27 = v24;
  else
    v27 = v25;
  if (a14 >= 1)
    v28 = &a11[(int)a4];
  else
    v28 = a11;
  if (a14 >= 1)
    v29 = a10;
  else
    v29 = v23;
  v30 = a12 - v19 * v26;
  v31 = a13 - v19 * v27;
  if ((_DWORD)a4 != 3)
  {
    v70 = (a4 - 1);
    v40 = (int)v70;
    v41 = 2 * v26;
    v69 = a4 - 2;
    v62 = v20;
    v63 = a2;
    v60 = v30;
    v61 = v21;
    v59 = v31;
    v68 = v17;
    v67 = a1;
    v65 = v41;
    v66 = 2 * a4;
    while (1)
    {
      v64 = a3;
      if (a2 >= 1)
        break;
LABEL_80:
      a3 = v64 - 1;
      a2 = v63;
      v15 = (unsigned __int16 *)((char *)v15 + v62);
      v14 = (_WORD *)((char *)v14 + v61);
      v29 = (unsigned __int16 *)((char *)v29 + v60);
      v28 = (_WORD *)((char *)v28 + v59);
      if (v64 <= 1)
        return;
    }
    v42 = a2;
    while (1)
    {
      v43 = (unsigned __int16)*v14;
      if (v43 == 0xFFFF)
      {
        v46 = v15[v40];
        if ((int)a4 < 2)
        {
          v49 = v15[v40];
        }
        else
        {
          v47 = v69;
          v48 = v70;
          do
          {
            v49 = v15[v47];
            v29[v48] = v46;
            --v47;
            v46 = v49;
            v39 = v48-- <= 1;
          }
          while (!v39);
        }
      }
      else
      {
        if (!*v14)
        {
          if ((int)a4 >= 1)
          {
            v44 = a4;
            v45 = v40;
            bzero(v29, v66);
            v41 = v65;
            v40 = v45;
            a4 = v44;
            v17 = v68;
            a1 = v67;
          }
          goto LABEL_78;
        }
        v50 = v15[v40];
        if (a1)
        {
          if (a1 < 1)
          {
            v56 = 0xFFFFFFFF / v43;
            if ((int)a4 > 1)
            {
              v57 = v70;
              do
              {
                v58 = v50 * v56;
                v39 = v57 <= 1;
                v50 = v15[(v57 - 1)];
                v29[v57--] = HIWORD(v58);
              }
              while (!v39);
            }
            v53 = v50 * v56;
          }
          else
          {
            if ((int)a4 >= 2)
            {
              v51 = v70;
              do
              {
                v52 = v50 * v43;
                v39 = v51 <= 1;
                v50 = v15[(v51 - 1)];
                v29[v51--] = (v52 + HIWORD(v52) + 1) >> 16;
              }
              while (!v39);
            }
            v53 = v50 * v43 + ((v50 * v43) >> 16) + 1;
          }
          *v29 = HIWORD(v53);
          goto LABEL_78;
        }
        if ((int)a4 < 2)
        {
          v49 = v15[v40];
        }
        else
        {
          v54 = v69;
          v55 = v70;
          do
          {
            v49 = v15[v54];
            v29[v55] = v50;
            --v54;
            LOWORD(v50) = v49;
            v39 = v55-- <= 1;
          }
          while (!v39);
        }
      }
      *v29 = v49;
LABEL_78:
      v14 += v17;
      v15 += v18;
      *v28 = v43;
      v29 = (unsigned __int16 *)((char *)v29 + v41);
      v28 += v27;
      v39 = v42-- <= 1;
      if (v39)
        goto LABEL_80;
    }
  }
  v32 = 2 * v26;
  do
  {
    if (a2 >= 1)
    {
      v33 = a2 + 1;
      do
      {
        v34 = (unsigned __int16)*v14;
        if (*v14)
        {
          if (v34 == 0xFFFF || !a1)
          {
            *(_DWORD *)v29 = *(_DWORD *)v15;
            LOWORD(v37) = v15[2];
          }
          else
          {
            if (a1 < 1)
            {
              v38 = 0xFFFFFFFF / v34 * v15[1];
              *v29 = (0xFFFFFFFF / v34 * *v15) >> 16;
              v29[1] = HIWORD(v38);
              v36 = 0xFFFFFFFF / v34 * v15[2];
            }
            else
            {
              v35 = v15[1] * v34 + ((v15[1] * v34) >> 16) + 1;
              *v29 = (*v15 * v34 + ((*v15 * v34) >> 16) + 1) >> 16;
              v29[1] = HIWORD(v35);
              v36 = v15[2] * v34 + ((v15[2] * v34) >> 16) + 1;
            }
            v37 = HIWORD(v36);
          }
        }
        else
        {
          LOWORD(v37) = 0;
          *(_DWORD *)v29 = 0;
        }
        --v33;
        v15 += v18;
        v29[2] = v37;
        *v28 = v34;
        v28 += v27;
        v14 += v17;
        v29 = (unsigned __int16 *)((char *)v29 + v32);
      }
      while (v33 > 1);
    }
    v15 = (unsigned __int16 *)((char *)v15 + v20);
    v14 = (_WORD *)((char *)v14 + v21);
    v29 = (unsigned __int16 *)((char *)v29 + v30);
    v28 = (_WORD *)((char *)v28 + v31);
    v39 = a3-- <= 1;
  }
  while (!v39);
}

void CGSConvertAlphaWordMeshed(int a1, int a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, int a9)
{
  int v9;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _WORD *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  _WORD *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  _WORD *v30;
  BOOL v31;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  __int16 v36;
  unsigned int v37;
  uint64_t v38;
  __int16 v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int v52;
  uint64_t v53;
  int v54;
  uint64_t v55;

  v9 = a2;
  v11 = a4 + 1;
  v12 = (a4 + 1) * a2;
  v13 = a6 - 2 * v12;
  if (a9 <= 0)
    v14 = -1;
  else
    v14 = a4;
  v15 = a8 - 2 * v12;
  v16 = a5 + 2 * (v14 < 1);
  v17 = (_WORD *)(a7 + 2 * (v14 < 1));
  v18 = v14;
  if (a4 != 3)
  {
    v55 = (a4 - 1);
    v33 = v11;
    v53 = 2 * a4;
    v34 = 2 * v11;
    v54 = a4 - 2;
    v49 = v15;
    v50 = a6 - 2 * v12;
    while (1)
    {
      v52 = a3;
      if (v9 >= 1)
        break;
LABEL_56:
      v9 = a2;
      a3 = v52 - 1;
      v16 += v50;
      v17 = (_WORD *)((char *)v17 + v49);
      if (v52 <= 1)
        return;
    }
    while (1)
    {
      v35 = *(unsigned __int16 *)(v16 + 2 * v18);
      if (v35 == 0xFFFF)
      {
        v36 = *(_WORD *)(v16 + 2 * (int)v55);
        if (a4 < 2)
        {
          v39 = *(_WORD *)(v16 + 2 * (int)v55);
        }
        else
        {
          v37 = v54;
          v38 = v55;
          do
          {
            v39 = *(_WORD *)(v16 + 2 * v37);
            v17[v38] = v36;
            --v37;
            v36 = v39;
            v31 = v38-- <= 1;
          }
          while (!v31);
        }
      }
      else
      {
        if (!*(_WORD *)(v16 + 2 * v18))
        {
          if (a4 >= 1)
            bzero(v17, v53);
          goto LABEL_54;
        }
        v40 = *(unsigned __int16 *)(v16 + 2 * (int)v55);
        if (a1)
        {
          if (a1 < 1)
          {
            v46 = 0xFFFFFFFF / v35;
            if (a4 > 1)
            {
              v47 = v55;
              do
              {
                v48 = v40 * v46;
                v31 = v47 <= 1;
                v40 = *(unsigned __int16 *)(v16 + 2 * (v47 - 1));
                v17[v47--] = HIWORD(v48);
              }
              while (!v31);
            }
            v43 = v40 * v46;
          }
          else
          {
            if (a4 >= 2)
            {
              v41 = v55;
              do
              {
                v42 = v40 * v35;
                v31 = v41 <= 1;
                v40 = *(unsigned __int16 *)(v16 + 2 * (v41 - 1));
                v17[v41--] = (v42 + HIWORD(v42) + 1) >> 16;
              }
              while (!v31);
            }
            v43 = v40 * v35 + ((v40 * v35) >> 16) + 1;
          }
          *v17 = HIWORD(v43);
          goto LABEL_54;
        }
        if (a4 < 2)
        {
          v39 = *(_WORD *)(v16 + 2 * (int)v55);
        }
        else
        {
          v44 = v54;
          v45 = v55;
          do
          {
            v39 = *(_WORD *)(v16 + 2 * v44);
            v17[v45] = v40;
            --v44;
            LOWORD(v40) = v39;
            v31 = v45-- <= 1;
          }
          while (!v31);
        }
      }
      *v17 = v39;
LABEL_54:
      v16 += 2 * v33;
      v17[v18] = v35;
      v17 = (_WORD *)((char *)v17 + v34);
      v31 = v9-- <= 1;
      if (v31)
        goto LABEL_56;
    }
  }
  v19 = v14;
  do
  {
    if (a2 >= 1)
    {
      v20 = 0;
      v21 = v16 + v19 * 2;
      v22 = a2 + 1;
      do
      {
        v23 = *(unsigned __int16 *)(v21 + v20);
        if (*(_WORD *)(v21 + v20))
        {
          if (v23 == 0xFFFF || !a1)
          {
            *(_DWORD *)&v17[v20 / 2] = *(_DWORD *)(v16 + v20);
            LOWORD(v28) = *(_WORD *)(v16 + v20 + 4);
          }
          else
          {
            if (a1 < 1)
            {
              v29 = 0xFFFFFFFF / v23 * *(unsigned __int16 *)(v16 + v20 + 2);
              v30 = &v17[v20 / 2];
              *v30 = (0xFFFFFFFF / v23 * *(unsigned __int16 *)(v16 + v20)) >> 16;
              v30[1] = HIWORD(v29);
              v27 = 0xFFFFFFFF / v23 * *(unsigned __int16 *)(v16 + v20 + 4);
            }
            else
            {
              v24 = *(unsigned __int16 *)(v16 + v20 + 2) * v23;
              v25 = &v17[v20 / 2];
              *v25 = (*(unsigned __int16 *)(v16 + v20) * v23 + ((*(unsigned __int16 *)(v16 + v20) * v23) >> 16) + 1) >> 16;
              v25[1] = (v24 + HIWORD(v24) + 1) >> 16;
              v26 = *(unsigned __int16 *)(v16 + v20 + 4) * v23;
              v27 = v26 + HIWORD(v26) + 1;
            }
            v28 = HIWORD(v27);
          }
        }
        else
        {
          LOWORD(v28) = 0;
          *(_DWORD *)&v17[v20 / 2] = 0;
        }
        v17[v20 / 2 + 2] = v28;
        v17[v19 + v20 / 2] = v23;
        --v22;
        v20 += 8;
      }
      while (v22 > 1);
      v16 += v20;
      v17 = (_WORD *)((char *)v17 + v20);
    }
    v16 += v13;
    v17 = (_WORD *)((char *)v17 + v15);
    v31 = a3-- <= 1;
  }
  while (!v31);
}

void CGSConvertAlphaFloatInterleved(int a1, int a2, int a3, int a4, uint64_t a5, float *a6, int a7, int a8, int a9, float *a10, float *a11, int a12, int a13, int a14)
{
  float *v14;
  float32x2_t *v15;
  int v18;
  int v19;
  uint64_t v20;
  float *v21;
  int v22;
  int v23;
  int v24;
  float *v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  float v31;
  float v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  float v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  float v42;
  float v43;
  uint64_t v44;
  __int32 v45;
  float v46;
  uint64_t v47;
  float v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;

  v14 = a6;
  v15 = (float32x2_t *)a5;
  if (a9 < 1)
  {
    if (a9 < 0)
      v18 = a4 + 1;
    else
      v18 = 1;
    if (a9 >= 0)
      v19 = a4;
    else
      v19 = a4 + 1;
    if (a9 < 0)
      v15 = (float32x2_t *)(a5 + 4);
  }
  else
  {
    v14 = &a6[a4];
    v18 = a4 + 1;
    v19 = a4 + 1;
  }
  v20 = a7 - 4 * v19 * a2;
  v21 = a10 + 1;
  if (a14 < 0)
    v22 = a4 + 1;
  else
    v22 = 1;
  if (a14 >= 0)
    v23 = a4;
  else
    v23 = a4 + 1;
  if (a14 >= 0)
    v21 = a10;
  if (a14 < 1)
  {
    v24 = v23;
  }
  else
  {
    v22 = a4 + 1;
    v24 = a4 + 1;
  }
  if (a14 >= 1)
    v25 = &a11[a4];
  else
    v25 = a11;
  if (a14 >= 1)
    v26 = a10;
  else
    v26 = v21;
  v27 = a12 - 4 * v24 * a2;
  v28 = v18;
  if (a4 == 3)
  {
    v29 = 4 * v19;
    while (a2 < 1)
    {
LABEL_42:
      v15 = (float32x2_t *)((char *)v15 + v20);
      v14 = (float *)((char *)v14 + a8 - 4 * v18 * a2);
      v26 = (float *)((char *)v26 + v27);
      v25 = (float *)((char *)v25 + a13 - 4 * v22 * a2);
      v33 = a3-- <= 1;
      if (v33)
        return;
    }
    v30 = a2 + 1;
    while (1)
    {
      v31 = *v14;
      if (*v14 != 1.0)
      {
        if (v31 == 0.0)
        {
          *(_QWORD *)v26 = 0;
          v32 = 0.0;
          goto LABEL_36;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            *(float32x2_t *)v26 = vmul_n_f32(*v15, 1.0 / v31);
            v32 = (float)(1.0 / v31) * v15[1].f32[0];
          }
          else
          {
            *(float32x2_t *)v26 = vmul_n_f32(*v15, v31);
            v32 = v31 * v15[1].f32[0];
          }
          goto LABEL_36;
        }
      }
      *(float32x2_t *)v26 = *v15;
      v32 = v15[1].f32[0];
LABEL_36:
      --v30;
      v15 = (float32x2_t *)((char *)v15 + v29);
      v26[2] = v32;
      *v25 = v31;
      v14 += v18;
      v26 += v24;
      v25 += v22;
      if (v30 <= 1)
        goto LABEL_42;
    }
  }
  v55 = (a4 - 1);
  v34 = v19;
  v35 = v22;
  v56 = 4 * a4;
  v36 = 4 * v24;
  v53 = a2;
  v51 = a8 - 4 * v18 * a2;
  v52 = a7 - 4 * v19 * a2;
  v49 = a13 - 4 * v22 * a2;
  v50 = v27;
  do
  {
    v54 = a3;
    if (a2 >= 1)
    {
      v37 = a2;
      do
      {
        v38 = *v14;
        if (*v14 == 0.0)
        {
          if (a4 >= 1)
          {
            v39 = v36;
            v57 = v37;
            bzero(v26, v56);
            v37 = v57;
            v36 = v39;
          }
        }
        else
        {
          v40 = v15->f32[(int)v55];
          if (!a1 || v38 == 1.0)
          {
            if (a4 < 2)
            {
              v45 = v15->i32[(int)v55];
            }
            else
            {
              v44 = v55;
              do
              {
                v33 = v44 <= 1;
                v45 = v15->i32[(v44 - 1)];
                v26[v44--] = v40;
                v40 = *(float *)&v45;
              }
              while (!v33);
            }
            *(_DWORD *)v26 = v45;
          }
          else
          {
            if (a1 < 1)
            {
              v46 = 1.0 / v38;
              if (a4 > 1)
              {
                v47 = v55;
                do
                {
                  v48 = v46 * v40;
                  v33 = v47 <= 1;
                  v40 = v15->f32[(v47 - 1)];
                  v26[v47--] = v48;
                }
                while (!v33);
              }
              v43 = v46 * v40;
            }
            else
            {
              if (a4 >= 2)
              {
                v41 = v55;
                do
                {
                  v42 = v38 * v40;
                  v33 = v41 <= 1;
                  v40 = v15->f32[(v41 - 1)];
                  v26[v41--] = v42;
                }
                while (!v33);
              }
              v43 = v38 * v40;
            }
            *v26 = v43;
          }
        }
        v14 += v28;
        v15 = (float32x2_t *)((char *)v15 + 4 * v34);
        *v25 = v38;
        v26 = (float *)((char *)v26 + v36);
        v25 += v35;
        v33 = v37-- <= 1;
      }
      while (!v33);
    }
    a2 = v53;
    a3 = v54 - 1;
    v15 = (float32x2_t *)((char *)v15 + v52);
    v14 = (float *)((char *)v14 + v51);
    v26 = (float *)((char *)v26 + v50);
    v25 = (float *)((char *)v25 + v49);
  }
  while (v54 > 1);
}

void CGSConvertAlphaFloatMeshed(int a1, int a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, int a9)
{
  int v9;
  int v11;
  int v12;
  int v13;
  float32x2_t *v14;
  float *v15;
  uint64_t v16;
  int v17;
  float v18;
  float v19;
  BOOL v20;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  float v25;
  float v26;
  uint64_t v27;
  float v28;
  float v29;
  uint64_t v30;
  __int32 v31;
  float v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  int v38;
  uint64_t v39;

  v9 = a2;
  v11 = a4 + 1;
  v12 = (a4 + 1) * a2;
  if (a9 <= 0)
    v13 = -1;
  else
    v13 = a4;
  v14 = (float32x2_t *)(a5 + 4 * (v13 < 1));
  v15 = (float *)(a7 + 4 * (v13 < 1));
  v16 = v13;
  if (a4 == 3)
  {
    while (a2 < 1)
    {
LABEL_17:
      v14 = (float32x2_t *)((char *)v14 + a6 - 4 * v12);
      v15 = (float *)((char *)v15 + a8 - 4 * v12);
      v20 = a3-- <= 1;
      if (v20)
        return;
    }
    v17 = a2 + 1;
    while (1)
    {
      v18 = v14->f32[v16];
      if (v18 != 1.0)
      {
        if (v18 == 0.0)
        {
          *(_QWORD *)v15 = 0;
          v19 = 0.0;
          goto LABEL_11;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            *(float32x2_t *)v15 = vmul_n_f32(*v14, 1.0 / v18);
            v19 = (float)(1.0 / v18) * v14[1].f32[0];
          }
          else
          {
            *(float32x2_t *)v15 = vmul_n_f32(*v14, v18);
            v19 = v18 * v14[1].f32[0];
          }
          goto LABEL_11;
        }
      }
      *(float32x2_t *)v15 = *v14;
      v19 = v14[1].f32[0];
LABEL_11:
      v15[2] = v19;
      v14 += 2;
      v15[v16] = v18;
      v15 += 4;
      if (--v17 <= 1)
        goto LABEL_17;
    }
  }
  v39 = (a4 - 1);
  v22 = v11;
  v23 = 4 * a4;
  v24 = 4 * v11;
  v35 = a8 - 4 * v12;
  v36 = a6 - 4 * v12;
  do
  {
    v38 = a3;
    if (v9 >= 1)
    {
      do
      {
        v25 = v14->f32[v16];
        if (v25 == 0.0)
        {
          if (a4 >= 1)
            bzero(v15, v23);
        }
        else
        {
          v26 = v14->f32[(int)v39];
          if (!a1 || v25 == 1.0)
          {
            if (a4 < 2)
            {
              v31 = v14->i32[(int)v39];
            }
            else
            {
              v30 = v39;
              do
              {
                v20 = v30 <= 1;
                v31 = v14->i32[(v30 - 1)];
                v15[v30--] = v26;
                v26 = *(float *)&v31;
              }
              while (!v20);
            }
            *(_DWORD *)v15 = v31;
          }
          else
          {
            if (a1 < 1)
            {
              v32 = 1.0 / v25;
              if (a4 > 1)
              {
                v33 = v39;
                do
                {
                  v34 = v32 * v26;
                  v20 = v33 <= 1;
                  v26 = v14->f32[(v33 - 1)];
                  v15[v33--] = v34;
                }
                while (!v20);
              }
              v29 = v32 * v26;
            }
            else
            {
              if (a4 >= 2)
              {
                v27 = v39;
                do
                {
                  v28 = v25 * v26;
                  v20 = v27 <= 1;
                  v26 = v14->f32[(v27 - 1)];
                  v15[v27--] = v28;
                }
                while (!v20);
              }
              v29 = v25 * v26;
            }
            *v15 = v29;
          }
        }
        v14 = (float32x2_t *)((char *)v14 + 4 * v22);
        v15[v16] = v25;
        v15 = (float *)((char *)v15 + v24);
        v20 = v9-- <= 1;
      }
      while (!v20);
    }
    v9 = a2;
    a3 = v38 - 1;
    v14 = (float32x2_t *)((char *)v14 + v36);
    v15 = (float *)((char *)v15 + v35);
  }
  while (v38 > 1);
}

void convert_alpha_float16_interleved(int a1, int a2, int a3, int a4, __int16 *a5, __int16 *a6, int a7, int a8, int a9, char *a10, _WORD *a11, int a12, int a13, int a14)
{
  __int16 *v14;
  __int16 *v15;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  int v22;
  int v23;
  int v24;
  _WORD *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v62;
  uint64_t v65;
  uint64_t v70;
  __int16 v71;
  float v72;
  uint64_t v73;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;

  v14 = a6;
  v15 = a5;
  if (a9 < 1)
  {
    if (a9 < 0)
      v18 = a4 + 1;
    else
      v18 = 1;
    if (a9 >= 0)
      v19 = a4;
    else
      v19 = a4 + 1;
    if (a9 < 0)
      v15 = a5 + 1;
  }
  else
  {
    v14 = &a6[a4];
    v18 = a4 + 1;
    v19 = a4 + 1;
  }
  v20 = a7 - 2 * v19 * a2;
  v21 = a10 + 2;
  if (a14 < 0)
    v22 = a4 + 1;
  else
    v22 = 1;
  if (a14 >= 0)
    v23 = a4;
  else
    v23 = a4 + 1;
  if (a14 >= 0)
    v21 = a10;
  if (a14 < 1)
  {
    v24 = v23;
  }
  else
  {
    v22 = a4 + 1;
    v24 = a4 + 1;
  }
  if (a14 >= 1)
    v25 = &a11[a4];
  else
    v25 = a11;
  if (a14 >= 1)
    v26 = a10;
  else
    v26 = v21;
  v27 = a12 - 2 * v24 * a2;
  v28 = v18;
  if (a4 == 3)
  {
    v29 = 2 * v19;
    v30 = 2 * v24;
    while (a2 < 1)
    {
LABEL_42:
      v15 = (__int16 *)((char *)v15 + v20);
      v14 = (__int16 *)((char *)v14 + a8 - 2 * v18 * a2);
      v26 += v27;
      v25 = (_WORD *)((char *)v25 + a13 - 2 * v22 * a2);
      v55 = a3-- <= 1;
      if (v55)
        return;
    }
    v31 = a2 + 1;
    while (1)
    {
      _H1 = *v14;
      __asm { FCVT            S2, H1 }
      if (_S2 != 1.0)
      {
        if (_S2 == 0.0)
        {
          *(_DWORD *)v26 = 0;
          _H2 = 0;
          goto LABEL_41;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            _S2 = 1.0 / _S2;
            _H3 = *v15;
            __asm { FCVT            S3, H3 }
            _H4 = v15[1];
            __asm { FCVT            S4, H4 }
            _S3 = _S2 * _S3;
            _S4 = _S2 * _S4;
            __asm { FCVT            H3, S3 }
            *(_WORD *)v26 = LOWORD(_S3);
            __asm { FCVT            H3, S4 }
          }
          else
          {
            _H3 = *v15;
            _H4 = v15[1];
            __asm { FCVT            S3, H3 }
            _S3 = _S2 * _S3;
            __asm { FCVT            H3, S3 }
            *(_WORD *)v26 = LOWORD(_S3);
            __asm { FCVT            S3, H4 }
            _S3 = _S2 * _S3;
            __asm { FCVT            H3, S3 }
          }
          *((_WORD *)v26 + 1) = _H3;
          _H3 = v15[2];
          __asm { FCVT            S3, H3 }
          _S2 = _S2 * _S3;
          __asm { FCVT            H2, S2 }
          goto LABEL_41;
        }
      }
      *(_DWORD *)v26 = *(_DWORD *)v15;
      _H2 = v15[2];
LABEL_41:
      --v31;
      v15 = (__int16 *)((char *)v15 + v29);
      *((_WORD *)v26 + 2) = _H2;
      *v25 = _H1;
      v25 += v22;
      v14 += v18;
      v26 += v30;
      if (v31 <= 1)
        goto LABEL_42;
    }
  }
  v84 = (a4 - 1);
  v56 = v19;
  v57 = v22;
  v85 = 2 * a4;
  v58 = 2 * v24;
  v82 = a2;
  v80 = a8 - 2 * v18 * a2;
  v81 = a7 - 2 * v19 * a2;
  v78 = a13 - 2 * v22 * a2;
  v79 = v27;
  do
  {
    v83 = a3;
    if (a2 >= 1)
    {
      v59 = a2;
      do
      {
        _H9 = *v14;
        __asm { FCVT            S1, H9 }
        if (_S1 == 0.0)
        {
          if (a4 >= 1)
          {
            v62 = v58;
            v86 = v59;
            bzero(v26, v85);
            v59 = v86;
            v58 = v62;
          }
        }
        else
        {
          _H0 = v15[(int)v84];
          if (!a1 || _S1 == 1.0)
          {
            if (a4 < 2)
            {
              v71 = v15[(int)v84];
            }
            else
            {
              v70 = v84;
              do
              {
                v55 = v70 <= 1;
                v71 = v15[(v70 - 1)];
                *(_WORD *)&v26[2 * v70--] = _H0;
                _H0 = v71;
              }
              while (!v55);
            }
            *(_WORD *)v26 = v71;
          }
          else
          {
            __asm { FCVT            S0, H0 }
            if (a1 < 1)
            {
              v72 = 1.0 / _S1;
              if (a4 > 1)
              {
                v73 = v84;
                do
                {
                  _H2 = v15[(v73 - 1)];
                  _S3 = v72 * _S0;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v26[2 * v73--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = v72 * _S0;
            }
            else
            {
              if (a4 >= 2)
              {
                v65 = v84;
                do
                {
                  _H2 = v15[(v65 - 1)];
                  _S3 = _S0 * _S1;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v26[2 * v65--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = _S0 * _S1;
            }
            __asm { FCVT            H0, S0 }
            *(_WORD *)v26 = _H0;
          }
        }
        v14 += v28;
        v15 += v56;
        *v25 = _H9;
        v26 += v58;
        v25 += v57;
        v55 = v59-- <= 1;
      }
      while (!v55);
    }
    a2 = v82;
    a3 = v83 - 1;
    v15 = (__int16 *)((char *)v15 + v81);
    v14 = (__int16 *)((char *)v14 + v80);
    v26 += v79;
    v25 = (_WORD *)((char *)v25 + v78);
  }
  while (v83 > 1);
}

void convert_alpha_float16_meshed(int a1, int a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, int a9)
{
  int v9;
  int v11;
  int v12;
  int v13;
  __int16 *v14;
  char *v15;
  uint64_t v16;
  int v17;
  BOOL v41;
  uint64_t v43;
  size_t v44;
  uint64_t v45;
  uint64_t v50;
  uint64_t v55;
  __int16 v56;
  float v57;
  uint64_t v58;
  uint64_t v63;
  uint64_t v64;
  int v66;
  uint64_t v67;

  v9 = a2;
  v11 = a4 + 1;
  v12 = (a4 + 1) * a2;
  if (a9 <= 0)
    v13 = -1;
  else
    v13 = a4;
  v14 = (__int16 *)(a5 + 2 * (v13 < 1));
  v15 = (char *)(a7 + 2 * (v13 < 1));
  v16 = v13;
  if (a4 == 3)
  {
    while (a2 < 1)
    {
LABEL_17:
      v14 = (__int16 *)((char *)v14 + a6 - 2 * v12);
      v15 += a8 - 2 * v12;
      v41 = a3-- <= 1;
      if (v41)
        return;
    }
    v17 = a2 + 1;
    while (1)
    {
      _H1 = v14[v16];
      __asm { FCVT            S2, H1 }
      if (_S2 != 1.0)
      {
        if (_S2 == 0.0)
        {
          *(_DWORD *)v15 = 0;
          _H2 = 0;
          goto LABEL_16;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            _S2 = 1.0 / _S2;
            _H3 = *v14;
            __asm { FCVT            S3, H3 }
            _H4 = v14[1];
            __asm { FCVT            S4, H4 }
            _S3 = _S2 * _S3;
            _S4 = _S2 * _S4;
            __asm { FCVT            H3, S3 }
            *(_WORD *)v15 = LOWORD(_S3);
            __asm { FCVT            H3, S4 }
          }
          else
          {
            _H3 = *v14;
            _H4 = v14[1];
            __asm { FCVT            S3, H3 }
            _S3 = _S2 * _S3;
            __asm { FCVT            H3, S3 }
            *(_WORD *)v15 = LOWORD(_S3);
            __asm { FCVT            S3, H4 }
            _S3 = _S2 * _S3;
            __asm { FCVT            H3, S3 }
          }
          *((_WORD *)v15 + 1) = _H3;
          _H3 = v14[2];
          __asm { FCVT            S3, H3 }
          _S2 = _S2 * _S3;
          __asm { FCVT            H2, S2 }
          goto LABEL_16;
        }
      }
      *(_DWORD *)v15 = *(_DWORD *)v14;
      _H2 = v14[2];
LABEL_16:
      *((_WORD *)v15 + 2) = _H2;
      v14 += 4;
      *(_WORD *)&v15[2 * v16] = _H1;
      v15 += 8;
      if (--v17 <= 1)
        goto LABEL_17;
    }
  }
  v67 = (a4 - 1);
  v43 = v11;
  v44 = 2 * a4;
  v45 = 2 * v11;
  v63 = a8 - 2 * v12;
  v64 = a6 - 2 * v12;
  do
  {
    v66 = a3;
    if (v9 >= 1)
    {
      do
      {
        _H9 = v14[v16];
        __asm { FCVT            S1, H9 }
        if (_S1 == 0.0)
        {
          if (a4 >= 1)
            bzero(v15, v44);
        }
        else
        {
          _H0 = v14[(int)v67];
          if (!a1 || _S1 == 1.0)
          {
            if (a4 < 2)
            {
              v56 = v14[(int)v67];
            }
            else
            {
              v55 = v67;
              do
              {
                v41 = v55 <= 1;
                v56 = v14[(v55 - 1)];
                *(_WORD *)&v15[2 * v55--] = _H0;
                _H0 = v56;
              }
              while (!v41);
            }
            *(_WORD *)v15 = v56;
          }
          else
          {
            __asm { FCVT            S0, H0 }
            if (a1 < 1)
            {
              v57 = 1.0 / _S1;
              if (a4 > 1)
              {
                v58 = v67;
                do
                {
                  _H2 = v14[(v58 - 1)];
                  _S3 = v57 * _S0;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v15[2 * v58--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = v57 * _S0;
            }
            else
            {
              if (a4 >= 2)
              {
                v50 = v67;
                do
                {
                  _H2 = v14[(v50 - 1)];
                  _S3 = _S0 * _S1;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v15[2 * v50--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = _S0 * _S1;
            }
            __asm { FCVT            H0, S0 }
            *(_WORD *)v15 = _H0;
          }
        }
        v14 += v43;
        *(_WORD *)&v15[2 * v16] = _H9;
        v15 += v45;
        v41 = v9-- <= 1;
      }
      while (!v41);
    }
    v9 = a2;
    a3 = v66 - 1;
    v14 = (__int16 *)((char *)v14 + v64);
    v15 += v63;
  }
  while (v66 > 1);
}

BOOL CGPDFCountElementsInCPChunk(void *a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  char v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v13;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(a1, "anchoringTextLine") == 0;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    v9 = objc_msgSend(a1, "count");
    if (v9)
    {
      v10 = v9;
      v11 = 0;
      v2 = 0;
      do
      {
        v2 += CGPDFCountElementsInCPChunk(objc_msgSend(a1, "childAtIndex:", v11));
        v11 = (v11 + 1);
      }
      while (v10 != (_DWORD)v11);
      return v2;
    }
    return 0;
  }
  v13 = 0;
  v3 = objc_msgSend(a1, "count");
  if (!v3)
    return 0;
  v4 = v3;
  if (!map((uint64_t (*)(uint64_t, uint64_t, uint64_t))countElementsInParagraph, (void *)objc_msgSend(a1, "childAtIndex:", 0), (uint64_t)&v13))return 0;
  v5 = v4;
  v6 = 1;
  while (v5 != v6)
  {
    v7 = map((uint64_t (*)(uint64_t, uint64_t, uint64_t))countElementsInParagraph, (void *)objc_msgSend(a1, "childAtIndex:", v6++), (uint64_t)&v13);
    if ((v7 & 1) == 0)
    {
      v8 = v6 - 1;
      goto LABEL_16;
    }
  }
  v8 = v5;
LABEL_16:
  if (v8 < v5)
    return 0;
  else
    return v13;
}

uint64_t countElementsInParagraph(void *a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v4;
  uint64_t v5;
  void *v6;
  void *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  unsigned int v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  _BYTE v39[512];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = objc_msgSend(a1, "count");
  if (v4)
  {
    v5 = 0;
    v32 = v4;
    do
    {
      v34 = v5;
      v6 = (void *)objc_msgSend(a1, "childAtIndex:", v32);
      v7 = (void *)objc_msgSend(v6, "charSequence");
      v8 = objc_msgSend(v6, "wordCount");
      v9 = v8;
      if (v8)
      {
        v10 = 0;
        v35 = v8;
        do
        {
          v11 = v6;
          v12 = objc_msgSend(v6, "wordAtIndex:", v10);
          v13 = *(unsigned int *)(v12 + 4);
          if ((_DWORD)v13)
          {
            v14 = (_DWORD *)v12;
            v15 = 0;
            v16 = 0;
            do
            {
              v17 = objc_msgSend(v7, "charAtIndex:", (v15 + *v14));
              v38 = 0;
              v18 = *(unsigned __int16 *)(v17 + 72);
              if (!v16 || !isCharacterOverlay(v16, v17))
              {
                if (v18 || (v20 = *(void **)(*(_QWORD *)(v17 + 160) + 64)) == 0)
                {
                  v36 = 0;
                  if (decomposes(v18, &v37, &v36))
                    v19 = v36;
                  else
                    v19 = 1;
                }
                else
                {
                  objc_msgSend(v20, "uniCharsFor:count:toArray:maxChars:", *(unsigned __int16 *)(v17 + 74), &v38, v39, 256);
                  if (v38)
                    v21 = v38;
                  else
                    v21 = 1;
                  if (v38 == 1)
                    v19 = 1;
                  else
                    v19 = v21;
                }
                *a3 += v19;
              }
              ++v15;
              v16 = v17;
            }
            while (v13 != v15);
          }
          ++*a3;
          ++v10;
          v9 = v35;
          v6 = v11;
        }
        while (v10 != v35);
      }
      v22 = objc_msgSend(v6, "inlineList");
      if (v22)
      {
        v23 = v22;
        do
        {
          v24 = *(_QWORD *)(v23 + 8);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
            v25 = 1;
          else
            v25 = CGPDFCountElementsInCPChunk(v24);
          *a3 += v25 + 1;
          v23 = *(_QWORD *)(v23 + 16);
        }
        while (v23);
      }
      if (objc_msgSend((id)objc_msgSend(v6, "parent"), "isPreformattedWithUnitWidth:", 0))
      {
        v26 = 0;
        if ((_DWORD)v9)
        {
          for (i = 0; i != v9; ++i)
          {
            v28 = objc_msgSend(v6, "spacesBeforeWordAtIndex:", i);
            if (i)
              v29 = v28 == 0;
            else
              v29 = 1;
            v30 = !v29;
            v26 = v26 + v28 - v30;
          }
        }
        *a3 += v26;
      }
      v5 = v34 + 1;
    }
    while (v34 + 1 != v32);
  }
  return 1;
}

uint64_t map(uint64_t (*a1)(uint64_t, uint64_t, uint64_t), void *a2, uint64_t a3)
{
  unsigned int v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  unint64_t v10;
  uint64_t v11;
  char v12;
  unint64_t v13;

  v6 = objc_msgSend(a2, "count");
  if (!v6)
    return 1;
  v7 = v6;
  v8 = a1(objc_msgSend(a2, "childAtIndex:", 0), 0, a3);
  result = 0;
  if (v8)
  {
    v10 = v7;
    v11 = 1;
    while (v10 != v11)
    {
      v12 = a1(objc_msgSend(a2, "childAtIndex:", v11), v11, a3);
      ++v11;
      if ((v12 & 1) == 0)
      {
        v13 = v11 - 1;
        return v13 >= v10;
      }
    }
    v13 = v10;
    return v13 >= v10;
  }
  return result;
}

char *CGPDFNodeMakeFromCPChunk(void *a1, uint64_t a2, uint64_t a3, CFDictionaryRef *a4, CFDictionaryRef *a5)
{
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  const __CFSet *Mutable;
  char *v18;
  size_t v19;
  uint64_t v20;
  char *Value;
  int v22;
  char *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  const void *v27;
  void *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const void *v38;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const void *v49;
  uint64_t v50;
  const void *v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  int64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const void *v60;
  const void *v61;
  uint64_t v62;
  char v63;
  char *v64;
  char v65;
  char *v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  const void *v77;
  int v78;
  uint64_t v79;
  const void *v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t i;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const void *v101;
  char *v102;
  char *v103;
  uint64_t j;
  char *v105;
  const void *v106;
  _QWORD *v107;
  const void *v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  const void *v113;
  uint64_t v114;
  void *v115;
  unsigned int v116;
  uint64_t v117;
  unsigned int v118;
  const void *v119;
  const void *v120;
  int v122;
  int v123;
  int v124;
  int v125;
  uint64_t v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 context;
  __int128 v131;
  __int128 v132;

  v10 = CGPDFNodeTypeFromCPChunk();
  if (!v10)
    return 0;
  v11 = v10;
  if (!a3)
  {
    v12 = objc_msgSend(a1, "count");
    if (v12)
    {
      v13 = v12;
      v14 = 0;
      do
      {
        v15 = (void *)objc_msgSend(a1, "childAtIndex:", v14);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          objc_msgSend(v15, "anchoringTextLine");
        v14 = (v14 + 1);
      }
      while (v13 != (_DWORD)v14);
    }
  }
  if (a2)
    v16 = *(_QWORD *)(a2 + 104);
  else
    v16 = 0;
  if (v11 != 517 || v16)
  {
    v22 = objc_msgSend(a1, "conformsToProtocol:", &unk_1EDD2F660);
    if (a4 && v22)
    {
      if (*a4)
      {
        Value = (char *)CFDictionaryGetValue(*a4, a1);
        if (Value)
          return Value;
      }
      else
      {
        *a4 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
      }
      CGPDFNodeInitInPage(v11);
      Value = v29;
      CFDictionaryAddValue(*a4, a1, v29);
    }
    else
    {
      CGPDFNodeInitInPage(v11);
      Value = v23;
    }
  }
  else
  {
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    CGPDFNodeSizeFromCPChunk(a1, Mutable);
    context = (unint64_t)objc_msgSend(a1, "clipBuffer");
    CFSetApplyFunction(Mutable, (CFSetApplierFunction)countClips, &context);
    CFRelease(Mutable);
    v18 = (char *)malloc_type_calloc(0x98uLL, 1uLL, 0x2C7ACE11uLL);
    *(_DWORD *)v18 = 517;
    *((_DWORD *)v18 + 10) = 1;
    *((_OWORD *)v18 + 1) = CPRangeNull;
    *((_QWORD *)v18 + 4) = 0;
    *((_QWORD *)v18 + 7) = 0;
    *(_QWORD *)(v18 + 44) = 0;
    v18[52] = 0;
    *((CGRect *)v18 + 2) = CGRectNull;
    *((_QWORD *)v18 + 13) = a2;
    if (a2)
    {
      *((_DWORD *)v18 + 10) = 2;
      *(_QWORD *)(a2 + 104) = v18;
      CGPDFNodeRelease((uint64_t)v18);
      v16 = *(_QWORD *)(a2 + 104);
      if (v16)
      {
        v19 = DWORD2(context);
        v20 = *(_QWORD *)(a2 + 104);
        while (*(_DWORD *)v20 != 517)
        {
          v20 = *(_QWORD *)(v20 + 8);
          if (!v20)
            goto LABEL_37;
        }
        v24 = *(unsigned int *)(v20 + 112);
        if ((_DWORD)v24)
        {
          v25 = 0;
          v26 = 8;
          do
          {
            v27 = *(const void **)(*(_QWORD *)(v20 + 120) + v26);
            if (v27)
            {
              CFRelease(v27);
              v24 = *(unsigned int *)(v20 + 112);
            }
            ++v25;
            v26 += 32;
          }
          while (v25 < v24);
        }
        free(*(void **)(v20 + 120));
        if ((_DWORD)v19)
          v28 = malloc_type_calloc(v19, 0x20uLL, 0x1060040A9AB1A44uLL);
        else
          v28 = 0;
        *(_QWORD *)(v20 + 120) = v28;
        *(_DWORD *)(v20 + 112) = 0;
      }
    }
    else
    {
      CGPDFNodeRelease((uint64_t)v18);
      v16 = 0;
    }
LABEL_37:
    Value = (char *)v16;
  }
  if (!Value)
    return Value;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(a1, "zoneBounds");
    v31 = v30;
    v33 = v32;
    v35 = v34;
    v37 = v36;
    v38 = (const void *)objc_msgSend(a1, "newBackgroundColor");
    if (*(_DWORD *)Value == 1538)
    {
      v39 = (const void *)*((_QWORD *)Value + 14);
      if (v39 != v38)
      {
        if (v39)
          CFRelease(v39);
        if (v38)
          CFRetain(v38);
        *((_QWORD *)Value + 14) = v38;
      }
    }
    if (v38)
      CFRelease(v38);
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend(a1, "cellBounds");
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        objc_msgSend(a1, "tableBounds");
      else
        objc_msgSend(a1, "renderedBounds");
    }
    v31 = v40;
    v33 = v41;
    v35 = v42;
    v37 = v43;
  }
  if ((Value[1] & 3) != 0)
  {
    *((_QWORD *)Value + 8) = v31;
    *((_QWORD *)Value + 9) = v33;
    *((_QWORD *)Value + 10) = v35;
    *((_QWORD *)Value + 11) = v37;
  }
  v44 = objc_msgSend(a1, "zOrder");
  if ((Value[1] & 3) != 0)
    *((_QWORD *)Value + 12) = v44;
  if (v11 > 513)
  {
    switch(v11)
    {
      case 514:
        v63 = objc_msgSend(a1, "lineBreakAfter");
        v64 = Value;
        while (*(_DWORD *)v64 != 514)
        {
          v64 = (char *)*((_QWORD *)v64 + 1);
          if (!v64)
            goto LABEL_94;
        }
        v64[104] = v63;
LABEL_94:
        objc_msgSend(a1, "rotationAngle");
        *((_QWORD *)Value + 4) = v67;
        return Value;
      case 516:
        v65 = objc_msgSend(a1, "hasRotatedCharacters");
        v66 = Value;
        while (*(_DWORD *)v66 != 516)
        {
          v66 = (char *)*((_QWORD *)v66 + 1);
          if (!v66)
            return Value;
        }
        v66[104] = v65;
        return Value;
      case 1537:
        *(_QWORD *)&context = 0;
        if (objc_msgSend(a1, "isPreformattedWithUnitWidth:", &context))
        {
          v45 = Value;
          while (*(_DWORD *)v45 != 1537)
          {
            v45 = (char *)*((_QWORD *)v45 + 1);
            if (!v45)
              goto LABEL_105;
          }
          *((_QWORD *)v45 + 14) = context;
        }
LABEL_105:
        if (!a1)
          return Value;
        goto LABEL_127;
    }
LABEL_91:
    if ((v11 & 0x100) == 0)
      goto LABEL_125;
    goto LABEL_111;
  }
  if (v11 == 257)
  {
    v46 = objc_msgSend(a1, "imageData");
    if (!v46)
      goto LABEL_111;
    v47 = v46;
    v48 = *(_QWORD *)(v46 + 80);
    v49 = *(const void **)(v46 + 96);
    v50 = *(_QWORD *)(v46 + 160);
    v51 = *(const void **)(v46 + 168);
    v52 = *(_OWORD *)(v46 + 120);
    context = *(_OWORD *)(v46 + 104);
    v131 = v52;
    v132 = *(_OWORD *)(v46 + 136);
    if (*(_DWORD *)Value == 257)
    {
      *((_QWORD *)Value + 15) = v48;
      if (v49)
        CFRetain(v49);
      *((_QWORD *)Value + 16) = v49;
      v53 = v131;
      *(_OWORD *)(Value + 136) = context;
      *(_OWORD *)(Value + 152) = v53;
      *(_OWORD *)(Value + 168) = v132;
      *((_QWORD *)Value + 23) = v50;
      if (v51)
        CFRetain(v51);
      *((_QWORD *)Value + 24) = v51;
    }
    if (*(_QWORD *)(v47 + 176) == -1)
      goto LABEL_111;
    v54 = *(_QWORD *)(objc_msgSend((id)objc_msgSend(a1, "page"), "PDFContext") + 2344);
    v55 = *(_QWORD *)(v47 + 176);
    goto LABEL_110;
  }
  if (v11 != 258)
  {
    if (v11 == 259)
    {
      CGPDFNodeSetCGPDFAnnotation((uint64_t)Value, (CFTypeRef)objc_msgSend(a1, "cgAnnotation"));
      return Value;
    }
    goto LABEL_91;
  }
  v125 = objc_msgSend(a1, "pdfObjectID");
  v124 = objc_msgSend(a1, "windingRule");
  objc_msgSend(a1, "lineWidth");
  v57 = v56;
  objc_msgSend(a1, "miterLimit");
  v59 = v58;
  v123 = objc_msgSend(a1, "lineCap");
  v122 = objc_msgSend(a1, "lineJoin");
  v60 = (const void *)objc_msgSend(a1, "fillColor");
  v61 = (const void *)objc_msgSend(a1, "strokeColor");
  v126 = objc_msgSend(a1, "fillObject");
  v62 = objc_msgSend(a1, "strokeObject");
  if (a1)
  {
    objc_msgSend(a1, "paintTransform");
  }
  else
  {
    v128 = 0u;
    v129 = 0u;
    v127 = 0u;
  }
  if (*(_DWORD *)Value == 258)
  {
    *((_DWORD *)Value + 30) = v125;
    *((_QWORD *)Value + 16) = 0;
    Value[136] = v124 == 1;
    *((_QWORD *)Value + 18) = v57;
    *((_QWORD *)Value + 19) = v59;
    *((_DWORD *)Value + 40) = v123;
    *((_DWORD *)Value + 41) = v122;
    if (v60)
      CFRetain(v60);
    *((_QWORD *)Value + 21) = v60;
    if (v61)
      CFRetain(v61);
    *((_QWORD *)Value + 22) = v61;
    if (v126 | v62)
    {
      v68 = malloc_type_malloc(0x40uLL, 0x1020040038FC326uLL);
      *((_QWORD *)Value + 23) = v68;
      *v68 = v126;
      v68[1] = v62;
      *((_OWORD *)v68 + 2) = v128;
      *((_OWORD *)v68 + 3) = v129;
      *((_OWORD *)v68 + 1) = v127;
    }
    else
    {
      *((_QWORD *)Value + 23) = 0;
    }
  }
  if ((objc_msgSend(a1, "mcid") & 0x8000000000000000) == 0)
  {
    v69 = *(_QWORD *)(objc_msgSend((id)objc_msgSend(a1, "page"), "PDFContext") + 2344);
    v55 = objc_msgSend(a1, "mcid");
    v54 = v69;
LABEL_110:
    CGPDFTaggedContextAddNode(v54, v55, (uint64_t)Value);
  }
LABEL_111:
  if (objc_msgSend(a1, "user"))
  {
    v70 = CGPDFNodeMakeFromCPChunk();
    v71 = v70;
    if ((Value[1] & 1) != 0)
      *((_QWORD *)Value + 14) = v70;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if (v71)
      {
        if (*(_DWORD *)v71 == 1538 && (Value[1] & 1) != 0)
        {
          v72 = *(_QWORD *)(v71 + 104);
          if (v72)
          {
            if (*(_DWORD *)v72 == 3)
            {
              v73 = *(unsigned int *)(v72 + 32);
              *(_QWORD *)(*(_QWORD *)(v72 + 40) + 8 * v73) = Value;
              *(_DWORD *)(v72 + 32) = v73 + 1;
            }
          }
        }
      }
    }
  }
  v74 = objc_msgSend(a1, "clipIndex");
  if (v74)
  {
    v75 = v74;
    v76 = objc_msgSend((id)objc_msgSend(a1, "page"), "PDFContext");
    v77 = CGPDFNodeClipMakeFromClipIndex(v76 + 2208, v75, *(_QWORD *)(v76 + 2112), v16, a5);
    if (v77)
    {
      if ((Value[1] & 1) != 0)
        *((_QWORD *)Value + 13) = v77;
    }
  }
LABEL_125:
  if (!a1 || v11 < 0x400)
    return Value;
LABEL_127:
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    CGPDFNodeMakeSubType((uint64_t)Value, 3);
    v78 = objc_msgSend(a1, "rowCount");
    v79 = objc_msgSend(a1, "rowY");
    if (v78)
    {
      v80 = (const void *)v79;
      if (v79)
      {
        if (*(_DWORD *)Value == 1538)
        {
          v81 = *((_QWORD *)Value + 13);
          if (v81)
          {
            if (*(_DWORD *)v81 == 3)
            {
              free(*(void **)(v81 + 8));
              v82 = malloc_type_malloc(8 * (v78 + 1), 0x100004000313F17uLL);
              *(_QWORD *)(v81 + 8) = v82;
              if (v82)
              {
                *(_DWORD *)(v81 + 4) = v78;
                memcpy(v82, v80, 8 * (v78 + 1));
              }
              else
              {
                *(_DWORD *)(v81 + 4) = 0;
              }
            }
          }
        }
      }
    }
    v111 = objc_msgSend(a1, "columnCount");
    v112 = objc_msgSend(a1, "columnX");
    if (v111)
    {
      v113 = (const void *)v112;
      if (v112)
      {
        if (*(_DWORD *)Value == 1538)
        {
          v114 = *((_QWORD *)Value + 13);
          if (v114)
          {
            if (*(_DWORD *)v114 == 3)
            {
              free(*(void **)(v114 + 24));
              v115 = malloc_type_malloc(8 * (v111 + 1), 0x100004000313F17uLL);
              *(_QWORD *)(v114 + 24) = v115;
              if (v115)
              {
                *(_DWORD *)(v114 + 16) = v111;
                memcpy(v115, v113, 8 * (v111 + 1));
              }
              else
              {
                *(_DWORD *)(v114 + 16) = 0;
              }
            }
          }
        }
      }
    }
    v116 = objc_msgSend(a1, "usedGraphicCount");
    if (*(_DWORD *)Value == 1538)
    {
      v117 = *((_QWORD *)Value + 13);
      if (v117)
      {
        if (*(_DWORD *)v117 == 3)
        {
          v118 = v116;
          free(*(void **)(v117 + 40));
          *(_QWORD *)(v117 + 40) = malloc_type_calloc(v118, 8uLL, 0x2004093837F09uLL);
          *(_DWORD *)(v117 + 32) = 0;
        }
      }
    }
    v109 = objc_msgSend(a1, "backgroundColor");
    if (*(_DWORD *)Value == 1538)
    {
      v110 = *((_QWORD *)Value + 13);
      if (v110)
      {
        if (*(_DWORD *)v110 == 3)
          goto LABEL_180;
      }
    }
    return Value;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
    return Value;
  CGPDFNodeMakeSubType((uint64_t)Value, 2);
  v83 = objc_msgSend(a1, "rowSpan");
  if (*(_DWORD *)Value == 1538)
  {
    v85 = *((_QWORD *)Value + 13);
    if (v85)
    {
      if (*(_DWORD *)v85 == 2)
      {
        *(_QWORD *)(v85 + 8) = v83;
        *(_QWORD *)(v85 + 16) = v84;
      }
    }
  }
  v86 = objc_msgSend(a1, "columnSpan");
  if (*(_DWORD *)Value == 1538)
  {
    v88 = *((_QWORD *)Value + 13);
    if (v88)
    {
      if (*(_DWORD *)v88 == 2)
      {
        *(_QWORD *)(v88 + 24) = v86;
        *(_QWORD *)(v88 + 32) = v87;
      }
    }
  }
  for (i = 0; i != 4; ++i)
  {
    v90 = sideMap[i];
    objc_msgSend(a1, "boundsOfBorder:", i);
    v92 = v91;
    v94 = v93;
    v96 = v95;
    v98 = v97;
    v99 = objc_msgSend(a1, "colorOfBorder:", i);
    if (*(_DWORD *)Value == 1538)
    {
      v100 = *((_QWORD *)Value + 13);
      if (v100)
      {
        if (*(_DWORD *)v100 == 2)
        {
          v101 = (const void *)v99;
          v102 = *(char **)(v100 + 40);
          if (!v102)
          {
            v103 = (char *)malloc_type_calloc(4uLL, 0x28uLL, 0x10200405CE47BF4uLL);
            if (!v103)
              continue;
            v102 = v103;
            for (j = 0; j != 160; j += 40)
              *(CGRect *)&v103[j] = CGRectNull;
          }
          v105 = &v102[40 * v90];
          *(_QWORD *)v105 = v92;
          *((_QWORD *)v105 + 1) = v94;
          *((_QWORD *)v105 + 2) = v96;
          *((_QWORD *)v105 + 3) = v98;
          v108 = (const void *)*((_QWORD *)v105 + 4);
          v107 = v105 + 32;
          v106 = v108;
          if (v108 != v101)
          {
            if (v106)
              CFRelease(v106);
            if (v101)
              CFRetain(v101);
            *v107 = v101;
          }
          *(_QWORD *)(v100 + 40) = v102;
        }
      }
    }
  }
  v109 = objc_msgSend(a1, "backgroundColor");
  if (*(_DWORD *)Value != 1538)
    return Value;
  v110 = *((_QWORD *)Value + 13);
  if (!v110 || *(_DWORD *)v110 != 2)
    return Value;
LABEL_180:
  v119 = (const void *)v109;
  v120 = *(const void **)(v110 + 48);
  if (v120 != v119)
  {
    if (v120)
      CFRelease(v120);
    if (v119)
      CFRetain(v119);
    *(_QWORD *)(v110 + 48) = v119;
  }
  return Value;
}

uint64_t CGPDFNodePopulateFromCPChunk(int *a1, void *a2, uint64_t a3, unsigned int *a4, CFDictionaryRef *a5, CFDictionaryRef *a6)
{
  void *v10;
  int v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  unint64_t v31;
  void *v32;
  char *v33;
  uint64_t v34;
  uint64_t TextRange;
  _QWORD v37[2];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  CFDictionaryRef *v41;
  CFDictionaryRef *v42;
  uint64_t v43;

  v10 = a2;
  if (!a1)
    goto LABEL_13;
  v12 = *a1;
  if ((*a1 & 0x100) != 0)
    return CGPDFNodePopulateFromCPGraphicObject((uint64_t)a1, a2, a3, a4);
  if (v12 == 516)
  {
    if (!a3)
      return 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = objc_msgSend(a2, "count");
    while (1)
    {
      v32 = (void *)objc_msgSend(a2, "childAtIndex:", v30);
      v37[0] = a1;
      v37[1] = a3;
      v38 = v28;
      v40 = 0;
      v41 = a5;
      v42 = a6;
      v43 = 0;
      v39 = 80;
      v33 = CGPDFNodeMakeFromCPChunk(v32, a3, 0, a5, a6);
      if (!v33)
        break;
      v34 = (uint64_t)v33;
      CGPDFNodeAddChild((uint64_t)a1, (uint64_t)v33, v30);
      v37[0] = v34;
      CGPDFNodeRelease(v34);
      if ((map((uint64_t (*)(uint64_t, uint64_t, uint64_t))paragraphs, v32, (uint64_t)v37) & 1) == 0)
        break;
      v28 = v38;
      *(_DWORD *)(v38 + 16) |= 0x80u;
      v29 = ++v30 >= v31;
      if (v31 == v30)
        goto LABEL_30;
    }
    if (!v29)
      return 0;
LABEL_30:
    *(_DWORD *)(v28 + 16) |= 0x200u;
    return 1;
  }
  if (v12 == 513)
  {
    result = CGPDFNodePopulateFromCPGraphicObject((uint64_t)a1, a2, a3, a4);
    if (!(_DWORD)result)
      return result;
    TextRange = CGPDFNodeGetTextRange((uint64_t)a1);
    v15 = v14;
    v16 = objc_msgSend(v10, "count");
    if (v16)
    {
      v17 = v16;
      v18 = 0;
      v19 = 0;
      do
      {
        v20 = (void *)objc_msgSend(v10, "childAtIndex:", v19);
        if (!objc_msgSend(v20, "anchoringTextLine"))
        {
          result = (uint64_t)CGPDFNodeMakeFromCPChunk(v20, a3, 0, a5, a6);
          if (!result)
            return result;
          v21 = result;
          CGPDFNodeAddChild((uint64_t)a1, result, v18);
          CGPDFNodeRelease(v21);
          *(_QWORD *)(v21 + 16) = TextRange;
          *(_QWORD *)(v21 + 24) = v15;
          ++v18;
        }
        v19 = (v19 + 1);
        v10 = a2;
      }
      while (v17 != (_DWORD)v19);
    }
  }
  else
  {
LABEL_13:
    v22 = objc_msgSend(a2, "count");
    if (v22)
    {
      v23 = v22;
      v24 = 0;
      v25 = 0;
      do
      {
        v26 = (void *)objc_msgSend(v10, "childAtIndex:", v25);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || !objc_msgSend(v26, "anchoringTextLine"))
        {
          result = (uint64_t)CGPDFNodeMakeFromCPChunk(v26, a3, 0, a5, a6);
          if (!result)
            return result;
          v27 = result;
          CGPDFNodeAddChild((uint64_t)a1, result, v24);
          CGPDFNodeRelease(v27);
          result = CGPDFNodePopulateFromCPChunk(v27, v26, a3, a4, a5, a6);
          if (!(_DWORD)result)
            return result;
          ++v24;
          v10 = a2;
        }
        v25 = (v25 + 1);
      }
      while (v23 != (_DWORD)v25);
    }
  }
  return 1;
}

uint64_t CGPDFNodePopulateFromCPGraphicObject(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  void *v8;
  _QWORD *v9;
  uint64_t result;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double *v28;

  if (!a3)
    return 0;
  v8 = closestCharacter(a2);
  v9 = v8;
  if (!v8
    || (result = (uint64_t)CGPDFTextStyleCreate((const void *)objc_msgSend(*(id *)(*((_QWORD *)v8 + 20) + 64), "cgPDFFont"), **((const void ***)v8 + 20), *(const void **)(*((_QWORD *)v8 + 20) + 96), *(double *)(*((_QWORD *)v8 + 20) + 72), 0.0, 0.0), (v9 = (_QWORD *)result) != 0))
  {
    v11 = *(_QWORD *)(a3 + 48);
    objc_msgSend(a2, "renderedBounds");
    v13 = v12;
    v15 = v14;
    v17 = v16;
    v19 = v18;
    v20 = (void *)objc_msgSend(a2, "anchoringTextLine");
    v27 = *(_QWORD *)&v15;
    if (v20)
      objc_msgSend(v20, "baseline", v15);
    v28 = CGPDFCharacterCreate(65532, 0, v13, v15, v17, v19, 0.0, 0.0, 0.0, 0.0, v21, v22, v23, v24, v25, v26, v27);
    CGPDFLayoutAppendTextElement(a3, v28, v9, *a4);
    *a4 = 0;
    if (v28)
    {
      if ((*(_QWORD *)v28)-- == 1)
        free(v28);
    }
    if (v9)
      CGPDFTextStyleRelease(v9);
    result = 1;
    *(_QWORD *)(a1 + 16) = v11;
    *(_QWORD *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t paragraphs(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  _DWORD *v22;
  int v23;
  _DWORD *v24;
  int v25;
  _DWORD *v26;
  int v27;
  _DWORD *v28;
  char v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t *v38;
  void *v39;
  unsigned int v40;
  BOOL v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;
  double v48;
  unsigned int *v49;
  unsigned int v50;
  char *v51;
  uint64_t v52;
  void *v53;
  double v54;
  double v55;
  double v56;
  double v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  unint64_t v65;
  unsigned int *v66;
  double v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  double v75;
  double v76;
  double v77;
  double *v78;
  double *v79;
  double *v80;
  double *v81;
  void *v82;
  char *v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const CGRect *v92;
  const CGRect *v93;
  const CGRect *v94;
  double height;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  double v102;
  double v103;
  double v104;
  double v105;
  CGFloat v106;
  CGFloat v107;
  CGFloat v108;
  CGFloat v109;
  double v110;
  double y;
  char *v112;
  _QWORD *v113;
  uint64_t v114;
  void *v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  double v120;
  double v121;
  double v122;
  double v123;
  double v124;
  double v125;
  double v126;
  double v127;
  uint64_t v128;
  CFArrayRef *v129;
  CFArrayRef *v130;
  uint64_t v131;
  int v132;
  unsigned int v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unsigned int v138;
  const __CFArray *v139;
  CFIndex Count;
  CFIndex v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _QWORD *ValueAtIndex;
  CFArrayRef *v147;
  int v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  double *v155;
  double *v156;
  uint64_t v157;
  const void *v158;
  double v159;
  const void *v160;
  const void *v161;
  double *v162;
  double *v163;
  _QWORD *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  int64_t v170;
  uint64_t i;
  void *v172;
  unint64_t v173;
  unint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  double *v183;
  double *v184;
  double *v185;
  double *v186;
  double *v187;
  const void *v188;
  double *v189;
  uint64_t v190;
  int v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  CGFloat *p_height;
  CGSize *p_size;
  const CGRect *v199;
  CGFloat *p_y;
  CGSize *v201;
  CGFloat *v202;
  CGFloat x;
  double v204;
  double width;
  CGFloat v206;
  const CGRect *v207;
  CGSize *v208;
  CGFloat *v209;
  BOOL v210;
  CGFloat *v211;
  const CGRect *v212;
  double v213;
  uint64_t v214;
  double v215;
  double v216;
  uint64_t v217;
  unint64_t v218;
  uint64_t v219;
  void *v220;
  uint64_t v221;
  int v222;
  uint64_t v223;
  uint64_t v224;
  int v225;
  unsigned int *v226;
  unint64_t v227;
  void *v228;
  uint64_t v229;
  CFDictionaryRef *v230;
  CFDictionaryRef *v231;
  unint64_t v232;
  unint64_t v233;
  uint64_t v234;
  _QWORD *v235;
  double v236;
  void *v237;
  _DWORD *v238;
  double v239;
  uint64_t v240;
  _QWORD *v241;
  double v242;
  unint64_t v243;
  __int128 v244;
  __int128 v245;
  __int128 v246;
  __int128 v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  _DWORD v251[2];
  double v252;
  CFDictionaryRef *v253;
  CFDictionaryRef *v254;
  uint64_t v255;
  CGRect v256;
  CGRect v257;
  CGRect v258;
  CGRect v259;
  CGRect v260;

  v3 = a3;
  v255 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)a3;
  v7 = *(_QWORD *)(a3 + 16);
  v8 = *(_DWORD *)(a3 + 24);
  v222 = *(_DWORD *)(a3 + 28);
  v241 = *(_QWORD **)(a3 + 8);
  v230 = *(CFDictionaryRef **)(a3 + 48);
  v231 = *(CFDictionaryRef **)(a3 + 40);
  result = (uint64_t)CGPDFNodeMakeFromCPChunk(a1, (uint64_t)v241, 0, v231, v230);
  if (!result)
    return result;
  v10 = result;
  CGPDFNodeAddChild(v6, result, a2);
  CGPDFNodeRelease(v10);
  v11 = *(uint64_t **)(v3 + 56);
  v220 = a1;
  v12 = (void *)objc_msgSend(a1, "listItem");
  v219 = v10;
  if (!v12)
    goto LABEL_50;
  v13 = v12;
  if (!objc_msgSend(v12, "paragraphCount") || (void *)objc_msgSend(v13, "paragraphAtIndex:", 0) != a1)
    goto LABEL_50;
  v14 = v3;
  v15 = (void *)objc_msgSend(v13, "list");
  v16 = objc_msgSend(v15, "itemCount");
  if (v16)
  {
    v17 = v16;
    if ((void *)objc_msgSend(v15, "itemAtIndex:", 0) == v13)
    {
      CGPDFNodeMakeSubType(v10, 1);
      if (*(_DWORD *)v10 == 1537)
      {
        v20 = *(_QWORD *)(v10 + 104);
        if (v20)
        {
          if (*(_DWORD *)v20 == 1)
          {
            free(*(void **)(v20 + 24));
            *(_QWORD *)(v20 + 24) = malloc_type_calloc(v17, 4uLL, 0x100004052888210uLL);
            *(_DWORD *)(v20 + 20) = 0;
          }
        }
      }
      v21 = objc_msgSend(v15, "type");
      if (*(_DWORD *)v219 == 1537)
      {
        v22 = *(_DWORD **)(v219 + 104);
        if (v22)
        {
          if (*v22 == 1)
            v22[1] = listStyleFromOrdinalType[v21];
        }
      }
      v23 = objc_msgSend(v13, "number");
      if (*(_DWORD *)v219 == 1537)
      {
        v24 = *(_DWORD **)(v219 + 104);
        if (v24)
        {
          if (*v24 == 1)
            v24[4] = v23;
        }
      }
      v25 = objc_msgSend(v15, "ordinalPrefixLength");
      if (*(_DWORD *)v219 == 1537)
      {
        v26 = *(_DWORD **)(v219 + 104);
        if (v26)
        {
          if (*v26 == 1)
            v26[8] = v25;
        }
      }
      v27 = objc_msgSend(v15, "ordinalSuffixLength");
      if (*(_DWORD *)v219 == 1537)
      {
        v28 = *(_DWORD **)(v219 + 104);
        if (v28)
        {
          if (*v28 == 1)
            v28[9] = v27;
        }
      }
      v29 = objc_msgSend(v15, "isMultilevel");
      if (*(_DWORD *)v219 == 1537)
      {
        v30 = *(_QWORD *)(v219 + 104);
        if (v30)
        {
          if (*(_DWORD *)v30 == 1)
            *(_BYTE *)(v30 + 40) = v29;
        }
      }
      v31 = (uint64_t *)malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
      if (!v31)
        goto LABEL_49;
      v32 = v31;
      *v31 = v219;
      v31[1] = (uint64_t)v11;
      v19 = objc_msgSend(v13, "paragraphCount");
      v11 = v32;
      v18 = v219;
      goto LABEL_36;
    }
    if (v11)
    {
      v18 = *v11;
      v19 = objc_msgSend(v13, "paragraphCount");
      if (!v18)
      {
LABEL_47:
        if ((void *)objc_msgSend(v15, "itemAtIndex:", v17 - 1) == v13)
        {
          v38 = (uint64_t *)v11[1];
          free(v11);
          v11 = v38;
        }
        goto LABEL_49;
      }
LABEL_36:
      if (*(_DWORD *)v18 == 1537)
      {
        if (v19)
        {
          if (*(_DWORD *)v219 == 1537)
          {
            v33 = *(_QWORD *)(v18 + 104);
            if (v33)
            {
              if (*(_DWORD *)v33 == 1)
              {
                v34 = *(_QWORD *)(v33 + 24);
                if (v34)
                {
                  v35 = *(unsigned int *)(v33 + 20);
                  if ((_DWORD)v35)
                  {
                    v36 = *(_DWORD *)(v34 + 4 * (v35 - 1)) + v19;
                    v37 = v219;
                  }
                  else
                  {
                    v37 = v219;
                    *(_QWORD *)(v33 + 8) = v219;
                    v36 = v19 - 1;
                  }
                  *(_DWORD *)(v33 + 20) = v35 + 1;
                  *(_DWORD *)(v34 + 4 * v35) = v36;
                  if (v18 != v37)
                  {
                    CGPDFNodeRemoveSubType(v37);
                    *(_QWORD *)(v37 + 104) = v33;
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_47;
    }
  }
LABEL_49:
  v3 = v14;
  v10 = v219;
LABEL_50:
  v217 = v3;
  *(_QWORD *)(v3 + 56) = v11;
  v39 = v220;
  v40 = objc_msgSend(v220, "count");
  if (!v40)
  {
    v44 = (uint64_t)v241;
    goto LABEL_255;
  }
  v41 = 0;
  v42 = 0;
  v43 = v8 | 4;
  v218 = v40;
  v44 = (uint64_t)v241;
  while (1)
  {
    v221 = v42;
    v45 = (void *)objc_msgSend(v39, "childAtIndex:");
    v46 = v45;
    v47 = v44 ? *(_QWORD *)(v44 + 48) : 0;
    objc_msgSend(v45, "baseline");
    v236 = v48;
    v237 = (void *)objc_msgSend(v46, "charSequence");
    v235 = (_QWORD *)objc_msgSend((id)objc_msgSend(v46, "page"), "PDFContext");
    v49 = (unsigned int *)objc_msgSend(v46, "inlineList");
    v50 = objc_msgSend(v46, "wordCount");
    v243 = 0;
    v243 = objc_msgSend(v46, "inlineCount") + (unint64_t)v50;
    v51 = CGPDFNodeMakeFromCPChunk(v46, v44, (uint64_t)&v243, v231, v230);
    if (!v51)
      break;
    v52 = (uint64_t)v51;
    CGPDFNodeAddChild(v10, (uint64_t)v51, v221);
    v229 = v52;
    CGPDFNodeRelease(v52);
    v228 = v46;
    v53 = (void *)objc_msgSend(v46, "parent");
    v242 = 0.0;
    v225 = objc_msgSend(v53, "isPreformattedWithUnitWidth:", &v242);
    if (!v243)
    {
      v60 = (uint64_t)v241;
      goto LABEL_210;
    }
    v58 = 0;
    v59 = 0;
    v227 = v50;
    v60 = (uint64_t)v241;
    v234 = v47;
    do
    {
      v61 = v43 | 1;
      if (v49 && v59 >= *v49)
      {
        v82 = (void *)*((_QWORD *)v49 + 1);
        v248 = v229;
        v249 = v60;
        v250 = v7;
        v251[0] = v43 | 1;
        v251[1] = v222;
        v252 = v236;
        v253 = v231;
        v254 = v230;
        v83 = (char *)malloc_type_calloc(0x48uLL, 1uLL, 0x2C7ACE11uLL);
        *(_DWORD *)v83 = 1;
        *((_DWORD *)v83 + 10) = 1;
        *((_OWORD *)v83 + 1) = CPRangeNull;
        *((_QWORD *)v83 + 4) = 0;
        *((_QWORD *)v83 + 7) = 0;
        *(_QWORD *)(v83 + 44) = 0;
        v83[52] = 0;
        CGPDFNodeAddChild(v229, (uint64_t)v83, v58);
        CGPDFNodeRelease((uint64_t)v83);
        if (v60)
          v84 = *(_QWORD *)(v60 + 48);
        else
          v84 = 0;
        v47 = v234;
        v85 = CGPDFNodeMakeFromCPChunk(v82, v60, 0, v231, v230);
        if (v85)
        {
          v86 = (uint64_t)v85;
          if (*(_DWORD *)v83 == 1)
          {
            v87 = *((_QWORD *)v83 + 8);
            if (v87)
            {
              *(_QWORD *)(v87 + 8) = 0;
              v83[52] = 0;
              CGPDFNodeRelease(v87);
            }
            else
            {
              v83[52] = 0;
            }
            *((_QWORD *)v83 + 8) = v86;
            v83[52] = 1;
            ++*(_DWORD *)(v86 + 40);
            *(_QWORD *)(v86 + 8) = v83;
          }
          CGPDFNodeRelease(v86);
          v88 = v86;
          v60 = (uint64_t)v241;
          if (!CGPDFNodePopulateFromCPChunk(v88, v82, v241, v251, v231, v230))
            goto LABEL_202;
          v89 = v249;
          if (v249)
            v90 = *(_QWORD *)(v249 + 48);
          else
            v90 = 0;
          *((_QWORD *)v83 + 2) = v84;
          *((_QWORD *)v83 + 3) = v90 - v84;
          v91 = *(_QWORD *)(v89 + 24) + 24 * *(_QWORD *)(v89 + 32);
          v7 = v91 - 24;
          v250 = v91 - 24;
          *(_DWORD *)(v91 - 8) |= 2u;
          v92 = (const CGRect *)closestCharacter(v82);
          v93 = v92;
          v94 = &CGRectZero;
          if (v92)
            v94 = v92;
          height = v94->size.height;
          objc_msgSend(v82, "renderedBounds");
          v106 = v102;
          v107 = v103;
          v108 = v104;
          v109 = v105;
          if (v104 < 0.0 || v105 < 0.0)
          {
            v256 = CGRectStandardize(*(CGRect *)&v102);
            v110 = v256.origin.x + v256.size.width;
            v256.origin.x = v106;
            v256.origin.y = v107;
            v256.size.width = v108;
            v256.size.height = v109;
            v257 = CGRectStandardize(v256);
            y = v257.origin.y;
            if (!v93)
            {
              v258.origin.x = v106;
              v258.origin.y = v107;
              v258.size.width = v108;
              v258.size.height = v109;
              v259 = CGRectStandardize(v258);
              v107 = v259.origin.y;
              goto LABEL_194;
            }
          }
          else
          {
            v110 = v102 + v104;
            y = v103;
            if (!v93)
            {
LABEL_194:
              v187 = CGPDFCharacterCreate(32, 0, v110, y, 0.0, height, 0.0, 0.0, 0.0, 0.0, v96, v97, v98, v99, v100, v101, *(uint64_t *)&v107);
              if (v93)
              {
                v188 = (const void *)objc_msgSend(*(id *)(*(_QWORD *)&v93[5].origin.x + 64), "cgPDFFont");
                v189 = CGPDFTextStyleCreate(v188, **(const void ***)&v93[5].origin.x, *(const void **)(*(_QWORD *)&v93[5].origin.x + 96), *(double *)(*(_QWORD *)&v93[5].origin.x + 72), v93[5].origin.y * 0.0174532925, v93[2].size.height - v252);
                CGPDFLayoutAppendTextElement(v89, v187, v189, 0x400u);
                if (v189)
                  CGPDFTextStyleRelease(v189);
              }
              else
              {
                CGPDFLayoutAppendTextElement(v89, v187, 0, 0x400u);
              }
              v60 = (uint64_t)v241;
              if (v187)
              {
                v63 = (*(_QWORD *)v187)-- == 1;
                if (v63)
                  free(v187);
              }
              goto LABEL_202;
            }
          }
          v107 = v93[2].size.height;
          goto LABEL_194;
        }
        v60 = (uint64_t)v241;
LABEL_202:
        v49 = (unsigned int *)*((_QWORD *)v49 + 2);
        goto LABEL_203;
      }
      if (v59 >= v227)
      {
        v47 = v234;
        goto LABEL_203;
      }
      v232 = v58;
      v226 = v49;
      if (v225)
      {
        v62 = objc_msgSend(v228, "spacesBeforeWordAtIndex:", v59);
        v63 = !v59 || v62 == 0;
        v64 = !v63;
        v65 = v62 - v64;
        if (v62 != v64)
        {
          v66 = (unsigned int *)objc_msgSend(v228, "wordAtIndex:", v59);
          v67 = v242;
          v74 = objc_msgSend(v237, "charAtIndex:", *v66);
          v75 = *(double *)(v74 + 24);
          v76 = *(double *)(v74 + 8);
          v77 = *(double *)v74 - (double)v65 * v67;
          do
          {
            v78 = CGPDFCharacterCreate(32, 0, v77, v76, v67, v75, 0.0, 0.0, 0.0, 0.0, v68, v69, v70, v71, v72, v73, *(_QWORD *)(v74 + 88));
            if (!v78)
              break;
            v79 = v78;
            v80 = CGPDFTextStyleCreate((const void *)objc_msgSend(*(id *)(*(_QWORD *)(v74 + 160) + 64), "cgPDFFont"), **(const void ***)(v74 + 160), *(const void **)(*(_QWORD *)(v74 + 160) + 96), *(double *)(*(_QWORD *)(v74 + 160) + 72), *(double *)(v74 + 168) * 0.0174532925, *(double *)(v74 + 88) - v236);
            if (!v80)
            {
              v63 = (*(_QWORD *)v79)-- == 1;
              if (v63)
                free(v79);
              break;
            }
            v81 = v80;
            CGPDFLayoutAppendTextElement((uint64_t)v241, v79, v80, 0x400u);
            v63 = (*(_QWORD *)v79)-- == 1;
            if (v63)
              free(v79);
            --v65;
            CGPDFTextStyleRelease(v81);
            v77 = v67 + v77;
          }
          while (v65);
        }
      }
      v238 = (_DWORD *)objc_msgSend(v228, "wordAtIndex:", v59);
      v240 = v238[1];
      v112 = (char *)malloc_type_calloc(0x48uLL, 1uLL, 0x2C7ACE11uLL);
      *(_DWORD *)v112 = 1;
      *((_DWORD *)v112 + 10) = 1;
      *((_OWORD *)v112 + 1) = CPRangeNull;
      *((_QWORD *)v112 + 4) = 0;
      *((_QWORD *)v112 + 7) = 0;
      *(_QWORD *)(v112 + 44) = 0;
      v112[52] = 0;
      CGPDFNodeAddChild(v229, (uint64_t)v112, v58);
      CGPDFNodeRelease((uint64_t)v112);
      v113 = v241;
      if (v241)
        v114 = v241[6];
      else
        v114 = 0;
      if (!(_DWORD)v240)
      {
        v47 = v234;
        goto LABEL_183;
      }
      v223 = v114;
      v224 = (uint64_t)v112;
      v233 = v59;
      v115 = 0;
      v116 = 0;
      v117 = 0;
      do
      {
        v118 = objc_msgSend(v237, "charAtIndex:", (*v238 + v116));
        if (!v117 || !isCharacterOverlay(v117, v118))
        {
          v119 = *(unsigned __int16 *)(v118 + 72);
          v120 = *(double *)v118;
          v121 = *(double *)(v118 + 8);
          v122 = *(double *)(v118 + 16);
          v123 = *(double *)(v118 + 24);
          v124 = *(double *)(v118 + 32);
          v125 = *(double *)(v118 + 40);
          v126 = *(double *)(v118 + 48);
          v127 = *(double *)(v118 + 56);
          v239 = *(double *)(v118 + 168);
          if (*(_WORD *)(v118 + 72))
          {
            LODWORD(v248) = 0;
            LODWORD(v244) = 0;
            if (decomposes(v119, &v248, &v244))
            {
              v128 = v244;
              v129 = (CFArrayRef *)malloc_type_malloc(2 * v244, 0x1000040BDFB0063uLL);
              v130 = v129;
              if (v129 && (_DWORD)v128)
              {
                v131 = 0;
                v132 = v248;
                do
                {
                  v133 = ds[(v132 + v131)];
                  if (HIWORD(v133))
                    LOWORD(v133) = 0;
                  *((_WORD *)v129 + v131++) = v133;
                }
                while (v128 != v131);
              }
              else
              {
                v128 = 0;
              }
            }
            else
            {
              v128 = 0;
              v130 = 0;
            }
            v147 = v130;
          }
          else
          {
            v134 = v235[258];
            v135 = v235[259];
            v136 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v135 - v134) >> 6) + 0xFFFFFFFF;
            if (v134 >= v135)
              LODWORD(v136) = 0;
            if (v135 > v118)
              v137 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v118 - v134) >> 6);
            else
              LODWORD(v137) = v136;
            if (v134 <= v118)
              v138 = v137;
            else
              v138 = 0;
            v130 = (CFArrayRef *)v235[287];
            if (v130)
            {
              v139 = v130[3];
              if (v139)
              {
                Count = CFArrayGetCount(v139);
                if (Count >= 1)
                {
                  v141 = Count;
                  v142 = v138;
                  v143 = -1;
                  do
                  {
                    v144 = v141 + v143;
                    if (v141 + v143 < 0 != __OFADD__(v141, v143))
                      ++v144;
                    v145 = v144 >> 1;
                    ValueAtIndex = CFArrayGetValueAtIndex(v130[3], v144 >> 1);
                    if (!ValueAtIndex)
                      break;
                    if (*ValueAtIndex == v142)
                    {
                      v147 = 0;
                      v128 = ValueAtIndex[2];
                      v130 = (CFArrayRef *)ValueAtIndex[3];
                      goto LABEL_141;
                    }
                    if (*ValueAtIndex >= v142)
                      v141 = v145;
                    else
                      v143 = v145;
                  }
                  while (v143 + 1 < v141);
                }
              }
              v128 = 0;
              v130 = 0;
            }
            else
            {
              v128 = 0;
            }
            v147 = 0;
LABEL_141:
            v113 = v241;
          }
          v148 = MEMORY[0x186DC3438](v119);
          if ((v148 == 13 || v148 == 1) && v113)
            *((_BYTE *)v113 + 72) = 1;
          v155 = CGPDFCharacterCreate(v119, *(_WORD *)(v118 + 74), v120, v121, v122, v123, v124, v125, v126, v127, v149, v150, v151, v152, v153, v154, *(_QWORD *)(v118 + 88));
          if (!v155)
            goto LABEL_154;
          v156 = v155;
          v157 = *(_QWORD *)(v118 + 160);
          v158 = (const void *)objc_msgSend(*(id *)(v157 + 64), "cgPDFFont");
          v159 = *(double *)(v157 + 72);
          v160 = *(const void **)v157;
          v161 = *(const void **)(v157 + 96);
          v113 = v241;
          v162 = CGPDFTextStyleCreate(v158, v160, v161, v159, v239 * 0.0174532925, *(double *)(v118 + 88) - v236);
          if (v162)
          {
            v163 = v162;
            CGPDFLayoutAppendTextElement((uint64_t)v241, v156, v162, v61);
            if (v128)
            {
              v164 = (_QWORD *)v241[7];
              if (!v164)
              {
                v164 = CPMultiUnicodesCreate();
                v241[7] = v164;
              }
              CPMultiUnicodesAppend((uint64_t)v164, v241[6] - 1, v128, v130);
            }
            CGPDFTextStyleRelease(v163);
          }
          v63 = (*(_QWORD *)v156)-- == 1;
          if (v63)
          {
            free(v156);
            if (v147)
LABEL_155:
              free(v147);
          }
          else
          {
LABEL_154:
            if (v147)
              goto LABEL_155;
          }
          v7 = v113[3] + 24 * v113[4] - 24;
        }
        v165 = *(_QWORD *)(v118 + 184);
        if (v165 != -1)
        {
          if (!v115)
          {
            v115 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3550]), "initWithCapacity:", v240);
            v165 = *(_QWORD *)(v118 + 184);
          }
          objc_msgSend(v115, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v165));
        }
        v61 = (v7 == 0) << 8;
        ++v116;
        v117 = v118;
      }
      while (v116 != v240);
      v47 = v234;
      if (!v115)
        goto LABEL_180;
      v246 = 0u;
      v247 = 0u;
      v244 = 0u;
      v245 = 0u;
      v166 = objc_msgSend(v115, "countByEnumeratingWithState:objects:count:", &v244, &v248, 16);
      if (!v166)
      {

LABEL_180:
        v58 = v232;
        v59 = v233;
        goto LABEL_181;
      }
      v167 = v166;
      v168 = 0;
      v169 = *(_QWORD *)v245;
      v170 = -1;
      do
      {
        for (i = 0; i != v167; ++i)
        {
          if (*(_QWORD *)v245 != v169)
            objc_enumerationMutation(v115);
          v172 = *(void **)(*((_QWORD *)&v244 + 1) + 8 * i);
          v173 = objc_msgSend(v115, "countForObject:", v172);
          if (v173 > v168)
          {
            v174 = v173;
            v170 = objc_msgSend(v172, "longLongValue");
            v168 = v174;
          }
        }
        v167 = objc_msgSend(v115, "countByEnumeratingWithState:objects:count:", &v244, &v248, 16);
      }
      while (v167);

      v59 = v233;
      if (v170 != -1)
      {
        v112 = (char *)v224;
        CGPDFTaggedContextAddNode(v235[293], v170, v224);
        v113 = v241;
        v47 = v234;
        v58 = v232;
        goto LABEL_182;
      }
      v113 = v241;
      v47 = v234;
      v58 = v232;
LABEL_181:
      v112 = (char *)v224;
LABEL_182:
      v114 = v223;
LABEL_183:
      if (v113)
        v175 = v113[6];
      else
        v175 = 0;
      *((_QWORD *)v112 + 2) = v114;
      *((_QWORD *)v112 + 3) = v175 - v114;
      *(_DWORD *)(v7 + 16) |= 2u;
      v176 = objc_msgSend(v237, "charAtIndex:", (*v238 + v238[1] - 1));
      v183 = CGPDFCharacterCreate(32, 0, *(double *)v176 + *(double *)(v176 + 16), *(double *)(v176 + 8), 0.0, *(double *)(v176 + 24), 0.0, 0.0, 0.0, 0.0, v177, v178, v179, v180, v181, v182, *(_QWORD *)(v176 + 88));
      if (v183)
      {
        v184 = v183;
        v185 = CGPDFTextStyleCreate((const void *)objc_msgSend(*(id *)(*(_QWORD *)(v176 + 160) + 64), "cgPDFFont"), **(const void ***)(v176 + 160), *(const void **)(*(_QWORD *)(v176 + 160) + 96), *(double *)(*(_QWORD *)(v176 + 160) + 72), *(double *)(v176 + 168) * 0.0174532925, *(double *)(v176 + 88) - v236);
        if (v185)
        {
          v186 = v185;
          CGPDFLayoutAppendTextElement((uint64_t)v241, v184, v185, 0x400u);
          CGPDFTextStyleRelease(v186);
        }
        v63 = (*(_QWORD *)v184)-- == 1;
        if (v63)
          free(v184);
      }
      ++v59;
      v60 = (uint64_t)v241;
      v49 = v226;
LABEL_203:
      v43 = 0;
      ++v58;
    }
    while (v58 < v243);
LABEL_210:
    *(_DWORD *)(v7 + 16) |= 8u;
    if (v60)
      v190 = *(_QWORD *)(v60 + 48);
    else
      v190 = 0;
    v191 = v225;
    if (v190 <= v47)
      v191 = 0;
    if (v191 == 1)
    {
      *(_QWORD *)(v229 + 16) = v47;
      *(_QWORD *)(v229 + 24) = v190 + ~v47;
    }
    v192 = v190 - 1;
    v10 = v219;
    if (v47 < v190 - 1)
    {
      v193 = 24 * v47;
      do
      {
        v194 = 0;
        if (v241 && (v47 & 0x8000000000000000) == 0)
        {
          if (v241[6] > v47 && (v195 = v241[3]) != 0)
            v194 = *(_QWORD *)(v195 + v193);
          else
            v194 = 0;
        }
        v196 = 0;
        ++v47;
        if (v241 && (v47 & 0x8000000000000000) == 0)
        {
          if (v241[6] <= v47)
          {
            v196 = 0;
          }
          else
          {
            v196 = v241[3];
            if (v196)
              v196 = *(_QWORD *)(v196 + v193 + 24);
          }
        }
        p_height = &CGRectNull.size.height;
        p_size = &CGRectNull.size;
        v199 = (const CGRect *)(v194 + 16);
        p_y = (CGFloat *)(v194 + 24);
        v201 = (CGSize *)(v194 + 32);
        v202 = (CGFloat *)(v194 + 40);
        if (!v194)
        {
          p_y = &CGRectNull.origin.y;
          v201 = &CGRectNull.size;
          v202 = &CGRectNull.size.height;
          v199 = &CGRectNull;
        }
        x = v199->origin.x;
        v204 = *v202;
        width = v201->width;
        v206 = *p_y;
        v207 = (const CGRect *)(v196 + 16);
        v208 = (CGSize *)(v196 + 32);
        v209 = (CGFloat *)(v196 + 40);
        v210 = v196 == 0;
        if (v196)
          v211 = (CGFloat *)(v196 + 24);
        else
          v211 = &CGRectNull.origin.y;
        if (v210)
        {
          v212 = &CGRectNull;
        }
        else
        {
          p_size = v208;
          p_height = v209;
          v212 = v207;
        }
        v213 = v212->origin.x;
        v57 = *p_height;
        v56 = p_size->width;
        if (p_size->width < 0.0 || v57 < 0.0)
        {
          v214 = *(_QWORD *)v211;
          v215 = v212->origin.x;
          *(CGRect *)(&v55 - 1) = CGRectStandardize(*(CGRect *)(&v56 - 2));
          v213 = v216;
        }
        if (width < 0.0 || (v54 = x, v204 < 0.0))
        {
          v260.origin.x = x;
          v260.origin.y = v206;
          v260.size.width = width;
          v260.size.height = v204;
          *(CGRect *)&v54 = CGRectStandardize(v260);
        }
        if (v194)
        {
          v54 = v213 - v54;
          *(CGFloat *)(v194 + 16) = x;
          *(CGFloat *)(v194 + 24) = v206;
          *(double *)(v194 + 32) = v54;
          *(double *)(v194 + 40) = v204;
        }
        v193 += 24;
      }
      while (v192 != v47);
    }
    v44 = (uint64_t)v241;
    if (objc_msgSend(v228, "lineBreakAfter", v54, v55, v56, v57))
      *(_WORD *)(*(_QWORD *)(v241[3] + 24 * v241[6] - 24) + 8) = 10;
    v39 = v220;
    v42 = v221 + 1;
    v43 = 4;
    v41 = v221 + 1 >= v218;
    if (v221 + 1 == v218)
    {
LABEL_255:
      *(_DWORD *)(v7 + 16) |= 0x20u;
      *(_QWORD *)(v217 + 16) = v7;
      *(_DWORD *)(v217 + 24) = 16;
      goto LABEL_256;
    }
  }
  *(_DWORD *)(v7 + 16) |= 0x20u;
  *(_QWORD *)(v217 + 16) = v7;
  *(_DWORD *)(v217 + 24) = 16;
  v44 = (uint64_t)v241;
  if (!v41)
    return 0;
LABEL_256:
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(v44 + 24) + 24 * *(_QWORD *)(v44 + 48) - 24) + 8) = 10;
  return 1;
}

void *closestCharacter(void *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  unsigned int *v5;
  void *v6;
  int v7;
  int v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  void *result;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;

uint64_t rightDescendantCharacter(void *a1)
{
  void *v2;
  void *v3;
  int v4;
  uint64_t result;
  uint64_t v6;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v2 = (void *)objc_msgSend(a1, "charSequence");
    if (v2)
    {
      v3 = v2;
      v4 = objc_msgSend(v2, "length");
      if (v4)
        return objc_msgSend(v3, "charAtIndex:", (v4 - 1));
    }
  }
  v6 = objc_msgSend(a1, "count") - 1;
  while ((_DWORD)v6 != -1)
  {
    result = rightDescendantCharacter(objc_msgSend(a1, "childAtIndex:", v6));
    v6 = (v6 - 1);
    if (result)
      return result;
  }
  return 0;
}

uint64_t leftDescendantCharacter(void *a1)
{
  void *v2;
  void *v3;
  uint64_t result;
  int v5;
  int v6;
  uint64_t v7;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v2 = (void *)objc_msgSend(a1, "charSequence");
    if (v2)
    {
      v3 = v2;
      if (objc_msgSend(v2, "length"))
        return objc_msgSend(v3, "charAtIndex:", 0);
    }
  }
  v5 = objc_msgSend(a1, "count");
  if (!v5)
    return 0;
  v6 = v5;
  v7 = 0;
  while (1)
  {
    result = leftDescendantCharacter(objc_msgSend(a1, "childAtIndex:", v7));
    if (result)
      break;
    v7 = (v7 + 1);
    if (v6 == (_DWORD)v7)
      return 0;
  }
  return result;
}

uint64_t CGPDFNodeTypeFromCPChunk()
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 257;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 258;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 259;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 513;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 514;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 1537;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 515;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 516;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 1538;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 1538;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 1538;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 1538;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 1538;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return 517;
  else
    return 0;
}

unint64_t CGPDFNodeSizeFromCPChunk(void *a1, const __CFSet *a2)
{
  int v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int i;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;

  v4 = CGPDFNodeTypeFromCPChunk();
  if (v4 != 514)
  {
    v10 = v4;
    if ((v4 & 0x100) != 0)
    {
      v11 = objc_msgSend((id)objc_msgSend(a1, "page"), "clipBuffer");
      for (i = objc_msgSend(a1, "clipIndex"); i; i = *(_DWORD *)(*(_QWORD *)(v11 + 16) + 52 * v13))
      {
        v13 = i;
        if (CFSetContainsValue(a2, (const void *)i))
          break;
        CFSetAddValue(a2, (const void *)v13);
      }
    }
    v14 = objc_msgSend(a1, "count");
    if (v14)
    {
      v15 = v14;
      v16 = 0;
      v17 = 0;
      v18 = v14;
      do
      {
        v19 = (void *)objc_msgSend(a1, "childAtIndex:", v16);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 && objc_msgSend(v19, "anchoringTextLine"))
          --v18;
        else
          v17 += CGPDFNodeSizeFromCPChunk(v19, a2);
        v16 = (v16 + 1);
      }
      while (v15 != (_DWORD)v16);
    }
    else
    {
      v18 = 0;
      v17 = 0;
    }
    if (v10 <= 513)
    {
      if (v10 > 256)
      {
        if (v10 == 257)
        {
          v20 = 200;
          goto LABEL_47;
        }
        if (v10 == 258)
        {
          v20 = 192;
          goto LABEL_47;
        }
      }
      else
      {
        if (!v10)
        {
          v20 = 0;
          goto LABEL_47;
        }
        if (v10 == 1)
        {
          v21 = 72;
          if (!v18)
            v21 = 64;
          return v21 + v17;
        }
      }
    }
    else if (v10 <= 516)
    {
      if (v10 == 516)
      {
        v20 = 112;
        goto LABEL_47;
      }
    }
    else
    {
      switch(v10)
      {
        case 517:
          v20 = 144;
          goto LABEL_47;
        case 1537:
          v20 = 136;
          goto LABEL_47;
        case 1538:
          v20 = 120;
LABEL_47:
          v21 = v20 + 8 * v18;
          return v21 + v17;
      }
    }
    v20 = 112;
    if (v10 < 0x400)
      v20 = 104;
    if ((v10 & 0x200) == 0)
      v20 = 120;
    if ((v10 & 0x300) == 0)
      v20 = 64;
    goto LABEL_47;
  }
  v5 = objc_msgSend(a1, "wordCount");
  v6 = objc_msgSend(a1, "inlineCount");
  v7 = ((unint64_t)v5 << 6) + 8 * (v6 + v5) + 112;
  if (v6)
  {
    v7 += 72 * v6;
    v8 = objc_msgSend(a1, "inlineList");
    if (v8)
    {
      v9 = v8;
      do
      {
        v7 += CGPDFNodeSizeFromCPChunk(*(_QWORD *)(v9 + 8), a2);
        v9 = *(_QWORD *)(v9 + 16);
      }
      while (v9);
    }
  }
  return v7;
}

uint64_t countClips(uint64_t result, _DWORD *a2)
{
  a2[2] += *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 16) + 52 * result + 8);
  return result;
}

const void *CGPDFNodeClipMakeFromClipIndex(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, CFDictionaryRef *a5)
{
  const void *Value;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  const void *v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v24;

  if (!a2)
    return 0;
  if (a5)
  {
    if (*a5)
    {
      Value = CFDictionaryGetValue(*a5, (const void *)a2);
      if (Value)
        return Value;
    }
    else
    {
      *a5 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
    }
  }
  v11 = *(_QWORD *)(a1 + 16);
  v12 = a2;
  v13 = *(unsigned int *)(v11 + 52 * a2);
  if ((_DWORD)v13 == a2)
    Value = 0;
  else
    Value = (const void *)CGPDFNodeClipMakeFromClipIndex(a1, v13, a3, a4, a5);
  v14 = v11 + 52 * a2;
  v24 = (_DWORD *)(v14 + 8);
  if (*(_DWORD *)(v14 + 8))
  {
    v15 = *(_DWORD *)(v14 + 8) - 1;
    do
    {
      if (a4 && *(_DWORD *)a4 == 517)
      {
        v16 = a3 + 216 * *(unsigned int *)(v11 + 52 * v12 + 4 * v15 + 12);
        v17 = *(_DWORD *)(v16 + 72);
        v18 = *(const void **)(v16 + 96);
        v19 = *(_BYTE *)(v16 + 104);
        v20 = *(unsigned int *)(a4 + 112);
        v21 = *(_QWORD *)(a4 + 120) + 32 * v20;
        *(_DWORD *)v21 = v17;
        if (v18)
        {
          CFRetain(v18);
          LODWORD(v20) = *(_DWORD *)(a4 + 112);
        }
        *(_QWORD *)(v21 + 8) = v18;
        *(_BYTE *)(v21 + 16) = v19 ^ 1;
        *(_QWORD *)(v21 + 24) = Value;
        *(_DWORD *)(a4 + 112) = v20 + 1;
        Value = (const void *)v21;
      }
      else
      {
        Value = 0;
      }
    }
    while ((unint64_t)v15--);
  }
  if (a5 && *a5 && Value && *v24)
    CFDictionaryAddValue(*a5, (const void *)v12, Value);
  return Value;
}

uint64_t cmap_create_with_name(const void *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  _QWORD *v5;
  const __CFAllocator *v6;
  const __CFData *v7;
  const __CFData *v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFReadStream *v11;
  __CFReadStream *v12;
  _BYTE *v13;
  CFIndex v14;
  int v15;
  BOOL v16;
  BOOL v17;
  CFIndex v18;
  CFIndex v19;
  CFIndex v20;
  void *v21;
  CFIndex v22;
  UInt8 v23;
  CFIndex v24;
  UInt8 v25;
  CFMutableArrayRef Mutable;
  UInt8 v27;
  CFIndex v28;
  unsigned int v29;
  unsigned int v30;
  CFIndex v31;
  unsigned int v32;
  unsigned int v33;
  _QWORD *v34;
  unsigned int v35;
  _QWORD *v36;
  CFIndex v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  CFIndex v42;
  uint64_t v43;
  CFIndex v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  CFIndex v48;
  unsigned int v49;
  CFIndex v50;
  uint64_t v51;
  uint64_t v52;
  _WORD *v53;
  _WORD *v54;
  uint64_t v55;
  CFIndex v56;
  unsigned int v57;
  uint64_t v58;
  UInt8 buffer[4];

  v2 = 0;
  while (1)
  {
    v3 = bsearch(a1, (&cmap_create_with_name_tables)[v2], (size_t)*(&cmap_create_with_name_tables)[v2 + 1], 0x20uLL, (int (__cdecl *)(const void *, const void *))CMapEntry_compare);
    if (v3)
      break;
    v2 += 2;
    if (v2 == 10)
      return 0;
  }
  v5 = v3;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v7 = CFDataCreateWithBytesNoCopy(0, *((const UInt8 **)v3 + 2), *((_QWORD *)v3 + 3), (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v8 = v7;
  if (!v7
    || (BytePtr = CFDataGetBytePtr(v7),
        Length = CFDataGetLength(v8),
        (v11 = CFReadStreamCreateWithBytesNoCopy(0, BytePtr, Length, v6)) == 0))
  {
    v4 = 0;
    goto LABEL_71;
  }
  v12 = v11;
  CFReadStreamOpen(v11);
  v13 = malloc_type_calloc(1uLL, 0x38uLL, 0x10300405646078BuLL);
  v4 = (uint64_t)v13;
  if (v13)
  {
    *(_DWORD *)v13 = 1;
    v13[41] = 0;
    *((_QWORD *)v13 + 1) = read_string(v12);
    *(_QWORD *)(v4 + 16) = read_string(v12);
    buffer[0] = 0;
    v14 = CFReadStreamRead(v12, buffer, 1);
    v15 = buffer[0];
    if (!v14)
      v15 = 0;
    *(_DWORD *)(v4 + 24) = v15;
    buffer[0] = 0;
    v16 = !CFReadStreamRead(v12, buffer, 1) || buffer[0] == 0;
    v17 = !v16;
    *(_BYTE *)(v4 + 40) = v17;
    if (v16)
    {
      *(_DWORD *)buffer = 0;
      v18 = CFReadStreamRead(v12, buffer, 4);
      v19 = bswap32(*(unsigned int *)buffer);
      if (v18)
        v20 = v19;
      else
        v20 = 0;
      v21 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200404BE0E0E6uLL);
      if (!v21)
        goto LABEL_69;
      buffer[0] = 0;
      v22 = CFReadStreamRead(v12, buffer, 1);
      v23 = buffer[0];
      if (!v22)
        v23 = 0;
      *(_BYTE *)v21 = v23;
      buffer[0] = 0;
      v24 = CFReadStreamRead(v12, buffer, 1);
      v25 = buffer[0];
      if (!v24)
        v25 = 0;
      *((_BYTE *)v21 + 1) = v25;
      if (!v20)
        goto LABEL_69;
      Mutable = CFArrayCreateMutable(0, v20, 0);
      *((_QWORD *)v21 + 1) = Mutable;
      if (!Mutable)
      {
        cmap_csr_set_release((uint64_t)v21);
        v21 = 0;
LABEL_69:
        *(_QWORD *)(v4 + 48) = v21;
        goto LABEL_70;
      }
      do
      {
        buffer[0] = 0;
        if (CFReadStreamRead(v12, buffer, 1))
          v27 = buffer[0];
        else
          v27 = 0;
        *(_DWORD *)buffer = 0;
        v28 = CFReadStreamRead(v12, buffer, 4);
        v29 = bswap32(*(unsigned int *)buffer);
        if (v28)
          v30 = v29;
        else
          v30 = 0;
        *(_DWORD *)buffer = 0;
        v31 = CFReadStreamRead(v12, buffer, 4);
        v32 = bswap32(*(unsigned int *)buffer);
        if (v31)
          v33 = v32;
        else
          v33 = 0;
        v34 = csr_create(v27, v30, v33);
        v34[3] = cmap_cid_set_create_with_stream(v12);
        v34[2] = cmap_cid_set_create_with_stream(v12);
        CFArrayAppendValue(*((CFMutableArrayRef *)v21 + 1), v34);
        --v20;
      }
      while (v20);
      *(_DWORD *)buffer = 0;
      if (CFReadStreamRead(v12, buffer, 4))
      {
        v35 = *(_DWORD *)buffer;
        if (*(_DWORD *)buffer)
        {
          v20 = operator new();
          *(_DWORD *)v20 = 0;
          *(_OWORD *)(v20 + 8) = 0u;
          v36 = (_QWORD *)(v20 + 8);
          *(_OWORD *)(v20 + 24) = 0u;
          *(_OWORD *)(v20 + 40) = 0u;
          *(_OWORD *)(v20 + 56) = 0u;
          *(_QWORD *)(v20 + 72) = 0;
          *(_DWORD *)(v20 + 80) = 1065353216;
          *(_DWORD *)buffer = 0;
          v37 = CFReadStreamRead(v12, buffer, 4);
          v38 = bswap32(*(unsigned int *)buffer);
          if (v37)
            v39 = v38 + 1;
          else
            v39 = 1;
          if (!grow_code_map((void **)v20, v39))
            goto LABEL_67;
          v40 = bswap32(v35);
          if (v40 <= 1)
            v41 = 1;
          else
            v41 = v40;
          do
          {
            *(_WORD *)buffer = 0;
            v42 = CFReadStreamRead(v12, buffer, 2);
            v43 = bswap32(*(unsigned __int16 *)buffer) >> 16;
            *(_WORD *)buffer = 0;
            v44 = CFReadStreamRead(v12, buffer, 2);
            v45 = bswap32(*(unsigned __int16 *)buffer) >> 16;
            if (!v44)
              v45 = 0;
            if (v42)
              v46 = v43;
            else
              v46 = 0;
            v47 = 8 * v46;
            *(_DWORD *)(*v36 + 8 * v46 + 4) = v45;
            *(_DWORD *)buffer = 0;
            v48 = CFReadStreamRead(v12, buffer, 4);
            v49 = bswap32(*(unsigned int *)buffer);
            if (!v48)
              v49 = 0;
            *(_DWORD *)(*v36 + v47) = v49;
            --v41;
          }
          while (v41);
          *(_WORD *)buffer = 0;
          v50 = CFReadStreamRead(v12, buffer, 2);
          v51 = bswap32(*(unsigned __int16 *)buffer) >> 16;
          if (!v50)
            v51 = 0;
          *(_QWORD *)(v20 + 40) = v51;
          *(_DWORD *)buffer = 0;
          if (!CFReadStreamRead(v12, buffer, 4) || !*(_DWORD *)buffer)
            goto LABEL_68;
          v52 = bswap32(*(unsigned int *)buffer);
          v53 = malloc_type_malloc(2 * v52, 0x1000040BDFB0063uLL);
          *(_QWORD *)(v20 + 32) = v53;
          if (v53)
          {
            v54 = v53;
            v55 = 0;
            *(_QWORD *)(v20 + 16) = v52;
            *(_QWORD *)(v20 + 24) = v52;
            do
            {
              *(_WORD *)buffer = 0;
              v56 = CFReadStreamRead(v12, buffer, 2);
              v57 = bswap32(*(unsigned __int16 *)buffer) >> 16;
              if (!v56)
                LOWORD(v57) = 0;
              v54[v55++] = v57;
            }
            while (*(_QWORD *)(v20 + 24) > (unint64_t)v55);
          }
          else
          {
LABEL_67:
            cmap_bf_set_release(v20);
            v20 = 0;
          }
        }
      }
LABEL_68:
      *((_QWORD *)v21 + 2) = v20;
      goto LABEL_69;
    }
  }
LABEL_70:
  CFReadStreamClose(v12);
  CFRelease(v12);
LABEL_71:
  CFRelease(v8);
  if (v5[1])
  {
    v58 = cmap_create_with_name();
    cmap_set_used_cmap(v4, v58);
    cmap_release(v58);
  }
  return v4;
}

uint64_t CMapEntry_compare(const char *a1, const char **a2)
{
  return strcmp(a1, *a2);
}

void function_evaluate_float(uint64_t a1, float *a2, float *a3, __n128 a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  double *v14;
  double *v15;
  float v16;
  double v17;
  float v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(a1 + 48);
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  MEMORY[0x1E0C80A78](a1, a4);
  v12 = (char *)v19 - v11;
  if (v10 <= 0x1FFFFFFFFFFFFFFELL)
    v13 = (char *)v19 - v11;
  else
    v13 = 0;
  if (v10 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000012)
    v13 = (char *)malloc_type_malloc(8 * v9, 0x46D3CF5AuLL);
  v14 = (double *)&v13[8 * v7];
  if (v7)
  {
    v15 = (double *)v13;
    do
    {
      v16 = *a2++;
      *v15++ = v16;
      --v7;
    }
    while (v7);
  }
  CGFunctionEvaluate(a1, v13, v14);
  for (; v8; --v8)
  {
    v17 = *v14++;
    v18 = v17;
    *a3++ = v18;
  }
  if (v13 != v12)
    free(v13);
}

uint64_t icc_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

CFTypeRef icc_create_icc_profile_ascii_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  CFTypeRef result;
  unint64_t *v11;
  const void *v12;
  uint64_t v13;
  const __CFString *v14;

  v8 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v8 + 20) != 6)
    _CGHandleAssert("icc_create_icc_profile_ascii_description", 194, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased", "Colorspace must be ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 20));
  v9 = *(_QWORD *)(v8 + 88);
  v12 = *(const void **)(v9 + 48);
  v11 = (unint64_t *)(v9 + 48);
  result = v12;
  if (v12)
    return CFRetain(result);
  v13 = *(_QWORD *)(*(_QWORD *)(v8 + 88) + 16);
  if (copy_icc_profile_ascii_description_cglibrarypredicate != -1)
    dispatch_once(&copy_icc_profile_ascii_description_cglibrarypredicate, &__block_literal_global_50);
  v14 = (const __CFString *)copy_icc_profile_ascii_description_f(v13);
  if (!v14)
    v14 = CFSTR("<no description>");
  while (!__ldxr(v11))
  {
    if (!__stxr((unint64_t)v14, v11))
      goto LABEL_11;
  }
  __clrex();
  CFRelease(v14);
LABEL_11:
  result = (CFTypeRef)*v11;
  if (*v11)
    return CFRetain(result);
  return result;
}

uint64_t (*__copy_icc_profile_ascii_description_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyASCIIDescriptionString");
  v1 = colorsync_smart_null_6743;
  if (result)
    v1 = result;
  copy_icc_profile_ascii_description_f = (uint64_t (*)(_QWORD))v1;
  return result;
}

uint64_t colorsync_smart_null_6743()
{
  return 0;
}

char *color_space_state_create_icc_derivative_with_state(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  char v9;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  _QWORD *v22;
  _QWORD *v23;
  _OWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t i;
  uint64_t v33;

  v8 = a3;
  v9 = a2;
  if (a2 && a3)
    _CGHandleAssert("color_space_state_create_icc_derivative_with_state", 365, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "(is_scene_referred_derivative && is_display_referred_derivative) == false", "scene referred %d display referred %d", a6, a7, a8, 1);
  if ((a2 & 1) == 0 && (a3 & 1) == 0)
    _CGHandleAssert("color_space_state_create_icc_derivative_with_state", 367, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "(is_scene_referred_derivative || is_display_referred_derivative) == true", "scene referred %d display referred %d", a6, a7, a8, 0);
  v11 = (char *)malloc_type_calloc(0x70uLL, 1uLL, 0xE48DE6BEuLL);
  v19 = v11;
  if (v11)
  {
    *(_DWORD *)v11 = 1;
    *((_WORD *)v11 + 4) = 0;
    v11[10] = *(_BYTE *)(a1 + 10);
    v11[12] = *(_BYTE *)(a1 + 12);
    v11[11] = 0;
    *(_DWORD *)(v11 + 14) = *(_DWORD *)(a1 + 14);
    v20 = *(_QWORD *)(a1 + 40);
    *((_QWORD *)v19 + 5) = v20;
    *((_QWORD *)v19 + 13) = icc_vtable;
    v21 = *(_DWORD *)(a1 + 28);
    *((_DWORD *)v19 + 5) = 6;
    *((_DWORD *)v19 + 6) = v21;
    *((_DWORD *)v19 + 7) = v21;
    *((_QWORD *)v19 + 9) = 0;
    *((_QWORD *)v19 + 10) = 0;
    *((_QWORD *)v19 + 4) = icc_get_default_color_components(v20, v12, v13, v14, v15, v16, v17, v18);
    v19[18] = v9;
    v19[19] = v8;
    v22 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F20409491EBA0uLL);
    *((_QWORD *)v19 + 11) = v22;
    if (v22)
    {
      v23 = v22;
      *(_DWORD *)v22 = 0;
      v22[1] = CGDataProviderRetain(*(CGDataProviderRef *)(*(_QWORD *)(a1 + 88) + 8));
      v23[2] = CFRetain(*(CFTypeRef *)(*(_QWORD *)(a1 + 88) + 16));
      v23[7] = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 56);
      v24 = malloc_type_malloc(16 * *((_QWORD *)v19 + 5), 0x100004000313F17uLL);
      v23[8] = v24;
      if (v24)
      {
        v19[13] = 1;
        for (i = *(_QWORD *)(a1 + 40); i; --i)
          *v24++ = xmmword_185004A60;
        *(_OWORD *)(v23 + 3) = *(_OWORD *)(*(_QWORD *)(a1 + 88) + 24);
        *((_QWORD *)v19 + 7) = icc_get_md5(v19, v25, v26, v27, v28, v29, v30, v31);
        *((_QWORD *)v19 + 8) = v33;
        return v19;
      }
      free(*((void **)v19 + 11));
    }
    free(v19);
    return 0;
  }
  return v19;
}

uint64_t *__colorspace_with_name_from_icc_data_block_invoke_27()
{
  uint64_t *result;
  uint64_t v1;

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t *)CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle
    && (result = (uint64_t *)dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "kColorSyncITUR2020_sRGBGammaProfile")) != 0)
  {
    v1 = *result;
  }
  else
  {
    v1 = 0;
  }
  colorspace_with_name_from_icc_data_s_169 = v1;
  return result;
}

uint64_t (*__create_colorspace_using_colorspace_state_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileContainsTag");
  v1 = colorsync_smart_null_6743;
  if (result)
    v1 = result;
  create_colorspace_using_colorspace_state_f = (uint64_t (*)(_QWORD, _QWORD))v1;
  return result;
}

uint64_t CGColorSpaceICCGetPlatformProfile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v8 + 20) != 6)
    _CGHandleAssert("CGColorSpaceICCGetPlatformProfile", 700, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased", "Colorspace not ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 20));
  return *(_QWORD *)(*(_QWORD *)(v8 + 88) + 16);
}

CGColorSpaceRef CGColorSpaceCreateFromCICP(__int16 a1)
{
  CFStringRef *v2;

  if ((a1 & 0xF7) != 1 && a1 != 12)
    return 0;
  if (a1 == 12)
  {
    if (HIBYTE(a1) > 0xFu)
    {
      if (HIBYTE(a1) == 16)
      {
        v2 = (CFStringRef *)&kCGColorSpaceDisplayP3_PQ;
        return CGColorSpaceCreateWithName(*v2);
      }
      if (HIBYTE(a1) == 18)
      {
        v2 = (CFStringRef *)&kCGColorSpaceDisplayP3_HLG;
        return CGColorSpaceCreateWithName(*v2);
      }
    }
    else
    {
      if (HIBYTE(a1) == 8)
      {
        v2 = (CFStringRef *)&kCGColorSpaceLinearDisplayP3;
        return CGColorSpaceCreateWithName(*v2);
      }
      if (HIBYTE(a1) == 13)
      {
        v2 = (CFStringRef *)&kCGColorSpaceDisplayP3;
        return CGColorSpaceCreateWithName(*v2);
      }
    }
    return 0;
  }
  if (a1 == 9)
  {
    if ((HIBYTE(a1) - 8) < 0xBu && ((0x5E1u >> (HIBYTE(a1) - 8)) & 1) != 0)
    {
      v2 = (CFStringRef *)off_1E1647308[(HIBYTE(a1) - 8)];
      return CGColorSpaceCreateWithName(*v2);
    }
    return 0;
  }
  if (a1 != 1)
    return 0;
  if (HIBYTE(a1) <= 0xCu)
  {
    if (HIBYTE(a1) == 1)
    {
      v2 = (CFStringRef *)&kCGColorSpaceITUR_709;
      return CGColorSpaceCreateWithName(*v2);
    }
    if (HIBYTE(a1) == 8)
    {
      v2 = (CFStringRef *)&kCGColorSpaceLinearSRGB;
      return CGColorSpaceCreateWithName(*v2);
    }
    return 0;
  }
  if (HIBYTE(a1) == 13)
  {
    v2 = (CFStringRef *)&kCGColorSpaceSRGB;
    return CGColorSpaceCreateWithName(*v2);
  }
  if (HIBYTE(a1) == 16)
  {
    v2 = (CFStringRef *)&kCGColorSpaceITUR_709_PQ;
    return CGColorSpaceCreateWithName(*v2);
  }
  if (HIBYTE(a1) != 18)
    return 0;
  v2 = (CFStringRef *)&kCGColorSpaceITUR_709_HLG;
  return CGColorSpaceCreateWithName(*v2);
}

CGColorSpaceRef CGColorSpaceCreateFromAttachments(CGColorSpaceRef result)
{
  const __CFDictionary *v1;
  CFTypeID v2;
  const __CFData *v3;
  const __CFData *v4;
  CFTypeID v5;
  const UInt8 *BytePtr;
  void *Value;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 != CFDictionaryGetTypeID())
      return 0;
    if (!CFDictionaryContainsKey(v1, CFSTR("kCGColorSpaceAttachment_CICP_data"))
      || (v3 = (const __CFData *)CFDictionaryGetValue(v1, CFSTR("kCGColorSpaceAttachment_CICP_data"))) == 0
      || (v4 = v3, v5 = CFGetTypeID(v3), v5 != CFDataGetTypeID())
      || CFDataGetLength(v4) < 4
      || (BytePtr = CFDataGetBytePtr(v4), (result = CGColorSpaceCreateFromCICP(*(_DWORD *)BytePtr)) == 0))
    {
      if (CFDictionaryContainsKey(v1, CFSTR("kCGColorSpace_Attachment_ICC_Data")))
      {
        Value = (void *)CFDictionaryGetValue(v1, CFSTR("kCGColorSpace_Attachment_ICC_Data"));
        return (CGColorSpaceRef)CGColorSpaceFromICCDataCacheGetRetained(Value);
      }
      return 0;
    }
  }
  return result;
}

BOOL CGColorSpaceGetCICPInfo(_BOOL8 result, _DWORD *a2)
{
  _QWORD *v3;
  CFTypeID v4;
  uint64_t *v5;
  uint64_t v6;
  _DWORD *CICPInfo_f;

  if (!result)
    return result;
  v3 = (_QWORD *)result;
  v4 = CFGetTypeID((CFTypeRef)result);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1)
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_77);
  if (v4 != CGColorSpaceGetTypeID_type_id)
    return 0;
  if (CGColorSpaceGetType(v3) == 6)
  {
    v5 = (uint64_t *)(*(_QWORD *)(v3[3] + 88) + 16);
  }
  else
  {
    if (CGColorSpaceGetType(v3) != 11)
    {
      v6 = 0;
      goto LABEL_12;
    }
    v5 = *(uint64_t **)(v3[3] + 88);
  }
  v6 = *v5;
LABEL_12:
  if (CGColorSpaceGetCICPInfo_cglibrarypredicate != -1)
    dispatch_once(&CGColorSpaceGetCICPInfo_cglibrarypredicate, &__block_literal_global_40_6834);
  CICPInfo_f = (_DWORD *)CGColorSpaceGetCICPInfo_f(v6);
  result = CICPInfo_f != 0;
  if (a2)
  {
    if (CICPInfo_f)
    {
      *a2 = *CICPInfo_f;
      return 1;
    }
  }
  return result;
}

uint64_t CGColorSpaceGetColorSyncProfile(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    v2 = *(_DWORD *)(v1 + 20);
    if (v2 == 11)
    {
      v3 = *(_QWORD *)(v1 + 88);
    }
    else
    {
      if (v2 != 6)
        return 0;
      v3 = *(_QWORD *)(v1 + 88) + 16;
    }
    return *(_QWORD *)v3;
  }
  return result;
}

void pdf_xref_release(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  const void **v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 160);
    if (v2)
    {
      v3 = (_QWORD *)(*(_QWORD *)(a1 + 168) + 32);
      do
      {
        if ((*((_BYTE *)v3 - 20) & 1) != 0 && *((_DWORD *)v3 - 6) == 9)
        {
          v4 = *v3;
          if (*v3)
          {
            if (*(_QWORD *)(v4 + 16) == a1)
              *(_QWORD *)(v4 + 16) = 0;
          }
        }
        v3 += 5;
        --v2;
      }
      while (v2);
    }
    if (*(_BYTE *)(a1 + 176))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
      if (*(_QWORD *)(a1 + 160))
      {
        v5 = 0;
        v6 = 0;
        while (1)
        {
          v7 = *(_QWORD *)(a1 + 168);
          v8 = v7 + v5;
          if ((*(_BYTE *)(v7 + v5 + 12) & 1) != 0)
            break;
LABEL_26:
          ++v6;
          v5 += 40;
          if (v6 >= *(_QWORD *)(a1 + 160))
            goto LABEL_27;
        }
        v9 = *(_DWORD *)(v8 + 8);
        if (v9 == 9)
        {
          v12 = *(_QWORD *)(*(_QWORD *)(v7 + v5 + 32) + 48);
        }
        else
        {
          if (v9 != 8)
          {
            if (v9 == 7)
            {
              v10 = *(_QWORD *)(v7 + v5 + 32);
              if (v10)
              {
                pthread_mutex_lock((pthread_mutex_t *)(v10 + 64));
                v11 = *(const void ***)(v10 + 56);
                if (v11)
                {
                  *(_QWORD *)(v10 + 56) = 0;
                  CGPDFAssociationRelease(v11);
                }
                pthread_mutex_unlock((pthread_mutex_t *)(v10 + 64));
              }
            }
            goto LABEL_24;
          }
          v12 = *(_QWORD *)(v7 + v5 + 32);
        }
        CGPDFDictionaryRemoveAssociation(v12);
LABEL_24:
        if ((*(_DWORD *)(v8 + 8) - 5) <= 4)
          pdf_object_release_compound_value(v8);
        goto LABEL_26;
      }
LABEL_27:
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 96));
    }
    CGPDFSecurityManagerRelease(*(_QWORD *)(a1 + 40));
    CGPDFXRefStreamRelease(*(_QWORD *)(a1 + 8));
    CGPDFXRefTableRelease(*(_QWORD *)(a1 + 16));
    v13 = *(const void **)(a1 + 24);
    if (v13)
      CFRelease(v13);
    v14 = *(_QWORD *)(a1 + 32);
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
    if (*(_QWORD *)a1)
      CFRelease(*(CFTypeRef *)a1);
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96));
    free(*(void **)(a1 + 168));
    free((void *)a1);
  }
}

uint64_t font_registry_smart_null()
{
  return 0;
}

uint64_t xt_copy_all_urls()
{
  if (xt_copy_all_urls_predicate != -1)
    dispatch_once(&xt_copy_all_urls_predicate, &__block_literal_global_3_6993);
  return xt_copy_all_urls_f(7);
}

uint64_t (*__xt_copy_all_urls_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadlibFontRegistryDYLD_once != -1)
    dispatch_once(&CGLibraryLoadlibFontRegistryDYLD_once, &__block_literal_global_10_19715);
  result = (uint64_t (*)())CGLibraryLoadlibFontRegistryDYLD_handle;
  if (CGLibraryLoadlibFontRegistryDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadlibFontRegistryDYLD_handle, "XTCopyAvailableFontURLs");
  v1 = font_registry_smart_null;
  if (result)
    v1 = result;
  xt_copy_all_urls_f = (uint64_t (*)(_QWORD))v1;
  return result;
}

uint64_t indexed_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

size_t CGColorSpaceGetColorTableCount(size_t space)
{
  uint64_t v1;

  if (space)
  {
    v1 = *(_QWORD *)(space + 24);
    if (*(_DWORD *)(v1 + 24) == 5)
      return *(_QWORD *)(*(_QWORD *)(v1 + 88) + 8) + 1;
    else
      return 0;
  }
  return space;
}

void CGColorSpaceGetColorTable(CGColorSpaceRef space, uint8_t *table)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;

  if (space)
  {
    if (table)
    {
      v2 = *((_QWORD *)space + 3);
      if (*(_DWORD *)(v2 + 24) == 5)
      {
        v3 = *(uint64_t **)(v2 + 88);
        v4 = *v3;
        if (*v3)
          v4 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 40);
        v5 = v4 * (v3[1] + 1);
        if (v5)
        {
          for (i = 0; i != v5; ++i)
            table[i] = *(_BYTE *)(v3[2] + i);
        }
      }
    }
  }
}

char *CGClipCreateWithStrokedPath(CFTypeRef cf, uint64_t a2)
{
  _BOOL4 v4;
  CFTypeID v5;
  char *v6;
  char v7;
  char *v8;
  unsigned int v9;
  unsigned int v10;
  CGMutablePathRef MutableCopy;
  unsigned int v12;

  if (!cf)
    return 0;
  if (CGPathDisableTypeValidation)
  {
    v4 = 1;
  }
  else
  {
    v5 = CFGetTypeID(cf);
    v4 = v5 == CGPathGetTypeID();
  }
  v6 = 0;
  if (a2)
  {
    if (v4)
    {
      v7 = *(_BYTE *)(a2 + 67);
      v8 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
      v6 = v8;
      if (v8)
      {
        *(_DWORD *)v8 = 1;
        do
        {
          v9 = __ldxr((unsigned int *)&CGClipCreate_identifier);
          v10 = v9 + 1;
        }
        while (__stxr(v10, (unsigned int *)&CGClipCreate_identifier));
        *((_DWORD *)v8 + 1) = v10;
        *((_WORD *)v8 + 4) = 514;
        *((_QWORD *)v8 + 2) = 0;
        v8[10] = v7;
        *((_QWORD *)v8 + 4) = *(_QWORD *)(a2 + 88);
        MutableCopy = CGPathCreateMutableCopy((CGPathRef)cf);
        *((_QWORD *)v6 + 3) = MutableCopy;
        if (MutableCopy)
        {
          do
            v12 = __ldxr((unsigned int *)a2);
          while (__stxr(v12 + 1, (unsigned int *)a2));
          *((_QWORD *)v6 + 2) = a2;
          return v6;
        }
        CGClipRelease(v6);
        return 0;
      }
    }
  }
  return v6;
}

unsigned int *CGClipCreateWithMask(unsigned int *result, char a2)
{
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  if (result)
  {
    v3 = result;
    result = (unsigned int *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
    if (result)
    {
      *result = 1;
      do
      {
        v4 = __ldxr((unsigned int *)&CGClipCreate_identifier);
        v5 = v4 + 1;
      }
      while (__stxr(v5, (unsigned int *)&CGClipCreate_identifier));
      result[1] = v5;
      *((_WORD *)result + 4) = 3;
      *((_QWORD *)result + 2) = 0;
      *((_BYTE *)result + 10) = a2;
      do
        v6 = __ldxr(v3);
      while (__stxr(v6 + 1, v3));
      *((_QWORD *)result + 3) = v3;
    }
  }
  return result;
}

unsigned int *CGClipCreateWithTextClipping(unsigned int *result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  if (result)
  {
    v1 = result;
    result = (unsigned int *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
    if (result)
    {
      *result = 1;
      do
      {
        v2 = __ldxr((unsigned int *)&CGClipCreate_identifier);
        v3 = v2 + 1;
      }
      while (__stxr(v3, (unsigned int *)&CGClipCreate_identifier));
      result[1] = v3;
      *((_WORD *)result + 4) = 4;
      *((_QWORD *)result + 2) = 0;
      *((_BYTE *)result + 10) = 1;
      do
        v4 = __ldxr(v1);
      while (__stxr(v4 + 1, v1));
      *((_QWORD *)result + 3) = v1;
    }
  }
  return result;
}

unsigned int *CGClipRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

uint64_t CGClipGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t CGClipEqualToClip(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    v5 = *(unsigned __int16 *)(a1 + 8);
    if (v5 != *(unsigned __int16 *)(a2 + 8))
      return 0;
    result = CGClipStrokeEqualToClipStroke(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16));
    if (!(_DWORD)result)
      return result;
    if (*(unsigned __int8 *)(a1 + 10) == *(unsigned __int8 *)(a2 + 10))
    {
      switch((char)v5)
      {
        case 0:
          if (!CGRectEqualToRect(*(CGRect *)(a1 + 24), *(CGRect *)(a2 + 24)))
            return 0;
          goto LABEL_17;
        case 2:
          result = CGPathEqualToPath(*(CGPathRef *)(a1 + 24), *(CGPathRef *)(a2 + 24));
          if ((_DWORD)result)
            goto LABEL_17;
          return result;
        case 3:
          if (!CGClipMaskEqualToClipMask(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24)))
            return 0;
          goto LABEL_17;
        case 4:
          result = CGTextClippingEqualToTextClipping(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24));
          if ((_DWORD)result)
            goto LABEL_17;
          return result;
        default:
LABEL_17:
          result = 1;
          break;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

double CGClipGetFlatness(uint64_t a1)
{
  double result;

  result = 1.0;
  if (*(_BYTE *)(a1 + 8) == 2)
    return *(double *)(a1 + 32);
  return result;
}

CGFloat CGClipGetRect(uint64_t a1)
{
  const CGRect *v1;

  v1 = &CGRectNull;
  if (!*(_BYTE *)(a1 + 8))
    v1 = (const CGRect *)(a1 + 24);
  return v1->origin.x;
}

uint64_t CGClipGetStroke(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 9) << 8 == 512)
    return *(_QWORD *)(a1 + 16);
  else
    return 0;
}

uint64_t CGClipGetTextClipping(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8) == 4)
    return *(_QWORD *)(a1 + 24);
  else
    return 0;
}

uint64_t CGClipGetMask(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8) == 3)
    return *(_QWORD *)(a1 + 24);
  else
    return 0;
}

uint64_t CGClipCreateClipPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  char *StrokedPath;
  CGPathRef Path;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;

  v9 = *(char *)(a1 + 8);
  if (!*(_BYTE *)(a1 + 8))
  {
    Path = CGPathCreateWithRect(*(CGRect *)(a1 + 24), 0);
    goto LABEL_8;
  }
  if (v9 == 4)
  {
    Path = CGTextClippingCreatePath(*(_QWORD *)(a1 + 24));
LABEL_8:
    v20 = (char *)Path;
    v21 = *(_QWORD *)(a1 + 16);
    if (!v21)
      return (uint64_t)v20;
    StrokedPath = (char *)CGClipStrokeCreateStrokedPath(v21, v20, v14, v15, v16, v17, v18, v19);
    if (v20)
      CFRelease(v20);
    return (uint64_t)StrokedPath;
  }
  if (v9 != 2)
    return 0;
  v10 = *(_QWORD *)(a1 + 16);
  StrokedPath = *(char **)(a1 + 24);
  if (v10)
    return CGClipStrokeCreateStrokedPath(v10, StrokedPath, a3, a4, a5, a6, a7, a8);
  if (StrokedPath)
    CFRetain(StrokedPath);
  return (uint64_t)StrokedPath;
}

void op_q_7124(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextSaveGState(a2);
}

void op_Q_7126(uint64_t a1, uint64_t a2)
{
  if ((CGPDFDrawingContextRestoreGState(a2) & 1) == 0)
    pdf_error("gstate stack underflow.");
}

void op_cm_7128(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGFloat v5;
  CGFloat v6;
  CGFloat v7;
  CGFloat v8;
  CGFloat v9;
  double *v10;
  CGContext *v11;
  CGAffineTransform v12;
  CGPDFReal value;
  CGPDFReal v14;
  CGPDFReal v15;
  CGPDFReal v16;
  CGPDFReal v17;
  CGPDFReal v18;

  v18 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16)
    && CGPDFScannerPopNumber(a1, &v17)
    && CGPDFScannerPopNumber(a1, &v18))
  {
    v4 = v18;
    v6 = v16;
    v5 = v17;
    v8 = v14;
    v7 = v15;
    v9 = value;
    v10 = *(double **)(a2 + 32);
    v12.a = v18;
    v12.b = v17;
    v12.c = v16;
    v12.d = v15;
    v12.tx = v14;
    v12.ty = value;
    CGPDFGStateConcatCTM(v10, &v12.a);
    v11 = *(CGContext **)(a2 + 88);
    if (v11)
    {
      v12.a = v4;
      v12.b = v5;
      v12.c = v6;
      v12.d = v7;
      v12.tx = v8;
      v12.ty = v9;
      CGContextConcatCTM(v11, &v12);
    }
  }
}

void op_j_7130(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  CGPDFInteger value;

  value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    if ((unint64_t)value >= 3)
    {
      pdf_error("invalid line join: %ld.", value);
    }
    else
    {
      v3 = *(_QWORD *)(a2 + 32);
      if (v3)
        *(_DWORD *)(v3 + 156) = value;
    }
  }
}

void op_J_7132(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  CGPDFInteger value;

  value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    if ((unint64_t)value >= 3)
    {
      pdf_error("invalid line cap: %ld.", value);
    }
    else
    {
      v3 = *(_QWORD *)(a2 + 32);
      if (v3)
        *(_DWORD *)(v3 + 152) = value;
    }
  }
}

void op_w_7134(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  CGPDFReal value;

  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    if (value >= 0.0)
    {
      v3 = *(_QWORD *)(a2 + 32);
      if (v3)
        *(CGPDFReal *)(v3 + 144) = value;
    }
    else
    {
      pdf_error("invalid line width: %g.", value);
    }
  }
}

void op_d_7136(CGPDFScanner *a1, uint64_t a2)
{
  __n128 v4;
  uint64_t v5;
  CGPDFReal value;

  v5 = 0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopArray(a1, (CGPDFArrayRef *)&v5))
  {
    v4.n128_f64[0] = value;
    set_line_dash(a2, v5, v4);
  }
}

void op_M_7138(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  CGPDFReal value;

  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    if (value >= 1.0)
    {
      v3 = *(_QWORD *)(a2 + 32);
      if (v3)
        *(CGPDFReal *)(v3 + 160) = value;
    }
    else
    {
      pdf_error("invalid miter limit: %g.", value);
    }
  }
}

CGPDFReal op_i_7140(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal result;
  uint64_t v4;
  CGPDFReal value;

  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      result = value;
      *(CGPDFReal *)(v4 + 248) = value;
    }
  }
  return result;
}

void op_g_7142(unint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *ResolvedColorSpace;
  __n128 v8;

  v2 = (uint64_t)a2;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), "DeviceGray");
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_6;
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 1, v8);
  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_G_7144(unint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *ResolvedColorSpace;
  __n128 v8;

  v2 = (uint64_t)a2;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), "DeviceGray");
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_6;
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 0, v8);
  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_k_7146(unint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *ResolvedColorSpace;
  __n128 v8;

  v2 = (uint64_t)a2;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), "DeviceCMYK");
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_6;
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 1, v8);
  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_K_7148(unint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *ResolvedColorSpace;
  __n128 v8;

  v2 = (uint64_t)a2;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), "DeviceCMYK");
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_6;
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 0, v8);
  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_rg_7150(unint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *ResolvedColorSpace;
  __n128 v8;

  v2 = (uint64_t)a2;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), "DeviceRGB");
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_6;
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 1, v8);
  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_RG_7152(unint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *ResolvedColorSpace;
  __n128 v8;

  v2 = (uint64_t)a2;
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), "DeviceRGB");
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_6;
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 0, v8);
  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_cs_7154(CGPDFScanner *a1, uint64_t *a2)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *v7;
  CGColorSpace *ResolvedColorSpace;
  CGColorSpace *v9;
  CGColorSpace *v10;
  char *value;

  value = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value))
    return;
  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      v4 = value;
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), v4);
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_9;
      }
      v7 = ColorSpace;
      goto LABEL_10;
    }
  }
  else
  {
    v3 = 0;
  }
LABEL_9:
  v7 = 0;
LABEL_10:
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v3, v7);
  if (ResolvedColorSpace)
  {
    v9 = ResolvedColorSpace;
    v10 = CGColorSpaceCopyDefaultColor((uint64_t)ResolvedColorSpace);
    CGPDFGStateSetFillColor(a2[4], v10);
    CGColorSpaceRelease(v9);
    if (v10)
      CFRelease(v10);
  }
}

void op_CS_7156(CGPDFScanner *a1, uint64_t *a2)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  CGColorSpace *ColorSpace;
  CGColorSpace *v7;
  CGColorSpace *ResolvedColorSpace;
  CGColorSpace *v9;
  CGColorSpace *v10;
  char *value;

  value = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value))
    return;
  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      v4 = value;
      v5 = *a2;
      while (1)
      {
        ColorSpace = CGPDFResourcesGetColorSpace(*(_QWORD *)(v5 + 32), v4);
        if (ColorSpace)
          break;
        v5 = *(_QWORD *)(v5 + 40);
        if (!v5)
          goto LABEL_9;
      }
      v7 = ColorSpace;
      goto LABEL_10;
    }
  }
  else
  {
    v3 = 0;
  }
LABEL_9:
  v7 = 0;
LABEL_10:
  ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v3, v7);
  if (ResolvedColorSpace)
  {
    v9 = ResolvedColorSpace;
    v10 = CGColorSpaceCopyDefaultColor((uint64_t)ResolvedColorSpace);
    CGPDFGStateSetStrokeColor(a2[4], v10);
    CGColorSpaceRelease(v9);
    if (v10)
      CFRelease(v10);
  }
}

void op_sc_7158(unint64_t a1, uint64_t a2, __n128 a3)
{
  set_color(a1, a2, 0, 1, a3);
}

void op_SC_7160(unint64_t a1, uint64_t a2, __n128 a3)
{
  set_color(a1, a2, 0, 0, a3);
}

void op_scn_7162(CGPDFScanner *a1, uint64_t *a2)
{
  unint64_t FillColor;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  CGColorSpaceRef ColorSpace;

  FillColor = CGPDFGStateGetFillColor(a2[4]);
  if (FillColor)
  {
    if ((FillColor & 0x8000000000000000) != 0)
    {
      ColorSpace = CGTaggedColorGetColorSpace(FillColor, v5, v6, v7, v8, v9, v10, v11);
      if (!ColorSpace)
        goto LABEL_9;
    }
    else
    {
      ColorSpace = *(CGColorSpaceRef *)(FillColor + 24);
      if (!ColorSpace)
        goto LABEL_9;
    }
    if (*(_DWORD *)(*((_QWORD *)ColorSpace + 3) + 24) == 6)
    {
      set_pattern(a1, a2, ColorSpace, 1);
      return;
    }
  }
  else
  {
    ColorSpace = 0;
  }
LABEL_9:
  set_color((unint64_t)a1, (uint64_t)a2, ColorSpace, 1, v12);
}

void op_SCN_7164(CGPDFScanner *a1, uint64_t *a2)
{
  unint64_t StrokeColor;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __n128 v12;
  CGColorSpaceRef ColorSpace;

  StrokeColor = CGPDFGStateGetStrokeColor(a2[4]);
  if (StrokeColor)
  {
    if ((StrokeColor & 0x8000000000000000) != 0)
    {
      ColorSpace = CGTaggedColorGetColorSpace(StrokeColor, v5, v6, v7, v8, v9, v10, v11);
      if (!ColorSpace)
        goto LABEL_9;
    }
    else
    {
      ColorSpace = *(CGColorSpaceRef *)(StrokeColor + 24);
      if (!ColorSpace)
        goto LABEL_9;
    }
    if (*(_DWORD *)(*((_QWORD *)ColorSpace + 3) + 24) == 6)
    {
      set_pattern(a1, a2, ColorSpace, 0);
      return;
    }
  }
  else
  {
    ColorSpace = 0;
  }
LABEL_9:
  set_color((unint64_t)a1, (uint64_t)a2, ColorSpace, 0, v12);
}

void op_ri_7166(CGPDFScanner *a1, uint64_t a2)
{
  char *value;

  value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
    set_rendering_intent(a2, value);
}

void op_m_7168(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGPDFReal value;

  v4 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &value))
  {
    CGContextMoveToPoint(*(CGContextRef *)(a2 + 88), value, v4);
    ++*(_QWORD *)(a2 + 168);
  }
}

void op_l_7170(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGPDFReal value;

  v4 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &value))
  {
    CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), value, v4);
    ++*(_QWORD *)(a2 + 168);
  }
}

void op_c_7172(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat y;
  CGPDFReal value;
  CGPDFReal v6;
  CGPDFReal v7;
  CGPDFReal v8;
  CGPDFReal v9;

  v9 = 0.0;
  v7 = 0.0;
  v8 = 0.0;
  value = 0.0;
  v6 = 0.0;
  y = 0.0;
  if (CGPDFScannerPopNumber(a1, &y)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v8)
    && CGPDFScannerPopNumber(a1, &v9))
  {
    CGContextAddCurveToPoint(*(CGContextRef *)(a2 + 88), v9, v8, v7, v6, value, y);
    *(_QWORD *)(a2 + 168) += 6;
  }
}

void op_v_7174(CGPDFScanner *a1, uint64_t a2)
{
  CGPoint PathCurrentPoint;
  CGFloat v5;
  CGPDFReal value;
  CGPDFReal v7;
  CGPDFReal v8;

  v7 = 0.0;
  v8 = 0.0;
  v5 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v8))
  {
    PathCurrentPoint = CGContextGetPathCurrentPoint((CGContextRef)*(_QWORD *)(a2 + 88));
    CGContextAddCurveToPoint(*(CGContextRef *)(a2 + 88), PathCurrentPoint.x, PathCurrentPoint.y, v8, v7, value, v5);
    *(_QWORD *)(a2 + 168) += 6;
  }
}

void op_y_7176(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGPDFReal value;
  CGPDFReal v6;
  CGPDFReal v7;

  v6 = 0.0;
  v7 = 0.0;
  v4 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7))
  {
    CGContextAddCurveToPoint(*(CGContextRef *)(a2 + 88), v7, v6, value, v4, value, v4);
    *(_QWORD *)(a2 + 168) += 6;
  }
}

void op_h_7178(uint64_t a1, uint64_t a2)
{
  CGContextClosePath(*(CGContextRef *)(a2 + 88));
}

void op_re_7180(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v4;
  CGPDFReal v5;
  CGContext *v6;
  CGPDFReal v7;
  double v8;
  double v9;
  CGPDFReal value;
  CGPDFReal y;
  CGPDFReal x;

  y = 0.0;
  x = 0.0;
  v9 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &y)
    && CGPDFScannerPopNumber(a1, &x))
  {
    v5 = value;
    v4 = y;
    v6 = *(CGContext **)(a2 + 88);
    v7 = x;
    if (value < 0.0 || (v8 = v9, v9 < 0.0))
    {
      CGContextMoveToPoint(v6, x, y);
      CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), x + value, y);
      CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), x + value, y + v9);
      CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), x, y + v9);
      CGContextClosePath(*(CGContextRef *)(a2 + 88));
    }
    else
    {
      CGContextAddRect(v6, *(CGRect *)&v7);
    }
    *(_QWORD *)(a2 + 168) += 4;
  }
}

void op_n_7182(uint64_t a1, uint64_t a2)
{
  const CGPath *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;

  v10 = 0;
  v3 = copy_clip_path(a2, &v10);
  CGContextBeginPath(*(CGContextRef *)(a2 + 88));
  if (v3)
  {
    CGContextAddPath(*(CGContextRef *)(a2 + 88), v3);
    clip(*(_QWORD *)(a2 + 88), v10, v4, v5, v6, v7, v8, v9);
    CFRelease(v3);
  }
}

void op_S_7184(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 2u, 0);
}

void op_s_7186(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 2u, 1);
}

void op_f_7188(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 0, 0);
}

void op_fstar_7191(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 1u, 0);
}

void op_B_7193(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 3u, 0);
}

void op_b_7195(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 3u, 1);
}

void op_Bstar_7197(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 4u, 0);
}

void op_bstar_7199(uint64_t a1, uint64_t a2)
{
  CGPDFDrawingContextDrawPath(a2, 4u, 1);
}

void op_W_7201(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 32);
  if (v2)
    *(_WORD *)(v2 + 48) = 1;
}

void op_Wstar_7203(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 32);
  if (v2)
    *(_WORD *)(v2 + 48) = 256;
}

BOOL op_Tc_7205(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  CGPDFReal *v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 72) = value;
      v6 = *(CGPDFReal **)(v4 + 272);
      if (v6)
        *v6 = v5;
    }
  }
  return result;
}

BOOL op_Tw_7207(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 80) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 8) = v5;
    }
  }
  return result;
}

BOOL op_Tz_7209(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 88) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 16) = v5;
    }
  }
  return result;
}

BOOL op_TL_7211(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 96) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 24) = v5;
    }
  }
  return result;
}

void op_Tf_7213(CGPDFScanner *a1, uint64_t *a2)
{
  uint64_t v4;
  const void *Font;
  uint64_t v6;
  CGPDFReal v7;
  uint64_t v8;
  char *v9;
  CGPDFReal value;

  v9 = 0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopName(a1, (const char **)&v9))
  {
    if (a2)
      v4 = *a2;
    else
      v4 = 0;
    Font = CGPDFContentStreamGetFont(v4, v9);
    if (Font)
    {
      CGPDFGStateSetFont(a2[4], Font);
      v6 = a2[4];
      if (v6)
      {
        v7 = value;
        *(CGPDFReal *)(v6 + 128) = value;
        v8 = *(_QWORD *)(v6 + 272);
        if (v8)
          *(CGPDFReal *)(v8 + 56) = v7;
      }
    }
    else
    {
    }
  }
}

void op_Tr_7215(CGPDFScanner *a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  CGPDFInteger value;

  value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    v3 = 0;
    switch(value)
    {
      case 0:
        goto LABEL_13;
      case 1:
        v3 = 1;
        goto LABEL_13;
      case 2:
        v3 = 2;
        goto LABEL_13;
      case 3:
        if (*(_BYTE *)(a2 + 176))
          v3 = 0;
        else
          v3 = 3;
        goto LABEL_13;
      case 4:
        v3 = 4;
        goto LABEL_13;
      case 5:
        v3 = 5;
        goto LABEL_13;
      case 6:
        v3 = 6;
        goto LABEL_13;
      case 7:
        v3 = 7;
LABEL_13:
        v4 = *(_QWORD *)(a2 + 32);
        if (v4)
        {
          *(_DWORD *)(v4 + 112) = v3;
          v5 = *(_QWORD *)(v4 + 272);
          if (v5)
            CGPDFTextObjectSetTextDrawingMode(v5, v3);
        }
        break;
      default:
        pdf_error("invalid text drawing mode: %ld.", value);
        break;
    }
  }
}

BOOL op_Ts_7217(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFReal v5;
  uint64_t v6;
  CGPDFReal value;

  value = 0.0;
  result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
    {
      v5 = value;
      *(CGPDFReal *)(v4 + 104) = value;
      v6 = *(_QWORD *)(v4 + 272);
      if (v6)
        *(CGPDFReal *)(v6 + 32) = v5;
    }
  }
  return result;
}

CGFloat op_BT_7219(uint64_t a1, uint64_t a2)
{
  CGFloat result;
  char *TextObject;

  if (*(_BYTE *)(a2 + 80))
  {
    pdf_error("warning: already in a text object.");
  }
  else
  {
    *(_BYTE *)(a2 + 80) = 1;
    TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
    result = CGAffineTransformIdentity.a;
    *(CGAffineTransform *)(TextObject + 72) = CGAffineTransformIdentity;
    *(CGAffineTransform *)(TextObject + 120) = CGAffineTransformIdentity;
  }
  return result;
}

void op_ET_7221(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  unsigned int *v4;
  __n128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_BYTE *)(a2 + 80))
  {
    v3 = (_QWORD *)*((_QWORD *)CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32)) + 22);
    if (v3)
    {
      v4 = (unsigned int *)malloc_type_malloc(0x18uLL, 0x2062DE7BuLL);
      *v4 = 1;
      *((_QWORD *)v4 + 1) = 0;
      *((_QWORD *)v4 + 2) = 0;
      CGPDFTextLayoutDrawGlyphs(v3, (void (*)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, char *, char *, _QWORD, uint64_t))clip_to_glyphs_20177, (uint64_t)v4, v5);
      CGPDFGStateSynchronizeContextForText(*(_QWORD *)(a2 + 32), *(CGContextRef *)(a2 + 88));
      CGContextClipToTextClipping(*(_QWORD *)(a2 + 88), (uint64_t)v4, v6, v7, v8, v9, v10, v11);
      CGTextClippingRelease(v4);
    }
    *(_BYTE *)(a2 + 80) = 0;
  }
  else
  {
  }
}

void op_Td_7223(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  double v5;
  CGPDFReal value;

  v5 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v5);
    }
    else
    {
    }
  }
}

void op_TD_7225(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  double v5;
  uint64_t v6;
  char *TextObject;
  double v8;
  CGPDFReal value;

  v8 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v8) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      v4 = *(_QWORD *)(a2 + 32);
      if (v4)
      {
        v5 = -v8;
        *(double *)(v4 + 96) = -v8;
        v6 = *(_QWORD *)(v4 + 272);
        if (v6)
          *(double *)(v6 + 24) = v5;
      }
      TextObject = CGPDFGStateGetTextObject(v4);
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v8);
    }
    else
    {
    }
  }
}

void op_Tm_7227(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  CGPDFReal v5;
  CGPDFReal v6;
  CGPDFReal v7;
  CGPDFReal v8;
  CGPDFReal v9;
  char *TextObject;
  uint64_t v11;
  CGPDFReal value;
  CGPDFReal v13;
  CGPDFReal v14;
  CGPDFReal v15;
  CGPDFReal v16;

  v15 = 0.0;
  v16 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v11 = 0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v11)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v13)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      v4 = v11;
      v5 = value;
      v6 = v13;
      v7 = v14;
      v8 = v15;
      v9 = v16;
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
      *((CGPDFReal *)TextObject + 9) = v9;
      *((CGPDFReal *)TextObject + 10) = v8;
      *((CGPDFReal *)TextObject + 11) = v7;
      *((CGPDFReal *)TextObject + 12) = v6;
      *((CGPDFReal *)TextObject + 13) = v5;
      *((_QWORD *)TextObject + 14) = v4;
      *((CGPDFReal *)TextObject + 15) = v9;
      *((CGPDFReal *)TextObject + 16) = v8;
      *((CGPDFReal *)TextObject + 17) = v7;
      *((CGPDFReal *)TextObject + 18) = v6;
      *((CGPDFReal *)TextObject + 19) = v5;
      *((_QWORD *)TextObject + 20) = v4;
    }
    else
    {
    }
  }
}

double op_Tstar_7229(uint64_t a1, uint64_t a2)
{
  char *TextObject;
  uint64_t v4;
  double v5;
  double result;

  if (*(_BYTE *)(a2 + 80))
  {
    TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
    v4 = *(_QWORD *)(a2 + 32);
    if (v4)
      v5 = *(double *)(v4 + 96);
    else
      v5 = 0.0;
    *(_QWORD *)&result = CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v5).n128_u64[0];
  }
  else
  {
  }
  return result;
}

void op_Tj_7231(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  CGPDFStringRef value;

  value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
      CGPDFTextObjectAppendString((uint64_t)TextObject, (uint64_t)value);
      CGPDFDrawingContextDrawText((_QWORD *)a2, (uint64_t)TextObject);
    }
    else
    {
    }
  }
}

void op_singlequote(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  uint64_t v4;
  uint64_t v5;
  double v6;
  CGPDFStringRef value;

  value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
      v4 = (uint64_t)TextObject;
      v5 = *(_QWORD *)(a2 + 32);
      if (v5)
        v6 = *(double *)(v5 + 96);
      else
        v6 = 0.0;
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v6);
      CGPDFTextObjectAppendString(v4, (uint64_t)value);
      CGPDFDrawingContextDrawText((_QWORD *)a2, v4);
    }
    else
    {
    }
  }
}

void op_doublequote(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  CGPDFReal v5;
  CGPDFReal *v6;
  CGPDFReal v7;
  char *TextObject;
  uint64_t v9;
  uint64_t v10;
  double v11;
  CGPDFReal v12;
  CGPDFReal v13;
  CGPDFStringRef value;

  v13 = 0.0;
  value = 0;
  v12 = 0.0;
  if (CGPDFScannerPopString(a1, &value) && CGPDFScannerPopNumber(a1, &v13) && CGPDFScannerPopNumber(a1, &v12))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      v4 = *(_QWORD *)(a2 + 32);
      if (v4)
      {
        v5 = v13;
        *(CGPDFReal *)(v4 + 72) = v13;
        v6 = *(CGPDFReal **)(v4 + 272);
        if (v6)
        {
          *v6 = v5;
          v7 = v12;
          *(CGPDFReal *)(v4 + 80) = v12;
          v6[1] = v7;
        }
        else
        {
          *(CGPDFReal *)(v4 + 80) = v12;
        }
      }
      TextObject = CGPDFGStateGetTextObject(v4);
      v9 = (uint64_t)TextObject;
      v10 = *(_QWORD *)(a2 + 32);
      if (v10)
        v11 = *(double *)(v10 + 96);
      else
        v11 = 0.0;
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v11);
      CGPDFTextObjectAppendString(v9, (uint64_t)value);
      CGPDFDrawingContextDrawText((_QWORD *)a2, v9);
    }
    else
    {
    }
  }
}

void op_TJ_7235(CGPDFScanner *a1, uint64_t a2)
{
  char *TextObject;
  uint64_t v4;
  CGPDFArrayRef value;

  value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      if (value)
      {
        TextObject = CGPDFGStateGetTextObject(*(_QWORD *)(a2 + 32));
        if (TextObject)
        {
          v4 = (uint64_t)TextObject;
          CGPDFTextObjectAppendStrings((uint64_t)TextObject, value);
          CGPDFDrawingContextDrawText((_QWORD *)a2, v4);
        }
      }
      else
      {
      }
    }
    else
    {
    }
  }
}

void op_Do_7237(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL4 v3;
  uint64_t v4;
  const char *v5;
  _DWORD *v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  CGPDFDictionary *v10;
  int v11;
  int v12;
  _BOOL4 Object;
  int v14;
  CGPDFArray *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  CGImage *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CGContext *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __CFDictionary *Mutable;
  _QWORD *v37;
  CGColorSpace *ResolvedColorSpace;
  CGColorSpace *v39;
  CGContext *v40;
  __int128 v41;
  CGPDFStream *v42;
  CGPDFDictionary *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  char *v52;
  CGFloat a;
  CGFloat b;
  __int128 v55;
  CGPDFScanner *v56;
  uint64_t v57;
  CGContext *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t GStateMark;
  const CGAffineTransform *v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  CGPDFStream *v81;
  CGPDFDictionary *v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  const char *v102;
  CGPDFObjectRef v103;
  CGAffineTransform v104;
  CGAffineTransform __s1;
  CGAffineTransform value;
  CGRect v107;

  v102 = 0;
  v3 = CGPDFScannerPopName(a1, &v102);
  if (!a2)
    return;
  if (!v3)
    return;
  v4 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    return;
  v5 = v102;
  while (1)
  {
    v6 = CGPDFResourcesCopyXObject(*(_QWORD *)(v4 + 32), v5);
    if (v6)
      break;
    v4 = *(_QWORD *)(v4 + 40);
    if (!v4)
      return;
  }
  v7 = v6;
  v8 = v6[26];
  if (!v8)
  {
    value.a = 0.0;
    v9 = *((_QWORD *)v6 + 3);
    if (v9)
      v10 = *(CGPDFDictionary **)(v9 + 48);
    else
      v10 = 0;
    if (!CGPDFDictionaryGetDictionary(v10, "OC", (CGPDFDictionaryRef *)&value))
    {
      v8 = 1;
      v7[26] = 1;
      goto LABEL_38;
    }
    if (*(_BYTE *)(a2 + 112))
      v11 = 1;
    else
      v11 = 2;
    v7[26] = v11;
    __s1.a = 0.0;
    if (!CGPDFDictionaryGetName(*(CGPDFDictionaryRef *)&value.a, "Type", (const char **)&__s1))
      goto LABEL_37;
    if (strcmp(*(const char **)&__s1.a, "OCMD"))
      goto LABEL_37;
    v104.a = 0.0;
    if (!CGPDFDictionaryGetObject(*(CGPDFDictionaryRef *)&value.a, "OCGs", (CGPDFObjectRef *)&v104)
      || !*(_QWORD *)&v104.a)
    {
      goto LABEL_37;
    }
    v12 = *(_DWORD *)(*(_QWORD *)&v104.a + 8);
    if (v12 == 7)
    {
      v15 = *(CGPDFArray **)(*(_QWORD *)&v104.a + 32);
      if (!v15 || (v16 = *((_QWORD *)v15 + 2)) == 0)
      {
        v14 = 2;
LABEL_36:
        v7[26] = v14;
        goto LABEL_37;
      }
      v17 = 1;
      do
      {
        v103 = 0;
        Object = CGPDFArrayGetObject(v15, v17 - 1, &v103);
        if (Object)
          Object = CGPDFDrawingContextShouldDrawOCG(a2, *((_QWORD *)v103 + 2), *((_QWORD *)v103 + 3));
        if (v17 >= v16)
          break;
        ++v17;
      }
      while (!Object);
    }
    else
    {
      if (v12 != 8)
      {
LABEL_37:
        v8 = v7[26];
        goto LABEL_38;
      }
      Object = CGPDFDrawingContextShouldDrawOCG(a2, *(_QWORD *)(*(_QWORD *)&v104.a + 16), *(_QWORD *)(*(_QWORD *)&v104.a + 24));
    }
    if (Object)
      v14 = 1;
    else
      v14 = 2;
    goto LABEL_36;
  }
LABEL_38:
  if (v8 == 1)
  {
    v18 = v7[4];
    if (v18 == 2)
    {
      v26 = CGPDFXObjectGetValue((uint64_t)v7);
      if (v26)
      {
        v27 = v26;
        if (*(_BYTE *)(v26 + 105))
          pdf_log("knockout groups aren't supported.");
        if (!*(_BYTE *)(v27 + 104))
          pdf_log("non-isolated groups aren't supported.");
        v28 = *(_QWORD *)(a2 + 32);
        if (v28)
        {
          v29 = *(CGContext **)(a2 + 88);
          if (v29)
          {
            CGContextSetAlpha(*(CGContextRef *)(a2 + 88), *(CGFloat *)(v28 + 200));
            CGPDFGStateSynchronizeColorRendering(v28, v29);
            CGPDFGStateSynchronizeRendering(v28, (uint64_t)v29, v30, v31, v32, v33, v34, v35);
          }
        }
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v37 = *(_QWORD **)(v27 + 96);
        if (v37 || (v37 = *(_QWORD **)(a2 + 16)) != 0)
        {
          ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(*(_QWORD *)a2, v37);
          v39 = ResolvedColorSpace;
          if (Mutable && ResolvedColorSpace)
            CFDictionarySetValue(Mutable, CFSTR("kCGContextColorSpace"), ResolvedColorSpace);
          CGColorSpaceRelease(v39);
        }
        CGCFDictionarySetRect(Mutable, CFSTR("kCGContextBoundingBox"), *(double *)(v27 + 8), *(double *)(v27 + 16), *(double *)(v27 + 24), *(double *)(v27 + 32));
        v40 = *(CGContext **)(a2 + 88);
        CGContextSaveGState(v40);
        v41 = *(_OWORD *)(v27 + 56);
        *(_OWORD *)&value.a = *(_OWORD *)(v27 + 40);
        *(_OWORD *)&value.c = v41;
        *(_OWORD *)&value.tx = *(_OWORD *)(v27 + 72);
        CGContextConcatCTM(v40, &value);
        v42 = *(CGPDFStream **)v27;
        v43 = *(CGPDFDictionary **)(v27 + 88);
        if (!CGContextIsEmptyClipBoundingBox((uint64_t)v40, v44, v45, v46, v47, v48, v49, v50))
        {
          v51 = CGPDFDrawingContextCreateWithStream(v42, v43, (CGPDFContentStreamRef *)a2);
          if (v51)
          {
            v52 = v51;
            *(CGPoint *)&value.a = CGRectNull.origin;
            *(CGSize *)&value.c = CGRectNull.size;
            if (Mutable)
            {
              if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1)
                dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_77);
              CGCFDictionaryGetCFTypeRef(Mutable, CFSTR("kCGContextColorSpace"), CGColorSpaceGetTypeID_type_id, (uint64_t *)v52 + 2);
              CGCFDictionaryGetRect(Mutable, CFSTR("kCGContextBoundingBox"), (UInt8 *)&value);
            }
            set_initial_group_gstate(*((_QWORD *)v52 + 4));
            set_initial_group_gstate(*((_QWORD *)v52 + 3));
            CGContextBeginTransparencyLayer(v40, Mutable);
            a = value.a;
            if (value.a != INFINITY)
            {
              b = value.b;
              if (value.b != INFINITY)
              {
                v55 = *(_OWORD *)&value.c;
                CGContextClipToRect(v40, *(CGRect *)&a);
              }
            }
            *((_QWORD *)v52 + 11) = v40;
            if (CGPDFDrawingContextGetOperatorTable_predicate != -1)
              dispatch_once(&CGPDFDrawingContextGetOperatorTable_predicate, &__block_literal_global_7120);
            v56 = CGPDFScannerCreate(*(CGPDFContentStreamRef *)v52, (CGPDFOperatorTableRef)CGPDFDrawingContextGetOperatorTable_operator_table, v52);
            CGPDFScannerScan(v56);
            if (v56)
              CFRelease(v56);
            CGContextEndTransparencyLayer(v40);
            CGPDFDrawingContextRelease(v52);
          }
        }
        if (Mutable)
          CFRelease(Mutable);
        CGContextRestoreGState(v40);
      }
    }
    else if (v18 == 1)
    {
      v57 = CGPDFXObjectGetValue((uint64_t)v7);
      v58 = *(CGContext **)(a2 + 88);
      CGContextGetBaseCTM((uint64_t)v58, v59, v60, v61, v62, v63, v64, (uint64_t)&value);
      GStateMark = CGContextGetGStateMark((uint64_t)v58, v65, v66, v67, v68, v69, v70, v71);
      v73 = (const CGAffineTransform *)(v57 + 56);
      if (!v57)
        v73 = &CGAffineTransformIdentity;
      v74 = *(_OWORD *)&v73->c;
      *(_OWORD *)&__s1.a = *(_OWORD *)&v73->a;
      *(_OWORD *)&__s1.c = v74;
      *(_OWORD *)&__s1.tx = *(_OWORD *)&v73->tx;
      CGContextConcatCTM(v58, &__s1);
      CGContextGetCTM(&__s1, v58);
      CGContextSetBaseCTM((uint64_t)v58, (__int128 *)&__s1, v75, v76, v77, v78, v79, v80);
      if (v57)
      {
        CGContextClipToRect(v58, *(CGRect *)(v57 + 24));
        v81 = *(CGPDFStream **)(v57 + 16);
        v82 = *(CGPDFDictionary **)(v57 + 104);
      }
      else
      {
        v107.origin.x = INFINITY;
        v107.size.width = 0.0;
        v107.size.height = 0.0;
        v107.origin.y = INFINITY;
        CGContextClipToRect(v58, v107);
        v81 = 0;
        v82 = 0;
      }
      v83 = CGPDFDrawingContextCreateWithStream(v81, v82, (CGPDFContentStreamRef *)a2);
      CGPDFDrawingContextDraw((uint64_t)v83, (uint64_t)v58, v84, v85, v86, v87, v88, v89);
      CGPDFDrawingContextRelease(v83);
      CGContextRestoreToGStateMark((uint64_t)v58, GStateMark, v90, v91, v92, v93, v94, v95);
      v104 = value;
      CGContextSetBaseCTM((uint64_t)v58, (__int128 *)&v104, v96, v97, v98, v99, v100, v101);
    }
    else if (v18)
    {
      pdf_error("unrecognized or unsupported XObject subtype.");
    }
    else
    {
      v19 = (CGImage *)CGPDFXObjectGetValue((uint64_t)v7);
      CGPDFDrawingContextDrawImage(a2, v19, v20, v21, v22, v23, v24, v25);
    }
    CFRelease(v7);
  }
}

void op_sh_7239(CGPDFScanner *a1, uint64_t *a2)
{
  _BOOL4 v3;
  uint64_t v4;
  char *v5;
  const void *Shading;
  uint64_t v7;
  CGShading *v8;
  char *value;

  value = 0;
  v3 = CGPDFScannerPopName(a1, (const char **)&value);
  if (a2)
  {
    if (v3)
    {
      v4 = *a2;
      if (*a2)
      {
        v5 = value;
        while (1)
        {
          Shading = CGPDFResourcesGetShading(*(_QWORD *)(v4 + 32), v5);
          if (Shading)
            break;
          v4 = *(_QWORD *)(v4 + 40);
          if (!v4)
            return;
        }
        v7 = CGPDFShadingGetShading((uint64_t)Shading);
        if (v7)
        {
          v8 = (CGShading *)v7;
          CGPDFGStateSynchronizeForImages(a2[4], (CGContextRef)a2[11]);
          CGContextDrawShading((CGContextRef)a2[11], v8);
        }
      }
    }
  }
}

void op_EI_7241(uint64_t *a1, uint64_t a2)
{
  CGImage *Inline;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CGImage *v11;
  CGPDFStreamRef value;

  value = 0;
  if (CGPDFScannerPopStream((CGPDFScannerRef)a1, &value))
  {
    Inline = (CGImage *)CGPDFImageCreateInline(a1[7], (uint64_t)value);
    if (Inline)
    {
      v11 = Inline;
      CGPDFDrawingContextDrawImage(a2, Inline, v5, v6, v7, v8, v9, v10);
      CFRelease(v11);
    }
  }
}

void op_d1_7243(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CGColor *FillColorAsColor;
  uint64_t v12;
  CGPDFReal value;
  CGPDFReal v14;
  CGPDFReal v15;
  CGPDFReal v16;
  CGPDFReal v17;

  v17 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  value = 0.0;
  v14 = 0.0;
  v12 = 0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v12)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16)
    && CGPDFScannerPopNumber(a1, &v17))
  {
    FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor(*(_QWORD *)(a2 + 88), v4, v5, v6, v7, v8, v9, v10);
    CGContextSetStrokeColorWithColor(*(CGContextRef *)(a2 + 88), FillColorAsColor);
  }
}

void op_gs_7245(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  CGPDFDictionary *ExtGState;
  CGPDFDictionary *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  CGPDFArray *v15;
  const void *v16;
  uint64_t v17;
  CGPDFReal v18;
  uint64_t v19;
  CGPDFObjectRef v20;
  uint64_t v21;
  int v22;
  CGPDFObjectRef v23;
  uint64_t v24;
  int v25;
  CGPDFObjectRef v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  CGPDFDictionary *v35;
  const void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double *v44;
  const void *v45;
  double v46;
  double v47;
  double v48;
  double v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t cftype;
  uint64_t v54;
  CGPDFReal v55;
  uint64_t v56;
  const void *v57;
  int v58;
  int v59;
  CGColorRef ResolvedColor;
  const void **v61;
  void *v62;
  uint64_t v63;
  const void *v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  const CGAffineTransform *v79;
  double b;
  double c;
  double d;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  CGColorSpace *v93;
  CGPDFArray *v94;
  CGFloat *v95;
  CGFloat *v96;
  CGColorRef v97;
  char *Function;
  uint64_t v99;
  CGFloat v100;
  double v101;
  CGPDFObjectRef v102;
  CGPDFArrayRef array;
  char *value;
  CGPDFInteger v105;
  CGPDFBoolean v106;
  CGPDFReal v107;
  CGPDFStreamRef v108;
  CGPDFDictionaryRef v109[6];
  CGPDFReal v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  CGRect v116;
  CGRect v117;

  v107 = 0.0;
  v106 = 0;
  value = 0;
  v105 = 0;
  v102 = 0;
  array = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value))
    return;
  v3 = a2 ? *(_QWORD *)a2 : 0;
  ExtGState = (CGPDFDictionary *)CGPDFContentStreamGetExtGState(v3, value);
  if (!ExtGState)
    return;
  v5 = ExtGState;
  if (CGPDFDictionaryGetNumber(ExtGState, "LW", &v107))
  {
    if (v107 >= 0.0)
    {
      v6 = *(_QWORD *)(a2 + 32);
      if (v6)
        *(CGPDFReal *)(v6 + 144) = v107;
    }
    else
    {
      pdf_error("invalid line width: %g.", v107);
    }
  }
  if (CGPDFDictionaryGetInteger(v5, "LC", &v105))
  {
    if ((unint64_t)v105 >= 3)
    {
      pdf_error("invalid line cap: %ld.", v105);
    }
    else
    {
      v7 = *(_QWORD *)(a2 + 32);
      if (v7)
        *(_DWORD *)(v7 + 152) = v105;
    }
  }
  if (CGPDFDictionaryGetInteger(v5, "LJ", &v105))
  {
    if ((unint64_t)v105 >= 3)
    {
      pdf_error("invalid line join: %ld.", v105);
    }
    else
    {
      v8 = *(_QWORD *)(a2 + 32);
      if (v8)
        *(_DWORD *)(v8 + 156) = v105;
    }
  }
  if (CGPDFDictionaryGetNumber(v5, "ML", &v107))
  {
    if (v107 >= 1.0)
    {
      v9 = *(_QWORD *)(a2 + 32);
      if (v9)
        *(CGPDFReal *)(v9 + 160) = v107;
    }
    else
    {
      pdf_error("invalid miter limit: %g.", v107);
    }
  }
  if (CGPDFDictionaryGetArray(v5, "D", &array)
    && CGPDFArrayGetNumber(array, 0, &v107)
    && CGPDFArrayGetArray(array, 1uLL, &array))
  {
    v10.n128_f64[0] = v107;
    set_line_dash(a2, (uint64_t)array, v10);
  }
  if (CGPDFDictionaryGetName(v5, "RI", (const char **)&value))
    set_rendering_intent(a2, value);
  if (CGPDFDictionaryGetBoolean(v5, "OP", &v106))
  {
    v11 = *(_QWORD *)(a2 + 32);
    if (v11)
    {
      v12 = v106 != 0;
      *(_BYTE *)(v11 + 218) = v106 != 0;
      *(_BYTE *)(v11 + 217) = v12;
    }
  }
  if (CGPDFDictionaryGetBoolean(v5, "op", &v106))
  {
    v13 = *(_QWORD *)(a2 + 32);
    if (v13)
      *(_BYTE *)(v13 + 217) = v106 != 0;
  }
  if (CGPDFDictionaryGetInteger(v5, "OPM", &v105))
  {
    v14 = *(_QWORD *)(a2 + 32);
    if (v14)
      *(_DWORD *)(v14 + 220) = v105;
  }
  if (CGPDFDictionaryGetArray(v5, "Font", &array))
  {
    v15 = array;
    v110 = 0.0;
    v109[0] = 0;
    if (CGPDFArrayGetDictionary(array, 0, v109) && CGPDFArrayGetNumber(v15, 1uLL, &v110))
    {
      v16 = (const void *)CGPDFFontCreate(v109[0]);
      CGPDFGStateSetFont(*(_QWORD *)(a2 + 32), v16);
      if (v16)
        CFRelease(v16);
      v17 = *(_QWORD *)(a2 + 32);
      if (v17)
      {
        v18 = v110;
        *(CGPDFReal *)(v17 + 128) = v110;
        v19 = *(_QWORD *)(v17 + 272);
        if (v19)
          *(CGPDFReal *)(v19 + 56) = v18;
      }
    }
  }
  if (CGPDFDictionaryGetObject(v5, "BG2", &v102))
  {
    v20 = v102;
    v21 = a2;
    v22 = 1;
  }
  else
  {
    if (!CGPDFDictionaryGetObject(v5, "BG", &v102))
      goto LABEL_54;
    v20 = v102;
    v21 = a2;
    v22 = 0;
  }
  set_black_generation(v21, (uint64_t)v20, v22);
LABEL_54:
  if (CGPDFDictionaryGetObject(v5, "UCR2", &v102))
  {
    v23 = v102;
    v24 = a2;
    v25 = 1;
  }
  else
  {
    if (!CGPDFDictionaryGetObject(v5, "UCR", &v102))
      goto LABEL_59;
    v23 = v102;
    v24 = a2;
    v25 = 0;
  }
  set_undercolor_removal(v24, (uint64_t)v23, v25);
LABEL_59:
  if (CGPDFDictionaryGetObject(v5, "TR2", &v102))
  {
    v26 = v102;
    v27 = a2;
    v28 = 1;
  }
  else
  {
    if (!CGPDFDictionaryGetObject(v5, "TR", &v102))
      goto LABEL_64;
    v26 = v102;
    v27 = a2;
    v28 = 0;
  }
  set_transfer(v27, (uint64_t)v26, v28);
LABEL_64:
  CGPDFDictionaryGetObject(v5, "HT", &v102);
  if (CGPDFDictionaryGetNumber(v5, "FL", &v107))
  {
    v29 = *(_QWORD *)(a2 + 32);
    if (v29)
      *(CGPDFReal *)(v29 + 248) = v107;
  }
  if (CGPDFDictionaryGetNumber(v5, "SM", &v107))
  {
    v30 = *(_QWORD *)(a2 + 32);
    if (v30)
      *(CGPDFReal *)(v30 + 256) = v107;
  }
  if (CGPDFDictionaryGetBoolean(v5, "SA", &v106))
  {
    v31 = *(_QWORD *)(a2 + 32);
    if (v31)
      *(_BYTE *)(v31 + 180) = v106 != 0;
  }
  if (CGPDFDictionaryGetObject(v5, "BM", &v102))
  {
    v32 = *(_QWORD *)(a2 + 32);
    if (v32)
    {
      v33 = CGPDFBlendModeFromCGPDFObject((uint64_t)v102);
      if (v33 != -1)
        *(_DWORD *)(v32 + 184) = v33;
    }
  }
  if (!CGPDFDictionaryGetObject(v5, "SMask", &v102))
    goto LABEL_91;
  if (v102)
  {
    v34 = *((_DWORD *)v102 + 2);
    if (v34 == 5)
    {
      if (!strcmp(*((const char **)v102 + 4), "None"))
      {
        v56 = *(_QWORD *)(a2 + 32);
        if (v56)
        {
          v57 = *(const void **)(v56 + 192);
          if (v57)
          {
            CFRelease(v57);
            *(_QWORD *)(v56 + 192) = 0;
          }
        }
      }
      else
      {
      }
      goto LABEL_91;
    }
    if (v34 == 8)
    {
      v35 = (CGPDFDictionary *)*((_QWORD *)v102 + 4);
      v36 = CGPDFDictionaryCopyAssociation((uint64_t)v35, "SoftMask");
      if (v36)
      {
        v43 = (uint64_t)v36;
        goto LABEL_83;
      }
      if (CGPDFSoftMaskGetTypeID_onceToken != -1)
        dispatch_once(&CGPDFSoftMaskGetTypeID_onceToken, &__block_literal_global_3401);
      cftype = pdf_create_cftype();
      if (!cftype)
        goto LABEL_168;
      v54 = cftype;
      v110 = 0.0;
      v108 = 0;
      v109[0] = 0;
      *(_QWORD *)(cftype + 16) = v35;
      if (!CGPDFDictionaryGetName(v35, "S", (const char **)&v110))
      {
        goto LABEL_167;
      }
      v55 = v110;
      if (!strcmp(*(const char **)&v110, "Alpha"))
      {
        v58 = 0;
      }
      else
      {
        if (strcmp(*(const char **)&v55, "Luminosity"))
        {
LABEL_167:
          CFRelease((CFTypeRef)v54);
LABEL_168:
          CGPDFGStateSetSoftMask(*(_QWORD *)(a2 + 32), 0);
          goto LABEL_91;
        }
        v58 = 1;
      }
      *(_DWORD *)(v54 + 24) = v58;
      if (!CGPDFDictionaryGetStream(v35, "G", &v108))
      {
        goto LABEL_167;
      }
      v92 = CGPDFGroupCreate(v108);
      *(_QWORD *)(v54 + 32) = v92;
      if (v92)
      {
        if (*(_DWORD *)(v54 + 24) != 1)
          goto LABEL_157;
        v93 = (CGColorSpace *)*((_QWORD *)v92 + 12);
        if (v93)
        {
          v94 = *(CGPDFArray **)(*((_QWORD *)v93 + 3) + 40);
          v95 = (CGFloat *)malloc_type_calloc(1uLL, 8 * (_QWORD)v94 + 8, 0x100004000313F17uLL);
          if (!v95)
            goto LABEL_167;
          v96 = v95;
          if (CGPDFDictionaryGetNumbers(v35, "BC", (uint64_t)v95, v94))
          {
            v96[(_QWORD)v94] = 1.0;
            v97 = CGColorCreate(v93, v96);
          }
          else
          {
            v97 = CGColorSpaceCopyDefaultColor((uint64_t)v93);
          }
          *(_QWORD *)(v54 + 40) = v97;
          free(v96);
LABEL_157:
          if (CGPDFDictionaryGetName(v35, "TR", (const char **)&v110))
          {
            if (strcmp(*(const char **)&v110, "Identity"))
            {
              goto LABEL_167;
            }
          }
          else if (CGPDFDictionaryGetObject(v35, "TR", v109))
          {
            Function = CGPDFFunctionCreateFunction((char *)v109[0]);
            *(_QWORD *)(v54 + 48) = Function;
            if (!Function)
              goto LABEL_167;
            if (*((_QWORD *)Function + 4) != 1 || *((_QWORD *)Function + 6) != 1)
            {
              goto LABEL_167;
            }
          }
          v43 = CGPDFDictionarySetAssociation((uint64_t)v35, (const void *)v54, "SoftMask");
          if (v43)
          {
LABEL_83:
            v44 = *(double **)(v43 + 32);
            if (v44)
            {
              v45 = 0;
              v46 = v44[1];
              if (v46 == INFINITY
                || (v47 = v44[2], v47 == INFINITY)
                || (v45 = 0, v48 = v44[3], v48 == 0.0)
                || (v49 = v44[4], v49 == 0.0))
              {
LABEL_152:
                CFRelease((CFTypeRef)v43);
                CGPDFGStateSetSoftMask(*(_QWORD *)(a2 + 32), v45);
                if (v45)
                  CFRelease(v45);
                goto LABEL_91;
              }
              if (a2)
                v50 = *(_QWORD *)a2;
              else
                v50 = 0;
              v45 = 0;
              v59 = *(_DWORD *)(v43 + 24);
              if (v59)
              {
                if (v59 != 1)
                  goto LABEL_152;
                ResolvedColor = CGPDFContentStreamCreateResolvedColor(v50, *(_QWORD *)(v43 + 40), v37, v38, v39, v40, v41, v42);
                if (!ResolvedColor)
                  goto LABEL_151;
              }
              else
              {
                ResolvedColor = 0;
              }
              if (v50 && (v61 = *(const void ***)(v50 + 16)) != 0)
              {
                v116.origin.x = pdf_page_get_box_rect(*(_QWORD *)(v50 + 16), 0);
                v117.origin.x = v46;
                v117.origin.y = v47;
                v117.size.width = v48;
                v117.size.height = v49;
                if (CGRectIntersectsRect(v116, v117))
                {
                  v62 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
                  if (v62)
                  {
                    v63 = (uint64_t)v62;
                    v64 = *v61;
                    if (v64)
                      CFRetain(v64);
                    goto LABEL_132;
                  }
                }
              }
              else
              {
                v65 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
                if (v65)
                {
                  v63 = (uint64_t)v65;
                  v64 = 0;
LABEL_132:
                  v101 = v49;
                  *(_QWORD *)(v63 + 8) = v64;
                  CFRetain((CFTypeRef)v43);
                  *(_QWORD *)v63 = v43;
                  v72 = *(_QWORD *)a2;
                  if (*(_QWORD *)a2)
                    CFRetain(*(CFTypeRef *)a2);
                  *(_QWORD *)(v63 + 16) = v72;
                  v73 = v44[5];
                  v74 = v44[6];
                  v75 = v44[7];
                  v76 = v44[8];
                  v77 = v44[9];
                  v78 = v44[10];
                  v79 = &CGAffineTransformIdentity;
                  if (*(_QWORD *)(a2 + 32))
                    v79 = *(const CGAffineTransform **)(a2 + 32);
                  b = v79->b;
                  c = v79->c;
                  d = v79->d;
                  v83 = v74 * c + v73 * v79->a;
                  v84 = v74 * d + v73 * b;
                  v85 = v76 * c + v75 * v79->a;
                  v86 = v76 * d + v75 * b;
                  v100 = v79->tx + c * v78 + v77 * v79->a;
                  v87 = d * v78 + v77 * b + v79->ty;
                  CGContextGetBaseCTM(*(_QWORD *)(a2 + 88), v66, v67, v68, v69, v70, v71, (uint64_t)&v110);
                  v88 = *(_QWORD **)(v43 + 48);
                  *(double *)v109 = v84 * v112 + v83 * v110;
                  *(double *)&v109[1] = v84 * v113 + v83 * v111;
                  *(double *)&v109[2] = v86 * v112 + v85 * v110;
                  *(double *)&v109[3] = v86 * v113 + v85 * v111;
                  *(double *)&v109[4] = v114 + v112 * v87 + v100 * v110;
                  *(double *)&v109[5] = v113 * v87 + v100 * v111 + v115;
                  v45 = (const void *)CGSoftMaskCreate(v63, (__int128 *)v109, ResolvedColor, v88, (uint64_t)&pdf_softmask_callbacks, v89, v90, v91, v46, v47, v48, v101);
                  if (ResolvedColor)
                    CFRelease(ResolvedColor);
                  if (!v45)
                    pdf_softmask_release_info((CFTypeRef *)v63);
                  goto LABEL_152;
                }
              }
              if (ResolvedColor)
                CFRelease(ResolvedColor);
            }
LABEL_151:
            v45 = 0;
            goto LABEL_152;
          }
          goto LABEL_168;
        }
      }
      goto LABEL_167;
    }
  }
  pdf_error("invalid soft mask.");
LABEL_91:
  if (CGPDFDictionaryGetNumber(v5, "CA", &v107))
    CGPDFGStateSetStrokeAlpha(*(_QWORD *)(a2 + 32), v107);
  if (CGPDFDictionaryGetNumber(v5, "ca", &v107))
    CGPDFGStateSetFillAlpha(*(_QWORD *)(a2 + 32), v107);
  if (CGPDFDictionaryGetBoolean(v5, "AIS", &v106))
  {
    v51 = *(_QWORD *)(a2 + 32);
    if (v51)
      *(_BYTE *)(v51 + 216) = v106 != 0;
  }
  if (CGPDFDictionaryGetBoolean(v5, "TK", &v106))
  {
    v52 = *(_QWORD *)(a2 + 32);
    if (v52)
      *(_BYTE *)(v52 + 136) = v106 != 0;
  }
  if (CGPDFDictionaryGetObject(v5, "AAPL:ST", &v102))
    set_style(a2, (uint64_t)v102);
}

void op_BDC_7247(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v5;
  unsigned int v6;
  int v7;
  CGPDFDictionary **v8;
  CGPDFDictionary *v9;
  const char *v10;
  CGPDFObjectRef Resource;
  _BOOL4 Integer;
  _BOOL4 v13;
  BOOL v14;
  CGPDFInteger v15;
  char *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  __CFDictionary *Mutable;
  uint64_t v28;
  void (*v29)(void);
  _QWORD *PropertyList;
  _BOOL4 ShouldDrawOCG;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  char *v38;
  uint64_t v39;
  CGPDFDictionary *v40;
  uint64_t v41;
  CGPDFObjectRef v42;
  char *value;
  CGPDFInteger valuePtr;

  v2 = *(_DWORD *)(a1 + 72);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.");
    return;
  }
  v5 = *(_QWORD *)(a1 + 80);
  v6 = v2 - 1;
  v42 = (CGPDFObjectRef)(v5 + 40 * (v2 - 1));
  value = 0;
  *(_DWORD *)(a1 + 72) = v2 - 1;
  if (!CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value))
    return;
  if (v5)
  {
    v7 = *(_DWORD *)(v5 + 40 * v6 + 8);
    if (v7 == 5)
    {
      v10 = *(const char **)(v5 + 40 * v6 + 32);
      if (v10)
      {
        Resource = CGPDFContentStreamGetResource(*(CGPDFContentStreamRef *)a2, "Properties", v10);
        if (!Resource || *((_DWORD *)Resource + 2) != 8)
        {
          v14 = 0;
          v15 = -1;
          goto LABEL_17;
        }
        v8 = (CGPDFDictionary **)((char *)Resource + 32);
        goto LABEL_7;
      }
    }
    else if (v7 == 8)
    {
      v8 = (CGPDFDictionary **)(v5 + 40 * v6 + 32);
LABEL_7:
      v9 = *v8;
      goto LABEL_14;
    }
  }
  v9 = 0;
LABEL_14:
  valuePtr = -1;
  Integer = CGPDFDictionaryGetInteger(v9, "MCID", &valuePtr);
  v13 = valuePtr >= 0;
  v14 = Integer && v13;
  if (Integer && v13)
    v15 = valuePtr;
  else
    v15 = -1;
LABEL_17:
  v16 = value;
  if (!strcmp(value, "OC"))
  {
    if (v5)
    {
      if (*(_DWORD *)(v5 + 40 * v6 + 8) == 5)
      {
        PropertyList = CGPDFContentStreamGetPropertyList(*(_QWORD *)(a1 + 56), *(const char **)(v5 + 40 * v6 + 32));
        if (PropertyList)
        {
          ShouldDrawOCG = CGPDFDrawingContextShouldDrawOCG(a2, PropertyList[4], PropertyList[5]);
          v32 = *(_QWORD *)(a1 + 96);
          v33 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
          *v33 = v32;
          v33[1] = 0;
          *(_QWORD *)(a1 + 96) = v33;
          v34 = *(_QWORD *)(a1 + 144);
          v35 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
          *v35 = v34;
          v35[1] = ShouldDrawOCG;
LABEL_47:
          *(_QWORD *)(a1 + 144) = v35;
          return;
        }
      }
      CGPDFDrawingContextSaveGState(a2);
LABEL_38:
      if (*(_DWORD *)(v5 + 40 * v6 + 8) == 5)
      {
        v38 = *(char **)(v5 + 40 * v6 + 32);
        value = v38;
        v39 = a2 ? *(_QWORD *)a2 : 0;
        v40 = (CGPDFDictionary *)CGPDFContentStreamGetPropertyList(v39, v38);
        if (CGPDFDictionaryGetObject(v40, "Style", &v42))
          set_style(a2, (uint64_t)v42);
      }
      goto LABEL_45;
    }
    CGPDFDrawingContextSaveGState(a2);
LABEL_45:
    CGPDFDrawingContextSaveGState(a2);
    v36 = *(_QWORD *)(a1 + 96);
    v37 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
    v37[1] = 1;
    goto LABEL_46;
  }
  if (!v14)
  {
    if (strcmp(v16, "AAPL:Style"))
    {
      v36 = *(_QWORD *)(a1 + 96);
      v37 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      v37[1] = 0;
LABEL_46:
      *v37 = v36;
      *(_QWORD *)(a1 + 96) = v37;
      v41 = *(_QWORD *)(a1 + 144);
      v35 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *v35 = v41;
      v35[1] = 1;
      goto LABEL_47;
    }
    CGPDFDrawingContextSaveGState(a2);
    if (v5)
      goto LABEL_38;
    goto LABEL_45;
  }
  v17 = *(_QWORD *)(a1 + 96);
  v18 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  *v18 = v17;
  v18[1] = 3;
  *(_QWORD *)(a1 + 96) = v18;
  v25 = *(const void **)(a2 + 96);
  if (v25)
  {
    v26 = *(_QWORD *)(a2 + 88);
    valuePtr = v15;
    if (v26 && *(_DWORD *)(v26 + 16) == 1129601108 && *(_DWORD *)(v26 + 24) == 1)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("PageProperties"), v25);
      CGCFDictionarySetNumber(Mutable, CFSTR("MCID"), kCFNumberSInt64Type, &valuePtr);
      v28 = *(_QWORD *)(v26 + 40);
      if (v28)
      {
        v29 = *(void (**)(void))(v28 + 168);
        if (v29)
          v29();
      }
      if (Mutable)
        CFRelease(Mutable);
    }
    else
    {
      handle_invalid_context((char)"CGPDFContextBeginTagWithMCID", v26, v19, v20, v21, v22, v23, v24);
    }
  }
}

void op_BMC_7249(CGPDFScanner *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  CGPDFOperatorTable *v10;
  CGPDFOperatorTable *v11;
  char *value;

  value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    if (!strcmp(value, "AAPL:StyleContent"))
    {
      if (a1)
      {
        v6 = *((_QWORD *)a1 + 12);
        v7 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *v7 = v6;
        v7[1] = 2;
        *((_QWORD *)a1 + 12) = v7;
      }
      v8 = *((_QWORD *)a1 + 18);
      v9 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *v9 = v8;
      v9[1] = 1;
      *((_QWORD *)a1 + 18) = v9;
      v10 = CGPDFOperatorTableCreate();
      if (v10)
      {
        v11 = v10;
        CGPDFOperatorTableSetCallback(v10, "BMC", (CGPDFOperatorCallback)op_BMC_7249);
        CGPDFOperatorTableSetCallback(v11, "BDC", (CGPDFOperatorCallback)op_BDC_7247);
        CGPDFOperatorTableSetCallback(v11, "EMC", (CGPDFOperatorCallback)op_EMC_7251);
        CGPDFScannerPushTable(a1, (uint64_t)v11);
        CFRelease(v11);
      }
    }
    else
    {
      if (a1)
      {
        v2 = *((_QWORD *)a1 + 12);
        v3 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *v3 = v2;
        v3[1] = 0;
        *((_QWORD *)a1 + 12) = v3;
      }
      v4 = *((_QWORD *)a1 + 18);
      v5 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *v5 = v4;
      v5[1] = 1;
      *((_QWORD *)a1 + 18) = v5;
    }
  }
}

void op_EMC_7251(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(uint64_t **)(a1 + 144);
  if (v4)
  {
    v5 = *v4;
    free(v4);
    *(_QWORD *)(a1 + 144) = v5;
  }
  v6 = *(_DWORD **)(a1 + 96);
  if (v6)
  {
    v7 = v6[2];
    v8 = *(_QWORD *)v6;
    free(v6);
    *(_QWORD *)(a1 + 96) = v8;
    switch(v7)
    {
      case 1:
        CGPDFDrawingContextRestoreGState(a2);
        CGPDFDrawingContextRestoreGState(a2);
        break;
      case 3:
        if (*(_QWORD *)(a2 + 96))
          CGPDFContextEndTag(*(CGContextRef *)(a2 + 88));
        break;
      case 2:
        free(*(void **)(a1 + 24));
        v9 = *(uint64_t **)(a1 + 32);
        if (v9)
        {
          v10 = *v9;
          free(v9);
          *(_QWORD *)(a1 + 32) = v10;
          if (v10)
            v11 = *(_QWORD *)(v10 + 8);
          else
            v11 = 0;
        }
        else
        {
          v11 = 0;
          *(_QWORD *)(a1 + 32) = 0;
        }
        *(_QWORD *)(a1 + 24) = v11;
        break;
    }
  }
}

void set_style(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeRef v4;
  CFTypeRef cf;

  cf = 0;
  if ((get_shadow_style(a2, (uint64_t *)&cf) & 1) != 0)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = cf;
    CGPDFGStateSetShadowStyle(v3, cf);
    if (v4)
      CFRelease(v4);
  }
  else
  {
    pdf_error("invalid shadow style.");
  }
}

CGColorSpaceRef get_shadow_style(uint64_t a1, uint64_t *a2)
{
  int v3;
  const char *v4;
  CGColorSpaceRef result;
  CGPDFDictionary *v6;
  long double v7;
  long double v8;
  __n128 v9;
  CGColorSpace *v10;
  CGPDFArray *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  CGColorRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CGColorSpace *DeviceRGB;
  CGPDFReal v25;
  char *value;
  CGPDFObjectRef v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v27 = (CGPDFObjectRef)a1;
  if (!a1)
  {
LABEL_7:
    *a2 = 0;
    return (CGColorSpaceRef)1;
  }
  v25 = 0.0;
  value = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if (v3 != 8)
  {
    if (v3 != 5)
      return 0;
    v4 = *(const char **)(a1 + 32);
    if (strcmp(v4, "Default") && strcmp(v4, "None"))
    {
      return 0;
    }
    goto LABEL_7;
  }
  v6 = *(CGPDFDictionary **)(a1 + 32);
  result = (CGColorSpaceRef)CGPDFDictionaryGetName(v6, "Subtype", (const char **)&value);
  if (!(_DWORD)result)
    return result;
  if (strcmp(value, "Shadow"))
    return 0;
  result = (CGColorSpaceRef)CGPDFDictionaryGetNumbers(v6, "Offset", (uint64_t)v28, (CGPDFArray *)2);
  if ((_DWORD)result)
  {
    v7 = *(double *)v28;
    v8 = *(double *)&v28[1];
    if (!CGPDFDictionaryGetNumber(v6, "Radius", &v25))
      v25 = 0.0;
    if (!CGPDFDictionaryGetObject(v6, "ColorSpace", &v27))
    {
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      v16 = CGColorCreate(DeviceRGB, get_shadow_style_default_components);
      CGColorSpaceRelease(DeviceRGB);
LABEL_29:
      *a2 = CGStyleCreateShadow2((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23, v7, v8, v25);
      if (v16)
        CFRelease(v16);
      return (CGColorSpaceRef)1;
    }
    result = cg_create_colorspace((uint64_t)v27);
    if (result)
    {
      v10 = result;
      v11 = (CGPDFArray *)(*(_QWORD *)(*((_QWORD *)result + 3) + 40) + 1);
      MEMORY[0x1E0C80A78](result, v9);
      v14 = (char *)&v25 - v13;
      if (v12 <= 0x1FFFFFFFFFFFFFFELL)
        v15 = (char *)&v25 - v13;
      else
        v15 = 0;
      if (v12 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000000ELL)
        v15 = (char *)malloc_type_malloc(8 * (_QWORD)v11, 0x71A9811FuLL);
      if (!v15)
        return 0;
      if (!CGPDFDictionaryGetNumbers(v6, "Color", (uint64_t)v15, v11))
      {
        if (v15 != v14)
          free(v15);
        return 0;
      }
      v16 = CGColorCreate(v10, (const CGFloat *)v15);
      if (v15 != v14)
        free(v15);
      CGColorSpaceRelease(v10);
      goto LABEL_29;
    }
  }
  return result;
}

void set_line_dash(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  double v12;
  double v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  if (a2 && (v5 = *(_QWORD *)(a2 + 16)) != 0)
  {
    v6 = a3.n128_u64[0];
    MEMORY[0x1E0C80A78](a1, a3);
    v9 = (char *)v17 - v8;
    if (v7 <= 0x1FFFFFFFFFFFFFFELL)
      v10 = (char *)v17 - v8;
    else
      v10 = 0;
    if (v7 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000016)
      v10 = (char *)malloc_type_malloc(8 * v5, 0x229C5B94uLL);
    if (v10)
    {
      if (CGPDFArrayGetNumbers(a2, (uint64_t)v10, v5))
      {
        v11 = 0;
        v12 = 0.0;
        do
        {
          v13 = *(double *)&v10[8 * v11];
          if (v13 < 0.0)
          {
            pdf_error("invalid dash array: lengths may not be negative.");
            goto LABEL_18;
          }
          v12 = v12 + v13;
          ++v11;
        }
        while (v5 != v11);
        if (v12 == 0.0)
        {
          pdf_error("invalid dash array: at least one length must be greater than zero.");
          goto LABEL_18;
        }
        v14 = (unsigned int *)malloc_type_calloc(1uLL, 8 * v5 + 24, 0x64A29F66uLL);
        *v14 = 1;
        *((_QWORD *)v14 + 1) = v6;
        *((_QWORD *)v14 + 2) = v5;
        memcpy(v14 + 6, v10, 8 * v5);
        if (v10 != v9)
          free(v10);
        CGPDFGStateSetDash(*(_QWORD *)(a1 + 32), v14);
        do
        {
          v15 = __ldxr(v14);
          v16 = v15 - 1;
        }
        while (__stxr(v16, v14));
        if (!v16)
          free(v14);
      }
      else
      {
        pdf_error("invalid dash array.");
LABEL_18:
        if (v10 != v9)
          free(v10);
      }
    }
  }
  else
  {
    CGPDFGStateSetDash(*(_QWORD *)(a1 + 32), 0);
  }
}

void set_rendering_intent(uint64_t a1, char *__s1)
{
  int v4;
  uint64_t v5;

  if (!strcmp(__s1, "AbsoluteColorimetric"))
  {
    v4 = 1;
  }
  else
  {
    if (!strcmp(__s1, "RelativeColorimetric"))
    {
LABEL_6:
      v4 = 2;
      goto LABEL_10;
    }
    if (!strcmp(__s1, "Saturation"))
    {
      v4 = 4;
    }
    else
    {
      if (strcmp(__s1, "Perceptual"))
      {
        goto LABEL_6;
      }
      v4 = 3;
    }
  }
LABEL_10:
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
    *(_DWORD *)(v5 + 176) = v4;
}

void set_black_generation(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeRef cf;

  cf = 0;
  if (build_function(a2, a3, (uint64_t *)&cf))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = cf;
    CGPDFGStateSetBlackGeneration(v4, cf);
    if (v5)
      CFRelease(v5);
  }
}

void set_undercolor_removal(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeRef cf;

  cf = 0;
  if (build_function(a2, a3, (uint64_t *)&cf))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = cf;
    CGPDFGStateSetUndercolorRemoval(v4, cf);
    if (v5)
      CFRelease(v5);
  }
}

void set_transfer(uint64_t a1, uint64_t a2, int a3)
{
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  CGPDFArray *v8;
  size_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  CGPDFObjectRef value;

  value = (CGPDFObjectRef)a2;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v7 = Mutable;
    v13 = 0;
    if (a2 && *(_DWORD *)(a2 + 8) == 7)
    {
      v8 = *(CGPDFArray **)(a2 + 32);
      if (v8 && *((_QWORD *)v8 + 2) == 4)
      {
        v9 = 0;
        while (1)
        {
          CGPDFArrayGetObject(v8, v9, &value);
          if (!build_transfer_function((uint64_t)value, a3, (uint64_t *)&v13))
            break;
          v10 = v13;
          CFArrayAppendValue(v7, v13);
          CFRelease(v10);
          if (++v9 == 4)
            goto LABEL_14;
        }
      }
      else
      {
        pdf_error("invalid transfer array.", v13);
      }
    }
    else if (build_transfer_function(a2, a3, (uint64_t *)&v13))
    {
      v11 = v13;
      v12 = 4;
      do
      {
        CFArrayAppendValue(v7, v11);
        --v12;
      }
      while (v12);
      CFRelease(v11);
LABEL_14:
      CGPDFGStateSetTransferFunctions(*(_QWORD **)(a1 + 32), v7);
    }
    CFRelease(v7);
  }
}

uint64_t build_transfer_function(uint64_t a1, int a2, uint64_t *a3)
{
  const char *v4;
  uint64_t result;

  if (a1 && *(_DWORD *)(a1 + 8) == 5)
  {
    v4 = *(const char **)(a1 + 32);
    if (a2 && !strcmp(*(const char **)(a1 + 32), "Default"))
    {
      *a3 = *MEMORY[0x1E0C9B0D0];
      return 1;
    }
    if (strcmp(v4, "Identity"))
    {
      return 0;
    }
    result = CGFunctionCreateIdentity();
  }
  else
  {
    result = (uint64_t)CGPDFFunctionCreateFunction((char *)a1);
    if (!result)
      return result;
  }
  *a3 = result;
  return 1;
}

uint64_t build_function(uint64_t a1, int a2, uint64_t *a3)
{
  const char *v4;
  uint64_t result;

  if (a1 && *(_DWORD *)(a1 + 8) == 5)
  {
    v4 = *(const char **)(a1 + 32);
    if (a2 && !strcmp(*(const char **)(a1 + 32), "Default"))
    {
      result = 0;
    }
    else
    {
      if (strcmp(v4, "Identity"))
      {
        return 0;
      }
      result = CGFunctionCreateIdentity();
    }
  }
  else
  {
    result = (uint64_t)CGPDFFunctionCreateFunction((char *)a1);
    if (!result)
      return result;
  }
  *a3 = result;
  return 1;
}

void set_pattern(CGPDFScanner *a1, uint64_t *a2, CGColorSpace *a3, int a4)
{
  _BOOL4 v8;
  uint64_t v9;
  char *v10;
  CGColorSpace *Pattern;
  __n128 v12;
  CGColorSpace *v13;
  uint64_t v14;
  BOOL v15;
  CGColorSpace *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  CGFloat *v20;
  CGFloat *v21;
  uint64_t v22;
  uint64_t v23;
  double *v24;
  double v25;
  CGColorSpace *v26;
  const __CFDictionary *Mutable;
  char *v28;
  const void **v29;
  const void *v30;
  __int128 *v31;
  int v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  BOOL v36;
  void (__cdecl *v37)(void *, CGContextRef);
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  CGFloat v43;
  CGFloat v44;
  BOOL v45;
  CGPatternTiling v46;
  uint64_t Shading;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  _BYTE *v55;
  uint64_t Instance;
  unsigned int v57;
  unsigned int v58;
  __int128 v59;
  const CGRect *v60;
  CGFloat *p_y;
  CGSize *p_size;
  CGFloat *p_height;
  __int128 v64;
  CGPatternRef v65;
  CGColorSpace *v66;
  CGColorRef v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  CGFloat width;
  _QWORD *v72;
  CGColorSpaceRef v73;
  char *value;
  CGPDFReal v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  CGAffineTransform matrix;
  CGPatternCallbacks callbacks;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  value = 0;
  v75 = 0.0;
  v8 = CGPDFScannerPopName(a1, (const char **)&value);
  if (!a2)
    return;
  if (!v8)
    return;
  v9 = *a2;
  if (!*a2)
    return;
  v10 = value;
  while (1)
  {
    Pattern = (CGColorSpace *)CGPDFResourcesGetPattern(*(_QWORD *)(v9 + 32), v10);
    if (Pattern)
      break;
    v9 = *(_QWORD *)(v9 + 40);
    if (!v9)
      return;
  }
  v13 = Pattern;
  if (a3)
    v14 = *(_QWORD *)(*((_QWORD *)a3 + 3) + 40);
  else
    v14 = 0;
  if (*((_DWORD *)Pattern + 4) != 1 || (*((_BYTE *)Pattern + 32) ? (v15 = v14 == 0) : (v15 = 1), v15))
  {
    v16 = 0;
  }
  else
  {
    Pattern = CGColorSpaceCreatePattern(0);
    v16 = Pattern;
    v14 = 0;
    a3 = Pattern;
  }
  MEMORY[0x1E0C80A78](Pattern, v12);
  v20 = (CGFloat *)((char *)&v72 - v19);
  if (v18 <= 0x1FFFFFFFFFFFFFFELL)
    v21 = (CGFloat *)((char *)&v72 - v19);
  else
    v21 = 0;
  if (v18 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000000ELL)
    v21 = (CGFloat *)malloc_type_malloc(8 * v17, 0xD79C9EE2uLL);
  if (!v21)
  {
    CGColorSpaceRelease(v16);
    return;
  }
  v73 = v16;
  if (!v14)
  {
LABEL_28:
    v23 = a2[4];
    if (a4)
    {
      if (v23)
      {
        v24 = (double *)(v23 + 200);
LABEL_34:
        v25 = *v24;
LABEL_39:
        v26 = v73;
        v21[v14] = v25;
        Mutable = (const __CFDictionary *)a2[8];
        if (Mutable
          || (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]),
              (a2[8] = (uint64_t)Mutable) != 0))
        {
          v28 = (char *)CFDictionaryGetValue(Mutable, v13);
          if (!v28)
          {
            if (*a2 && (v29 = *(const void ***)(*a2 + 16)) != 0)
              v30 = *v29;
            else
              v30 = 0;
            v31 = (__int128 *)a2[3];
            if (v31)
            {
              *(_QWORD *)&callbacks.version = 0;
              v32 = *((_DWORD *)v13 + 4);
              if (v32 == 2)
              {
                Shading = CGPDFShadingGetShading(*((_QWORD *)v13 + 18));
                v54 = *((_OWORD *)v13 + 7);
                v76 = *((_OWORD *)v13 + 6);
                v77 = v54;
                v78 = *((_OWORD *)v13 + 8);
                if (Shading)
                {
                  v55 = (_BYTE *)Shading;
                  if (kCGPatternWillDeallocate_block_invoke_once != -1)
                    dispatch_once(&kCGPatternWillDeallocate_block_invoke_once, &__block_literal_global_5_16460);
                  Instance = CGTypeCreateInstance(CGPatternGetTypeID_pattern_type_id, 176, v48, v49, v50, v51, v52, v53);
                  if (Instance)
                  {
                    v28 = (char *)Instance;
                    do
                    {
                      v57 = __ldxr(identifier_16461);
                      v58 = v57 + 1;
                    }
                    while (__stxr(v58, identifier_16461));
                    *(_DWORD *)(Instance + 16) = v58;
                    *(_DWORD *)(Instance + 20) = 1;
                    v59 = v77;
                    *(_OWORD *)(Instance + 24) = v76;
                    *(_OWORD *)(Instance + 40) = v59;
                    *(_OWORD *)(Instance + 56) = v78;
                    *(_BYTE *)(Instance + 72) = 1;
                    *(_BYTE *)(Instance + 184) = 0;
                    CFRetain(v55);
                    *((_QWORD *)v28 + 10) = v55;
                    if (v55[40])
                    {
                      v60 = (const CGRect *)(v55 + 48);
                      p_y = (CGFloat *)(v55 + 56);
                      p_size = (CGSize *)(v55 + 64);
                      p_height = (CGFloat *)(v55 + 72);
                    }
                    else
                    {
                      v60 = &CGRectInfinite;
                      p_height = &CGRectInfinite.size.height;
                      p_y = &CGRectInfinite.origin.y;
                      p_size = &CGRectInfinite.size;
                    }
                    v26 = v73;
                    v69 = *(_QWORD *)p_height;
                    v70 = *(_QWORD *)p_y;
                    width = p_size->width;
                    *((_QWORD *)v28 + 13) = *(_QWORD *)&v60->origin.x;
                    *((_QWORD *)v28 + 14) = v70;
                    *((CGFloat *)v28 + 15) = width;
                    *((_QWORD *)v28 + 16) = v69;
                    *((_QWORD *)v28 + 17) = 0;
                    *((_QWORD *)v28 + 18) = 0;
                    *(_WORD *)(v28 + 185) = 1;
                    *((_OWORD *)v28 + 10) = shading_callbacks;
                    *((_QWORD *)v28 + 22) = release_shading;
                    *((_QWORD *)v28 + 11) = 0;
LABEL_87:
                    CFDictionarySetValue((CFMutableDictionaryRef)a2[8], v13, v28);
                    CFRelease(v28);
                    goto LABEL_77;
                  }
                }
              }
              else if (v32 == 1)
              {
                v33 = malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
                __CFSetLastAllocationEventName();
                if (v33)
                {
                  v72 = v33;
                  *v33 = v13;
                  if (v30)
                    CFRetain(v30);
                  v34 = v72;
                  v72[1] = v30;
                  v35 = v34;
                  v34[2] = CGPDFGStateCreateCopy(v31);
                  if (*((_DWORD *)v13 + 4) == 1)
                  {
                    v36 = *((_BYTE *)v13 + 32) == 0;
                    v37 = (void (__cdecl *)(void *, CGContextRef))(*((_BYTE *)v13 + 32)
                                                                 ? type1_draw_colored_pattern
                                                                 : type1_draw_uncolored_pattern);
                    callbacks.drawPattern = v37;
                    callbacks.releaseInfo = (CGPatternReleaseInfoCallback)type1_release_info;
                    v38 = *((_QWORD *)v13 + 5);
                    v39 = *((_QWORD *)v13 + 6);
                    v40 = *((_QWORD *)v13 + 7);
                    v41 = *((_QWORD *)v13 + 8);
                    v42 = *((_OWORD *)v13 + 7);
                    *(_OWORD *)&matrix.a = *((_OWORD *)v13 + 6);
                    *(_OWORD *)&matrix.c = v42;
                    *(_OWORD *)&matrix.tx = *((_OWORD *)v13 + 8);
                    v43 = *((double *)v13 + 9);
                    v44 = *((double *)v13 + 10);
                    v45 = !v36;
                    v46 = *((_DWORD *)v13 + 9);
                  }
                  else
                  {
                    v45 = 0;
                    callbacks.drawPattern = (CGPatternDrawPatternCallback)type1_draw_uncolored_pattern;
                    callbacks.releaseInfo = (CGPatternReleaseInfoCallback)type1_release_info;
                    v38 = 0x7FF0000000000000;
                    v39 = 0x7FF0000000000000;
                    v40 = 0;
                    v41 = 0;
                    v64 = *((_OWORD *)v13 + 7);
                    *(_OWORD *)&matrix.a = *((_OWORD *)v13 + 6);
                    *(_OWORD *)&matrix.c = v64;
                    v43 = 0.0;
                    v46 = kCGPatternTilingConstantSpacingMinimalDistortion;
                    *(_OWORD *)&matrix.tx = *((_OWORD *)v13 + 8);
                    v44 = 0.0;
                  }
                  v65 = CGPatternCreate(v35, *(CGRect *)&v38, &matrix, v43, v44, v46, v45, &callbacks);
                  if (v65)
                  {
                    v28 = (char *)v65;
                    v66 = (CGColorSpace *)*((_QWORD *)v65 + 12);
                    if (v66 != v13)
                    {
                      if (v66)
                        CFRelease(v66);
                      CFRetain(v13);
                      *((_QWORD *)v28 + 12) = v13;
                    }
                    v26 = v73;
                    goto LABEL_87;
                  }
                }
              }
            }
            v28 = 0;
            v26 = v73;
          }
        }
        else
        {
          v28 = 0;
        }
LABEL_77:
        v67 = CGColorCreateWithPattern(a3, (CGPatternRef)v28, v21);
        v68 = a2[4];
        if (a4)
          CGPDFGStateSetFillColor(v68, v67);
        else
          CGPDFGStateSetStrokeColor(v68, v67);
        if (v67)
          CFRelease(v67);
        CGColorSpaceRelease(v26);
        if (v21 != v20)
          free(v21);
        return;
      }
    }
    else if (v23)
    {
      v24 = (double *)(v23 + 208);
      goto LABEL_34;
    }
    v25 = 1.0;
    goto LABEL_39;
  }
  v22 = v14 - 1;
  while (CGPDFScannerPopNumber(a1, &v75))
  {
    v21[v22--] = v75;
    if (v22 == -1)
      goto LABEL_28;
  }
  if (v21 != v20)
    free(v21);
  CGColorSpaceRelease(v73);
}

CGPDFOperatorTable *CGPDFDrawingContextCreateContentTypesTable(char a1)
{
  CGPDFOperatorTable *v2;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;

  v2 = CGPDFOperatorTableCreate();
  if ((a1 & 2) != 0)
  {
    for (i = 0; i != 18; i += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[i], (CGPDFOperatorCallback)(&operators)[i + 1]);
    CGPDFOperatorTableSetCallback(v2, "gs", (CGPDFOperatorCallback)op_gs_7245);
  }
  if ((a1 & 4) != 0)
  {
    for (j = 0; j != 26; j += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[j + 18], (CGPDFOperatorCallback)(&operators)[j + 19]);
  }
  if ((a1 & 8) != 0)
  {
    for (k = 0; k != 38; k += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[k + 44], (CGPDFOperatorCallback)(&operators)[k + 45]);
  }
  if ((a1 & 0x10) != 0)
  {
    for (m = 0; m != 34; m += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[m + 82], (CGPDFOperatorCallback)(&operators)[m + 83]);
  }
  if ((a1 & 0x20) != 0)
  {
    for (n = 0; n != 6; n += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[n + 116], (CGPDFOperatorCallback)(&operators)[n + 117]);
  }
  if ((a1 & 0x40) != 0)
  {
    CGPDFOperatorTableSetCallback(v2, "d1", (CGPDFOperatorCallback)op_d1_7243);
    for (ii = 0; ii != 6; ii += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[ii + 126], (CGPDFOperatorCallback)(&operators)[ii + 127]);
  }
  return v2;
}

const void *CGPDFResourcesCopyXObject(uint64_t a1, const char *a2)
{
  const void *v2;
  os_unfair_lock_s *v5;
  __CFString *v6;
  const __CFDictionary *v7;
  __CFDictionary **v8;
  BOOL v9;
  CGPDFObjectRef resource;
  uint64_t v11;
  CGPDFDictionary *v12;
  char *v13;
  int v15;
  uint64_t cftype;
  void *v17;
  void *v18;
  char *value;
  CGPDFObjectRef v20;

  v2 = 0;
  if (a1 && a2)
  {
    v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v8 = (__CFDictionary **)(a1 + 40);
    v7 = *(const __CFDictionary **)(a1 + 40);
    if (v6)
      v9 = v7 == 0;
    else
      v9 = 1;
    if (!v9)
    {
      v2 = CFDictionaryGetValue(v7, v6);
      if (v2)
        goto LABEL_8;
    }
    resource = get_resource(a1, "XObject", a2);
    if (resource)
    {
      value = 0;
      if (*((_DWORD *)resource + 2) == 9)
      {
        v11 = *((_QWORD *)resource + 4);
        if (v11)
          v12 = *(CGPDFDictionary **)(v11 + 48);
        else
          v12 = 0;
        if (!CGPDFDictionaryGetName(v12, "Subtype", (const char **)&value))
        {
          goto LABEL_19;
        }
        v13 = value;
        if (!strcmp(value, "Image"))
        {
          v15 = 0;
        }
        else
        {
          if (strcmp(v13, "Form"))
          {
            goto LABEL_19;
          }
          v20 = 0;
          if (CGPDFDictionaryGetObject(v12, "Group", &v20) && v20 && *((_DWORD *)v20 + 2) == 8)
            v15 = 2;
          else
            v15 = 1;
        }
        if (CGPDFXObjectGetTypeID_onceToken != -1)
          dispatch_once(&CGPDFXObjectGetTypeID_onceToken, &__block_literal_global_17282);
        cftype = pdf_create_cftype();
        if (cftype)
        {
          v17 = (void *)cftype;
          *(_DWORD *)(cftype + 16) = v15;
          *(_QWORD *)(cftype + 24) = v11;
          *(_DWORD *)(cftype + 104) = 0;
          pthread_mutex_init((pthread_mutex_t *)(cftype + 32), 0);
          v18 = table_set_value(v8, v6, v17);
          v2 = v18;
          if (v18)
            CFRelease(v18);
LABEL_8:
          CFRelease(v6);
          CFRetain(v2);
LABEL_20:
          os_unfair_lock_unlock(v5);
          return v2;
        }
      }
    }
LABEL_19:
    CFRelease(v6);
    v2 = 0;
    goto LABEL_20;
  }
  return v2;
}

const void *CGPDFResourcesGetPattern(uint64_t a1, const char *a2)
{
  const void *v2;
  os_unfair_lock_s *v5;
  __CFString *v6;
  const __CFDictionary *v7;
  __CFDictionary **v8;
  BOOL v9;
  CGPDFObjectRef resource;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  int v15;
  CGPDFDictionary **v16;
  uint64_t v17;
  CGPDFDictionary *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CGPDFDictionary *v22;
  uint64_t cftype;
  uint64_t v24;
  __int128 v25;
  char v27;
  __int128 v28;
  CGPDFDictionaryRef *v29;
  const char *v30;
  CGPDFInteger value;
  CGPDFInteger v32;
  CGPDFObjectRef v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v2 = 0;
  v37 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v8 = (__CFDictionary **)(a1 + 48);
    v7 = *(const __CFDictionary **)(a1 + 48);
    if (v6)
      v9 = v7 == 0;
    else
      v9 = 1;
    if (!v9)
    {
      v2 = CFDictionaryGetValue(v7, v6);
      if (v2)
        goto LABEL_41;
    }
    resource = get_resource(a1, "Pattern", a2);
    if (!resource)
      goto LABEL_40;
    v11 = (uint64_t)resource;
    v12 = (void *)CGPDFObjectCopyAssociation((uint64_t)resource, "Pattern");
    if (v12)
    {
      v13 = v12;
      goto LABEL_11;
    }
    value = 0;
    v15 = *(_DWORD *)(v11 + 8);
    if (v15 == 9)
    {
      v17 = *(_QWORD *)(v11 + 32);
      if (!v17)
      {
        v18 = 0;
LABEL_19:
        if (!CGPDFDictionaryGetInteger(v18, "PatternType", &value))
        {
          goto LABEL_40;
        }
        if (value == 2)
        {
          v33 = (CGPDFObjectRef)v11;
          if (CGPDFPatternGetTypeID_onceToken != -1)
            dispatch_once(&CGPDFPatternGetTypeID_onceToken, &__block_literal_global_7491);
          cftype = pdf_create_cftype();
          v20 = cftype;
          if (!cftype)
          {
LABEL_70:
            v13 = (void *)CGPDFObjectSetAssociation(v11, (const void *)v20, "Pattern");
            if (v13)
            {
LABEL_11:
              v14 = table_set_value(v8, v6, v13);
              v2 = v14;
              if (v14)
                CFRelease(v14);
              goto LABEL_41;
            }
LABEL_40:
            v2 = 0;
LABEL_41:
            CFRelease(v6);
            os_unfair_lock_unlock(v5);
            return v2;
          }
          *(_DWORD *)(cftype + 16) = 2;
          if (*(_DWORD *)(v11 + 8) == 8)
          {
            v22 = *(CGPDFDictionary **)(v11 + 32);
            if (CGPDFDictionaryGetObject(v22, "Shading", &v33))
            {
              v24 = CGPDFShadingCreateWithObject((uint64_t)v33);
              *(_QWORD *)(v20 + 144) = v24;
              if (v24)
              {
                if (CGPDFDictionaryGetNumbers(v22, "Matrix", (uint64_t)&v34, (CGPDFArray *)6))
                {
                  v25 = v35;
                  *(_OWORD *)(v20 + 96) = v34;
                  *(_OWORD *)(v20 + 112) = v25;
                  *(_OWORD *)(v20 + 128) = v36;
                }
                else
                {
                  *(CGAffineTransform *)(v20 + 96) = CGAffineTransformIdentity;
                }
                v29 = (CGPDFDictionaryRef *)(v20 + 152);
                v30 = "ExtGState";
LABEL_63:
                if (!CGPDFDictionaryGetDictionary(v22, v30, v29))
                  *v29 = 0;
                goto LABEL_70;
              }
            }
            else
            {
            }
          }
          else
          {
            pdf_error("invalid Type 2 pattern: not a dictionary.");
          }
        }
        else
        {
          if (value != 1)
          {
            goto LABEL_40;
          }
          if (CGPDFPatternGetTypeID_onceToken != -1)
            dispatch_once(&CGPDFPatternGetTypeID_onceToken, &__block_literal_global_7491);
          v19 = pdf_create_cftype();
          v20 = v19;
          if (!v19)
            goto LABEL_70;
          v32 = 0;
          v33 = 0;
          *(_DWORD *)(v19 + 16) = 1;
          if (*(_DWORD *)(v11 + 8) == 9)
          {
            v21 = *(_QWORD *)(v11 + 32);
            *(_QWORD *)(v19 + 24) = v21;
            if (v21)
              v22 = *(CGPDFDictionary **)(v21 + 48);
            else
              v22 = 0;
            if (CGPDFDictionaryGetInteger(v22, "PaintType", (CGPDFInteger *)&v33))
            {
              v27 = (char)v33;
              if (v33 != (CGPDFObjectRef)1)
              {
                if (v33 != (CGPDFObjectRef)2)
                {
                  goto LABEL_69;
                }
                v27 = 0;
              }
              *(_BYTE *)(v20 + 32) = v27;
              if (CGPDFDictionaryGetInteger(v22, "TilingType", &v32))
              {
                if ((unint64_t)(v32 - 1) >= 3)
                {
                }
                else
                {
                  *(_DWORD *)(v20 + 36) = dword_184F7D970[v32 - 1];
                  if (CGPDFDictionaryGetRect(v22, "BBox", (double *)(v20 + 40)))
                  {
                    if (CGPDFDictionaryGetNumber(v22, "XStep", (CGPDFReal *)(v20 + 72)))
                    {
                      if (CGPDFDictionaryGetNumber(v22, "YStep", (CGPDFReal *)(v20 + 80)))
                      {
                        if (CGPDFDictionaryGetNumbers(v22, "Matrix", (uint64_t)&v34, (CGPDFArray *)6))
                        {
                          v28 = v35;
                          *(_OWORD *)(v20 + 96) = v34;
                          *(_OWORD *)(v20 + 112) = v28;
                          *(_OWORD *)(v20 + 128) = v36;
                        }
                        else
                        {
                          *(CGAffineTransform *)(v20 + 96) = CGAffineTransformIdentity;
                        }
                        v29 = (CGPDFDictionaryRef *)(v20 + 88);
                        v30 = "Resources";
                        goto LABEL_63;
                      }
                    }
                    else
                    {
                    }
                  }
                  else
                  {
                  }
                }
              }
              else
              {
              }
            }
            else
            {
            }
          }
          else
          {
            pdf_error("invalid Type 1 pattern: not a stream.");
          }
        }
LABEL_69:
        CFRelease((CFTypeRef)v20);
        v20 = 0;
        goto LABEL_70;
      }
      v16 = (CGPDFDictionary **)(v17 + 48);
    }
    else
    {
      if (v15 != 8)
      {
        pdf_error("invalid pattern: not a dictionary or stream.");
        goto LABEL_40;
      }
      v16 = (CGPDFDictionary **)(v11 + 32);
    }
    v18 = *v16;
    goto LABEL_19;
  }
  return v2;
}

const void *CGPDFResourcesGetShading(uint64_t a1, const char *a2)
{
  const void *Value;
  os_unfair_lock_s *v5;
  __CFString *v6;
  const __CFDictionary *v7;
  BOOL v8;
  CGPDFObjectRef resource;
  void *v10;
  void *v11;

  Value = 0;
  if (a1 && a2)
  {
    v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v7 = *(const __CFDictionary **)(a1 + 56);
    if (v6)
      v8 = v7 == 0;
    else
      v8 = 1;
    if (v8 || (Value = CFDictionaryGetValue(v7, v6)) == 0)
    {
      resource = get_resource(a1, "Shading", a2);
      v10 = (void *)CGPDFShadingCreateWithObject((uint64_t)resource);
      if (v10)
      {
        v11 = table_set_value((__CFDictionary **)(a1 + 56), v6, v10);
        Value = v11;
        if (v11)
          CFRelease(v11);
      }
      else
      {
        Value = 0;
      }
    }
    CFRelease(v6);
    os_unfair_lock_unlock(v5);
  }
  return Value;
}

void traverseBoundary(uint64_t a1, int *a2)
{
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  char v7;
  char v8;
  double *v9;
  char v10;
  double *v11;
  char v12;
  double v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  double v18;
  _BOOL4 v19;
  double v20;
  double v21;
  double v22;
  uint64_t v23;
  double v24;
  _BOOL4 v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  _BOOL4 v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  _BOOL4 v38;
  BOOL v39;
  BOOL v40;
  char v41;
  _BOOL4 v42;
  BOOL v43;
  _BOOL4 v44;
  char v45;
  BOOL v46;
  int v47;
  int v49;
  BOOL v50;
  uint64_t v52;
  char v53;
  int v54;
  unint64_t v55;
  double *v56;

  if (*(_BYTE *)(a1 + 31))
  {
    v3 = *a2;
    v4 = *a2;
    if ((*a2 - 1) < 3)
    {
      if (!*(_BYTE *)(a1 + 29))
      {
        *(_BYTE *)(a1 + 28) = 1;
LABEL_15:
        v6 = 0;
        v55 = qword_184F7D950[v4];
        v7 = *(_BYTE *)(a1 + 20);
        v8 = *(_BYTE *)(a1 + 22);
        v9 = *(double **)a1;
        v10 = *(_BYTE *)(a1 + 21);
        v11 = (double *)(*((_QWORD *)a2 + 1) + 8);
        v12 = *(_BYTE *)(a1 + 23);
        while (1)
        {
          *(_BYTE *)(a1 + 24) = v7;
          *(_BYTE *)(a1 + 25) = v10;
          *(_BYTE *)(a1 + 26) = v8;
          *(_BYTE *)(a1 + 27) = v12;
          *(_DWORD *)(a1 + 20) = 0;
          v13 = *(v11 - 1);
          v14 = *v9;
          v15 = v9[2];
          v16 = v9[3];
          if (v15 < 0.0 || v16 < 0.0)
          {
            v17 = *((_QWORD *)v9 + 1);
            *(_QWORD *)&v14 = (unint64_t)CGRectStandardize(*(CGRect *)&v14);
          }
          v18 = vabdd_f64(v13, v14);
          v19 = v18 < 0.015;
          *(_BYTE *)(a1 + 21) = v19;
          v20 = *v9;
          v21 = v9[2];
          v22 = v9[3];
          if (v21 < 0.0 || v22 < 0.0)
          {
            v23 = *((_QWORD *)v9 + 1);
            *(CGRect *)&v20 = CGRectStandardize(*(CGRect *)&v20);
          }
          v24 = vabdd_f64(v13, v20 + v21);
          v25 = v24 < 0.015;
          *(_BYTE *)(a1 + 23) = v25;
          v26 = *v11;
          v27 = v9[1];
          v28 = v9[2];
          v29 = v9[3];
          v56 = v11;
          if (v28 < 0.0 || v29 < 0.0)
          {
            v30 = *v9;
            *(CGRect *)(&v27 - 1) = CGRectStandardize(*(CGRect *)(&v27 - 1));
          }
          v31 = vabdd_f64(v26, v27);
          v32 = v31 < 0.015;
          *(_BYTE *)(a1 + 20) = v32;
          v33 = v9[1];
          v34 = v9[2];
          v35 = v9[3];
          if (v34 < 0.0 || v35 < 0.0)
          {
            v36 = *v9;
            *(CGRect *)(&v33 - 1) = CGRectStandardize(*(CGRect *)(&v33 - 1));
          }
          v37 = vabdd_f64(v26, v33 + v35);
          v38 = v37 < 0.015;
          *(_BYTE *)(a1 + 22) = v38;
          if (++v6 >= v55)
            break;
          if (v10)
            v19 = v18 < 0.015;
          else
            v19 = 0;
          *(_BYTE *)(a1 + 21) = v19;
          if (v12)
            v25 = v24 < 0.015;
          else
            v25 = 0;
          *(_BYTE *)(a1 + 23) = v25;
          if (v7)
            v32 = v31 < 0.015;
          else
            v32 = 0;
          *(_BYTE *)(a1 + 20) = v32;
          if (v8)
            v38 = v37 < 0.015;
          else
            v38 = 0;
          *(_BYTE *)(a1 + 22) = v38;
          if (v32 || v25 || v19)
          {
            v39 = v25;
            goto LABEL_205;
          }
          v39 = v25;
          if (!v38)
            break;
LABEL_205:
          v12 = v39;
          v10 = v19;
          v8 = v38;
          v7 = v32;
          v11 = v56 + 2;
          if (v55 == v6)
            return;
        }
        v40 = v19;
        v41 = v38;
        if (!v32 && !v19)
        {
          if (v38)
          {
            v40 = 0;
            v41 = 1;
          }
          else
          {
            if (!v25)
              goto LABEL_207;
            v40 = 0;
            v41 = 0;
          }
        }
        if (*(_BYTE *)(a1 + 8))
        {
          if (v7)
          {
            if (v19)
            {
LABEL_54:
              v42 = 1;
              v39 = v25;
              v40 = v19;
              goto LABEL_89;
            }
            v39 = 0;
            if (v32 && !v25)
            {
              v42 = 1;
              v40 = 0;
              goto LABEL_89;
            }
            v40 = 0;
          }
          if (v10)
          {
            if (v38)
            {
              v41 = 1;
              v39 = v25;
LABEL_64:
              v42 = 1;
              goto LABEL_89;
            }
            v41 = 0;
            if (!v32 && v19)
              goto LABEL_54;
            v40 = v19;
          }
          if (v8)
          {
            if (v25)
            {
              v42 = 1;
              goto LABEL_56;
            }
            v39 = 0;
            if (v38)
            {
              v40 = v19;
              v43 = !v19;
            }
            else
            {
              v43 = 0;
            }
            if (v43)
            {
              v41 = 1;
              v40 = 0;
              goto LABEL_64;
            }
            v41 = v38;
          }
          else
          {
            v39 = v25;
          }
          v42 = v12 != 0;
          v44 = v25;
          if (v25)
            v45 = v38;
          else
            v45 = v41;
          if (v38)
            v44 = 0;
          if (v12)
            v46 = v25;
          else
            v46 = v39;
          if (!v12)
          {
            v45 = v41;
            v44 = v12 != 0;
          }
          if (!v32)
          {
            v39 = v46;
            v41 = v45;
            v42 = v44;
          }
LABEL_89:
          *(_BYTE *)(a1 + 8) = v42;
          v47 = *(unsigned __int8 *)(a1 + 9);
          if (!*(_BYTE *)(a1 + 9))
            goto LABEL_133;
          if (v7)
          {
            if (v25)
            {
LABEL_92:
              v39 = v25;
              goto LABEL_122;
            }
            v39 = 0;
            if (v32)
            {
              if (!v19)
              {
                v40 = 0;
                goto LABEL_122;
              }
              v40 = v19;
              if (v10)
              {
LABEL_122:
                v47 = 1;
                *(_BYTE *)(a1 + 9) = 1;
                goto LABEL_134;
              }
              goto LABEL_104;
            }
            if (!v10)
              goto LABEL_104;
          }
          else
          {
            if (!v10)
              goto LABEL_104;
            if (v32)
              goto LABEL_122;
          }
          if (!v19)
          {
            if (v8)
            {
LABEL_109:
              if (v38)
              {
                if (v25)
                {
                  v41 = 1;
                  if (v12)
                  {
                    v40 = 0;
                    goto LABEL_92;
                  }
                  v40 = 0;
                  v47 = 0;
                  goto LABEL_130;
                }
                v39 = 0;
                v40 = 0;
LABEL_121:
                v41 = 1;
                goto LABEL_122;
              }
              if (v12)
              {
                v40 = 0;
                goto LABEL_123;
              }
              v40 = 0;
              v41 = 0;
              goto LABEL_132;
            }
            v40 = 0;
LABEL_119:
            if (v12)
            {
              if (v38)
                goto LABEL_121;
LABEL_123:
              v41 = 0;
              v47 = !v32 && v25;
LABEL_130:
              v39 = v25;
              goto LABEL_133;
            }
LABEL_132:
            v47 = 0;
LABEL_133:
            *(_BYTE *)(a1 + 9) = v47;
            if (((v42 | v47) & 1) == 0)
              goto LABEL_207;
LABEL_134:
            v49 = *(_DWORD *)(a1 + 12);
            if (v49)
            {
              switch(*(_DWORD *)(a1 + 16))
              {
                case 1:
                  if (v42)
                  {
                    v50 = !v38 && v40;
                    if (v38 && v19)
                      goto LABEL_195;
                    LOBYTE(v19) = v50;
                  }
                  else
                  {
                    LOBYTE(v19) = v40;
                    LOBYTE(v38) = v41;
                  }
                  if (!v32 || !v47)
                    goto LABEL_205;
                  if (v25)
                  {
                    HIDWORD(v52) = 4;
                    LODWORD(v52) = v49 + 1;
                    LOBYTE(v32) = 1;
                    goto LABEL_183;
                  }
                  v39 = 0;
                  goto LABEL_201;
                case 2:
                  if (v42)
                  {
                    if (v38)
                    {
                      if (v25)
                        goto LABEL_187;
                      v39 = 0;
                      LOBYTE(v38) = 1;
                    }
                  }
                  else
                  {
                    LOBYTE(v38) = v41;
                  }
                  if (!v32 || !v47)
                    goto LABEL_204;
                  if (!v19)
                  {
LABEL_201:
                    LOBYTE(v32) = 1;
                    goto LABEL_205;
                  }
                  HIDWORD(v52) = 1;
                  LODWORD(v52) = v49 + 1;
                  LOBYTE(v32) = 1;
                  LOBYTE(v25) = v39;
LABEL_183:
                  v41 = v38;
                  goto LABEL_197;
                case 3:
                  v53 = !v32 || !v42;
                  if ((v53 & 1) != 0)
                    goto LABEL_192;
                  if (v25)
                  {
                    HIDWORD(v52) = 4;
                    LODWORD(v52) = v49 + 1;
                    LOBYTE(v32) = 1;
                    goto LABEL_188;
                  }
                  v39 = 0;
LABEL_192:
                  if (!v47)
                    goto LABEL_199;
                  if (!v38)
                    goto LABEL_204;
                  if (v19)
                  {
LABEL_195:
                    HIDWORD(v52) = 2;
                    LODWORD(v52) = v49 + 1;
                    v41 = 1;
                    goto LABEL_196;
                  }
                  LOBYTE(v38) = 1;
                  goto LABEL_205;
                case 4:
                  v54 = !v32 || !v42;
                  if (!v54)
                    v40 = 0;
                  if ((v54 & 1) == 0 && v19)
                  {
                    HIDWORD(v52) = 1;
                    LODWORD(v52) = v49 + 1;
                    goto LABEL_167;
                  }
                  if (!v47)
                  {
LABEL_199:
                    LOBYTE(v19) = v40;
                    goto LABEL_198;
                  }
                  if (!v38)
                    goto LABEL_204;
                  if (!v25)
                  {
                    v39 = 0;
                    LOBYTE(v38) = 1;
                    goto LABEL_204;
                  }
LABEL_187:
                  HIDWORD(v52) = 3;
                  LODWORD(v52) = v49 + 1;
                  v41 = 1;
LABEL_188:
                  LOBYTE(v19) = v40;
                  break;
                default:
                  goto LABEL_207;
              }
              goto LABEL_197;
            }
            if (v32)
            {
              if (v19)
              {
                v52 = 0x100000001;
LABEL_167:
                LOBYTE(v32) = 1;
LABEL_196:
                LOBYTE(v25) = v39;
LABEL_197:
                *(_QWORD *)(a1 + 12) = v52;
                v39 = v25;
LABEL_198:
                LOBYTE(v38) = v41;
                goto LABEL_205;
              }
              v39 = 0;
              LOBYTE(v32) = 1;
              v52 = 0x400000001;
              LOBYTE(v38) = v41;
              if (v25)
                goto LABEL_197;
            }
            else
            {
              LOBYTE(v32) = 0;
              if (v38)
              {
                if (v19)
                {
                  v41 = 1;
                  LOBYTE(v25) = v39;
                  v52 = 0x200000001;
                  goto LABEL_197;
                }
                v39 = 0;
                v41 = 1;
                v52 = 0x300000001;
                LOBYTE(v38) = 1;
                if (v25)
                  goto LABEL_197;
              }
              else
              {
LABEL_204:
                LOBYTE(v19) = v40;
              }
            }
            goto LABEL_205;
          }
          if (!v38)
          {
            v41 = 0;
            v40 = v19;
            goto LABEL_122;
          }
          v41 = 1;
          v40 = v19;
LABEL_104:
          if (v8)
          {
            v40 = v19;
            if (v19)
              goto LABEL_122;
            goto LABEL_109;
          }
          goto LABEL_119;
        }
        v42 = 0;
LABEL_56:
        v39 = v25;
        goto LABEL_89;
      }
      goto LABEL_207;
    }
    if (v3)
    {
      if (v3 != 4)
      {
LABEL_207:
        *(_BYTE *)(a1 + 31) = 0;
        return;
      }
      if (*(_BYTE *)(a1 + 28))
      {
LABEL_8:
        *(_BYTE *)(a1 + 29) = 1;
        return;
      }
    }
    else
    {
      v5 = *(unsigned __int8 *)(a1 + 28);
      if (!*(_BYTE *)(a1 + 28) && *(_BYTE *)(a1 + 30))
      {
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 20) = 16843009;
      }
      *(_BYTE *)(a1 + 30) = 1;
      if (v5)
        goto LABEL_8;
    }
    if (v4 <= 3 && !*(_BYTE *)(a1 + 29))
      goto LABEL_15;
  }
}

const CGPath *CGPathIsCongruentToARect(const CGPath *result)
{
  const CGPath *v1;
  CGRect PathBoundingBox;
  CGRect *info;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;

  if (result)
  {
    v1 = result;
    if (CGPathIsEmpty(result))
    {
      return 0;
    }
    else
    {
      PathBoundingBox = CGPathGetPathBoundingBox(v1);
      info = &PathBoundingBox;
      v5 = 257;
      v6 = 0;
      v7 = 0x101010101010101;
      v8 = 0x1000000;
      CGPathApply(v1, &info, (CGPathApplierFunction)traverseBoundary);
      return (const CGPath *)(HIBYTE(v8) && HIDWORD(v5) > 3);
    }
  }
  return result;
}

__n128 checkRectilinear(uint64_t a1, uint64_t a2, __n128 result)
{
  _OWORD *v3;
  double v4;
  double v5;
  unsigned int v6;
  double *v7;
  _OWORD *v8;
  uint64_t v9;
  double *v10;
  double *v11;
  uint64_t v12;

  if (*(_BYTE *)(a1 + 41))
  {
    v3 = (_OWORD *)(a1 + 24);
    v4 = *(double *)(a1 + 24);
    result.n128_u64[0] = *(_QWORD *)a1;
    v5 = *(double *)(a1 + 32);
    v6 = *(_DWORD *)a2;
    if ((*(_DWORD *)a2 - 1) >= 3)
    {
      v7 = (double *)(a1 + 8);
      if (v6 != 4)
      {
        if (!v6)
        {
          v8 = *(_OWORD **)(a2 + 8);
          *(_OWORD *)v7 = *v8;
          result = *(__n128 *)v8;
          *v3 = *v8;
        }
        return result;
      }
      v6 = 1;
    }
    else
    {
      *(_BYTE *)(a1 + 40) = 1;
      v7 = *(double **)(a2 + 8);
    }
    v9 = v6;
    v10 = v7;
    while (vabdd_f64(*v10, v4) < result.n128_f64[0])
    {
      v10 += 2;
      if (!--v9)
        goto LABEL_17;
    }
    v11 = v7 + 1;
    v12 = v6;
    while (vabdd_f64(*v11, v5) < result.n128_f64[0])
    {
      v11 += 2;
      if (!--v12)
        goto LABEL_17;
    }
    *(_BYTE *)(a1 + 41) = 0;
LABEL_17:
    result = *(__n128 *)&v7[2 * v6 - 2];
    *v3 = result;
  }
  return result;
}

_DWORD *countElements(_DWORD *result)
{
  ++*result;
  return result;
}

_BYTE *elementIsFlat(_BYTE *result, _DWORD *a2)
{
  if (*result)
  {
    if (*a2 > 4u || ((1 << *a2) & 0x13) == 0)
      *result = 0;
  }
  return result;
}

void CGPathAddFlattenedCurve(const CGPath *a1, float64_t a2, float64_t a3, float64_t a4, float64_t a5, CGFloat a6, CGFloat a7, double a8)
{
  float64x2_t CurrentPoint;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  double v23;
  float64x2_t v24;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  int v34;
  unsigned int v38;
  float64x2_t v42;
  float64x2_t v44;
  float64x2_t v46;
  float64x2_t v48;

  CurrentPoint = (float64x2_t)CGPathGetCurrentPoint(a1);
  v11.f64[0] = a2;
  v11.f64[1] = a3;
  v12 = vsubq_f64(v11, CurrentPoint);
  v13 = v11;
  v14.f64[0] = a4;
  v14.f64[1] = a5;
  v11.f64[0] = a6;
  v11.f64[1] = a7;
  v15 = vsubq_f64(v14, v13);
  v16 = vsubq_f64(v11, v14);
  v17 = vsubq_f64(v15, v12);
  v18 = vsubq_f64(v16, v15);
  v19 = (float64x2_t)vzip2q_s64((int64x2_t)v17, (int64x2_t)v18);
  v20 = vmulq_f64(v19, v19);
  v21 = (float64x2_t)vzip1q_s64((int64x2_t)v17, (int64x2_t)v18);
  v22 = vmlaq_f64(v20, v21, v21);
  if (v22.f64[0] <= v22.f64[1])
    v22.f64[0] = v22.f64[1];
  v23 = v22.f64[0] * 9.0 * 0.0625;
  if (v23 > a8 * a8)
  {
    v24 = vsubq_f64(v18, v17);
    __asm
    {
      FMOV            V5.2D, #3.0
      FMOV            V6.2D, #6.0
    }
    v31 = vmulq_f64(v24, _Q6);
    v32 = vmlaq_f64(v24, _Q5, vaddq_f64(v12, v17));
    v33 = vmulq_f64(vaddq_f64(v17, v24), _Q6);
    v34 = 1;
    __asm
    {
      FMOV            V2.2D, #0.125
      FMOV            V3.2D, #0.25
      FMOV            V4.2D, #0.5
    }
    do
    {
      v31 = vmulq_f64(v31, _Q2);
      v33 = vsubq_f64(vmulq_f64(v33, _Q3), v31);
      v32 = vsubq_f64(vmulq_f64(v32, _Q4), vmulq_f64(v33, _Q4));
      v34 *= 2;
      v23 = v23 * 0.0625;
    }
    while (v23 > a8 * a8 && v34 <= 0x10000);
    if (v34 >= 2)
    {
      v38 = v34 + 1;
      do
      {
        v46 = v31;
        v48 = vaddq_f64(CurrentPoint, v32);
        v42 = vaddq_f64(v32, v33);
        v44 = vaddq_f64(v31, v33);
        CGPathAddLineToPoint(a1, 0, v48.f64[0], v48.f64[1]);
        v32 = v42;
        v33 = v44;
        v31 = v46;
        CurrentPoint = v48;
        --v38;
      }
      while (v38 > 2);
    }
  }
  CGPathAddLineToPoint(a1, 0, a6, a7);
}

void addFlattenedElement(uint64_t a1, uint64_t a2)
{
  CGMutablePathRef v2;
  double *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  CGPoint CurrentPoint;
  double v10;
  double v11;
  double v12;
  double v13;
  const CGPath *v14;
  CGFloat v15;
  CGFloat v16;
  double v17;
  double *v18;

  switch(*(_DWORD *)a2)
  {
    case 0:
      CGPathMoveToPoint(*(CGMutablePathRef *)a1, 0, **(CGFloat **)(a2 + 8), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 8));
      break;
    case 1:
      CGPathAddLineToPoint(*(CGMutablePathRef *)a1, 0, **(CGFloat **)(a2 + 8), *(CGFloat *)(*(_QWORD *)(a2 + 8) + 8));
      break;
    case 2:
      v2 = *(CGMutablePathRef *)a1;
      v3 = *(double **)(a2 + 8);
      v4 = *(double *)(a1 + 8);
      v5 = *v3;
      v6 = v3[1];
      v7 = v3[2];
      v8 = v3[3];
      CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*(_QWORD *)a1);
      v10 = (CurrentPoint.x + v5 * 2.0) / 3.0;
      v11 = (CurrentPoint.y + v6 * 2.0) / 3.0;
      v12 = (v7 + v5 * 2.0) / 3.0;
      v13 = (v8 + v6 * 2.0) / 3.0;
      v14 = v2;
      v15 = v7;
      v16 = v8;
      v17 = v4;
      goto LABEL_6;
    case 3:
      v18 = *(double **)(a2 + 8);
      v17 = *(double *)(a1 + 8);
      v10 = *v18;
      v11 = v18[1];
      v12 = v18[2];
      v13 = v18[3];
      v15 = v18[4];
      v16 = v18[5];
      v14 = *(const CGPath **)a1;
LABEL_6:
      CGPathAddFlattenedCurve(v14, v10, v11, v12, v13, v15, v16, v17);
      break;
    case 4:
      CGPathCloseSubpath(*(CGMutablePathRef *)a1);
      break;
    default:
      return;
  }
}

void CGPathAddIntersection(CGPath *a1, const CGPath **a2, unsigned int a3)
{
  const CGPath **v4;
  int *PolygonFromPath;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int *v10;
  int *v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  char *contour_bboxes;
  char *v16;
  int *v17;
  double *v18;
  int v19;
  uint64_t v20;
  int v21;
  int *v22;
  int *v23;
  uint64_t i;
  uint64_t v25;
  double *v26;
  double v27;
  double *v28;
  int v29;
  _BOOL4 v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  int *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  uint64_t v42;
  int *v43;
  int v44;
  double *v45;
  double *v46;
  int v47;
  double *v48;
  double *v49;
  double *v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  double v56;
  double v57;
  uint64_t v58;
  double v59;
  double *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  double v64;
  uint64_t *v65;
  double v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t j;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  _BOOL4 v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  double v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  BOOL v86;
  BOOL v88;
  int v89;
  _BOOL4 v91;
  int v92;
  int v93;
  BOOL v94;
  int v95;
  int v96;
  _BOOL4 v98;
  int v99;
  int v100;
  int v101;
  double v102;
  uint64_t v103;
  uint64_t v104;
  double *v105;
  uint64_t v106;
  uint64_t v107;
  double *v108;
  uint64_t v109;
  uint64_t v110;
  double *v111;
  uint64_t v112;
  uint64_t v113;
  double *v114;
  uint64_t v115;
  uint64_t v116;
  double *v117;
  uint64_t v118;
  uint64_t v119;
  double *v120;
  uint64_t v121;
  uint64_t v122;
  double *v123;
  uint64_t v124;
  double *v125;
  uint64_t v126;
  uint64_t v127;
  double *v128;
  uint64_t v129;
  uint64_t v130;
  double *v131;
  uint64_t v132;
  uint64_t v133;
  double v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  double v139;
  _QWORD *v140;
  _QWORD *v141;
  uint64_t v142;
  double *v143;
  double *v144;
  _QWORD *v145;
  double v146;
  double v147;
  double v148;
  double v149;
  double v150;
  double v151;
  double v152;
  BOOL v153;
  double v154;
  double v155;
  double v156;
  _QWORD *v157;
  void **v158;
  _QWORD *v159;
  double *v160;
  double *v161;
  uint64_t v162;
  double *v163;
  _QWORD *v164;
  uint64_t v165;
  _QWORD *v166;
  _QWORD *v167;
  _QWORD *v168;
  uint64_t *v169;
  uint64_t v170;
  uint64_t v171;
  int v172;
  uint64_t v173;
  uint64_t v174;
  int v175;
  int v176;
  uint64_t *v177;
  uint64_t v178;
  uint64_t *v179;
  uint64_t v180;
  __int128 v181;
  int v182;
  int v183;
  int v184;
  _BOOL4 v185;
  _BOOL4 v187;
  int v188;
  int v189;
  int v190;
  BOOL v191;
  double v192;
  uint64_t v193;
  double *v194;
  uint64_t v195;
  double *v196;
  uint64_t v197;
  double *v198;
  uint64_t v199;
  double *v200;
  uint64_t v201;
  double *v202;
  uint64_t v203;
  double *v204;
  uint64_t v205;
  double *v206;
  uint64_t v207;
  double *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v218;
  uint64_t v219;
  _QWORD *v220;
  int v221;
  _QWORD *v222;
  uint64_t v223;
  _QWORD *v224;
  unsigned int v225;
  uint64_t v226;
  unsigned int v227;
  _QWORD *v228;
  uint64_t v229;
  void *v230;
  _QWORD *v231;
  int v232;
  _QWORD *v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  void *v237;
  uint64_t v238;
  _QWORD *v239;
  uint64_t v240;
  _QWORD *v241;
  _QWORD *v242;
  _QWORD *v243;
  _QWORD *v244;
  _QWORD *v245;
  int *v246;
  unint64_t v247;
  unint64_t k;
  uint64_t v249;
  unsigned int *v250;
  float64x2_t v251;
  uint64_t v252;
  float64x2_t *v253;
  float64x2_t v254;
  float64x2_t v255;
  uint64_t v256;
  float64x2_t *v257;
  float64x2_t v258;
  unsigned int v259;
  uint64_t v260;
  _QWORD *v261;
  unint64_t v262;
  const CGPath **v263;
  CGPath *v264;
  uint64_t v265;
  int *v266;
  double *v267;
  uint64_t v268;
  double *v269;
  int *v270;
  int *v271;
  double *v272;
  int v273;
  int v274;
  double *v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  void *v285;
  void *v286;
  uint64_t v287;
  void *v288;
  uint64_t v289;
  _QWORD v290[2];

  v4 = a2;
  PolygonFromPath = createPolygonFromPath(*a2);
  v7 = a3;
  v8 = 1;
  v264 = a1;
  v265 = v7;
  v263 = v4;
  do
  {
    v9 = createPolygonFromPath(v4[v8]);
    v10 = (int *)malloc_type_malloc(0x18uLL, 0x1030040B05087B7uLL);
    v11 = PolygonFromPath;
    PolygonFromPath = v10;
    v288 = 0;
    v289 = 0;
    v286 = 0;
    v287 = 0;
    v284 = 0;
    v285 = 0;
    v12 = *v11;
    if (!*v11 || !*v9)
    {
      *v10 = 0;
      *((_QWORD *)v10 + 1) = 0;
      *((_QWORD *)v10 + 2) = 0;
      goto LABEL_412;
    }
    v13 = v12 < 1 || *v9 < 1;
    v271 = v11;
    if (!v13)
    {
      v14 = v8;
      contour_bboxes = create_contour_bboxes(v11);
      v16 = create_contour_bboxes(v9);
      v17 = v271;
      v18 = (double *)v16;
      v19 = *v271;
      LODWORD(v20) = *v9;
      v21 = *v9 * *v271;
      if (v21)
      {
        v22 = (int *)malloc_type_malloc(4 * v21, 0x100004052888210uLL);
        v17 = v271;
        v23 = v22;
        v19 = *v271;
        LODWORD(v20) = *v9;
      }
      else
      {
        v23 = 0;
      }
      if (v19 >= 1)
      {
        for (i = 0; i < v19; ++i)
        {
          if ((int)v20 >= 1)
          {
            v25 = 0;
            v26 = (double *)&contour_bboxes[32 * i];
            v27 = v26[2];
            v28 = v18 + 2;
            do
            {
              if (v27 >= *(v28 - 2) && *v26 <= *v28)
              {
                v30 = v26[3] < *(v28 - 1) || v26[1] > v28[1];
                v29 = !v30;
              }
              else
              {
                v29 = 0;
              }
              v23[(int)i + *v17 * (int)v25++] = v29;
              v20 = *v9;
              v28 += 4;
            }
            while (v25 < v20);
            v19 = *v17;
          }
        }
      }
      if ((int)v20 >= 1)
      {
        v31 = 0;
        v32 = v23;
        do
        {
          v33 = v19 & ~(v19 >> 31);
          v34 = v32;
          while (v33)
          {
            v35 = *v34++;
            --v33;
            if (v35)
              goto LABEL_33;
          }
          *(_DWORD *)(*((_QWORD *)v9 + 2) + 16 * v31) = -*(_DWORD *)(*((_QWORD *)v9 + 2) + 16 * v31);
LABEL_33:
          ++v31;
          v32 += v19;
        }
        while (v31 != v20);
      }
      if (v19 >= 1)
      {
        v36 = 0;
        v37 = v19;
        v38 = v20 & ~((int)v20 >> 31);
        v39 = 4 * v19;
        v40 = v38 + 1;
        v41 = v23;
        do
        {
          v42 = v40;
          v43 = v41;
          while (--v42)
          {
            v44 = *v43;
            v43 = (int *)((char *)v43 + v39);
            if (v44)
              goto LABEL_41;
          }
          *(_DWORD *)(*((_QWORD *)v17 + 2) + 16 * v36) = -*(_DWORD *)(*((_QWORD *)v17 + 2) + 16 * v36);
LABEL_41:
          ++v36;
          ++v41;
        }
        while (v36 != v37);
      }
      if (contour_bboxes)
        free(contour_bboxes);
      if (v18)
        free(v18);
      if (v23)
        free(v23);
      v11 = v271;
      v12 = *v271;
      v8 = v14;
    }
    if (v12 < 1)
      v45 = 0;
    else
      v45 = build_lmt((double **)&v286, (double **)&v289, &v284, (unsigned int *)v11, 1);
    v269 = v45;
    if (*v9 < 1)
    {
      v46 = 0;
    }
    else
    {
      v46 = build_lmt((double **)&v286, (double **)&v289, &v284, (unsigned int *)v9, 0);
      v45 = v269;
    }
    v11 = v271;
    v275 = (double *)v286;
    if (v286)
    {
      v267 = v46;
      if ((_DWORD)v284)
      {
        v47 = v284;
        v48 = (double *)malloc_type_malloc(8 * (int)v284, 0x100004000313F17uLL);
      }
      else
      {
        v47 = 0;
        v48 = 0;
      }
      v272 = v48;
      build_sbt((int *)&v284 + 1, (uint64_t)v48, v289);
      free_sbtree((void **)&v289);
      if (v271 == PolygonFromPath)
        gpc_free_polygon((uint64_t)v271);
      if (v9 == PolygonFromPath)
        gpc_free_polygon((uint64_t)v9);
      v51 = v47;
      v268 = v8;
      if (v47 < 1)
      {
        *((_QWORD *)PolygonFromPath + 1) = 0;
        *((_QWORD *)PolygonFromPath + 2) = 0;
      }
      else
      {
        v270 = v9;
        v266 = PolygonFromPath;
        v52 = 0;
        v53 = 0;
        v54 = 0;
        v55 = 0;
        v276 = 0;
        v56 = 0.0;
        v57 = 0.0;
        do
        {
          v58 = v53 + 1;
          HIDWORD(v284) = v58;
          v59 = v272[v53];
          if ((int)v58 < v51)
          {
            v57 = v272[v58];
            v56 = v57 - v59;
          }
          v60 = v275;
          if (v275 && *v275 == v59)
          {
            v61 = *((_QWORD *)v275 + 1);
            if (v61)
            {
              do
              {
                v62 = v287;
                if (v287)
                {
                  v63 = 0;
                  v64 = *(double *)(v61 + 48);
                  v65 = &v287;
                  while (1)
                  {
                    v66 = *(double *)(v62 + 48);
                    if (v64 < v66)
                      break;
                    v67 = v62;
                    if (v64 == v66 && *(double *)(v61 + 64) < *(double *)(v62 + 64))
                      break;
                    v65 = (uint64_t *)(v62 + 136);
                    v62 = *(_QWORD *)(v62 + 136);
                    v63 = v67;
                    if (!v62)
                      goto LABEL_83;
                  }
                  *(_QWORD *)(v61 + 128) = v63;
                  *(_QWORD *)(v61 + 136) = *v65;
                  *(_QWORD *)(*v65 + 128) = v61;
                  *v65 = v61;
                }
                else
                {
                  v67 = 0;
                  v65 = &v287;
LABEL_83:
                  *v65 = v61;
                  *(_QWORD *)(v61 + 128) = v67;
                  *(_QWORD *)(v61 + 136) = 0;
                }
                v61 = *(_QWORD *)(v61 + 160);
              }
              while (v61);
              v52 = v287;
            }
            v60 = (double *)*((_QWORD *)v275 + 2);
          }
          v275 = v60;
          if (v52)
          {
            *(_DWORD *)(v52 + 76 + 4 * *(int *)(v52 + 72)) = *(double *)(v52 + 40) != v59;
            *(_DWORD *)(v52 + 76 + 4 * (*(_DWORD *)(v52 + 72) == 0)) = 0;
            *(_DWORD *)(v52 + 100) = 0;
            v68 = *(_QWORD *)(v52 + 136);
            for (j = v52; v68; j = v73)
            {
              v70 = v68 + 76;
              *(_DWORD *)(v68 + 76 + 4 * *(int *)(v68 + 72)) = *(double *)(v68 + 40) != v59;
              v71 = *(int *)(v68 + 72);
              *(_DWORD *)(v68 + 76 + 4 * (*(_DWORD *)(v68 + 72) == 0)) = 0;
              *(_DWORD *)(v68 + 100) = 0;
              v72 = *(_DWORD *)(v68 + 76 + 4 * v71);
              if (v72)
              {
                v73 = v68;
                if (vabdd_f64(*(double *)(j + 48), *(double *)(v68 + 48)) <= 2.22044605e-16)
                {
                  v73 = v68;
                  if (vabdd_f64(*(double *)(j + 64), *(double *)(v68 + 64)) <= 2.22044605e-16)
                  {
                    v73 = v68;
                    if (*(double *)(j + 40) != v59)
                    {
                      *(_DWORD *)(v70 + 4 * v71) = *(_DWORD *)(j + 76 + 4 * v71) ^ v72;
                      v74 = *(_DWORD *)(v68 + 72) == 0;
                      v75 = *(_DWORD *)(j + 76 + 4 * (*(_DWORD *)(v68 + 72) == 0));
                      *(_DWORD *)(v68 + 100) = 1;
                      *(_DWORD *)(v70 + 4 * v74) = v75;
                      *(_DWORD *)(j + 76) = 0;
                      *(_DWORD *)(j + 80) = 0;
                      *(_DWORD *)(j + 100) = 2;
                      v73 = v68;
                    }
                  }
                }
              }
              else
              {
                v73 = j;
              }
              v68 = *(_QWORD *)(v68 + 136);
            }
            v76 = 0;
            v77 = 0;
            v78 = -1.79769313e308;
            do
            {
              v80 = *(_DWORD *)(v52 + 76);
              v79 = *(_DWORD *)(v52 + 80);
              v82 = *(_DWORD *)(v52 + 84);
              v81 = *(_DWORD *)(v52 + 88);
              v83 = v80 + 2 * v82;
              v84 = v79 + 2 * v81;
              if (v83 | v84)
              {
                *(_DWORD *)(v52 + 92) = v55;
                *(_DWORD *)(v52 + 96) = v54;
                if (!v83 || (v85 = 1, !v54) && !v77)
                {
                  if (!v84 || (v85 = 1, !v55) && !v76)
                  {
                    if (v83)
                      v86 = v84 == 0;
                    else
                      v86 = 1;
                    v85 = !v86 && v55 == v54;
                  }
                }
                if (v55)
                  v88 = v54 == 0;
                else
                  v88 = 1;
                v89 = !v88;
                v91 = v55 != v80 && v54 != v79;
                v92 = v55 ^ (v76 != 0);
                v93 = v77 != 0;
                if (v92)
                  v94 = v54 == v93;
                else
                  v94 = 1;
                v95 = !v94;
                v96 = v81 ^ v93;
                v98 = v92 != v82 && v96 != v54;
                v55 ^= v80;
                if (v83)
                  v76 = next_h_state[6 * v76 - 2 + 2 * v83 + v55];
                v54 ^= v79;
                if (v84)
                  v77 = next_h_state[6 * v77 - 2 + 2 * v84 + v54];
                if (v85)
                {
                  if (v98)
                    v99 = 2;
                  else
                    v99 = 0;
                  if (v89)
                    v100 = 4;
                  else
                    v100 = 0;
                  if (v91)
                    v101 = 8;
                  else
                    v101 = 0;
                  v102 = *(double *)(v52 + 48);
                  switch(v100 | v101 | v99 | v95)
                  {
                    case 1:
                      v104 = v276;
                      if (v102 != v78)
                      {
                        if (v276)
                        {
                          v105 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *v105 = v102;
                          v105[1] = v59;
                          v106 = *(_QWORD *)(v276 + 32);
                          v105[2] = *(double *)(v106 + 8);
                          *(_QWORD *)(v106 + 8) = v105;
                          v104 = v276;
                        }
                        v78 = v102;
                      }
                      merge_right(v104, *(_QWORD *)(v52 + 120), (uint64_t)v285);
                      goto LABEL_186;
                    case 2:
                      v107 = *(_QWORD *)(v52 + 120);
                      if (v107)
                      {
                        v108 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                        *v108 = v102;
                        v108[1] = v59;
                        v109 = *(_QWORD *)(v107 + 32);
                        v108[2] = *(double *)(v109 + 8);
                        *(_QWORD *)(v109 + 8) = v108;
                        v103 = *(_QWORD *)(v52 + 120);
LABEL_160:
                        v276 = v103;
                      }
                      else
                      {
                        v276 = 0;
                      }
                      goto LABEL_197;
                    case 4:
                      v110 = v276;
                      if (v102 == v78)
                        goto LABEL_185;
                      if (!v276)
                        goto LABEL_184;
                      v111 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                      *v111 = v102;
                      v111[1] = v59;
                      v111[2] = 0.0;
                      v112 = *(_QWORD *)(v276 + 32);
                      *(_QWORD *)(*(_QWORD *)(v112 + 16) + 16) = v111;
                      *(_QWORD *)(v112 + 16) = v111;
                      goto LABEL_183;
                    case 5:
                      if (*(double *)(v52 + 24) == v59)
                      {
                        v113 = *(_QWORD *)(v52 + 120);
                        if (v113)
                        {
                          v114 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *v114 = v102;
                          v114[1] = v59;
                          v114[2] = 0.0;
                          v115 = *(_QWORD *)(v113 + 32);
                          *(_QWORD *)(*(_QWORD *)(v115 + 16) + 16) = v114;
                          *(_QWORD *)(v115 + 16) = v114;
                        }
                      }
                      goto LABEL_179;
                    case 6:
                      v116 = v276;
                      if (v102 != v78)
                      {
                        v78 = *(double *)(v52 + 48);
                        if (v276)
                        {
                          v117 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *v117 = v102;
                          v117[1] = v59;
                          v117[2] = 0.0;
                          v118 = *(_QWORD *)(v276 + 32);
                          *(_QWORD *)(*(_QWORD *)(v118 + 16) + 16) = v117;
                          *(_QWORD *)(v118 + 16) = v117;
                          v116 = v276;
                          v78 = v102;
                        }
                      }
                      merge_left(v116, *(_QWORD *)(v52 + 120), (uint64_t)v285);
                      goto LABEL_175;
                    case 7:
                    case 8:
                      add_local_min(&v285, v52, *(double *)(v52 + 48), v59);
                      v103 = *(_QWORD *)(v52 + 112);
                      goto LABEL_160;
                    case 9:
                      v119 = v276;
                      if (v102 != v78)
                      {
                        v78 = *(double *)(v52 + 48);
                        if (v276)
                        {
                          v120 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *v120 = v102;
                          v120[1] = v59;
                          v121 = *(_QWORD *)(v276 + 32);
                          v120[2] = *(double *)(v121 + 8);
                          *(_QWORD *)(v121 + 8) = v120;
                          v119 = v276;
                          v78 = v102;
                        }
                      }
                      merge_right(v119, *(_QWORD *)(v52 + 120), (uint64_t)v285);
LABEL_175:
                      *(_QWORD *)(v52 + 120) = 0;
                      add_local_min(&v285, v52, v102, v59);
                      v276 = *(_QWORD *)(v52 + 112);
                      break;
                    case 0xA:
                      if (*(double *)(v52 + 24) == v59)
                      {
                        v122 = *(_QWORD *)(v52 + 120);
                        if (v122)
                        {
                          v123 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *v123 = v102;
                          v123[1] = v59;
                          v124 = *(_QWORD *)(v122 + 32);
                          v123[2] = *(double *)(v124 + 8);
                          *(_QWORD *)(v124 + 8) = v123;
                        }
                      }
LABEL_179:
                      *(_QWORD *)(v52 + 112) = *(_QWORD *)(v52 + 120);
                      goto LABEL_197;
                    case 0xB:
                      v110 = v276;
                      if (v102 == v78)
                        goto LABEL_185;
                      if (!v276)
                        goto LABEL_184;
                      v125 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                      *v125 = v102;
                      v125[1] = v59;
                      v126 = *(_QWORD *)(v276 + 32);
                      v125[2] = *(double *)(v126 + 8);
                      *(_QWORD *)(v126 + 8) = v125;
LABEL_183:
                      v110 = v276;
LABEL_184:
                      v78 = v102;
LABEL_185:
                      *(_QWORD *)(v52 + 112) = v110;
LABEL_186:
                      v276 = 0;
                      break;
                    case 0xD:
                      v127 = *(_QWORD *)(v52 + 120);
                      if (v127)
                      {
                        v128 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                        *v128 = v102;
                        v128[1] = v59;
                        v128[2] = 0.0;
                        v129 = *(_QWORD *)(v127 + 32);
                        *(_QWORD *)(*(_QWORD *)(v129 + 16) + 16) = v128;
                        *(_QWORD *)(v129 + 16) = v128;
                        v276 = *(_QWORD *)(v52 + 120);
                      }
                      else
                      {
                        v276 = 0;
                      }
                      *(_QWORD *)(v52 + 120) = 0;
LABEL_197:
                      v78 = v102;
                      break;
                    case 0xE:
                      v130 = v276;
                      if (v102 != v78)
                      {
                        if (v276)
                        {
                          v131 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *v131 = v102;
                          v131[1] = v59;
                          v131[2] = 0.0;
                          v132 = *(_QWORD *)(v276 + 32);
                          *(_QWORD *)(*(_QWORD *)(v132 + 16) + 16) = v131;
                          *(_QWORD *)(v132 + 16) = v131;
                          v130 = v276;
                        }
                        v78 = v102;
                      }
                      merge_left(v130, *(_QWORD *)(v52 + 120), (uint64_t)v285);
                      v276 = 0;
                      *(_QWORD *)(v52 + 120) = 0;
                      break;
                    default:
                      break;
                  }
                }
              }
              v52 = *(_QWORD *)(v52 + 136);
            }
            while (v52);
            v52 = v287;
            v133 = v287;
            if (v287)
            {
              do
              {
                v134 = *(double *)(v133 + 40);
                if (v134 == v59)
                {
                  v135 = *(_QWORD *)(v133 + 128);
                  v136 = *(_QWORD *)(v133 + 136);
                  v137 = v136;
                  if (v135)
                  {
                    *(_QWORD *)(v135 + 136) = v136;
                    v137 = v52;
                  }
                  if (v136)
                    *(_QWORD *)(v136 + 128) = v135;
                  if (v135)
                  {
                    if (*(_DWORD *)(v133 + 104) == 1 && *(_DWORD *)(v135 + 104) == 2)
                    {
                      *(_QWORD *)(v135 + 120) = *(_QWORD *)(v133 + 120);
                      *(_DWORD *)(v135 + 104) = 0;
                      v138 = *(_QWORD *)(v135 + 128);
                      if (v138)
                      {
                        if (*(_DWORD *)(v138 + 104) == 2)
                          *(_DWORD *)(v135 + 104) = 1;
                      }
                    }
                  }
                  v52 = v137;
                }
                else
                {
                  if (v134 == v57)
                    v139 = *(double *)(v133 + 32);
                  else
                    v139 = *(double *)(v133 + 16) + *(double *)(v133 + 64) * (v57 - *(double *)(v133 + 24));
                  *(double *)(v133 + 56) = v139;
                }
                v133 = *(_QWORD *)(v133 + 136);
              }
              while (v133);
              v287 = v52;
            }
          }
          if (SHIDWORD(v284) >= (int)v284)
            break;
          v273 = HIDWORD(v284);
          v274 = v284;
          v140 = v288;
          if (v288)
          {
            do
            {
              v141 = (_QWORD *)v140[4];
              free(v140);
              v140 = v141;
            }
            while (v141);
            v288 = 0;
          }
          v290[0] = 0;
          if (v52)
          {
            v142 = v52;
            while (1)
            {
              if (*(_DWORD *)(v142 + 100) != 1 && !*(_DWORD *)(v142 + 76) && !*(_DWORD *)(v142 + 80))
                goto LABEL_251;
              v143 = (double *)v290[0];
              if (!v290[0])
              {
                v145 = v290;
                goto LABEL_249;
              }
              v144 = (double *)(v142 + 64);
              v145 = v290;
              do
              {
                v146 = v143[2];
                v147 = *(double *)(v142 + 56);
                if (v147 >= v146
                  || ((v148 = v143[1],
                       v149 = v146 - v148,
                       v150 = *(double *)(v142 + 48),
                       v151 = v149 - (v147 - v150),
                       v152 = fabs(v151),
                       *v144 != v143[3])
                    ? (v153 = v152 > 2.22044605e-16)
                    : (v153 = 0),
                      !v153))
                {
                  v164 = malloc_type_malloc(0x28uLL, 0x102004060DBCA02uLL);
                  *v145 = v164;
                  *v164 = v142;
                  v165 = *v145;
                  *(_OWORD *)(*v145 + 8) = *(_OWORD *)(v142 + 48);
                  goto LABEL_250;
                }
                v154 = (v150 - v148) / v151;
                v155 = v154 * v56;
                v156 = *v143;
                v157 = v288;
                if (!v288)
                {
                  v158 = &v288;
LABEL_244:
                  v160 = (double *)malloc_type_malloc(0x28uLL, 0x1020040D4280EFAuLL);
                  v157 = 0;
                  goto LABEL_245;
                }
                if (*((double *)v288 + 3) > v155)
                {
                  v158 = &v288;
                  goto LABEL_241;
                }
                do
                {
                  v159 = v157;
                  v157 = (_QWORD *)v157[4];
                  if (!v157)
                  {
                    v158 = (void **)(v159 + 4);
                    goto LABEL_244;
                  }
                }
                while (*((double *)v157 + 3) <= v155);
                v158 = (void **)(v159 + 4);
LABEL_241:
                v160 = (double *)malloc_type_malloc(0x28uLL, 0x1020040D4280EFAuLL);
LABEL_245:
                *v158 = v160;
                *v160 = v156;
                *((_QWORD *)*v158 + 1) = v142;
                v161 = (double *)*v158;
                v161[2] = v148 + v154 * v149;
                v161[3] = v155;
                *((_QWORD *)v161 + 4) = v157;
                v162 = *v145;
                v163 = *(double **)(v162 + 32);
                v145 = (_QWORD *)(v162 + 32);
                v143 = v163;
              }
              while (v163);
LABEL_249:
              v166 = malloc_type_malloc(0x28uLL, 0x102004060DBCA02uLL);
              v143 = 0;
              *v145 = v166;
              *v166 = v142;
              v165 = *v145;
              *(_OWORD *)(*v145 + 8) = *(_OWORD *)(v142 + 48);
              v144 = (double *)(v142 + 64);
LABEL_250:
              *(double *)(v165 + 24) = *v144;
              *(_QWORD *)(v165 + 32) = v143;
LABEL_251:
              v142 = *(_QWORD *)(v142 + 136);
              if (!v142)
              {
                v167 = (_QWORD *)v290[0];
                if (v290[0])
                {
                  do
                  {
                    v168 = (_QWORD *)v167[4];
                    free(v167);
                    v167 = v168;
                  }
                  while (v168);
                }
                break;
              }
            }
          }
          v169 = (uint64_t *)v288;
          if (v288)
          {
            while (1)
            {
              v173 = *v169;
              v174 = v169[1];
              v175 = *(_DWORD *)(*v169 + 76);
              if (!v175)
                break;
              v176 = *(_DWORD *)(v174 + 76);
              if (v176)
              {
                v177 = (uint64_t *)(v173 + 112);
                v178 = *(_QWORD *)(v173 + 112);
                v179 = (uint64_t *)(v174 + 112);
                v180 = *(_QWORD *)(v174 + 112);
                v181 = *((_OWORD *)v169 + 1);
                if (*(_DWORD *)(v173 + 92))
                  goto LABEL_262;
                v172 = 1;
              }
              else
              {
                if (!*(_DWORD *)(v174 + 80))
                  goto LABEL_334;
                v176 = 0;
                v177 = (uint64_t *)(v173 + 112);
                v178 = *(_QWORD *)(v173 + 112);
                v179 = (uint64_t *)(v174 + 112);
                v180 = *(_QWORD *)(v174 + 112);
                v181 = *((_OWORD *)v169 + 1);
                v172 = *(_DWORD *)(v173 + 92) == 0;
              }
LABEL_270:
              v183 = *(_DWORD *)(v173 + 80);
              if (!v183)
              {
                if (!*(_DWORD *)(v174 + 80))
                {
                  v184 = *(_DWORD *)(v173 + 96);
                  if (!v184)
                    goto LABEL_278;
                }
LABEL_276:
                v184 = *(_DWORD *)(v174 + 96) != 0;
                goto LABEL_278;
              }
              if (*(_DWORD *)(v173 + 96))
              {
                v184 = *(_DWORD *)(v174 + 80);
                if (v184)
                  goto LABEL_276;
              }
              else
              {
                v184 = 1;
              }
LABEL_278:
              v185 = v176 != v172 && *(_DWORD *)(v174 + 80) != v184;
              v187 = v175 != v172 && v183 != v184;
              if ((v176 ^ v175) == v172)
              {
                v188 = 0;
                if (v185)
                  v189 = 2;
                else
                  v189 = 0;
                if (v187)
                  v190 = 4;
                else
                  v190 = 0;
              }
              else
              {
                v191 = (*(_DWORD *)(v174 + 80) ^ v183) != v184;
                if (v185)
                  v189 = 2;
                else
                  v189 = 0;
                if (v187)
                  v190 = 4;
                else
                  v190 = 0;
                if (v191)
                  v188 = 8;
                else
                  v188 = 0;
              }
              v192 = v59 + *((double *)&v181 + 1);
              switch(v190 | v172 & v184 | v188 | v189)
              {
                case 1:
                  if (v178 && v180)
                  {
                    v277 = v181;
                    v194 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(_QWORD *)v194 = v277;
                    v194[1] = v192;
                    v195 = *(_QWORD *)(v178 + 32);
                    v194[2] = *(double *)(v195 + 8);
                    *(_QWORD *)(v195 + 8) = v194;
                    merge_right(v178, v180, (uint64_t)v285);
                    goto LABEL_332;
                  }
                  goto LABEL_334;
                case 2:
                  if (v180)
                  {
                    v278 = v181;
                    v196 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(_QWORD *)v196 = v278;
                    v196[1] = v192;
                    v197 = *(_QWORD *)(v180 + 32);
                    v196[2] = *(double *)(v197 + 8);
                    *(_QWORD *)(v197 + 8) = v196;
                    goto LABEL_328;
                  }
                  goto LABEL_334;
                case 4:
                  if (v178)
                  {
                    v279 = v181;
                    v198 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(_QWORD *)v198 = v279;
                    v198[1] = v192;
                    v198[2] = 0.0;
                    v199 = *(_QWORD *)(v178 + 32);
                    *(_QWORD *)(*(_QWORD *)(v199 + 16) + 16) = v198;
                    *(_QWORD *)(v199 + 16) = v198;
                    goto LABEL_325;
                  }
                  goto LABEL_334;
                case 6:
                  if (v178 && v180)
                  {
                    v280 = v181;
                    v200 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(_QWORD *)v200 = v280;
                    v200[1] = v192;
                    v200[2] = 0.0;
                    v201 = *(_QWORD *)(v178 + 32);
                    *(_QWORD *)(*(_QWORD *)(v201 + 16) + 16) = v200;
                    *(_QWORD *)(v201 + 16) = v200;
                    merge_left(v178, v180, (uint64_t)v285);
                    goto LABEL_321;
                  }
                  goto LABEL_334;
                case 7:
                case 8:
                  v193 = *v169;
                  goto LABEL_322;
                case 9:
                  if (v178 && v180)
                  {
                    v280 = v181;
                    v202 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(_QWORD *)v202 = v280;
                    v202[1] = v192;
                    v203 = *(_QWORD *)(v178 + 32);
                    v202[2] = *(double *)(v203 + 8);
                    *(_QWORD *)(v203 + 8) = v202;
                    merge_right(v178, v180, (uint64_t)v285);
LABEL_321:
                    v193 = v173;
                    *(_QWORD *)&v181 = v280;
LABEL_322:
                    add_local_min(&v285, v193, *(double *)&v181, v192);
                    *v179 = *(_QWORD *)(v173 + 112);
                  }
                  goto LABEL_334;
                case 0xB:
                  if (v178)
                  {
                    v281 = v181;
                    v204 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(_QWORD *)v204 = v281;
                    v204[1] = v192;
                    v205 = *(_QWORD *)(v178 + 32);
                    v204[2] = *(double *)(v205 + 8);
                    *(_QWORD *)(v205 + 8) = v204;
LABEL_325:
                    *v179 = v178;
                    *v177 = 0;
                  }
                  goto LABEL_334;
                case 0xD:
                  if (!v180)
                    goto LABEL_334;
                  v282 = v181;
                  v206 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                  *(_QWORD *)v206 = v282;
                  v206[1] = v192;
                  v206[2] = 0.0;
                  v207 = *(_QWORD *)(v180 + 32);
                  *(_QWORD *)(*(_QWORD *)(v207 + 16) + 16) = v206;
                  *(_QWORD *)(v207 + 16) = v206;
LABEL_328:
                  *v177 = v180;
                  break;
                case 0xE:
                  if (!v178 || !v180)
                    goto LABEL_334;
                  v283 = v181;
                  v208 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                  *(_QWORD *)v208 = v283;
                  v208[1] = v192;
                  v208[2] = 0.0;
                  v209 = *(_QWORD *)(v178 + 32);
                  *(_QWORD *)(*(_QWORD *)(v209 + 16) + 16) = v208;
                  *(_QWORD *)(v209 + 16) = v208;
                  merge_left(v178, v180, (uint64_t)v285);
LABEL_332:
                  *v177 = 0;
                  break;
                default:
                  goto LABEL_334;
              }
              *v179 = 0;
LABEL_334:
              if (*(_DWORD *)(v173 + 76))
                *(_DWORD *)(v174 + 92) = *(_DWORD *)(v174 + 92) == 0;
              if (*(_DWORD *)(v174 + 76))
                *(_DWORD *)(v173 + 92) = *(_DWORD *)(v173 + 92) == 0;
              if (*(_DWORD *)(v173 + 80))
                *(_DWORD *)(v174 + 96) = *(_DWORD *)(v174 + 96) == 0;
              if (*(_DWORD *)(v174 + 80))
                *(_DWORD *)(v173 + 96) = *(_DWORD *)(v173 + 96) == 0;
              v170 = *(_QWORD *)(v173 + 128);
              v210 = *(_QWORD *)(v174 + 136);
              if (v210)
                *(_QWORD *)(v210 + 128) = v173;
              if (*(_DWORD *)(v173 + 100) == 1)
              {
                while (1)
                {
                  v170 = *(_QWORD *)(v170 + 128);
                  if (!v170)
                    break;
                  if (*(_DWORD *)(v170 + 100) != 2)
                    goto LABEL_349;
                }
LABEL_256:
                v170 = 0;
                *(_QWORD *)(v52 + 128) = v174;
                *(_QWORD *)(v174 + 136) = v52;
                v171 = *(_QWORD *)(v173 + 136);
                v52 = v171;
                if (!v171)
                  goto LABEL_353;
                goto LABEL_352;
              }
              if (!v170)
                goto LABEL_256;
LABEL_349:
              v211 = *(_QWORD *)(v170 + 136);
              if (!v211)
                MEMORY[0x80] = v174;
              *(_QWORD *)(v174 + 136) = v211;
              *(_QWORD *)(v170 + 136) = *(_QWORD *)(v173 + 136);
              v171 = *(_QWORD *)(v173 + 136);
              if (!v171)
                goto LABEL_353;
LABEL_352:
              *(_QWORD *)(v171 + 128) = v170;
LABEL_353:
              v212 = *(_QWORD *)(v174 + 136);
              if (v212)
                *(_QWORD *)(v212 + 128) = v174;
              *(_QWORD *)(v173 + 136) = v210;
              v169 = (uint64_t *)v169[4];
              if (!v169)
                goto LABEL_356;
            }
            if (!*(_DWORD *)(v173 + 80))
              goto LABEL_334;
            v176 = *(_DWORD *)(v174 + 76);
            if (v176)
            {
              v177 = (uint64_t *)(v173 + 112);
              v178 = *(_QWORD *)(v173 + 112);
              v179 = (uint64_t *)(v174 + 112);
              v180 = *(_QWORD *)(v174 + 112);
              v181 = *((_OWORD *)v169 + 1);
              v182 = *(_DWORD *)(v174 + 92);
            }
            else
            {
              if (!*(_DWORD *)(v174 + 80))
                goto LABEL_334;
              v177 = (uint64_t *)(v173 + 112);
              v178 = *(_QWORD *)(v173 + 112);
              v179 = (uint64_t *)(v174 + 112);
              v180 = *(_QWORD *)(v174 + 112);
              v181 = *((_OWORD *)v169 + 1);
              v176 = *(_DWORD *)(v173 + 92);
              if (!v176)
              {
                v172 = 0;
                goto LABEL_270;
              }
              v176 = 0;
LABEL_262:
              v182 = *(_DWORD *)(v174 + 92);
            }
            v172 = v182 != 0;
            goto LABEL_270;
          }
LABEL_356:
          if (v52)
          {
            v213 = v52;
            do
            {
              v214 = *(_QWORD *)(v52 + 136);
              v215 = *(_QWORD *)(v52 + 152);
              v216 = *(_QWORD *)(v52 + 112);
              if (*(double *)(v52 + 40) != v57 || v215 == 0)
              {
                *(_QWORD *)(v52 + 120) = v216;
                *(_DWORD *)(v52 + 104) = *(_DWORD *)(v52 + 100);
                *(_QWORD *)(v52 + 84) = *(_QWORD *)(v52 + 76);
                *(_QWORD *)(v52 + 48) = *(_QWORD *)(v52 + 56);
                v218 = v213;
              }
              else
              {
                *(_QWORD *)(v215 + 120) = v216;
                *(_DWORD *)(v215 + 104) = *(_DWORD *)(v52 + 100);
                *(_DWORD *)(v215 + 84) = *(_DWORD *)(v52 + 76);
                *(_DWORD *)(v215 + 88) = *(_DWORD *)(v52 + 80);
                v219 = *(_QWORD *)(v52 + 128);
                v218 = v215;
                if (v219)
                {
                  *(_QWORD *)(v219 + 136) = v215;
                  v218 = v213;
                }
                if (v214)
                  *(_QWORD *)(v214 + 128) = v215;
                *(_QWORD *)(v215 + 128) = v219;
                *(_QWORD *)(v215 + 136) = v214;
                v213 = v218;
              }
              *(_QWORD *)(v52 + 112) = 0;
              v52 = v214;
            }
            while (v214);
          }
          else
          {
            v218 = 0;
          }
          v287 = v218;
          v52 = v218;
          v53 = v273;
          v51 = v274;
        }
        while (v273 < v274);
        v220 = v285;
        PolygonFromPath = v266;
        *((_QWORD *)v266 + 1) = 0;
        *((_QWORD *)v266 + 2) = 0;
        v4 = v263;
        a1 = v264;
        v9 = v270;
        if (v220)
        {
          v221 = 0;
          v222 = v220;
          while (1)
          {
            if (*(_DWORD *)v222)
            {
              v223 = v222[4];
              v224 = *(_QWORD **)(v223 + 8);
              if (!v224)
                goto LABEL_382;
              v225 = -1;
              v226 = *(_QWORD *)(v223 + 8);
              do
              {
                v227 = v225;
                v226 = *(_QWORD *)(v226 + 16);
                ++v225;
              }
              while (v226);
              if (v225 <= 1)
              {
                do
                {
                  v228 = (_QWORD *)v224[2];
                  free(v224);
                  v224 = v228;
                }
                while (v228);
LABEL_382:
                *(_DWORD *)v222 = 0;
                goto LABEL_383;
              }
              *(_DWORD *)v222 = v227 + 2;
              ++v221;
            }
LABEL_383:
            v222 = (_QWORD *)v222[3];
            if (!v222)
            {
              *v266 = v221;
              if (v221 <= 0)
              {
                do
                {
                  v231 = (_QWORD *)v220[3];
                  free(v220);
                  v220 = v231;
                }
                while (v231);
              }
              else
              {
                *((_QWORD *)v266 + 1) = malloc_type_malloc(4 * v221, 0x100004052888210uLL);
                v229 = *v266;
                if ((_DWORD)v229)
                  v230 = malloc_type_malloc(16 * v229, 0x1020040D5A9D86FuLL);
                else
                  v230 = 0;
                v232 = 0;
                *((_QWORD *)v266 + 2) = v230;
                do
                {
                  v233 = (_QWORD *)v220[3];
                  if (*(_DWORD *)v220)
                  {
                    v234 = v220[4];
                    *(_DWORD *)(*((_QWORD *)v266 + 1) + 4 * v232) = *(_DWORD *)(v234 + 4);
                    v235 = *(int *)v220;
                    v236 = *((_QWORD *)v266 + 2);
                    *(_DWORD *)(v236 + 16 * v232) = v235;
                    if ((_DWORD)v235)
                    {
                      v237 = malloc_type_malloc(16 * v235, 0x1000040451B5BE8uLL);
                      v238 = *((_QWORD *)v266 + 2) + 16 * v232;
                      *(_QWORD *)(v238 + 8) = v237;
                      LODWORD(v235) = *(_DWORD *)v238;
                      v234 = v220[4];
                    }
                    else
                    {
                      *(_QWORD *)(v236 + 16 * v232 + 8) = 0;
                    }
                    v239 = *(_QWORD **)(v234 + 8);
                    if (v239)
                    {
                      v240 = 16 * (int)v235 - 16;
                      do
                      {
                        v241 = (_QWORD *)v239[2];
                        *(_OWORD *)(*(_QWORD *)(*((_QWORD *)v266 + 2) + 16 * v232 + 8) + v240) = *(_OWORD *)v239;
                        free(v239);
                        v240 -= 16;
                        v239 = v241;
                      }
                      while (v241);
                    }
                    ++v232;
                    v9 = v270;
                  }
                  free(v220);
                  v220 = v233;
                }
                while (v233);
              }
LABEL_402:
              v242 = v288;
              if (v288)
              {
                do
                {
                  v243 = (_QWORD *)v242[4];
                  free(v242);
                  v242 = v243;
                }
                while (v243);
              }
              v244 = v286;
              v7 = v265;
              v8 = v268;
              if (v286)
              {
                do
                {
                  v245 = (_QWORD *)v244[2];
                  free(v244);
                  v244 = v245;
                }
                while (v245);
              }
              if (v267)
                free(v267);
              if (v269)
                free(v269);
              v11 = v271;
              v50 = v272;
              if (v272)
              {
LABEL_411:
                free(v50);
                v11 = v271;
              }
              goto LABEL_412;
            }
          }
        }
      }
      *PolygonFromPath = 0;
      goto LABEL_402;
    }
    *PolygonFromPath = 0;
    *((_QWORD *)PolygonFromPath + 1) = 0;
    *((_QWORD *)PolygonFromPath + 2) = 0;
    if (v45)
    {
      v49 = v46;
      free(v45);
      v46 = v49;
      v11 = v271;
    }
    if (v46)
    {
      v50 = v46;
      goto LABEL_411;
    }
LABEL_412:
    v246 = v11;
    gpc_free_polygon((uint64_t)v11);
    free(v246);
    gpc_free_polygon((uint64_t)v9);
    free(v9);
    ++v8;
  }
  while (v8 != v7);
  v247 = *PolygonFromPath;
  if ((_DWORD)v247)
  {
    for (k = 0; k < v247; ++k)
    {
      v249 = *((_QWORD *)PolygonFromPath + 2);
      v250 = (unsigned int *)(v249 + 16 * k);
      v251 = 0uLL;
      if (v249)
      {
        v252 = *v250;
        if ((_DWORD)v252)
        {
          v253 = *(float64x2_t **)(v249 + 16 * k + 8);
          v254 = *v253;
          if ((_DWORD)v252 == 1)
          {
            v255 = *v253;
          }
          else
          {
            v256 = v252 - 1;
            v257 = v253 + 1;
            v255 = v254;
            do
            {
              v258 = *v257++;
              v255 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v255, v258), (int8x16_t)v258, (int8x16_t)v255);
              v254 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v258, v254), (int8x16_t)v258, (int8x16_t)v254);
              --v256;
            }
            while (v256);
          }
          v251 = vsubq_f64(v254, v255);
        }
      }
      if (v251.f64[0] > 0.01 || v251.f64[1] > 0.01)
      {
        v259 = *v250;
        if ((int)*v250 >= 1)
        {
          CGPathMoveToPoint(a1, 0, **(CGFloat **)(v249 + 16 * k + 8), *(CGFloat *)(*(_QWORD *)(v249 + 16 * k + 8) + 8));
          v259 = *v250;
        }
        if (v259 >= 2)
        {
          v260 = 0;
          v261 = (_QWORD *)(v249 + 16 * k + 8);
          v262 = 1;
          do
          {
            CGPathAddLineToPoint(a1, 0, *(CGFloat *)(*v261 + v260 + 16), *(CGFloat *)(*v261 + v260 + 24));
            ++v262;
            v260 += 16;
          }
          while (v262 < *v250);
        }
        CGPathCloseSubpath(a1);
        v247 = *PolygonFromPath;
      }
    }
  }
  gpc_free_polygon((uint64_t)PolygonFromPath);
  free(PolygonFromPath);
}

int *createPolygonFromPath(const CGPath *a1)
{
  const CGPath *Mutable;
  unsigned int v3;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  int *v8;
  const CGPath *info;
  void *v11;
  int *v12;
  CGRect PathBoundingBox;
  CGRect v14;

  LOBYTE(info) = 1;
  if (a1)
  {
    CGPathApply(a1, &info, (CGPathApplierFunction)elementIsFlat);
    if ((_BYTE)info)
    {
      CFRetain(a1);
      Mutable = a1;
    }
    else
    {
      Mutable = CGPathCreateMutable();
      info = Mutable;
      v11 = (void *)0x3FE3333333333333;
      CGPathApply(a1, &info, (CGPathApplierFunction)addFlattenedElement);
      if (!Mutable)
        goto LABEL_9;
    }
    LODWORD(info) = 0;
    CGPathApply(Mutable, &info, (CGPathApplierFunction)countElements);
    v3 = info;
    if (info < 0x2711)
      goto LABEL_10;
    CFRelease(Mutable);
    PathBoundingBox = CGPathGetPathBoundingBox(a1);
    x = PathBoundingBox.origin.x;
    y = PathBoundingBox.origin.y;
    width = PathBoundingBox.size.width;
    height = PathBoundingBox.size.height;
    Mutable = CGPathCreateMutable();
    v14.origin.x = x;
    v14.origin.y = y;
    v14.size.width = width;
    v14.size.height = height;
    CGPathAddRect(Mutable, 0, v14);
    if (Mutable)
    {
      LODWORD(info) = 0;
      CGPathApply(Mutable, &info, (CGPathApplierFunction)countElements);
      v3 = info;
      goto LABEL_10;
    }
  }
  else
  {
    Mutable = 0;
  }
LABEL_9:
  v3 = 0;
LABEL_10:
  info = 0;
  v11 = 0;
  v8 = (int *)malloc_type_malloc(0x18uLL, 0x1030040B05087B7uLL);
  v12 = v8;
  *v8 = 0;
  *((_QWORD *)v8 + 1) = 0;
  *((_QWORD *)v8 + 2) = 0;
  if (v3)
  {
    LODWORD(info) = 0;
    v11 = malloc_type_calloc(v3, 0x10uLL, 0x1000040451B5BE8uLL);
    CGPathApply(Mutable, &info, (CGPathApplierFunction)addVertex);
    if ((int)info >= 2)
      gpc_add_contour(v12, (int *)&info);
    free(v11);
  }
  if (Mutable)
    CFRelease(Mutable);
  return v12;
}

void addVertex(int *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  switch(*(_DWORD *)a2)
  {
    case 0:
      if (*a1 >= 2)
        gpc_add_contour(*((int **)a1 + 2), a1);
      *(_OWORD *)*((_QWORD *)a1 + 1) = *(_OWORD *)*(_QWORD *)(a2 + 8);
      goto LABEL_9;
    case 1:
      v4 = *((_QWORD *)a1 + 1);
      v5 = *a1;
      *a1 = v5 + 1;
      v6 = *(_OWORD *)*(_QWORD *)(a2 + 8);
      goto LABEL_11;
    case 2:
      v4 = *((_QWORD *)a1 + 1);
      v5 = *a1;
      *a1 = v5 + 1;
      v6 = *(_OWORD *)(*(_QWORD *)(a2 + 8) + 16);
      goto LABEL_11;
    case 3:
      v4 = *((_QWORD *)a1 + 1);
      v5 = *a1;
      *a1 = v5 + 1;
      v6 = *(_OWORD *)(*(_QWORD *)(a2 + 8) + 32);
LABEL_11:
      *(_OWORD *)(v4 + 16 * v5) = v6;
      break;
    case 4:
      if (*a1 >= 2)
      {
        gpc_add_contour(*((int **)a1 + 2), a1);
LABEL_9:
        *a1 = 1;
      }
      break;
    default:
      return;
  }
}

uint64_t countSubpaths(uint64_t result, _DWORD *a2)
{
  if ((*a2 | 4) == 4)
  {
    *(_BYTE *)(result + 4) = 1;
  }
  else if (*(_BYTE *)(result + 4))
  {
    ++*(_DWORD *)result;
    *(_BYTE *)(result + 4) = 0;
  }
  return result;
}

void createSubpaths(uint64_t a1, int *a2)
{
  unsigned int v4;
  uint64_t v5;
  CGPath *Mutable;
  int v7;
  CGPath *v8;
  CGFloat *v9;

  if (*a2 == 4)
  {
    if (!*(_BYTE *)(a1 + 32))
    {
      v4 = *(_DWORD *)(a1 + 28);
      if (v4 <= *(_DWORD *)(a1 + 24))
        CGPathCloseSubpath(*(CGMutablePathRef *)(*(_QWORD *)a1 + 8 * (v4 - 1)));
      goto LABEL_4;
    }
  }
  else
  {
    if (!*a2)
    {
      *(_OWORD *)(a1 + 8) = *(_OWORD *)*((_QWORD *)a2 + 1);
LABEL_4:
      *(_BYTE *)(a1 + 32) = 1;
      return;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 28);
    if (*(_BYTE *)(a1 + 32))
    {
      if (v5 < *(_DWORD *)(a1 + 24))
      {
        Mutable = CGPathCreateMutable();
        CGPathMoveToPoint(Mutable, 0, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16));
        v5 = *(unsigned int *)(a1 + 28);
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v5) = Mutable;
      }
      LODWORD(v5) = v5 + 1;
      *(_DWORD *)(a1 + 28) = v5;
      *(_BYTE *)(a1 + 32) = 0;
    }
    if (v5 <= *(_DWORD *)(a1 + 24))
    {
      v7 = *a2;
      if (*a2 == 3)
      {
        v8 = *(CGPath **)(*(_QWORD *)a1 + 8 * (v5 - 1));
        v9 = (CGFloat *)*((_QWORD *)a2 + 1);
        CGPathAddCurveToPoint(v8, 0, *v9, v9[1], v9[2], v9[3], v9[4], v9[5]);
      }
      else if (v7 == 2)
      {
        CGPathAddQuadCurveToPoint(*(CGMutablePathRef *)(*(_QWORD *)a1 + 8 * (v5 - 1)), 0, **((CGFloat **)a2 + 1), *(CGFloat *)(*((_QWORD *)a2 + 1) + 8), *(CGFloat *)(*((_QWORD *)a2 + 1) + 16), *(CGFloat *)(*((_QWORD *)a2 + 1) + 24));
      }
      else if (v7 == 1)
      {
        CGPathAddLineToPoint(*(CGMutablePathRef *)(*(_QWORD *)a1 + 8 * (v5 - 1)), 0, **((CGFloat **)a2 + 1), *(CGFloat *)(*((_QWORD *)a2 + 1) + 8));
      }
    }
  }
}

char *CGClipStrokeCreate(const CGAffineTransform *a1, unsigned __int8 a2, __int16 a3, char a4, char a5, unsigned int *a6, double a7, double a8, double a9)
{
  char *result;
  const CGAffineTransform *v19;
  __int128 v20;
  __int128 v21;
  unsigned int v22;

  result = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
  *(_DWORD *)result = 1;
  v19 = &CGAffineTransformIdentity;
  if (a1)
    v19 = a1;
  v21 = *(_OWORD *)&v19->c;
  v20 = *(_OWORD *)&v19->tx;
  *(_OWORD *)(result + 8) = *(_OWORD *)&v19->a;
  *(_OWORD *)(result + 24) = v21;
  *(_OWORD *)(result + 40) = v20;
  *((double *)result + 7) = a7;
  *((_WORD *)result + 32) = a2 | (unsigned __int16)(a3 << 8);
  *((double *)result + 9) = a8;
  result[66] = a4;
  result[67] = a5;
  if (a6)
  {
    do
      v22 = __ldxr(a6);
    while (__stxr(v22 + 1, a6));
  }
  *((_QWORD *)result + 10) = a6;
  *((double *)result + 11) = a9;
  return result;
}

char *CGClipStrokeCreateWithGState(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 128);
  return CGClipStrokeCreate((const CGAffineTransform *)(a1 + 24), *(_WORD *)(v1 + 2), *(__int16 *)(v1 + 2) >> 8, *(_BYTE *)(v1 + 1), HIBYTE(*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4)) & 1, *(unsigned int **)(v1 + 32), *(double *)(v1 + 8), *(double *)(v1 + 16), *(double *)(*(_QWORD *)(a1 + 144) + 8));
}

unsigned int *CGClipStrokeCreateCopy(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

unsigned int *CGClipStrokeRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

char *CGClipStrokeCreateCopyWithTransform(uint64_t a1, const CGAffineTransform *a2)
{
  return CGClipStrokeCreate(a2, *(_WORD *)(a1 + 64), *(__int16 *)(a1 + 64) >> 8, *(_BYTE *)(a1 + 66), *(_BYTE *)(a1 + 67), *(unsigned int **)(a1 + 80), *(double *)(a1 + 56), *(double *)(a1 + 72), *(double *)(a1 + 88));
}

void CGClipStrokeRelease(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if (a1)
  {
    do
    {
      v2 = __ldxr(a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, a1));
    if (!v3)
    {
      v4 = (unsigned int *)*((_QWORD *)a1 + 10);
      if (v4)
      {
        do
        {
          v5 = __ldxr(v4);
          v6 = v5 - 1;
        }
        while (__stxr(v6, v4));
        if (!v6)
          free(v4);
      }
      free(a1);
    }
  }
}

BOOL CGClipStrokeEqualToClipStroke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    if (*(double *)(a1 + 8) != *(double *)(a2 + 8))
      return 0;
    v2 = 0;
    if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 16), *(float64x2_t *)(a2 + 16)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)(a2 + 32)))), 0xFuLL))) & 1) != 0&& *(double *)(a1 + 48) == *(double *)(a2 + 48))
    {
      if (*(double *)(a1 + 56) != *(double *)(a2 + 56)
        || *(unsigned __int16 *)(a1 + 64) != *(unsigned __int16 *)(a2 + 64)
        || *(double *)(a1 + 72) != *(double *)(a2 + 72)
        || *(unsigned __int8 *)(a1 + 66) != *(unsigned __int8 *)(a2 + 66)
        || *(unsigned __int8 *)(a1 + 67) != *(unsigned __int8 *)(a2 + 67)
        || *(double *)(a1 + 88) != *(double *)(a2 + 88))
      {
        return 0;
      }
      return !CGDashEqualToDash(*(_QWORD *)(a1 + 80), *(_QWORD *)(a2 + 80));
    }
  }
  return v2;
}

__n128 CGClipStrokeGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  const CGAffineTransform *v2;
  __int128 v3;
  __n128 result;

  v2 = (const CGAffineTransform *)(a1 + 8);
  if (!a1)
    v2 = &CGAffineTransformIdentity;
  v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

double CGClipStrokeGetLineWidth(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 56);
  else
    return 0.0;
}

uint64_t CGClipStrokeGetLineCap(uint64_t result)
{
  if (result)
    return *(char *)(result + 64);
  return result;
}

uint64_t CGClipStrokeGetLineJoin(uint64_t result)
{
  if (result)
    return *(char *)(result + 65);
  return result;
}

double CGClipStrokeGetMiterLimit(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 72);
  else
    return 0.0;
}

BOOL CGClipStrokeGetStrokeAdjust(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 66) != 0;
  return result;
}

BOOL CGClipStrokeGetShouldAntialias(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 67) != 0;
  return result;
}

uint64_t CGClipStrokeGetDash(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 80);
  return result;
}

double CGClipStrokeGetFlatness(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 88);
  else
    return 0.0;
}

uint64_t CGClipStrokeCreateStrokedPath(uint64_t a1, char *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v10;
  uint64_t v11;
  char *DashedPath;
  uint64_t StrokedPath;

  if (!cf)
    return 0;
  if (!CGPathDisableTypeValidation)
  {
    v10 = CFGetTypeID(cf);
    if (v10 != CGPathGetTypeID())
      return 0;
  }
  v11 = *(_QWORD *)(a1 + 80);
  DashedPath = cf;
  if (v11)
    DashedPath = (char *)CGPathCreateDashedPath(cf, (_anonymous_namespace_ *)(a1 + 8), (const double *)(v11 + 24), *(_QWORD *)(v11 + 16), a5, a6, a7, a8, *(double *)(v11 + 8));
  StrokedPath = CGPathCreateStrokedPath(DashedPath, (_anonymous_namespace_ *)(a1 + 8), (char)*(_WORD *)(a1 + 64), (*(__int16 *)(a1 + 64) >> 8), a5, a6, a7, a8, *(double *)(a1 + 56), *(double *)(a1 + 72), *(double *)(a1 + 88));
  if (DashedPath != cf && DashedPath)
    CFRelease(DashedPath);
  return StrokedPath;
}

uint64_t CGPDFDocumentGetXRef(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 16);
    if (v1)
      return **(_QWORD **)(v1 + 16);
    else
      return 0;
  }
  return result;
}

uint64_t CGPDFXRefGetEntry(uint64_t result, unint64_t a2, unsigned __int16 a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *object_offset;
  uint64_t v11;

  if (!result)
    return result;
  if (!a4)
  {
    pdf_error("Output parameter is NULL\n");
    return 0;
  }
  v7 = *(_QWORD *)(result + 16);
  if (!v7)
  {
    result = *(_QWORD *)(result + 8);
    if (result)
      return CGPDFXRefStreamGetEntry(result, a2, a3, a4);
    return result;
  }
  v8 = *(_QWORD **)(v7 + 8);
  if (!v8)
    return 0;
  while (1)
  {
    v9 = v8[1];
    object_offset = xref_table_get_object_offset(*(_QWORD **)(v9 + 40), a2, a3);
    if (object_offset)
    {
      *(_DWORD *)a4 = 0;
      *(_QWORD *)(a4 + 8) = object_offset;
      *(_BYTE *)(a4 + 24) = 1;
      *(_WORD *)(a4 + 26) = a3;
    }
    v11 = *(_QWORD *)(v9 + 32);
    if (v11)
    {
      if (CGPDFXRefStreamGetEntry(v11, a2, a3, a4))
        break;
    }
    v8 = (_QWORD *)*v8;
    if (!v8)
      return 0;
  }
  return 1;
}

uint64_t CGPDFXRefPrint(uint64_t a1, FILE *__stream)
{
  uint64_t v4;
  FILE *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *i;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  FILE *v16;
  uint64_t v17;
  _QWORD *v18;

  fwrite("xref\n", 5uLL, 1uLL, __stream);
  v4 = *(_QWORD *)(a1 + 16);
  v16 = __stream;
  if (v4)
  {
    if (__stream)
      v5 = __stream;
    else
      v5 = (FILE *)*MEMORY[0x1E0C80C20];
    v6 = *(_QWORD **)(v4 + 8);
    if (v6)
    {
      do
      {
        v18 = v6;
        v7 = v6[1];
        fprintf(v5, "xref table @ offset %lld:\n", *(_QWORD *)(v7 + 8));
        v17 = v7;
        for (i = *(_QWORD **)(v7 + 40); i; i = (_QWORD *)*i)
        {
          v9 = (_QWORD *)i[1];
          fprintf(v5, "  %ld %ld\n", *v9, v9[1]);
          if ((uint64_t)v9[1] >= 1)
          {
            v10 = 0;
            v11 = v9 + 3;
            do
            {
              fprintf(v5, "    %.10lld ", v11[v10]);
              v12 = v9[2];
              if (v12)
                LODWORD(v12) = *(unsigned __int16 *)(v12 + 2 * v10);
              fprintf(v5, "%.5hu ", v12);
              if (v11[v10])
                v13 = 110;
              else
                v13 = 102;
              fprintf(v5, "%c \n", v13);
              ++v10;
            }
            while (v10 < v9[1]);
          }
        }
        CGPDFDictionaryPrintWithIndent(*(_QWORD *)(v17 + 16), v5, 0);
        fputc(10, v5);
        v14 = *(_QWORD *)(v17 + 32);
        if (v14)
          CGPDFXRefStreamPrint(v14, (uint64_t)v5);
        v6 = (_QWORD *)*v18;
      }
      while (*v18);
    }
  }
  else
  {
    CGPDFXRefStreamPrint(*(_QWORD *)(a1 + 8), (uint64_t)__stream);
  }
  return fputc(10, v16);
}

uint64_t CGPDFXRefEntryPrint(_DWORD *a1, FILE *a2)
{
  FILE *v3;
  const char *v4;
  const char *v5;

  if (a2)
    v3 = a2;
  else
    v3 = (FILE *)*MEMORY[0x1E0C80C20];
  fprintf(v3, "CGPDFXRefEntry (%p)\n", a1);
  if (*a1)
    v4 = "kCGPDFXRefEntryKindStream";
  else
    v4 = "kCGPDFXRefEntryKindOffset";
  fprintf(v3, "  kind: %s\n", v4);
  if (*a1 == 1)
    fprintf(v3, "  object_number = %lu, index = %ld\n");
  else
    fprintf(v3, "  offset = %lld\n");
  v5 = "true";
  if (!*((_BYTE *)a1 + 24))
    v5 = "false";
  return fprintf(v3, "  used = %s, generation = %hu\n", v5, *((unsigned __int16 *)a1 + 13));
}

__int128 *rips_s_super()
{
  return &_rips_class;
}

CGColorSpaceRef rips_s_ColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;

  v8 = *(_QWORD *)(a1 + 80);
  if (!v8)
    return (CGColorSpaceRef)rips_s_cs;
  if ((v8 & 0x8000000000000000) != 0)
    return CGTaggedColorGetColorSpace(v8, a2, a3, a4, a5, a6, a7, a8);
  return *(CGColorSpaceRef *)(v8 + 24);
}

uint64_t rips_s_BltImage(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  uint64_t v15;
  int v16;
  double v18;
  float v19;
  float v20;
  uint64_t v21;
  char *v22;
  uint64_t *v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  char *v34;
  char *v35;
  int *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _QWORD *Cache;
  __n128 v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  size_t v61;
  uint64_t v62;
  double *v63;
  unint64_t v64;
  double *v65;
  uint64_t v66;
  CGColorSpaceRef ColorSpace;
  CGColor *v68;
  CGColorSpaceRef v69;
  uint64_t v70;
  double *Components;
  _QWORD *v72;
  double *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  __int128 v82;
  __int128 v83;
  int *v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  double *v89;
  uint64_t v90;
  uint64_t *v91;
  double *v92;
  _QWORD v93[2];
  int32x4_t v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  uint64_t v99;
  _OWORD v100[3];
  __int128 v101;
  uint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  v14 = (uint64_t)a2;
  if (a2 || (v14 = a3) != 0)
    v15 = *(unsigned int *)(v14 + 52);
  else
    v15 = 3;
  v16 = *(_DWORD *)(a1 + 12);
  if ((v16 & 0x40) == 0)
  {
    if ((v16 & 0x1000) == 0)
      return RIPLayerBltImage((uint64_t)a2, a3, a4, (uint64_t)a5, a8, a6, a7, a8);
    return 1;
  }
  v94 = 0uLL;
  v93[1] = 0;
  v93[0] = 0;
  v18 = *(double *)(a8 + 48);
  v19 = *(float *)(a1 + 112);
  if (!a3
    || (v94 = vaddq_s32(*(int32x4_t *)(a1 + 96), *a5),
        CGSBoundsIntersection((int *)(a3 + 12), v94.i32, v93)))
  {
    v20 = v18;
    if ((float)(v19 * v20) <= 0.0039062
      || (a4 ? (v21 = a4) : (v21 = (uint64_t)a5),
          (v22 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, v21, 0, 0, v15, a6, a7, a8)) == 0))
    {
LABEL_71:
      if (!a3)
        goto LABEL_76;
      goto LABEL_72;
    }
    v23 = (uint64_t *)v22;
    v24 = *(_OWORD *)(a8 + 16);
    v100[0] = *(_OWORD *)a8;
    v100[1] = v24;
    v25 = *(_OWORD *)(a8 + 48);
    v100[2] = *(_OWORD *)(a8 + 32);
    v101 = v25;
    v26 = *(_QWORD *)(a8 + 64);
    LODWORD(v100[0]) = 1;
    v102 = v26;
    *(_QWORD *)&v101 = 0x3FF0000000000000;
    RIPLayerBltImage((uint64_t)v22, 0, a4, (uint64_t)a5, (uint64_t)v100, a6, a7, a8);
    v33 = *(float *)(a1 + 116);
    if (v33 >= 0.5)
      v34 = RIPLayerGaussianBlur((uint64_t)v23, v15, v27, v28, v29, v30, v31, v32, v33);
    else
      v34 = RIPLayerCreateWithLayer(*v23, (uint64_t *)((char *)v23 + 12), v23, v15);
    v35 = v34;
    if (!v34)
    {
LABEL_70:
      (*(void (**)(uint64_t *))(*v23 + 24))(v23);
      goto LABEL_71;
    }
    v36 = (int *)(v34 + 12);
    v37 = *((_DWORD *)v34 + 3);
    v38 = *(_DWORD *)(a1 + 88);
    if (v37 < 0)
    {
      if ((int)(0x80000000 - v37) > v38)
      {
LABEL_25:
        (*(void (**)(char *, int *))(*(_QWORD *)v34 + 24))(v34, v36);
        return 0;
      }
    }
    else if ((v37 ^ 0x7FFFFFFF) < v38)
    {
      goto LABEL_25;
    }
    v39 = *((_DWORD *)v34 + 4);
    v40 = *(_DWORD *)(a1 + 92);
    if (v39 < 0)
    {
      if ((int)(0x80000000 - v39) > v40)
        goto LABEL_25;
    }
    else if ((v39 ^ 0x7FFFFFFF) < v40)
    {
      goto LABEL_25;
    }
    *((_DWORD *)v34 + 3) = v38 + v37;
    *((_DWORD *)v34 + 4) = v40 + v39;
    if (a3)
      v41 = (int *)(a3 + 12);
    else
      v41 = (int *)(v34 + 12);
    if (!CGSBoundsIntersection(v41, v36, &v94))
    {
LABEL_69:
      (*(void (**)(char *))(*(_QWORD *)v35 + 24))(v35);
      goto LABEL_70;
    }
    v99 = 0;
    v97 = 0u;
    v98 = 0u;
    v96 = 0u;
    v95 = 0u;
    if (*(float *)(a1 + 120) != 0.0 || *(float *)(a1 + 124) != 1.0)
      RIPLayerResample((uint64_t)v35, (float *)(a1 + 120), v42, v43, v44, v45, v46, v47);
    if (v20 >= 0.99609
      && !*(_QWORD *)(a5[1].i64[0] + 88)
      && (*(_BYTE *)(a1 + 13) & 0x10) == 0
      && *(int *)a8 <= 2
      && (!a3 || !*(_QWORD *)(a3 + 56)))
    {
      RIPLayerMask(v35, v23, v42, v43, v44, v45, v46, v47);
    }
    v48 = *(_QWORD *)(a1 + 80);
    if (!v48)
    {
      if (default_shadow_color_predicate != -1)
        dispatch_once(&default_shadow_color_predicate, &__block_literal_global_2);
      v48 = default_shadow_color_shadow_color;
    }
    Cache = CGColorTransformGetCache(*(_QWORD **)(a8 + 16));
    if (Cache)
    {
      v51 = Cache[2];
      if (v51)
      {
        v52 = *(_QWORD *)(*(_QWORD *)(v51 + 24) + 40);
        if (v52 >> 61)
        {
          MEMORY[0x1E0C80A78](Cache, v50);
          v89 = (double *)&v86;
          v92 = 0;
LABEL_56:
          v66 = *(_QWORD *)(a8 + 16);
          v91 = &v87;
          v88 = v60;
          v90 = v66;
          if (v48)
          {
            if ((v48 & 0x8000000000000000) != 0)
            {
              ColorSpace = CGTaggedColorGetColorSpace(v48, v53, v54, v55, v56, v57, v58, v59);
              v68 = (CGColor *)v48;
              v69 = ColorSpace;
            }
            else
            {
              v68 = (CGColor *)v48;
              v69 = *(CGColorSpaceRef *)(v48 + 24);
            }
          }
          else
          {
            v68 = 0;
            v69 = 0;
          }
          v70 = *(unsigned int *)(a8 + 8);
          Components = (double *)CGColorGetComponents(v68);
          v72 = v69;
          v73 = v92;
          if ((CGColorTransformConvertColorComponents(v90, v72, v70, Components, v92) & 1) != 0)
          {
            RIPColorCreateWithColor(*(_DWORD *)(a8 + 24), v73, v88, 1.0);
            v81 = v80;
          }
          else
          {
            v81 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
            *v81 = &ripc_class;
            v81[1] = 0;
            v81[2] = 0;
            v81[3] = 0;
            *((_DWORD *)v81 + 39) = 1065353216;
          }
          if (v73 != v89)
            free(v73);
          v82 = *(_OWORD *)(a8 + 48);
          v97 = *(_OWORD *)(a8 + 32);
          v98 = v82;
          v99 = *(_QWORD *)(a8 + 64);
          v83 = *(_OWORD *)a8;
          v96 = *(_OWORD *)(a8 + 16);
          v95 = v83;
          *(double *)&v98 = (float)(v19 * v20);
          if ((*(_BYTE *)(a1 + 13) & 0x10) != 0)
            RIPLayerDefine((uint64_t)a2, (__n128 *)&v94, v74, v75, v76, v77, v78, v79);
          RIPLayerBltShape(a2, a3, v94.i32, (uint64_t)v35, (uint64_t)v81, 0, (uint64_t)&v95, v79);
          free(v81);
          goto LABEL_69;
        }
        Cache = (_QWORD *)(8 * v52);
      }
      else
      {
        Cache = 0;
      }
    }
    v61 = MEMORY[0x1E0C80A78](Cache, v50);
    v89 = (double *)((char *)&v87 - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v60 <= 0x1FFFFFFFFFFFFFFELL)
      v63 = (double *)((char *)&v87 - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0));
    else
      v63 = 0;
    v92 = v63;
    if (v60 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022)
    {
      v91 = (uint64_t *)v48;
      v64 = v60;
      v65 = (double *)malloc_type_malloc(v61, 0x17B18C98uLL);
      v60 = v64;
      v48 = (unint64_t)v91;
      v92 = v65;
    }
    goto LABEL_56;
  }
LABEL_72:
  if (a4)
    v84 = (int *)a4;
  else
    v84 = (int *)a5;
  if (!CGSBoundsIntersection((int *)(a3 + 12), v84, v93))
    return 1;
LABEL_76:
  if ((*(_BYTE *)(a1 + 13) & 0x10) != 0)
    return 1;
  if (a3)
    v85 = v93;
  else
    v85 = (_QWORD *)a4;
  return RIPLayerBltImage((uint64_t)a2, a3, (uint64_t)v85, (uint64_t)a5, a8, a6, a7, a8);
}

void __default_shadow_color_block_invoke()
{
  CGColorSpace *DeviceGray;
  __int128 v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  DeviceGray = CGColorSpaceCreateDeviceGray();
  v1 = xmmword_184F7DAD8;
  default_shadow_color_shadow_color = (uint64_t)CGColorCreate(DeviceGray, (const CGFloat *)&v1);
  CGColorSpaceRelease(DeviceGray);
}

void CGPDFPatternFinalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 144);
  if (v1)
    CFRelease(v1);
}

uint64_t path_iterator_dilator_create(unsigned int *a1, double a2, double a3)
{
  float *v6;
  float v7;
  float v8;
  uint64_t result;
  unsigned int v10;

  v6 = (float *)malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
  v7 = a2;
  *v6 = v7;
  v8 = a3;
  v6[3] = v8;
  v6[1] = 0.0;
  v6[4] = 0.0;
  *((_BYTE *)v6 + 28) = 1;
  v6[6] = 0.0;
  result = operator new();
  *(_QWORD *)(result + 8) = v6;
  *(_OWORD *)(result + 16) = path_iterator_dilator_create_callbacks;
  *(_OWORD *)(result + 32) = *(_OWORD *)&off_1E162CB10;
  if (a1)
  {
    do
      v10 = __ldxr(a1);
    while (__stxr(v10 + 1, a1));
  }
  *(_QWORD *)(result + 48) = a1;
  *(_DWORD *)result = 1;
  return result;
}

uint64_t path_dilator_begin(uint64_t result, uint64_t a2, _QWORD *a3)
{
  uint64_t (*v3)(_QWORD, uint64_t, _QWORD);

  *(_BYTE *)(result + 28) = 1;
  if (a3)
  {
    v3 = (uint64_t (*)(_QWORD, uint64_t, _QWORD))a3[2];
    if (v3)
      return v3(a3[1], a2, a3[6]);
  }
  return result;
}

void path_dilator_iterate(uint64_t a1, int a2, double *a3, uint64_t a4)
{
  double v5;
  double v6;
  float v7;
  float v8;
  float v9;
  double v10;
  double v11;
  double v12;
  float v13;
  double v14;
  double v15;
  double v16;

  switch(a2)
  {
    case 0:
      v6 = *a3;
      v5 = a3[1];
      if (!*(_BYTE *)(a1 + 28))
        addClosepath(a1, a4);
      v7 = v6;
      v8 = v5;
      *(float *)(a1 + 4) = v7;
      *(float *)(a1 + 8) = v7;
      *(float *)(a1 + 16) = v8;
      *(float *)(a1 + 20) = v8;
      return;
    case 1:
      addLine(a1, a4, *a3, a3[1]);
      return;
    case 2:
      v9 = (*a3 + *a3) / 3.0;
      v10 = a3[2];
      v11 = a3[3];
      v12 = v10 / 3.0 + v9;
      v13 = (a3[1] + a3[1]) / 3.0;
      v14 = (float)((float)(*(float *)(a1 + 4) / 3.0) + v9);
      v15 = (float)((float)(*(float *)(a1 + 16) / 3.0) + v13);
      v16 = v11 / 3.0 + v13;
      goto LABEL_8;
    case 3:
      v14 = *a3;
      v15 = a3[1];
      v12 = a3[2];
      v16 = a3[3];
      v10 = a3[4];
      v11 = a3[5];
LABEL_8:
      addCube(a1, a4, v14, v15, v12, v16, v10, v11);
      break;
    case 4:
      addClosepath(a1, a4);
      break;
    default:
      abort();
  }
}

void path_dilator_end(uint64_t a1, _QWORD *a2)
{
  void (*v3)(_QWORD, _QWORD);

  addClosepath(a1, (uint64_t)a2);
  if (a2)
  {
    v3 = (void (*)(_QWORD, _QWORD))a2[4];
    if (v3)
      v3(a2[1], a2[6]);
  }
}

void addClosepath(uint64_t a1, uint64_t a2)
{
  float v4;

  if (!*(_BYTE *)(a1 + 28))
  {
    v4 = addLine(a1, a2, *(float *)(a1 + 8), *(float *)(a1 + 20));
    if (a2)
      (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, float))(a2 + 24))(*(_QWORD *)(a2 + 8), 4, 0, *(_QWORD *)(a2 + 48), v4);
    *(_BYTE *)(a1 + 28) = 1;
  }
}

float addLine(uint64_t a1, uint64_t a2, double a3, double a4)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  BOOL v13;
  float v14;
  float v15;
  double v16;
  double v17;
  double v18;
  float v19;
  float result;
  double v21;
  double v22;

  v8 = *(float *)(a1 + 4);
  v9 = a3 - v8;
  v10 = *(float *)(a1 + 16);
  v11 = a4 - v10;
  if (v11 >= 0.0)
  {
    v12 = 0.0;
    if (v11 > 0.0)
      v12 = *(float *)a1;
  }
  else
  {
    v12 = -*(float *)a1;
  }
  v13 = v9 <= 0.0;
  if (v9 >= 0.0)
  {
    v14 = *(float *)(a1 + 12);
    v15 = 0.0;
    if (!v13)
      v15 = -v14;
  }
  else
  {
    v14 = *(float *)(a1 + 12);
    v15 = v14;
  }
  v16 = (float)((float)(v8 + v12) + *(float *)(a1 + 24));
  v17 = (float)((float)(v10 + v15) + v14);
  if (*(_BYTE *)(a1 + 28))
  {
    v21 = v16;
    v22 = v17;
    if (a2)
      (*(void (**)(_QWORD, _QWORD, double *, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), 0, &v21, *(_QWORD *)(a2 + 48));
    *(_BYTE *)(a1 + 28) = 0;
  }
  else
  {
    v21 = v16;
    v22 = v17;
    if (a2)
      (*(void (**)(_QWORD, uint64_t, double *, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), 1, &v21, *(_QWORD *)(a2 + 48));
  }
  v18 = v15 + a4 + *(float *)(a1 + 12);
  v21 = v12 + a3 + *(float *)(a1 + 24);
  v22 = v18;
  if (a2)
    (*(void (**)(_QWORD, uint64_t, double *, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), 1, &v21, *(_QWORD *)(a2 + 48));
  v19 = a3;
  *(float *)(a1 + 4) = v19;
  result = a4;
  *(float *)(a1 + 16) = result;
  return result;
}

uint64_t addCube(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;

  v11 = a1;
  v12 = *(float *)(a1 + 4);
  v13 = (a3 - a5) * a3 + a5 * (a5 - v12) + a7 * (v12 - a3);
  if (v13 >= 0.0)
  {
    v14 = *(float *)(a1 + 16);
    v15 = a7 - v12 + (a3 - a5) * 3.0;
    v16 = v12 + a5 + a3 * -2.0;
    if (v15 == 0.0)
    {
      if (v16 == 0.0)
        return addCubeMonotonicX(a1, a2, a3, a4, a5, a6, a7, a8);
      v17 = 2.0;
      v18 = (v12 - a3) * 0.5 / v16;
    }
    else if (v16 != 0.0 || (v17 = 0.0, v18 = 0.0, v13 != 0.0))
    {
      v19 = 1.0;
      if (v16 < 0.0)
        v19 = -1.0;
      v20 = -(v16 + v19 * sqrt(v13));
      v21 = v20 / v15;
      v22 = (a4 - v14) / v20;
      if (v21 >= v22)
        v18 = v22;
      else
        v18 = v21;
      if (v21 <= v22)
        v17 = v22;
      else
        v17 = v21;
    }
    v23 = 2.0;
    if (v18 < 1.0e-10)
    {
      v24 = v17;
    }
    else
    {
      v23 = v17;
      v24 = v18;
    }
    if (v24 >= 1.0e-10 && v24 <= 1.0)
    {
      if (1.0 - v23 >= 1.0e-10)
      {
        v40 = (v23 - v24) / (1.0 - v24);
        v41 = v12 + a3 * -2.0 + a5;
        v42 = v14 + a4 * -2.0 + a6;
        v43 = v12 + (v24 * ((a7 + (a5 - a3) * -3.0 - v12) * v24 + v41 * 3.0) + (a3 - v12) * 3.0) * v24;
        v44 = v14 + (v24 * ((a8 + (a6 - a4) * -3.0 - v14) * v24 + v42 * 3.0) + (a4 - v14) * 3.0) * v24;
        v51 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v24) + (a7 - a5) * -2.0) * (1.0 - v24);
        v45 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v24) + (a8 - a6) * -2.0) * (1.0 - v24);
        v46 = a7 - (a7 - a5) * (1.0 - v24);
        v47 = a8 - (a8 - a6) * (1.0 - v24);
        addCubeMonotonicX(a1, a2, v12 + (a3 - v12) * v24, v14 + (a4 - v14) * v24, v12 + (v41 * v24 + (a3 - v12) * 2.0) * v24, v14 + (v42 * v24 + (a4 - v14) * 2.0) * v24, v43, v44);
        v48 = a8 - v47;
        v35 = v43 + (v51 - v43) * v40;
        v36 = v44 + (v45 - v44) * v40;
        v49 = v46 + v43 + v51 * -2.0;
        v37 = v43 + (v40 * v49 + (v51 - v43) * 2.0) * v40;
        v50 = v47 + v44 + v45 * -2.0;
        v38 = v44 + (v40 * v50 + (v45 - v44) * 2.0) * v40;
        v29 = v43 + (v40 * (v40 * (a7 + (v46 - v51) * -3.0 - v43) + v49 * 3.0) + (v51 - v43) * 3.0) * v40;
        v30 = v44 + (v40 * (v40 * (a8 + (v47 - v45) * -3.0 - v44) + v50 * 3.0) + (v45 - v44) * 3.0) * v40;
        v31 = a7 + ((1.0 - v40) * (a7 + v46 * -2.0 + v51) + (a7 - v46) * -2.0) * (1.0 - v40);
        v32 = a8 + ((1.0 - v40) * (a8 + v47 * -2.0 + v45) + (a8 - v47) * -2.0) * (1.0 - v40);
        v33 = a7 - (a7 - v46) * (1.0 - v40);
        v34 = a8 - v48 * (1.0 - v40);
        a1 = v11;
      }
      else
      {
        v25 = v12 + a3 * -2.0 + a5;
        v26 = v12 + (v25 * v24 + (a3 - v12) * 2.0) * v24;
        v27 = v14 + a4 * -2.0 + a6;
        v28 = v14 + (v27 * v24 + (a4 - v14) * 2.0) * v24;
        v29 = v12 + (v24 * ((a7 + (a5 - a3) * -3.0 - v12) * v24 + v25 * 3.0) + (a3 - v12) * 3.0) * v24;
        v30 = v14 + (v24 * ((a8 + (a6 - a4) * -3.0 - v14) * v24 + v27 * 3.0) + (a4 - v14) * 3.0) * v24;
        v31 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v24) + (a7 - a5) * -2.0) * (1.0 - v24);
        v32 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v24) + (a8 - a6) * -2.0) * (1.0 - v24);
        v33 = a7 - (a7 - a5) * (1.0 - v24);
        v34 = a8 - (a8 - a6) * (1.0 - v24);
        v35 = v12 + (a3 - v12) * v24;
        v36 = v14 + (a4 - v14) * v24;
        v37 = v26;
        v38 = v28;
      }
      addCubeMonotonicX(a1, a2, v35, v36, v37, v38, v29, v30);
      a1 = v11;
      a3 = v31;
      a4 = v32;
      a5 = v33;
      a6 = v34;
    }
  }
  return addCubeMonotonicX(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t addCubeMonotonicX(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;

  v11 = a1;
  v12 = *(float *)(a1 + 16);
  v13 = (a4 - a6) * a4 + a6 * (a6 - v12) + a8 * (v12 - a4);
  if (v13 >= 0.0)
  {
    v14 = a8 - v12 + (a4 - a6) * 3.0;
    v15 = v12 + a6 + a4 * -2.0;
    if (v14 == 0.0)
    {
      if (v15 == 0.0)
        return addCubeMonotonic(a1, a2, a3, a4, a5, a6, a7, a8);
      v16 = 2.0;
      v17 = (v12 - a4) * 0.5 / v15;
    }
    else if (v15 != 0.0 || (v16 = 0.0, v17 = 0.0, v13 != 0.0))
    {
      v18 = 1.0;
      if (v15 < 0.0)
        v18 = -1.0;
      v19 = -(v15 + v18 * sqrt(v13));
      v20 = v19 / v14;
      v21 = (a4 - v12) / v19;
      if (v20 >= v21)
        v17 = v21;
      else
        v17 = v20;
      if (v20 <= v21)
        v16 = v21;
      else
        v16 = v20;
    }
    v22 = 2.0;
    if (v17 < 1.0e-10)
    {
      v23 = v16;
    }
    else
    {
      v22 = v16;
      v23 = v17;
    }
    if (v23 >= 1.0e-10 && v23 <= 1.0)
    {
      v24 = *(float *)(a1 + 4);
      if (1.0 - v22 >= 1.0e-10)
      {
        v40 = (v22 - v23) / (1.0 - v23);
        v41 = v24 + a3 * -2.0 + a5;
        v42 = v12 + a4 * -2.0 + a6;
        v43 = v24 + (v23 * ((a7 + (a5 - a3) * -3.0 - v24) * v23 + v41 * 3.0) + (a3 - v24) * 3.0) * v23;
        v44 = v12 + (v23 * ((a8 + (a6 - a4) * -3.0 - v12) * v23 + v42 * 3.0) + (a4 - v12) * 3.0) * v23;
        v51 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v23) + (a7 - a5) * -2.0) * (1.0 - v23);
        v45 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v23) + (a8 - a6) * -2.0) * (1.0 - v23);
        v46 = a7 - (a7 - a5) * (1.0 - v23);
        v47 = a8 - (a8 - a6) * (1.0 - v23);
        addCubeMonotonic(a1, a2, v24 + (a3 - v24) * v23, v12 + (a4 - v12) * v23, v24 + (v41 * v23 + (a3 - v24) * 2.0) * v23, v12 + (v42 * v23 + (a4 - v12) * 2.0) * v23, v43, v44);
        v48 = a8 - v47;
        v35 = v43 + (v51 - v43) * v40;
        v36 = v44 + (v45 - v44) * v40;
        v49 = v46 + v43 + v51 * -2.0;
        v37 = v43 + (v40 * v49 + (v51 - v43) * 2.0) * v40;
        v50 = v47 + v44 + v45 * -2.0;
        v38 = v44 + (v40 * v50 + (v45 - v44) * 2.0) * v40;
        v29 = v43 + (v40 * (v40 * (a7 + (v46 - v51) * -3.0 - v43) + v49 * 3.0) + (v51 - v43) * 3.0) * v40;
        v30 = v44 + (v40 * (v40 * (a8 + (v47 - v45) * -3.0 - v44) + v50 * 3.0) + (v45 - v44) * 3.0) * v40;
        v31 = a7 + ((1.0 - v40) * (a7 + v46 * -2.0 + v51) + (a7 - v46) * -2.0) * (1.0 - v40);
        v32 = a8 + ((1.0 - v40) * (a8 + v47 * -2.0 + v45) + (a8 - v47) * -2.0) * (1.0 - v40);
        v33 = a7 - (a7 - v46) * (1.0 - v40);
        v34 = a8 - v48 * (1.0 - v40);
        a1 = v11;
      }
      else
      {
        v25 = v24 + a3 * -2.0 + a5;
        v26 = v24 + (v25 * v23 + (a3 - v24) * 2.0) * v23;
        v27 = v12 + a4 * -2.0 + a6;
        v28 = v12 + (v27 * v23 + (a4 - v12) * 2.0) * v23;
        v29 = v24 + (v23 * ((a7 + (a5 - a3) * -3.0 - v24) * v23 + v25 * 3.0) + (a3 - v24) * 3.0) * v23;
        v30 = v12 + (v23 * ((a8 + (a6 - a4) * -3.0 - v12) * v23 + v27 * 3.0) + (a4 - v12) * 3.0) * v23;
        v31 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v23) + (a7 - a5) * -2.0) * (1.0 - v23);
        v32 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v23) + (a8 - a6) * -2.0) * (1.0 - v23);
        v33 = a7 - (a7 - a5) * (1.0 - v23);
        v34 = a8 - (a8 - a6) * (1.0 - v23);
        v35 = v24 + (a3 - v24) * v23;
        v36 = v12 + (a4 - v12) * v23;
        v37 = v26;
        v38 = v28;
      }
      addCubeMonotonic(a1, a2, v35, v36, v37, v38, v29, v30);
      a1 = v11;
      a3 = v31;
      a4 = v32;
      a5 = v33;
      a6 = v34;
    }
  }
  return addCubeMonotonic(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t addCubeMonotonic(uint64_t result, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  BOOL v21;
  float v22;
  float v23;
  double v24;
  double v25;
  double v26;
  double v27;
  float v28;
  float v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  uint64_t v36;

  v15 = result;
  v36 = *MEMORY[0x1E0C80C00];
  v16 = *(float *)(result + 4);
  v17 = a7 - v16;
  v18 = *(float *)(result + 16);
  v19 = a8 - v18;
  if (v19 >= 0.0)
  {
    v20 = 0.0;
    if (v19 > 0.0)
      v20 = *(float *)result;
  }
  else
  {
    v20 = -*(float *)result;
  }
  v21 = v17 <= 0.0;
  if (v17 >= 0.0)
  {
    v22 = *(float *)(result + 12);
    v23 = 0.0;
    if (!v21)
      v23 = -v22;
  }
  else
  {
    v22 = *(float *)(result + 12);
    v23 = v22;
  }
  v24 = (float)((float)(v16 + v20) + *(float *)(result + 24));
  v25 = (float)((float)(v18 + v23) + v22);
  if (*(_BYTE *)(result + 28))
  {
    v30 = v24;
    v31 = v25;
    if (a2)
      result = (*(uint64_t (**)(_QWORD, _QWORD, double *, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), 0, &v30, *(_QWORD *)(a2 + 48));
    *(_BYTE *)(v15 + 28) = 0;
  }
  else
  {
    v30 = v24;
    v31 = v25;
    if (a2)
      result = (*(uint64_t (**)(_QWORD, uint64_t, double *, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), 1, &v30, *(_QWORD *)(a2 + 48));
  }
  if (a2)
  {
    v26 = *(float *)(v15 + 12);
    v27 = *(float *)(v15 + 24);
    v30 = v20 + a3 + v27;
    v31 = v23 + a4 + v26;
    v32 = v20 + a5 + v27;
    v33 = v23 + a6 + v26;
    v34 = v20 + a7 + v27;
    v35 = v23 + a8 + v26;
    result = (*(uint64_t (**)(_QWORD, uint64_t, double *, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), 3, &v30, *(_QWORD *)(a2 + 48));
  }
  v28 = a7;
  *(float *)(v15 + 4) = v28;
  v29 = a8;
  *(float *)(v15 + 16) = v29;
  return result;
}

uint64_t path_iterator_orientation_create(unsigned int *a1)
{
  char *v2;
  _QWORD *v3;
  uint64_t result;
  unsigned int v5;

  v2 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
  v3 = malloc_type_malloc(0x200uLL, 0x95C2046AuLL);
  *v3 = 0;
  v3[1] = 0;
  v3[2] = v3 + 64;
  v3[3] = ((unint64_t)v3 + 55) & 0xFFFFFFFFFFFFFFF8;
  v3[4] = 0;
  v3[5] = 464;
  *(_QWORD *)v2 = v3;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  v2[48] = 1;
  result = operator new();
  *(_QWORD *)(result + 8) = v2;
  *(_OWORD *)(result + 16) = path_iterator_orientation_create_callbacks;
  *(_OWORD *)(result + 32) = *(_OWORD *)&off_1E162CB30;
  if (a1)
  {
    do
      v5 = __ldxr(a1);
    while (__stxr(v5 + 1, a1));
  }
  *(_QWORD *)(result + 48) = a1;
  *(_DWORD *)result = 1;
  return result;
}

uint64_t path_orientation_begin(uint64_t result, uint64_t a2, _QWORD *a3)
{
  uint64_t (*v3)(_QWORD, uint64_t, _QWORD);

  *(_QWORD *)(result + 40) = 0;
  *(_BYTE *)(result + 48) = 1;
  if (a3)
  {
    v3 = (uint64_t (*)(_QWORD, uint64_t, _QWORD))a3[2];
    if (v3)
      return v3(a3[1], a2, a3[6]);
  }
  return result;
}

_OWORD *path_orientation_iterate(uint64_t a1, int a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  _OWORD *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  switch(a2)
  {
    case 0:
      if (!*(_BYTE *)(a1 + 48))
        *(double *)(a1 + 40) = *(double *)(a1 + 40)
                             + (*(double *)(a1 + 8) - *(double *)(a1 + 24))
                             * (*(double *)(a1 + 32) + *(double *)(a1 + 16))
                             * 0.5;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)a3;
      *(_BYTE *)(a1 + 48) = 1;
      v10 = 0;
      goto LABEL_6;
    case 1:
      *(double *)(a1 + 40) = *(double *)(a1 + 40) + (*a3 - *(double *)(a1 + 24)) * (*(double *)(a1 + 32) + a3[1]) * 0.5;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)a3;
      *(_BYTE *)(a1 + 48) = 0;
      v10 = 1;
LABEL_6:
      result = (_OWORD *)path_add((unsigned __int8 **)a1, v10, (uint64_t)a3, a4, a5, a6, a7, a8);
      *result = *(_OWORD *)a3;
      break;
    case 2:
      orientation_cubic_segment(a1, *(double *)(a1 + 24), *(double *)(a1 + 32), (*(double *)(a1 + 24) + *a3 * 2.0) / 3.0, (*(double *)(a1 + 32) + a3[1] * 2.0) / 3.0, (a3[2] + *a3 * 2.0) / 3.0, (a3[3] + a3[1] * 2.0) / 3.0, a3[2], a3[3]);
      *(_OWORD *)(a1 + 24) = *((_OWORD *)a3 + 1);
      *(_BYTE *)(a1 + 48) = 0;
      result = (_OWORD *)path_add((unsigned __int8 **)a1, 2u, v12, v13, v14, v15, v16, v17);
      *result = *(_OWORD *)a3;
      result[1] = *((_OWORD *)a3 + 1);
      break;
    case 3:
      orientation_cubic_segment(a1, *(double *)(a1 + 24), *(double *)(a1 + 32), *a3, a3[1], a3[2], a3[3], a3[4], a3[5]);
      *(_OWORD *)(a1 + 24) = *((_OWORD *)a3 + 2);
      *(_BYTE *)(a1 + 48) = 0;
      result = (_OWORD *)path_add((unsigned __int8 **)a1, 3u, v18, v19, v20, v21, v22, v23);
      *result = *(_OWORD *)a3;
      result[1] = *((_OWORD *)a3 + 1);
      result[2] = *((_OWORD *)a3 + 2);
      break;
    case 4:
      *(double *)(a1 + 40) = *(double *)(a1 + 40)
                           + (*(double *)(a1 + 8) - *(double *)(a1 + 24))
                           * (*(double *)(a1 + 32) + *(double *)(a1 + 16))
                           * 0.5;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a1 + 8);
      *(_BYTE *)(a1 + 48) = 1;
      result = (_OWORD *)path_add((unsigned __int8 **)a1, 4u, (uint64_t)a3, a4, a5, a6, a7, a8);
      break;
    default:
      abort();
  }
  return result;
}

void path_orientation_end(uint64_t a1, unsigned int *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  void (*v9)(_QWORD, _QWORD);

  if (!*(_BYTE *)(a1 + 48))
    *(double *)(a1 + 40) = *(double *)(a1 + 40)
                         + (*(double *)(a1 + 8) - *(double *)(a1 + 24))
                         * (*(double *)(a1 + 32) + *(double *)(a1 + 16))
                         * 0.5;
  if (*(_QWORD *)a1)
  {
    if (*(double *)(a1 + 40) <= 0.0)
    {
      path_iterator_iterate(a2, *(_QWORD *)a1);
    }
    else
    {
      v4 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
      v5 = malloc_type_malloc(0x200uLL, 0x95C2046AuLL);
      *v5 = 0;
      v5[1] = 0;
      v5[2] = v5 + 64;
      v5[3] = ((unint64_t)v5 + 55) & 0xFFFFFFFFFFFFFFF8;
      v5[4] = 0;
      v5[5] = 464;
      v4[3] = v5;
      v6 = operator new();
      v7 = v6;
      *(_QWORD *)(v6 + 8) = v4;
      *(_OWORD *)(v6 + 16) = path_iterator_reverse_create_callbacks;
      *(_OWORD *)(v6 + 32) = *(_OWORD *)off_1E162CB50;
      if (a2)
      {
        do
          v8 = __ldxr(a2);
        while (__stxr(v8 + 1, a2));
      }
      *(_QWORD *)(v6 + 48) = a2;
      *(_DWORD *)v6 = 1;
      path_iterator_iterate((_QWORD *)v6, *(_QWORD *)a1);
      path_iterator::release(v7);
    }
    path_free(*(void **)a1);
    *(_QWORD *)a1 = 0;
  }
  if (a2)
  {
    v9 = (void (*)(_QWORD, _QWORD))*((_QWORD *)a2 + 4);
    if (v9)
      v9(*((_QWORD *)a2 + 1), *((_QWORD *)a2 + 6));
  }
}

void path_orientation_release_info(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
    path_free(v2);
  free(a1);
}

double orientation_cubic_segment(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v13;
  BOOL v14;
  double result;

  if (a2 == a4 && a3 == a5)
  {
    v14 = a2 == a6 && a3 == a7;
    if (v14 || a6 == a8 && a7 == a9)
      *(double *)(a1 + 40) = (a8 - a2) * (a3 + a9) * 0.5 + *(double *)(a1 + 40);
    goto LABEL_24;
  }
  if (a4 != a8 || a5 != a9 || a6 != a8 || a7 != a9)
  {
LABEL_24:
    v13 = (a8 * (a3 + a7 * 6.0 + a9 * 10.0 + a5 * 3.0)
         - a2 * (a9 + a5 * 6.0 + a3 * 10.0 + a7 * 3.0)
         + a4 * 3.0 * (-(a7 - a3 * 2.0) - a9)
         + a6 * -3.0 * (-(a5 - a9 * 2.0) - a3))
        / 20.0;
    goto LABEL_25;
  }
  v13 = (a8 - a2) * (a3 + a9) * 0.5;
LABEL_25:
  result = v13 + *(double *)(a1 + 40);
  *(double *)(a1 + 40) = result;
  return result;
}

double *CGDashCreate(const void *a1, uint64_t a2, double a3)
{
  double *v3;

  v3 = 0;
  if (a1 && a2)
  {
    v3 = (double *)malloc_type_calloc(1uLL, 8 * a2 + 24, 0x64A29F66uLL);
    *(_DWORD *)v3 = 1;
    v3[1] = a3;
    *((_QWORD *)v3 + 2) = a2;
    memcpy(v3 + 3, a1, 8 * a2);
  }
  return v3;
}

unsigned int *CGDashRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

void CGDashRelease(void *a1)
{
  unsigned int v1;
  unsigned int v2;

  if (a1)
  {
    do
    {
      v1 = __ldxr((unsigned int *)a1);
      v2 = v1 - 1;
    }
    while (__stxr(v2, (unsigned int *)a1));
    if (!v2)
      free(a1);
  }
}

uint64_t CGDashGetPattern(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;

  if (a2)
  {
    if (a1)
      v3 = *(_QWORD *)(a1 + 8);
    else
      v3 = 0;
    *a2 = v3;
  }
  if (a3)
  {
    if (a1)
      v4 = *(_QWORD *)(a1 + 16);
    else
      v4 = 0;
    *a3 = v4;
  }
  if (a1)
    return a1 + 24;
  else
    return 0;
}

void CMYKf16_sample_CMYK32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_CMYK32", 15965, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_cmyk32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_cmyk32", 15969, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_CMYK64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_CMYK64", 15973, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_cmyk64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_cmyk64", 15977, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_WF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_WF", 15981, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_Wf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_Wf", 15984, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_RGBF", 15988, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_RGBf", 15991, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_RGBAF", 15995, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_RGBAf", 15999, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_CMYKF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_CMYKF", 16003, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_CMYKf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  _CGHandleAssert("CMYKf16_sample_CMYKf", 16007, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

_DWORD *CMYKf16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  float *v9;
  float v10;
  int v13;
  float v17;
  float v18;
  float v19;
  char *v26;

  v9 = *(float **)(*(_QWORD *)a1 + 64);
  _S10 = *v9;
  v10 = v9[1];
  if (a2 && a3 > 9 || (a2 = malloc_type_malloc(0x3AuLL, 0x705560E0uLL)) != 0)
  {
    if (_S10 <= a6)
      _S0 = a6;
    else
      _S0 = _S10;
    if (v10 < a6)
      _S0 = v10;
    if (a5)
      v13 = a4;
    else
      v13 = 0;
    if (v13 == 1)
    {
      _S1 = _S0 * (float)(v10 - *a5);
      _S2 = _S10;
      _S3 = _S10;
    }
    else if (v13 == 4)
    {
      _S10 = _S0 * *a5;
      _S2 = _S0 * a5[1];
      _S3 = _S0 * a5[2];
      _S1 = _S0 * a5[3];
    }
    else
    {
      _S2 = _S10;
      _S3 = _S10;
      _S1 = _S10;
      if (v13 == 3)
      {
        v17 = _S0 * (float)(v10 - *a5);
        v18 = _S0 * (float)(v10 - a5[1]);
        v19 = _S0 * (float)(v10 - a5[2]);
        if (v17 >= v18)
          _S1 = _S0 * (float)(v10 - a5[1]);
        else
          _S1 = _S0 * (float)(v10 - *a5);
        if (v19 < _S1)
          _S1 = _S0 * (float)(v10 - a5[2]);
        _S10 = v17 - _S1;
        _S2 = v18 - _S1;
        _S3 = v19 - _S1;
      }
    }
    *(_OWORD *)a2 = xmmword_185004D80;
    a2[6] = 0;
    *((_QWORD *)a2 + 2) = 1;
    __asm { FCVT            H4, S10 }
    *((_WORD *)a2 + 24) = _H4;
    __asm { FCVT            H0, S0 }
    *((_WORD *)a2 + 28) = _H0;
    v26 = (char *)(a2 + 14);
    if (!_NF)
      v26 = 0;
    *((_QWORD *)a2 + 4) = a2 + 12;
    *((_QWORD *)a2 + 5) = v26;
    __asm { FCVT            H0, S2 }
    *((_WORD *)a2 + 25) = _H0;
    __asm { FCVT            H0, S3 }
    *((_WORD *)a2 + 26) = _H0;
    __asm { FCVT            H0, S1 }
    *((_WORD *)a2 + 27) = _H0;
  }
  return a2;
}

uint64_t CMYKf16_mark(uint64_t a1, __n128 a2)
{
  return CMYKf16_mark_inner(*(_QWORD *)(*(_QWORD *)a1 + 56), a2);
}

uint64_t CMYKf16_mark_inner(uint64_t a1, __n128 a2)
{
  unsigned __int32 v2;
  unsigned __int32 v3;
  unsigned __int32 v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int32x2_t v18;
  double v19;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint16x4_t *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  int v37;
  int v38;
  unsigned int v39;
  size_t v40;
  _BYTE *v41;
  _BYTE *v42;
  unint64_t v43;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  float16x4_t *v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  float16x4_t *v64;
  int v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  __n128 v73;
  __n128 v74;
  float32x4_t v75;
  float32x4_t v76;
  double v77;
  double v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __n128 v83;
  int32x4_t v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  char *v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  float16x4_t *v95;
  int v96;
  float16x4_t *v97;
  uint64_t v98;
  float16x4_t *v99;
  void *v100;
  uint64_t v101;
  float16x4_t *v102;
  unsigned int v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  char *v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  int v113;
  float16x4_t *v120;
  uint64_t v121;
  float16x4_t *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  uint64_t v127;
  int v128;
  float16x4_t *v143;
  uint64_t v144;
  float16x4_t *v145;
  uint64_t v146;
  uint64_t v147;
  int v148;
  uint64_t v149;
  int v150;
  float v153;
  float16x4_t *v158;
  uint64_t v159;
  float16x4_t *v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  uint64_t v164;
  int v165;
  float16x4_t *v171;
  uint64_t v172;
  float16x4_t *v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  uint64_t v177;
  int v178;
  float v181;
  float16x4_t *v186;
  uint64_t v187;
  float16x4_t *v188;
  uint64_t v189;
  uint64_t v190;
  int v191;
  uint64_t v192;
  int v193;
  float16x4_t *v197;
  uint64_t v198;
  float16x4_t *v199;
  uint64_t v200;
  uint64_t v201;
  int v202;
  uint64_t v203;
  int v204;
  float v207;
  float16x4_t *v212;
  uint64_t v213;
  float16x4_t *v214;
  uint64_t v215;
  uint64_t v216;
  int v217;
  uint64_t v218;
  int v219;
  float16x4_t *v225;
  uint64_t v226;
  float16x4_t *v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  int v232;
  float16x4_t *v238;
  uint64_t v239;
  float16x4_t *v240;
  uint64_t v241;
  uint64_t v242;
  int v243;
  uint64_t v244;
  int v245;
  float v257;
  float v266;
  float v276;
  float v280;
  float16x4_t *v284;
  uint64_t v285;
  float16x4_t *v286;
  uint64_t v287;
  uint64_t v288;
  int v289;
  uint64_t v290;
  int v291;
  float16x4_t *v316;
  uint64_t v317;
  float16x4_t *v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  unint64_t v327;
  unint64_t v328;
  float16x4_t *v329;
  uint64_t v330;
  float16x4_t *v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  unint64_t v340;
  unint64_t v341;
  float16x4_t *v342;
  uint64_t v343;
  float16x4_t *v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  unint64_t v353;
  unint64_t v354;
  float16x4_t *v355;
  uint64_t v356;
  float16x4_t *v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  unint64_t v365;
  unint64_t v366;
  float16x4_t *v367;
  uint64_t v368;
  float16x4_t *v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  unint64_t v377;
  unint64_t v378;
  float16x4_t *v379;
  uint64_t v380;
  float16x4_t *v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  unint64_t v390;
  unint64_t v391;
  float16x4_t *v392;
  uint64_t v393;
  float16x4_t *v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  unint64_t v403;
  unint64_t v404;
  float16x4_t *v405;
  uint64_t v406;
  float16x4_t *v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  unint64_t v415;
  unint64_t v416;
  float16x4_t *v417;
  uint64_t v418;
  float16x4_t *v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  unint64_t v428;
  unint64_t v429;
  float16x4_t *v430;
  uint64_t v431;
  float16x4_t *v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  unint64_t v440;
  uint64_t v441;
  float16x4_t *v442;
  uint64_t v443;
  float16x4_t *v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  unint64_t v452;
  unint64_t v453;
  float16x4_t *v454;
  uint64_t v455;
  float16x4_t *v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  unint64_t v465;
  unint64_t v466;
  float16x4_t *v467;
  uint64_t v468;
  float16x4_t *v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  unint64_t v478;
  unint64_t v479;
  float16x4_t *v480;
  uint64_t v481;
  float16x4_t *v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  unint64_t v491;
  unint64_t v492;
  float16x4_t *v493;
  uint64_t v494;
  float16x4_t *v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  unint64_t v504;
  unint64_t v505;
  float16x4_t *v506;
  uint64_t v507;
  float16x4_t *v508;
  uint64_t v509;
  uint64_t v510;
  int v511;
  int v512;
  float16x4_t v515;
  float16x4_t *v516;
  uint64_t v517;
  float16x4_t *v518;
  uint64_t v519;
  uint64_t v520;
  int v521;
  int v522;
  float16x4_t *v534;
  uint64_t v535;
  float16x4_t *v536;
  uint64_t v537;
  uint64_t v538;
  int v539;
  int v540;
  float16x4_t *v542;
  uint64_t v543;
  float16x4_t *v544;
  uint64_t v545;
  uint64_t v546;
  int v547;
  int v548;
  float v551;
  float16x4_t *v552;
  uint64_t v553;
  float16x4_t *v554;
  uint64_t v555;
  uint64_t v556;
  int v557;
  int v558;
  float v567;
  float v569;
  float v581;
  float v583;
  float16x4_t *v587;
  uint64_t v588;
  float16x4_t *v589;
  uint64_t v590;
  uint64_t v591;
  int v592;
  int v593;
  float16x4_t *v594;
  uint64_t v595;
  float16x4_t *v596;
  uint64_t v597;
  uint64_t v598;
  uint8x8_t v599;
  int v600;
  uint64_t v601;
  uint64_t v602;
  int v603;
  int v604;
  float16x4_t *v605;
  uint64_t v606;
  float16x4_t *v607;
  uint64_t v608;
  uint64_t v609;
  int v610;
  int v611;
  float16x4_t *v612;
  uint64_t v613;
  float16x4_t *v614;
  uint64_t v615;
  uint64_t v616;
  int v617;
  int v618;
  float16x4_t *v619;
  uint64_t v620;
  float16x4_t *v621;
  uint64_t v622;
  uint64_t v623;
  int v624;
  int v625;
  float16x4_t *v626;
  unint64_t v627;
  int v628;
  int v629;
  unint64_t v630;
  uint64_t v631;
  unint64_t v632;
  unint64_t v633;
  int v634;
  uint64_t v635;
  char *v636;
  unint64_t v637;
  uint64_t v638;
  int v639;
  uint64_t v640;
  char *v641;
  uint64_t v642;
  char *v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  char *v647;
  uint64_t v648;
  uint64_t v649;
  int v650;
  uint64_t v651;
  char *v652;
  uint64_t v653;
  int v654;
  int v655;
  unsigned int v656;
  int v657;
  uint64_t v658;
  uint64_t v659;
  int v660;
  int v661;
  unsigned int v662;
  float32x4_t v663;
  float32x4_t v664;
  unsigned int v665;
  int v666;
  unsigned int v667;
  unsigned int v677;
  int v681;
  float32x4_t v682;
  int v683;
  float32x4_t v687;
  int v688;
  int v689;
  float v692;
  float32x4_t v695;
  int v696;
  int v697;
  float32x4_t v701;
  int v702;
  int v703;
  float v706;
  int v709;
  uint64_t v710;
  float32x4_t v711;
  int v712;
  int v716;
  int v717;
  uint64_t v718;
  int v719;
  int v723;
  float32x4_t v724;
  int v725;
  int v726;
  float32x4_t v730;
  int v731;
  int v732;
  float32x4_t v736;
  int v737;
  int v738;
  float v744;
  float v747;
  float v751;
  int v757;
  uint64_t v758;
  float32x4_t v759;
  int v760;
  float16x4_t v765;
  __n128 v766;
  int v767;
  int v768;
  __n128 v771;
  int v772;
  int v773;
  __n128 v776;
  int v777;
  int v778;
  float16x4_t v781;
  int v782;
  int v783;
  float16x4_t v785;
  int v786;
  int v787;
  __n128 v789;
  int v790;
  int v791;
  __n128 v794;
  int v795;
  int v796;
  float16x4_t v799;
  int v800;
  int v801;
  __n128 v803;
  int v804;
  int v805;
  __n128 v808;
  int v809;
  int v810;
  __n128 v812;
  int v813;
  int v814;
  __n128 v816;
  int v817;
  int v818;
  __n128 v821;
  int v822;
  int v823;
  int v826;
  int v827;
  __n128 v830;
  int v831;
  int v832;
  int *v835;
  float32x4_t v836;
  unsigned int v837;
  int v838;
  unsigned int v839;
  float16x8_t v840;
  unsigned int v841;
  int v843;
  float32x4_t v844;
  int v845;
  int v846;
  int v847;
  unint64_t v848;
  int v849;
  char *v850;
  char *v851;
  unint64_t v852;
  char *v853;
  char *v854;
  unint64_t v855;
  int v856;
  int v857;
  int v858;
  uint64_t v859;
  uint64_t v860;
  unint64_t v861;
  int v862;
  int v863;
  int v864;
  int v865;
  int v866;
  int v867;
  int v868;
  int v869;
  int v870;
  int v871;
  int v872;
  int v873;
  int v874;
  int v875;
  int v876;
  int v877;
  unint64_t v878;
  float16x4_t *v879;
  unint64_t v880;
  float16x4_t *v881;
  unsigned int v882;
  uint64_t v883;
  unint64_t v884;
  uint64_t v885;
  int32x2_t v886;
  unint64_t v887;
  uint64_t v888;
  unint64_t v889;
  float32x4_t v890;
  unint64_t v891;
  int32x2_t v892;
  uint64_t v893;
  __n128 v894;
  uint64_t v895;
  uint64_t v896;
  int v897[4];
  int32x4_t v898;
  __int128 v899;
  __int128 v900;
  __int128 v901;
  __int128 v902;
  __int128 v903;
  __int128 v904;
  __int128 v905;
  __int128 v906;
  _DWORD v907[1024];
  uint64_t v908;

  v5 = MEMORY[0x1E0C80A78](a1, a2);
  v908 = *MEMORY[0x1E0C80C00];
  v21 = *(char **)(v6 + 96);
  v22 = *(_QWORD *)(v6 + 48);
  v23 = *(unsigned int *)(v5 + 16 * *(_DWORD *)v6 + 8 * (v21 == 0) + 4 * (v22 == 0));
  if ((int)v23 > 27)
    return 0xFFFFFFFFLL;
  v25 = v6;
  v26 = *(unsigned int *)(v6 + 4);
  v27 = v26 - 1;
  if ((int)v26 < 1)
    return 0;
  v28 = *(_DWORD *)(v6 + 8);
  v29 = (v28 - 1);
  if (v28 < 1)
    return 0;
  v30 = *(uint16x4_t **)(v6 + 136);
  v848 = v6;
  if ((*(_DWORD *)v6 & 0xFF0000) == 0x50000 || !v30)
  {
    v32 = *(_DWORD *)v6 & 0xFF00;
    v849 = *(_DWORD *)(v5 + 16 * *(_DWORD *)v6 + 8 * (v21 == 0) + 4 * (v22 == 0));
    if (v32 == 1024)
    {
      v907[0] = *(_DWORD *)(v6 + 4);
      v897[0] = v28;
      if (v21)
        _Q5.i16[0] = *(_WORD *)v21;
      else
        _Q5.i16[0] = 15360;
      __asm { FCVT            S17, H5 }
      v48 = (unint64_t)*(int *)(v6 + 28) >> 3;
      v50 = *(int *)(v6 + 12);
      v49 = *(int *)(v6 + 16);
      if (v22)
      {
        v51 = (unint64_t)*(int *)(v6 + 32) >> 1;
        v888 = v22 + 2 * (v50 + v51 * v49);
        v882 = 1;
      }
      else
      {
        v888 = 0;
        v51 = 0;
        v882 = 0;
      }
      _Q1.n128_u64[0] = **(_QWORD **)(v6 + 88);
      v892 = _D17;
      v894 = _Q1;
      *(float *)v18.i32 = 1.0 - *(float *)_D17.i32;
      v58 = *(_QWORD *)(v6 + 40) + 8 * (v50 + v49 * v48);
      v890 = _Q5;
      v886 = v18;
      v878 = v51;
      v880 = (unint64_t)*(int *)(v6 + 28) >> 3;
      v885 = v58;
      if (v30)
      {
        shape_enum_clip_alloc(v5, v6, (int *)v30, 1, 1, 1, *(_DWORD *)(v6 + 104), *(_DWORD *)(v6 + 108), v26, v28);
        v42 = v59;
        v60 = v888;
        v61 = v51;
        if (v59)
          goto LABEL_1232;
        return 1;
      }
      v42 = 0;
      if (v22)
        v62 = v26;
      else
        v62 = 0;
      v63 = v26;
      v61 = v51 - v62;
      v60 = v888;
      v64 = (float16x4_t *)v58;
      v65 = v63;
      v66 = v63;
LABEL_903:
      v58 = v48 - v66;
      switch((int)v23)
      {
        case 0:
          v649 = v58 + v65;
          v650 = v897[0];
          v651 = v897[0] - 1;
          v652 = (char *)&v64[(v649 * v651) & (v649 >> 63)];
          if (v649 < 0)
            v649 = -v649;
          CGBlt_fillBytes(8 * v65, v897[0], 0, v652, 8 * v649);
          if (!v22)
            goto LABEL_1208;
          v653 = v61 + v65;
          v60 += 2 * ((v653 * v651) & (v653 >> 63));
          if (v653 >= 0)
            v61 += v65;
          else
            v61 = -v653;
          v654 = 2 * v65;
          v655 = 2 * v61;
          v656 = v650;
          v657 = 0;
          goto LABEL_1207;
        case 1:
          v658 = v58 + v65;
          if (v658 < 0)
          {
            v64 += v658 * (v897[0] - 1);
            v658 = -v658;
          }
          v659 = *(_QWORD *)(v848 + 88);
          v660 = v897[0];
          if (v659)
            CGSFillDRAM64(v64, 8 * v658, 8 * v65, v897[0], v659, 8, 8, 1, 0, 0);
          else
            CGBlt_fillBytes(8 * v65, v897[0], 0, (char *)v64, 8 * v658);
          if (v22)
          {
            v835 = *(int **)(v848 + 96);
            if (!v835)
              v835 = (int *)&_CMYK_float_alpha;
            v60 += 2 * (((v61 + v65) * (v660 - 1)) & ((uint64_t)(v61 + v65) >> 63));
            if ((uint64_t)(v61 + v65) >= 0)
              v61 += v65;
            else
              v61 = -(uint64_t)(v61 + v65);
            v657 = *v835;
            v654 = 2 * v65;
            v655 = 2 * v61;
            v656 = v660;
LABEL_1207:
            CGBlt_fillBytes(v654, v656, v657, (char *)v60, v655);
          }
LABEL_1208:
          LODWORD(v23) = v849;
          goto LABEL_1229;
        case 2:
          v661 = v897[0];
          v662 = v65 >> 2;
          v663 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          if (v22)
          {
            v664 = (float32x4_t)vdupq_lane_s32(v18, 0);
            v665 = v662 + 1;
            do
            {
              v666 = v65;
              if (v65 >= 4)
              {
                v667 = v665;
                do
                {
                  *v64 = vcvt_f16_f32(vmlaq_f32(v663, v664, vcvtq_f32_f16(*v64)));
                  _H2 = *(_WORD *)v60;
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v18.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)v60 = LOWORD(_S2);
                  v64[1] = vcvt_f16_f32(vmlaq_f32(v663, v664, vcvtq_f32_f16(v64[1])));
                  LOWORD(_S2) = *(_WORD *)(v60 + 2);
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v18.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)(v60 + 2) = LOWORD(_S2);
                  v64[2] = vcvt_f16_f32(vmlaq_f32(v663, v664, vcvtq_f32_f16(v64[2])));
                  LOWORD(_S2) = *(_WORD *)(v60 + 4);
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v18.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)(v60 + 4) = LOWORD(_S2);
                  v64[3] = vcvt_f16_f32(vmlaq_f32(v663, v664, vcvtq_f32_f16(v64[3])));
                  LOWORD(_S2) = *(_WORD *)(v60 + 6);
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v18.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)(v60 + 6) = LOWORD(_S2);
                  v64 += 4;
                  --v667;
                  v60 += 8 * v882;
                }
                while (v667 > 1);
                v666 = v65 & 3;
              }
              if (v666 >= 1)
              {
                v677 = v666 + 1;
                do
                {
                  *v64 = vcvt_f16_f32(vmlaq_f32(v663, v664, vcvtq_f32_f16(*v64)));
                  ++v64;
                  _H2 = *(_WORD *)v60;
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v18.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)v60 = LOWORD(_S2);
                  v60 += 2 * v882;
                  --v677;
                }
                while (v677 > 1);
              }
              v64 += v58;
              v60 += 2 * v61;
              --v661;
            }
            while (v661);
          }
          else
          {
            v836 = (float32x4_t)vdupq_lane_s32(v18, 0);
            v837 = v662 + 1;
            do
            {
              v838 = v65;
              if (v65 >= 4)
              {
                v839 = v837;
                do
                {
                  v840 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(v663, v836, vcvtq_f32_f16(v64[2]))), vmlaq_f32(v663, v836, vcvt_hight_f32_f16(*(float16x8_t *)v64[2].i8)));
                  *(float16x8_t *)v64->i8 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(v663, v836, vcvtq_f32_f16(*v64))), vmlaq_f32(v663, v836, vcvt_hight_f32_f16(*(float16x8_t *)v64->i8)));
                  *(float16x8_t *)v64[2].i8 = v840;
                  v64 += 4;
                  --v839;
                  v60 += 8 * v882;
                }
                while (v839 > 1);
                v838 = v65 & 3;
              }
              if (v838 >= 1)
              {
                v841 = v838 + 1;
                do
                {
                  *v64 = vcvt_f16_f32(vmlaq_f32(v663, v836, vcvtq_f32_f16(*v64)));
                  ++v64;
                  v60 += 2 * v882;
                  --v841;
                }
                while (v841 > 1);
              }
              v64 += v58;
              v60 += 2 * v61;
              --v661;
            }
            while (v661);
          }
          goto LABEL_1228;
        case 3:
          v681 = v897[0];
          v682 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          do
          {
            v683 = v65;
            do
            {
              _Q3.n128_u16[0] = *(_WORD *)v60;
              __asm { FCVT            S2, H3 }
              if (_S2 <= 0.0)
              {
                *v64 = 0;
                _H2 = 0;
              }
              else if (_S2 >= 1.0)
              {
                *v64 = (float16x4_t)v894.n128_u64[0];
                _H2 = _Q5.i16[0];
              }
              else
              {
                _Q3.n128_u64[0] = (unint64_t)vcvt_f16_f32(vmulq_f32(v682, vcvtq_f32_f16((float16x4_t)vdup_lane_s16((int16x4_t)_Q3.n128_u64[0], 0))));
                *v64 = (float16x4_t)_Q3.n128_u64[0];
                _S2 = *(float *)_D17.i32 * _S2;
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)v60 = _H2;
              ++v64;
              v60 += 2 * v882;
              --v683;
            }
            while (v683);
            v64 += v58;
            v60 += 2 * v61;
            --v681;
          }
          while (v681);
          goto LABEL_1228;
        case 4:
          v687 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          v688 = v897[0];
          do
          {
            v689 = v65;
            do
            {
              _H2 = *(_WORD *)v60;
              __asm { FCVT            S2, H2 }
              v692 = 1.0 - _S2;
              if (v692 <= 0.0)
              {
                *v64 = 0;
                _H2 = 0;
              }
              else if (v692 >= 1.0)
              {
                *v64 = (float16x4_t)v894.n128_u64[0];
                _H2 = _Q5.i16[0];
              }
              else
              {
                *v64 = vcvt_f16_f32(vmulq_n_f32(v687, v692));
                _S2 = v692 * *(float *)_D17.i32;
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)v60 = _H2;
              ++v64;
              v60 += 2 * v882;
              --v689;
            }
            while (v689);
            v64 += v58;
            v60 += 2 * v61;
            --v688;
          }
          while (v688);
          goto LABEL_1228;
        case 5:
          v695 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          v696 = v897[0];
          do
          {
            v697 = v65;
            do
            {
              _H1 = *(_WORD *)v60;
              __asm { FCVT            S1, H1 }
              *v64 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), *(float *)v18.i32), v695, _S1));
              ++v64;
              _S1 = (float)(*(float *)v18.i32 * _S1) + (float)(*(float *)_D17.i32 * _S1);
              __asm { FCVT            H1, S1 }
              *(_WORD *)v60 = LOWORD(_S1);
              v60 += 2 * v882;
              --v697;
            }
            while (v697);
            v64 += v58;
            v60 += 2 * v61;
            --v696;
          }
          while (v696);
          goto LABEL_1228;
        case 6:
          v701 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          v702 = v897[0];
          while (1)
          {
            v703 = v65;
            do
            {
              _H2 = *(_WORD *)v60;
              __asm { FCVT            S2, H2 }
              v706 = 1.0 - _S2;
              if ((float)(1.0 - _S2) >= 1.0)
              {
                *v64 = (float16x4_t)v894.n128_u64[0];
                _H2 = _Q5.i16[0];
              }
              else
              {
                if (v706 <= 0.0)
                  goto LABEL_958;
                *v64 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v64), v701, v706));
                _S2 = _S2 + (float)(*(float *)_D17.i32 * v706);
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)v60 = _H2;
LABEL_958:
              ++v64;
              v60 += 2 * v882;
              --v703;
            }
            while (v703);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v702)
            {
LABEL_1228:
              v897[0] = 0;
              goto LABEL_1229;
            }
          }
        case 7:
          v709 = v897[0];
          v710 = 2 * v882;
          v711 = vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)_Q5.f32, 0));
          if (v22)
          {
            do
            {
              v712 = v65;
              do
              {
                *v64 = vcvt_f16_f32(vmulq_f32(v711, vcvtq_f32_f16(*v64)));
                ++v64;
                _H1 = *(_WORD *)v60;
                __asm { FCVT            S1, H1 }
                _S1 = *(float *)_D17.i32 * _S1;
                __asm { FCVT            H1, S1 }
                *(_WORD *)v60 = LOWORD(_S1);
                v60 += v710;
                --v712;
              }
              while (v712);
              v64 += v58;
              v60 += 2 * v61;
              --v709;
            }
            while (v709);
          }
          else
          {
            do
            {
              v716 = v65;
              do
              {
                *v64 = vcvt_f16_f32(vmulq_f32(v711, vcvtq_f32_f16(*v64)));
                ++v64;
                v60 += v710;
                --v716;
              }
              while (v716);
              v64 += v58;
              v60 += 2 * v61;
              --v709;
            }
            while (v709);
          }
          goto LABEL_1228;
        case 8:
          v717 = v897[0];
          v718 = 2 * v882;
          if (v22)
          {
            do
            {
              v719 = v65;
              do
              {
                *v64 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), *(float *)v18.i32));
                ++v64;
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S0, H0 }
                _S0 = *(float *)v18.i32 * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)v60 = LOWORD(_S0);
                v60 += v718;
                --v719;
              }
              while (v719);
              v64 += v58;
              v60 += 2 * v61;
              --v717;
            }
            while (v717);
          }
          else
          {
            do
            {
              v723 = v65;
              do
              {
                *v64 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), *(float *)v18.i32));
                ++v64;
                v60 += v718;
                --v723;
              }
              while (v723);
              v64 += v58;
              v60 += 2 * v61;
              --v717;
            }
            while (v717);
          }
          goto LABEL_1228;
        case 9:
          v724 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          v725 = v897[0];
          do
          {
            v726 = v65;
            do
            {
              _H2 = *(_WORD *)v60;
              __asm { FCVT            S2, H2 }
              *v64 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), *(float *)_D17.i32), v724, 1.0 - _S2));
              ++v64;
              _S2 = (float)(*(float *)_D17.i32 * _S2) + (float)(*(float *)_D17.i32 * (float)(1.0 - _S2));
              __asm { FCVT            H2, S2 }
              *(_WORD *)v60 = LOWORD(_S2);
              v60 += 2 * v882;
              --v726;
            }
            while (v726);
            v64 += v58;
            v60 += 2 * v61;
            --v725;
          }
          while (v725);
          goto LABEL_1228;
        case 10:
          v730 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
          v731 = v897[0];
          do
          {
            v732 = v65;
            do
            {
              _H2 = *(_WORD *)v60;
              __asm { FCVT            S2, H2 }
              *v64 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v64), *(float *)v18.i32), v730, 1.0 - _S2));
              ++v64;
              _S2 = (float)(*(float *)v18.i32 * _S2) + (float)(*(float *)_D17.i32 * (float)(1.0 - _S2));
              __asm { FCVT            H2, S2 }
              *(_WORD *)v60 = LOWORD(_S2);
              v60 += 2 * v882;
              --v732;
            }
            while (v732);
            v64 += v58;
            v60 += 2 * v61;
            --v731;
          }
          while (v731);
          goto LABEL_1228;
        case 11:
          v736 = vsubq_f32((float32x4_t)vdupq_lane_s32(_D17, 0), vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]));
          v737 = v897[0];
          if (v22)
          {
            do
            {
              v738 = v65;
              do
              {
                _H5 = *(_WORD *)v60;
                __asm { FCVT            S5, H5 }
                _S6 = *(float *)_D17.i32 + _S5;
                _H7 = v64->i16[0];
                __asm { FCVT            S7, H7 }
                v744 = v736.f32[0] + (float)(_S5 - _S7);
                if ((float)(*(float *)_D17.i32 + _S5) > 1.0)
                  _S6 = 1.0;
                _H16 = v64->i16[1];
                __asm { FCVT            S16, H16 }
                v747 = v736.f32[1] + (float)(_S5 - _S16);
                _S7 = _S6 - v744;
                __asm { FCVT            H7, S7 }
                v64->i16[0] = LOWORD(_S7);
                LOWORD(_S7) = *(_WORD *)v60;
                __asm { FCVT            S7, H7 }
                LOWORD(_S16) = v64->i16[2];
                __asm { FCVT            S16, H16 }
                v751 = v736.f32[2] + (float)(_S7 - _S16);
                _S5 = _S6 - v747;
                __asm { FCVT            H5, S5 }
                v64->i16[1] = LOWORD(_S5);
                LOWORD(_S5) = *(_WORD *)v60;
                __asm { FCVT            S5, H5 }
                LOWORD(_S16) = v64->i16[3];
                __asm { FCVT            S16, H16 }
                _S7 = _S6 - v751;
                __asm { FCVT            H7, S7 }
                v64->i16[2] = LOWORD(_S7);
                __asm { FCVT            H7, S6 }
                *(_WORD *)v60 = LOWORD(_S7);
                _S5 = _S6 - (float)(v736.f32[3] + (float)(_S5 - _S16));
                __asm { FCVT            H5, S5 }
                v64->i16[3] = LOWORD(_S5);
                ++v64;
                v60 += 2 * v882;
                --v738;
              }
              while (v738);
              v64 += v58;
              v60 += 2 * v61;
              --v737;
            }
            while (v737);
          }
          else
          {
            __asm { FMOV            V1.4S, #1.0 }
            do
            {
              v843 = v65;
              do
              {
                *v64 = vcvt_f16_f32(vsubq_f32(_Q1, vaddq_f32(v736, vsubq_f32(_Q1, vcvtq_f32_f16(*v64)))));
                ++v64;
                v60 += 2 * v882;
                --v843;
              }
              while (v843);
              v64 += v58;
              v60 += 2 * v61;
              --v737;
            }
            while (v737);
          }
          goto LABEL_1228;
        case 12:
          v757 = v897[0];
          v758 = 2 * v882;
          if (v22)
          {
            v759 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
            do
            {
              v760 = v65;
              do
              {
                _H2 = *(_WORD *)v60;
                __asm { FCVT            S2, H2 }
                _S2 = *(float *)_D17.i32 + _S2;
                if (_S2 > 1.0)
                  _S2 = 1.0;
                __asm { FCVT            H2, S2 }
                v765.i32[0] = v64->i32[0];
                *(_WORD *)v60 = _H2;
                v765.i32[1] = v64->i32[1];
                *v64++ = vcvt_f16_f32(vaddq_f32(v759, vcvtq_f32_f16(v765)));
                v60 += v758;
                --v760;
              }
              while (v760);
              v64 += v58;
              v60 += 2 * v61;
              --v757;
            }
            while (v757);
          }
          else
          {
            v844 = vcvtq_f32_f16((float16x4_t)v894.n128_u64[0]);
            do
            {
              v845 = v65;
              do
              {
                *v64 = vcvt_f16_f32(vaddq_f32(v844, vcvtq_f32_f16(*v64)));
                ++v64;
                v60 += v758;
                --v845;
              }
              while (v845);
              v64 += v58;
              v60 += 2 * v61;
              --v757;
            }
            while (v757);
          }
          goto LABEL_1228;
        case 13:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v766 = v894;
          v767 = v897[0];
          while (1)
          {
            v768 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v766 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1014;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v766.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAmultiplyPDA(v766, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1014:
              ++v64;
              v60 += 2 * v882;
              --v768;
            }
            while (v768);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v767)
              goto LABEL_1198;
          }
        case 14:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v771 = v894;
          v772 = v897[0];
          while (1)
          {
            v773 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v771 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1027;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v771.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAscreenPDA(v771, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1027:
              ++v64;
              v60 += 2 * v882;
              --v773;
            }
            while (v773);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v772)
              goto LABEL_1198;
          }
        case 15:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v776 = v894;
          v777 = v897[0];
          while (1)
          {
            v778 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v776 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1040;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v776.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAoverlayPDA(v776, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1040:
              ++v64;
              v60 += 2 * v882;
              --v778;
            }
            while (v778);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v777)
              goto LABEL_1198;
          }
        case 16:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v781 = (float16x4_t)v894.n128_u64[0];
          v782 = v897[0];
          while (1)
          {
            v783 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_Q4.f32[0] <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v781 = *(float16x4_t *)v890.f32;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1053;
                }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              v781.i16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAdarkenPDA(v781, _Q1, _Q2, _Q3, _Q4, (float32x4_t)v894, *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, (float16x4_t)v894.n128_u64[0], *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1053:
              ++v64;
              v60 += 2 * v882;
              --v783;
            }
            while (v783);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v782)
              goto LABEL_1198;
          }
        case 17:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v785 = (float16x4_t)v894.n128_u64[0];
          v786 = v897[0];
          while (1)
          {
            v787 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_Q4.f32[0] <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v785 = *(float16x4_t *)v890.f32;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1066;
                }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              v785.i16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAlightenPDA(v785, _Q1, _Q2, _Q3, _Q4, (float32x4_t)v894, *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, (float16x4_t)v894.n128_u64[0], *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1066:
              ++v64;
              v60 += 2 * v882;
              --v787;
            }
            while (v787);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v786)
              goto LABEL_1198;
          }
        case 18:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v789 = v894;
          v790 = v897[0];
          while (1)
          {
            v791 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v789 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1079;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v789.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAcolordodgePDA(v789, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1079:
              ++v64;
              v60 += 2 * v882;
              --v791;
            }
            while (v791);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v790)
              goto LABEL_1198;
          }
        case 19:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v794 = v894;
          v795 = v897[0];
          while (1)
          {
            v796 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v794 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1092;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v794.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAcolorburnPDA(v794, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1092:
              ++v64;
              v60 += 2 * v882;
              --v796;
            }
            while (v796);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v795)
              goto LABEL_1198;
          }
        case 20:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v799 = (float16x4_t)v894.n128_u64[0];
          v800 = v897[0];
          while (1)
          {
            v801 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_Q4.f32[0] <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v799 = *(float16x4_t *)v890.f32;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1105;
                }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              v799.i16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAsoftlightPDA(v799, _Q1, _Q2, _Q3, *(double *)_Q4.i64, (int32x2_t)v894.n128_u64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i32[0], v894.n128_i16[2], v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1105:
              ++v64;
              v60 += 2 * v882;
              --v801;
            }
            while (v801);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v800)
              goto LABEL_1198;
          }
        case 21:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v803 = v894;
          v804 = v897[0];
          while (1)
          {
            v805 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v803 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1118;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v803.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAhardlightPDA(v803, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1118:
              ++v64;
              v60 += 2 * v882;
              --v805;
            }
            while (v805);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v804)
              goto LABEL_1198;
          }
        case 22:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v808 = v894;
          v809 = v897[0];
          while (1)
          {
            v810 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_Q4.f32[0] <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v808 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1131;
                }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              v808.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAdifferencePDA(v808, _Q1, _Q2, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, (int32x2_t)v894.n128_u64[0], (float16x4_t)v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1131:
              ++v64;
              v60 += 2 * v882;
              --v810;
            }
            while (v810);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v809)
              goto LABEL_1198;
          }
        case 23:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v812 = v894;
          v813 = v897[0];
          while (1)
          {
            v814 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_Q4.f32[0] <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v812 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1144;
                }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              v812.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAexclusionPDA(v812, _Q1, _Q2, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, (float16x4_t)v894.n128_u64[0], *(double *)&v18, *(int32x2_t *)&v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1144:
              ++v64;
              v60 += 2 * v882;
              --v814;
            }
            while (v814);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v813)
              goto LABEL_1198;
          }
        case 24:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v816 = v894;
          v817 = v897[0];
          while (1)
          {
            v818 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v816 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1157;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v816.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAhuePDA(v816, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1157:
              ++v64;
              v60 += 2 * v882;
              --v818;
            }
            while (v818);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v817)
              goto LABEL_1198;
          }
        case 25:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v821 = v894;
          v822 = v897[0];
          while (1)
          {
            v823 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S4, H0 }
                if (_S4 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  v821 = (__n128)v890;
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1170;
                }
              }
              else
              {
                _S4 = 1.0;
              }
              v821.n128_u16[0] = v64->i16[0];
              _Q1.n128_u16[0] = v64->u16[1];
              _Q2.n128_u16[0] = v64->u16[2];
              _Q3.n128_u16[0] = v64->u16[3];
              v5 = PDAsaturationPDA(v821, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
                     v894.n128_i16[3],
                     *(float *)_D17.i32);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1170:
              ++v64;
              v60 += 2 * v882;
              --v823;
            }
            while (v823);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v822)
              goto LABEL_1198;
          }
        case 26:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          LOWORD(v3) = v894.n128_u16[2];
          LOWORD(v2) = v894.n128_u16[1];
          LOWORD(v4) = v894.n128_u16[3];
          v826 = v897[0];
          while (1)
          {
            v827 = v65;
            do
            {
              if (v22)
              {
                _H0 = *(_WORD *)v60;
                __asm { FCVT            S0, H0 }
                if (_S0 <= 0.0)
                {
                  *v64 = (float16x4_t)v894.n128_u64[0];
                  *(_WORD *)v60 = v890.i16[0];
                  goto LABEL_1183;
                }
              }
              else
              {
                _S0 = 1.0;
              }
              _Q1.n128_u32[0] = v2;
              _Q2.n128_u32[0] = v3;
              _Q3.n128_u32[0] = v4;
              v5 = PDAluminosityPDA(v894, _Q1, _Q2, _Q3, *(float *)_D17.i32, *(double *)_Q5.i64, *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v64->i32[0], HIWORD(v64->i32[0]), v64->i32[1],
                     HIWORD(v64->i32[1]),
                     _S0);
              *v64 = (float16x4_t)v5;
              if (v22)
                *(_WORD *)v60 = v6;
              _D17.i32[0] = v892.i32[0];
LABEL_1183:
              ++v64;
              v60 += 2 * v882;
              --v827;
            }
            while (v827);
            v64 += v58;
            v60 += 2 * v61;
            if (!--v826)
              goto LABEL_1198;
          }
        case 27:
          if (*(float *)_D17.i32 <= 0.0)
            goto LABEL_1229;
          v830 = v894;
          v831 = v897[0];
          break;
        default:
          goto LABEL_1230;
      }
LABEL_1188:
      v832 = v65;
      while (v22)
      {
        _H0 = *(_WORD *)v60;
        __asm { FCVT            S4, H0 }
        if (_S4 > 0.0)
          goto LABEL_1193;
        *v64 = (float16x4_t)v894.n128_u64[0];
        v830 = (__n128)v890;
        *(_WORD *)v60 = v890.i16[0];
LABEL_1196:
        ++v64;
        v60 += 2 * v882;
        if (!--v832)
        {
          v64 += v58;
          v60 += 2 * v61;
          if (!--v831)
          {
LABEL_1198:
            v897[0] = 0;
            LODWORD(v23) = v849;
            v51 = v878;
            v48 = v880;
LABEL_1229:
            v58 = v885;
LABEL_1230:
            if (!v42)
              return 1;
            v896 = 0;
LABEL_1232:
            v5 = shape_enum_clip_next((uint64_t)v42, (int *)&v896 + 1, &v896, v907, v897);
            if (!(_DWORD)v5)
              goto LABEL_66;
            v64 = (float16x4_t *)(v58 + 8 * v48 * (int)v896 + 8 * SHIDWORD(v896));
            v66 = v907[0];
            if (v22)
            {
              v60 = v888 + 2 * v51 * (int)v896 + 2 * SHIDWORD(v896);
              v61 = v51 - v907[0];
            }
            v65 = v907[0];
            _Q5.i64[0] = v890.i64[0];
            _D17 = v892;
            v18 = v886;
            goto LABEL_903;
          }
          goto LABEL_1188;
        }
      }
      _S4 = 1.0;
LABEL_1193:
      v830.n128_u16[0] = v64->i16[0];
      _Q1.n128_u16[0] = v64->u16[1];
      _Q2.n128_u16[0] = v64->u16[2];
      _Q3.n128_u16[0] = v64->u16[3];
      v5 = PDAluminosityPDA(v830, _Q1, _Q2, _Q3, _S4, v894.n128_f64[0], *(double *)&v18, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v894.n128_i16[0], v894.n128_i16[1], v894.n128_i16[2],
             v894.n128_i16[3],
             *(float *)_D17.i32);
      *v64 = (float16x4_t)v5;
      if (v22)
        *(_WORD *)v60 = v6;
      _D17.i32[0] = v892.i32[0];
      goto LABEL_1196;
    }
    v907[0] = *(_DWORD *)(v6 + 4);
    v897[0] = v28;
    v34 = *(int *)(v6 + 12);
    v33 = *(int *)(v6 + 16);
    v861 = (unint64_t)*(int *)(v6 + 28) >> 3;
    if (v22)
    {
      v855 = (unint64_t)*(int *)(v6 + 32) >> 1;
      v35 = (char *)(v22 + 2 * (v34 + v855 * v33));
      v36 = 0xFFFFFFFFLL;
    }
    else
    {
      v35 = 0;
      v855 = 0;
      v36 = 0;
    }
    v52 = *(float16x4_t **)(v6 + 88);
    v852 = *(_QWORD *)(v6 + 40) + 8 * (v34 + v33 * v861);
    v53 = *(unsigned int *)(v6 + 104);
    v54 = *(_DWORD *)(v6 + 56);
    v55 = *(_DWORD *)(v6 + 60);
    v884 = (unint64_t)*(int *)(v6 + 76) >> 3;
    if (v32 == 256)
    {
      if (v21)
      {
        v56 = (unint64_t)*(int *)(v6 + 80) >> 1;
        v21 += 2 * v54 + 2 * v56 * v55;
        v57 = 0xFFFFFFFFLL;
      }
      else
      {
        v56 = 0;
        v57 = 0;
      }
      v52 += v54 + v55 * v884;
      if (v884 == v861 && (uint64_t)(v852 - (_QWORD)v52) >= 1)
      {
        if (v26 >= (v852 - (unint64_t)v52) >> 3)
        {
          v852 += 8 * v27;
          v52 += v27;
          v35 += 2 * (v36 & v27);
          v7 = 0xFFFFFFFFLL;
          v884 = (unint64_t)*(int *)(v6 + 28) >> 3;
          v21 += 2 * (v57 & v27);
          goto LABEL_49;
        }
        if (v852 <= (unint64_t)&v52[v861 * v29 + v27])
        {
          v852 += 8 * v861 * v29;
          v35 += 2 * v855 * v29;
          v855 = -(uint64_t)v855;
          v21 += 2 * v56 * v29;
          v36 &= 1u;
          v56 = -(uint64_t)v56;
          v57 &= 1u;
          v7 = 1;
          v52 += v861 * v29;
          v884 = -(uint64_t)v861;
          v861 = -(uint64_t)v861;
          goto LABEL_49;
        }
      }
      v36 &= 1u;
      v57 &= 1u;
      v7 = 1;
LABEL_49:
      v846 = *(_DWORD *)(v6 + 60);
      v847 = *(_DWORD *)(v6 + 56);
      if (v30)
      {
        v85 = v21;
        v893 = v57;
        v895 = v36;
        v879 = 0;
        v881 = 0;
        v86 = -1;
        v891 = v56;
        v857 = v56;
        v858 = v884;
        goto LABEL_54;
      }
      v91 = (int)v7 * (int)v26;
      v889 = v855 - (int)v36 * (int)v26;
      v92 = -1;
      v856 = v7;
      v857 = v56;
      v93 = v884;
      v858 = v884;
LABEL_62:
      v881 = 0;
      v859 = 0;
      v860 = (uint64_t)v52;
      v97 = 0;
      v884 = v93 - v91;
      v891 = v56 - (int)v57 * (int)v26;
      v98 = (uint64_t)v21;
      v89 = v21;
      v90 = v35;
      v99 = (float16x4_t *)v852;
      goto LABEL_67;
    }
    v858 = *(_DWORD *)(v6 + 64);
    v857 = *(_DWORD *)(v6 + 68);
    if (v21)
    {
      v56 = (unint64_t)*(int *)(v6 + 80) >> 1;
      v57 = 1;
    }
    else
    {
      v56 = 0;
      v57 = 0;
    }
    v881 = &v52[v884 * v857];
    v36 &= 1u;
    if (v30)
    {
      v85 = v21;
      v846 = *(_DWORD *)(v6 + 60);
      v847 = *(_DWORD *)(v6 + 56);
      v893 = v57;
      v891 = v56;
      v895 = v36;
      LODWORD(v7) = 1;
      v879 = *(float16x4_t **)(v6 + 88);
      v86 = (uint64_t)v879;
LABEL_54:
      v856 = v7;
      shape_enum_clip_alloc(v5, v6, (int *)v30, v7, v861, 1, v53, *(_DWORD *)(v6 + 108), v26, v28);
      v88 = v87;
      v21 = v85;
      v883 = (uint64_t)v85;
      v89 = v85;
      v90 = v35;
      v889 = v855;
      if (v87)
        goto LABEL_852;
      return 1;
    }
    v889 = v855 - (v36 * v26);
    if (!v52)
    {
      v846 = *(_DWORD *)(v6 + 60);
      v847 = *(_DWORD *)(v6 + 56);
      v92 = 0;
      v856 = 1;
      v91 = v26;
      v93 = (unint64_t)*(int *)(v6 + 76) >> 3;
      goto LABEL_62;
    }
    v94 = v55 % v857;
    v846 = v55 % v857;
    v860 = *(_QWORD *)(v6 + 88);
    v95 = &v52[v884 * v94];
    v96 = v54 % v858;
    v97 = &v95[v96];
    v92 = (unint64_t)&v95[v858];
    v891 = v56;
    v847 = v96;
    v859 = 0;
    if (v21)
    {
      v98 = (uint64_t)&v21[2 * v56 * v94 + 2 * v96];
      v856 = 1;
      v57 = 1;
      v89 = (char *)v98;
    }
    else
    {
      v98 = 0;
      v89 = 0;
      v856 = 1;
    }
    v52 = &v95[v96];
    v90 = v35;
    v99 = (float16x4_t *)v852;
    v91 = v26;
LABEL_67:
    v895 = v36;
    v893 = v57;
    v887 = v861 - v91;
    v877 = v26;
    switch((int)v23)
    {
      case 0:
        v853 = v21;
        v879 = v97;
        v883 = v98;
        v86 = v92;
        v850 = v35;
        v101 = v887 - (int)v26;
        v102 = &v99[-(int)v26 + 1];
        if (v856 >= 0)
        {
          v102 = v99;
          v101 = v887 + (int)v26;
        }
        v103 = v897[0];
        v104 = v897[0] - 1;
        v105 = (char *)&v102[(v101 * v104) & (v101 >> 63)];
        if (v101 < 0)
          v101 = -v101;
        CGBlt_fillBytes(8 * v26, v897[0], 0, v105, 8 * v101);
        if ((_DWORD)v895)
        {
          if (v856 < 0)
          {
            v106 = v889 - (int)v26;
            v90 += -2 * (int)v26 + 2;
          }
          else
          {
            v106 = v889 + (int)v26;
          }
          v90 += 2 * ((v106 * v104) & (v106 >> 63));
          if (v106 < 0)
            v106 = -v106;
          v889 = v106;
          CGBlt_fillBytes(2 * v26, v103, 0, v90, 2 * v106);
        }
        goto LABEL_813;
      case 1:
        v107 = v35;
        v108 = *(unsigned __int8 *)(v25 + 1);
        if (v108 == 2)
        {
          if ((int)v26 >= 4 && (8 * v858) <= 0x40)
          {
            _Q0.n128_u32[0] = 8 * v858;
            v599 = (uint8x8_t)vcnt_s8((int8x8_t)_Q0.n128_u64[0]);
            v599.i16[0] = vaddlv_u8(v599);
            if (v599.i32[0] <= 1u)
            {
              v879 = v97;
              v883 = v98;
              v86 = v92;
              v600 = v897[0];
              v52 = (float16x4_t *)v860;
              CGSFillDRAM64(v99, 8 * (v26 + v887), 8 * v26, v897[0], v860, 8 * v884, 8 * v858, v857, 8 * v847, v846);
              if ((_DWORD)v895)
              {
                v88 = v859;
                if ((_DWORD)v893)
                  CGSFillDRAM64(v90, 2 * (v26 + v889), 2 * v26, v600, (uint64_t)v21, 2 * v891, 2 * v858, v857, 2 * v847, v846);
                else
                  CGBlt_fillBytes(2 * v26, v600, 1065353216, v90, 2 * (v26 + v889));
              }
              else
              {
                v88 = v859;
              }
              v35 = v107;
              if (v88)
                goto LABEL_851;
              return 1;
            }
          }
        }
        else if (v108 == 1)
        {
          v879 = v97;
          v883 = v98;
          v850 = v35;
          v853 = v21;
          v86 = v92;
          if (v856 < 0)
          {
            v109 = v884 - (int)v26;
            v52 += -(int)v26 + 1;
            v110 = v887 - (int)v26;
            v99 += -(int)v26 + 1;
          }
          else
          {
            v109 = v884 + (int)v26;
            v110 = v887 + (int)v26;
          }
          v634 = v897[0];
          v635 = v897[0] - 1;
          v636 = (char *)&v52[(v109 * v635) & (v109 >> 63)];
          if (v109 >= 0)
            v637 = v109;
          else
            v637 = -v109;
          if (v110 >= 0)
            LODWORD(v638) = v110;
          else
            v638 = -v110;
          v884 = v637;
          CGBlt_copyBytes(8 * v26, v897[0], v636, (char *)&v99[(v110 * v635) & (v110 >> 63)], 8 * v637, 8 * v638);
          if ((_DWORD)v895)
          {
            v639 = 2 * v26;
            v88 = v859;
            v52 = (float16x4_t *)v860;
            if ((_DWORD)v893)
            {
              v640 = v891 - (int)v26;
              v641 = &v89[-2 * (int)v26 + 2];
              v642 = v889 - (int)v26;
              v643 = &v90[-2 * (int)v26 + 2];
              if (v856 >= 0)
              {
                v641 = v89;
                v643 = v90;
                v640 = v891 + (int)v26;
                v642 = v889 + (int)v26;
              }
              v89 = &v641[2 * ((v640 * v635) & (v640 >> 63))];
              if (v640 >= 0)
                v644 = v640;
              else
                v644 = -v640;
              v90 = &v643[2 * ((v642 * v635) & (v642 >> 63))];
              if (v642 >= 0)
                v645 = v642;
              else
                v645 = -v642;
              v889 = v645;
              v891 = v644;
              CGBlt_copyBytes(v639, v634, v89, v90, 2 * v644, 2 * v645);
            }
            else
            {
              v646 = v889 - (int)v26;
              v647 = &v90[-2 * (int)v26 + 2];
              if (v856 >= 0)
              {
                v647 = v90;
                v646 = v889 + (int)v26;
              }
              v648 = (v646 * v635) & (v646 >> 63);
              v90 = &v647[2 * v648];
              if (v646 < 0)
                v646 = -v646;
              v889 = v646;
              CGBlt_fillBytes(v639, v634, 1065353216, &v647[2 * v648], 2 * v646);
            }
            LODWORD(v23) = v849;
            v35 = v850;
          }
          else
          {
LABEL_813:
            LODWORD(v23) = v849;
            v35 = v850;
            v88 = v859;
            v52 = (float16x4_t *)v860;
          }
          v21 = v853;
          if (v88)
            goto LABEL_851;
          return 1;
        }
        if ((_DWORD)v36)
        {
          v601 = 2 * (int)v36;
          v602 = 8 * v856;
          if ((_DWORD)v57)
          {
            v603 = v897[0];
            do
            {
              v604 = v26;
              do
              {
                *v99 = *v52;
                *(_WORD *)v90 = *(_WORD *)v89;
                v605 = &v52[v856];
                if ((unint64_t)v605 >= v92)
                  v606 = -(uint64_t)v858;
                else
                  v606 = 0;
                v89 += 2 * (int)v57 + 2 * v606;
                v52 = &v605[v606];
                v90 += v601;
                v99 = (float16x4_t *)((char *)v99 + v602);
                --v604;
              }
              while (v604);
              if (v881)
              {
                v607 = &v97[v884];
                if (v607 >= v881)
                  v608 = -(uint64_t)(v891 * v857);
                else
                  v608 = 0;
                v98 += 2 * v891 + 2 * v608;
                if (v607 >= v881)
                  v609 = -(uint64_t)(v884 * v857);
                else
                  v609 = 0;
                v97 = &v607[v609];
                v92 += 8 * v609 + 8 * v884;
                v89 = (char *)v98;
                v52 = v97;
              }
              else
              {
                v52 += v884;
                v89 += 2 * v891;
              }
              v99 += v887;
              v90 += 2 * v889;
              --v603;
            }
            while (v603);
          }
          else
          {
            v617 = v897[0];
            do
            {
              v618 = v26;
              do
              {
                *v99 = *v52;
                *(_WORD *)v90 = 15360;
                v619 = &v52[v856];
                if ((unint64_t)v619 >= v92)
                  v620 = -(uint64_t)v858;
                else
                  v620 = 0;
                v89 += 2 * v620;
                v52 = &v619[v620];
                v90 += v601;
                v99 = (float16x4_t *)((char *)v99 + v602);
                --v618;
              }
              while (v618);
              if (v881)
              {
                v621 = &v97[v884];
                if (v621 >= v881)
                  v622 = -(uint64_t)(v891 * v857);
                else
                  v622 = 0;
                v98 += 2 * v891 + 2 * v622;
                if (v621 >= v881)
                  v623 = -(uint64_t)(v884 * v857);
                else
                  v623 = 0;
                v97 = &v621[v623];
                v92 += 8 * v623 + 8 * v884;
                v89 = (char *)v98;
                v52 = v97;
              }
              else
              {
                v52 += v884;
                v89 += 2 * v891;
              }
              v99 += v887;
              v90 += 2 * v889;
              --v617;
            }
            while (v617);
          }
        }
        else
        {
          v610 = v897[0];
          do
          {
            v611 = v26;
            do
            {
              *v99 = *v52;
              v612 = &v52[v856];
              if ((unint64_t)v612 >= v92)
                v613 = -(uint64_t)v858;
              else
                v613 = 0;
              v89 += 2 * (int)v57 + 2 * v613;
              v52 = &v612[v613];
              v99 += v856;
              --v611;
            }
            while (v611);
            if (v881)
            {
              v614 = &v97[v884];
              if (v614 >= v881)
                v615 = -(uint64_t)(v891 * v857);
              else
                v615 = 0;
              v98 += 2 * v891 + 2 * v615;
              if (v614 >= v881)
                v616 = -(uint64_t)(v884 * v857);
              else
                v616 = 0;
              v97 = &v614[v616];
              v92 += 8 * v616 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v610;
          }
          while (v610);
        }
        goto LABEL_849;
      case 2:
        if ((_DWORD)v36)
        {
          v111 = v897[0];
          v112 = 2 * (int)v36;
          while (1)
          {
            v113 = v26;
            do
            {
              _H1 = *(_WORD *)v89;
              __asm { FCVT            S1, H1 }
              if (_S1 >= 1.0)
              {
                *v99 = *v52;
                _H1 = *(_WORD *)v89;
              }
              else
              {
                if (_S1 <= 0.0)
                  goto LABEL_88;
                *v99 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v52), vcvtq_f32_f16(*v99), 1.0 - _S1));
                _H3 = *(_WORD *)v90;
                __asm { FCVT            S3, H3 }
                _S1 = _S1 + (float)(_S3 * (float)(1.0 - _S1));
                __asm { FCVT            H1, S1 }
              }
              *(_WORD *)v90 = _H1;
LABEL_88:
              v120 = &v52[v856];
              if ((unint64_t)v120 >= v92)
                v121 = -(uint64_t)v858;
              else
                v121 = 0;
              v89 += 2 * (int)v57 + 2 * v121;
              v52 = &v120[v121];
              v90 += v112;
              v99 += v856;
              --v113;
            }
            while (v113);
            if (v881)
            {
              v122 = &v97[v884];
              if (v122 >= v881)
                v123 = -(uint64_t)(v891 * v857);
              else
                v123 = 0;
              v98 += 2 * v891 + 2 * v123;
              if (v122 >= v881)
                v124 = -(uint64_t)(v884 * v857);
              else
                v124 = 0;
              v97 = &v122[v124];
              v92 += 8 * v124 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            if (!--v111)
              goto LABEL_849;
          }
        }
        v511 = v897[0];
LABEL_657:
        v512 = v26;
        while (1)
        {
          _H1 = *(_WORD *)v89;
          __asm { FCVT            S1, H1 }
          if (_S1 >= 1.0)
            break;
          if (_S1 > 0.0)
          {
            v515 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v52), vcvtq_f32_f16(*v99), 1.0 - _S1));
LABEL_662:
            *v99 = v515;
          }
          v516 = &v52[v856];
          if ((unint64_t)v516 >= v92)
            v517 = -(uint64_t)v858;
          else
            v517 = 0;
          v89 += 2 * (int)v57 + 2 * v517;
          v52 = &v516[v517];
          v99 += v856;
          if (!--v512)
          {
            if (v881)
            {
              v518 = &v97[v884];
              if (v518 >= v881)
                v519 = -(uint64_t)(v891 * v857);
              else
                v519 = 0;
              v98 += 2 * v891 + 2 * v519;
              if (v518 >= v881)
                v520 = -(uint64_t)(v884 * v857);
              else
                v520 = 0;
              v97 = &v518[v520];
              v92 += 8 * v520 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            if (!--v511)
            {
LABEL_849:
              v879 = v97;
              v883 = v98;
              v86 = v92;
              v897[0] = 0;
LABEL_850:
              v88 = v859;
              v52 = (float16x4_t *)v860;
              if (!v859)
                return 1;
LABEL_851:
              v896 = 0;
LABEL_852:
              if (!shape_enum_clip_next(v88, (int *)&v896 + 1, &v896, v907, v897))
              {
                v100 = (void *)v88;
LABEL_874:
                free(v100);
                return 1;
              }
              v859 = v88;
              v860 = (uint64_t)v52;
              if (v881)
              {
                v99 = (float16x4_t *)(v852 + 8 * v861 * (int)v896 + 8 * SHIDWORD(v896));
                v624 = ((int)v896 + *(_DWORD *)(v25 + 60)) % v857;
                v91 = v907[0];
                v625 = (HIDWORD(v896) + *(_DWORD *)(v25 + 56)) % v858;
                v626 = &v52[v884 * v624];
                v97 = &v626[v625];
                v92 = (unint64_t)&v626[v858];
                v36 = v895;
                if ((_DWORD)v895)
                  v90 = &v35[2 * v855 * (int)v896 + 2 * SHIDWORD(v896)];
                v627 = v889;
                if ((_DWORD)v895)
                  v627 = v855 - v907[0];
                v889 = v627;
                if ((_DWORD)v893)
                  v57 = v893;
                else
                  v57 = 0;
                v98 = v883;
                if ((_DWORD)v893)
                {
                  v98 = (uint64_t)&v21[2 * v891 * v624 + 2 * v625];
                  v89 = (char *)v98;
                }
                LODWORD(v26) = v907[0];
                v52 = &v626[v625];
                v846 = ((int)v896 + *(_DWORD *)(v25 + 60)) % v857;
                v847 = (HIDWORD(v896) + *(_DWORD *)(v25 + 56)) % v858;
              }
              else
              {
                v881 = 0;
                v628 = HIDWORD(v896) * v856;
                LODWORD(v26) = v907[0];
                v629 = v907[0] * v856;
                v99 = (float16x4_t *)(v852 + 8 * v861 * (int)v896 + 8 * HIDWORD(v896) * v856);
                v91 = v907[0] * v856;
                v52 += (int)v896 * v858 + HIDWORD(v896) * v856;
                v884 = v858 - v907[0] * v856;
                v36 = v895;
                if ((_DWORD)v895)
                  v90 = &v35[2 * v855 * (int)v896 + 2 * v628];
                v630 = v889;
                if ((_DWORD)v895)
                  v630 = v855 - v629;
                v631 = (uint64_t)&v21[2 * (int)v896 * v857 + 2 * v628];
                v632 = v857 - v629;
                v57 = v893;
                if ((_DWORD)v893)
                  v89 = (char *)v631;
                v633 = v891;
                if ((_DWORD)v893)
                  v633 = v632;
                v889 = v630;
                v891 = v633;
                v92 = v86;
                v98 = v883;
                v97 = v879;
              }
              goto LABEL_67;
            }
            goto LABEL_657;
          }
        }
        v515 = *v52;
        goto LABEL_662;
      case 3:
        v125 = (int)v36;
        if ((_DWORD)v57)
        {
          v126 = v897[0];
          v127 = 2 * (int)v36;
          do
          {
            v128 = v26;
            do
            {
              _H1 = *(_WORD *)v90;
              __asm { FCVT            S1, H1 }
              if (_S1 <= 0.0)
              {
                *v99 = 0;
                _H1 = 0;
              }
              else
              {
                _H2 = v52->i16[0];
                if (_S1 >= 1.0)
                {
                  v99->i16[0] = _H2;
                  v99->i16[1] = v52->i16[1];
                  v99->i32[1] = v52->i32[1];
                  _H1 = *(_WORD *)v89;
                }
                else
                {
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[0] = LOWORD(_S2);
                  LOWORD(_S2) = v52->i16[1];
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[1] = LOWORD(_S2);
                  LOWORD(_S2) = v52->i16[2];
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[2] = LOWORD(_S2);
                  LOWORD(_S2) = v52->i16[3];
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[3] = LOWORD(_S2);
                  LOWORD(_S2) = *(_WORD *)v89;
                  __asm { FCVT            S2, H2 }
                  _S1 = _S1 * _S2;
                  __asm { FCVT            H1, S1 }
                }
              }
              *(_WORD *)v90 = _H1;
              v143 = &v52[v856];
              if ((unint64_t)v143 >= v92)
                v144 = -(uint64_t)v858;
              else
                v144 = 0;
              v89 += 2 * (int)v57 + 2 * v144;
              v52 = &v143[v144];
              v90 += v127;
              v99 += v856;
              --v128;
            }
            while (v128);
            if (v881)
            {
              v145 = &v97[v884];
              if (v145 >= v881)
                v146 = -(uint64_t)(v891 * v857);
              else
                v146 = 0;
              v98 += 2 * v891 + 2 * v146;
              if (v145 >= v881)
                v147 = -(uint64_t)(v884 * v857);
              else
                v147 = 0;
              v97 = &v145[v147];
              v92 += 8 * v147 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v126;
          }
          while (v126);
        }
        else
        {
          v521 = v897[0];
          do
          {
            v522 = v26;
            do
            {
              _H1 = *(_WORD *)v90;
              __asm { FCVT            S1, H1 }
              if (_S1 <= 0.0)
              {
                *v99 = 0;
              }
              else
              {
                _H2 = v52->i16[0];
                if (_S1 >= 1.0)
                {
                  v99->i16[0] = _H2;
                  v99->i16[1] = v52->i16[1];
                  v99->i32[1] = v52->i32[1];
                }
                else
                {
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[0] = LOWORD(_S2);
                  LOWORD(_S2) = v52->i16[1];
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[1] = LOWORD(_S2);
                  LOWORD(_S2) = v52->i16[2];
                  __asm { FCVT            S2, H2 }
                  _S2 = _S1 * _S2;
                  __asm { FCVT            H2, S2 }
                  v99->i16[2] = LOWORD(_S2);
                  LOWORD(_S2) = v52->i16[3];
                  __asm { FCVT            S2, H2 }
                  _S1 = _S1 * _S2;
                  __asm { FCVT            H1, S1 }
                  v99->i16[3] = LOWORD(_S1);
                }
              }
              v534 = &v52[v856];
              if ((unint64_t)v534 >= v92)
                v535 = -(uint64_t)v858;
              else
                v535 = 0;
              v89 += 2 * v535;
              v52 = &v534[v535];
              v90 += 2 * v125;
              v99 += v856;
              --v522;
            }
            while (v522);
            if (v881)
            {
              v536 = &v97[v884];
              if (v536 >= v881)
                v537 = -(uint64_t)(v891 * v857);
              else
                v537 = 0;
              v98 += 2 * v891 + 2 * v537;
              if (v536 >= v881)
                v538 = -(uint64_t)(v884 * v857);
              else
                v538 = 0;
              v97 = &v536[v538];
              v92 += 8 * v538 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v521;
          }
          while (v521);
        }
        goto LABEL_849;
      case 4:
        v148 = v897[0];
        v149 = 2 * (int)v36;
        do
        {
          v150 = v26;
          do
          {
            _H2 = *(_WORD *)v90;
            __asm { FCVT            S2, H2 }
            v153 = 1.0 - _S2;
            if (v153 <= 0.0)
            {
              *v99 = 0;
              _H2 = 0;
            }
            else if (v153 >= 1.0)
            {
              _H2 = 15360;
              if ((_DWORD)v57)
                _H2 = *(_WORD *)v89;
            }
            else
            {
              *v99 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v52), v153));
              if ((_DWORD)v57)
              {
                _H3 = *(_WORD *)v89;
                __asm { FCVT            S3, H3 }
              }
              else
              {
                _S3 = 1.0;
              }
              _S2 = v153 * _S3;
              __asm { FCVT            H2, S2 }
            }
            *(_WORD *)v90 = _H2;
            v158 = &v52[v856];
            if ((unint64_t)v158 >= v92)
              v159 = -(uint64_t)v858;
            else
              v159 = 0;
            v89 += 2 * (int)v57 + 2 * v159;
            v52 = &v158[v159];
            v90 += v149;
            v99 += v856;
            --v150;
          }
          while (v150);
          if (v881)
          {
            v160 = &v97[v884];
            if (v160 >= v881)
              v161 = -(uint64_t)(v891 * v857);
            else
              v161 = 0;
            v98 += 2 * v891 + 2 * v161;
            if (v160 >= v881)
              v162 = -(uint64_t)(v884 * v857);
            else
              v162 = 0;
            v97 = &v160[v162];
            v92 += 8 * v162 + 8 * v884;
            v89 = (char *)v98;
            v52 = v97;
          }
          else
          {
            v52 += v884;
            v89 += 2 * v891;
          }
          v99 += v887;
          v90 += 2 * v889;
          --v148;
        }
        while (v148);
        goto LABEL_849;
      case 5:
        v163 = v897[0];
        v164 = 2 * (int)v36;
        do
        {
          v165 = v26;
          do
          {
            _H1 = *(_WORD *)v90;
            __asm { FCVT            S1, H1 }
            _H2 = *(_WORD *)v89;
            __asm { FCVT            S2, H2 }
            *v99 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v99), 1.0 - _S2), vcvtq_f32_f16(*v52), _S1));
            _S1 = (float)((float)(1.0 - _S2) * _S1) + (float)(_S2 * _S1);
            __asm { FCVT            H1, S1 }
            *(_WORD *)v90 = LOWORD(_S1);
            v171 = &v52[v856];
            if ((unint64_t)v171 >= v92)
              v172 = -(uint64_t)v858;
            else
              v172 = 0;
            v89 += 2 * (int)v57 + 2 * v172;
            v52 = &v171[v172];
            v90 += v164;
            v99 += v856;
            --v165;
          }
          while (v165);
          if (v881)
          {
            v173 = &v97[v884];
            if (v173 >= v881)
              v174 = -(uint64_t)(v891 * v857);
            else
              v174 = 0;
            v98 += 2 * v891 + 2 * v174;
            if (v173 >= v881)
              v175 = -(uint64_t)(v884 * v857);
            else
              v175 = 0;
            v97 = &v173[v175];
            v92 += 8 * v175 + 8 * v884;
            v89 = (char *)v98;
            v52 = v97;
          }
          else
          {
            v52 += v884;
            v89 += 2 * v891;
          }
          v99 += v887;
          v90 += 2 * v889;
          --v163;
        }
        while (v163);
        goto LABEL_849;
      case 6:
        v176 = v897[0];
        v177 = 2 * (int)v36;
        while (1)
        {
          v178 = v26;
          do
          {
            _H2 = *(_WORD *)v90;
            __asm { FCVT            S2, H2 }
            v181 = 1.0 - _S2;
            if ((float)(1.0 - _S2) >= 1.0)
            {
              *v99 = *v52;
              _H2 = 15360;
              if ((_DWORD)v57)
                _H2 = *(_WORD *)v89;
            }
            else
            {
              if (v181 <= 0.0)
                goto LABEL_180;
              *v99 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v99), vcvtq_f32_f16(*v52), v181));
              if ((_DWORD)v57)
              {
                _H4 = *(_WORD *)v89;
                __asm { FCVT            S4, H4 }
              }
              else
              {
                _S4 = 1.0;
              }
              _S2 = _S2 + (float)(_S4 * v181);
              __asm { FCVT            H2, S2 }
            }
            *(_WORD *)v90 = _H2;
LABEL_180:
            v186 = &v52[v856];
            if ((unint64_t)v186 >= v92)
              v187 = -(uint64_t)v858;
            else
              v187 = 0;
            v89 += 2 * (int)v57 + 2 * v187;
            v52 = &v186[v187];
            v90 += v177;
            v99 += v856;
            --v178;
          }
          while (v178);
          if (v881)
          {
            v188 = &v97[v884];
            if (v188 >= v881)
              v189 = -(uint64_t)(v891 * v857);
            else
              v189 = 0;
            v98 += 2 * v891 + 2 * v189;
            if (v188 >= v881)
              v190 = -(uint64_t)(v884 * v857);
            else
              v190 = 0;
            v97 = &v188[v190];
            v92 += 8 * v190 + 8 * v884;
            v89 = (char *)v98;
            v52 = v97;
          }
          else
          {
            v52 += v884;
            v89 += 2 * v891;
          }
          v99 += v887;
          v90 += 2 * v889;
          if (!--v176)
            goto LABEL_849;
        }
      case 7:
        if (!(_DWORD)v36)
        {
          v539 = v897[0];
          do
          {
            v540 = v26;
            do
            {
              _Q1.n128_u16[0] = *(_WORD *)v89;
              __asm { FCVT            S2, H1 }
              if (_S2 <= 0.0)
              {
                *v99 = 0;
              }
              else if (_S2 < 1.0)
              {
                _Q1.n128_u64[0] = (unint64_t)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16((int16x4_t)_Q1.n128_u64[0], 0)), vcvtq_f32_f16(*v99)));
                *v99 = (float16x4_t)_Q1.n128_u64[0];
              }
              v542 = &v52[v856];
              if ((unint64_t)v542 >= v92)
                v543 = -(uint64_t)v858;
              else
                v543 = 0;
              v89 += 2 * (int)v57 + 2 * v543;
              v52 = &v542[v543];
              v99 += v856;
              --v540;
            }
            while (v540);
            if (v881)
            {
              v544 = &v97[v884];
              if (v544 >= v881)
                v545 = -(uint64_t)(v891 * v857);
              else
                v545 = 0;
              v98 += 2 * v891 + 2 * v545;
              if (v544 >= v881)
                v546 = -(uint64_t)(v884 * v857);
              else
                v546 = 0;
              v97 = &v544[v546];
              v92 += 8 * v546 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v539;
          }
          while (v539);
          goto LABEL_849;
        }
        v191 = v897[0];
        v192 = 2 * (int)v36;
LABEL_197:
        v193 = v26;
        while (1)
        {
          _Q2.n128_u16[0] = *(_WORD *)v89;
          __asm { FCVT            S1, H2 }
          if (_S1 <= 0.0)
            break;
          if (_S1 < 1.0)
          {
            _Q2.n128_u64[0] = (unint64_t)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16((int16x4_t)_Q2.n128_u64[0], 0)), vcvtq_f32_f16(*v99)));
            *v99 = (float16x4_t)_Q2.n128_u64[0];
            _Q2.n128_u16[0] = *(_WORD *)v90;
            __asm { FCVT            S2, H2 }
            _S1 = _S1 * _Q2.n128_f32[0];
            __asm { FCVT            H1, S1 }
LABEL_202:
            *(_WORD *)v90 = _H1;
          }
          v197 = &v52[v856];
          if ((unint64_t)v197 >= v92)
            v198 = -(uint64_t)v858;
          else
            v198 = 0;
          v89 += 2 * (int)v57 + 2 * v198;
          v52 = &v197[v198];
          v90 += v192;
          v99 += v856;
          if (!--v193)
          {
            if (v881)
            {
              v199 = &v97[v884];
              if (v199 >= v881)
                v200 = -(uint64_t)(v891 * v857);
              else
                v200 = 0;
              v98 += 2 * v891 + 2 * v200;
              if (v199 >= v881)
                v201 = -(uint64_t)(v884 * v857);
              else
                v201 = 0;
              v97 = &v199[v201];
              v92 += 8 * v201 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            if (!--v191)
              goto LABEL_849;
            goto LABEL_197;
          }
        }
        *v99 = 0;
        _H1 = 0;
        goto LABEL_202;
      case 8:
        if (!(_DWORD)v36)
        {
          v547 = v897[0];
          do
          {
            v548 = v26;
            do
            {
              _H1 = *(_WORD *)v89;
              __asm { FCVT            S1, H1 }
              v551 = 1.0 - _S1;
              if (v551 <= 0.0)
              {
                *v99 = 0;
              }
              else if (v551 < 1.0)
              {
                *v99 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v99), v551));
              }
              v552 = &v52[v856];
              if ((unint64_t)v552 >= v92)
                v553 = -(uint64_t)v858;
              else
                v553 = 0;
              v89 += 2 * (int)v57 + 2 * v553;
              v52 = &v552[v553];
              v99 += v856;
              --v548;
            }
            while (v548);
            if (v881)
            {
              v554 = &v97[v884];
              if (v554 >= v881)
                v555 = -(uint64_t)(v891 * v857);
              else
                v555 = 0;
              v98 += 2 * v891 + 2 * v555;
              if (v554 >= v881)
                v556 = -(uint64_t)(v884 * v857);
              else
                v556 = 0;
              v97 = &v554[v556];
              v92 += 8 * v556 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v547;
          }
          while (v547);
          goto LABEL_849;
        }
        v202 = v897[0];
        v203 = 2 * (int)v36;
LABEL_220:
        v204 = v26;
        break;
      case 9:
        v217 = v897[0];
        v218 = 2 * (int)v36;
        do
        {
          v219 = v26;
          do
          {
            _H1 = *(_WORD *)v90;
            __asm { FCVT            S1, H1 }
            _H2 = *(_WORD *)v89;
            __asm { FCVT            S2, H2 }
            *v99 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v99), _S2), vcvtq_f32_f16(*v52), 1.0 - _S1));
            _S1 = (float)(_S1 * _S2) + (float)(_S2 * (float)(1.0 - _S1));
            __asm { FCVT            H1, S1 }
            *(_WORD *)v90 = LOWORD(_S1);
            v225 = &v52[v856];
            if ((unint64_t)v225 >= v92)
              v226 = -(uint64_t)v858;
            else
              v226 = 0;
            v89 += 2 * (int)v57 + 2 * v226;
            v52 = &v225[v226];
            v90 += v218;
            v99 += v856;
            --v219;
          }
          while (v219);
          if (v881)
          {
            v227 = &v97[v884];
            if (v227 >= v881)
              v228 = -(uint64_t)(v891 * v857);
            else
              v228 = 0;
            v98 += 2 * v891 + 2 * v228;
            if (v227 >= v881)
              v229 = -(uint64_t)(v884 * v857);
            else
              v229 = 0;
            v97 = &v227[v229];
            v92 += 8 * v229 + 8 * v884;
            v89 = (char *)v98;
            v52 = v97;
          }
          else
          {
            v52 += v884;
            v89 += 2 * v891;
          }
          v99 += v887;
          v90 += 2 * v889;
          --v217;
        }
        while (v217);
        goto LABEL_849;
      case 10:
        v230 = v897[0];
        v231 = 2 * (int)v36;
        do
        {
          v232 = v26;
          do
          {
            _H1 = *(_WORD *)v90;
            __asm { FCVT            S1, H1 }
            _H2 = *(_WORD *)v89;
            __asm { FCVT            S2, H2 }
            *v99 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v99), 1.0 - _S2), vcvtq_f32_f16(*v52), 1.0 - _S1));
            _S1 = (float)((float)(1.0 - _S2) * _S1) + (float)(_S2 * (float)(1.0 - _S1));
            __asm { FCVT            H1, S1 }
            *(_WORD *)v90 = LOWORD(_S1);
            v238 = &v52[v856];
            if ((unint64_t)v238 >= v92)
              v239 = -(uint64_t)v858;
            else
              v239 = 0;
            v89 += 2 * (int)v57 + 2 * v239;
            v52 = &v238[v239];
            v90 += v231;
            v99 += v856;
            --v232;
          }
          while (v232);
          if (v881)
          {
            v240 = &v97[v884];
            if (v240 >= v881)
              v241 = -(uint64_t)(v891 * v857);
            else
              v241 = 0;
            v98 += 2 * v891 + 2 * v241;
            if (v240 >= v881)
              v242 = -(uint64_t)(v884 * v857);
            else
              v242 = 0;
            v97 = &v240[v242];
            v92 += 8 * v242 + 8 * v884;
            v89 = (char *)v98;
            v52 = v97;
          }
          else
          {
            v52 += v884;
            v89 += 2 * v891;
          }
          v99 += v887;
          v90 += 2 * v889;
          --v230;
        }
        while (v230);
        goto LABEL_849;
      case 11:
        if ((_DWORD)v36)
        {
          v243 = v897[0];
          v244 = 2 * (int)v36;
          do
          {
            v245 = v26;
            do
            {
              _S1 = 1.0;
              _S2 = 1.0;
              if ((_DWORD)v57)
              {
                _H0 = *(_WORD *)v89;
                __asm { FCVT            S2, H0 }
              }
              _H0 = *(_WORD *)v90;
              __asm { FCVT            S3, H0 }
              _S0 = _S2 + _S3;
              if ((float)(_S2 + _S3) > 1.0)
                _S0 = 1.0;
              if ((_DWORD)v57)
              {
                _H1 = *(_WORD *)v89;
                __asm { FCVT            S1, H1 }
              }
              _H4 = v99->i16[0];
              __asm { FCVT            S4, H4 }
              _H5 = v52->i16[0];
              __asm { FCVT            S5, H5 }
              v257 = (float)(_S3 - _S4) + (float)(_S2 - _S5);
              _H6 = v99->i16[1];
              _H5 = v52->i16[1];
              _S2 = _S0 - v257;
              __asm { FCVT            H2, S2 }
              v99->i16[0] = LOWORD(_S2);
              _S2 = 1.0;
              _S4 = 1.0;
              if ((_DWORD)v57)
              {
                _H4 = *(_WORD *)v89;
                __asm { FCVT            S4, H4 }
              }
              __asm
              {
                FCVT            S6, H6
                FCVT            S5, H5
              }
              v266 = (float)(_S3 - _S6) + (float)(_S1 - _S5);
              _H3 = *(_WORD *)v90;
              _H5 = v99->i16[2];
              _H1 = v52->i16[2];
              _S6 = _S0 - v266;
              __asm { FCVT            H6, S6 }
              v99->i16[1] = LOWORD(_S6);
              _H6 = *(_WORD *)v90;
              if ((_DWORD)v57)
              {
                _H2 = *(_WORD *)v89;
                __asm { FCVT            S2, H2 }
              }
              __asm
              {
                FCVT            S3, H3
                FCVT            S5, H5
                FCVT            S1, H1
              }
              v276 = (float)(_S3 - _S5) + (float)(_S4 - _S1);
              __asm { FCVT            S3, H6 }
              _H4 = v99->i16[3];
              __asm { FCVT            S4, H4 }
              v280 = _S3 - _S4;
              LOWORD(_S4) = v52->i16[3];
              __asm { FCVT            S4, H4 }
              _S1 = _S0 - v276;
              __asm { FCVT            H1, S1 }
              v99->i16[2] = LOWORD(_S1);
              __asm { FCVT            H1, S0 }
              *(_WORD *)v90 = LOWORD(_S1);
              _S0 = _S0 - (float)(v280 + (float)(_S2 - _S4));
              __asm { FCVT            H0, S0 }
              v99->i16[3] = LOWORD(_S0);
              v284 = &v52[v856];
              if ((unint64_t)v284 >= v92)
                v285 = -(uint64_t)v858;
              else
                v285 = 0;
              v89 += 2 * (int)v57 + 2 * v285;
              v52 = &v284[v285];
              v90 += v244;
              v99 += v856;
              --v245;
            }
            while (v245);
            if (v881)
            {
              v286 = &v97[v884];
              if (v286 >= v881)
                v287 = -(uint64_t)(v891 * v857);
              else
                v287 = 0;
              v98 += 2 * v891 + 2 * v287;
              if (v286 >= v881)
                v288 = -(uint64_t)(v884 * v857);
              else
                v288 = 0;
              v97 = &v286[v288];
              v92 += 8 * v288 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v243;
          }
          while (v243);
        }
        else
        {
          v557 = v897[0];
          do
          {
            v558 = v26;
            do
            {
              _S2 = 1.0;
              if ((_DWORD)v57)
              {
                _H2 = *(_WORD *)v89;
                __asm { FCVT            S2, H2 }
              }
              _S3 = 1.0;
              if ((_DWORD)v57)
              {
                _H3 = *(_WORD *)v89;
                __asm { FCVT            S3, H3 }
              }
              _H4 = v99->i16[0];
              __asm { FCVT            S4, H4 }
              _H5 = v52->i16[0];
              __asm { FCVT            S5, H5 }
              v567 = (float)(1.0 - _S4) + (float)(_S2 - _S5);
              LOWORD(_S4) = v99->i16[1];
              __asm { FCVT            S4, H4 }
              v569 = 1.0 - _S4;
              LOWORD(_S4) = v52->i16[1];
              __asm { FCVT            S4, H4 }
              _S2 = 1.0 - v567;
              __asm { FCVT            H2, S2 }
              v99->i16[0] = LOWORD(_S2);
              _S2 = 1.0 - (float)(v569 + (float)(_S3 - _S4));
              __asm { FCVT            H2, S2 }
              v99->i16[1] = LOWORD(_S2);
              _S2 = 1.0;
              if ((_DWORD)v57)
              {
                _H2 = *(_WORD *)v89;
                __asm { FCVT            S2, H2 }
              }
              _H4 = v52->i16[2];
              _S3 = 1.0;
              if ((_DWORD)v57)
              {
                _H3 = *(_WORD *)v89;
                __asm { FCVT            S3, H3 }
              }
              _H5 = v99->i16[2];
              __asm
              {
                FCVT            S5, H5
                FCVT            S4, H4
              }
              v581 = (float)(1.0 - _S5) + (float)(_S2 - _S4);
              LOWORD(_S4) = v99->i16[3];
              __asm { FCVT            S4, H4 }
              v583 = 1.0 - _S4;
              LOWORD(_S4) = v52->i16[3];
              __asm { FCVT            S4, H4 }
              _S2 = 1.0 - v581;
              __asm { FCVT            H2, S2 }
              v99->i16[2] = LOWORD(_S2);
              _S1 = 1.0 - (float)(v583 + (float)(_S3 - _S4));
              __asm { FCVT            H1, S1 }
              v99->i16[3] = LOWORD(_S1);
              v587 = &v52[v856];
              if ((unint64_t)v587 >= v92)
                v588 = -(uint64_t)v858;
              else
                v588 = 0;
              v89 += 2 * (int)v57 + 2 * v588;
              v52 = &v587[v588];
              v99 += v856;
              --v558;
            }
            while (v558);
            if (v881)
            {
              v589 = &v97[v884];
              if (v589 >= v881)
                v590 = -(uint64_t)(v891 * v857);
              else
                v590 = 0;
              v98 += 2 * v891 + 2 * v590;
              if (v589 >= v881)
                v591 = -(uint64_t)(v884 * v857);
              else
                v591 = 0;
              v97 = &v589[v591];
              v92 += 8 * v591 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v557;
          }
          while (v557);
        }
        goto LABEL_849;
      case 12:
        if ((_DWORD)v36)
        {
          v289 = v897[0];
          v290 = 2 * (int)v36;
          do
          {
            v291 = v26;
            do
            {
              if ((_DWORD)v57)
              {
                _H1 = *(_WORD *)v89;
                __asm { FCVT            S1, H1 }
              }
              else
              {
                _S1 = 1.0;
              }
              _H2 = *(_WORD *)v90;
              __asm { FCVT            S2, H2 }
              _S1 = _S1 + _S2;
              _H2 = v99->i16[0];
              _H3 = v52->i16[0];
              if (_S1 > 1.0)
                _S1 = 1.0;
              _H4 = v99->i16[1];
              _H5 = v52->i16[1];
              __asm { FCVT            H1, S1 }
              *(_WORD *)v90 = _H1;
              __asm
              {
                FCVT            S1, H3
                FCVT            S2, H2
              }
              _S1 = _S2 + _S1;
              __asm { FCVT            H1, S1 }
              v99->i16[0] = LOWORD(_S1);
              __asm
              {
                FCVT            S1, H5
                FCVT            S2, H4
              }
              _S1 = _S2 + _S1;
              __asm { FCVT            H1, S1 }
              v99->i16[1] = LOWORD(_S1);
              LOWORD(_S1) = v99->i16[2];
              LOWORD(_S2) = v52->i16[2];
              _H3 = v99->i16[3];
              _H4 = v52->i16[3];
              __asm
              {
                FCVT            S2, H2
                FCVT            S1, H1
              }
              _S1 = _S1 + _S2;
              __asm { FCVT            H1, S1 }
              v99->i16[2] = LOWORD(_S1);
              __asm
              {
                FCVT            S1, H4
                FCVT            S2, H3
              }
              _S1 = _S2 + _S1;
              __asm { FCVT            H1, S1 }
              v99->i16[3] = LOWORD(_S1);
              v316 = &v52[v856];
              if ((unint64_t)v316 >= v92)
                v317 = -(uint64_t)v858;
              else
                v317 = 0;
              v89 += 2 * (int)v57 + 2 * v317;
              v52 = &v316[v317];
              v90 += v290;
              v99 += v856;
              --v291;
            }
            while (v291);
            if (v881)
            {
              v318 = &v97[v884];
              if (v318 >= v881)
                v319 = -(uint64_t)(v891 * v857);
              else
                v319 = 0;
              v98 += 2 * v891 + 2 * v319;
              if (v318 >= v881)
                v320 = -(uint64_t)(v884 * v857);
              else
                v320 = 0;
              v97 = &v318[v320];
              v92 += 8 * v320 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v289;
          }
          while (v289);
        }
        else
        {
          v592 = v897[0];
          do
          {
            v593 = v26;
            do
            {
              *v99 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(*v99), vcvtq_f32_f16(*v52)));
              v594 = &v52[v856];
              if ((unint64_t)v594 >= v92)
                v595 = -(uint64_t)v858;
              else
                v595 = 0;
              v89 += 2 * (int)v57 + 2 * v595;
              v52 = &v594[v595];
              v99 += v856;
              --v593;
            }
            while (v593);
            if (v881)
            {
              v596 = &v97[v884];
              if (v596 >= v881)
                v597 = -(uint64_t)(v891 * v857);
              else
                v597 = 0;
              v98 += 2 * v891 + 2 * v597;
              if (v596 >= v881)
                v598 = -(uint64_t)(v884 * v857);
              else
                v598 = 0;
              v97 = &v596[v598];
              v92 += 8 * v598 + 8 * v884;
              v89 = (char *)v98;
              v52 = v97;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            v99 += v887;
            v90 += 2 * v889;
            --v592;
          }
          while (v592);
        }
        goto LABEL_849;
      case 13:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v321 = (int)v57;
        v862 = v897[0];
        v322 = 2 * (int)v36;
        v323 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1239;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_331;
LABEL_1239:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_331:
              v327 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v328 = PDAmultiplyPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v323, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v328;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v327;
              v323 = -(uint64_t)v858;
            }
          }
          v329 = &v52[v856];
          if ((unint64_t)v329 >= v92)
            v330 = v323;
          else
            v330 = 0;
          v89 += 2 * v321 + 2 * v330;
          v52 = &v329[v330];
          v90 += v322;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v331 = &v879[v884];
              v332 = -(uint64_t)(v891 * v857);
              if (v331 < v881)
                v332 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v332);
              v333 = -(uint64_t)(v884 * v857);
              if (v331 < v881)
                v333 = 0;
              v52 = &v331[v333];
              v92 += 8 * v333 + 8 * v884;
              v883 += 2 * v891 + 2 * v332;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v862)
              goto LABEL_655;
          }
        }
      case 14:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v334 = (int)v57;
        v863 = v897[0];
        v335 = 2 * (int)v36;
        v336 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1240;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_353;
LABEL_1240:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_353:
              v340 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v341 = PDAscreenPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v336, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v341;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v340;
              v336 = -(uint64_t)v858;
            }
          }
          v342 = &v52[v856];
          if ((unint64_t)v342 >= v92)
            v343 = v336;
          else
            v343 = 0;
          v89 += 2 * v334 + 2 * v343;
          v52 = &v342[v343];
          v90 += v335;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v344 = &v879[v884];
              v345 = -(uint64_t)(v891 * v857);
              if (v344 < v881)
                v345 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v345);
              v346 = -(uint64_t)(v884 * v857);
              if (v344 < v881)
                v346 = 0;
              v52 = &v344[v346];
              v92 += 8 * v346 + 8 * v884;
              v883 += 2 * v891 + 2 * v345;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v863)
              goto LABEL_655;
          }
        }
      case 15:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v347 = (int)v57;
        v864 = v897[0];
        v348 = 2 * (int)v36;
        v349 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1241;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_375;
LABEL_1241:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_375:
              v353 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v354 = PDAoverlayPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v349, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v354;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v353;
              v349 = -(uint64_t)v858;
            }
          }
          v355 = &v52[v856];
          if ((unint64_t)v355 >= v92)
            v356 = v349;
          else
            v356 = 0;
          v89 += 2 * v347 + 2 * v356;
          v52 = &v355[v356];
          v90 += v348;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v357 = &v879[v884];
              v358 = -(uint64_t)(v891 * v857);
              if (v357 < v881)
                v358 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v358);
              v359 = -(uint64_t)(v884 * v857);
              if (v357 < v881)
                v359 = 0;
              v52 = &v357[v359];
              v92 += 8 * v359 + 8 * v884;
              v883 += 2 * v891 + 2 * v358;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v864)
              goto LABEL_655;
          }
        }
      case 16:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v360 = (int)v57;
        v865 = v897[0];
        v361 = 2 * (int)v36;
        v362 = -(uint64_t)v858;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1242;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_397;
LABEL_1242:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_Q4.f32[0] <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_397:
              v365 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v366 = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], _Q1, _Q2, _Q3, _Q4, _Q5, *(double *)&v18, v19, v362, v6, (uint64_t)v30, v7, v57, v92, v53, v98, *v52, _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v366;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v365;
              v362 = -(uint64_t)v858;
            }
          }
          v367 = &v52[v856];
          if ((unint64_t)v367 >= v92)
            v368 = v362;
          else
            v368 = 0;
          v89 += 2 * v360 + 2 * v368;
          v52 = &v367[v368];
          v90 += v361;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v369 = &v879[v884];
              v370 = -(uint64_t)(v891 * v857);
              if (v369 < v881)
                v370 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v370);
              v371 = -(uint64_t)(v884 * v857);
              if (v369 < v881)
                v371 = 0;
              v52 = &v369[v371];
              v92 += 8 * v371 + 8 * v884;
              v883 += 2 * v891 + 2 * v370;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v865)
              goto LABEL_655;
          }
        }
      case 17:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v372 = (int)v57;
        v866 = v897[0];
        v373 = 2 * (int)v36;
        v374 = -(uint64_t)v858;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1243;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_419;
LABEL_1243:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_Q4.f32[0] <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_419:
              v377 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v378 = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], _Q1, _Q2, _Q3, _Q4, _Q5, *(double *)&v18, v19, v374, v6, (uint64_t)v30, v7, v57, v92, v53, v98, *v52, _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v378;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v377;
              v374 = -(uint64_t)v858;
            }
          }
          v379 = &v52[v856];
          if ((unint64_t)v379 >= v92)
            v380 = v374;
          else
            v380 = 0;
          v89 += 2 * v372 + 2 * v380;
          v52 = &v379[v380];
          v90 += v373;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v381 = &v879[v884];
              v382 = -(uint64_t)(v891 * v857);
              if (v381 < v881)
                v382 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v382);
              v383 = -(uint64_t)(v884 * v857);
              if (v381 < v881)
                v383 = 0;
              v52 = &v381[v383];
              v92 += 8 * v383 + 8 * v884;
              v883 += 2 * v891 + 2 * v382;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v866)
              goto LABEL_655;
          }
        }
      case 18:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v384 = (int)v57;
        v867 = v897[0];
        v385 = 2 * (int)v36;
        v386 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1244;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_441;
LABEL_1244:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_441:
              v390 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v391 = PDAcolordodgePDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v386, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v391;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v390;
              v386 = -(uint64_t)v858;
            }
          }
          v392 = &v52[v856];
          if ((unint64_t)v392 >= v92)
            v393 = v386;
          else
            v393 = 0;
          v89 += 2 * v384 + 2 * v393;
          v52 = &v392[v393];
          v90 += v385;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v394 = &v879[v884];
              v395 = -(uint64_t)(v891 * v857);
              if (v394 < v881)
                v395 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v395);
              v396 = -(uint64_t)(v884 * v857);
              if (v394 < v881)
                v396 = 0;
              v52 = &v394[v396];
              v92 += 8 * v396 + 8 * v884;
              v883 += 2 * v891 + 2 * v395;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v867)
              goto LABEL_655;
          }
        }
      case 19:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v397 = (int)v57;
        v868 = v897[0];
        v398 = 2 * (int)v36;
        v399 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1245;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_463;
LABEL_1245:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_463:
              v403 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v404 = PDAcolorburnPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v399, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v404;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v403;
              v399 = -(uint64_t)v858;
            }
          }
          v405 = &v52[v856];
          if ((unint64_t)v405 >= v92)
            v406 = v399;
          else
            v406 = 0;
          v89 += 2 * v397 + 2 * v406;
          v52 = &v405[v406];
          v90 += v398;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v407 = &v879[v884];
              v408 = -(uint64_t)(v891 * v857);
              if (v407 < v881)
                v408 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v408);
              v409 = -(uint64_t)(v884 * v857);
              if (v407 < v881)
                v409 = 0;
              v52 = &v407[v409];
              v92 += 8 * v409 + 8 * v884;
              v883 += 2 * v891 + 2 * v408;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v868)
              goto LABEL_655;
          }
        }
      case 20:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v410 = (int)v57;
        v869 = v897[0];
        v411 = 2 * (int)v36;
        v412 = -(uint64_t)v858;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1246;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_485;
LABEL_1246:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_Q4.f32[0] <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_485:
              v415 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v416 = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], _Q1, _Q2, _Q3, *(double *)_Q4.i64, *(int32x2_t *)_Q5.f32, *(double *)&v18, v19, v412, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], v52->i32[1], HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v416;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v415;
              v412 = -(uint64_t)v858;
            }
          }
          v417 = &v52[v856];
          if ((unint64_t)v417 >= v92)
            v418 = v412;
          else
            v418 = 0;
          v89 += 2 * v410 + 2 * v418;
          v52 = &v417[v418];
          v90 += v411;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v419 = &v879[v884];
              v420 = -(uint64_t)(v891 * v857);
              if (v419 < v881)
                v420 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v420);
              v421 = -(uint64_t)(v884 * v857);
              if (v419 < v881)
                v421 = 0;
              v52 = &v419[v421];
              v92 += 8 * v421 + 8 * v884;
              v883 += 2 * v891 + 2 * v420;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v869)
              goto LABEL_655;
          }
        }
      case 21:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v422 = (int)v57;
        v870 = v897[0];
        v423 = 2 * (int)v36;
        v424 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1247;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_507;
LABEL_1247:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_507:
              v428 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v429 = PDAhardlightPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v424, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v429;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v428;
              v424 = -(uint64_t)v858;
            }
          }
          v430 = &v52[v856];
          if ((unint64_t)v430 >= v92)
            v431 = v424;
          else
            v431 = 0;
          v89 += 2 * v422 + 2 * v431;
          v52 = &v430[v431];
          v90 += v423;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v432 = &v879[v884];
              v433 = -(uint64_t)(v891 * v857);
              if (v432 < v881)
                v433 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v433);
              v434 = -(uint64_t)(v884 * v857);
              if (v432 < v881)
                v434 = 0;
              v52 = &v432[v434];
              v92 += 8 * v434 + 8 * v884;
              v883 += 2 * v891 + 2 * v433;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v870)
              goto LABEL_655;
          }
        }
      case 22:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v435 = (int)v57;
        v871 = v897[0];
        v436 = 2 * (int)v36;
        v437 = -(uint64_t)v858;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1248;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_529;
LABEL_1248:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_Q4.f32[0] <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_529:
              v440 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v441 = PDAdifferencePDA(_Q0, _Q1, _Q2, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, *(int32x2_t *)_Q5.f32, (float16x4_t)v18, v19, v437, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v441;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v440;
              v437 = -(uint64_t)v858;
            }
          }
          v442 = &v52[v856];
          if ((unint64_t)v442 >= v92)
            v443 = v437;
          else
            v443 = 0;
          v89 += 2 * v435 + 2 * v443;
          v52 = &v442[v443];
          v90 += v436;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v444 = &v879[v884];
              v445 = -(uint64_t)(v891 * v857);
              if (v444 < v881)
                v445 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v445);
              v446 = -(uint64_t)(v884 * v857);
              if (v444 < v881)
                v446 = 0;
              v52 = &v444[v446];
              v92 += 8 * v446 + 8 * v884;
              v883 += 2 * v891 + 2 * v445;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v871)
              goto LABEL_655;
          }
        }
      case 23:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v447 = (int)v57;
        v872 = v897[0];
        v448 = 2 * (int)v36;
        v449 = -(uint64_t)v858;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1249;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_551;
LABEL_1249:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_Q4.f32[0] <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_551:
              v452 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v453 = PDAexclusionPDA(_Q0, _Q1, _Q2, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, *(float16x4_t *)_Q5.f32, *(double *)&v18, *(int32x2_t *)&v19, v449, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v453;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v452;
              v449 = -(uint64_t)v858;
            }
          }
          v454 = &v52[v856];
          if ((unint64_t)v454 >= v92)
            v455 = v449;
          else
            v455 = 0;
          v89 += 2 * v447 + 2 * v455;
          v52 = &v454[v455];
          v90 += v448;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v456 = &v879[v884];
              v457 = -(uint64_t)(v891 * v857);
              if (v456 < v881)
                v457 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v457);
              v458 = -(uint64_t)(v884 * v857);
              if (v456 < v881)
                v458 = 0;
              v52 = &v456[v458];
              v92 += 8 * v458 + 8 * v884;
              v883 += 2 * v891 + 2 * v457;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v872)
              goto LABEL_655;
          }
        }
      case 24:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v459 = (int)v57;
        v873 = v897[0];
        v460 = 2 * (int)v36;
        v461 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1250;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_573;
LABEL_1250:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_573:
              v465 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v466 = PDAhuePDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v461, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v466;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v465;
              v461 = -(uint64_t)v858;
            }
          }
          v467 = &v52[v856];
          if ((unint64_t)v467 >= v92)
            v468 = v461;
          else
            v468 = 0;
          v89 += 2 * v459 + 2 * v468;
          v52 = &v467[v468];
          v90 += v460;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v469 = &v879[v884];
              v470 = -(uint64_t)(v891 * v857);
              if (v469 < v881)
                v470 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v470);
              v471 = -(uint64_t)(v884 * v857);
              if (v469 < v881)
                v471 = 0;
              v52 = &v469[v471];
              v92 += 8 * v471 + 8 * v884;
              v883 += 2 * v891 + 2 * v470;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v873)
              goto LABEL_655;
          }
        }
      case 25:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v472 = (int)v57;
        v874 = v897[0];
        v473 = 2 * (int)v36;
        v474 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1251;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_595;
LABEL_1251:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_595:
              v478 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v479 = PDAsaturationPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v474, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v479;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v478;
              v474 = -(uint64_t)v858;
            }
          }
          v480 = &v52[v856];
          if ((unint64_t)v480 >= v92)
            v481 = v474;
          else
            v481 = 0;
          v89 += 2 * v472 + 2 * v481;
          v52 = &v480[v481];
          v90 += v473;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v482 = &v879[v884];
              v483 = -(uint64_t)(v891 * v857);
              if (v482 < v881)
                v483 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v483);
              v484 = -(uint64_t)(v884 * v857);
              if (v482 < v881)
                v484 = 0;
              v52 = &v482[v484];
              v92 += 8 * v484 + 8 * v884;
              v883 += 2 * v891 + 2 * v483;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v874)
              goto LABEL_655;
          }
        }
      case 26:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v485 = (int)v57;
        v875 = v897[0];
        v486 = 2 * (int)v36;
        v487 = -(uint64_t)v858;
        while (1)
        {
          _Q5.i32[0] = 1.0;
          _S4 = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1252;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S4, H0 }
          if (_S4 > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_617;
LABEL_1252:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S5, H0 }
            if (_Q5.f32[0] <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S4 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_617:
              v491 = v92;
              _Q0.n128_u16[0] = v52->i16[0];
              _Q1.n128_u16[0] = v52->u16[1];
              _Q2.n128_u16[0] = v52->u16[2];
              _Q3.n128_u16[0] = v52->u16[3];
              v492 = PDAluminosityPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v487, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v99->i32[0], HIWORD(v99->i32[0]), v99->i32[1],
                       HIWORD(v99->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v492;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v491;
              v487 = -(uint64_t)v858;
            }
          }
          v493 = &v52[v856];
          if ((unint64_t)v493 >= v92)
            v494 = v487;
          else
            v494 = 0;
          v89 += 2 * v485 + 2 * v494;
          v52 = &v493[v494];
          v90 += v486;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v495 = &v879[v884];
              v496 = -(uint64_t)(v891 * v857);
              if (v495 < v881)
                v496 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v496);
              v497 = -(uint64_t)(v884 * v857);
              if (v495 < v881)
                v497 = 0;
              v52 = &v495[v497];
              v92 += 8 * v497 + 8 * v884;
              v883 += 2 * v891 + 2 * v496;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v875)
              goto LABEL_655;
          }
        }
      case 27:
        v879 = v97;
        v883 = v98;
        v851 = v35;
        v854 = v21;
        v498 = (int)v57;
        v876 = v897[0];
        v499 = 2 * (int)v36;
        v500 = -(uint64_t)v858;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (!(_DWORD)v57)
            goto LABEL_1253;
          _H0 = *(_WORD *)v89;
          __asm { FCVT            S5, H0 }
          if (_Q5.f32[0] > 0.0)
          {
            if (!(_DWORD)v36)
              goto LABEL_639;
LABEL_1253:
            _H0 = *(_WORD *)v90;
            __asm { FCVT            S4, H0 }
            if (_S4 <= 0.0)
            {
              _Q0.n128_u64[0] = (unint64_t)*v52;
              *v99 = *v52;
              __asm { FCVT            H0, S5 }
              *(_WORD *)v90 = _Q0.n128_u16[0];
            }
            else
            {
LABEL_639:
              v504 = v92;
              _Q0.n128_u16[0] = v99->i16[0];
              _Q1.n128_u16[0] = v99->u16[1];
              _Q2.n128_u16[0] = v99->u16[2];
              _Q3.n128_u16[0] = v99->u16[3];
              v505 = PDAluminosityPDA(_Q0, _Q1, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&v18, v19, v500, v6, (uint64_t)v30, v7, v57, v92, v53, v98, v52->i32[0], HIWORD(v52->i32[0]), v52->i32[1],
                       HIWORD(v52->i32[1]),
                       _Q5.f32[0]);
              LODWORD(v36) = v895;
              *v99 = (float16x4_t)v505;
              if ((_DWORD)v895)
                *(_WORD *)v90 = v6;
              v57 = v893;
              v92 = v504;
              v500 = -(uint64_t)v858;
            }
          }
          v506 = &v52[v856];
          if ((unint64_t)v506 >= v92)
            v507 = v500;
          else
            v507 = 0;
          v89 += 2 * v498 + 2 * v507;
          v52 = &v506[v507];
          v90 += v499;
          v99 += v856;
          LODWORD(v26) = v26 - 1;
          if (!(_DWORD)v26)
          {
            if (v881)
            {
              v508 = &v879[v884];
              v509 = -(uint64_t)(v891 * v857);
              if (v508 < v881)
                v509 = 0;
              v89 = (char *)(v883 + 2 * v891 + 2 * v509);
              v510 = -(uint64_t)(v884 * v857);
              if (v508 < v881)
                v510 = 0;
              v52 = &v508[v510];
              v92 += 8 * v510 + 8 * v884;
              v883 += 2 * v891 + 2 * v509;
              v879 = v52;
            }
            else
            {
              v52 += v884;
              v89 += 2 * v891;
            }
            LODWORD(v26) = v877;
            v99 += v887;
            v90 += 2 * v889;
            if (!--v876)
              break;
          }
        }
LABEL_655:
        v86 = v92;
        v897[0] = 0;
        v25 = v848;
        LODWORD(v23) = v849;
        v21 = v854;
        v35 = v851;
        goto LABEL_850;
      default:
        v879 = v97;
        v883 = v98;
        v86 = v92;
        goto LABEL_850;
    }
    while (1)
    {
      _H1 = *(_WORD *)v89;
      __asm { FCVT            S1, H1 }
      v207 = 1.0 - _S1;
      if (v207 <= 0.0)
        break;
      if (v207 < 1.0)
      {
        *v99 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v99), v207));
        _H2 = *(_WORD *)v90;
        __asm { FCVT            S2, H2 }
        _S1 = v207 * _S2;
        __asm { FCVT            H1, S1 }
LABEL_225:
        *(_WORD *)v90 = _H1;
      }
      v212 = &v52[v856];
      if ((unint64_t)v212 >= v92)
        v213 = -(uint64_t)v858;
      else
        v213 = 0;
      v89 += 2 * (int)v57 + 2 * v213;
      v52 = &v212[v213];
      v90 += v203;
      v99 += v856;
      if (!--v204)
      {
        if (v881)
        {
          v214 = &v97[v884];
          if (v214 >= v881)
            v215 = -(uint64_t)(v891 * v857);
          else
            v215 = 0;
          v98 += 2 * v891 + 2 * v215;
          if (v214 >= v881)
            v216 = -(uint64_t)(v884 * v857);
          else
            v216 = 0;
          v97 = &v214[v216];
          v92 += 8 * v216 + 8 * v884;
          v89 = (char *)v98;
          v52 = v97;
        }
        else
        {
          v52 += v884;
          v89 += 2 * v891;
        }
        v99 += v887;
        v90 += 2 * v889;
        if (!--v202)
          goto LABEL_849;
        goto LABEL_220;
      }
    }
    *v99 = 0;
    _H1 = 0;
    goto LABEL_225;
  }
  v31 = *(unsigned int *)(v6 + 128);
  if ((v31 | 8) == 8)
  {
    if ((*(_DWORD *)v6 & 0xFF00) == 0x400)
      CMYKf16_mark_constmask(v6, v23, (uint64_t)v30, v7, v8, v9, v31, v11, _Q0.n128_f64[0], (int32x4_t)_Q1, _Q2.n128_f64[0], _Q3, _Q4, _Q5, *(double *)&v18, v19);
    else
      CMYKf16_mark_pixelmask(v6, v23, _Q0, _Q1.n128_f64[0], _Q2, _Q3, _Q4, _Q5, (float16x4_t)v18, v19, (uint64_t)v30, v7, v8, v9, v31, v11);
  }
  else
  {
    v37 = *(_DWORD *)(v6 + 112);
    v38 = *(_DWORD *)(v6 + 116);
    v39 = (v37 + 15) & 0xFFFFFFF0;
    v40 = v39 * v38;
    if ((int)v40 <= 4096)
    {
      v42 = v907;
      v43 = v6;
    }
    else
    {
      v41 = malloc_type_malloc(v40, 0x346A640BuLL);
      if (!v41)
        return 1;
      v42 = v41;
      v43 = v848;
      v30 = *(uint16x4_t **)(v848 + 136);
      LODWORD(v31) = *(_DWORD *)(v848 + 128);
    }
    CGSConvertBitsToMask(v30, *(_DWORD *)(v43 + 124), v42, v39, v37, v38, v31);
    v79 = *(_OWORD *)(v43 + 112);
    v903 = *(_OWORD *)(v43 + 96);
    v904 = v79;
    v80 = *(_OWORD *)(v43 + 144);
    v905 = *(_OWORD *)(v43 + 128);
    v906 = v80;
    v81 = *(_OWORD *)(v43 + 48);
    v899 = *(_OWORD *)(v43 + 32);
    v900 = v81;
    v82 = *(_OWORD *)(v43 + 80);
    v901 = *(_OWORD *)(v43 + 64);
    v902 = v82;
    v83 = *(__n128 *)v43;
    v84 = *(int32x4_t *)(v43 + 16);
    *(_OWORD *)v897 = *(_OWORD *)v43;
    v898 = v84;
    HIDWORD(v904) = (v37 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v905 + 1) = v42;
    if (BYTE1(v897[0]) << 8 == 1024)
      CMYKf16_mark_constmask((unint64_t)v897, v23, v67, v68, v69, v70, v71, v72, v83.n128_f64[0], v84, v73.n128_f64[0], v74, v75, v76, v77, v78);
    else
      CMYKf16_mark_pixelmask((unint64_t)v897, v23, v83, *(double *)v84.i64, v73, v74, v75, v76, *(float16x4_t *)&v77, v78, v67, v68, v69, v70, v71, v72);
    if (v42 != (_BYTE *)v907)
    {
LABEL_66:
      v100 = v42;
      goto LABEL_874;
    }
  }
  return 1;
}

unint64_t PDAmultiplyPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v27;
  float v29;
  float v31;
  float v33;
  float v35;
  float v37;
  float v39;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;

  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  v27 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  v29 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  v31 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  v33 = a5 - _S0;
  __asm { FCVT            S0, H17 }
  v35 = a21 - _S0;
  __asm { FCVT            S1, H16 }
  v37 = a21 - _S1;
  __asm { FCVT            S2, H7 }
  v39 = a21 - _S2;
  __asm { FCVT            S3, H6 }
  v41 = a21 - _S3;
  v42 = v27 * v35;
  v43 = v29 * v37;
  v44 = v31 * v39;
  v45 = v33 * v41;
  if (a21 != 1.0)
  {
    v42 = v42 + (float)(v27 * (float)(1.0 - a21));
    v43 = v43 + (float)(v29 * (float)(1.0 - a21));
    v44 = v44 + (float)(v31 * (float)(1.0 - a21));
    v45 = v45 + (float)(v33 * (float)(1.0 - a21));
  }
  v46 = v42 + (float)(v35 * (float)(1.0 - a5));
  v47 = v43 + (float)(v37 * (float)(1.0 - a5));
  v48 = v44 + (float)(v39 * (float)(1.0 - a5));
  v49 = v45 + (float)(v41 * (float)(1.0 - a5));
  if (a5 == 1.0)
  {
    v46 = v42;
    v47 = v43;
    v48 = v44;
    v49 = v45;
  }
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  _S0 = _S4 - v46;
  __asm { FCVT            H0, S0 }
  _S1 = _S4 - v47;
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - v48;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v49;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)LOWORD(_S2) << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)LOWORD(_S1) << 16) | LOWORD(_S0);
}

unint64_t PDAscreenPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v34;
  float v35;
  float v36;
  float v37;

  _H5 = a20;
  _H6 = a19;
  _H7 = a18;
  _H17 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S3, H3
    FCVT            S17, H17
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  v34 = (float)(a5 - _S0) + (float)((float)(a21 - _S17) * (float)(1.0 - (float)(a5 - _S0)));
  v35 = (float)(a5 - _S1) + (float)((float)(a21 - _S7) * (float)(1.0 - (float)(a5 - _S1)));
  v36 = (float)(a5 - _S2) + (float)((float)(a21 - _S6) * (float)(1.0 - (float)(a5 - _S2)));
  v37 = (float)(a5 - _S3) + (float)((float)(a21 - _S5) * (float)(1.0 - (float)(a5 - _S3)));
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  _S0 = _S4 - v34;
  __asm { FCVT            H0, S0 }
  _S1 = _S4 - v35;
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - v36;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v37;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)LOWORD(_S2) << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)LOWORD(_S1) << 16) | LOWORD(_S0);
}

unint64_t PDAoverlayPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v27;
  float v29;
  float v31;
  float v33;
  float v35;
  float v37;
  float v39;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;

  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  v27 = a5 - _S0;
  __asm { FCVT            S1, H1 }
  v29 = a5 - _S1;
  __asm { FCVT            S2, H2 }
  v31 = a5 - _S2;
  __asm { FCVT            S3, H3 }
  v33 = a5 - _S3;
  __asm { FCVT            S17, H17 }
  v35 = a21 - _S17;
  __asm { FCVT            S16, H16 }
  v37 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  v39 = a21 - _S7;
  __asm { FCVT            S6, H6 }
  v41 = a21 - _S6;
  v42 = (float)(v27 * v35) + (float)(v27 * v35);
  v43 = (float)(v29 * v37) + (float)(v29 * v37);
  v44 = (float)(v31 * v39) + (float)(v31 * v39);
  v45 = (float)(v33 * v41) + (float)(v33 * v41);
  v46 = a5 * a21;
  v47 = a5 * 0.5;
  _NF = v27 < (float)(a5 * 0.5);
  v48 = a21 + 1.0;
  v49 = a5 + 1.0;
  v50 = (float)((float)((float)((float)(a5 + 1.0) * v35) + (float)(v27 * (float)(a21 + 1.0))) - v42) - (float)(a5 * a21);
  v51 = 1.0 - a21;
  v52 = 1.0 - a5;
  v53 = (float)((float)((float)(1.0 - a5) * v35) + (float)(v27 * (float)(1.0 - a21))) + v42;
  if (!_NF)
    v53 = v50;
  _NF = v29 < v47;
  v54 = (float)((float)((float)(v49 * v37) + (float)(v29 * v48)) - v43) - v46;
  v55 = (float)((float)(v52 * v37) + (float)(v29 * v51)) + v43;
  if (!_NF)
    v55 = v54;
  _NF = v31 < v47;
  v56 = (float)((float)((float)(v49 * v39) + (float)(v31 * v48)) - v44) - v46;
  v57 = (float)((float)(v52 * v39) + (float)(v31 * v51)) + v44;
  if (!_NF)
    v57 = v56;
  _NF = v33 < v47;
  v58 = (float)((float)((float)(v49 * v41) + (float)(v33 * v48)) - v45) - v46;
  v59 = (float)((float)(v52 * v41) + (float)(v33 * v51)) + v45;
  if (!_NF)
    v59 = v58;
  _S4 = (float)(a5 + a21) - v46;
  _S0 = _S4 - v53;
  __asm { FCVT            H0, S0 }
  _S1 = _S4 - v55;
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - v57;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v59;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)LOWORD(_S2) << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)LOWORD(_S1) << 16) | LOWORD(_S0);
}

unint64_t PDAlightenPDA(float16x4_t a1, __n128 a2, __n128 a3, __n128 a4, float32x4_t a5, float32x4_t a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float16x4_t a17, float a18)
{
  float32x4_t v16;
  float32x4_t v18;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v28;
  uint64x2_t v29;

  a6.f32[0] = a18;
  a1.i16[1] = a2.n128_u16[0];
  a1.i16[2] = a3.n128_u16[0];
  a1.i16[3] = a4.n128_u16[0];
  v16 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 0), vcvtq_f32_f16(a1));
  _Q1 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0), vcvtq_f32_f16(a17));
  v18 = vmulq_n_f32(v16, a18);
  _Q3 = vmulq_n_f32(_Q1, a5.f32[0]);
  _Q2 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(_Q3, v18), (int8x16_t)_Q3, (int8x16_t)v18);
  _Q3.i32[0] = 1.0;
  v21 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a6, _Q3)), 0), (int8x16_t)vmlaq_n_f32(_Q2, v16, 1.0 - a18), (int8x16_t)_Q2);
  v22 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a5, _Q3)), 0), (int8x16_t)vmlaq_n_f32(v21, _Q1, 1.0 - a5.f32[0]), (int8x16_t)v21);
  _Q1.f32[0] = (float)(a5.f32[0] + a18) - (float)(a5.f32[0] * a18);
  _Q2.f32[0] = _Q1.f32[0] - v22.f32[0];
  __asm { FCVT            H2, S2 }
  _Q3.f32[0] = _Q1.f32[0] - v22.f32[2];
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S1
  }
  v22.i32[0] = vextq_s8(*(int8x16_t *)&v22, *(int8x16_t *)&v22, 8uLL).i32[1];
  *(float32x2_t *)v22.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q1.f32, 0), *(float32x2_t *)v22.f32);
  v22.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v22)).u64[0];
  v28.i64[0] = v22.u32[0];
  v28.i64[1] = v22.u32[1];
  _Q1.i64[0] = 0xFFFFLL;
  _Q1.i64[1] = 0xFFFFLL;
  v29 = vshlq_u64((uint64x2_t)vandq_s8(v28, (int8x16_t)_Q1), (uint64x2_t)xmmword_185004D90);
  return v29.i64[0] | ((unint64_t)_Q3.u16[0] << 32) | _Q2.u16[0] | v29.i64[1];
}

unint64_t PDAdarkenPDA(float16x4_t a1, __n128 a2, __n128 a3, __n128 a4, float32x4_t a5, float32x4_t a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float16x4_t a17, float a18)
{
  float32x4_t v16;
  float32x4_t v18;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v28;
  uint64x2_t v29;

  a6.f32[0] = a18;
  a1.i16[1] = a2.n128_u16[0];
  a1.i16[2] = a3.n128_u16[0];
  a1.i16[3] = a4.n128_u16[0];
  v16 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 0), vcvtq_f32_f16(a1));
  _Q1 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0), vcvtq_f32_f16(a17));
  v18 = vmulq_n_f32(v16, a18);
  _Q3 = vmulq_n_f32(_Q1, a5.f32[0]);
  _Q2 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, _Q3), (int8x16_t)_Q3, (int8x16_t)v18);
  _Q3.i32[0] = 1.0;
  v21 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a6, _Q3)), 0), (int8x16_t)vmlaq_n_f32(_Q2, v16, 1.0 - a18), (int8x16_t)_Q2);
  v22 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a5, _Q3)), 0), (int8x16_t)vmlaq_n_f32(v21, _Q1, 1.0 - a5.f32[0]), (int8x16_t)v21);
  _Q1.f32[0] = (float)(a5.f32[0] + a18) - (float)(a5.f32[0] * a18);
  _Q2.f32[0] = _Q1.f32[0] - v22.f32[0];
  __asm { FCVT            H2, S2 }
  _Q3.f32[0] = _Q1.f32[0] - v22.f32[2];
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S1
  }
  v22.i32[0] = vextq_s8(*(int8x16_t *)&v22, *(int8x16_t *)&v22, 8uLL).i32[1];
  *(float32x2_t *)v22.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q1.f32, 0), *(float32x2_t *)v22.f32);
  v22.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v22)).u64[0];
  v28.i64[0] = v22.u32[0];
  v28.i64[1] = v22.u32[1];
  _Q1.i64[0] = 0xFFFFLL;
  _Q1.i64[1] = 0xFFFFLL;
  v29 = vshlq_u64((uint64x2_t)vandq_s8(v28, (int8x16_t)_Q1), (uint64x2_t)xmmword_185004D90);
  return v29.i64[0] | ((unint64_t)_Q3.u16[0] << 32) | _Q2.u16[0] | v29.i64[1];
}

unint64_t PDAcolordodgePDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v26;
  float v28;
  float v31;
  float v33;
  float v34;
  float v35;
  float v39;
  float v40;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;

  _H17 = a19;
  _H7 = a18;
  _H16 = a17;
  __asm { FCVT            S0, H0 }
  v26 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  v28 = a5 - _S0;
  __asm
  {
    FCVT            S18, H2
    FCVT            S0, H16
  }
  v31 = a21 - _S0;
  __asm { FCVT            S19, H7 }
  v33 = a21 * a21;
  v34 = 0.0;
  v35 = 0.0;
  if (v26 != 0.0)
  {
    if (v31 == a21)
      v35 = 1.0;
    else
      v35 = (float)(v26 * v33) / (float)(a21 - v31);
  }
  _H20 = a20;
  __asm
  {
    FCVT            S21, H3
    FCVT            S22, H17
  }
  v39 = a5 - _S18;
  v40 = a21 - _S19;
  if (v28 != 0.0)
  {
    if (v40 == a21)
      v34 = 1.0;
    else
      v34 = (float)(v28 * v33) / (float)(a21 - v40);
  }
  __asm { FCVT            S23, H20 }
  v42 = a5 - _S21;
  v43 = a21 - _S22;
  v44 = 0.0;
  v45 = 0.0;
  if (v39 != 0.0)
  {
    if (v43 == a21)
      v45 = 1.0;
    else
      v45 = (float)(v39 * v33) / (float)(a21 - v43);
  }
  v46 = a21 - _S23;
  if (v42 != 0.0)
  {
    if (v46 == a21)
      v44 = 1.0;
    else
      v44 = (float)(v42 * v33) / (float)(a21 - v46);
  }
  v47 = v35 + (float)(v26 * (float)(1.0 - a21));
  v48 = v34 + (float)(v28 * (float)(1.0 - a21));
  v49 = v45 + (float)(v39 * (float)(1.0 - a21));
  v50 = v44 + (float)(v42 * (float)(1.0 - a21));
  if (a21 == 1.0)
  {
    v47 = v35;
    v48 = v34;
    v51 = v45;
  }
  else
  {
    v51 = v49;
  }
  if (a21 == 1.0)
    v52 = v44;
  else
    v52 = v50;
  v53 = v47 + (float)(v31 * (float)(1.0 - a5));
  v54 = v48 + (float)(v40 * (float)(1.0 - a5));
  if (a5 == 1.0)
    v53 = v47;
  else
    v48 = v54;
  if (a5 == 1.0)
  {
    v55 = v52;
  }
  else
  {
    v51 = v51 + (float)(v43 * (float)(1.0 - a5));
    v55 = v52 + (float)(v46 * (float)(1.0 - a5));
  }
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  if (v53 > _S4)
    v53 = _S4;
  if (v48 > _S4)
    v48 = _S4;
  if (v51 > _S4)
    v51 = _S4;
  if (v55 > _S4)
    v55 = _S4;
  _S0 = _S4 - v53;
  __asm { FCVT            H0, S0 }
  _S1 = _S4 - v48;
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - v51;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v55;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)LOWORD(_S2) << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)LOWORD(_S1) << 16) | LOWORD(_S0);
}

unint64_t PDAcolorburnPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v27;
  float v29;
  float v31;
  float v33;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;

  _H6 = a20;
  _H21 = a19;
  _H18 = a18;
  _H16 = a17;
  __asm { FCVT            S0, H0 }
  v27 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  v29 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  v31 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  v33 = a5 - _S0;
  __asm
  {
    FCVT            S16, H16
    FCVT            S18, H18
    FCVT            S23, H21
    FCVT            S24, H6
  }
  v38 = a5 * a21;
  v39 = a5 * a21;
  v40 = a5 * a21;
  v41 = a5 * a21;
  v42 = a5 * a21;
  if (a21 != 1.0)
  {
    v39 = v38 + (float)(v27 * (float)(1.0 - a21));
    v40 = v38 + (float)(v29 * (float)(1.0 - a21));
    v41 = v38 + (float)(v31 * (float)(1.0 - a21));
    v42 = v38 + (float)(v33 * (float)(1.0 - a21));
  }
  v43 = a21 - _S16;
  v44 = a21 - _S18;
  v45 = a21 - _S23;
  v46 = a21 - _S24;
  if (a5 != 1.0)
  {
    v39 = v39 + (float)(v43 * (float)(1.0 - a5));
    v40 = v40 + (float)(v44 * (float)(1.0 - a5));
    v41 = v41 + (float)(v45 * (float)(1.0 - a5));
    v42 = v42 + (float)(v46 * (float)(1.0 - a5));
  }
  v47 = a5 - v27;
  if (v47 != 0.0)
  {
    if (v43 == 0.0 || (v39 = v39 - (float)((float)((float)(a21 * a21) * v47) / v43), v39 < 0.0))
      v39 = 0.0;
  }
  v48 = a5 - v29;
  if (v48 != 0.0)
  {
    if (v44 == 0.0 || (v40 = v40 - (float)((float)((float)(a21 * a21) * v48) / v44), v40 < 0.0))
      v40 = 0.0;
  }
  v49 = a5 - v31;
  if (v49 != 0.0)
  {
    if (v45 == 0.0 || (v41 = v41 - (float)((float)((float)(a21 * a21) * v49) / v45), v41 < 0.0))
      v41 = 0.0;
  }
  v50 = a5 - v33;
  if (v50 != 0.0)
  {
    if (v46 == 0.0 || (v42 = v42 - (float)((float)((float)(a21 * a21) * v50) / v46), v42 < 0.0))
      v42 = 0.0;
  }
  _S0 = (float)(a5 + a21) - v38;
  _S1 = _S0 - v39;
  __asm { FCVT            H1, S1 }
  _S2 = _S0 - v40;
  __asm { FCVT            H2, S2 }
  _S3 = _S0 - v41;
  __asm { FCVT            H3, S3 }
  *(float *)&_S4 = _S0 - v42;
  __asm
  {
    FCVT            H4, S4
    FCVT            H0, S0
  }
  return ((unint64_t)LOWORD(_S3) << 32) | ((unint64_t)_S4 << 48) | ((unint64_t)LOWORD(_S2) << 16) | LOWORD(_S1);
}

unint64_t PDAhardlightPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v27;
  float v29;
  float v31;
  float v33;
  float v35;
  float v37;
  float v39;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;

  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  v27 = a5 - _S0;
  __asm { FCVT            S1, H1 }
  v29 = a5 - _S1;
  __asm { FCVT            S2, H2 }
  v31 = a5 - _S2;
  __asm { FCVT            S3, H3 }
  v33 = a5 - _S3;
  __asm { FCVT            S17, H17 }
  v35 = a21 - _S17;
  __asm { FCVT            S16, H16 }
  v37 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  v39 = a21 - _S7;
  __asm { FCVT            S6, H6 }
  v41 = a21 - _S6;
  v42 = (float)(v27 * v35) + (float)(v27 * v35);
  v43 = (float)(v29 * v37) + (float)(v29 * v37);
  v44 = (float)(v31 * v39) + (float)(v31 * v39);
  v45 = (float)(v33 * v41) + (float)(v33 * v41);
  v46 = a5 * a21;
  v47 = a21 * 0.5;
  v48 = 1.0 - a21;
  v49 = 1.0 - a5;
  v50 = (float)((float)((float)(1.0 - a5) * v35) + (float)(v27 * (float)(1.0 - a21))) + v42;
  v51 = a21 + 1.0;
  v52 = a5 + 1.0;
  v53 = (float)((float)((float)((float)(a5 + 1.0) * v35) + (float)(v27 * (float)(a21 + 1.0))) - v42) - (float)(a5 * a21);
  if (v35 <= (float)(a21 * 0.5))
    v53 = v50;
  v54 = (float)((float)(v49 * v37) + (float)(v29 * v48)) + v43;
  v55 = (float)((float)((float)(v52 * v37) + (float)(v29 * v51)) - v43) - v46;
  if (v37 <= v47)
    v55 = v54;
  v56 = (float)((float)(v49 * v39) + (float)(v31 * v48)) + v44;
  v57 = (float)((float)((float)(v52 * v39) + (float)(v31 * v51)) - v44) - v46;
  if (v39 <= v47)
    v57 = v56;
  v58 = (float)((float)(v49 * v41) + (float)(v33 * v48)) + v45;
  v59 = (float)((float)((float)(v52 * v41) + (float)(v33 * v51)) - v45) - v46;
  if (v41 <= v47)
    v59 = v58;
  _S4 = (float)(a5 + a21) - v46;
  _S0 = _S4 - v53;
  __asm { FCVT            H0, S0 }
  _S1 = _S4 - v55;
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - v57;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v59;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)LOWORD(_S2) << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)LOWORD(_S1) << 16) | LOWORD(_S0);
}

unint64_t PDAsoftlightPDA(float16x4_t a1, __n128 a2, __n128 _Q2, __n128 _Q3, double a5, int32x2_t a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int32 a17, __int16 a18, __int16 a19, float a20)
{
  float16x4_t v18;
  float v26;
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float v34;
  float v36;
  float32x2_t v37;
  float32x2_t v38;
  double v39;
  float v40;
  float v41;
  double v42;
  float v43;
  float v44;
  float v45;
  double v46;
  unint64_t v50;
  int8x16_t v51;
  int8x16_t v52;
  uint64x2_t v53;

  *(float *)a6.i32 = a20;
  _H7 = a19;
  _H6 = a18;
  v18.i32[0] = a17;
  __asm { FCVT            S2, H2 }
  v26 = *(float *)&a5 - _S2;
  __asm { FCVT            S3, H3 }
  v28 = *(float *)&a5 - _S3;
  a1.i16[1] = a2.n128_u16[0];
  v29 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
  v30 = vsub_f32(v29, (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a1));
  _Q0 = vcvtq_f32_f16(v18);
  v31 = (float32x2_t)vdup_lane_s32(a6, 0);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v31, *(float32x2_t *)_Q0.f32);
  __asm { FCVT            S6, H6 }
  v34 = a20 - _S6;
  __asm { FCVT            S7, H7 }
  v36 = a20 - _S7;
  if (*(float *)&a5 == 0.0)
  {
    v39 = 0.0;
    v40 = 0.0;
    v41 = 0.0;
  }
  else
  {
    v37 = vmul_f32(v30, *(float32x2_t *)_Q0.f32);
    v38 = vsub_f32(vadd_f32(v37, v37), vdiv_f32(vmul_f32(vmul_f32(v30, v30), vsub_f32(vadd_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)_Q0.f32), v31)), v29));
    v39 = COERCE_DOUBLE(vbic_s8((int8x8_t)v38, (int8x8_t)vcltz_f32(v38)));
    v40 = (float)((float)(v26 * v34) + (float)(v26 * v34))
        - (float)((float)((float)(v26 * v26) * (float)((float)(v34 + v34) - a20)) / *(float *)&a5);
    v41 = 0.0;
    if (v40 < 0.0)
      v40 = 0.0;
    if ((float)((float)((float)(v28 * v36) + (float)(v28 * v36))
               - (float)((float)((float)(v28 * v28) * (float)((float)(v36 + v36) - a20)) / *(float *)&a5)) >= 0.0)
      v41 = (float)((float)(v28 * v36) + (float)(v28 * v36))
          - (float)((float)((float)(v28 * v28) * (float)((float)(v36 + v36) - a20)) / *(float *)&a5);
  }
  v42 = COERCE_DOUBLE(vmla_n_f32(*(float32x2_t *)&v39, v30, 1.0 - a20));
  v43 = v40 + (float)(v26 * (float)(1.0 - a20));
  v44 = v41 + (float)(v28 * (float)(1.0 - a20));
  if (a20 == 1.0)
    v45 = v40;
  else
    v45 = v43;
  if (a20 == 1.0)
  {
    v44 = v41;
    v46 = v39;
  }
  else
  {
    v46 = v42;
  }
  if (*(float *)&a5 != 1.0)
  {
    v46 = COERCE_DOUBLE(vmla_n_f32(*(float32x2_t *)&v46, *(float32x2_t *)_Q0.f32, 1.0 - *(float *)&a5));
    v45 = v45 + (float)(v34 * (float)(1.0 - *(float *)&a5));
    v44 = v44 + (float)(v36 * (float)(1.0 - *(float *)&a5));
  }
  _Q0.f32[0] = (float)(*(float *)&a5 + a20) - (float)(*(float *)&a5 * a20);
  _S4 = _Q0.f32[0] - *(float *)&v46;
  __asm { FCVT            H4, S4 }
  _S3 = _Q0.f32[0] - v45;
  __asm
  {
    FCVT            H3, S3
    FCVT            H5, S0
  }
  *(float *)&v46 = v44;
  *(float32x2_t *)_Q0.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q0.f32, 0), *(float32x2_t *)&v46);
  v50 = vmovl_u16((uint16x4_t)vcvt_f16_f32(_Q0)).u64[0];
  v51.i64[0] = v50;
  v51.i64[1] = HIDWORD(v50);
  v52.i64[0] = 0xFFFFLL;
  v52.i64[1] = 0xFFFFLL;
  v53 = vshlq_u64((uint64x2_t)vandq_s8(v51, v52), (uint64x2_t)xmmword_185004D90);
  return v53.i64[0] | ((unint64_t)LOWORD(_S3) << 32) | LOWORD(_S4) | v53.i64[1];
}

uint64_t PDAdifferencePDA(__n128 _Q0, __n128 a2, __n128 _Q2, float16x4_t a4, double a5, int32x2_t a6, float16x4_t a7, double _D7, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v28;
  float v30;
  float v32;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  unsigned __int16 v51;
  uint64_t v52;
  float32x4_t v53;
  float32x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;
  int8x16_t v58;
  int8x16_t v59;
  uint64x2_t v60;

  a7.i16[0] = a20;
  _H7 = a19;
  *(float *)a6.i32 = a21;
  _H16 = a17;
  __asm { FCVT            S0, H0 }
  v28 = *(float *)&a5 - _S0;
  __asm { FCVT            S2, H2 }
  v30 = *(float *)&a5 - _S2;
  __asm { FCVT            S16, H16 }
  v32 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  v34 = a21 - _S7;
  v35 = v28 + v32;
  v36 = v28 * a21;
  v37 = v32 * *(float *)&a5;
  v38 = v35 - v36;
  v39 = v36 - v37;
  v40 = v38 - v37;
  if (v39 < 0.0)
    v39 = -v39;
  v41 = v40 + v39;
  v42 = v30 + v34;
  v43 = v30 * a21;
  v44 = v34 * *(float *)&a5;
  v45 = v42 - v43;
  v46 = v43 - v44;
  *(float *)&_D7 = v45 - v44;
  if (v46 < 0.0)
    v46 = -v46;
  v47 = *(float *)&_D7 + v46;
  *(float *)&_D7 = (float)(*(float *)&a5 + a21) - (float)(*(float *)&a5 * a21);
  _S0 = *(float *)&_D7 - v41;
  __asm { FCVT            H0, S0 }
  _S2 = *(float *)&_D7 - v47;
  __asm
  {
    FCVT            H2, S2
    FCVT            H16, S7
  }
  v51 = LOWORD(_S0);
  v52 = LOWORD(_S2);
  a4.i16[1] = a2.n128_u16[0];
  v53 = vcvtq_f32_f16(a4);
  *(float32x2_t *)v53.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), *(float32x2_t *)v53.f32);
  a7.i16[1] = a18;
  v54 = vsub_f32((float32x2_t)vdup_lane_s32(a6, 0), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a7));
  v55 = vadd_f32(*(float32x2_t *)v53.f32, v54);
  *(float32x2_t *)v53.f32 = vmul_n_f32(*(float32x2_t *)v53.f32, a21);
  v56 = vmul_n_f32(v54, *(float *)&a5);
  v57 = vsub_f32(v55, *(float32x2_t *)v53.f32);
  *(float32x2_t *)v53.f32 = vsub_f32(*(float32x2_t *)v53.f32, v56);
  *(float32x2_t *)v53.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&_D7, 0), vadd_f32(vsub_f32(v57, v56), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(*(float32x2_t *)v53.f32), (int8x8_t)vneg_f32(*(float32x2_t *)v53.f32), *(int8x8_t *)v53.f32)));
  v53.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v53)).u64[0];
  v58.i64[0] = v53.u32[0];
  v58.i64[1] = v53.u32[1];
  v59.i64[0] = 0xFFFFLL;
  v59.i64[1] = 0xFFFFLL;
  v60 = vshlq_u64((uint64x2_t)vandq_s8(v58, v59), (uint64x2_t)xmmword_185004D90);
  return v60.i64[0] | (v52 << 32) | v51 | v60.i64[1];
}

unint64_t PDAexclusionPDA(__n128 _Q0, __n128 a2, __n128 _Q2, float16x4_t a4, double a5, float16x4_t a6, double _D6, int32x2_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v29;
  unsigned __int16 v32;
  float32x4_t v33;
  float32x2_t v34;
  int8x16_t v35;
  int8x16_t v36;
  uint64x2_t v37;

  a6.i16[0] = a20;
  LOWORD(_D6) = a19;
  *(float *)a8.i32 = a21;
  _H16 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S2, H2
    FCVT            S16, H16
    FCVT            S6, H6
  }
  v29 = (float)((float)(*(float *)&a5 - _S2) + (float)(a21 - *(float *)&_D6))
      + (float)((float)((float)(a21 - *(float *)&_D6) * (float)(*(float *)&a5 - _S2)) * -2.0);
  *(float *)&_D6 = (float)(*(float *)&a5 + a21) - (float)(*(float *)&a5 * a21);
  _S0 = *(float *)&_D6
      - (float)((float)((float)(*(float *)&a5 - _S0) + (float)(a21 - _S16))
              + (float)((float)((float)(a21 - _S16) * (float)(*(float *)&a5 - _S0)) * -2.0));
  __asm { FCVT            H0, S0 }
  _S2 = *(float *)&_D6 - v29;
  __asm
  {
    FCVT            H2, S2
    FCVT            H16, S6
  }
  v32 = LOWORD(_S0);
  a4.i16[1] = a2.n128_u16[0];
  v33 = vcvtq_f32_f16(a4);
  *(float32x2_t *)v33.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), *(float32x2_t *)v33.f32);
  a6.i16[1] = a18;
  v34 = vsub_f32((float32x2_t)vdup_lane_s32(a8, 0), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a6));
  *(float32x2_t *)v33.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&_D6, 0), vmla_f32(vadd_f32(*(float32x2_t *)v33.f32, v34), (float32x2_t)0xC0000000C0000000, vmul_f32(v34, *(float32x2_t *)v33.f32)));
  v33.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v33)).u64[0];
  v35.i64[0] = v33.u32[0];
  v35.i64[1] = v33.u32[1];
  v36.i64[0] = 0xFFFFLL;
  v36.i64[1] = 0xFFFFLL;
  v37 = vshlq_u64((uint64x2_t)vandq_s8(v35, v36), (uint64x2_t)xmmword_185004D90);
  return v37.i64[0] | ((unint64_t)LOWORD(_S2) << 32) | v32 | v37.i64[1];
}

unint64_t PDAhuePDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v26;
  float v28;
  float v30;
  float v32;
  float v34;
  float v36;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v48;
  float v49;
  float v50;
  uint64_t v51;
  _BOOL8 v52;
  uint64_t v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v67;
  float v68;
  float v69;
  uint64_t v70;

  _H6 = a19;
  _H7 = a18;
  _H16 = a17;
  v70 = *MEMORY[0x1E0C80C00];
  __asm { FCVT            S0, H0 }
  v26 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  v28 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  v30 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  v32 = a5 - _S0;
  __asm { FCVT            S1, H16 }
  v34 = a21 - _S1;
  __asm { FCVT            S1, H7 }
  v36 = a21 - _S1;
  __asm { FCVT            S1, H6 }
  v38 = a21 - _S1;
  v39 = 0.0;
  v40 = v26 - (float)(v26 * a21);
  v41 = v28 * a21;
  v42 = v28 - (float)(v28 * a21);
  v43 = v30 * a21;
  v44 = v30 - (float)(v30 * a21);
  v45 = v32 - (float)(v32 * a21);
  if (a21 == 1.0)
    v40 = 0.0;
  else
    v32 = v32 * a21;
  if (a21 == 1.0)
  {
    v42 = 0.0;
    v44 = 0.0;
    v43 = v30;
  }
  else
  {
    v39 = v45;
  }
  if (a21 == 1.0)
    v41 = v28;
  else
    v26 = v26 * a21;
  if (a5 != 1.0)
  {
    _H21 = a20;
    __asm { FCVT            S21, H21 }
    v48 = v34 + v40;
    v34 = v34 * a5;
    v40 = v48 - v34;
    v49 = v36 + v42;
    v36 = v36 * a5;
    v42 = v49 - v36;
    v50 = v38 + v44;
    v38 = v38 * a5;
    v44 = v50 - v38;
    v39 = (float)((float)(a21 - _S21) + v39) - (float)((float)(a21 - _S21) * a5);
  }
  v67 = v34;
  v68 = v36;
  v69 = v38;
  v51 = v34 < v36;
  v52 = v34 >= v36;
  if (v38 >= *(&v67 + v52))
  {
    v53 = v34 >= v36;
    if (v38 > *(&v67 + v51))
    {
      v52 = v34 < v36;
      v51 = 2;
    }
  }
  else
  {
    v53 = 2;
  }
  v54 = *(&v67 + v51);
  v55 = *(&v67 + v53);
  if (v54 <= v55)
  {
    *(&v67 + v51) = 0.0;
    *(&v67 + v52) = 0.0;
  }
  else
  {
    if (v26 >= v41)
      v56 = v41;
    else
      v56 = v26;
    if (v26 >= v41)
      v57 = v26;
    else
      v57 = v41;
    if (v43 > v57)
      v58 = v43;
    else
      v58 = v57;
    if (v43 >= v56)
      v57 = v58;
    else
      v56 = v43;
    v59 = v57 - v56;
    *(&v67 + v51) = v59;
    *(&v67 + v52) = (float)(v59 / (float)(v54 - v55)) * (float)(*(&v67 + v52) - *(&v67 + v53));
  }
  *(&v67 + v53) = 0.0;
  v60 = (float)((float)((float)(v41 - v68) * 0.59) + (float)((float)(v26 - v67) * 0.3))
      + (float)((float)(v43 - v69) * 0.11);
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  _S1 = _S4 - (float)(v40 + (float)(v67 + v60));
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - (float)(v42 + (float)(v68 + v60));
  __asm { FCVT            H2, S2 }
  _S3 = _S4 - (float)(v44 + (float)(v69 + v60));
  __asm { FCVT            H3, S3 }
  *(float *)&_S0 = _S4 - (float)(v32 + v39);
  __asm
  {
    FCVT            H0, S0
    FCVT            H4, S4
  }
  return ((unint64_t)_S0 << 48) | ((unint64_t)LOWORD(_S3) << 32) | ((unint64_t)LOWORD(_S2) << 16) | LOWORD(_S1);
}

unint64_t PDAsaturationPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v26;
  float v28;
  float v30;
  float v32;
  float v34;
  float v36;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v48;
  float v49;
  float v50;
  uint64_t v51;
  _BOOL8 v52;
  uint64_t v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v66;
  float v67;
  float v68;
  uint64_t v69;

  _H6 = a19;
  _H7 = a18;
  _H16 = a17;
  v69 = *MEMORY[0x1E0C80C00];
  __asm { FCVT            S0, H0 }
  v26 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  v28 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  v30 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  v32 = a5 - _S0;
  __asm { FCVT            S1, H16 }
  v34 = a21 - _S1;
  __asm { FCVT            S1, H7 }
  v36 = a21 - _S1;
  __asm { FCVT            S1, H6 }
  v38 = a21 - _S1;
  v39 = 0.0;
  v40 = v26 - (float)(v26 * a21);
  v41 = v28 * a21;
  v42 = v28 - (float)(v28 * a21);
  v43 = v30 * a21;
  v44 = v30 - (float)(v30 * a21);
  v45 = v32 - (float)(v32 * a21);
  if (a21 == 1.0)
    v40 = 0.0;
  else
    v32 = v32 * a21;
  if (a21 == 1.0)
  {
    v42 = 0.0;
    v44 = 0.0;
    v43 = v30;
  }
  else
  {
    v39 = v45;
  }
  if (a21 == 1.0)
    v41 = v28;
  else
    v26 = v26 * a21;
  if (a5 != 1.0)
  {
    _H21 = a20;
    __asm { FCVT            S21, H21 }
    v48 = v34 + v40;
    v34 = v34 * a5;
    v40 = v48 - v34;
    v49 = v36 + v42;
    v36 = v36 * a5;
    v42 = v49 - v36;
    v50 = v38 + v44;
    v38 = v38 * a5;
    v44 = v50 - v38;
    v39 = (float)((float)(a21 - _S21) + v39) - (float)((float)(a21 - _S21) * a5);
  }
  v66 = v26;
  v67 = v41;
  v68 = v43;
  v51 = v26 < v41;
  v52 = v26 >= v41;
  if (v43 >= *(&v66 + v52))
  {
    v53 = v26 >= v41;
    if (v43 > *(&v66 + v51))
    {
      v52 = v26 < v41;
      v51 = 2;
    }
  }
  else
  {
    v53 = 2;
  }
  v54 = *(&v66 + v51);
  v55 = *(&v66 + v53);
  if (v54 <= v55)
  {
    *(&v66 + v51) = 0.0;
    *(&v66 + v52) = 0.0;
  }
  else
  {
    if (v34 >= v36)
      v56 = v36;
    else
      v56 = v34;
    if (v34 < v36)
      v34 = v36;
    if (v38 > v34)
      v57 = v38;
    else
      v57 = v34;
    if (v38 >= v56)
    {
      v38 = v56;
      v34 = v57;
    }
    v58 = v34 - v38;
    *(&v66 + v51) = v58;
    *(&v66 + v52) = (float)(v58 / (float)(v54 - v55)) * (float)(*(&v66 + v52) - *(&v66 + v53));
  }
  *(&v66 + v53) = 0.0;
  v59 = (float)((float)((float)(v41 - v67) * 0.59) + (float)((float)(v26 - v66) * 0.3))
      + (float)((float)(v43 - v68) * 0.11);
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  _S1 = _S4 - (float)(v40 + (float)(v66 + v59));
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - (float)(v42 + (float)(v67 + v59));
  __asm { FCVT            H2, S2 }
  _S3 = _S4 - (float)(v44 + (float)(v68 + v59));
  __asm { FCVT            H3, S3 }
  *(float *)&_S0 = _S4 - (float)(v32 + v39);
  __asm
  {
    FCVT            H0, S0
    FCVT            H4, S4
  }
  return ((unint64_t)_S0 << 48) | ((unint64_t)LOWORD(_S3) << 32) | ((unint64_t)LOWORD(_S2) << 16) | LOWORD(_S1);
}

unint64_t PDAluminosityPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  float v27;
  float v29;
  float v31;
  float v33;
  float v35;
  float v37;
  float v39;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;

  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  v27 = a5 - _S0;
  __asm { FCVT            S1, H1 }
  v29 = a5 - _S1;
  __asm { FCVT            S2, H2 }
  v31 = a5 - _S2;
  __asm { FCVT            S17, H17 }
  v33 = a21 - _S17;
  __asm { FCVT            S16, H16 }
  v35 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  v37 = a21 - _S7;
  __asm { FCVT            S6, H6 }
  v39 = a21 - _S6;
  __asm { FCVT            S3, H3 }
  v41 = v27 - (float)(v27 * a21);
  v42 = v29 - (float)(v29 * a21);
  v43 = v31 - (float)(v31 * a21);
  v44 = (float)(a5 - _S3) - (float)((float)(a5 - _S3) * a21);
  if (_ZF)
  {
    v41 = 0.0;
    v42 = 0.0;
    v43 = 0.0;
    v44 = 0.0;
  }
  else
  {
    v31 = v31 * a21;
    v29 = v29 * a21;
    v27 = v27 * a21;
  }
  v45 = (float)(v33 + v41) - (float)(v33 * a5);
  v46 = (float)(v35 + v42) - (float)(v35 * a5);
  v47 = (float)(v37 + v43) - (float)(v37 * a5);
  v48 = (float)(v39 + v44) - (float)(v39 * a5);
  if (a5 == 1.0)
  {
    v45 = v41;
    v49 = v42;
  }
  else
  {
    v33 = v33 * a5;
    v35 = v35 * a5;
    v37 = v37 * a5;
    v39 = v39 * a5;
    v49 = v46;
  }
  if (a5 == 1.0)
    v50 = v43;
  else
    v50 = v47;
  if (a5 != 1.0)
    v44 = v48;
  v51 = (float)((float)((float)(v35 - v29) * 0.59) + (float)((float)(v33 - v27) * 0.3))
      + (float)((float)(v37 - v31) * 0.11);
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  _S0 = _S4 - (float)(v45 + (float)(v27 + v51));
  __asm { FCVT            H0, S0 }
  _S1 = _S4 - (float)(v49 + (float)(v29 + v51));
  __asm { FCVT            H1, S1 }
  _S2 = _S4 - (float)(v50 + (float)(v31 + v51));
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - (float)(v39 + v44);
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)LOWORD(_S2) << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)LOWORD(_S1) << 16) | LOWORD(_S0);
}

unint64_t CMYKf16_mark_constmask(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, int32x4_t _Q1, double a11, __n128 a12, float32x4_t _Q4, float32x4_t _Q5, double _D6, double a16)
{
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned __int16 *v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  unint64_t v28;
  float16x4_t *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  float v43;
  unsigned int v47;
  int v48;
  float16x4_t *v49;
  char v50;
  unsigned int *v51;
  unsigned __int16 *v52;
  int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  float16x4_t *v59;
  char v60;
  unsigned int *v61;
  unsigned __int16 *v62;
  int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  float32x4_t v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  float v74;
  float v76;
  float v78;
  float32x4_t v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  float v87;
  float v89;
  float v92;
  float v94;
  float32x4_t v97;
  uint64_t v98;
  int v99;
  float v102;
  float32x4_t v106;
  uint64_t v107;
  int v108;
  unsigned int v109;
  float v112;
  float v113;
  float v117;
  float16x4_t v119;
  uint64_t v120;
  float32x4_t v121;
  int v122;
  unsigned int v123;
  float v127;
  float v131;
  uint64_t v132;
  int v133;
  unsigned int v134;
  float v138;
  float32x4_t v150;
  uint64_t v151;
  int v152;
  float v153;
  float v158;
  float32x4_t v160;
  uint64_t v161;
  int v162;
  float v165;
  float32x4_t v169;
  uint64_t v170;
  int v171;
  float v172;
  float v188;
  float v192;
  float v198;
  float v202;
  float32x4_t v206;
  uint64_t v207;
  int v208;
  float v209;
  float16x4_t v216;
  uint64_t v217;
  int v219;
  float v220;
  __n128 v221;
  __n128 v222;
  float16x4_t v223;
  int32x2_t v226;
  uint64_t v227;
  int v229;
  float v230;
  __n128 v231;
  __n128 v232;
  float16x4_t v233;
  int32x2_t v236;
  uint64_t v237;
  int v239;
  float v240;
  __n128 v241;
  __n128 v242;
  float16x4_t v243;
  int32x2_t v246;
  uint64_t v247;
  int v248;
  float v249;
  __n128 v250;
  __n128 v251;
  int32x2_t v253;
  uint64_t v254;
  int v255;
  float v256;
  __n128 v257;
  __n128 v258;
  int32x2_t v260;
  uint64_t v261;
  int v263;
  float v264;
  __n128 v265;
  __n128 v266;
  float16x4_t v267;
  int32x2_t v270;
  uint64_t v271;
  int v273;
  float v274;
  __n128 v275;
  __n128 v276;
  float16x4_t v277;
  int32x2_t v280;
  uint64_t v281;
  int v282;
  float v283;
  __n128 v284;
  __n128 v285;
  int32x2_t v286;
  int32x2_t v288;
  uint64_t v289;
  int v291;
  float v292;
  __n128 v293;
  __n128 v294;
  float16x4_t v295;
  int32x2_t v298;
  uint64_t v299;
  int v301;
  float v302;
  __n128 v303;
  __n128 v304;
  int32x2_t v305;
  int32x2_t v307;
  uint64_t v308;
  int v310;
  float v311;
  __n128 v312;
  __n128 v313;
  float16x4_t v314;
  int32x2_t v316;
  uint64_t v317;
  int v319;
  float v320;
  __n128 v321;
  __n128 v322;
  float16x4_t v323;
  int32x2_t v326;
  uint64_t v327;
  int v329;
  float v330;
  __n128 v331;
  __n128 v332;
  float16x4_t v333;
  int32x2_t v336;
  uint64_t v337;
  int v338;
  float v339;
  __n128 v341;
  __n128 v342;
  int32x2_t v344;
  uint64_t v345;
  int v347;
  float v348;
  __n128 v349;
  __n128 v350;
  float16x4_t v351;
  int32x2_t v354;
  int v355;
  int v356;
  int v357;
  char v358;
  unsigned int *v359;
  float16x4_t *v360;
  int v361;
  int v362;
  unsigned int v363;
  unsigned int v364;
  int v365;
  char v366;
  unsigned int *v367;
  float16x4_t *v368;
  int v369;
  int v370;
  unsigned int v371;
  unsigned int v372;
  float32x4_t v373;
  int v374;
  unsigned int v375;
  float32x4_t v376;
  int v377;
  unsigned int v378;
  float v382;
  int v393;
  float v394;
  int v395;
  uint64_t v396;
  unint64_t v397;
  int v398;
  float32x4_t v399;
  unint64_t v400;
  unsigned int v401;
  unsigned int v402;
  float v404;
  float v406;
  float v411;
  float v413;
  float v418;
  float v420;
  unsigned int v424;
  float v425;
  float v427;
  int v431;
  uint64_t v432;
  unint64_t v433;
  int v434;
  float32x4_t v435;
  float32x4_t v436;
  unint64_t v437;
  unsigned int v438;
  unsigned int v439;
  unsigned int v464;
  int v470;
  uint64_t v471;
  int v472;
  float32x4_t v473;
  unint64_t v474;
  unsigned int v475;
  int v476;
  unsigned int v477;
  float16x4_t v478;
  float16x4_t v479;
  float16x4_t v480;
  unsigned int v481;
  int v482;
  uint64_t v483;
  unint64_t v484;
  int v485;
  float32x4_t v486;
  float32x4_t v487;
  unsigned int v488;
  int v489;
  unsigned int v490;
  float v500;
  float v503;
  float v506;
  unsigned int v509;
  float v510;
  float v520;
  int v531;
  float32x4_t v532;
  float32x4_t v533;
  float32x4_t v534;
  float32x4_t v535;
  float32x4_t v536;
  float32x4_t v537;
  float32x4_t v538;
  float32x4_t v539;
  float32x4_t v540;
  float32x4_t v541;
  float32x4_t v542;
  float32x4_t v543;
  float32x4_t v544;
  float32x4_t v545;
  float32x4_t v546;
  unint64_t v547;

  v16 = *(_QWORD *)(result + 48);
  v17 = *(_QWORD *)(result + 136);
  v18 = *(unsigned __int16 **)(result + 96);
  if (v18)
    _Q1.i16[0] = *v18;
  else
    _Q1.i16[0] = 15360;
  v20 = *(int *)(result + 12);
  v19 = *(int *)(result + 16);
  if (v16)
  {
    v21 = (unint64_t)*(int *)(result + 32) >> 1;
    v22 = (unsigned __int16 *)(v16 + 2 * (v20 + v21 * v19));
    v23 = 1;
    if (!v17)
      return result;
  }
  else
  {
    v22 = 0;
    v21 = 0;
    v23 = 0;
    if (!v17)
      return result;
  }
  v24 = *(_DWORD *)(result + 4);
  v25 = v21 - v24;
  if (v16)
    v26 = v21 - v24;
  else
    v26 = v21;
  v27 = *(_DWORD *)(result + 8);
  v28 = (unint64_t)*(int *)(result + 28) >> 3;
  _Q0.i64[0] = **(_QWORD **)(result + 88);
  __asm { FCVT            S8, H1 }
  v35 = (float16x4_t *)(*(_QWORD *)(result + 40) + 8 * (v20 + v28 * v19));
  v36 = *(int *)(result + 124);
  v37 = v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v36;
  v38 = v36 - v24;
  v547 = v28 - v24;
  switch((int)a2)
  {
    case 0:
      if (v16)
      {
        v39 = 2 * v23;
        do
        {
          v40 = v24;
          do
          {
            v41 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v41 == 255)
              {
                *v35 = 0;
                _H1 = 0;
              }
              else
              {
                v43 = (float)(v41 ^ 0xFFu) * 0.0039216;
                *v35 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v35), v43));
                _H2 = *v22;
                __asm { FCVT            S2, H2 }
                _S1 = v43 * _S2;
                __asm { FCVT            H1, S1 }
              }
              *v22 = _H1;
            }
            ++v37;
            ++v35;
            v22 = (unsigned __int16 *)((char *)v22 + v39);
            --v40;
          }
          while (v40);
          v37 += v38;
          v35 += v547;
          v22 += v26;
          --v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v355 = v24;
          do
          {
            v356 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v356 == 255)
                *v35 = 0;
              else
                *v35 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v35), (float)(v356 ^ 0xFFu) * 0.0039216));
            }
            ++v37;
            ++v35;
            --v355;
          }
          while (v355);
          v37 += v38;
          v35 += v547;
          --v27;
        }
        while (v27);
      }
      return result;
    case 1:
      v47 = v37 & 3;
      if (!v16)
      {
        v357 = -1 << (8 * v47);
        if ((v37 & 3) != 0)
          v358 = v37 & 0xFC;
        else
          v358 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v36;
        if ((v37 & 3) != 0)
        {
          v359 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v357 = -1;
          v359 = (unsigned int *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v36);
        }
        if ((v37 & 3) != 0)
          v360 = &v35[-(v37 & 3)];
        else
          v360 = v35;
        if ((v37 & 3) != 0)
          v361 = v47 + v24;
        else
          v361 = *(_DWORD *)(result + 4);
        if ((((_BYTE)v361 + v358) & 3) != 0)
        {
          v362 = 4 - (((_BYTE)v361 + v358) & 3);
          v47 += v362;
          v363 = 0xFFFFFFFF >> (8 * v362);
          if (v361 >= 4)
            v364 = v363;
          else
            v364 = 0;
          if (v361 >= 4)
            v363 = -1;
          v357 &= v363;
        }
        else
        {
          v364 = 0;
        }
        v471 = v38 - v47;
        v472 = v361 >> 2;
        v473 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
        v474 = v547 - v47;
        while (1)
        {
          v475 = *v359 & v357;
          v476 = v472;
          v477 = v364;
          if (!v475)
            goto LABEL_533;
LABEL_515:
          if (v475 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v475)
            {
              v478 = *(float16x4_t *)_Q0.i8;
              if (v475 != 255)
                v478 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v473, (float)v475 * 0.0039216))), vcvtq_f32_f16(*v360), 1.0 - (float)((float)v475 * 0.0039216)));
              *v360 = v478;
            }
            if (BYTE1(v475))
            {
              v479 = *(float16x4_t *)_Q0.i8;
              if (BYTE1(v475) != 255)
                v479 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v473, (float)BYTE1(v475) * 0.0039216))), vcvtq_f32_f16(v360[1]), 1.0 - (float)((float)BYTE1(v475) * 0.0039216)));
              v360[1] = v479;
            }
            result = BYTE2(v475);
            if (BYTE2(v475))
            {
              v480 = *(float16x4_t *)_Q0.i8;
              if (BYTE2(v475) != 255)
                v480 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v473, (float)BYTE2(v475) * 0.0039216))), vcvtq_f32_f16(v360[2]), 1.0 - (float)((float)BYTE2(v475) * 0.0039216)));
              v360[2] = v480;
            }
            v481 = HIBYTE(v475);
            if (v481 == 255)
              goto LABEL_530;
            if (v481)
              v360[3] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v473, (float)v481 * 0.0039216))), vcvtq_f32_f16(v360[3]), 1.0 - (float)((float)v481 * 0.0039216)));
LABEL_533:
            while (1)
            {
              v482 = v476;
              v360 += 4;
              --v476;
              ++v359;
              if (v482 < 2)
                break;
              v475 = *v359;
              if (*v359)
                goto LABEL_515;
            }
            if (!v477)
              break;
            v477 = 0;
            v475 = *v359 & v364;
          }
          v359 = (unsigned int *)((char *)v359 + v471);
          v360 += v474;
          if (!--v27)
            return result;
        }
        *v360 = *(float16x4_t *)_Q0.i8;
        v360[1] = *(float16x4_t *)_Q0.i8;
        v360[2] = *(float16x4_t *)_Q0.i8;
LABEL_530:
        v360[3] = *(float16x4_t *)_Q0.i8;
        goto LABEL_533;
      }
      v48 = -1 << (8 * v47);
      v49 = &v35[-(v37 & 3)];
      if ((v37 & 3) != 0)
        v50 = v37 & 0xFC;
      else
        v50 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v36;
      if ((v37 & 3) != 0)
      {
        v51 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        v48 = -1;
        v51 = (unsigned int *)v37;
      }
      if ((v37 & 3) != 0)
        v52 = &v22[-(v37 & 3)];
      else
        v52 = v22;
      if ((v37 & 3) != 0)
      {
        v53 = v47 + v24;
      }
      else
      {
        v49 = v35;
        v53 = v24;
      }
      if ((((_BYTE)v53 + v50) & 3) != 0)
      {
        v54 = 4 - (((_BYTE)v53 + v50) & 3);
        v47 += v54;
        v55 = 0xFFFFFFFF >> (8 * v54);
        if (v53 >= 4)
          v56 = v55;
        else
          v56 = 0;
        if (v53 >= 4)
          v55 = -1;
        v48 &= v55;
      }
      else
      {
        v56 = 0;
      }
      v396 = v38 - v47;
      v397 = v547 - v47;
      v398 = v53 >> 2;
      v399 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v400 = v25 - v47;
      do
      {
        v401 = *v51 & v48;
        LODWORD(result) = v398;
        v402 = v56;
        if (!v401)
          goto LABEL_484;
LABEL_463:
        if (v401 == -1)
        {
          *v49 = *(float16x4_t *)_Q0.i8;
          *v52 = _Q1.i16[0];
          v49[1] = *(float16x4_t *)_Q0.i8;
          v52[1] = _Q1.i16[0];
          v49[2] = *(float16x4_t *)_Q0.i8;
          v52[2] = _Q1.i16[0];
LABEL_481:
          v49[3] = *(float16x4_t *)_Q0.i8;
          v52[3] = _Q1.i16[0];
          goto LABEL_484;
        }
        while (1)
        {
          if ((_BYTE)v401)
          {
            if (v401 == 255)
            {
              *v49 = *(float16x4_t *)_Q0.i8;
              _H5 = _Q1.i16[0];
            }
            else
            {
              v404 = (float)v401 * 0.0039216;
              _S6 = v404 * _S8;
              __asm { FCVT            H6, S6 }
              v406 = 1.0 - v404;
              *v49 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v399, v404))), vcvtq_f32_f16(*v49), 1.0 - v404));
              __asm { FCVT            S5, H6 }
              LOWORD(_S6) = *v52;
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * v406);
              __asm { FCVT            H5, S5 }
            }
            *v52 = _H5;
          }
          if (BYTE1(v401))
          {
            if (BYTE1(v401) == 255)
            {
              v49[1] = *(float16x4_t *)_Q0.i8;
              _H5 = _Q1.i16[0];
            }
            else
            {
              v411 = (float)BYTE1(v401) * 0.0039216;
              _S6 = v411 * _S8;
              __asm { FCVT            H6, S6 }
              v413 = 1.0 - v411;
              v49[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v399, v411))), vcvtq_f32_f16(v49[1]), 1.0 - v411));
              __asm { FCVT            S5, H6 }
              LOWORD(_S6) = v52[1];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * v413);
              __asm { FCVT            H5, S5 }
            }
            v52[1] = _H5;
          }
          if (BYTE2(v401))
          {
            if (BYTE2(v401) == 255)
            {
              v49[2] = *(float16x4_t *)_Q0.i8;
              _H5 = _Q1.i16[0];
            }
            else
            {
              v418 = (float)BYTE2(v401) * 0.0039216;
              _S6 = v418 * _S8;
              __asm { FCVT            H6, S6 }
              v420 = 1.0 - v418;
              v49[2] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v399, v418))), vcvtq_f32_f16(v49[2]), 1.0 - v418));
              __asm { FCVT            S5, H6 }
              LOWORD(_S6) = v52[2];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * v420);
              __asm { FCVT            H5, S5 }
            }
            v52[2] = _H5;
          }
          v424 = HIBYTE(v401);
          if (v424 == 255)
            goto LABEL_481;
          if (v424)
          {
            v425 = (float)v424 * 0.0039216;
            _S6 = v425 * _S8;
            __asm { FCVT            H6, S6 }
            v427 = 1.0 - v425;
            v49[3] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v399, v425))), vcvtq_f32_f16(v49[3]), 1.0 - v425));
            __asm { FCVT            S5, H6 }
            LOWORD(_S6) = v52[3];
            __asm { FCVT            S6, H6 }
            _S5 = _S5 + (float)(_S6 * v427);
            __asm { FCVT            H5, S5 }
            v52[3] = LOWORD(_S5);
          }
LABEL_484:
          while (1)
          {
            v431 = result;
            v49 += 4;
            v52 += 4;
            result = (result - 1);
            ++v51;
            if (v431 < 2)
              break;
            v401 = *v51;
            if (*v51)
              goto LABEL_463;
          }
          if (!v402)
            break;
          v402 = 0;
          v401 = *v51 & v56;
        }
        v51 = (unsigned int *)((char *)v51 + v396);
        v49 += v397;
        v52 += v400;
        --v27;
      }
      while (v27);
      return result;
    case 2:
      *(float *)_Q1.i32 = 1.0 - _S8;
      v57 = v37 & 3;
      if (v16)
      {
        v58 = -1 << (8 * v57);
        v59 = &v35[-(v37 & 3)];
        if ((v37 & 3) != 0)
          v60 = v37 & 0xFC;
        else
          v60 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v36;
        if ((v37 & 3) != 0)
        {
          v61 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v58 = -1;
          v61 = (unsigned int *)v37;
        }
        if ((v37 & 3) != 0)
          v62 = &v22[-(v37 & 3)];
        else
          v62 = v22;
        if ((v37 & 3) != 0)
        {
          v63 = v57 + v24;
        }
        else
        {
          v59 = v35;
          v63 = v24;
        }
        if ((((_BYTE)v63 + v60) & 3) != 0)
        {
          v64 = 4 - (((_BYTE)v63 + v60) & 3);
          v57 += v64;
          v65 = 0xFFFFFFFF >> (8 * v64);
          if (v63 >= 4)
            v66 = v65;
          else
            v66 = 0;
          if (v63 >= 4)
            v65 = -1;
          v58 &= v65;
        }
        else
        {
          v66 = 0;
        }
        v432 = v38 - v57;
        v433 = v547 - v57;
        v434 = v63 >> 2;
        v435 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
        v436 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
        v437 = v25 - v57;
        while (1)
        {
          v438 = *v61 & v58;
          LODWORD(result) = v434;
          v439 = v66;
          if (!v438)
            goto LABEL_505;
LABEL_494:
          if (v438 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v438)
            {
              _S5 = (float)v438 * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              *v59 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v435, _S5))), vcvtq_f32_f16(*v59), 1.0 - _S6));
              LOWORD(_S5) = *v62;
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              __asm { FCVT            H5, S5 }
              *v62 = LOWORD(_S5);
            }
            if ((v438 & 0xFF00) != 0)
            {
              _S5 = (float)BYTE1(v438) * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              v59[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v435, _S5))), vcvtq_f32_f16(v59[1]), 1.0 - _S6));
              LOWORD(_S5) = v62[1];
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              __asm { FCVT            H5, S5 }
              v62[1] = LOWORD(_S5);
            }
            if ((v438 & 0xFF0000) != 0)
            {
              _S5 = (float)BYTE2(v438) * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              v59[2] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v435, _S5))), vcvtq_f32_f16(v59[2]), 1.0 - _S6));
              LOWORD(_S5) = v62[2];
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              __asm { FCVT            H5, S5 }
              v62[2] = LOWORD(_S5);
            }
            v464 = HIBYTE(v438);
            if (v464)
            {
              _S5 = (float)v464 * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              v59[3] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v435, _S5))), vcvtq_f32_f16(v59[3]), 1.0 - _S6));
              LOWORD(_S5) = v62[3];
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              goto LABEL_504;
            }
LABEL_505:
            while (1)
            {
              v470 = result;
              v59 += 4;
              v62 += 4;
              result = (result - 1);
              ++v61;
              if (v470 < 2)
                break;
              v438 = *v61;
              if (*v61)
                goto LABEL_494;
            }
            if (!v439)
              break;
            v439 = 0;
            v438 = *v61 & v66;
          }
          v61 = (unsigned int *)((char *)v61 + v432);
          v59 += v433;
          v62 += v437;
          if (!--v27)
            return result;
        }
        *v59 = vcvt_f16_f32(vmlaq_f32(v435, v436, vcvtq_f32_f16(*v59)));
        _H5 = *v62;
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
        __asm { FCVT            H5, S5 }
        *v62 = LOWORD(_S5);
        v59[1] = vcvt_f16_f32(vmlaq_f32(v435, v436, vcvtq_f32_f16(v59[1])));
        LOWORD(_S5) = v62[1];
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
        __asm { FCVT            H5, S5 }
        v62[1] = LOWORD(_S5);
        v59[2] = vcvt_f16_f32(vmlaq_f32(v435, v436, vcvtq_f32_f16(v59[2])));
        LOWORD(_S5) = v62[2];
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
        __asm { FCVT            H5, S5 }
        v62[2] = LOWORD(_S5);
        v59[3] = vcvt_f16_f32(vmlaq_f32(v435, v436, vcvtq_f32_f16(v59[3])));
        LOWORD(_S5) = v62[3];
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
LABEL_504:
        __asm { FCVT            H5, S5 }
        v62[3] = _H5;
        goto LABEL_505;
      }
      v365 = -1 << (8 * v57);
      if ((v37 & 3) != 0)
        v366 = v37 & 0xFC;
      else
        v366 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v36;
      if ((v37 & 3) != 0)
      {
        v367 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        v365 = -1;
        v367 = (unsigned int *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v36);
      }
      if ((v37 & 3) != 0)
        v368 = &v35[-(v37 & 3)];
      else
        v368 = v35;
      if ((v37 & 3) != 0)
        v369 = v57 + v24;
      else
        v369 = *(_DWORD *)(result + 4);
      if ((((_BYTE)v369 + v366) & 3) != 0)
      {
        v370 = 4 - (((_BYTE)v369 + v366) & 3);
        v57 += v370;
        v371 = 0xFFFFFFFF >> (8 * v370);
        if (v369 >= 4)
          v372 = v371;
        else
          v372 = 0;
        if (v369 >= 4)
          v371 = -1;
        v365 &= v371;
      }
      else
      {
        v372 = 0;
      }
      v483 = v38 - v57;
      v484 = v547 - v57;
      v485 = v369 >> 2;
      v486 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v487 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
      while (1)
      {
        v488 = *v367 & v365;
        v489 = v485;
        v490 = v372;
        if (!v488)
          goto LABEL_554;
LABEL_543:
        if (v488 == -1)
          break;
        while (1)
        {
          if ((_BYTE)v488)
          {
            result = v488;
            v500 = (float)v488 * 0.0039216;
            _S17 = v500 * _S8;
            __asm
            {
              FCVT            H17, S17
              FCVT            S17, H17
            }
            *v368 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v486, v500))), vcvtq_f32_f16(*v368), 1.0 - _S17));
          }
          if ((v488 & 0xFF00) != 0)
          {
            result = BYTE1(v488);
            v503 = (float)BYTE1(v488) * 0.0039216;
            _S17 = v503 * _S8;
            __asm
            {
              FCVT            H17, S17
              FCVT            S17, H17
            }
            v368[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v486, v503))), vcvtq_f32_f16(v368[1]), 1.0 - _S17));
          }
          if ((v488 & 0xFF0000) != 0)
          {
            result = BYTE2(v488);
            v506 = (float)BYTE2(v488) * 0.0039216;
            _S17 = v506 * _S8;
            __asm
            {
              FCVT            H17, S17
              FCVT            S17, H17
            }
            v368[2] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v486, v506))), vcvtq_f32_f16(v368[2]), 1.0 - _S17));
          }
          v509 = HIBYTE(v488);
          if (v509)
          {
            v510 = (float)v509 * 0.0039216;
            _S17 = v510 * v486.f32[0];
            __asm { FCVT            H17, S17 }
            _S18 = v510 * v486.f32[1];
            __asm { FCVT            H18, S18 }
            _S19 = v510 * v486.f32[2];
            __asm { FCVT            H19, S19 }
            _S20 = v510 * v486.f32[3];
            __asm { FCVT            H20, S20 }
            _S16 = v510 * _S8;
            __asm
            {
              FCVT            H16, S16
              FCVT            S17, H17
            }
            _H21 = v368[3].i16[0];
            __asm
            {
              FCVT            S21, H21
              FCVT            S16, H16
            }
            v520 = 1.0 - _S16;
            _S17 = _S17 + (float)(_S21 * v520);
            __asm { FCVT            H17, S17 }
            v368[3].i16[0] = LOWORD(_S17);
            __asm { FCVT            S17, H18 }
            LOWORD(_S18) = v368[3].i16[1];
            __asm { FCVT            S18, H18 }
            _S17 = _S17 + (float)(_S18 * v520);
            __asm { FCVT            H17, S17 }
            v368[3].i16[1] = LOWORD(_S17);
            __asm { FCVT            S17, H19 }
            LOWORD(_S18) = v368[3].i16[2];
            __asm { FCVT            S18, H18 }
            _S17 = _S17 + (float)(_S18 * v520);
            __asm { FCVT            H17, S17 }
            v368[3].i16[2] = LOWORD(_S17);
            __asm { FCVT            S17, H20 }
            LOWORD(_S18) = v368[3].i16[3];
            __asm { FCVT            S18, H18 }
            _S16 = _S17 + (float)(_S18 * v520);
            goto LABEL_553;
          }
LABEL_554:
          while (1)
          {
            v531 = v489;
            v368 += 4;
            --v489;
            ++v367;
            if (v531 < 2)
              break;
            v488 = *v367;
            if (*v367)
              goto LABEL_543;
          }
          if (!v490)
            break;
          v490 = 0;
          v488 = *v367 & v372;
        }
        v367 = (unsigned int *)((char *)v367 + v483);
        v368 += v484;
        if (!--v27)
          return result;
      }
      *(float16x8_t *)v368->i8 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(v486, v487, vcvtq_f32_f16(*v368))), vmlaq_f32(v486, v487, vcvt_hight_f32_f16(*(float16x8_t *)v368->i8)));
      v368[2] = vcvt_f16_f32(vmlaq_f32(v486, v487, vcvtq_f32_f16(v368[2])));
      _H16 = v368[3].i16[0];
      __asm { FCVT            S16, H16 }
      _S16 = v486.f32[0] + (float)(_S16 * *(float *)_Q1.i32);
      __asm { FCVT            H16, S16 }
      v368[3].i16[0] = LOWORD(_S16);
      LOWORD(_S16) = v368[3].i16[1];
      __asm { FCVT            S16, H16 }
      _S16 = v486.f32[1] + (float)(_S16 * *(float *)_Q1.i32);
      __asm { FCVT            H16, S16 }
      v368[3].i16[1] = LOWORD(_S16);
      LOWORD(_S16) = v368[3].i16[2];
      __asm { FCVT            S16, H16 }
      _S16 = v486.f32[2] + (float)(_S16 * *(float *)_Q1.i32);
      __asm { FCVT            H16, S16 }
      v368[3].i16[2] = LOWORD(_S16);
      LOWORD(_S16) = v368[3].i16[3];
      __asm { FCVT            S16, H16 }
      _S16 = v486.f32[3] + (float)(_S16 * *(float *)_Q1.i32);
LABEL_553:
      __asm { FCVT            H16, S16 }
      v368[3].i16[3] = _H16;
      goto LABEL_554;
    case 3:
      v67 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v68 = 2 * v23;
      do
      {
        v69 = v24;
        do
        {
          v70 = *(unsigned __int8 *)v37;
          if (*(_BYTE *)v37)
          {
            if (v70 == 255)
            {
              _Q4.i16[0] = *v22;
              __asm { FCVT            S3, H4 }
              _S3 = _S8 * _S3;
              __asm { FCVT            H3, S3 }
              *(float16x4_t *)_Q4.f32 = vcvt_f16_f32(vmulq_f32(v67, vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)_Q4.f32, 0))));
              *v35 = *(float16x4_t *)_Q4.f32;
            }
            else
            {
              v74 = (float)v70 * 0.0039216;
              _H4 = *v22;
              __asm { FCVT            S4, H4 }
              v76 = v74 * _Q4.f32[0];
              _S6 = (float)(v74 * _Q4.f32[0]) * _S8;
              __asm { FCVT            H6, S6 }
              v78 = 1.0 - v74;
              *v35 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v67, v76))), vcvtq_f32_f16(*v35), v78));
              __asm { FCVT            S5, H6 }
              _S3 = _S5 + (float)(_Q4.f32[0] * v78);
              __asm { FCVT            H3, S3 }
            }
            *v22 = _H3;
          }
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v68);
          --v69;
        }
        while (v69);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        --v27;
      }
      while (v27);
      return result;
    case 4:
      v81 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v82 = 2 * v23;
      do
      {
        v83 = v24;
        do
        {
          v84 = *(unsigned __int8 *)v37;
          if (*(_BYTE *)v37)
          {
            if (v84 == 255)
            {
              _H3 = *v22;
              __asm { FCVT            S3, H3 }
              v87 = 1.0 - _S3;
              _S3 = (float)(1.0 - _S3) * _S8;
              *v35 = vcvt_f16_f32(vmulq_n_f32(v81, v87));
            }
            else
            {
              v89 = (float)v84 * 0.0039216;
              _H4 = *v22;
              __asm { FCVT            S4, H4 }
              v92 = v89 * (float)(1.0 - _S4);
              _S6 = v92 * _S8;
              __asm { FCVT            H6, S6 }
              v94 = 1.0 - v89;
              *v35 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v81, v92))), vcvtq_f32_f16(*v35), v94));
              __asm { FCVT            S5, H6 }
              _S3 = _S5 + (float)(_S4 * v94);
            }
            __asm { FCVT            H3, S3 }
            *v22 = _H3;
          }
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v82);
          --v83;
        }
        while (v83);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        --v27;
      }
      while (v27);
      return result;
    case 5:
      v97 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v98 = 2 * v23;
      do
      {
        v99 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            _H3 = *v22;
            __asm { FCVT            S3, H3 }
            v102 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _S5 = v102 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
            }
            *v35 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v35), 1.0 - _S5), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v97, v102))), _S3));
            _S3 = (float)((float)(1.0 - _S5) * _S3) + (float)(_S5 * _S3);
            __asm { FCVT            H3, S3 }
            *v22 = LOWORD(_S3);
          }
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v98);
          --v99;
        }
        while (v99);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        --v27;
      }
      while (v27);
      return result;
    case 6:
      v106 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v107 = 2 * v23;
      while (1)
      {
        v108 = v24;
        do
        {
          v109 = *(unsigned __int8 *)v37;
          if (!*(_BYTE *)v37)
            goto LABEL_98;
          _H3 = *v22;
          __asm { FCVT            S3, H3 }
          v112 = 1.0 - _S3;
          if ((float)(1.0 - _S3) >= 1.0)
          {
            v117 = (float)v109 * 0.0039216;
            _S3 = v117 * _S8;
            *v35 = vcvt_f16_f32(vmulq_n_f32(v106, v117));
          }
          else
          {
            if (v112 <= 0.0)
              goto LABEL_98;
            v113 = (float)v109 * 0.0039216;
            _S6 = v113 * _S8;
            __asm { FCVT            H6, S6 }
            *v35 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v35), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v106, v113))), v112));
            __asm { FCVT            S5, H6 }
            _S3 = _S3 + (float)(_S5 * v112);
          }
          __asm { FCVT            H3, S3 }
          *v22 = _H3;
LABEL_98:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v107);
          --v108;
        }
        while (v108);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 7:
      v119 = (float16x4_t)vdup_lane_s16(*(int16x4_t *)_Q1.i8, 0);
      if (v16)
      {
        v120 = 2 * v23;
        v121 = vcvtq_f32_f16(v119);
        do
        {
          v122 = v24;
          do
          {
            v123 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v123 == 255)
              {
                *v35 = vcvt_f16_f32(vmulq_f32(v121, vcvtq_f32_f16(*v35)));
                _H3 = *v22;
                __asm { FCVT            S3, H3 }
                _S3 = _S8 * _S3;
              }
              else
              {
                v127 = (float)((float)((float)v123 * 0.0039216) * _S8) + (float)(1.0 - (float)((float)v123 * 0.0039216));
                *v35 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v35), v127));
                _H4 = *v22;
                __asm { FCVT            S4, H4 }
                _S3 = v127 * _S4;
              }
              __asm { FCVT            H3, S3 }
              *v22 = _H3;
            }
            ++v37;
            ++v35;
            v22 = (unsigned __int16 *)((char *)v22 + v120);
            --v122;
          }
          while (v122);
          v37 += v38;
          v35 += v547;
          v22 += v26;
          --v27;
        }
        while (v27);
      }
      else
      {
        v373 = vcvtq_f32_f16(v119);
        do
        {
          v374 = v24;
          do
          {
            v375 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v375 == 255)
                v376 = vmulq_f32(v373, vcvtq_f32_f16(*v35));
              else
                v376 = vmulq_n_f32(vcvtq_f32_f16(*v35), (float)((float)((float)v375 * 0.0039216) * _S8)+ (float)(1.0 - (float)((float)v375 * 0.0039216)));
              *v35 = vcvt_f16_f32(v376);
            }
            ++v37;
            ++v35;
            --v374;
          }
          while (v374);
          v37 += v38;
          v35 += v547;
          --v27;
        }
        while (v27);
      }
      return result;
    case 8:
      v131 = 1.0 - _S8;
      if (v16)
      {
        v132 = 2 * v23;
        do
        {
          v133 = v24;
          do
          {
            v134 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              _H3 = v35->i16[0];
              if (v134 == 255)
              {
                __asm { FCVT            S3, H3 }
                _S4 = v131 * _S3;
                v138 = 1.0 - _S8;
              }
              else
              {
                __asm { FCVT            S4, H3 }
                v138 = (float)((float)((float)v134 * -0.0039216) * _S8) + 1.0;
                _S4 = v138 * _S4;
              }
              __asm { FCVT            H4, S4 }
              v35->i16[0] = _H4;
              _H4 = v35->i16[1];
              __asm { FCVT            S4, H4 }
              _S4 = v138 * _S4;
              __asm { FCVT            H4, S4 }
              v35->i16[1] = LOWORD(_S4);
              LOWORD(_S4) = v35->i16[2];
              __asm { FCVT            S4, H4 }
              _S4 = v138 * _S4;
              __asm { FCVT            H4, S4 }
              v35->i16[2] = LOWORD(_S4);
              LOWORD(_S4) = v35->i16[3];
              __asm { FCVT            S4, H4 }
              _S4 = v138 * _S4;
              __asm { FCVT            H4, S4 }
              v35->i16[3] = LOWORD(_S4);
              LOWORD(_S4) = *v22;
              __asm { FCVT            S4, H4 }
              _S3 = v138 * _S4;
              __asm { FCVT            H3, S3 }
              *v22 = LOWORD(_S3);
            }
            ++v37;
            ++v35;
            v22 = (unsigned __int16 *)((char *)v22 + v132);
            --v133;
          }
          while (v133);
          v37 += v38;
          v35 += v547;
          v22 += v26;
          --v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v377 = v24;
          do
          {
            v378 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              _H3 = v35->i16[0];
              if (v378 == 255)
              {
                __asm { FCVT            S3, H3 }
                _S4 = v131 * _S3;
                v382 = 1.0 - _S8;
              }
              else
              {
                __asm { FCVT            S4, H3 }
                v382 = (float)((float)((float)v378 * -0.0039216) * _S8) + 1.0;
                _S4 = v382 * _S4;
              }
              __asm { FCVT            H4, S4 }
              v35->i16[0] = _H4;
              _H4 = v35->i16[1];
              __asm { FCVT            S4, H4 }
              _S4 = v382 * _S4;
              __asm { FCVT            H4, S4 }
              v35->i16[1] = LOWORD(_S4);
              LOWORD(_S4) = v35->i16[2];
              __asm { FCVT            S4, H4 }
              _S4 = v382 * _S4;
              __asm { FCVT            H4, S4 }
              v35->i16[2] = LOWORD(_S4);
              LOWORD(_S4) = v35->i16[3];
              __asm { FCVT            S4, H4 }
              _S3 = v382 * _S4;
              __asm { FCVT            H3, S3 }
              v35->i16[3] = LOWORD(_S3);
            }
            ++v37;
            ++v35;
            --v377;
          }
          while (v377);
          v37 += v38;
          v35 += v547;
          --v27;
        }
        while (v27);
      }
      return result;
    case 9:
      v150 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v151 = 2 * v23;
      do
      {
        v152 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v153 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _H4 = *v22;
            __asm { FCVT            S4, H4 }
            _S5 = v153 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
            }
            v158 = (float)(1.0 - v153) + _S5;
            *v35 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v35), v158), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v150, v153))), 1.0 - _S4));
            _S3 = (float)(v158 * _S4) + (float)(_S5 * (float)(1.0 - _S4));
            __asm { FCVT            H3, S3 }
            *v22 = LOWORD(_S3);
          }
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v151);
          --v152;
        }
        while (v152);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        --v27;
      }
      while (v27);
      return result;
    case 10:
      v160 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v161 = 2 * v23;
      do
      {
        v162 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            _H3 = *v22;
            __asm { FCVT            S3, H3 }
            v165 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _S5 = v165 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
            }
            *v35 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v35), 1.0 - _S5), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v160, v165))), 1.0 - _S3));
            _S3 = (float)((float)(1.0 - _S5) * _S3) + (float)(_S5 * (float)(1.0 - _S3));
            __asm { FCVT            H3, S3 }
            *v22 = LOWORD(_S3);
          }
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v161);
          --v162;
        }
        while (v162);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        --v27;
      }
      while (v27);
      return result;
    case 11:
      v169 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      if (v16)
      {
        v170 = 2 * v23;
        do
        {
          v171 = v24;
          do
          {
            if (*(_BYTE *)v37)
            {
              v172 = (float)*(unsigned __int8 *)v37 * 0.0039216;
              _S7 = v172 * v169.f32[0];
              __asm { FCVT            H7, S7 }
              _S16 = v172 * v169.f32[1];
              __asm { FCVT            H16, S16 }
              _S17 = v172 * v169.f32[2];
              __asm { FCVT            H17, S17 }
              _S18 = v172 * v169.f32[3];
              __asm { FCVT            H18, S18 }
              _S6 = v172 * _S8;
              __asm { FCVT            H6, S6 }
              _H19 = *v22;
              __asm
              {
                FCVT            S19, H19
                FCVT            S6, H6
              }
              _S20 = _S6 + _S19;
              _H21 = v35->i16[0];
              __asm
              {
                FCVT            S21, H21
                FCVT            S7, H7
              }
              v188 = (float)(_S6 - _S7) + (float)(_S19 - _S21);
              if ((float)(_S6 + _S19) > 1.0)
                _S20 = 1.0;
              _H21 = v35->i16[1];
              __asm
              {
                FCVT            S21, H21
                FCVT            S16, H16
              }
              v192 = (float)(_S6 - _S16) + (float)(_S19 - _S21);
              _S7 = _S20 - v188;
              __asm { FCVT            H7, S7 }
              v35->i16[0] = LOWORD(_S7);
              LOWORD(_S7) = *v22;
              __asm { FCVT            S7, H7 }
              _H19 = v35->i16[2];
              __asm
              {
                FCVT            S19, H19
                FCVT            S17, H17
              }
              v198 = (float)(_S6 - _S17) + (float)(_S7 - _S19);
              _S16 = _S20 - v192;
              __asm { FCVT            H16, S16 }
              v35->i16[1] = LOWORD(_S16);
              LOWORD(_S16) = *v22;
              __asm { FCVT            S16, H16 }
              LOWORD(_S17) = v35->i16[3];
              __asm { FCVT            S17, H17 }
              v202 = _S16 - _S17;
              __asm { FCVT            S17, H18 }
              _S7 = _S20 - v198;
              __asm { FCVT            H7, S7 }
              v35->i16[2] = LOWORD(_S7);
              __asm { FCVT            H7, S20 }
              *v22 = LOWORD(_S7);
              _S6 = _S20 - (float)((float)(_S6 - _S17) + v202);
              __asm { FCVT            H6, S6 }
              v35->i16[3] = LOWORD(_S6);
            }
            ++v37;
            ++v35;
            v22 = (unsigned __int16 *)((char *)v22 + v170);
            --v171;
          }
          while (v171);
          v37 += v38;
          v35 += v547;
          v22 += v26;
          --v27;
        }
        while (v27);
      }
      else
      {
        __asm { FMOV            V2.4S, #1.0 }
        do
        {
          v393 = v24;
          do
          {
            if (*(_BYTE *)v37)
            {
              v394 = (float)*(unsigned __int8 *)v37 * 0.0039216;
              _Q4.f32[0] = v394 * _S8;
              __asm
              {
                FCVT            H4, S4
                FCVT            S4, H4
              }
              _Q4 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q4.f32, 0);
              *v35 = vcvt_f16_f32(vsubq_f32(_Q2, vaddq_f32(vsubq_f32(_Q4, vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v169, v394)))), vsubq_f32(_Q2, vcvtq_f32_f16(*v35)))));
            }
            ++v37;
            ++v35;
            --v393;
          }
          while (v393);
          v37 += v38;
          v35 += v547;
          --v27;
        }
        while (v27);
      }
      return result;
    case 12:
      v206 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      if (v16)
      {
        v207 = 2 * v23;
        do
        {
          v208 = v24;
          do
          {
            if (*(_BYTE *)v37)
            {
              v209 = (float)*(unsigned __int8 *)v37 * 0.0039216;
              _S4 = v209 * _S8;
              __asm { FCVT            H4, S4 }
              _H5 = *v22;
              __asm
              {
                FCVT            S5, H5
                FCVT            S4, H4
              }
              _S4 = _S4 + _S5;
              if (_S4 > 1.0)
                _S4 = 1.0;
              __asm { FCVT            H4, S4 }
              v216.i32[0] = v35->i32[0];
              *v22 = _H4;
              v216.i32[1] = v35->i32[1];
              *v35 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(v216), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v206, v209)))));
            }
            ++v37;
            ++v35;
            v22 = (unsigned __int16 *)((char *)v22 + v207);
            --v208;
          }
          while (v208);
          v37 += v38;
          v35 += v547;
          v22 += v26;
          --v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v395 = v24;
          do
          {
            if (*(_BYTE *)v37)
              *v35 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(*v35), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v206, (float)*(unsigned __int8 *)v37 * 0.0039216)))));
            ++v37;
            ++v35;
            --v395;
          }
          while (v395);
          v37 += v38;
          v35 += v547;
          --v27;
        }
        while (v27);
      }
      return result;
    case 13:
      v532 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v217 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v219 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v220 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v220 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v221 = (__n128)v532;
              v222 = (__n128)vmulq_n_f32(v532, v220);
              v223 = vcvt_f16_f32((float32x4_t)v222);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_167;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v222.n128_u16[0] = v35->u16[1];
              v221.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAmultiplyPDA(_Q0, v222, v221, a12, _S4, *(double *)&v223, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v223.i16[0], v223.i16[1], v223.i16[2],
                         v223.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v226.i32[0] = result;
              v226.i32[1] = WORD1(result);
              v223 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v226, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_167:
                *v35 = v223;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_169;
              }
              *v35 = v223;
            }
          }
LABEL_169:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v217);
          --v219;
        }
        while (v219);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 14:
      v533 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v227 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v229 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v230 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v230 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v231 = (__n128)v533;
              v232 = (__n128)vmulq_n_f32(v533, v230);
              v233 = vcvt_f16_f32((float32x4_t)v232);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_182;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v232.n128_u16[0] = v35->u16[1];
              v231.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAscreenPDA(_Q0, v232, v231, a12, _S4, *(double *)&v233, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v233.i16[0], v233.i16[1], v233.i16[2],
                         v233.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v236.i32[0] = result;
              v236.i32[1] = WORD1(result);
              v233 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v236, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_182:
                *v35 = v233;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_184;
              }
              *v35 = v233;
            }
          }
LABEL_184:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v227);
          --v229;
        }
        while (v229);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 15:
      v534 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v237 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v239 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v240 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v240 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v241 = (__n128)v534;
              v242 = (__n128)vmulq_n_f32(v534, v240);
              v243 = vcvt_f16_f32((float32x4_t)v242);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_197;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v242.n128_u16[0] = v35->u16[1];
              v241.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAoverlayPDA(_Q0, v242, v241, a12, _S4, *(double *)&v243, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v243.i16[0], v243.i16[1], v243.i16[2],
                         v243.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v246.i32[0] = result;
              v246.i32[1] = WORD1(result);
              v243 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v246, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_197:
                *v35 = v243;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_199;
              }
              *v35 = v243;
            }
          }
LABEL_199:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v237);
          --v239;
        }
        while (v239);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 16:
      v535 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v247 = 2 * v23;
      _Q0.i32[1] = -1;
      while (1)
      {
        v248 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v249 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            *(float *)_Q0.i32 = v249 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v250 = (__n128)v535;
              v251 = (__n128)vmulq_n_f32(v535, v249);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v251);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_Q4.f32[0] <= 0.0)
                  goto LABEL_212;
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.i16[0] = v35->i16[0];
              v251.n128_u16[0] = v35->u16[1];
              v250.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAdarkenPDA(*(float16x4_t *)_Q0.i8, v251, v250, a12, _Q4, _Q5, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, *(float16x4_t *)_Q5.f32, *(float *)&_D6);
              _Q0 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v253.i32[0] = result;
              v253.i32[1] = WORD1(result);
              *(int16x4_t *)_Q5.f32 = vmovn_s32(vmovn_hight_s64(v253, _Q0));
              if (v16)
              {
                _Q0.i16[0] = a2;
LABEL_212:
                *v35 = *(float16x4_t *)_Q5.f32;
                *v22 = _Q0.i16[0];
                goto LABEL_214;
              }
              *v35 = *(float16x4_t *)_Q5.f32;
            }
          }
LABEL_214:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v247);
          --v248;
        }
        while (v248);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 17:
      v536 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v254 = 2 * v23;
      _Q0.i32[1] = -1;
      while (1)
      {
        v255 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v256 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            *(float *)_Q0.i32 = v256 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v257 = (__n128)v536;
              v258 = (__n128)vmulq_n_f32(v536, v256);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v258);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_Q4.f32[0] <= 0.0)
                  goto LABEL_227;
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.i16[0] = v35->i16[0];
              v258.n128_u16[0] = v35->u16[1];
              v257.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAlightenPDA(*(float16x4_t *)_Q0.i8, v258, v257, a12, _Q4, _Q5, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, *(float16x4_t *)_Q5.f32, *(float *)&_D6);
              _Q0 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v260.i32[0] = result;
              v260.i32[1] = WORD1(result);
              *(int16x4_t *)_Q5.f32 = vmovn_s32(vmovn_hight_s64(v260, _Q0));
              if (v16)
              {
                _Q0.i16[0] = a2;
LABEL_227:
                *v35 = *(float16x4_t *)_Q5.f32;
                *v22 = _Q0.i16[0];
                goto LABEL_229;
              }
              *v35 = *(float16x4_t *)_Q5.f32;
            }
          }
LABEL_229:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v254);
          --v255;
        }
        while (v255);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 18:
      v537 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v261 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v263 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v264 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v264 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v265 = (__n128)v537;
              v266 = (__n128)vmulq_n_f32(v537, v264);
              v267 = vcvt_f16_f32((float32x4_t)v266);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_242;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v266.n128_u16[0] = v35->u16[1];
              v265.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAcolordodgePDA(_Q0, v266, v265, a12, _S4, *(double *)&v267, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v267.i16[0], v267.i16[1], v267.i16[2],
                         v267.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v270.i32[0] = result;
              v270.i32[1] = WORD1(result);
              v267 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v270, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_242:
                *v35 = v267;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_244;
              }
              *v35 = v267;
            }
          }
LABEL_244:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v261);
          --v263;
        }
        while (v263);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 19:
      v538 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v271 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v273 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v274 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v274 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v275 = (__n128)v538;
              v276 = (__n128)vmulq_n_f32(v538, v274);
              v277 = vcvt_f16_f32((float32x4_t)v276);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_257;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v276.n128_u16[0] = v35->u16[1];
              v275.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAcolorburnPDA(_Q0, v276, v275, a12, _S4, *(double *)&v277, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v277.i16[0], v277.i16[1], v277.i16[2],
                         v277.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v280.i32[0] = result;
              v280.i32[1] = WORD1(result);
              v277 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v280, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_257:
                *v35 = v277;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_259;
              }
              *v35 = v277;
            }
          }
LABEL_259:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v271);
          --v273;
        }
        while (v273);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 20:
      v539 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v281 = 2 * v23;
      _Q0.i32[1] = -1;
      while (1)
      {
        v282 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v283 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            *(float *)_Q0.i32 = v283 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v284 = (__n128)v539;
              v285 = (__n128)vmulq_n_f32(v539, v283);
              v286 = (int32x2_t)vcvt_f16_f32((float32x4_t)v285);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_Q4.f32[0] <= 0.0)
                  goto LABEL_272;
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.i16[0] = v35->i16[0];
              v285.n128_u16[0] = v35->u16[1];
              v284.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAsoftlightPDA(*(float16x4_t *)_Q0.i8, v285, v284, a12, *(double *)_Q4.i64, v286, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v286.i32[0], v286.i16[2], v286.i16[3],
                         *(float *)&_D6);
              _Q0 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v288.i32[0] = result;
              v288.i32[1] = WORD1(result);
              v286 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v288, _Q0));
              if (v16)
              {
                _Q0.i16[0] = a2;
LABEL_272:
                *v35 = (float16x4_t)v286;
                *v22 = _Q0.i16[0];
                goto LABEL_274;
              }
              *v35 = (float16x4_t)v286;
            }
          }
LABEL_274:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v281);
          --v282;
        }
        while (v282);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 21:
      v540 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v289 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v291 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v292 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v292 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v293 = (__n128)v540;
              v294 = (__n128)vmulq_n_f32(v540, v292);
              v295 = vcvt_f16_f32((float32x4_t)v294);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_287;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v294.n128_u16[0] = v35->u16[1];
              v293.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAhardlightPDA(_Q0, v294, v293, a12, _S4, *(double *)&v295, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v295.i16[0], v295.i16[1], v295.i16[2],
                         v295.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v298.i32[0] = result;
              v298.i32[1] = WORD1(result);
              v295 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v298, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_287:
                *v35 = v295;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_289;
              }
              *v35 = v295;
            }
          }
LABEL_289:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v289);
          --v291;
        }
        while (v291);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 22:
      v541 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v299 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v301 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v302 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v302 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v303 = (__n128)v541;
              v304 = (__n128)vmulq_n_f32(v541, v302);
              v305 = (int32x2_t)vcvt_f16_f32((float32x4_t)v304);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_Q4.f32[0] <= 0.0)
                  goto LABEL_302;
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v304.n128_u16[0] = v35->u16[1];
              v303.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAdifferencePDA(_Q0, v304, v303, (float16x4_t)a12.n128_u64[0], *(double *)_Q4.i64, v305, *(float16x4_t *)&_D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v305.i16[0], v305.i16[1], v305.i16[2],
                         v305.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v307.i32[0] = result;
              v307.i32[1] = WORD1(result);
              v305 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v307, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_302:
                *v35 = (float16x4_t)v305;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_304;
              }
              *v35 = (float16x4_t)v305;
            }
          }
LABEL_304:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v299);
          --v301;
        }
        while (v301);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 23:
      v542 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v308 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v310 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v311 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v311 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v312 = (__n128)v542;
              v313 = (__n128)vmulq_n_f32(v542, v311);
              v314 = vcvt_f16_f32((float32x4_t)v313);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_Q4.f32[0] <= 0.0)
                  goto LABEL_317;
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v313.n128_u16[0] = v35->u16[1];
              v312.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAexclusionPDA(_Q0, v313, v312, (float16x4_t)a12.n128_u64[0], *(double *)_Q4.i64, v314, _D6, *(int32x2_t *)&a16, result, a2, a3, a4, a5, a6, a7, a8, v314.i16[0], v314.i16[1], v314.i16[2],
                         v314.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v316.i32[0] = result;
              v316.i32[1] = WORD1(result);
              v314 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v316, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_317:
                *v35 = v314;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_319;
              }
              *v35 = v314;
            }
          }
LABEL_319:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v308);
          --v310;
        }
        while (v310);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 24:
      v543 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v317 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v319 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v320 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v320 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v321 = (__n128)v543;
              v322 = (__n128)vmulq_n_f32(v543, v320);
              v323 = vcvt_f16_f32((float32x4_t)v322);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_332;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v322.n128_u16[0] = v35->u16[1];
              v321.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAhuePDA(_Q0, v322, v321, a12, _S4, *(double *)&v323, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v323.i16[0], v323.i16[1], v323.i16[2],
                         v323.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v326.i32[0] = result;
              v326.i32[1] = WORD1(result);
              v323 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v326, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_332:
                *v35 = v323;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_334;
              }
              *v35 = v323;
            }
          }
LABEL_334:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v317);
          --v319;
        }
        while (v319);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 25:
      v544 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v327 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      while (1)
      {
        v329 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v330 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            _Q0.n128_f32[0] = v330 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCVT            S6, H0
            }
            if (*(float *)&_D6 > 0.0)
            {
              v331 = (__n128)v544;
              v332 = (__n128)vmulq_n_f32(v544, v330);
              v333 = vcvt_f16_f32((float32x4_t)v332);
              if (v16)
              {
                _H1 = *v22;
                __asm { FCVT            S4, H1 }
                if (_S4 <= 0.0)
                  goto LABEL_347;
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v35->i16[0];
              v332.n128_u16[0] = v35->u16[1];
              v331.n128_u16[0] = v35->u16[2];
              a12.n128_u16[0] = v35->u16[3];
              result = PDAsaturationPDA(_Q0, v332, v331, a12, _S4, *(double *)&v333, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v333.i16[0], v333.i16[1], v333.i16[2],
                         v333.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
              v336.i32[0] = result;
              v336.i32[1] = WORD1(result);
              v333 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v336, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_347:
                *v35 = v333;
                *v22 = _Q0.n128_u16[0];
                goto LABEL_349;
              }
              *v35 = v333;
            }
          }
LABEL_349:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v327);
          --v329;
        }
        while (v329);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 26:
      v545 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v337 = 2 * v23;
      while (1)
      {
        v338 = v24;
        do
        {
          if (*(_BYTE *)v37)
          {
            v339 = (float)*(unsigned __int8 *)v37 * 0.0039216;
            *(float *)_Q1.i32 = v339 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCVT            S4, H1
            }
            if (_S4 > 0.0)
            {
              v341 = (__n128)v545;
              v342 = (__n128)vmulq_n_f32(v545, v339);
              v342.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v342);
              if (v16)
              {
                _H2 = *v22;
                __asm { FCVT            S5, H2 }
                if (_Q5.f32[0] <= 0.0)
                  goto LABEL_362;
              }
              else
              {
                _Q5.i32[0] = 1.0;
              }
              _Q1.i16[0] = v342.n128_i16[1];
              a12.n128_u16[0] = v342.n128_u16[3];
              v341.n128_u16[0] = v342.n128_u16[2];
              result = PDAluminosityPDA(v342, (__n128)_Q1, v341, a12, _S4, *(double *)_Q5.i64, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v35->i32[0], HIWORD(v35->i32[0]), v35->i32[1],
                         HIWORD(v35->i32[1]),
                         _Q5.f32[0]);
              v344.i32[0] = result;
              v344.i32[1] = WORD1(result);
              _Q1 = vmovn_hight_s64(v344, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0));
              v342.n128_u64[0] = (unint64_t)vmovn_s32(_Q1);
              if (v16)
              {
                _Q1.i16[0] = a2;
LABEL_362:
                *v35 = (float16x4_t)v342.n128_u64[0];
                *v22 = _Q1.i16[0];
                goto LABEL_364;
              }
              *v35 = (float16x4_t)v342.n128_u64[0];
            }
          }
LABEL_364:
          ++v37;
          ++v35;
          v22 = (unsigned __int16 *)((char *)v22 + v337);
          --v338;
        }
        while (v338);
        v37 += v38;
        v35 += v547;
        v22 += v26;
        if (!--v27)
          return result;
      }
    case 27:
      v546 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      v345 = 2 * v23;
      _Q0 = (__n128)xmmword_185004DA0;
      break;
    default:
      return result;
  }
  do
  {
    v347 = v24;
    do
    {
      if (*(_BYTE *)v37)
      {
        v348 = (float)*(unsigned __int8 *)v37 * 0.0039216;
        _Q0.n128_f32[0] = v348 * _S8;
        __asm
        {
          FCVT            H0, S0
          FCVT            S6, H0
        }
        if (*(float *)&_D6 > 0.0)
        {
          v349 = (__n128)v546;
          v350 = (__n128)vmulq_n_f32(v546, v348);
          v351 = vcvt_f16_f32((float32x4_t)v350);
          if (v16)
          {
            _H1 = *v22;
            __asm { FCVT            S4, H1 }
            if (_S4 <= 0.0)
              goto LABEL_377;
          }
          else
          {
            _S4 = 1.0;
          }
          _Q0.n128_u16[0] = v35->i16[0];
          v350.n128_u16[0] = v35->u16[1];
          v349.n128_u16[0] = v35->u16[2];
          a12.n128_u16[0] = v35->u16[3];
          result = PDAluminosityPDA(_Q0, v350, v349, a12, _S4, *(double *)&v351, _D6, a16, result, a2, a3, a4, a5, a6, a7, a8, v351.i16[0], v351.i16[1], v351.i16[2],
                     v351.i16[3],
                     *(float *)&_D6);
          _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_185004DA0);
          v354.i32[0] = result;
          v354.i32[1] = WORD1(result);
          v351 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v354, (int64x2_t)_Q0));
          if (v16)
          {
            _Q0.n128_u16[0] = a2;
LABEL_377:
            *v35 = v351;
            *v22 = _Q0.n128_u16[0];
            goto LABEL_379;
          }
          *v35 = v351;
        }
      }
LABEL_379:
      ++v37;
      ++v35;
      v22 = (unsigned __int16 *)((char *)v22 + v345);
      --v347;
    }
    while (v347);
    v37 += v38;
    v35 += v547;
    v22 += v26;
    --v27;
  }
  while (v27);
  return result;
}

