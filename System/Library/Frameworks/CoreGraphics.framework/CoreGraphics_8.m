uint64_t cmyk64_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  int8x16_t *v44;
  int8x16_t *v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int *v48;
  float v49;
  int v50;
  float32x4_t v51;
  unsigned int v52;
  int v53;
  int v54;
  int64_t v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int8x16_t *v58;
  float32x4_t v59;
  float32x4_t v60;
  float v61;
  float v62;
  unint64_t v63;
  unint64_t v64;
  unsigned int *v65;
  unsigned int *v66;
  float32x4_t v67;
  int8x16_t *v68;
  float32x4_t v69;
  float v70;
  unsigned int *v71;
  _DWORD *v72;
  int64_t v73;
  int8x16_t *v74;
  unsigned int *v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  int8x16_t *v80;
  unint64_t v81;
  unint64_t v82;
  unsigned int *v83;
  unsigned int *v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  float32x4_t v102;
  float v103;

  v14 = *(_QWORD *)(result + 40);
  v15 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v90 = *(_QWORD *)(result + 88);
  v100 = *(_QWORD *)(result + 120);
  v101 = *(_QWORD *)(result + 112);
  v16 = *(_QWORD *)(result + 152) - 16;
  v91 = *(_QWORD *)(result + 144) - 1;
  v17 = *(_DWORD *)(result + 260) - 1;
  v98 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v18 = *(_DWORD *)(result + 256);
  v93 = *(_DWORD *)(result + 28);
  v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  v86 = *(_DWORD *)(result + 188);
  v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  v88 = *(_QWORD *)(result + 72);
  v89 = *(_QWORD *)(result + 64);
  v96 = v14;
  v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      v23 = v90;
      if (a3 <= v90)
      {
        v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        v31 = 0x3FFFFFFF;
        v32 = a3;
        v22 = a4;
        v24 = v89;
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = *(_QWORD *)(result + 224) + v90;
        v28 = v27 - a3 + (v26 >> 1);
        v22 = a4;
        v24 = v89;
        if (v28 < 1)
          goto LABEL_37;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v31 = v86 | v29;
        v32 = v27 - 0x1000000;
        v30 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v88 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      v24 = v89;
      v23 = v90;
      if (v21 < 1)
        goto LABEL_37;
      if (v21 >= v19)
        LODWORD(v25) = 0x3FFFFFFF;
      else
        v25 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v31 = v86 | v25;
      v32 = v20 + 0x1000000;
      v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        v37 = ((unint64_t)a2 >> 26) & 0x3C;
        v36 = a2;
      }
      else
      {
        v38 = *(_QWORD *)(result + 192);
        v39 = *(_QWORD *)(result + 200) + v87;
        v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1)
          goto LABEL_37;
        if (v40 < v38)
          v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v86;
        v36 = v39 - 0x1000000;
        v37 = 28;
      }
    }
    else
    {
      v33 = *(_QWORD *)(result + 192);
      v34 = v24 - *(_QWORD *)(result + 200);
      v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1)
        goto LABEL_37;
      if (v35 < v33)
        v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v86;
      v36 = v34 + 0x1000000;
      v37 = 32;
    }
    if (v31 >= 0x400000)
      break;
LABEL_37:
    v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    v16 += 16;
    *(_BYTE *)++v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50)
      return result;
  }
  v41 = v32 >> 32;
  v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  v44 = *(int8x16_t **)(result + 32);
  v45 = (int8x16_t *)v99;
  if (v99 >= v43)
    v45 = (int8x16_t *)v43;
  if (v45 < v44)
    v45 = *(int8x16_t **)(result + 32);
  if (v14)
  {
    v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    v47 = *(unsigned int **)(result + 40);
    v48 = (unsigned int *)v94;
    v92 = v46;
    if (v94 >= v46)
      v48 = (unsigned int *)v46;
    if (v48 >= v47)
      v47 = v48;
    v49 = COERCE_FLOAT(bswap32(*v47));
  }
  else
  {
    v92 = 0;
    v49 = 1.0;
  }
  v51 = (float32x4_t)vrev32q_s8(*v45);
  if (v15)
  {
    v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    v53 = v52 & 0xF;
    v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      v68 = (int8x16_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68)
        v68 = (int8x16_t *)v99;
      if (v68 >= v44)
        v44 = v68;
      v69 = (float32x4_t)vrev32q_s8(*v44);
      v70 = 1.0;
      if (v14)
      {
        v71 = (unsigned int *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71)
          v71 = (unsigned int *)v94;
        if ((unint64_t)v71 < *(_QWORD *)(result + 40))
          v71 = *(unsigned int **)(result + 40);
        v70 = COERCE_FLOAT(bswap32(*v71));
      }
      v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          v55 = (unint64_t)HIWORD(v52) << 56;
          v56 = (int8x16_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56)
            v57 = v56;
          else
            v57 = (int8x16_t *)v99;
          if (v57 < v44)
            v57 = v44;
          v58 = (int8x16_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58)
            v58 = (int8x16_t *)v99;
          if (v58 >= v44)
            v44 = v58;
          v59 = (float32x4_t)vrev32q_s8(*v57);
          v60 = (float32x4_t)vrev32q_s8(*v44);
          v61 = 1.0;
          v62 = 1.0;
          if (v14)
          {
            v63 = v92 + (v55 >> 54);
            v64 = *(_QWORD *)(result + 40);
            if (v94 >= v63)
              v65 = (unsigned int *)(v92 + (v55 >> 54));
            else
              v65 = (unsigned int *)v94;
            if ((unint64_t)v65 < v64)
              v65 = *(unsigned int **)(result + 40);
            v61 = COERCE_FLOAT(bswap32(*v65));
            v66 = (unsigned int *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66)
              v66 = (unsigned int *)v94;
            if ((unint64_t)v66 < v64)
              v66 = *(unsigned int **)(result + 40);
            v62 = COERCE_FLOAT(bswap32(*v66));
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      v73 = (unint64_t)HIWORD(v52) << 56;
      v74 = (int8x16_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74)
        v74 = (int8x16_t *)v99;
      if (v74 >= v44)
        v44 = v74;
      v69 = (float32x4_t)vrev32q_s8(*v44);
      v70 = 1.0;
      if (v14)
      {
        v75 = (unsigned int *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75)
          v75 = (unsigned int *)v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(unsigned int **)(result + 40);
        v70 = COERCE_FLOAT(bswap32(*v75));
      }
      v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  v76 = 0;
  v16 += 16;
  v85 = v22;
  v77 = v22 - 1;
  a3 += v100;
  v78 = v23 - a3;
  a2 += v101;
  v79 = v87 - a2;
  while (1)
  {
    v102 = v51;
    v103 = v49;
    CMYKF_10639(v16, v102.f32);
    *(_BYTE *)(v91 + 1 + v76) = v31 >> 22;
    v14 = v96;
    result = v97;
    if (v77 == (_DWORD)v76)
      return result;
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      v50 = ~(_DWORD)v76 + v85;
      goto LABEL_38;
    }
    v80 = (int8x16_t *)v99;
    v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    v44 = *(int8x16_t **)(v97 + 32);
    if (v99 >= v43)
      v80 = (int8x16_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    if (v80 < v44)
      v80 = *(int8x16_t **)(v97 + 32);
    if (v96)
    {
      v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      v83 = *(unsigned int **)(v97 + 40);
      v84 = (unsigned int *)v94;
      v92 = v82;
      if (v94 >= v82)
        v84 = (unsigned int *)v82;
      if (v84 >= v83)
        v83 = v84;
      v49 = COERCE_FLOAT(bswap32(*v83));
    }
    else
    {
      v49 = 1.0;
    }
    v51 = (float32x4_t)vrev32q_s8(*v80);
    if (v15)
    {
      v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        v23 = v90;
        v91 += v76 + 1;
        v22 = ~(_DWORD)v76 + v85;
        v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    v16 += 16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    v31 = -1;
  }
}

uint64_t cmyk64_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  float32x4_t *v44;
  float32x4_t *v45;
  unint64_t v46;
  float *v47;
  float *v48;
  float v49;
  int v50;
  float32x4_t v51;
  unsigned int v52;
  int v53;
  int v54;
  int64_t v55;
  float32x4_t *v56;
  float32x4_t *v57;
  float32x4_t *v58;
  float32x4_t v59;
  float32x4_t v60;
  float v61;
  float v62;
  unint64_t v63;
  unint64_t v64;
  float *v65;
  float *v66;
  float32x4_t v67;
  float32x4_t *v68;
  float32x4_t v69;
  float v70;
  float *v71;
  _DWORD *v72;
  int64_t v73;
  float32x4_t *v74;
  float *v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  float32x4_t *v80;
  unint64_t v81;
  unint64_t v82;
  float *v83;
  float *v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  float32x4_t v102;
  float v103;

  v14 = *(_QWORD *)(result + 40);
  v15 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v90 = *(_QWORD *)(result + 88);
  v100 = *(_QWORD *)(result + 120);
  v101 = *(_QWORD *)(result + 112);
  v16 = *(_QWORD *)(result + 152) - 16;
  v91 = *(_QWORD *)(result + 144) - 1;
  v17 = *(_DWORD *)(result + 260) - 1;
  v98 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v18 = *(_DWORD *)(result + 256);
  v93 = *(_DWORD *)(result + 28);
  v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  v86 = *(_DWORD *)(result + 188);
  v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  v88 = *(_QWORD *)(result + 72);
  v89 = *(_QWORD *)(result + 64);
  v96 = v14;
  v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      v23 = v90;
      if (a3 <= v90)
      {
        v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        v31 = 0x3FFFFFFF;
        v32 = a3;
        v22 = a4;
        v24 = v89;
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = *(_QWORD *)(result + 224) + v90;
        v28 = v27 - a3 + (v26 >> 1);
        v22 = a4;
        v24 = v89;
        if (v28 < 1)
          goto LABEL_37;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v31 = v86 | v29;
        v32 = v27 - 0x1000000;
        v30 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v88 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      v24 = v89;
      v23 = v90;
      if (v21 < 1)
        goto LABEL_37;
      if (v21 >= v19)
        LODWORD(v25) = 0x3FFFFFFF;
      else
        v25 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v31 = v86 | v25;
      v32 = v20 + 0x1000000;
      v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        v37 = ((unint64_t)a2 >> 26) & 0x3C;
        v36 = a2;
      }
      else
      {
        v38 = *(_QWORD *)(result + 192);
        v39 = *(_QWORD *)(result + 200) + v87;
        v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1)
          goto LABEL_37;
        if (v40 < v38)
          v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v86;
        v36 = v39 - 0x1000000;
        v37 = 28;
      }
    }
    else
    {
      v33 = *(_QWORD *)(result + 192);
      v34 = v24 - *(_QWORD *)(result + 200);
      v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1)
        goto LABEL_37;
      if (v35 < v33)
        v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v86;
      v36 = v34 + 0x1000000;
      v37 = 32;
    }
    if (v31 >= 0x400000)
      break;
LABEL_37:
    v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    v16 += 16;
    *(_BYTE *)++v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50)
      return result;
  }
  v41 = v32 >> 32;
  v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  v44 = *(float32x4_t **)(result + 32);
  v45 = (float32x4_t *)v99;
  if (v99 >= v43)
    v45 = (float32x4_t *)v43;
  if (v45 < v44)
    v45 = *(float32x4_t **)(result + 32);
  if (v14)
  {
    v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    v47 = *(float **)(result + 40);
    v48 = (float *)v94;
    v92 = v46;
    if (v94 >= v46)
      v48 = (float *)v46;
    if (v48 >= v47)
      v47 = v48;
    v49 = *v47;
  }
  else
  {
    v92 = 0;
    v49 = 1.0;
  }
  v51 = *v45;
  if (v15)
  {
    v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    v53 = v52 & 0xF;
    v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      v68 = (float32x4_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68)
        v68 = (float32x4_t *)v99;
      if (v68 >= v44)
        v44 = v68;
      v69 = *v44;
      v70 = 1.0;
      if (v14)
      {
        v71 = (float *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71)
          v71 = (float *)v94;
        if ((unint64_t)v71 < *(_QWORD *)(result + 40))
          v71 = *(float **)(result + 40);
        v70 = *v71;
      }
      v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          v55 = (unint64_t)HIWORD(v52) << 56;
          v56 = (float32x4_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56)
            v57 = v56;
          else
            v57 = (float32x4_t *)v99;
          if (v57 < v44)
            v57 = v44;
          v58 = (float32x4_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58)
            v58 = (float32x4_t *)v99;
          if (v58 >= v44)
            v44 = v58;
          v59 = *v57;
          v60 = *v44;
          v61 = 1.0;
          v62 = 1.0;
          if (v14)
          {
            v63 = v92 + (v55 >> 54);
            v64 = *(_QWORD *)(result + 40);
            if (v94 >= v63)
              v65 = (float *)(v92 + (v55 >> 54));
            else
              v65 = (float *)v94;
            if ((unint64_t)v65 < v64)
              v65 = *(float **)(result + 40);
            v61 = *v65;
            v66 = (float *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66)
              v66 = (float *)v94;
            if ((unint64_t)v66 < v64)
              v66 = *(float **)(result + 40);
            v62 = *v66;
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      v73 = (unint64_t)HIWORD(v52) << 56;
      v74 = (float32x4_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74)
        v74 = (float32x4_t *)v99;
      if (v74 >= v44)
        v44 = v74;
      v69 = *v44;
      v70 = 1.0;
      if (v14)
      {
        v75 = (float *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75)
          v75 = (float *)v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(float **)(result + 40);
        v70 = *v75;
      }
      v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  v76 = 0;
  v16 += 16;
  v85 = v22;
  v77 = v22 - 1;
  a3 += v100;
  v78 = v23 - a3;
  a2 += v101;
  v79 = v87 - a2;
  while (1)
  {
    v102 = v51;
    v103 = v49;
    CMYKF_10639(v16, v102.f32);
    *(_BYTE *)(v91 + 1 + v76) = v31 >> 22;
    v14 = v96;
    result = v97;
    if (v77 == (_DWORD)v76)
      return result;
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      v50 = ~(_DWORD)v76 + v85;
      goto LABEL_38;
    }
    v80 = (float32x4_t *)v99;
    v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    v44 = *(float32x4_t **)(v97 + 32);
    if (v99 >= v43)
      v80 = (float32x4_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    if (v80 < v44)
      v80 = *(float32x4_t **)(v97 + 32);
    if (v96)
    {
      v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      v83 = *(float **)(v97 + 40);
      v84 = (float *)v94;
      v92 = v82;
      if (v94 >= v82)
        v84 = (float *)v82;
      if (v84 >= v83)
        v83 = v84;
      v49 = *v83;
    }
    else
    {
      v49 = 1.0;
    }
    v51 = *v80;
    if (v15)
    {
      v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        v23 = v90;
        v91 += v76 + 1;
        v22 = ~(_DWORD)v76 + v85;
        v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    v16 += 16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    v31 = -1;
  }
}

uint64_t CMYKF_10639(uint64_t result, float *a2)
{
  float v2;
  float v3;
  float v4;
  uint64_t v5;
  int v6;
  float v7;
  int v8;
  float v9;
  int v10;
  uint64_t v11;

  v2 = a2[4];
  if (v2 <= 0.0)
  {
    LOWORD(v5) = 0;
    *(_QWORD *)result = 0;
  }
  else
  {
    v4 = *a2;
    v3 = a2[1];
    LODWORD(v5) = (int)(float)((float)(v2 * 65535.0) + 0.5);
    if (v2 <= 1.0)
      v5 = v5;
    else
      v5 = 0xFFFFLL;
    if (v2 > 1.0)
      v2 = 1.0;
    LOWORD(v6) = v5;
    if (v4 <= v2)
    {
      if (v4 >= 0.0)
        v6 = (int)(float)((float)(v4 * 65535.0) + 0.5);
      else
        LOWORD(v6) = 0;
    }
    v7 = a2[2];
    v8 = v5;
    if (v3 <= v2)
    {
      if (v3 >= 0.0)
        v8 = (int)(float)((float)(v3 * 65535.0) + 0.5);
      else
        v8 = 0;
    }
    v9 = a2[3];
    LOWORD(v10) = v5;
    if (v7 <= v2)
    {
      if (v7 >= 0.0)
        v10 = (int)(float)((float)(v7 * 65535.0) + 0.5);
      else
        LOWORD(v10) = 0;
    }
    v11 = v5;
    if (v9 <= v2)
    {
      if (v9 >= 0.0)
        v11 = (int)(float)((float)(v9 * 65535.0) + 0.5);
      else
        v11 = 0;
    }
    *(_QWORD *)result = ((unint64_t)(unsigned __int16)v10 << 32) | (v11 << 48) | (v8 << 16) | (unint64_t)(unsigned __int16)v6;
  }
  *(_WORD *)(result + 8) = v5;
  return result;
}

_DWORD *cmyk64_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 v13;

  v11 = PIXELCONSTANT_10663(*(float **)(*(_QWORD *)a1 + 64), a4, a5, a6, a7, a8, a9);
  v13 = v12;
  if (a2 && a3 > 0xB || (a2 = malloc_type_malloc(0x3CuLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_185004D80;
    a2[6] = 0;
    *((_QWORD *)a2 + 2) = 1;
    *((_QWORD *)a2 + 6) = v11;
    *((_QWORD *)a2 + 4) = a2 + 12;
    if (v13 > 0xFEu)
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    else
    {
      a2[14] = v13 | (v13 << 16);
      *((_QWORD *)a2 + 5) = a2 + 14;
    }
  }
  return a2;
}

uint64_t cmyk64_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  int8x8_t v4;
  __int16 *v5;
  uint64_t v6;
  int v7;
  uint64_t v9;
  unint64_t *v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint16x4_t *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  size_t v26;
  _BYTE *v27;
  _BYTE *v28;
  int32x2_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  int8x8_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  unint64_t *v42;
  unint64_t *v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  __int16 *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t *v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  unsigned __int16 *v79;
  unsigned int v80;
  int8x8_t *v81;
  unint64_t v82;
  int v83;
  unsigned int v84;
  unint64_t *v85;
  unint64_t v86;
  int32x2_t v87;
  int32x2_t v88;
  int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  int32x2_t v93;
  uint32x2_t v94;
  uint32x2_t v95;
  int32x2_t v96;
  int32x2_t v97;
  int v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  int32x2_t v102;
  uint32x2_t v103;
  uint32x2_t v104;
  int v105;
  int v106;
  unint64_t v107;
  int v108;
  int v109;
  int32x2_t v110;
  int v111;
  int v112;
  int v113;
  uint32x2_t v114;
  int32x2_t v115;
  uint32x2_t v116;
  int32x2_t v117;
  int v118;
  uint64_t v119;
  int v120;
  int v121;
  uint32x2_t v122;
  int32x2_t v123;
  uint32x2_t v124;
  int v125;
  int v126;
  unint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  int v131;
  uint64_t v132;
  int v133;
  unint64_t v134;
  int v135;
  unint64_t v136;
  int v137;
  uint64_t v138;
  int v139;
  unint64_t v140;
  int v141;
  unint64_t v142;
  int v143;
  __int16 v144;
  int v145;
  __int16 v146;
  int v147;
  __int16 v148;
  int v149;
  __int16 v150;
  int v151;
  __int16 v152;
  int v153;
  __int16 v154;
  int v155;
  __int16 v156;
  int v157;
  __int16 v158;
  int v159;
  __int16 v160;
  int v161;
  __int16 v162;
  int v163;
  __int16 v164;
  int v165;
  __int16 v166;
  int v167;
  __int16 v168;
  int v169;
  __int16 v170;
  int v171;
  __int16 v172;
  int v173;
  int *v174;
  uint64_t v175;
  uint64_t v176;
  unsigned int v177;
  int8x8_t *v178;
  unint64_t v179;
  int v180;
  unsigned int v181;
  unint64_t *v182;
  unint64_t v183;
  int v184;
  int32x2_t v185;
  int32x2_t v186;
  int32x2_t v187;
  int8x8_t v188;
  uint32x2_t v189;
  int32x2_t v190;
  int32x2_t v191;
  uint32x2_t v192;
  int v193;
  int32x2_t v194;
  int32x2_t v195;
  int32x2_t v196;
  int8x8_t v197;
  uint32x2_t v198;
  int32x2_t v199;
  int32x2_t v200;
  uint32x2_t v201;
  uint64_t v202;
  int8x8_t *v203;
  unsigned int v204;
  uint64_t v205;
  char *v206;
  uint64_t v207;
  int v208;
  uint64_t v209;
  uint64_t v210;
  int v211;
  uint64_t v212;
  uint64_t v213;
  int v214;
  int v215;
  unint64_t v216;
  uint64_t *v217;
  uint64_t v218;
  uint64_t *v219;
  BOOL v220;
  uint64_t v221;
  uint64_t *v222;
  unint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  int v227;
  uint64_t v228;
  int v229;
  int v230;
  int v231;
  unsigned int v232;
  int32x2_t v233;
  uint32x2_t v234;
  int32x2_t v235;
  uint32x2_t v236;
  uint64_t *v237;
  uint64_t v238;
  uint64_t *v239;
  BOOL v240;
  uint64_t v241;
  unint64_t v242;
  uint64_t v243;
  int v244;
  uint64_t v245;
  int v246;
  unsigned int v247;
  unsigned int v248;
  int v249;
  int32x2_t v250;
  uint32x2_t v251;
  int32x2_t v252;
  uint32x2_t v253;
  uint64_t *v254;
  uint64_t v255;
  uint64_t *v256;
  BOOL v257;
  uint64_t v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  int v262;
  uint64_t v263;
  int v264;
  uint64_t v265;
  uint64_t *v266;
  uint64_t v267;
  uint64_t *v268;
  BOOL v269;
  uint64_t v270;
  uint64_t *v271;
  unint64_t v272;
  uint64_t v273;
  unint64_t v274;
  uint64_t v275;
  int v276;
  uint64_t v277;
  __int16 v278;
  int v279;
  uint64_t *v280;
  uint64_t v281;
  uint64_t *v282;
  BOOL v283;
  uint64_t v284;
  uint64_t *v285;
  unint64_t v286;
  uint64_t v287;
  int v288;
  uint64_t v289;
  int v290;
  int v291;
  int v292;
  unsigned int v293;
  int32x2_t v294;
  uint32x2_t v295;
  int32x2_t v296;
  uint32x2_t v297;
  uint64_t *v298;
  uint64_t v299;
  uint64_t *v300;
  BOOL v301;
  uint64_t v302;
  unint64_t v303;
  uint64_t v304;
  int v305;
  uint64_t v306;
  int v307;
  unsigned int v308;
  int v309;
  int v310;
  int32x2_t v311;
  uint32x2_t v312;
  int32x2_t v313;
  uint32x2_t v314;
  uint64_t *v315;
  uint64_t v316;
  uint64_t *v317;
  BOOL v318;
  uint64_t v319;
  unint64_t v320;
  uint64_t v321;
  uint64_t v322;
  int v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  int v327;
  int v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t *v332;
  uint64_t v333;
  uint64_t *v334;
  BOOL v335;
  uint64_t v336;
  uint64_t *v337;
  unint64_t v338;
  uint64_t v339;
  uint64_t v340;
  int v341;
  uint64_t v342;
  uint64_t v343;
  int v344;
  __int16 *v345;
  int v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t *v349;
  uint64_t v350;
  uint64_t *v351;
  BOOL v352;
  uint64_t v353;
  uint64_t *v354;
  unint64_t v355;
  uint64_t v356;
  uint64_t v357;
  int v358;
  uint64_t v359;
  uint64_t v360;
  unint64_t v361;
  int v362;
  uint64_t *v363;
  uint64_t v364;
  uint64_t *v365;
  BOOL v366;
  uint64_t v367;
  uint64_t *v368;
  unint64_t v369;
  uint64_t v370;
  uint64_t v371;
  int v372;
  uint64_t v373;
  uint64_t v374;
  int v375;
  unint64_t v376;
  int v377;
  uint64_t *v378;
  uint64_t v379;
  uint64_t *v380;
  BOOL v381;
  uint64_t v382;
  uint64_t *v383;
  unint64_t v384;
  uint64_t v385;
  unint64_t v386;
  uint64_t v387;
  int v388;
  uint64_t v389;
  uint64_t v390;
  int v391;
  unint64_t v392;
  unsigned int v393;
  unint64_t v394;
  __int16 v395;
  unint64_t v396;
  uint64_t *v397;
  uint64_t v398;
  uint64_t *v399;
  BOOL v400;
  uint64_t v401;
  uint64_t *v402;
  unint64_t v403;
  uint64_t v404;
  unint64_t v405;
  uint64_t v406;
  int v407;
  uint64_t v408;
  uint64_t v409;
  int v410;
  unint64_t v411;
  unsigned int v412;
  unint64_t v413;
  __int16 v414;
  unint64_t v415;
  uint64_t *v416;
  uint64_t v417;
  uint64_t *v418;
  BOOL v419;
  uint64_t v420;
  uint64_t *v421;
  unint64_t v422;
  uint64_t v423;
  unint64_t v424;
  uint64_t v425;
  int v426;
  uint64_t v427;
  uint64_t v428;
  int v429;
  unint64_t v430;
  unsigned int v431;
  unint64_t v432;
  __int16 v433;
  unint64_t v434;
  uint64_t *v435;
  uint64_t v436;
  uint64_t *v437;
  BOOL v438;
  uint64_t v439;
  uint64_t *v440;
  unint64_t v441;
  uint64_t v442;
  unint64_t v443;
  uint64_t v444;
  int v445;
  uint64_t v446;
  uint64_t v447;
  int v448;
  unint64_t v449;
  unsigned int v450;
  unint64_t v451;
  __int16 v452;
  unint64_t v453;
  uint64_t *v454;
  uint64_t v455;
  uint64_t *v456;
  BOOL v457;
  uint64_t v458;
  uint64_t *v459;
  unint64_t v460;
  uint64_t v461;
  unint64_t v462;
  uint64_t v463;
  int v464;
  uint64_t v465;
  uint64_t v466;
  int v467;
  unint64_t v468;
  unsigned int v469;
  unint64_t v470;
  __int16 v471;
  unint64_t v472;
  uint64_t *v473;
  uint64_t v474;
  uint64_t *v475;
  BOOL v476;
  uint64_t v477;
  uint64_t *v478;
  unint64_t v479;
  uint64_t v480;
  unint64_t v481;
  uint64_t v482;
  int v483;
  uint64_t v484;
  uint64_t v485;
  int v486;
  unint64_t v487;
  unsigned int v488;
  unint64_t v489;
  __int16 v490;
  unint64_t v491;
  uint64_t *v492;
  uint64_t v493;
  uint64_t *v494;
  BOOL v495;
  uint64_t v496;
  uint64_t *v497;
  unint64_t v498;
  uint64_t v499;
  unint64_t v500;
  uint64_t v501;
  int v502;
  uint64_t v503;
  uint64_t v504;
  int v505;
  unint64_t v506;
  unsigned int v507;
  unint64_t v508;
  __int16 v509;
  unint64_t v510;
  uint64_t *v511;
  uint64_t v512;
  uint64_t *v513;
  BOOL v514;
  uint64_t v515;
  uint64_t *v516;
  unint64_t v517;
  uint64_t v518;
  unint64_t v519;
  uint64_t v520;
  int v521;
  uint64_t v522;
  uint64_t v523;
  int v524;
  unint64_t v525;
  unsigned int v526;
  unint64_t v527;
  __int16 v528;
  unint64_t v529;
  uint64_t *v530;
  uint64_t v531;
  uint64_t *v532;
  BOOL v533;
  uint64_t v534;
  uint64_t *v535;
  unint64_t v536;
  uint64_t v537;
  unint64_t v538;
  uint64_t v539;
  int v540;
  uint64_t v541;
  uint64_t v542;
  int v543;
  unint64_t v544;
  unsigned int v545;
  unint64_t v546;
  __int16 v547;
  unint64_t v548;
  uint64_t *v549;
  uint64_t v550;
  uint64_t *v551;
  BOOL v552;
  uint64_t v553;
  uint64_t *v554;
  unint64_t v555;
  uint64_t v556;
  unint64_t v557;
  uint64_t v558;
  int v559;
  uint64_t v560;
  uint64_t v561;
  int v562;
  unint64_t v563;
  unsigned int v564;
  unint64_t v565;
  __int16 v566;
  unint64_t v567;
  uint64_t *v568;
  uint64_t v569;
  uint64_t *v570;
  BOOL v571;
  uint64_t v572;
  uint64_t *v573;
  unint64_t v574;
  uint64_t v575;
  unint64_t v576;
  uint64_t v577;
  int v578;
  uint64_t v579;
  uint64_t v580;
  int v581;
  unint64_t v582;
  unsigned int v583;
  unint64_t v584;
  __int16 v585;
  unint64_t v586;
  uint64_t *v587;
  uint64_t v588;
  uint64_t *v589;
  BOOL v590;
  uint64_t v591;
  uint64_t *v592;
  unint64_t v593;
  uint64_t v594;
  unint64_t v595;
  uint64_t v596;
  int v597;
  uint64_t v598;
  uint64_t v599;
  int v600;
  unint64_t v601;
  unsigned int v602;
  unint64_t v603;
  __int16 v604;
  unint64_t v605;
  uint64_t *v606;
  uint64_t v607;
  uint64_t *v608;
  BOOL v609;
  uint64_t v610;
  uint64_t *v611;
  unint64_t v612;
  uint64_t v613;
  unint64_t v614;
  uint64_t v615;
  int v616;
  uint64_t v617;
  uint64_t v618;
  int v619;
  unint64_t v620;
  unsigned int v621;
  unint64_t v622;
  __int16 v623;
  unint64_t v624;
  uint64_t *v625;
  uint64_t v626;
  uint64_t *v627;
  BOOL v628;
  uint64_t v629;
  uint64_t *v630;
  unint64_t v631;
  uint64_t v632;
  unint64_t v633;
  uint64_t v634;
  int v635;
  uint64_t v636;
  uint64_t v637;
  unint64_t v638;
  unsigned int v639;
  unint64_t v640;
  unint64_t v641;
  uint64_t *v642;
  uint64_t v643;
  uint64_t *v644;
  BOOL v645;
  uint64_t v646;
  uint64_t *v647;
  unint64_t v648;
  uint64_t v649;
  unint64_t v650;
  uint64_t v651;
  int v652;
  uint64_t v653;
  uint64_t v654;
  int v655;
  unint64_t v656;
  unsigned int v657;
  unint64_t v658;
  __int16 v659;
  unint64_t v660;
  uint64_t *v661;
  uint64_t v662;
  uint64_t *v663;
  BOOL v664;
  uint64_t v665;
  uint64_t *v666;
  unint64_t v667;
  uint64_t v668;
  int v669;
  int v670;
  unint64_t v671;
  uint64_t *v672;
  uint64_t v673;
  uint64_t *v674;
  BOOL v675;
  uint64_t v676;
  uint64_t *v677;
  unint64_t v678;
  uint64_t v679;
  int v680;
  uint64_t v681;
  int v682;
  int v683;
  int32x2_t v684;
  int32x2_t v685;
  int32x2_t v686;
  int32x2_t v687;
  uint32x2_t v688;
  int32x2_t v689;
  uint32x2_t v690;
  uint32x2_t v691;
  int32x2_t v692;
  int8x8_t v693;
  uint64_t *v694;
  uint64_t v695;
  uint64_t *v696;
  BOOL v697;
  uint64_t v698;
  unint64_t v699;
  uint64_t v700;
  int v701;
  int v702;
  int v703;
  int32x2_t v704;
  int32x2_t v705;
  int32x2_t v706;
  int32x2_t v707;
  uint32x2_t v708;
  int32x2_t v709;
  uint32x2_t v710;
  uint32x2_t v711;
  int32x2_t v712;
  int8x8_t v713;
  uint64_t *v714;
  uint64_t v715;
  uint64_t *v716;
  BOOL v717;
  uint64_t v718;
  unint64_t v719;
  uint64_t v720;
  int v721;
  int v722;
  unsigned int v723;
  int32x2_t v724;
  int32x2_t v725;
  int32x2_t v726;
  int32x2_t v727;
  uint32x2_t v728;
  int32x2_t v729;
  uint32x2_t v730;
  uint32x2_t v731;
  int32x2_t v732;
  int8x8_t v733;
  uint64_t *v734;
  uint64_t v735;
  uint64_t *v736;
  BOOL v737;
  uint64_t v738;
  unint64_t v739;
  uint64_t v740;
  int v741;
  uint64_t v742;
  int v743;
  unint64_t v744;
  int v745;
  uint64_t *v746;
  uint64_t v747;
  uint64_t *v748;
  BOOL v749;
  uint64_t v750;
  uint64_t *v751;
  unint64_t v752;
  uint64_t v753;
  int v754;
  int v755;
  unint64_t v756;
  uint64_t *v757;
  uint64_t v758;
  uint64_t *v759;
  BOOL v760;
  uint64_t v761;
  uint64_t *v762;
  unint64_t v763;
  uint64_t v764;
  int v765;
  int v766;
  unint64_t v767;
  unint64_t v768;
  int v769;
  int v770;
  unint64_t v771;
  uint64_t v772;
  unint64_t v773;
  uint8x8_t v774;
  int v775;
  uint64_t v776;
  uint64_t v777;
  int v778;
  int v779;
  uint64_t *v780;
  uint64_t v781;
  uint64_t *v782;
  BOOL v783;
  uint64_t v784;
  unint64_t v785;
  uint64_t v786;
  uint64_t v787;
  int v788;
  int v789;
  uint64_t *v790;
  uint64_t v791;
  uint64_t *v792;
  BOOL v793;
  uint64_t v794;
  unint64_t v795;
  uint64_t v796;
  int v797;
  int v798;
  uint64_t *v799;
  uint64_t v800;
  uint64_t *v801;
  BOOL v802;
  uint64_t v803;
  unint64_t v804;
  uint64_t v805;
  int v806;
  uint64_t v807;
  uint64_t v808;
  char *v809;
  uint64_t v810;
  unint64_t v811;
  unsigned int v812;
  int v813;
  uint64_t v814;
  __int16 *v815;
  uint64_t v816;
  char *v817;
  char *v818;
  uint64_t v819;
  uint64_t v820;
  char *v821;
  uint64_t v822;
  int v823;
  int v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  unint64_t v869;
  unint64_t v870;
  char *v871;
  int v872;
  unsigned __int16 *v873;
  uint64_t v874;
  int v875;
  int v876;
  uint64_t v877;
  unint64_t v878;
  int v879;
  int v880;
  int v881;
  int v882;
  int v883;
  int v884;
  int v885;
  int v886;
  int v887;
  int v888;
  int v889;
  int v890;
  int v891;
  int v892;
  int v893;
  int v894;
  int v895;
  int v896;
  int v897;
  int v898;
  int v899;
  int v900;
  int v901;
  unint64_t v902;
  unsigned int v903;
  unsigned int v904;
  unint64_t v905;
  int v906;
  unint64_t v907;
  unint64_t v908;
  unint64_t v909;
  unsigned int v910;
  unint64_t v911;
  int8x8_t *v912;
  uint64_t *v913;
  char *v914;
  __int16 *v915;
  int v916;
  int v917;
  unint64_t v918;
  uint64_t v919;
  unint64_t v920;
  unint64_t v921;
  __int16 *v922;
  unint64_t v923;
  uint64_t v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  uint64_t v928;
  uint64_t v929;
  uint64_t v930;
  uint64_t v931;
  uint64_t v932;
  uint64_t v933;
  uint64_t v934;
  uint64_t v935;
  uint64_t v936;
  uint64_t v937;
  uint64_t v938;
  uint64_t v939;
  uint64_t v940;
  int v941;
  uint64_t v942;
  uint64_t v943;
  uint64_t v944;
  int v945;
  int v946;
  uint64_t *v947;
  unint64_t v948;
  unint64_t v949;
  int8x8_t *v950;
  uint64_t v951;
  int v952[4];
  __int128 v953;
  __int128 v954;
  __int128 v955;
  __int128 v956;
  __int128 v957;
  __int128 v958;
  __int128 v959;
  __int128 v960;
  __int128 v961;
  _DWORD v962[1024];
  uint64_t v963;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v963 = *MEMORY[0x1E0C80C00];
  v5 = *(__int16 **)(v3 + 96);
  v6 = *(_QWORD *)(v3 + 48);
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v5 == 0)
                 + 4 * (v6 == 0));
  if (v7 > 27)
    return 0xFFFFFFFFLL;
  v9 = v3;
  v10 = (unint64_t *)*(unsigned int *)(v3 + 4);
  v11 = (_DWORD)v10 - 1;
  if ((int)v10 < 1)
    return 0;
  v12 = *(_DWORD *)(v3 + 8);
  v13 = (v12 - 1);
  if (v12 < 1)
    return 0;
  v14 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v14)
  {
    v16 = *(_DWORD *)v3 & 0xFF00;
    v872 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                     + 16 * *(_DWORD *)v3
                     + 8 * (v5 == 0)
                     + 4 * (v6 == 0));
    v867 = v3;
    if (v16 == 1024)
    {
      v962[0] = *(_DWORD *)(v3 + 4);
      v952[0] = v12;
      if (v5)
        v17 = (unsigned __int16)*v5;
      else
        v17 = 0xFFFF;
      v29 = **(int32x2_t **)(v3 + 88);
      v30 = (unint64_t)*(int *)(v3 + 28) >> 3;
      v32 = *(int *)(v3 + 12);
      v31 = *(int *)(v3 + 16);
      if (v6)
      {
        v918 = (unint64_t)*(int *)(v3 + 32) >> 1;
        v914 = (char *)(v6 + 2 * (v32 + v918 * v31));
        v910 = 1;
      }
      else
      {
        v918 = 0;
        v910 = 0;
        v914 = 0;
      }
      v38 = (int8x8_t *)(*(_QWORD *)(v3 + 40) + 8 * (v32 + v31 * v30));
      v912 = v38;
      v908 = (unint64_t)*(int *)(v3 + 28) >> 3;
      if (!v14)
      {
        v942 = 0;
        if (v6)
          v42 = v10;
        else
          v42 = 0;
        v949 = v918 - (_QWORD)v42;
        v43 = v10;
        v41 = v914;
        goto LABEL_72;
      }
      shape_enum_clip_alloc(v2, v3, (int *)v14, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), (int)v10, v12);
      v40 = v39;
      v949 = v918;
      v41 = v914;
      if (v39)
      {
        while (shape_enum_clip_next(v40, (int *)&v951 + 1, &v951, v962, v952))
        {
          v942 = v40;
          v38 += v30 * (int)v951 + SHIDWORD(v951);
          v43 = (unint64_t *)v962[0];
          v64 = v949;
          if (v6)
            v64 = v918 - v962[0];
          v949 = v64;
          if (v6)
            v41 = &v914[2 * v918 * (int)v951 + 2 * SHIDWORD(v951)];
          LODWORD(v10) = v962[0];
LABEL_72:
          v948 = v30 - (_QWORD)v43;
          v916 = (int)v10;
          switch(v7)
          {
            case 0:
              v65 = v948 + (int)v10;
              v66 = (int)v10;
              v67 = v952[0];
              v68 = v952[0] - 1;
              v69 = (v65 * v68) & (v65 >> 63);
              if (v65 < 0)
                v65 = -v65;
              CGBlt_fillBytes(8 * v66, v952[0], 0, (char *)&v38[v69], 8 * v65);
              if (v6)
              {
                v70 = v949 + v66;
                v71 = (v70 * v68) & (v70 >> 63);
                if (v70 < 0)
                  v70 = -v70;
                v41 += 2 * v71;
                v949 = v70;
                CGBlt_fillBytes(2 * v66, v67, 0, v41, 2 * v70);
              }
              goto LABEL_341;
            case 1:
              v72 = (int)v10;
              v73 = v948 + (int)v10;
              if (v73 < 0)
              {
                v38 += v73 * (v952[0] - 1);
                v73 = -v73;
              }
              v74 = *(_QWORD *)(v867 + 88);
              if (v74)
              {
                v75 = 8 * (_DWORD)v10;
                v76 = v952[0];
                CGSFillDRAM64(v38, 8 * v73, v75, v952[0], v74, 8, 8, 1, 0, 0);
              }
              else
              {
                v173 = 8 * (_DWORD)v10;
                v76 = v952[0];
                CGBlt_fillBytes(v173, v952[0], 0, (char *)v38, 8 * v73);
              }
              v38 = v912;
              if (v6)
              {
                v174 = *(int **)(v867 + 96);
                if (!v174)
                  v174 = (int *)&PIXELALPHAPLANARCONSTANT_15938;
                v175 = v949 + v72;
                if ((uint64_t)(v949 + v72) >= 0)
                  v176 = v949 + v72;
                else
                  v176 = -v175;
                v41 += 2 * (((v949 + v72) * (int)(v76 - 1)) & (v175 >> 63));
                v949 = v176;
                CGBlt_fillBytes(2 * v916, v76, *v174, v41, 2 * v176);
              }
              goto LABEL_343;
            case 2:
              v77 = v10 >> 2;
              v906 = v10 & 3;
              v78 = v952[0];
              if (v6)
              {
                v903 = v77 + 1;
                do
                {
                  v945 = v78;
                  if ((int)v10 < 4)
                  {
                    v83 = (int)v10;
                  }
                  else
                  {
                    v79 = (unsigned __int16 *)(v41 + 4);
                    v80 = v903;
                    do
                    {
                      cmyk64_DAplusDAM(v38, v79 - 2, *(_QWORD *)&v29, v17, (unint64_t)*v38, *(v79 - 2), (unsigned __int16)~(_WORD)v17);
                      cmyk64_DAplusDAM(&v38[1], v79 - 1, *(_QWORD *)&v29, v17, *(_QWORD *)&v38[1], *(v79 - 1), (unsigned __int16)~(_WORD)v17);
                      cmyk64_DAplusDAM(&v38[2], v79, *(_QWORD *)&v29, v17, *(_QWORD *)&v38[2], *v79, (unsigned __int16)~(_WORD)v17);
                      v82 = (unint64_t)v38[3];
                      v81 = v38 + 3;
                      cmyk64_DAplusDAM(v81, v79 + 1, *(_QWORD *)&v29, v17, v82, v79[1], (unsigned __int16)~(_WORD)v17);
                      v38 = v81 + 1;
                      v79 += 4 * v910;
                      --v80;
                    }
                    while (v80 > 1);
                    v41 = (char *)(v79 - 2);
                    v83 = v906;
                  }
                  if (v83 < 1)
                  {
                    v85 = (unint64_t *)v38;
                  }
                  else
                  {
                    v84 = v83 + 1;
                    v85 = (unint64_t *)v38;
                    do
                    {
                      v86 = *v85++;
                      cmyk64_DAplusDAM(v38, v41, *(_QWORD *)&v29, v17, v86, *(unsigned __int16 *)v41, (unsigned __int16)~(_WORD)v17);
                      --v84;
                      v41 += 2 * v910;
                      v38 = (int8x8_t *)v85;
                    }
                    while (v84 > 1);
                  }
                  v38 = (int8x8_t *)&v85[v948];
                  v41 += 2 * v949;
                  v78 = v945 - 1;
                  LODWORD(v10) = v916;
                }
                while (v945 != 1);
              }
              else
              {
                v904 = v77 + 1;
                do
                {
                  v946 = v78;
                  if ((int)v10 < 4)
                  {
                    v180 = (int)v10;
                  }
                  else
                  {
                    v177 = v904;
                    do
                    {
                      cmyk64_DplusDM(v38, *(_QWORD *)&v29, (unint64_t)*v38, (unsigned __int16)~(_WORD)v17);
                      cmyk64_DplusDM(&v38[1], *(_QWORD *)&v29, *(_QWORD *)&v38[1], (unsigned __int16)~(_WORD)v17);
                      cmyk64_DplusDM(&v38[2], *(_QWORD *)&v29, *(_QWORD *)&v38[2], (unsigned __int16)~(_WORD)v17);
                      v179 = (unint64_t)v38[3];
                      v178 = v38 + 3;
                      cmyk64_DplusDM(v178, *(_QWORD *)&v29, v179, (unsigned __int16)~(_WORD)v17);
                      v38 = v178 + 1;
                      v41 += 8 * v910;
                      --v177;
                    }
                    while (v177 > 1);
                    v180 = v906;
                  }
                  if (v180 < 1)
                  {
                    v182 = (unint64_t *)v38;
                  }
                  else
                  {
                    v181 = v180 + 1;
                    v182 = (unint64_t *)v38;
                    do
                    {
                      v183 = *v182++;
                      cmyk64_DplusDM(v38, *(_QWORD *)&v29, v183, (unsigned __int16)~(_WORD)v17);
                      --v181;
                      v41 += 2 * v910;
                      v38 = (int8x8_t *)v182;
                    }
                    while (v181 > 1);
                  }
                  v38 = (int8x8_t *)&v182[v948];
                  v41 += 2 * v949;
                  v78 = v946 - 1;
                  LODWORD(v10) = v916;
                }
                while (v946 != 1);
              }
              goto LABEL_340;
            case 3:
              v87.i32[0] = HIWORD(v29.i32[0]);
              v87.i32[1] = HIWORD(*(_QWORD *)&v29);
              v88 = (int32x2_t)vand_s8((int8x8_t)v29, (int8x8_t)0xFFFF0000FFFFLL);
              v89 = v952[0];
              do
              {
                v90 = (int)v10;
                do
                {
                  v91 = *(unsigned __int16 *)v41;
                  if (v91 == 0xFFFF)
                  {
                    *v38 = (int8x8_t)v29;
                    LOWORD(v91) = v17;
                  }
                  else if (*(_WORD *)v41)
                  {
                    v92 = v91 ^ 0xFFFF;
                    v93 = vdup_n_s32(v92);
                    v94 = (uint32x2_t)vmul_s32(v88, v93);
                    v95 = (uint32x2_t)vmul_s32(v87, v93);
                    *v38 = (int8x8_t)vsli_n_s32(vsub_s32(v29, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v94, v94, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v87, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v95, v95, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                    v91 = v17 - ((v92 * v17 + ((v92 * v17) >> 16) + 1) >> 16);
                  }
                  else
                  {
                    *v38 = 0;
                  }
                  *(_WORD *)v41 = v91;
                  ++v38;
                  v41 += 2 * v910;
                  --v90;
                }
                while (v90);
                v38 += v948;
                v41 += 2 * v949;
                --v89;
              }
              while (v89);
              goto LABEL_352;
            case 4:
              v96 = (int32x2_t)vand_s8((int8x8_t)v29, (int8x8_t)0xFFFF0000FFFFLL);
              v97.i32[0] = HIWORD(v29.i32[0]);
              v97.i32[1] = HIWORD(*(_QWORD *)&v29);
              v98 = v952[0];
              do
              {
                v99 = (int)v10;
                do
                {
                  v100 = *(unsigned __int16 *)v41;
                  if (*(_WORD *)v41)
                  {
                    if (v100 != 0xFFFF)
                    {
                      v102 = vdup_n_s32(v100);
                      v103 = (uint32x2_t)vmul_s32(v96, v102);
                      v104 = (uint32x2_t)vmul_s32(v97, v102);
                      *v38 = (int8x8_t)vsli_n_s32(vsub_s32(v29, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v103, v103, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v97, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v104, v104, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                      v101 = v17 - ((v100 * v17 + ((v100 * v17) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      LOWORD(v101) = 0;
                      *v38 = 0;
                    }
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    LOWORD(v101) = v17;
                  }
                  *(_WORD *)v41 = v101;
                  ++v38;
                  v41 += 2 * v910;
                  --v99;
                }
                while (v99);
                v38 += v948;
                v41 += 2 * v949;
                --v98;
              }
              while (v98);
              goto LABEL_352;
            case 5:
              v105 = v952[0];
              do
              {
                v106 = (int)v10;
                v10 = (unint64_t *)v38;
                do
                {
                  v107 = *v10++;
                  cmyk64_DAMplusDAM((unsigned int *)v38, v41, *(_QWORD *)&v29, v17, *(unsigned __int16 *)v41, v107, *(unsigned __int16 *)v41, (unsigned __int16)~(_WORD)v17);
                  v41 += 2 * v910;
                  v38 = (int8x8_t *)v10;
                  --v106;
                }
                while (v106);
                v38 = (int8x8_t *)&v10[v948];
                v41 += 2 * v949;
                --v105;
                LODWORD(v10) = v916;
              }
              while (v105);
              goto LABEL_340;
            case 6:
              v108 = v952[0];
              do
              {
                v109 = (int)v10;
                do
                {
                  if (*(_WORD *)v41 != 0xFFFF)
                  {
                    if ((unsigned __int16)~*(_WORD *)v41 == 0xFFFF)
                    {
                      *v38 = (int8x8_t)v29;
                      *(_WORD *)v41 = v17;
                    }
                    else
                    {
                      cmyk64_DAplusDAM(v38, v41, (uint64_t)*v38, *(_WORD *)v41, *(_QWORD *)&v29, v17, (unsigned __int16)~*(_WORD *)v41);
                    }
                  }
                  ++v38;
                  v41 += 2 * v910;
                  --v109;
                }
                while (v109);
                v38 += v948;
                v41 += 2 * v949;
                --v108;
              }
              while (v108);
              goto LABEL_340;
            case 7:
              v110 = vdup_n_s32((unsigned __int16)~(_WORD)v17);
              v111 = v952[0];
              if (v6)
              {
                do
                {
                  v112 = (int)v10;
                  do
                  {
                    v113 = *(unsigned __int16 *)v41;
                    v114 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v38, (int8x8_t)0xFFFF0000FFFFLL), v110);
                    v115.i32[0] = HIWORD(v38->u32[0]);
                    v115.i32[1] = HIWORD(*(unint64_t *)v38);
                    v116 = (uint32x2_t)vmul_s32(v115, v110);
                    *v38 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v38, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v114, v114, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v115, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v116, v116, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                    ++v38;
                    *(_WORD *)v41 = v113
                                  - (((unsigned __int16)~(_WORD)v17 * v113
                                    + (((unsigned __int16)~(_WORD)v17 * v113) >> 16)
                                    + 1) >> 16);
                    v41 += 2 * v910;
                    --v112;
                  }
                  while (v112);
                  v38 += v948;
                  v41 += 2 * v949;
                  --v111;
                }
                while (v111);
              }
              else
              {
                do
                {
                  v184 = (int)v10;
                  do
                  {
                    v185 = (int32x2_t)*v38;
                    v186.i32[0] = vshl_u32((uint32x2_t)*v38, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                    v187.i32[0] = v186.i32[0];
                    v187.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v38);
                    v188 = (int8x8_t)vmul_s32(v187, v110);
                    v187.i32[0] = v38->u16[0];
                    v187.i32[1] = HIWORD(*(unint64_t *)v38);
                    v189 = (uint32x2_t)vmul_s32(v187, v110);
                    v186.i32[1] = HIDWORD(*(unint64_t *)v38);
                    v185.i32[1] = HIWORD(*(unint64_t *)v38);
                    v190 = vsub_s32(v185, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v189, v189, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    v191 = vshl_n_s32(v190, 0x10uLL);
                    v190.i16[1] = 0;
                    v190.i32[1] = v191.i32[1];
                    v192 = (uint32x2_t)vsub_s32(v186, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)v188, (uint32x2_t)v188, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    v188.i32[0] = vshl_u32(v192, (uint32x2_t)0xFFFF00000010).u32[0];
                    v188.i32[1] = v192.u16[2];
                    *v38++ = vorr_s8(v188, (int8x8_t)v190);
                    v41 += 2 * v910;
                    --v184;
                  }
                  while (v184);
                  v38 += v948;
                  v41 += 2 * v949;
                  --v111;
                }
                while (v111);
              }
              goto LABEL_352;
            case 8:
              v117 = vdup_n_s32(v17);
              v118 = v952[0];
              v119 = 2 * v910;
              if (v6)
              {
                do
                {
                  v120 = (int)v10;
                  do
                  {
                    v121 = *(unsigned __int16 *)v41;
                    v122 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v38, (int8x8_t)0xFFFF0000FFFFLL), v117);
                    v123.i32[0] = HIWORD(v38->u32[0]);
                    v123.i32[1] = HIWORD(*(unint64_t *)v38);
                    v124 = (uint32x2_t)vmul_s32(v123, v117);
                    *v38 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v38, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v122, v122, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v123, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v124, v124, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                    ++v38;
                    *(_WORD *)v41 = v121 - ((v17 * v121 + ((v17 * v121) >> 16) + 1) >> 16);
                    v41 += v119;
                    --v120;
                  }
                  while (v120);
                  v38 += v948;
                  v41 += 2 * v949;
                  --v118;
                }
                while (v118);
              }
              else
              {
                do
                {
                  v193 = (int)v10;
                  do
                  {
                    v194 = (int32x2_t)*v38;
                    v195.i32[0] = vshl_u32((uint32x2_t)*v38, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                    v196.i32[0] = v195.i32[0];
                    v196.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v38);
                    v197 = (int8x8_t)vmul_s32(v196, v117);
                    v196.i32[0] = v38->u16[0];
                    v196.i32[1] = HIWORD(*(unint64_t *)v38);
                    v198 = (uint32x2_t)vmul_s32(v196, v117);
                    v195.i32[1] = HIDWORD(*(unint64_t *)v38);
                    v194.i32[1] = HIWORD(*(unint64_t *)v38);
                    v199 = vsub_s32(v194, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v198, v198, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    v200 = vshl_n_s32(v199, 0x10uLL);
                    v199.i16[1] = 0;
                    v199.i32[1] = v200.i32[1];
                    v201 = (uint32x2_t)vsub_s32(v195, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)v197, (uint32x2_t)v197, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    v197.i32[0] = vshl_u32(v201, (uint32x2_t)0xFFFF00000010).u32[0];
                    v197.i32[1] = v201.u16[2];
                    *v38++ = vorr_s8(v197, (int8x8_t)v199);
                    v41 += v119;
                    --v193;
                  }
                  while (v193);
                  v38 += v948;
                  v41 += 2 * v949;
                  --v118;
                }
                while (v118);
              }
LABEL_352:
              v952[0] = 0;
              goto LABEL_342;
            case 9:
              v125 = v952[0];
              do
              {
                v126 = (int)v10;
                v10 = (unint64_t *)v38;
                do
                {
                  v127 = *v10++;
                  cmyk64_DAMplusDAM((unsigned int *)v38, v41, *(_QWORD *)&v29, v17, *(unsigned __int16 *)v41 ^ 0xFFFF, v127, *(unsigned __int16 *)v41, v17);
                  v41 += 2 * v910;
                  v38 = (int8x8_t *)v10;
                  --v126;
                }
                while (v126);
                v38 = (int8x8_t *)&v10[v948];
                v41 += 2 * v949;
                --v125;
                LODWORD(v10) = v916;
              }
              while (v125);
              goto LABEL_340;
            case 10:
              v128 = v952[0];
              do
              {
                v129 = (int)v10;
                v10 = (unint64_t *)v38;
                do
                {
                  v130 = *v10++;
                  cmyk64_DAMplusDAM((unsigned int *)v38, v41, *(_QWORD *)&v29, v17, *(unsigned __int16 *)v41 ^ 0xFFFF, v130, *(unsigned __int16 *)v41, (unsigned __int16)~(_WORD)v17);
                  v41 += 2 * v910;
                  v38 = (int8x8_t *)v10;
                  --v129;
                }
                while (v129);
                v38 = (int8x8_t *)&v10[v948];
                v41 += 2 * v949;
                --v128;
                LODWORD(v10) = v916;
              }
              while (v128);
              goto LABEL_340;
            case 11:
              v131 = v952[0];
              v132 = 2 * v910;
              if (v6)
              {
                do
                {
                  v133 = (int)v10;
                  v10 = (unint64_t *)v38;
                  do
                  {
                    v134 = *v10++;
                    cmyk64_DAplusdDA((int *)v38, (__int16 *)v41, v134, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    v41 += v132;
                    v38 = (int8x8_t *)v10;
                    --v133;
                  }
                  while (v133);
                  v38 = (int8x8_t *)&v10[v948];
                  v41 += 2 * v949;
                  --v131;
                  LODWORD(v10) = v916;
                }
                while (v131);
              }
              else
              {
                do
                {
                  v135 = (int)v10;
                  v10 = (unint64_t *)v38;
                  do
                  {
                    v136 = *v10++;
                    cmyk64_DplusdDA((int *)v38, v136, *(_QWORD *)&v29, v17);
                    v41 += v132;
                    v38 = (int8x8_t *)v10;
                    --v135;
                  }
                  while (v135);
                  v38 = (int8x8_t *)&v10[v948];
                  v41 += 2 * v949;
                  --v131;
                  LODWORD(v10) = v916;
                }
                while (v131);
              }
              goto LABEL_340;
            case 12:
              v137 = v952[0];
              v138 = 2 * v910;
              if (v6)
              {
                do
                {
                  v139 = (int)v10;
                  v10 = (unint64_t *)v38;
                  do
                  {
                    v140 = *v10++;
                    cmyk64_DApluslDA((unsigned int *)v38, v41, v140, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    v41 += v138;
                    v38 = (int8x8_t *)v10;
                    --v139;
                  }
                  while (v139);
                  v38 = (int8x8_t *)&v10[v948];
                  v41 += 2 * v949;
                  --v137;
                  LODWORD(v10) = v916;
                }
                while (v137);
              }
              else
              {
                do
                {
                  v141 = (int)v10;
                  v10 = (unint64_t *)v38;
                  do
                  {
                    v142 = *v10++;
                    cmyk64_DpluslD((unsigned int *)v38, v142, *(_QWORD *)&v29);
                    v41 += v138;
                    v38 = (int8x8_t *)v10;
                    --v141;
                  }
                  while (v141);
                  v38 = (int8x8_t *)&v10[v948];
                  v41 += 2 * v949;
                  --v137;
                  LODWORD(v10) = v916;
                }
                while (v137);
              }
LABEL_340:
              v952[0] = 0;
              v7 = v872;
              goto LABEL_341;
            case 13:
              if (!v17)
                goto LABEL_342;
              v143 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAmultiplyPDA_10646((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v144;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAmultiplyPDA_10646((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v143;
                  LODWORD(v10) = v916;
                  if (!v143)
                    break;
                }
              }
              break;
            case 14:
              if (!v17)
                goto LABEL_342;
              v145 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAscreenPDA_10647((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v146;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAscreenPDA_10647((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v145;
                  LODWORD(v10) = v916;
                  if (!v145)
                    break;
                }
              }
              break;
            case 15:
              if (!v17)
                goto LABEL_342;
              v147 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAoverlayPDA_10648((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v148;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAoverlayPDA_10648((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v147;
                  LODWORD(v10) = v916;
                  if (!v147)
                    break;
                }
              }
              break;
            case 16:
              if (!v17)
                goto LABEL_342;
              v149 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAdarkenPDA_10650((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v150;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAdarkenPDA_10650((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v149;
                  LODWORD(v10) = v916;
                  if (!v149)
                    break;
                }
              }
              break;
            case 17:
              if (!v17)
                goto LABEL_342;
              v151 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAlightenPDA_10649((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v152;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAlightenPDA_10649((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v151;
                  LODWORD(v10) = v916;
                  if (!v151)
                    break;
                }
              }
              break;
            case 18:
              if (!v17)
                goto LABEL_342;
              v153 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAcolordodgePDA_10651((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v154;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAcolordodgePDA_10651((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v153;
                  LODWORD(v10) = v916;
                  if (!v153)
                    break;
                }
              }
              break;
            case 19:
              if (!v17)
                goto LABEL_342;
              v155 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAcolorburnPDA_10652((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v156;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAcolorburnPDA_10652((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v155;
                  LODWORD(v10) = v916;
                  if (!v155)
                    break;
                }
              }
              break;
            case 20:
              if (!v17)
                goto LABEL_342;
              v157 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAsoftlightPDA_10654((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v158;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAsoftlightPDA_10654((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v157;
                  LODWORD(v10) = v916;
                  if (!v157)
                    break;
                }
              }
              break;
            case 21:
              if (!v17)
                goto LABEL_342;
              v159 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAhardlightPDA_10653((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v160;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAhardlightPDA_10653((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v159;
                  LODWORD(v10) = v916;
                  if (!v159)
                    break;
                }
              }
              break;
            case 22:
              if (!v17)
                goto LABEL_342;
              v161 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAdifferencePDA_10655((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v162;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAdifferencePDA_10655((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v161;
                  LODWORD(v10) = v916;
                  if (!v161)
                    break;
                }
              }
              break;
            case 23:
              if (!v17)
                goto LABEL_342;
              v163 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAexclusionPDA_10656((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v164;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAexclusionPDA_10656((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v163;
                  LODWORD(v10) = v916;
                  if (!v163)
                    break;
                }
              }
              break;
            case 24:
              if (!v17)
                goto LABEL_342;
              v165 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAhuePDA_10657((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v166;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAhuePDA_10657((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v165;
                  LODWORD(v10) = v916;
                  if (!v165)
                    break;
                }
              }
              break;
            case 25:
              if (!v17)
                goto LABEL_342;
              v167 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAsaturationPDA_10658((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v168;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAsaturationPDA_10658((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v167;
                  LODWORD(v10) = v916;
                  if (!v167)
                    break;
                }
              }
              break;
            case 26:
              if (!v17)
                goto LABEL_342;
              v169 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAluminosityPDA_10659(*(_QWORD *)&v29, v17, (unint64_t)*v38, *(unsigned __int16 *)v41);
                    *(_WORD *)v41 = v170;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAluminosityPDA_10659(*(_QWORD *)&v29, v17, (unint64_t)*v38, 0xFFFFu);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v169;
                  LODWORD(v10) = v916;
                  if (!v169)
                    break;
                }
              }
              break;
            case 27:
              if (!v17)
                goto LABEL_342;
              v171 = v952[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *v38 = (int8x8_t)PDAluminosityPDA_10659((unint64_t)*v38, *(unsigned __int16 *)v41, *(_QWORD *)&v29, v17);
                    *(_WORD *)v41 = v172;
                  }
                  else
                  {
                    *v38 = (int8x8_t)v29;
                    *(_WORD *)v41 = v17;
                  }
                }
                else
                {
                  *v38 = (int8x8_t)PDAluminosityPDA_10659((unint64_t)*v38, 0xFFFFu, *(_QWORD *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v910;
                LODWORD(v10) = (_DWORD)v10 - 1;
                if (!(_DWORD)v10)
                {
                  v38 += v948;
                  v41 += 2 * v949;
                  --v171;
                  LODWORD(v10) = v916;
                  if (!v171)
                    break;
                }
              }
              break;
            default:
              goto LABEL_342;
          }
          v952[0] = 0;
LABEL_341:
          v30 = v908;
LABEL_342:
          v38 = v912;
LABEL_343:
          v40 = v942;
          if (!v942)
            return 1;
          v951 = 0;
        }
        v49 = (void *)v40;
LABEL_1080:
        free(v49);
      }
      return 1;
    }
    v962[0] = *(_DWORD *)(v3 + 4);
    v952[0] = v12;
    v18 = *(_QWORD *)(v3 + 88);
    v20 = *(int *)(v3 + 12);
    v19 = *(int *)(v3 + 16);
    v21 = (unint64_t)*(int *)(v3 + 28) >> 3;
    if (v6)
    {
      v870 = (unint64_t)*(int *)(v3 + 32) >> 1;
      v871 = (char *)(v6 + 2 * (v20 + v870 * v19));
      v22 = 0xFFFFFFFFLL;
    }
    else
    {
      v870 = 0;
      v871 = 0;
      v22 = 0;
    }
    v869 = *(_QWORD *)(v3 + 40) + 8 * (v20 + v19 * v21);
    v33 = *(_DWORD *)(v3 + 56);
    v34 = *(_DWORD *)(v3 + 60);
    v35 = (unint64_t)*(int *)(v3 + 76) >> 3;
    if (v16 == 256)
    {
      if (v5)
      {
        v36 = (unint64_t)*(int *)(v3 + 80) >> 1;
        v5 += v33 + v36 * v34;
        v37 = 0xFFFFFFFFLL;
      }
      else
      {
        v36 = 0;
        v37 = 0;
      }
      v947 = (uint64_t *)(v18 + 8 * (v33 + v34 * v35));
      if (v35 == v21 && (uint64_t)(v869 - (_QWORD)v947) >= 1)
      {
        if ((unint64_t)v10 >= (v869 - (unint64_t)v947) >> 3)
        {
          v869 += 8 * v11;
          v947 += v11;
          v871 += 2 * (v22 & v11);
          v50 = 0xFFFFFFFFLL;
          v35 = (unint64_t)*(int *)(v3 + 28) >> 3;
          v5 += v37 & v11;
          goto LABEL_49;
        }
        if (v869 <= (unint64_t)&v947[v21 * v13 + v11])
        {
          v869 += 8 * v21 * v13;
          v35 = -(uint64_t)v21;
          v63 = &v871[2 * v870 * v13];
          v870 = -(uint64_t)v870;
          v871 = v63;
          v5 += v36 * v13;
          v22 &= 1u;
          v36 = -(uint64_t)v36;
          v37 &= 1u;
          v50 = 1;
          v947 += v21 * v13;
          v21 = -(uint64_t)v21;
          goto LABEL_49;
        }
      }
      v22 &= 1u;
      v37 &= 1u;
      v50 = 1;
LABEL_49:
      v823 = *(_DWORD *)(v3 + 60);
      v824 = *(_DWORD *)(v3 + 56);
      if (v14)
      {
        v943 = v22;
        v944 = v37;
        v911 = 0;
        v913 = 0;
        v18 = -1;
        v876 = v35;
        v875 = v36;
        goto LABEL_54;
      }
      v56 = (unint64_t *)((int)v50 * (int)v10);
      v909 = v870 - (int)v22 * (int)v10;
      v57 = -1;
      v875 = v36;
      v876 = v35;
LABEL_62:
      v911 = 0;
      v877 = 0;
      v62 = 0;
      v35 -= (unint64_t)v56;
      v36 -= (int)v37 * (int)v10;
      v868 = (uint64_t)v947;
      v950 = (int8x8_t *)v869;
      v53 = v871;
      v54 = v5;
      v61 = (uint64_t)v5;
      goto LABEL_353;
    }
    v876 = *(_DWORD *)(v3 + 64);
    v875 = *(_DWORD *)(v3 + 68);
    if (v5)
    {
      v36 = (unint64_t)*(int *)(v3 + 80) >> 1;
      v37 = 1;
    }
    else
    {
      v36 = 0;
      v37 = 0;
    }
    v911 = v18 + 8 * v35 * v875;
    v22 &= 1u;
    if (v14)
    {
      v823 = *(_DWORD *)(v3 + 60);
      v824 = *(_DWORD *)(v3 + 56);
      v943 = v22;
      v944 = v37;
      v50 = 1;
      v913 = *(uint64_t **)(v3 + 88);
      v947 = v913;
LABEL_54:
      v878 = v21;
      shape_enum_clip_alloc(v2, v3, (int *)v14, v50, v21, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), (int)v10, v12);
      v52 = v51;
      v868 = (uint64_t)v947;
      v53 = v871;
      v909 = v870;
      v54 = v5;
      v915 = v5;
      v55 = v911;
      if (v51)
        goto LABEL_1058;
      return 1;
    }
    v909 = v870 - (v22 * (_DWORD)v10);
    if (!v18)
    {
      v823 = *(_DWORD *)(v3 + 60);
      v824 = *(_DWORD *)(v3 + 56);
      v947 = 0;
      v57 = 0;
      v50 = 1;
      v56 = v10;
      goto LABEL_62;
    }
    v58 = v34 % v875;
    v823 = v34 % v875;
    v868 = *(_QWORD *)(v3 + 88);
    v59 = v18 + 8 * v35 * v58;
    v60 = v33 % v876;
    v947 = (uint64_t *)(v59 + 8 * v60);
    v57 = v59 + 8 * v876;
    v824 = v60;
    v877 = 0;
    if (v5)
    {
      v61 = (uint64_t)&v5[v36 * v58 + v60];
      v50 = 1;
      v37 = 1;
      v950 = (int8x8_t *)v869;
      v53 = v871;
      v62 = (uint64_t *)(v59 + 8 * v60);
      v54 = (__int16 *)v61;
    }
    else
    {
      v54 = 0;
      v61 = 0;
      v50 = 1;
      v950 = (int8x8_t *)v869;
      v53 = v871;
      v62 = (uint64_t *)(v59 + 8 * v60);
    }
    v56 = v10;
LABEL_353:
    v943 = v22;
    v944 = v37;
    v878 = v21;
    v905 = v35;
    v907 = v21 - (_QWORD)v56;
    v917 = (int)v10;
    v902 = v36;
    switch(v872)
    {
      case 0:
        v913 = v62;
        v915 = (__int16 *)v61;
        v18 = v57;
        v202 = v907 - (int)v10;
        v203 = &v950[-(int)v10 + 1];
        if ((int)v50 >= 0)
        {
          v203 = v950;
          v202 = v907 + (int)v10;
        }
        v204 = v952[0];
        v205 = v952[0] - 1;
        v206 = (char *)&v203[(v202 * v205) & (v202 >> 63)];
        if (v202 < 0)
          v202 = -v202;
        CGBlt_fillBytes(8 * (_DWORD)v10, v952[0], 0, v206, 8 * v202);
        if (!(_DWORD)v943)
          goto LABEL_1055;
        v874 = v50;
        if ((v50 & 0x80000000) != 0)
        {
          v207 = v909 - (int)v10;
          v53 += -2 * (int)v10 + 2;
        }
        else
        {
          v207 = v909 + (int)v10;
        }
        v787 = (v207 * v205) & (v207 >> 63);
        if (v207 < 0)
          v207 = -v207;
        v909 = v207;
        v53 += 2 * v787;
        CGBlt_fillBytes(2 * (_DWORD)v10, v204, 0, v53, 2 * v207);
        goto LABEL_1053;
      case 1:
        v874 = v50;
        v208 = *(unsigned __int8 *)(v867 + 1);
        if (v208 == 2)
        {
          if ((int)v10 >= 4 && (8 * v876) <= 0x40)
          {
            v4.i32[0] = 8 * v876;
            v774 = (uint8x8_t)vcnt_s8(v4);
            v774.i16[0] = vaddlv_u8(v774);
            if (v774.i32[0] <= 1u)
            {
              v913 = v62;
              v915 = (__int16 *)v61;
              v18 = v57;
              v775 = v952[0];
              CGSFillDRAM64(v950, 8 * ((_DWORD)v10 + v907), 8 * (_DWORD)v10, v952[0], v868, 8 * v35, 8 * v876, v875, 8 * v824, v823);
              if (!(_DWORD)v943)
                goto LABEL_1054;
              v52 = v877;
              if ((_DWORD)v37)
                CGSFillDRAM64(v53, 2 * ((_DWORD)v10 + v909), 2 * (_DWORD)v10, v775, (uint64_t)v5, 2 * v36, 2 * v876, v875, 2 * v824, v823);
              else
                CGBlt_fillBytes(2 * (_DWORD)v10, v775, -1, v53, 2 * ((_DWORD)v10 + v909));
              goto LABEL_1056;
            }
          }
        }
        else if (v208 == 1)
        {
          v913 = v62;
          v915 = (__int16 *)v61;
          v18 = v57;
          if ((v50 & 0x80000000) != 0)
          {
            v209 = v35 - (int)v10;
            v947 += -(int)v10 + 1;
            v210 = v907 - (int)v10;
            v950 += -(int)v10 + 1;
          }
          else
          {
            v209 = v35 + (int)v10;
            v210 = v907 + (int)v10;
          }
          v806 = v952[0];
          v807 = v952[0] - 1;
          if (v209 >= 0)
            v808 = v209;
          else
            v808 = -v209;
          v809 = (char *)&v947[(v209 * v807) & (v209 >> 63)];
          if (v210 >= 0)
            LODWORD(v810) = v210;
          else
            v810 = -v210;
          v811 = v808;
          CGBlt_copyBytes(8 * (_DWORD)v10, v952[0], v809, (char *)&v950[(v210 * v807) & (v210 >> 63)], 8 * v808, 8 * v810);
          if (!(_DWORD)v943)
          {
            v35 = v811;
            goto LABEL_1054;
          }
          v812 = v806;
          v813 = 2 * (_DWORD)v10;
          v52 = v877;
          if ((_DWORD)v37)
          {
            v814 = v36 - (int)v10;
            v815 = &v54[-(int)v10 + 1];
            v816 = v909 - (int)v10;
            v817 = &v53[-2 * (int)v10 + 2];
            if ((int)v50 >= 0)
            {
              v814 = v36 + (int)v10;
              v816 = v909 + (int)v10;
              v817 = v53;
              v815 = v54;
            }
            if (v814 >= 0)
              v36 = v814;
            else
              v36 = -v814;
            v818 = (char *)&v815[(v814 * v807) & (v814 >> 63)];
            if (v816 >= 0)
              v819 = v816;
            else
              v819 = -v816;
            v909 = v819;
            v54 = (__int16 *)v818;
            v53 = &v817[2 * ((v816 * v807) & (v816 >> 63))];
            CGBlt_copyBytes(v813, v812, v818, v53, 2 * v36, 2 * v819);
          }
          else
          {
            v820 = v909 - (int)v10;
            v821 = &v53[-2 * (int)v10 + 2];
            if ((int)v50 >= 0)
            {
              v820 = v909 + (int)v10;
              v821 = v53;
            }
            if (v820 >= 0)
              v822 = v820;
            else
              v822 = -v820;
            v909 = v822;
            v53 = &v821[2 * ((v820 * v807) & (v820 >> 63))];
            CGBlt_fillBytes(v813, v812, -1, v53, 2 * v822);
          }
          v35 = v811;
          goto LABEL_1056;
        }
        if ((_DWORD)v22)
        {
          v776 = 8 * (int)v50;
          v777 = 2 * (int)v22;
          if ((_DWORD)v37)
          {
            v778 = v952[0];
            do
            {
              v779 = (int)v10;
              do
              {
                *v950 = (int8x8_t)*v947;
                *(_WORD *)v53 = *v54;
                v780 = &v947[(int)v50];
                if ((unint64_t)v780 >= v57)
                  v781 = -(uint64_t)v876;
                else
                  v781 = 0;
                v54 += (int)v37 + v781;
                v947 = &v780[v781];
                v950 = (int8x8_t *)((char *)v950 + v776);
                v53 += v777;
                --v779;
              }
              while (v779);
              if (v911)
              {
                v782 = &v62[v35];
                v783 = (unint64_t)v782 >= v911;
                if ((unint64_t)v782 >= v911)
                  v784 = -(uint64_t)(v35 * v875);
                else
                  v784 = 0;
                v62 = &v782[v784];
                v785 = v57 + 8 * v784;
                if (v783)
                  v786 = -(uint64_t)(v36 * v875);
                else
                  v786 = 0;
                v61 += 2 * v36 + 2 * v786;
                v57 = v785 + 8 * v35;
                v947 = v62;
                v54 = (__int16 *)v61;
              }
              else
              {
                v947 += v35;
                v54 += v36;
              }
              v950 += v907;
              v53 += 2 * v909;
              --v778;
            }
            while (v778);
          }
          else
          {
            v797 = v952[0];
            do
            {
              v798 = (int)v10;
              do
              {
                *v950 = (int8x8_t)*v947;
                *(_WORD *)v53 = -1;
                v799 = &v947[(int)v50];
                if ((unint64_t)v799 >= v57)
                  v800 = -(uint64_t)v876;
                else
                  v800 = 0;
                v54 += v800;
                v947 = &v799[v800];
                v950 = (int8x8_t *)((char *)v950 + v776);
                v53 += v777;
                --v798;
              }
              while (v798);
              if (v911)
              {
                v801 = &v62[v35];
                v802 = (unint64_t)v801 >= v911;
                if ((unint64_t)v801 >= v911)
                  v803 = -(uint64_t)(v35 * v875);
                else
                  v803 = 0;
                v62 = &v801[v803];
                v804 = v57 + 8 * v803;
                if (v802)
                  v805 = -(uint64_t)(v36 * v875);
                else
                  v805 = 0;
                v61 += 2 * v36 + 2 * v805;
                v57 = v804 + 8 * v35;
                v947 = v62;
                v54 = (__int16 *)v61;
              }
              else
              {
                v947 += v35;
                v54 += v36;
              }
              v950 += v907;
              v53 += 2 * v909;
              --v797;
            }
            while (v797);
          }
        }
        else
        {
          v788 = v952[0];
          do
          {
            v789 = (int)v10;
            do
            {
              *v950 = (int8x8_t)*v947;
              v790 = &v947[(int)v50];
              if ((unint64_t)v790 >= v57)
                v791 = -(uint64_t)v876;
              else
                v791 = 0;
              v54 += (int)v37 + v791;
              v947 = &v790[v791];
              v950 += (int)v50;
              --v789;
            }
            while (v789);
            if (v911)
            {
              v792 = &v62[v35];
              v793 = (unint64_t)v792 >= v911;
              if ((unint64_t)v792 >= v911)
                v794 = -(uint64_t)(v35 * v875);
              else
                v794 = 0;
              v62 = &v792[v794];
              v795 = v57 + 8 * v794;
              if (v793)
                v796 = -(uint64_t)(v36 * v875);
              else
                v796 = 0;
              v61 += 2 * v36 + 2 * v796;
              v57 = v795 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v788;
          }
          while (v788);
        }
LABEL_1144:
        v913 = v62;
        v915 = (__int16 *)v61;
        v18 = v57;
        v952[0] = 0;
        goto LABEL_1055;
      case 2:
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v50 = (int)v50;
        v913 = v62;
        v915 = (__int16 *)v61;
        if ((_DWORD)v22)
        {
          v825 = -(uint64_t)(v36 * v875);
          v211 = v952[0];
          v212 = 8 * (int)v50;
          v213 = 2 * (int)v22;
          v919 = (int)v50;
          do
          {
            v879 = v211;
            v214 = (int)v10;
            do
            {
              v215 = (unsigned __int16)*v54;
              if (*v54)
              {
                if (v215 == 0xFFFF)
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = -1;
                }
                else
                {
                  v216 = v57;
                  cmyk64_DAplusDAM(v950, v53, *v947, v215, (unint64_t)*v950, *(unsigned __int16 *)v53, v215 ^ 0xFFFF);
                  v57 = v216;
                  v50 = v919;
                }
              }
              v217 = &v947[v50];
              if ((unint64_t)v217 >= v57)
                v218 = -(uint64_t)v876;
              else
                v218 = 0;
              v54 += (int)v37 + v218;
              v947 = &v217[v218];
              v950 = (int8x8_t *)((char *)v950 + v212);
              v53 += v213;
              --v214;
            }
            while (v214);
            if (v911)
            {
              v219 = &v913[v35];
              v220 = (unint64_t)v219 >= v911;
              v221 = -(uint64_t)(v35 * v875);
              if ((unint64_t)v219 < v911)
                v221 = 0;
              v222 = &v219[v221];
              v223 = v57 + 8 * v221;
              v224 = v825;
              if (!v220)
                v224 = 0;
              v225 = (uint64_t)&v915[v902 + v224];
              v57 = v223 + 8 * v35;
              v947 = v222;
              v226 = v222;
              v54 = (__int16 *)v225;
            }
            else
            {
              v947 += v35;
              v54 += v902;
              v226 = v913;
              v225 = (uint64_t)v915;
            }
            v913 = v226;
            v915 = (__int16 *)v225;
            v950 += v907;
            v53 += 2 * v909;
            v211 = v879 - 1;
          }
          while (v879 != 1);
        }
        else
        {
          v845 = -(uint64_t)(v36 * v875);
          v669 = v952[0];
          do
          {
            v901 = v669;
            do
            {
              v670 = (unsigned __int16)*v54;
              if (*v54)
              {
                if (v670 == 0xFFFF)
                {
                  *v950 = (int8x8_t)*v947;
                }
                else
                {
                  v671 = v57;
                  cmyk64_DplusDM(v950, *v947, (unint64_t)*v950, v670 ^ 0xFFFF);
                  v57 = v671;
                }
              }
              v672 = &v947[(int)v50];
              if ((unint64_t)v672 >= v57)
                v673 = -(uint64_t)v876;
              else
                v673 = 0;
              v54 += (int)v37 + v673;
              v947 = &v672[v673];
              v950 += (int)v50;
              LODWORD(v10) = (_DWORD)v10 - 1;
            }
            while ((_DWORD)v10);
            if (v911)
            {
              v674 = &v913[v35];
              v675 = (unint64_t)v674 >= v911;
              v676 = -(uint64_t)(v35 * v875);
              if ((unint64_t)v674 < v911)
                v676 = 0;
              v677 = &v674[v676];
              v678 = v57 + 8 * v676;
              v679 = v845;
              if (!v675)
                v679 = 0;
              v57 = v678 + 8 * v35;
              v947 = v677;
              v913 = v677;
              v915 += v902 + v679;
              v54 = v915;
            }
            else
            {
              v947 += v35;
              v54 += v902;
            }
            LODWORD(v10) = v917;
            v950 += v907;
            v53 += 2 * v909;
            v669 = v901 - 1;
          }
          while (v901 != 1);
        }
        goto LABEL_955;
      case 3:
        if ((_DWORD)v37)
        {
          v227 = v952[0];
          v228 = 2 * (int)v22;
          do
          {
            v229 = (int)v10;
            do
            {
              v230 = *(unsigned __int16 *)v53;
              if (v230 == 0xFFFF)
              {
                *v950 = (int8x8_t)*v947;
                LOWORD(v230) = *v54;
              }
              else if (*(_WORD *)v53)
              {
                v231 = (unsigned __int16)*v54;
                v232 = v230 ^ 0xFFFF;
                v233 = vdup_n_s32(v232);
                v234 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v947, (int8x8_t)0xFFFF0000FFFFLL), v233);
                v235.i32[0] = WORD1(*v947);
                v235.i32[1] = HIWORD(*v947);
                v236 = (uint32x2_t)vmul_s32(v235, v233);
                *v950 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v947, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v234, v234, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v235, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v236, v236, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                v230 = v231 - ((v232 * v231 + ((v232 * v231) >> 16) + 1) >> 16);
              }
              else
              {
                *v950 = 0;
              }
              *(_WORD *)v53 = v230;
              v237 = &v947[(int)v50];
              if ((unint64_t)v237 >= v57)
                v238 = -(uint64_t)v876;
              else
                v238 = 0;
              v54 += (int)v37 + v238;
              v947 = &v237[v238];
              v950 += (int)v50;
              v53 += v228;
              --v229;
            }
            while (v229);
            if (v911)
            {
              v239 = &v62[v35];
              v240 = (unint64_t)v239 >= v911;
              if ((unint64_t)v239 >= v911)
                v241 = -(uint64_t)(v35 * v875);
              else
                v241 = 0;
              v62 = &v239[v241];
              v242 = v57 + 8 * v241;
              if (v240)
                v243 = -(uint64_t)(v36 * v875);
              else
                v243 = 0;
              v61 += 2 * v36 + 2 * v243;
              v57 = v242 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v227;
          }
          while (v227);
        }
        else
        {
          v680 = v952[0];
          v681 = 2 * (int)v22;
          do
          {
            v682 = (int)v10;
            do
            {
              v683 = *(unsigned __int16 *)v53;
              if (v683 == 0xFFFF)
              {
                *v950 = (int8x8_t)*v947;
              }
              else if (*(_WORD *)v53)
              {
                v684 = (int32x2_t)*v947;
                v685.i32[0] = vshl_u32(*(uint32x2_t *)v947, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v686.i32[0] = v685.i32[0];
                v686.i32[1] = (unsigned __int16)WORD2(*v947);
                v687 = vdup_n_s32(v683 ^ 0xFFFFu);
                v688 = (uint32x2_t)vmul_s32(v686, v687);
                v689.i32[0] = (unsigned __int16)*v947;
                v689.i32[1] = HIWORD(*v947);
                v690 = (uint32x2_t)vmul_s32(v689, v687);
                v685.i32[1] = HIDWORD(*v947);
                v691 = (uint32x2_t)vsub_s32(v685, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v688, v688, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v684.i32[1] = v689.i32[1];
                v692 = vsub_s32(v684, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v690, v690, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v693 = (int8x8_t)vshl_n_s32(v692, 0x10uLL);
                v692.i16[1] = 0;
                v692.i32[1] = v693.i32[1];
                v693.i32[0] = vshl_u32(v691, (uint32x2_t)0xFFFF00000010).u32[0];
                v693.i32[1] = v691.u16[2];
                *v950 = vorr_s8(v693, (int8x8_t)v692);
              }
              else
              {
                *v950 = 0;
              }
              v694 = &v947[(int)v50];
              if ((unint64_t)v694 >= v57)
                v695 = -(uint64_t)v876;
              else
                v695 = 0;
              v947 = &v694[v695];
              v54 += v695;
              v950 += (int)v50;
              v53 += v681;
              --v682;
            }
            while (v682);
            if (v911)
            {
              v696 = &v62[v35];
              v697 = (unint64_t)v696 >= v911;
              if ((unint64_t)v696 >= v911)
                v698 = -(uint64_t)(v35 * v875);
              else
                v698 = 0;
              v62 = &v696[v698];
              v699 = v57 + 8 * v698;
              if (v697)
                v700 = -(uint64_t)(v36 * v875);
              else
                v700 = 0;
              v61 += 2 * v36 + 2 * v700;
              v57 = v699 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v680;
          }
          while (v680);
        }
        goto LABEL_1144;
      case 4:
        v244 = v952[0];
        v245 = 2 * (int)v22;
        do
        {
          v246 = (int)v10;
          do
          {
            v247 = *(unsigned __int16 *)v53;
            if (*(_WORD *)v53)
            {
              LOWORD(v248) = ~(_WORD)v247;
              if (v247 != 0xFFFF)
              {
                if ((_DWORD)v37)
                  v249 = (unsigned __int16)*v54;
                else
                  v249 = 0xFFFF;
                v250 = vdup_n_s32(v247);
                v251 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v947, (int8x8_t)0xFFFF0000FFFFLL), v250);
                v252.i32[0] = WORD1(*v947);
                v252.i32[1] = HIWORD(*v947);
                v253 = (uint32x2_t)vmul_s32(v252, v250);
                *v950 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v947, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v251, v251, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v252, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v253, v253, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                v248 = v249 - ((v247 * v249 + ((v247 * v249) >> 16) + 1) >> 16);
              }
              else
              {
                *v950 = 0;
              }
            }
            else if ((_DWORD)v37)
            {
              LOWORD(v248) = *v54;
            }
            else
            {
              LOWORD(v248) = -1;
            }
            *(_WORD *)v53 = v248;
            v254 = &v947[(int)v50];
            if ((unint64_t)v254 >= v57)
              v255 = -(uint64_t)v876;
            else
              v255 = 0;
            v947 = &v254[v255];
            v54 += (int)v37 + v255;
            v950 += (int)v50;
            v53 += v245;
            --v246;
          }
          while (v246);
          if (v911)
          {
            v256 = &v62[v35];
            v257 = (unint64_t)v256 >= v911;
            if ((unint64_t)v256 >= v911)
              v258 = -(uint64_t)(v35 * v875);
            else
              v258 = 0;
            v62 = &v256[v258];
            v259 = v57 + 8 * v258;
            if (v257)
              v260 = -(uint64_t)(v36 * v875);
            else
              v260 = 0;
            v61 += 2 * v36 + 2 * v260;
            v57 = v259 + 8 * v35;
            v947 = v62;
            v54 = (__int16 *)v61;
          }
          else
          {
            v947 += v35;
            v54 += v36;
          }
          v950 += v907;
          v53 += 2 * v909;
          --v244;
        }
        while (v244);
        goto LABEL_1144;
      case 5:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v261 = (int)v50;
        v826 = -(uint64_t)(v36 * v875);
        v846 = -(uint64_t)(v35 * v875);
        v262 = v952[0];
        v263 = 2 * (int)v22;
        do
        {
          v880 = v262;
          v264 = (int)v10;
          v920 = v57;
          do
          {
            v265 = v261;
            cmyk64_DAMplusDAM((unsigned int *)v950, v53, *v947, (unsigned __int16)*v54, *(unsigned __int16 *)v53, (unint64_t)*v950, *(unsigned __int16 *)v53, (unsigned __int16)*v54 ^ 0xFFFF);
            v261 = v265;
            v57 = v920;
            v266 = &v947[v265];
            if ((unint64_t)v266 >= v920)
              v267 = -(uint64_t)v876;
            else
              v267 = 0;
            v54 += (int)v37 + v267;
            v947 = &v266[v267];
            v950 += (int)v50;
            v53 += v263;
            --v264;
          }
          while (v264);
          if (v911)
          {
            v36 = v902;
            v268 = &v913[v905];
            v269 = (unint64_t)v268 >= v911;
            v270 = v846;
            if ((unint64_t)v268 < v911)
              v270 = 0;
            v271 = &v268[v270];
            v272 = v920 + 8 * v270;
            v273 = v826;
            if (!v269)
              v273 = 0;
            v57 = v272 + 8 * v905;
            v947 = v271;
            v913 = v271;
            v915 += v902 + v273;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v262 = v880 - 1;
        }
        while (v880 != 1);
        goto LABEL_1052;
      case 6:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v274 = v35;
        v275 = (int)v37;
        v847 = -(uint64_t)(v274 * v875);
        v276 = v952[0];
        v277 = 2 * (int)v22;
        do
        {
          v881 = v276;
          v921 = v57;
          do
          {
            if (*(_WORD *)v53 != 0xFFFF)
            {
              if ((unsigned __int16)~*(_WORD *)v53 == 0xFFFF)
              {
                *v950 = (int8x8_t)*v947;
                if ((_DWORD)v37)
                  v278 = *v54;
                else
                  v278 = -1;
                *(_WORD *)v53 = v278;
              }
              else
              {
                if ((_DWORD)v37)
                  v279 = (unsigned __int16)*v54;
                else
                  v279 = 0xFFFF;
                cmyk64_DAplusDAM(v950, v53, (uint64_t)*v950, *(_WORD *)v53, *v947, v279, (unsigned __int16)~*(_WORD *)v53);
                LODWORD(v37) = v944;
                v57 = v921;
              }
            }
            v280 = &v947[(int)v50];
            if ((unint64_t)v280 >= v57)
              v281 = -(uint64_t)v876;
            else
              v281 = 0;
            v54 += v275 + v281;
            v947 = &v280[v281];
            v950 += (int)v50;
            v53 += v277;
            LODWORD(v10) = (_DWORD)v10 - 1;
          }
          while ((_DWORD)v10);
          if (v911)
          {
            v282 = &v913[v905];
            v283 = (unint64_t)v282 >= v911;
            v284 = v847;
            if ((unint64_t)v282 < v911)
              v284 = 0;
            v285 = &v282[v284];
            v286 = v57 + 8 * v284;
            v287 = -(uint64_t)(v36 * v875);
            if (!v283)
              v287 = 0;
            v57 = v286 + 8 * v905;
            v947 = v285;
            v913 = v285;
            v915 += v36 + v287;
            v54 = v915;
          }
          else
          {
            v947 += v905;
            v54 += v36;
          }
          LODWORD(v10) = v917;
          v950 += v907;
          v53 += 2 * v909;
          v276 = v881 - 1;
        }
        while (v881 != 1);
        goto LABEL_955;
      case 7:
        if ((_DWORD)v22)
        {
          v288 = v952[0];
          v289 = 2 * (int)v22;
          do
          {
            v290 = (int)v10;
            do
            {
              v291 = (unsigned __int16)*v54;
              if (v291 != 0xFFFF)
              {
                if (*v54)
                {
                  v292 = *(unsigned __int16 *)v53;
                  v293 = v291 ^ 0xFFFF;
                  v294 = vdup_n_s32(v293);
                  v295 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v950, (int8x8_t)0xFFFF0000FFFFLL), v294);
                  v296.i32[0] = HIWORD(v950->u32[0]);
                  v296.i32[1] = HIWORD(*(unint64_t *)v950);
                  v297 = (uint32x2_t)vmul_s32(v296, v294);
                  *v950 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v950, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v295, v295, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v296, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v297, v297, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  v291 = v292 - ((v293 * v292 + ((v293 * v292) >> 16) + 1) >> 16);
                }
                else
                {
                  *v950 = 0;
                }
                *(_WORD *)v53 = v291;
              }
              v298 = &v947[(int)v50];
              if ((unint64_t)v298 >= v57)
                v299 = -(uint64_t)v876;
              else
                v299 = 0;
              v54 += (int)v37 + v299;
              v947 = &v298[v299];
              v950 += (int)v50;
              v53 += v289;
              --v290;
            }
            while (v290);
            if (v911)
            {
              v300 = &v62[v35];
              v301 = (unint64_t)v300 >= v911;
              if ((unint64_t)v300 >= v911)
                v302 = -(uint64_t)(v35 * v875);
              else
                v302 = 0;
              v62 = &v300[v302];
              v303 = v57 + 8 * v302;
              if (v301)
                v304 = -(uint64_t)(v36 * v875);
              else
                v304 = 0;
              v61 += 2 * v36 + 2 * v304;
              v57 = v303 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v288;
          }
          while (v288);
        }
        else
        {
          v701 = v952[0];
          do
          {
            v702 = (int)v10;
            do
            {
              v703 = (unsigned __int16)*v54;
              if (v703 != 0xFFFF)
              {
                if (*v54)
                {
                  v704 = (int32x2_t)*v950;
                  v705.i32[0] = vshl_u32((uint32x2_t)*v950, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v706.i32[0] = v705.i32[0];
                  v706.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v950);
                  v707 = vdup_n_s32(v703 ^ 0xFFFFu);
                  v708 = (uint32x2_t)vmul_s32(v706, v707);
                  v709.i32[0] = v950->u16[0];
                  v709.i32[1] = HIWORD(*(unint64_t *)v950);
                  v710 = (uint32x2_t)vmul_s32(v709, v707);
                  v705.i32[1] = HIDWORD(*(unint64_t *)v950);
                  v711 = (uint32x2_t)vsub_s32(v705, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v708, v708, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v704.i32[1] = v709.i32[1];
                  v712 = vsub_s32(v704, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v710, v710, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v713 = (int8x8_t)vshl_n_s32(v712, 0x10uLL);
                  v712.i16[1] = 0;
                  v712.i32[1] = v713.i32[1];
                  v713.i32[0] = vshl_u32(v711, (uint32x2_t)0xFFFF00000010).u32[0];
                  v713.i32[1] = v711.u16[2];
                  *v950 = vorr_s8(v713, (int8x8_t)v712);
                }
                else
                {
                  *v950 = 0;
                }
              }
              v714 = &v947[(int)v50];
              if ((unint64_t)v714 >= v57)
                v715 = -(uint64_t)v876;
              else
                v715 = 0;
              v947 = &v714[v715];
              v54 += (int)v37 + v715;
              v950 += (int)v50;
              --v702;
            }
            while (v702);
            if (v911)
            {
              v716 = &v62[v35];
              v717 = (unint64_t)v716 >= v911;
              if ((unint64_t)v716 >= v911)
                v718 = -(uint64_t)(v35 * v875);
              else
                v718 = 0;
              v62 = &v716[v718];
              v719 = v57 + 8 * v718;
              if (v717)
                v720 = -(uint64_t)(v36 * v875);
              else
                v720 = 0;
              v61 += 2 * v36 + 2 * v720;
              v57 = v719 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v701;
          }
          while (v701);
        }
        goto LABEL_1144;
      case 8:
        if ((_DWORD)v22)
        {
          v305 = v952[0];
          v306 = 2 * (int)v22;
          do
          {
            v307 = (int)v10;
            do
            {
              v308 = (unsigned __int16)*v54;
              if (*v54)
              {
                if (v308 != 0xFFFF)
                {
                  v310 = *(unsigned __int16 *)v53;
                  v311 = vdup_n_s32(v308);
                  v312 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v950, (int8x8_t)0xFFFF0000FFFFLL), v311);
                  v313.i32[0] = HIWORD(v950->u32[0]);
                  v313.i32[1] = HIWORD(*(unint64_t *)v950);
                  v314 = (uint32x2_t)vmul_s32(v313, v311);
                  *v950 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v950, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v312, v312, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v313, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v314, v314, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  v309 = v310 - ((v308 * v310 + ((v308 * v310) >> 16) + 1) >> 16);
                }
                else
                {
                  LOWORD(v309) = 0;
                  *v950 = 0;
                }
                *(_WORD *)v53 = v309;
              }
              v315 = &v947[(int)v50];
              if ((unint64_t)v315 >= v57)
                v316 = -(uint64_t)v876;
              else
                v316 = 0;
              v947 = &v315[v316];
              v54 += (int)v37 + v316;
              v950 += (int)v50;
              v53 += v306;
              --v307;
            }
            while (v307);
            if (v911)
            {
              v317 = &v62[v35];
              v318 = (unint64_t)v317 >= v911;
              if ((unint64_t)v317 >= v911)
                v319 = -(uint64_t)(v35 * v875);
              else
                v319 = 0;
              v62 = &v317[v319];
              v320 = v57 + 8 * v319;
              if (v318)
                v321 = -(uint64_t)(v36 * v875);
              else
                v321 = 0;
              v61 += 2 * v36 + 2 * v321;
              v57 = v320 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v305;
          }
          while (v305);
        }
        else
        {
          v721 = v952[0];
          do
          {
            v722 = (int)v10;
            do
            {
              v723 = (unsigned __int16)*v54;
              if (*v54)
              {
                if (v723 != 0xFFFF)
                {
                  v724 = (int32x2_t)*v950;
                  v725.i32[0] = vshl_u32((uint32x2_t)*v950, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v726.i32[0] = v725.i32[0];
                  v726.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v950);
                  v727 = vdup_n_s32(v723);
                  v728 = (uint32x2_t)vmul_s32(v726, v727);
                  v729.i32[0] = v950->u16[0];
                  v729.i32[1] = HIWORD(*(unint64_t *)v950);
                  v730 = (uint32x2_t)vmul_s32(v729, v727);
                  v725.i32[1] = HIDWORD(*(unint64_t *)v950);
                  v731 = (uint32x2_t)vsub_s32(v725, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v728, v728, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v724.i32[1] = v729.i32[1];
                  v732 = vsub_s32(v724, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v730, v730, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v733 = (int8x8_t)vshl_n_s32(v732, 0x10uLL);
                  v732.i16[1] = 0;
                  v732.i32[1] = v733.i32[1];
                  v733.i32[0] = vshl_u32(v731, (uint32x2_t)0xFFFF00000010).u32[0];
                  v733.i32[1] = v731.u16[2];
                  *v950 = vorr_s8(v733, (int8x8_t)v732);
                }
                else
                {
                  *v950 = 0;
                }
              }
              v734 = &v947[(int)v50];
              if ((unint64_t)v734 >= v57)
                v735 = -(uint64_t)v876;
              else
                v735 = 0;
              v947 = &v734[v735];
              v54 += (int)v37 + v735;
              v950 += (int)v50;
              --v722;
            }
            while (v722);
            if (v911)
            {
              v736 = &v62[v35];
              v737 = (unint64_t)v736 >= v911;
              if ((unint64_t)v736 >= v911)
                v738 = -(uint64_t)(v35 * v875);
              else
                v738 = 0;
              v62 = &v736[v738];
              v739 = v57 + 8 * v738;
              if (v737)
                v740 = -(uint64_t)(v36 * v875);
              else
                v740 = 0;
              v61 += 2 * v36 + 2 * v740;
              v57 = v739 + 8 * v35;
              v947 = v62;
              v54 = (__int16 *)v61;
            }
            else
            {
              v947 += v35;
              v54 += v36;
            }
            v950 += v907;
            v53 += 2 * v909;
            --v721;
          }
          while (v721);
        }
        goto LABEL_1144;
      case 9:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v322 = (int)v50;
        v827 = -(uint64_t)(v36 * v875);
        v848 = -(uint64_t)(v35 * v875);
        v323 = v952[0];
        v324 = 8 * (int)v50;
        v325 = 2 * (int)v22;
        v326 = -(uint64_t)v876;
        do
        {
          v882 = v323;
          v327 = (int)v10;
          do
          {
            v922 = v54;
            v328 = (unsigned __int16)*v54;
            v329 = v57;
            v330 = v322;
            v331 = v326;
            cmyk64_DAMplusDAM((unsigned int *)v950, v53, *v947, v328, *(unsigned __int16 *)v53 ^ 0xFFFF, (unint64_t)*v950, *(unsigned __int16 *)v53, v328);
            v326 = v331;
            v322 = v330;
            v57 = v329;
            v332 = &v947[v330];
            if ((unint64_t)v332 >= v329)
              v333 = v331;
            else
              v333 = 0;
            v54 = &v922[(int)v37 + v333];
            v947 = &v332[v333];
            v950 = (int8x8_t *)((char *)v950 + v324);
            v53 += v325;
            --v327;
          }
          while (v327);
          if (v911)
          {
            v36 = v902;
            v334 = &v913[v905];
            v335 = (unint64_t)v334 >= v911;
            v336 = v848;
            if ((unint64_t)v334 < v911)
              v336 = 0;
            v337 = &v334[v336];
            v338 = v329 + 8 * v336;
            v339 = v827;
            if (!v335)
              v339 = 0;
            v57 = v338 + 8 * v905;
            v947 = v337;
            v913 = v337;
            v915 += v902 + v339;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v323 = v882 - 1;
        }
        while (v882 != 1);
        goto LABEL_1052;
      case 10:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v340 = (int)v50;
        v828 = -(uint64_t)(v36 * v875);
        v849 = -(uint64_t)(v35 * v875);
        v341 = v952[0];
        v342 = 2 * (int)v22;
        v343 = -(uint64_t)v876;
        do
        {
          v883 = v341;
          v344 = (int)v10;
          v923 = v57;
          do
          {
            v345 = v54;
            v346 = (unsigned __int16)*v54;
            v347 = v340;
            v348 = v343;
            cmyk64_DAMplusDAM((unsigned int *)v950, v53, *v947, v346, *(unsigned __int16 *)v53 ^ 0xFFFF, (unint64_t)*v950, *(unsigned __int16 *)v53, v346 ^ 0xFFFF);
            v343 = v348;
            v340 = v347;
            v57 = v923;
            v349 = &v947[v347];
            if ((unint64_t)v349 >= v923)
              v350 = v348;
            else
              v350 = 0;
            v54 = &v345[(int)v37 + v350];
            v947 = &v349[v350];
            v950 += (int)v50;
            v53 += v342;
            --v344;
          }
          while (v344);
          if (v911)
          {
            v36 = v902;
            v351 = &v913[v905];
            v352 = (unint64_t)v351 >= v911;
            v353 = v849;
            if ((unint64_t)v351 < v911)
              v353 = 0;
            v354 = &v351[v353];
            v355 = v923 + 8 * v353;
            v356 = v828;
            if (!v352)
              v356 = 0;
            v57 = v355 + 8 * v905;
            v947 = v354;
            v913 = v354;
            v915 += v902 + v356;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v341 = v883 - 1;
        }
        while (v883 != 1);
        goto LABEL_1052;
      case 11:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v924 = (int)v50;
        v357 = (int)v37;
        if ((_DWORD)v22)
        {
          v829 = -(uint64_t)(v36 * v875);
          v358 = v952[0];
          v359 = 8 * (int)v50;
          v360 = 2 * (int)v22;
          do
          {
            v884 = v358;
            v361 = v57;
            do
            {
              if ((_DWORD)v37)
                v362 = (unsigned __int16)*v54;
              else
                v362 = 0xFFFF;
              cmyk64_DAplusdDA((int *)v950, (__int16 *)v53, (unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v362);
              v363 = &v947[v924];
              if ((unint64_t)v363 >= v361)
                v364 = -(uint64_t)v876;
              else
                v364 = 0;
              v54 += v357 + v364;
              v947 = &v363[v364];
              v950 = (int8x8_t *)((char *)v950 + v359);
              v53 += v360;
              LODWORD(v10) = (_DWORD)v10 - 1;
              LODWORD(v37) = v944;
            }
            while ((_DWORD)v10);
            v57 = v361;
            if (v911)
            {
              v365 = &v913[v905];
              v366 = (unint64_t)v365 >= v911;
              v367 = -(uint64_t)(v905 * v875);
              if ((unint64_t)v365 < v911)
                v367 = 0;
              v368 = &v365[v367];
              v369 = v361 + 8 * v367;
              v370 = v829;
              if (!v366)
                v370 = 0;
              v57 = v369 + 8 * v905;
              v947 = v368;
              v913 = v368;
              v915 += v902 + v370;
              v54 = v915;
            }
            else
            {
              v947 += v905;
              v54 += v902;
            }
            LODWORD(v10) = v917;
            v950 += v907;
            v53 += 2 * v909;
            v358 = v884 - 1;
          }
          while (v884 != 1);
          goto LABEL_955;
        }
        v865 = -(uint64_t)(v36 * v875);
        v741 = v952[0];
        v742 = 8 * (int)v50;
        do
        {
          v743 = v917;
          v744 = v57;
          do
          {
            if ((_DWORD)v37)
              v745 = (unsigned __int16)*v54;
            else
              v745 = 0xFFFF;
            cmyk64_DplusdDA((int *)v950, (unint64_t)*v950, *v947, v745);
            v746 = &v947[v924];
            if ((unint64_t)v746 >= v744)
              v747 = -(uint64_t)v876;
            else
              v747 = 0;
            v54 += v357 + v747;
            v947 = &v746[v747];
            v950 = (int8x8_t *)((char *)v950 + v742);
            --v743;
            LODWORD(v37) = v944;
          }
          while (v743);
          v57 = v744;
          if (v911)
          {
            v36 = v902;
            v748 = &v913[v905];
            v749 = (unint64_t)v748 >= v911;
            v750 = -(uint64_t)(v905 * v875);
            if ((unint64_t)v748 < v911)
              v750 = 0;
            v751 = &v748[v750];
            v752 = v744 + 8 * v750;
            v753 = v865;
            if (!v749)
              v753 = 0;
            v57 = v752 + 8 * v905;
            v947 = v751;
            v913 = v751;
            v915 += v902 + v753;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          --v741;
        }
        while (v741);
        goto LABEL_1052;
      case 12:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        if ((_DWORD)v22)
        {
          v925 = (int)v50;
          v371 = (int)v37;
          v830 = -(uint64_t)(v36 * v875);
          v372 = v952[0];
          v373 = 8 * (int)v50;
          v374 = 2 * (int)v22;
          do
          {
            v885 = v372;
            v375 = v917;
            v376 = v57;
            do
            {
              if ((_DWORD)v37)
                v377 = (unsigned __int16)*v54;
              else
                v377 = 0xFFFF;
              cmyk64_DApluslDA((unsigned int *)v950, v53, (unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v377);
              v378 = &v947[v925];
              if ((unint64_t)v378 >= v376)
                v379 = -(uint64_t)v876;
              else
                v379 = 0;
              v54 += v371 + v379;
              v947 = &v378[v379];
              v950 = (int8x8_t *)((char *)v950 + v373);
              v53 += v374;
              --v375;
              LODWORD(v37) = v944;
            }
            while (v375);
            v57 = v376;
            if (v911)
            {
              v36 = v902;
              v380 = &v913[v905];
              v381 = (unint64_t)v380 >= v911;
              v382 = -(uint64_t)(v905 * v875);
              if ((unint64_t)v380 < v911)
                v382 = 0;
              v383 = &v380[v382];
              v384 = v376 + 8 * v382;
              v385 = v830;
              if (!v381)
                v385 = 0;
              v57 = v384 + 8 * v905;
              v947 = v383;
              v913 = v383;
              v915 += v902 + v385;
              v54 = v915;
            }
            else
            {
              v36 = v902;
              v947 += v905;
              v54 += v902;
            }
            v950 += v907;
            v53 += 2 * v909;
            v372 = v885 - 1;
          }
          while (v885 != 1);
        }
        else
        {
          v866 = -(uint64_t)(v36 * v875);
          v754 = v952[0];
          do
          {
            v941 = v754;
            v755 = v917;
            do
            {
              v756 = v57;
              cmyk64_DpluslD((unsigned int *)v950, (unint64_t)*v950, *v947);
              v57 = v756;
              v757 = &v947[(int)v50];
              if ((unint64_t)v757 >= v756)
                v758 = -(uint64_t)v876;
              else
                v758 = 0;
              v54 += (int)v37 + v758;
              v947 = &v757[v758];
              v950 += (int)v50;
              --v755;
            }
            while (v755);
            if (v911)
            {
              v36 = v902;
              v759 = &v913[v35];
              v760 = (unint64_t)v759 >= v911;
              v761 = -(uint64_t)(v35 * v875);
              if ((unint64_t)v759 < v911)
                v761 = 0;
              v762 = &v759[v761];
              v763 = v756 + 8 * v761;
              v764 = v866;
              if (!v760)
                v764 = 0;
              v57 = v763 + 8 * v35;
              v947 = v762;
              v913 = v762;
              v915 += v902 + v764;
              v54 = v915;
            }
            else
            {
              v36 = v902;
              v947 += v35;
              v54 += v902;
            }
            v950 += v907;
            v53 += 2 * v909;
            v754 = v941 - 1;
          }
          while (v941 != 1);
        }
        goto LABEL_1052;
      case 13:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v926 = (int)v50;
        v386 = v35;
        v387 = (int)v37;
        v388 = v952[0];
        v831 = -(uint64_t)(v36 * v875);
        v850 = -(uint64_t)(v386 * v875);
        v389 = 8 * (int)v50;
        v390 = 2 * (int)v22;
        while (1)
        {
          v886 = v388;
          v391 = (int)v10;
          v392 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v393 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_600;
              if ((_DWORD)v22)
                goto LABEL_595;
            }
            else
            {
              v393 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_595:
                if (*(_WORD *)v53)
                {
                  v394 = PDAmultiplyPDA_10646((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v393);
                  v57 = v392;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v394;
                  *(_WORD *)v53 = v395;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v393;
                }
                goto LABEL_600;
              }
            }
            v396 = PDAmultiplyPDA_10646((unint64_t)*v950, 0xFFFFu, *v947, v393);
            v57 = v392;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v396;
LABEL_600:
            v397 = &v947[v926];
            if ((unint64_t)v397 >= v57)
              v398 = -(uint64_t)v876;
            else
              v398 = 0;
            v54 += v387 + v398;
            v947 = &v397[v398];
            v950 = (int8x8_t *)((char *)v950 + v389);
            v53 += v390;
            --v391;
          }
          while (v391);
          if (v911)
          {
            v36 = v902;
            v399 = &v913[v905];
            v400 = (unint64_t)v399 >= v911;
            v401 = v850;
            if ((unint64_t)v399 < v911)
              v401 = 0;
            v402 = &v399[v401];
            v403 = v57 + 8 * v401;
            v404 = v831;
            if (!v400)
              v404 = 0;
            v57 = v403 + 8 * v905;
            v947 = v402;
            v913 = v402;
            v915 += v902 + v404;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v388 = v886 - 1;
          if (v886 == 1)
            goto LABEL_1052;
        }
      case 14:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v927 = (int)v50;
        v405 = v35;
        v406 = (int)v37;
        v407 = v952[0];
        v832 = -(uint64_t)(v36 * v875);
        v851 = -(uint64_t)(v405 * v875);
        v408 = 8 * (int)v50;
        v409 = 2 * (int)v22;
        while (1)
        {
          v887 = v407;
          v410 = (int)v10;
          v411 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v412 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_623;
              if ((_DWORD)v22)
                goto LABEL_618;
            }
            else
            {
              v412 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_618:
                if (*(_WORD *)v53)
                {
                  v413 = PDAscreenPDA_10647((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v412);
                  v57 = v411;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v413;
                  *(_WORD *)v53 = v414;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v412;
                }
                goto LABEL_623;
              }
            }
            v415 = PDAscreenPDA_10647((unint64_t)*v950, 0xFFFFu, *v947, v412);
            v57 = v411;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v415;
LABEL_623:
            v416 = &v947[v927];
            if ((unint64_t)v416 >= v57)
              v417 = -(uint64_t)v876;
            else
              v417 = 0;
            v54 += v406 + v417;
            v947 = &v416[v417];
            v950 = (int8x8_t *)((char *)v950 + v408);
            v53 += v409;
            --v410;
          }
          while (v410);
          if (v911)
          {
            v36 = v902;
            v418 = &v913[v905];
            v419 = (unint64_t)v418 >= v911;
            v420 = v851;
            if ((unint64_t)v418 < v911)
              v420 = 0;
            v421 = &v418[v420];
            v422 = v57 + 8 * v420;
            v423 = v832;
            if (!v419)
              v423 = 0;
            v57 = v422 + 8 * v905;
            v947 = v421;
            v913 = v421;
            v915 += v902 + v423;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v407 = v887 - 1;
          if (v887 == 1)
            goto LABEL_1052;
        }
      case 15:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v928 = (int)v50;
        v424 = v35;
        v425 = (int)v37;
        v426 = v952[0];
        v833 = -(uint64_t)(v36 * v875);
        v852 = -(uint64_t)(v424 * v875);
        v427 = 8 * (int)v50;
        v428 = 2 * (int)v22;
        while (1)
        {
          v888 = v426;
          v429 = (int)v10;
          v430 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v431 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_646;
              if ((_DWORD)v22)
                goto LABEL_641;
            }
            else
            {
              v431 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_641:
                if (*(_WORD *)v53)
                {
                  v432 = PDAoverlayPDA_10648((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v431);
                  v57 = v430;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v432;
                  *(_WORD *)v53 = v433;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v431;
                }
                goto LABEL_646;
              }
            }
            v434 = PDAoverlayPDA_10648((unint64_t)*v950, 0xFFFFu, *v947, v431);
            v57 = v430;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v434;
LABEL_646:
            v435 = &v947[v928];
            if ((unint64_t)v435 >= v57)
              v436 = -(uint64_t)v876;
            else
              v436 = 0;
            v54 += v425 + v436;
            v947 = &v435[v436];
            v950 = (int8x8_t *)((char *)v950 + v427);
            v53 += v428;
            --v429;
          }
          while (v429);
          if (v911)
          {
            v36 = v902;
            v437 = &v913[v905];
            v438 = (unint64_t)v437 >= v911;
            v439 = v852;
            if ((unint64_t)v437 < v911)
              v439 = 0;
            v440 = &v437[v439];
            v441 = v57 + 8 * v439;
            v442 = v833;
            if (!v438)
              v442 = 0;
            v57 = v441 + 8 * v905;
            v947 = v440;
            v913 = v440;
            v915 += v902 + v442;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v426 = v888 - 1;
          if (v888 == 1)
            goto LABEL_1052;
        }
      case 16:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v929 = (int)v50;
        v443 = v35;
        v444 = (int)v37;
        v445 = v952[0];
        v834 = -(uint64_t)(v36 * v875);
        v853 = -(uint64_t)(v443 * v875);
        v446 = 8 * (int)v50;
        v447 = 2 * (int)v22;
        while (1)
        {
          v889 = v445;
          v448 = (int)v10;
          v449 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v450 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_669;
              if ((_DWORD)v22)
                goto LABEL_664;
            }
            else
            {
              v450 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_664:
                if (*(_WORD *)v53)
                {
                  v451 = PDAdarkenPDA_10650((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v450);
                  v57 = v449;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v451;
                  *(_WORD *)v53 = v452;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v450;
                }
                goto LABEL_669;
              }
            }
            v453 = PDAdarkenPDA_10650((unint64_t)*v950, 0xFFFFu, *v947, v450);
            v57 = v449;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v453;
LABEL_669:
            v454 = &v947[v929];
            if ((unint64_t)v454 >= v57)
              v455 = -(uint64_t)v876;
            else
              v455 = 0;
            v54 += v444 + v455;
            v947 = &v454[v455];
            v950 = (int8x8_t *)((char *)v950 + v446);
            v53 += v447;
            --v448;
          }
          while (v448);
          if (v911)
          {
            v36 = v902;
            v456 = &v913[v905];
            v457 = (unint64_t)v456 >= v911;
            v458 = v853;
            if ((unint64_t)v456 < v911)
              v458 = 0;
            v459 = &v456[v458];
            v460 = v57 + 8 * v458;
            v461 = v834;
            if (!v457)
              v461 = 0;
            v57 = v460 + 8 * v905;
            v947 = v459;
            v913 = v459;
            v915 += v902 + v461;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v445 = v889 - 1;
          if (v889 == 1)
            goto LABEL_1052;
        }
      case 17:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v930 = (int)v50;
        v462 = v35;
        v463 = (int)v37;
        v464 = v952[0];
        v835 = -(uint64_t)(v36 * v875);
        v854 = -(uint64_t)(v462 * v875);
        v465 = 8 * (int)v50;
        v466 = 2 * (int)v22;
        while (1)
        {
          v890 = v464;
          v467 = (int)v10;
          v468 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v469 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_692;
              if ((_DWORD)v22)
                goto LABEL_687;
            }
            else
            {
              v469 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_687:
                if (*(_WORD *)v53)
                {
                  v470 = PDAlightenPDA_10649((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v469);
                  v57 = v468;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v470;
                  *(_WORD *)v53 = v471;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v469;
                }
                goto LABEL_692;
              }
            }
            v472 = PDAlightenPDA_10649((unint64_t)*v950, 0xFFFFu, *v947, v469);
            v57 = v468;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v472;
LABEL_692:
            v473 = &v947[v930];
            if ((unint64_t)v473 >= v57)
              v474 = -(uint64_t)v876;
            else
              v474 = 0;
            v54 += v463 + v474;
            v947 = &v473[v474];
            v950 = (int8x8_t *)((char *)v950 + v465);
            v53 += v466;
            --v467;
          }
          while (v467);
          if (v911)
          {
            v36 = v902;
            v475 = &v913[v905];
            v476 = (unint64_t)v475 >= v911;
            v477 = v854;
            if ((unint64_t)v475 < v911)
              v477 = 0;
            v478 = &v475[v477];
            v479 = v57 + 8 * v477;
            v480 = v835;
            if (!v476)
              v480 = 0;
            v57 = v479 + 8 * v905;
            v947 = v478;
            v913 = v478;
            v915 += v902 + v480;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v464 = v890 - 1;
          if (v890 == 1)
            goto LABEL_1052;
        }
      case 18:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v931 = (int)v50;
        v481 = v35;
        v482 = (int)v37;
        v483 = v952[0];
        v836 = -(uint64_t)(v36 * v875);
        v855 = -(uint64_t)(v481 * v875);
        v484 = 8 * (int)v50;
        v485 = 2 * (int)v22;
        while (1)
        {
          v891 = v483;
          v486 = (int)v10;
          v487 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v488 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_715;
              if ((_DWORD)v22)
                goto LABEL_710;
            }
            else
            {
              v488 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_710:
                if (*(_WORD *)v53)
                {
                  v489 = PDAcolordodgePDA_10651((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v488);
                  v57 = v487;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v489;
                  *(_WORD *)v53 = v490;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v488;
                }
                goto LABEL_715;
              }
            }
            v491 = PDAcolordodgePDA_10651((unint64_t)*v950, 0xFFFFu, *v947, v488);
            v57 = v487;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v491;
LABEL_715:
            v492 = &v947[v931];
            if ((unint64_t)v492 >= v57)
              v493 = -(uint64_t)v876;
            else
              v493 = 0;
            v54 += v482 + v493;
            v947 = &v492[v493];
            v950 = (int8x8_t *)((char *)v950 + v484);
            v53 += v485;
            --v486;
          }
          while (v486);
          if (v911)
          {
            v36 = v902;
            v494 = &v913[v905];
            v495 = (unint64_t)v494 >= v911;
            v496 = v855;
            if ((unint64_t)v494 < v911)
              v496 = 0;
            v497 = &v494[v496];
            v498 = v57 + 8 * v496;
            v499 = v836;
            if (!v495)
              v499 = 0;
            v57 = v498 + 8 * v905;
            v947 = v497;
            v913 = v497;
            v915 += v902 + v499;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v483 = v891 - 1;
          if (v891 == 1)
            goto LABEL_1052;
        }
      case 19:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v932 = (int)v50;
        v500 = v35;
        v501 = (int)v37;
        v502 = v952[0];
        v837 = -(uint64_t)(v36 * v875);
        v856 = -(uint64_t)(v500 * v875);
        v503 = 8 * (int)v50;
        v504 = 2 * (int)v22;
        while (1)
        {
          v892 = v502;
          v505 = (int)v10;
          v506 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v507 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_738;
              if ((_DWORD)v22)
                goto LABEL_733;
            }
            else
            {
              v507 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_733:
                if (*(_WORD *)v53)
                {
                  v508 = PDAcolorburnPDA_10652((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v507);
                  v57 = v506;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v508;
                  *(_WORD *)v53 = v509;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v507;
                }
                goto LABEL_738;
              }
            }
            v510 = PDAcolorburnPDA_10652((unint64_t)*v950, 0xFFFFu, *v947, v507);
            v57 = v506;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v510;
LABEL_738:
            v511 = &v947[v932];
            if ((unint64_t)v511 >= v57)
              v512 = -(uint64_t)v876;
            else
              v512 = 0;
            v54 += v501 + v512;
            v947 = &v511[v512];
            v950 = (int8x8_t *)((char *)v950 + v503);
            v53 += v504;
            --v505;
          }
          while (v505);
          if (v911)
          {
            v36 = v902;
            v513 = &v913[v905];
            v514 = (unint64_t)v513 >= v911;
            v515 = v856;
            if ((unint64_t)v513 < v911)
              v515 = 0;
            v516 = &v513[v515];
            v517 = v57 + 8 * v515;
            v518 = v837;
            if (!v514)
              v518 = 0;
            v57 = v517 + 8 * v905;
            v947 = v516;
            v913 = v516;
            v915 += v902 + v518;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v502 = v892 - 1;
          if (v892 == 1)
            goto LABEL_1052;
        }
      case 20:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v933 = (int)v50;
        v519 = v35;
        v520 = (int)v37;
        v521 = v952[0];
        v838 = -(uint64_t)(v36 * v875);
        v857 = -(uint64_t)(v519 * v875);
        v522 = 8 * (int)v50;
        v523 = 2 * (int)v22;
        while (1)
        {
          v893 = v521;
          v524 = (int)v10;
          v525 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v526 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_761;
              if ((_DWORD)v22)
                goto LABEL_756;
            }
            else
            {
              v526 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_756:
                if (*(_WORD *)v53)
                {
                  v527 = PDAsoftlightPDA_10654((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v526);
                  v57 = v525;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v527;
                  *(_WORD *)v53 = v528;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v526;
                }
                goto LABEL_761;
              }
            }
            v529 = PDAsoftlightPDA_10654((unint64_t)*v950, 0xFFFFu, *v947, v526);
            v57 = v525;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v529;
LABEL_761:
            v530 = &v947[v933];
            if ((unint64_t)v530 >= v57)
              v531 = -(uint64_t)v876;
            else
              v531 = 0;
            v54 += v520 + v531;
            v947 = &v530[v531];
            v950 = (int8x8_t *)((char *)v950 + v522);
            v53 += v523;
            --v524;
          }
          while (v524);
          if (v911)
          {
            v36 = v902;
            v532 = &v913[v905];
            v533 = (unint64_t)v532 >= v911;
            v534 = v857;
            if ((unint64_t)v532 < v911)
              v534 = 0;
            v535 = &v532[v534];
            v536 = v57 + 8 * v534;
            v537 = v838;
            if (!v533)
              v537 = 0;
            v57 = v536 + 8 * v905;
            v947 = v535;
            v913 = v535;
            v915 += v902 + v537;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v521 = v893 - 1;
          if (v893 == 1)
            goto LABEL_1052;
        }
      case 21:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v934 = (int)v50;
        v538 = v35;
        v539 = (int)v37;
        v540 = v952[0];
        v839 = -(uint64_t)(v36 * v875);
        v858 = -(uint64_t)(v538 * v875);
        v541 = 8 * (int)v50;
        v542 = 2 * (int)v22;
        while (1)
        {
          v894 = v540;
          v543 = (int)v10;
          v544 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v545 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_784;
              if ((_DWORD)v22)
                goto LABEL_779;
            }
            else
            {
              v545 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_779:
                if (*(_WORD *)v53)
                {
                  v546 = PDAhardlightPDA_10653((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v545);
                  v57 = v544;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v546;
                  *(_WORD *)v53 = v547;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v545;
                }
                goto LABEL_784;
              }
            }
            v548 = PDAhardlightPDA_10653((unint64_t)*v950, 0xFFFFu, *v947, v545);
            v57 = v544;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v548;
LABEL_784:
            v549 = &v947[v934];
            if ((unint64_t)v549 >= v57)
              v550 = -(uint64_t)v876;
            else
              v550 = 0;
            v54 += v539 + v550;
            v947 = &v549[v550];
            v950 = (int8x8_t *)((char *)v950 + v541);
            v53 += v542;
            --v543;
          }
          while (v543);
          if (v911)
          {
            v36 = v902;
            v551 = &v913[v905];
            v552 = (unint64_t)v551 >= v911;
            v553 = v858;
            if ((unint64_t)v551 < v911)
              v553 = 0;
            v554 = &v551[v553];
            v555 = v57 + 8 * v553;
            v556 = v839;
            if (!v552)
              v556 = 0;
            v57 = v555 + 8 * v905;
            v947 = v554;
            v913 = v554;
            v915 += v902 + v556;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v540 = v894 - 1;
          if (v894 == 1)
            goto LABEL_1052;
        }
      case 22:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v935 = (int)v50;
        v557 = v35;
        v558 = (int)v37;
        v559 = v952[0];
        v840 = -(uint64_t)(v36 * v875);
        v859 = -(uint64_t)(v557 * v875);
        v560 = 8 * (int)v50;
        v561 = 2 * (int)v22;
        while (1)
        {
          v895 = v559;
          v562 = (int)v10;
          v563 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v564 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_807;
              if ((_DWORD)v22)
                goto LABEL_802;
            }
            else
            {
              v564 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_802:
                if (*(_WORD *)v53)
                {
                  v565 = PDAdifferencePDA_10655((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v564);
                  v57 = v563;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v565;
                  *(_WORD *)v53 = v566;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v564;
                }
                goto LABEL_807;
              }
            }
            v567 = PDAdifferencePDA_10655((unint64_t)*v950, 0xFFFFu, *v947, v564);
            v57 = v563;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v567;
LABEL_807:
            v568 = &v947[v935];
            if ((unint64_t)v568 >= v57)
              v569 = -(uint64_t)v876;
            else
              v569 = 0;
            v54 += v558 + v569;
            v947 = &v568[v569];
            v950 = (int8x8_t *)((char *)v950 + v560);
            v53 += v561;
            --v562;
          }
          while (v562);
          if (v911)
          {
            v36 = v902;
            v570 = &v913[v905];
            v571 = (unint64_t)v570 >= v911;
            v572 = v859;
            if ((unint64_t)v570 < v911)
              v572 = 0;
            v573 = &v570[v572];
            v574 = v57 + 8 * v572;
            v575 = v840;
            if (!v571)
              v575 = 0;
            v57 = v574 + 8 * v905;
            v947 = v573;
            v913 = v573;
            v915 += v902 + v575;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v559 = v895 - 1;
          if (v895 == 1)
            goto LABEL_1052;
        }
      case 23:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v936 = (int)v50;
        v576 = v35;
        v577 = (int)v37;
        v578 = v952[0];
        v841 = -(uint64_t)(v36 * v875);
        v860 = -(uint64_t)(v576 * v875);
        v579 = 8 * (int)v50;
        v580 = 2 * (int)v22;
        while (1)
        {
          v896 = v578;
          v581 = (int)v10;
          v582 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v583 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_830;
              if ((_DWORD)v22)
                goto LABEL_825;
            }
            else
            {
              v583 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_825:
                if (*(_WORD *)v53)
                {
                  v584 = PDAexclusionPDA_10656((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v583);
                  v57 = v582;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v584;
                  *(_WORD *)v53 = v585;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v583;
                }
                goto LABEL_830;
              }
            }
            v586 = PDAexclusionPDA_10656((unint64_t)*v950, 0xFFFFu, *v947, v583);
            v57 = v582;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v586;
LABEL_830:
            v587 = &v947[v936];
            if ((unint64_t)v587 >= v57)
              v588 = -(uint64_t)v876;
            else
              v588 = 0;
            v54 += v577 + v588;
            v947 = &v587[v588];
            v950 = (int8x8_t *)((char *)v950 + v579);
            v53 += v580;
            --v581;
          }
          while (v581);
          if (v911)
          {
            v36 = v902;
            v589 = &v913[v905];
            v590 = (unint64_t)v589 >= v911;
            v591 = v860;
            if ((unint64_t)v589 < v911)
              v591 = 0;
            v592 = &v589[v591];
            v593 = v57 + 8 * v591;
            v594 = v841;
            if (!v590)
              v594 = 0;
            v57 = v593 + 8 * v905;
            v947 = v592;
            v913 = v592;
            v915 += v902 + v594;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v578 = v896 - 1;
          if (v896 == 1)
            goto LABEL_1052;
        }
      case 24:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v937 = (int)v50;
        v595 = v35;
        v596 = (int)v37;
        v597 = v952[0];
        v842 = -(uint64_t)(v36 * v875);
        v861 = -(uint64_t)(v595 * v875);
        v598 = 8 * (int)v50;
        v599 = 2 * (int)v22;
        while (1)
        {
          v897 = v597;
          v600 = (int)v10;
          v601 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v602 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_853;
              if ((_DWORD)v22)
                goto LABEL_848;
            }
            else
            {
              v602 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_848:
                if (*(_WORD *)v53)
                {
                  v603 = PDAhuePDA_10657((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v602);
                  v57 = v601;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v603;
                  *(_WORD *)v53 = v604;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v602;
                }
                goto LABEL_853;
              }
            }
            v605 = PDAhuePDA_10657((unint64_t)*v950, 0xFFFFu, *v947, v602);
            v57 = v601;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v605;
LABEL_853:
            v606 = &v947[v937];
            if ((unint64_t)v606 >= v57)
              v607 = -(uint64_t)v876;
            else
              v607 = 0;
            v54 += v596 + v607;
            v947 = &v606[v607];
            v950 = (int8x8_t *)((char *)v950 + v598);
            v53 += v599;
            --v600;
          }
          while (v600);
          if (v911)
          {
            v36 = v902;
            v608 = &v913[v905];
            v609 = (unint64_t)v608 >= v911;
            v610 = v861;
            if ((unint64_t)v608 < v911)
              v610 = 0;
            v611 = &v608[v610];
            v612 = v57 + 8 * v610;
            v613 = v842;
            if (!v609)
              v613 = 0;
            v57 = v612 + 8 * v905;
            v947 = v611;
            v913 = v611;
            v915 += v902 + v613;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v597 = v897 - 1;
          if (v897 == 1)
            goto LABEL_1052;
        }
      case 25:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v938 = (int)v50;
        v614 = v35;
        v615 = (int)v37;
        v616 = v952[0];
        v843 = -(uint64_t)(v36 * v875);
        v862 = -(uint64_t)(v614 * v875);
        v617 = 8 * (int)v50;
        v618 = 2 * (int)v22;
        while (1)
        {
          v898 = v616;
          v619 = (int)v10;
          v620 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v621 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_876;
              if ((_DWORD)v22)
                goto LABEL_871;
            }
            else
            {
              v621 = 0xFFFF;
              if ((_DWORD)v22)
              {
LABEL_871:
                if (*(_WORD *)v53)
                {
                  v622 = PDAsaturationPDA_10658((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v621);
                  v57 = v620;
                  LODWORD(v22) = v943;
                  LODWORD(v37) = v944;
                  *v950 = (int8x8_t)v622;
                  *(_WORD *)v53 = v623;
                }
                else
                {
                  *v950 = (int8x8_t)*v947;
                  *(_WORD *)v53 = v621;
                }
                goto LABEL_876;
              }
            }
            v624 = PDAsaturationPDA_10658((unint64_t)*v950, 0xFFFFu, *v947, v621);
            v57 = v620;
            LODWORD(v22) = v943;
            LODWORD(v37) = v944;
            *v950 = (int8x8_t)v624;
LABEL_876:
            v625 = &v947[v938];
            if ((unint64_t)v625 >= v57)
              v626 = -(uint64_t)v876;
            else
              v626 = 0;
            v54 += v615 + v626;
            v947 = &v625[v626];
            v950 = (int8x8_t *)((char *)v950 + v617);
            v53 += v618;
            --v619;
          }
          while (v619);
          if (v911)
          {
            v36 = v902;
            v627 = &v913[v905];
            v628 = (unint64_t)v627 >= v911;
            v629 = v862;
            if ((unint64_t)v627 < v911)
              v629 = 0;
            v630 = &v627[v629];
            v631 = v57 + 8 * v629;
            v632 = v843;
            if (!v628)
              v632 = 0;
            v57 = v631 + 8 * v905;
            v947 = v630;
            v913 = v630;
            v915 += v902 + v632;
            v54 = v915;
          }
          else
          {
            v36 = v902;
            v947 += v905;
            v54 += v902;
          }
          v950 += v907;
          v53 += 2 * v909;
          v616 = v898 - 1;
          if (v898 == 1)
            goto LABEL_1052;
        }
      case 26:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v939 = (int)v50;
        v633 = v35;
        v634 = (int)v37;
        v635 = v952[0];
        v863 = -(uint64_t)(v633 * v875);
        v636 = 8 * (int)v50;
        v637 = 2 * (int)v22;
        while (1)
        {
          v899 = v635;
          v638 = v57;
          do
          {
            if ((_DWORD)v37)
            {
              v639 = (unsigned __int16)*v54;
              if (!*v54)
                goto LABEL_900;
              if (!(_DWORD)v22)
              {
LABEL_898:
                v641 = PDAluminosityPDA_10659(*v947, v639, (unint64_t)*v950, 0xFFFFu);
                v57 = v638;
                LODWORD(v22) = v943;
                LODWORD(v37) = v944;
                *v950 = (int8x8_t)v641;
                goto LABEL_900;
              }
            }
            else
            {
              v639 = 0xFFFF;
              if (!(_DWORD)v22)
                goto LABEL_898;
            }
            v640 = *v947;
            if (*(_WORD *)v53)
            {
              v640 = PDAluminosityPDA_10659(v640, v639, (unint64_t)*v950, *(unsigned __int16 *)v53);
              v57 = v638;
              LODWORD(v22) = v943;
              LODWORD(v37) = v944;
            }
            *v950 = (int8x8_t)v640;
            *(_WORD *)v53 = v639;
LABEL_900:
            v642 = &v947[v939];
            if ((unint64_t)v642 >= v57)
              v643 = -(uint64_t)v876;
            else
              v643 = 0;
            v54 += v634 + v643;
            v947 = &v642[v643];
            v950 = (int8x8_t *)((char *)v950 + v636);
            v53 += v637;
            LODWORD(v10) = (_DWORD)v10 - 1;
          }
          while ((_DWORD)v10);
          if (v911)
          {
            v644 = &v913[v905];
            v645 = (unint64_t)v644 >= v911;
            v646 = v863;
            if ((unint64_t)v644 < v911)
              v646 = 0;
            v647 = &v644[v646];
            v648 = v57 + 8 * v646;
            v649 = -(uint64_t)(v36 * v875);
            if (!v645)
              v649 = 0;
            v57 = v648 + 8 * v905;
            v947 = v647;
            v913 = v647;
            v915 += v36 + v649;
            v54 = v915;
          }
          else
          {
            v947 += v905;
            v54 += v36;
          }
          LODWORD(v10) = v917;
          v950 += v907;
          v53 += 2 * v909;
          v635 = v899 - 1;
          if (v899 == 1)
          {
LABEL_955:
            v18 = v57;
            v952[0] = 0;
            v5 = (__int16 *)v873;
            v36 = v902;
            goto LABEL_1053;
          }
        }
      case 27:
        v913 = v62;
        v915 = (__int16 *)v61;
        v873 = (unsigned __int16 *)v5;
        v874 = v50;
        v940 = (int)v50;
        v650 = v35;
        v651 = (int)v37;
        v652 = v952[0];
        v844 = -(uint64_t)(v36 * v875);
        v864 = -(uint64_t)(v650 * v875);
        v653 = 8 * (int)v50;
        v654 = 2 * (int)v22;
        break;
      default:
        v913 = v62;
        v915 = (__int16 *)v61;
        v18 = v57;
        goto LABEL_1055;
    }
LABEL_914:
    v900 = v652;
    v655 = (int)v10;
    v656 = v57;
    while (1)
    {
      if ((_DWORD)v37)
      {
        v657 = (unsigned __int16)*v54;
        if (!*v54)
          goto LABEL_923;
        if (!(_DWORD)v22)
          goto LABEL_921;
      }
      else
      {
        v657 = 0xFFFF;
        if (!(_DWORD)v22)
        {
LABEL_921:
          v660 = PDAluminosityPDA_10659((unint64_t)*v950, 0xFFFFu, *v947, v657);
          v57 = v656;
          LODWORD(v22) = v943;
          LODWORD(v37) = v944;
          *v950 = (int8x8_t)v660;
          goto LABEL_923;
        }
      }
      if (*(_WORD *)v53)
      {
        v658 = PDAluminosityPDA_10659((unint64_t)*v950, *(unsigned __int16 *)v53, *v947, v657);
        v57 = v656;
        LODWORD(v22) = v943;
        LODWORD(v37) = v944;
        *v950 = (int8x8_t)v658;
        *(_WORD *)v53 = v659;
      }
      else
      {
        *v950 = (int8x8_t)*v947;
        *(_WORD *)v53 = v657;
      }
LABEL_923:
      v661 = &v947[v940];
      if ((unint64_t)v661 >= v57)
        v662 = -(uint64_t)v876;
      else
        v662 = 0;
      v54 += v651 + v662;
      v947 = &v661[v662];
      v950 = (int8x8_t *)((char *)v950 + v653);
      v53 += v654;
      if (!--v655)
      {
        if (v911)
        {
          v36 = v902;
          v663 = &v913[v905];
          v664 = (unint64_t)v663 >= v911;
          v665 = v864;
          if ((unint64_t)v663 < v911)
            v665 = 0;
          v666 = &v663[v665];
          v667 = v57 + 8 * v665;
          v668 = v844;
          if (!v664)
            v668 = 0;
          v57 = v667 + 8 * v905;
          v947 = v666;
          v913 = v666;
          v915 += v902 + v668;
          v54 = v915;
        }
        else
        {
          v36 = v902;
          v947 += v905;
          v54 += v902;
        }
        v950 += v907;
        v53 += 2 * v909;
        v652 = v900 - 1;
        if (v900 == 1)
        {
LABEL_1052:
          v18 = v57;
          v952[0] = 0;
          v5 = (__int16 *)v873;
LABEL_1053:
          v35 = v905;
LABEL_1054:
          v50 = v874;
LABEL_1055:
          v52 = v877;
LABEL_1056:
          v55 = v911;
          if (!v52)
            return 1;
          v951 = 0;
LABEL_1058:
          if (!shape_enum_clip_next(v52, (int *)&v951 + 1, &v951, v962, v952))
          {
            v49 = (void *)v52;
            goto LABEL_1080;
          }
          v877 = v52;
          if (v55)
          {
            v911 = v55;
            v21 = v878;
            v950 = (int8x8_t *)(v869 + 8 * v878 * (int)v951 + 8 * SHIDWORD(v951));
            v765 = ((int)v951 + *(_DWORD *)(v867 + 60)) % v875;
            v56 = (unint64_t *)v962[0];
            v766 = (HIDWORD(v951) + *(_DWORD *)(v867 + 56)) % v876;
            v767 = v868 + 8 * v35 * v765;
            v62 = (uint64_t *)(v767 + 8 * v766);
            v57 = v767 + 8 * v876;
            v22 = v943;
            v768 = v909;
            if ((_DWORD)v943)
              v768 = v870 - v962[0];
            v909 = v768;
            if ((_DWORD)v943)
              v53 = &v871[2 * v870 * (int)v951 + 2 * SHIDWORD(v951)];
            if ((_DWORD)v944)
              v37 = v944;
            else
              v37 = 0;
            if ((_DWORD)v944)
              v54 = &v5[v36 * v765 + v766];
            v61 = (uint64_t)v915;
            if ((_DWORD)v944)
              v61 = (uint64_t)&v5[v36 * v765 + v766];
            LODWORD(v10) = v962[0];
            v947 = v62;
            v823 = ((int)v951 + *(_DWORD *)(v867 + 60)) % v875;
            v824 = (HIDWORD(v951) + *(_DWORD *)(v867 + 56)) % v876;
          }
          else
          {
            v911 = 0;
            v769 = HIDWORD(v951) * v50;
            LODWORD(v10) = v962[0];
            v770 = v962[0] * v50;
            v21 = v878;
            v950 = (int8x8_t *)(v869 + 8 * v878 * (int)v951 + 8 * HIDWORD(v951) * (int)v50);
            v56 = (unint64_t *)(v962[0] * (int)v50);
            v947 = (uint64_t *)(v868 + 8 * (int)v951 * v876 + 8 * HIDWORD(v951) * (int)v50);
            v35 = v876 - v962[0] * (int)v50;
            v22 = v943;
            v37 = v944;
            v771 = v909;
            if ((_DWORD)v943)
              v771 = v870 - v770;
            v909 = v771;
            if ((_DWORD)v943)
              v53 = &v871[2 * v870 * (int)v951 + 2 * v769];
            v772 = (uint64_t)&v5[(int)v951 * v875 + v769];
            v773 = v875 - v770;
            if ((_DWORD)v944)
            {
              v36 = v773;
              v54 = (__int16 *)v772;
            }
            v57 = v18;
            v62 = v913;
            v61 = (uint64_t)v915;
          }
          goto LABEL_353;
        }
        goto LABEL_914;
      }
    }
  }
  v15 = *(_DWORD *)(v3 + 128);
  if ((v15 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      cmyk64_mark_constmask(v3, v7);
    else
      cmyk64_mark_pixelmask(v3, v7);
    return 1;
  }
  v23 = *(_DWORD *)(v3 + 112);
  v24 = *(_DWORD *)(v3 + 116);
  v25 = (v23 + 15) & 0xFFFFFFF0;
  v26 = v25 * v24;
  if ((int)v26 <= 4096)
  {
    v28 = v962;
LABEL_38:
    CGSConvertBitsToMask(v14, *(_DWORD *)(v9 + 124), v28, v25, v23, v24, v15);
    v44 = *(_OWORD *)(v9 + 112);
    v958 = *(_OWORD *)(v9 + 96);
    v959 = v44;
    v45 = *(_OWORD *)(v9 + 144);
    v960 = *(_OWORD *)(v9 + 128);
    v961 = v45;
    v46 = *(_OWORD *)(v9 + 48);
    v954 = *(_OWORD *)(v9 + 32);
    v955 = v46;
    v47 = *(_OWORD *)(v9 + 80);
    v956 = *(_OWORD *)(v9 + 64);
    v957 = v47;
    v48 = *(_OWORD *)(v9 + 16);
    *(_OWORD *)v952 = *(_OWORD *)v9;
    v953 = v48;
    HIDWORD(v959) = (v23 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v960 + 1) = v28;
    if (BYTE1(v952[0]) << 8 == 1024)
      cmyk64_mark_constmask((uint64_t)v952, v7);
    else
      cmyk64_mark_pixelmask((uint64_t)v952, v7);
    if (v28 != (_BYTE *)v962)
    {
      v49 = v28;
      goto LABEL_1080;
    }
    return 1;
  }
  v27 = malloc_type_malloc(v26, 0x8303D2FuLL);
  if (v27)
  {
    v28 = v27;
    v14 = *(uint16x4_t **)(v9 + 136);
    v15 = *(_DWORD *)(v9 + 128);
    goto LABEL_38;
  }
  return 1;
}

uint64_t cmyk64_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL4 v7;
  signed int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  int v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  int v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _OWORD v46[64];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  memset(v46, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*(_QWORD *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v29, (uint64_t)v46) < 1)
    return 0xFFFFFFFFLL;
  v18 = 269501476;
  v19 = *(_DWORD *)a3;
  *((_QWORD *)&v29 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 269501476)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(_QWORD *)&v29 = *(_QWORD *)&CMYK16_image_sample[2 * v20 + 2];
      if ((_QWORD)v29)
      {
LABEL_28:
        DWORD2(v29) = v18;
        if ((v21 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v30) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_RGB32;
              goto LABEL_51;
            case 1u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_RGB32;
              goto LABEL_53;
            case 2u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_W8;
              goto LABEL_51;
            case 3u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_RGB24;
              goto LABEL_51;
            case 4u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_rgb32;
LABEL_51:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 0;
              break;
            case 5u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_rgb32;
LABEL_53:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 8;
              break;
            default:
              goto LABEL_29;
          }
          cmyk64_image_mark_image(v26, (uint64_t)&v29, v27, v28, (void (*)(_QWORD, _QWORD))v25);
          return 1;
        }
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(_QWORD *)&v29 = *(_QWORD *)&CMYK8_image_sample[2 * v20 + 2];
        if ((_QWORD)v29)
        {
          v18 = 134759444;
          v23 = 8;
LABEL_27:
          LODWORD(v30) = v23;
          goto LABEL_28;
        }
      }
      *(_QWORD *)&v29 = *(_QWORD *)&CMYKF_image_sample[2 * v20 + 2];
      if ((_QWORD)v29)
      {
        v18 = 538985509;
        v23 = 20;
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(_QWORD)v40 && (~DWORD1(v30) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((BYTE4(v30) & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      cmyk64_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(_QWORD *)&v29 = cmyk64_sample_cmyk64;
LABEL_29:
  cmyk64_image_mark((uint64_t)a2, (uint64_t)&v29, v8, v17);
  return 1;
}

uint64_t cmyk64_shade(uint64_t a1, __n128 a2)
{
  uint64_t *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  signed int v11;
  __n128 v13;
  void *v14;
  unint64_t v15;
  _BYTE *v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38[2];
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[2];
  int v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[40];
  uint64_t v47;

  v2 = (uint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v7 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v8 = *v2;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  v9 = *(_QWORD *)(v8 + 56);
  v10 = *v3;
  if (!*((_QWORD *)v3 + 12))
  {
    if (*(_QWORD *)(v4 + 72))
      v7 = 0;
    else
      v7 = *(float *)(v4 + 4) >= 1.0;
  }
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v11 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(_QWORD *)(v5 + 16))
    {
      v14 = cmyk64_shade_radial_CMYK;
    }
    else if (*(_QWORD *)(v5 + 24))
    {
      v14 = cmyk64_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      v14 = cmyk64_shade_axial_CMYK;
    }
    else
    {
      v14 = cmyk64_shade_custom_CMYK;
    }
    *(_QWORD *)&v17[0] = v14;
    if ((_QWORD)v40)
    {
      *((_QWORD *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    v15 = *((_QWORD *)&v19 + 1) * v19;
    if ((uint64_t)(*((_QWORD *)&v19 + 1) * v19) <= 384)
    {
      v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(_BYTE *)(v5 + 1))
        *(_QWORD *)&v39 = &_blt_shade_samples_noise;
      goto LABEL_29;
    }
    v16 = malloc_type_malloc(10 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      v15 = *((_QWORD *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)&v17[0])
    return 0xFFFFFFFFLL;
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  cmyk64_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1]))
    free(v38[1]);
  return 1;
}

void cmyk64_shade_radial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float *v12;
  float v13;
  float v14;
  float v15;
  float v16;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  float v27;
  float v28;
  int v29;
  int v30;
  float v31;
  float v32;
  float v33;
  float v34;
  _WORD *i;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  BOOL v43;
  float v44;
  BOOL v45;
  int v46;
  float v47;
  uint64_t *v48;
  uint64_t v49;
  float v50;
  float v51;
  float v52;
  uint64_t *v53;
  int v54;
  float v55;
  float v56;
  float v57;
  float v59;
  float v60;
  float v61;
  int v62;
  int v63;
  uint64_t v65;
  __int16 v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t *v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t *v76;
  __int16 v77;
  uint64_t v78;
  int v79;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(a1 + 284);
  v6 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v7 = v6 * (float)a2;
  v8 = v6 * (float)a3;
  v9 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v8) + (float)(v4 * v7));
  v10 = *(float *)(a1 + 300) + (float)((float)(v8 * *(float *)(a1 + 292)) + (float)(v5 * v7));
  v12 = *(float **)(a1 + 400);
  v13 = *(float *)(a1 + 336);
  v14 = *(float *)(a1 + 344);
  v15 = *(float *)(a1 + 304);
  v16 = *(float *)(a1 + 308);
  v17 = *(_DWORD *)(a1 + 324);
  v18 = v12[2];
  v19 = v12[4];
  v20 = v12[5];
  v21 = v12[7];
  v24 = a1 + 144;
  v22 = *(_BYTE **)(a1 + 144);
  v23 = *(_QWORD *)(v24 + 8);
  v25 = *(uint64_t **)(a1 + 376);
  v26 = *(_QWORD *)(a1 + 360);
  if (v18 != 0.0 || v21 != 0.0 || v5 != 0.0)
  {
    v30 = *(_DWORD *)(a1 + 320);
    v31 = v12[3];
    v32 = v12[8];
    v33 = -v12[6];
    v34 = v16 - v15;
    for (i = (_WORD *)(v23 + 8); ; i += 8)
    {
      v36 = v33 + (float)((float)(v9 + v9) * v18);
      v37 = (float)((float)(v10 * v10) + (float)(v9 * v9)) - v21;
      if (v20 == 0.0)
      {
        v44 = v37 / v36;
      }
      else
      {
        v38 = (float)((float)(v20 * -4.0) * v37) + (float)(v36 * v36);
        if (v38 < 0.0)
          goto LABEL_39;
        v39 = sqrtf(v38);
        v40 = v32 * (float)(v36 - v39);
        v41 = v36 + v39;
        v42 = v32 * v41;
        v43 = (float)(v32 * v41) <= v40;
        if ((float)(v32 * v41) <= v40)
          v44 = v32 * v41;
        else
          v44 = v40;
        if (v43)
          v42 = v40;
        if (v42 < 0.0)
        {
          v45 = v42 < v31;
LABEL_25:
          v46 = v30;
          if (v45)
            goto LABEL_39;
LABEL_26:
          if ((v46 & 0x80000000) == 0)
            goto LABEL_38;
          goto LABEL_39;
        }
        if (v42 <= 1.0)
        {
          v47 = v15 + (float)(v42 * v34);
          goto LABEL_37;
        }
        if ((v17 & 0x80000000) == 0)
        {
          v46 = v17;
          if (v42 <= v19)
          {
LABEL_38:
            v48 = (uint64_t *)(v26 + 10 * v46);
LABEL_40:
            v49 = *v48;
            LOWORD(v48) = *((_WORD *)v48 + 4);
            *((_QWORD *)i - 1) = v49;
            *i = (_WORD)v48;
            LOBYTE(v48) = -1;
            goto LABEL_41;
          }
        }
      }
      if (v44 < 0.0)
      {
        v45 = v44 < v31;
        goto LABEL_25;
      }
      if (v44 > 1.0)
      {
        v46 = v17;
        if (v44 > v19)
          goto LABEL_39;
        goto LABEL_26;
      }
      v47 = v15 + (float)(v44 * v34);
LABEL_37:
      v46 = (int)(float)(v14 * (float)(v47 - v13));
      if ((v46 & 0x80000000) == 0)
        goto LABEL_38;
LABEL_39:
      v48 = v25;
      if (v25)
        goto LABEL_40;
LABEL_41:
      v9 = v4 + v9;
      v10 = v5 + v10;
      *v22++ = (_BYTE)v48;
      if (!--a4)
        return;
    }
  }
  v27 = v10 * v10;
  v28 = -v20;
  if (v27 <= (float)-v20)
  {
    v50 = fabsf(v12[8]);
    v51 = v20 * -4.0;
    v52 = v16 - v15;
    v53 = (uint64_t *)(v26 + 10 * v17);
    v54 = a4 + 2;
    while (1)
    {
      v55 = v27 + (float)(v9 * v9);
      v56 = v4 + v9;
      v57 = v27 + (float)(v56 * v56);
      if (v55 > v28 && v57 > v28)
      {
        if (v17 < 0)
        {
          if (!v25)
          {
            v72 = 0;
            LOBYTE(v71) = 0;
            goto LABEL_65;
          }
          v66 = *((_WORD *)v25 + 4);
          v67 = *v25;
        }
        else
        {
          v66 = *((_WORD *)v53 + 4);
          v67 = *v53;
        }
        *(_QWORD *)v23 = v67;
        *(_WORD *)(v23 + 8) = v66;
        goto LABEL_63;
      }
      v59 = sqrtf(v51 * v57);
      v60 = v50 * sqrtf(v51 * v55);
      v61 = v50 * v59;
      v62 = (int)(float)(v14 * (float)((float)(v15 + (float)(v60 * v52)) - v13));
      v63 = (int)(float)(v14 * (float)((float)(v15 + (float)((float)(v50 * v59) * v52)) - v13));
      if (v60 <= 1.0 && v61 <= 1.0)
      {
        v68 = (uint64_t *)(v26 + 10 * v62);
        v69 = *v68;
        LOWORD(v68) = *((_WORD *)v68 + 4);
        v70 = (uint64_t *)(v26 + 10 * v63);
        v67 = *v70;
        v66 = *((_WORD *)v70 + 4);
        *(_QWORD *)v23 = v69;
        *(_WORD *)(v23 + 8) = (_WORD)v68;
LABEL_63:
        LOBYTE(v71) = -1;
        goto LABEL_64;
      }
      if (v60 <= 1.0)
      {
        if ((v62 & 0x80000000) == 0)
        {
          v65 = 5 * v62;
LABEL_69:
          v71 = (uint64_t *)(v26 + 2 * v65);
LABEL_71:
          v73 = *v71;
          LOWORD(v71) = *((_WORD *)v71 + 4);
          *(_QWORD *)v23 = v73;
          *(_WORD *)(v23 + 8) = (_WORD)v71;
          LOBYTE(v71) = -1;
          goto LABEL_72;
        }
      }
      else if (v60 <= v19)
      {
        v65 = 5 * v17;
        if ((v17 & 0x80000000) == 0)
          goto LABEL_69;
      }
      v71 = v25;
      if (v25)
        goto LABEL_71;
LABEL_72:
      if (v61 <= 1.0)
      {
        if (v63 < 0)
          goto LABEL_79;
        v74 = 5 * v63;
      }
      else if (v61 > v19 || (v74 = 5 * v17, v17 < 0))
      {
LABEL_79:
        if (!v25)
        {
          v72 = 0;
          goto LABEL_65;
        }
        v67 = *v25;
        v66 = *((_WORD *)v25 + 4);
        goto LABEL_64;
      }
      v75 = (uint64_t *)(v26 + 2 * v74);
      v67 = *v75;
      v66 = *((_WORD *)v75 + 4);
LABEL_64:
      *(_QWORD *)(v23 + 16) = v67;
      *(_WORD *)(v23 + 24) = v66;
      v72 = -1;
LABEL_65:
      v9 = v4 + v56;
      v23 += 32;
      *v22 = (_BYTE)v71;
      v22[1] = v72;
      v22 += 2;
      v54 -= 2;
      if (v54 <= 2)
        return;
    }
  }
  if (v25 || (v17 & 0x80000000) == 0)
  {
    if (v17 >= 0)
      v76 = (uint64_t *)(v26 + 10 * v17);
    else
      v76 = *(uint64_t **)(a1 + 376);
    v77 = *((_WORD *)v76 + 4);
    v78 = *v76;
    v79 = a4 + 4;
    do
    {
      *(_QWORD *)v23 = v78;
      *(_WORD *)(v23 + 8) = v77;
      *(_QWORD *)(v23 + 16) = v78;
      *(_WORD *)(v23 + 24) = v77;
      *(_QWORD *)(v23 + 32) = v78;
      *(_WORD *)(v23 + 40) = v77;
      *(_QWORD *)(v23 + 48) = v78;
      v79 -= 4;
      *(_WORD *)(v23 + 56) = v77;
      v23 += 64;
      *(_DWORD *)v22 = -1;
      v22 += 4;
    }
    while (v79 > 4);
  }
  else
  {
    if (a4 >= 4)
      v29 = 4;
    else
      v29 = a4;
    bzero(v22, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t cmyk64_shade_conic_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  float v16;
  float v17;
  unsigned int v18;
  float v19;
  unsigned int v20;
  float v21;
  BOOL v22;
  float v23;
  float v24;
  unsigned __int16 *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned __int16 *v31;
  uint64_t result;
  unint64_t v33;
  float v34;
  float v35;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  v9 = *(float *)(a1 + 284);
  v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  v34 = *(float *)(a1 + 336);
  v35 = *(float *)(a1 + 304);
  v12 = *(float *)(a1 + 344);
  v13 = *(_QWORD *)(a1 + 360);
  v15 = *(_BYTE **)(a1 + 144);
  v14 = *(_QWORD *)(a1 + 152);
  v16 = *(float *)(a1 + 308) - v35;
  do
  {
    v17 = v12 * (float)((float)(v35 + (float)((float)((float)(atan2f(v10, v8) * 0.15915) + 0.5) * v16)) - v34);
    v18 = vcvtms_s32_f32(v17);
    v19 = ceilf(v17);
    v20 = vcvtms_s32_f32(v12 + v17);
    v21 = v17 - (float)(int)floorf(v17);
    if (v17 < 0.0)
      v18 = v20;
    v22 = v17 <= v12;
    v23 = ceilf(v17 - v12);
    v24 = (float)(v21 * 255.0) + 0.5;
    if (v22)
      v23 = v19;
    v25 = (unsigned __int16 *)(v13 + 2 * (int)(5 * v18));
    v26 = *v25;
    v27 = v25[1];
    v28 = v25[2];
    v29 = v25[3];
    v30 = 255 - (int)v24;
    v31 = (unsigned __int16 *)(v13 + 10 * (int)v23);
    result = (int)v24 * v31[1];
    LODWORD(v25) = (v31[4] * (int)v24 + v30 * v25[4]) >> 8;
    v33 = ((unint64_t)(unsigned __int16)(((int)v24 * v31[2] + v30 * v28) >> 8) << 32) | ((unint64_t)((v31[3] * (int)v24 + v30 * v29) >> 8) << 48) | (((_DWORD)result + v30 * v27) << 8) & 0xFFFF0000 | (unsigned __int16)(((int)v24 * *v31 + v30 * v26) >> 8);
    *(_WORD *)(v14 + 8) = (_WORD)v25;
    *(_QWORD *)v14 = v33;
    v14 += 16;
    v8 = v4 + v8;
    v10 = v9 + v10;
    *v15++ = -1;
    --a4;
  }
  while (a4);
  return result;
}

float cmyk64_shade_custom_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  int v20;
  _BYTE *v21;
  _WORD *v22;
  uint64_t v23;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;

  result = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(result * v6));
  v9 = *(float *)(a1 + 284);
  v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  v11 = *(float *)(a1 + 304);
  v12 = *(float *)(a1 + 308);
  v13 = *(float *)(a1 + 312);
  v14 = *(float *)(a1 + 316);
  v15 = *(float *)(a1 + 336);
  v16 = *(float *)(a1 + 348);
  v17 = *(float *)(a1 + 344);
  v18 = *(float *)(a1 + 356);
  v19 = *(_QWORD *)(a1 + 376);
  v20 = 5 * *(_DWORD *)(a1 + 48);
  v21 = *(_BYTE **)(a1 + 144);
  v22 = (_WORD *)(*(_QWORD *)(a1 + 152) + 8);
  v23 = *(_QWORD *)(a1 + 360);
  do
  {
    if (v8 < v11 || v10 < v13)
    {
      v25 = 0;
      v26 = 0;
    }
    else
    {
      v25 = v8 == v12;
      v26 = v8 < v12;
    }
    if (v26 || v25)
    {
      v27 = v10 == v14;
      v28 = v10 < v14;
    }
    else
    {
      v27 = 0;
      v28 = 0;
    }
    if (v28 || v27)
    {
      v29 = v23 + 2 * v20 * (int)(float)(v18 * (float)(v10 - v16)) + 10 * (int)(float)(v17 * (float)(v8 - v15));
LABEL_15:
      v30 = *(_QWORD *)v29;
      LOWORD(v29) = *(_WORD *)(v29 + 8);
      *((_QWORD *)v22 - 1) = v30;
      *v22 = v29;
      LOBYTE(v29) = -1;
      goto LABEL_16;
    }
    v29 = v19;
    if (v19)
      goto LABEL_15;
LABEL_16:
    v8 = result + v8;
    v10 = v9 + v10;
    *v21++ = v29;
    v22 += 8;
    --a4;
  }
  while (a4);
  return result;
}

void cmyk64_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v7;
  float v8;
  float v9;
  float v10;
  int v11;
  int v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  _WORD *i;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  __int16 v25;
  uint64_t v26;
  int v27;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a3))
             + (float)(v4 * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a2)));
  v7 = *(float *)(a1 + 336);
  v8 = *(float *)(a1 + 344);
  v9 = *(float *)(a1 + 304);
  v10 = *(float *)(a1 + 308);
  v11 = *(_DWORD *)(a1 + 320);
  v12 = *(_DWORD *)(a1 + 324);
  v15 = a1 + 144;
  v13 = *(_DWORD **)(a1 + 144);
  v14 = *(_QWORD *)(v15 + 8);
  v16 = *(uint64_t **)(a1 + 376);
  v17 = *(_QWORD *)(a1 + 360);
  if (v4 != 0.0)
  {
    for (i = (_WORD *)(v14 + 8); ; i += 8)
    {
      v20 = v11;
      if (v5 >= v9)
      {
        v20 = v12;
        if (v5 <= v10)
          v20 = (int)(float)(v8 * (float)(v5 - v7));
      }
      if ((v20 & 0x80000000) == 0)
        break;
      v21 = v16;
      if (v16)
        goto LABEL_18;
LABEL_19:
      v5 = v4 + v5;
      *(_BYTE *)v13 = (_BYTE)v21;
      v13 = (_DWORD *)((char *)v13 + 1);
      if (!--a4)
        return;
    }
    v21 = (uint64_t *)(v17 + 10 * v20);
LABEL_18:
    v22 = *v21;
    LOWORD(v21) = *((_WORD *)v21 + 4);
    *((_QWORD *)i - 1) = v22;
    *i = (_WORD)v21;
    LOBYTE(v21) = -1;
    goto LABEL_19;
  }
  if (v5 >= v9)
  {
    v11 = v12;
    if (v5 <= v10)
      v11 = (int)(float)(v8 * (float)(v5 - v7));
  }
  if ((v11 & 0x80000000) == 0 || v16)
  {
    v23 = (uint64_t *)(v17 + 10 * v11);
    if (v11 < 0)
      v24 = v16;
    else
      v24 = v23;
    v25 = *((_WORD *)v24 + 4);
    v26 = *v24;
    v27 = a4 + 4;
    do
    {
      *(_QWORD *)v14 = v26;
      *(_WORD *)(v14 + 8) = v25;
      *(_QWORD *)(v14 + 16) = v26;
      *(_WORD *)(v14 + 24) = v25;
      *(_QWORD *)(v14 + 32) = v26;
      *(_WORD *)(v14 + 40) = v25;
      *(_QWORD *)(v14 + 48) = v26;
      v27 -= 4;
      *(_WORD *)(v14 + 56) = v25;
      v14 += 64;
      *v13++ = -1;
    }
    while (v27 > 4);
  }
  else
  {
    if (a4 >= 4)
      v18 = 4;
    else
      v18 = a4;
    bzero(v13, ((a4 - v18 + 3) & 0xFFFFFFFC) + 4);
  }
}

void cmyk64_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  unint64_t v4;
  uint64_t v7;
  float v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  __int16 *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int8x8_t *v35;
  uint64_t v36;
  int v37;
  int v38;
  _QWORD *v39;
  uint64_t v40;
  void *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  void *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  void *v52;
  int v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  void (*v57)(_QWORD *, uint64_t);
  uint64_t v58;
  _BYTE *v59;
  unsigned int v60;
  int v61;
  _BYTE *v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  float *v69;
  float v70;
  float v71;
  int v72;
  int v73;
  int v74;
  unsigned int v75;
  float v76;
  int v77;
  float v78;
  int v79;
  float v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _WORD *v87;
  uint64_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  unint64_t v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  float *v99;
  float v100;
  uint64_t v101;
  float v102;
  int v103;
  float v104;
  int v105;
  float v106;
  int v107;
  float v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _WORD *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  int v117;
  unsigned __int8 *v118;
  uint64_t v119;
  int v120;
  int v121;
  int v122;
  unsigned int v123;
  int32x2_t v124;
  uint32x2_t v125;
  int32x2_t v126;
  uint32x2_t v127;
  int v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  _BYTE *v132;
  unsigned int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _BYTE *v141;
  unsigned int v142;
  uint64_t v143;
  int v144;
  int v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  int v151;
  int v152;
  int v153;
  unsigned __int16 *v154;
  int v155;
  unsigned __int8 *v156;
  int v157;
  int32x2_t v158;
  int v159;
  unsigned int v160;
  int32x2_t v161;
  uint32x2_t v162;
  int32x2_t v163;
  uint32x2_t v164;
  int v165;
  unsigned __int16 *v166;
  int v167;
  int v168;
  int32x2_t v169;
  int v170;
  unsigned int v171;
  int32x2_t v172;
  uint32x2_t v173;
  int32x2_t v174;
  uint32x2_t v175;
  int v176;
  unsigned __int16 *v177;
  int v178;
  int v179;
  unint64_t v180;
  int v181;
  unint64_t v182;
  unsigned int v183;
  int v184;
  unsigned __int16 *v185;
  int v186;
  int v187;
  int32x2_t v188;
  int v189;
  unsigned int v190;
  int32x2_t v191;
  uint32x2_t v192;
  int32x2_t v193;
  uint32x2_t v194;
  uint64_t v195;
  unsigned __int16 *v196;
  int v197;
  unsigned __int8 *v198;
  int v199;
  int v200;
  unsigned int v201;
  int32x2_t v202;
  uint32x2_t v203;
  int32x2_t v204;
  uint32x2_t v205;
  uint64_t v206;
  unsigned __int16 *v207;
  int v208;
  int v209;
  int v210;
  unsigned int v211;
  int32x2_t v212;
  uint32x2_t v213;
  int32x2_t v214;
  uint32x2_t v215;
  int v216;
  unsigned __int16 *v217;
  int v218;
  int v219;
  unint64_t v220;
  unsigned __int16 v221;
  int v222;
  unint64_t v223;
  unsigned int v224;
  int v225;
  unsigned __int16 *v226;
  int v227;
  int v228;
  unint64_t v229;
  int v230;
  unint64_t v231;
  unsigned int v232;
  uint64_t v233;
  _WORD *v234;
  int v235;
  int v236;
  unint64_t v237;
  int v238;
  unsigned int v239;
  uint64_t v240;
  _WORD *v241;
  int v242;
  int v243;
  unint64_t v244;
  int v245;
  unsigned int v246;
  unsigned __int16 *v247;
  unsigned __int8 *v248;
  int v249;
  int v250;
  int v251;
  int v252;
  unint64_t v253;
  unint64_t v254;
  __int16 v255;
  __int16 v256;
  unsigned __int16 *v257;
  int v258;
  int v259;
  int v260;
  int v261;
  unint64_t v262;
  unint64_t v263;
  __int16 v264;
  __int16 v265;
  unsigned __int16 *v266;
  int v267;
  int v268;
  int v269;
  int v270;
  unint64_t v271;
  unint64_t v272;
  __int16 v273;
  __int16 v274;
  unsigned __int16 *v275;
  int v276;
  int v277;
  int v278;
  int v279;
  unint64_t v280;
  unint64_t v281;
  __int16 v282;
  __int16 v283;
  unsigned __int16 *v284;
  int v285;
  int v286;
  int v287;
  int v288;
  unint64_t v289;
  unint64_t v290;
  __int16 v291;
  __int16 v292;
  unsigned __int16 *v293;
  int v294;
  int v295;
  int v296;
  int v297;
  unint64_t v298;
  unint64_t v299;
  __int16 v300;
  __int16 v301;
  unsigned __int16 *v302;
  int v303;
  int v304;
  int v305;
  int v306;
  unint64_t v307;
  unint64_t v308;
  __int16 v309;
  __int16 v310;
  unsigned __int16 *v311;
  int v312;
  int v313;
  int v314;
  int v315;
  unint64_t v316;
  unint64_t v317;
  __int16 v318;
  __int16 v319;
  unsigned __int16 *v320;
  int v321;
  int v322;
  int v323;
  int v324;
  unint64_t v325;
  unint64_t v326;
  __int16 v327;
  __int16 v328;
  unsigned __int16 *v329;
  int v330;
  int v331;
  int v332;
  int v333;
  unint64_t v334;
  unint64_t v335;
  __int16 v336;
  __int16 v337;
  unsigned __int16 *v338;
  int v339;
  int v340;
  int v341;
  int v342;
  unint64_t v343;
  unint64_t v344;
  __int16 v345;
  __int16 v346;
  unsigned __int16 *v347;
  int v348;
  int v349;
  int v350;
  int v351;
  unint64_t v352;
  unint64_t v353;
  __int16 v354;
  __int16 v355;
  unsigned __int16 *v356;
  int v357;
  int v358;
  int v359;
  int v360;
  unint64_t v361;
  unint64_t v362;
  __int16 v363;
  __int16 v364;
  unsigned __int16 *v365;
  int v366;
  int v367;
  int v368;
  int v369;
  unint64_t v370;
  unint64_t v371;
  __int16 v372;
  unsigned __int16 *v373;
  int v374;
  int v375;
  int v376;
  int v377;
  unint64_t v378;
  unint64_t v379;
  __int16 v380;
  __int16 v381;
  int v382;
  int v383;
  int32x2_t v384;
  int32x2_t v385;
  int32x2_t v386;
  int32x2_t v387;
  uint32x2_t v388;
  int32x2_t v389;
  uint32x2_t v390;
  uint32x2_t v391;
  int32x2_t v392;
  int32x2_t v393;
  int8x8_t v394;
  unsigned __int8 *v395;
  unsigned int v396;
  int8x8_t *v397;
  unsigned int *v398;
  int v399;
  int8x8_t *v400;
  int v401;
  uint64_t v402;
  _BYTE *v403;
  int8x8_t *v404;
  unsigned int v405;
  int v406;
  unsigned int v407;
  int v408;
  int v409;
  unsigned int v410;
  unsigned int v411;
  uint64_t v412;
  unint64_t v413;
  int v414;
  unsigned __int16 *v415;
  int v416;
  int v417;
  int32x2_t v418;
  int32x2_t v419;
  int32x2_t v420;
  int32x2_t v421;
  uint32x2_t v422;
  int32x2_t v423;
  uint32x2_t v424;
  uint32x2_t v425;
  int32x2_t v426;
  int32x2_t v427;
  int8x8_t v428;
  unsigned __int16 *v429;
  int v430;
  int v431;
  int32x2_t v432;
  int32x2_t v433;
  int32x2_t v434;
  int32x2_t v435;
  uint32x2_t v436;
  int32x2_t v437;
  uint32x2_t v438;
  uint32x2_t v439;
  int32x2_t v440;
  int32x2_t v441;
  int8x8_t v442;
  _WORD *v443;
  int v444;
  int v445;
  unint64_t v446;
  int v447;
  unsigned int v448;
  int v449;
  int v450;
  uint64_t v451;
  int v452;
  unsigned int v453;
  int v454;
  unint64_t v455;
  _BYTE *v456;
  unint64_t v457;
  uint64_t v458;
  _BYTE *v459;
  uint64_t v460;
  int v461;
  int v462;
  int v463;
  int v464;
  unint64_t v465;
  unint64_t v466;
  unint64_t v467;
  int v468;
  int v469;
  unsigned __int8 *v470;
  int v471;
  int v472;
  int v473;
  unsigned int v474;
  unsigned int v475;
  uint64_t v476;
  unint64_t v477;
  int v478;
  int v479;
  uint64_t v480;
  int v481;
  int v482;
  uint64_t v483;
  unint64_t v484;
  uint64_t v485;
  uint64_t v486;
  void *v487;
  uint64_t v488;
  uint64_t v489;
  unint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  int v496;
  _QWORD *v497;
  int *v498;
  void *v499;
  int v500;
  uint64_t v501;
  uint64_t v502;
  unsigned int v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;

  v506 = *MEMORY[0x1E0C80C00];
  v504 = *(unsigned int *)(a1 + 4);
  v491 = (int)v504;
  v4 = ((int)v504 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 > 0x1FFFFFF)
    return;
  v7 = *(_QWORD *)(a1 + 40);
  v505 = *(_QWORD *)(a1 + 48);
  v8 = *(float *)(a2 + 184);
  v9 = *(int **)(a1 + 136);
  v10 = *(_QWORD *)(a2 + 104);
  v501 = *(_QWORD *)(a2 + 96);
  v502 = v10;
  v11 = *(int *)(a1 + 24);
  v12 = *(int *)(a1 + 28);
  v14 = *(int *)(a1 + 16);
  v13 = (void *)*(int *)(a1 + 20);
  v498 = v9;
  v499 = v13;
  v15 = *(int *)(a1 + 12);
  v500 = *(_DWORD *)(a1 + 8);
  v497 = (_QWORD *)a2;
  v16 = *(int *)(a2 + 16);
  v17 = (v16 + 18) * v4;
  if (v17 > 65439)
  {
    v20 = (char *)malloc_type_calloc(1uLL, v17 + 96, 0x3023562EuLL);
    v19 = v20;
    v22 = v20;
    v23 = v497;
    if (!v20)
      return;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1, a4);
    v19 = (char *)&v484 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v19, v18);
    v22 = 0;
    v23 = v497;
  }
  v487 = v22;
  v492 = a1;
  v503 = a3;
  v24 = (unint64_t)(v19 + 15) & 0xFFFFFFFFFFFFFFF0;
  v25 = v24 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v23[20] = v25;
  if ((_DWORD)v16)
    v26 = 16 * v4;
  else
    v26 = 0;
  v27 = v25 + v26;
  v28 = v12 >> 3;
  v23[18] = v24;
  v23[19] = v25 + v26;
  if (v505)
  {
    v29 = v492;
    v30 = (unint64_t)*(int *)(v492 + 32) >> 1;
    v31 = (__int16 *)(v505 + 2 * (v15 + v30 * v14));
    v495 = v30 - v491;
    v32 = v491;
    v33 = 1;
  }
  else
  {
    v31 = 0;
    v495 = 0;
    v33 = 0;
    v32 = v491;
    v29 = v492;
  }
  v496 = (int)(float)((float)(v8 * 65535.0) + 0.5);
  v34 = v7 + (v11 - 1) * v12 + 8 * (_QWORD)v499;
  v35 = (int8x8_t *)(v7 + 8 * (v15 + v28 * v14));
  v494 = v28 - v32;
  v36 = *(int *)(v29 + 104);
  v37 = *(_DWORD *)(v29 + 108);
  v38 = *(unsigned __int8 *)(v29 + 2);
  if (v38 == 6 || v38 == 1)
  {
    v39 = v497;
    v40 = v501;
    if (!v498)
      goto LABEL_545;
    v484 = v28;
    v41 = 0;
    v42 = 0;
    v43 = *(int *)(v492 + 124);
    v44 = (uint64_t)v498 + v36 + (int)v43 * (uint64_t)v37;
    v32 = v491;
    v493 = v43 - v491;
LABEL_21:
    v51 = v504;
    goto LABEL_22;
  }
  v484 = v28;
  v40 = v501;
  if (!v498)
  {
    v44 = 0;
    v41 = 0;
    v493 = 0;
    v42 = 0;
    v39 = v497;
    goto LABEL_21;
  }
  v485 = v34;
  v486 = v33;
  shape_enum_clip_alloc((uint64_t)v20, v21, v498, 1, 1, 1, v36, v37, v504, v500);
  if (!v45)
    goto LABEL_545;
  v46 = v45;
  v47 = 0;
  v48 = (int)((v16 * v4 + 15) & 0xFFFFFFF0);
  if (!(_DWORD)v16)
    v48 = 16 * v4;
  v49 = v491;
  v493 = -v491;
  v44 = v27 + v48 + 16;
  v50 = v503;
  v39 = v497;
  v51 = v504;
  while (2)
  {
    v41 = v46;
    v501 = v495 + v49;
LABEL_549:
    v480 = v50;
    while (1)
    {
      v481 = *(_DWORD *)(v44 - 16);
      v482 = v481 - v47;
      if (v481 > v47)
      {
        v500 -= v482;
        if (v500 < 1)
          goto LABEL_543;
        v50 = v480;
        v40 += v39[16] * v482;
        v502 += v39[17] * v482;
        v35 += v484 * v482;
        v483 = v501 * v482;
        if (!v505)
          v483 = 0;
        v31 += v483;
        v47 = v481;
        goto LABEL_549;
      }
      if (v47 < *(_DWORD *)(v44 - 12) + v481)
        break;
      if (!shape_enum_clip_scan((uint64_t)v41, (_DWORD *)(v44 - 16)))
        goto LABEL_543;
    }
    v32 = v491;
    v33 = v486;
    v34 = v485;
    v42 = v47;
LABEL_22:
    v52 = v41;
    v53 = v496 ^ 0xFFFF;
    v489 = (v51 - 1) + 1;
    v488 = -v32;
    v485 = v34;
    v490 = v34 - 8;
    v486 = v33;
    v54 = 2 * v33;
    v55 = v52;
    v56 = v502;
LABEL_23:
    LODWORD(v498) = v42;
    v499 = v55;
    v57 = (void (*)(_QWORD *, uint64_t))*v39;
    v501 = v40;
    v502 = v56;
    v57(v39, v40);
    v58 = v39[20];
    v59 = (_BYTE *)v39[18];
    v60 = *((_DWORD *)v39 + 2);
    if (v60 == *((_DWORD *)v39 + 3))
    {
      v50 = v503;
      if (v496 != 0xFFFF)
      {
        v61 = v51;
        v62 = (_BYTE *)v39[18];
        do
        {
          if (*v62)
          {
            v63 = *(unsigned __int16 *)(v58 + 8);
            v64 = (unsigned __int16)WORD2(*(_QWORD *)v58) * v53;
            *(_QWORD *)v58 = ((HIWORD(*(_QWORD *)v58)
                             - ((HIWORD(*(_QWORD *)v58) * v53 + ((HIWORD(*(_QWORD *)v58) * v53) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v58) - ((v64 + HIWORD(v64) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v58) - ((WORD1(*(_QWORD *)v58) * v53 + ((WORD1(*(_QWORD *)v58) * v53) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v58 - (((unsigned __int16)*(_QWORD *)v58 * v53 + (((unsigned __int16)*(_QWORD *)v58 * v53) >> 16) + 1) >> 16));
            *(_WORD *)(v58 + 8) = v63 - ((v63 * v53 + ((v63 * v53) >> 16) + 1) >> 16);
          }
          ++v62;
          v58 += 16;
          --v61;
        }
        while (v61);
        v58 += 16 * v488;
        v59 += v489 + v488;
      }
    }
    else
    {
      v65 = v39[19];
      v66 = HIWORD(v60) & 0x3F;
      v50 = v503;
      if (v66 == 16)
      {
        if (v496 == 0xFFFF)
        {
          v110 = 0;
          v111 = 0;
          do
          {
            if (v59[v110])
              *(_OWORD *)(v58 + v111) = *(_OWORD *)(v65 + v111);
            v111 += 16;
            ++v110;
          }
          while (v51 != (_DWORD)v110);
        }
        else
        {
          v81 = 0;
          v82 = 0;
          do
          {
            if (v59[v81])
            {
              v83 = *(unsigned __int16 *)(v65 + v82 + 8);
              v84 = *(_QWORD *)(v65 + v82);
              v85 = v58 + v82;
              *(_QWORD *)v85 = ((HIWORD(v84)
                               - ((HIWORD(v84) * v53 + ((HIWORD(v84) * v53) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v84) - ((WORD2(v84) * v53 + ((WORD2(v84) * v53) >> 16) + 1) >> 16)) << 32) | ((WORD1(v84) - ((WORD1(v84) * v53 + ((WORD1(v84) * v53) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v84 - (((unsigned __int16)v84 * v53 + (((unsigned __int16)v84 * v53) >> 16) + 1) >> 16));
              *(_WORD *)(v85 + 8) = v83 - ((v83 * v53 + ((v83 * v53) >> 16) + 1) >> 16);
            }
            v82 += 16;
            ++v81;
          }
          while (v51 != (_DWORD)v81);
        }
      }
      else if (v66 == 32)
      {
        if (v496 == 0xFFFF)
        {
          v97 = 0;
          v98 = 0;
          v99 = (float *)(v65 + 8);
          do
          {
            if (v59[v97])
            {
              v100 = v99[2];
              if (v100 <= 0.0)
              {
                LOWORD(v101) = 0;
                *(_QWORD *)(v58 + v98) = 0;
              }
              else
              {
                LODWORD(v101) = (int)(float)((float)(v100 * 65535.0) + 0.5);
                v102 = *(v99 - 2);
                if (v100 <= 1.0)
                  v101 = v101;
                else
                  v101 = 0xFFFFLL;
                if (v100 > 1.0)
                  v100 = 1.0;
                LOWORD(v103) = v101;
                if (v102 <= v100)
                {
                  if (v102 >= 0.0)
                    v103 = (int)(float)((float)(v102 * 65535.0) + 0.5);
                  else
                    LOWORD(v103) = 0;
                }
                v104 = *(v99 - 1);
                v105 = v101;
                if (v104 <= v100)
                {
                  if (v104 >= 0.0)
                    v105 = (int)(float)((float)(v104 * 65535.0) + 0.5);
                  else
                    v105 = 0;
                }
                v106 = *v99;
                LOWORD(v107) = v101;
                if (*v99 <= v100)
                {
                  if (v106 >= 0.0)
                    v107 = (int)(float)((float)(v106 * 65535.0) + 0.5);
                  else
                    LOWORD(v107) = 0;
                }
                v108 = v99[1];
                v109 = v101;
                if (v108 <= v100)
                {
                  if (v108 >= 0.0)
                    v109 = (int)(float)((float)(v108 * 65535.0) + 0.5);
                  else
                    v109 = 0;
                }
                *(_QWORD *)(v58 + v98) = ((unint64_t)(unsigned __int16)v107 << 32) | (v109 << 48) | (v105 << 16) | (unint64_t)(unsigned __int16)v103;
              }
              *(_WORD *)(v58 + v98 + 8) = v101;
            }
            v98 += 16;
            v99 += 5;
            ++v97;
          }
          while (v51 != (_DWORD)v97);
        }
        else
        {
          v67 = 0;
          v68 = 0;
          v69 = (float *)(v65 + 8);
          do
          {
            if (v59[v67])
            {
              v70 = v69[2];
              if (v70 <= 0.0)
              {
                LOWORD(v75) = 0;
                *(_QWORD *)(v58 + v68) = 0;
              }
              else
              {
                v71 = *(v69 - 2);
                v72 = (int)(float)((float)(v70 * 65535.0) + 0.5);
                if (v70 > 1.0)
                  v72 = 0xFFFF;
                v73 = v72;
                if (v70 > 1.0)
                  v70 = 1.0;
                v74 = v72;
                if (v71 <= v70)
                {
                  if (v71 >= 0.0)
                    v74 = (int)(float)((float)(v71 * 65535.0) + 0.5);
                  else
                    v74 = 0;
                }
                v76 = *(v69 - 1);
                v77 = v72;
                if (v76 <= v70)
                {
                  if (v76 >= 0.0)
                    v77 = (int)(float)((float)(v76 * 65535.0) + 0.5);
                  else
                    v77 = 0;
                }
                v78 = *v69;
                v79 = v72;
                if (*v69 <= v70)
                {
                  if (v78 >= 0.0)
                    v79 = (int)(float)((float)(v78 * 65535.0) + 0.5);
                  else
                    v79 = 0;
                }
                v80 = v69[1];
                if (v80 <= v70)
                {
                  if (v80 >= 0.0)
                    v73 = (int)(float)((float)(v80 * 65535.0) + 0.5);
                  else
                    v73 = 0;
                }
                v75 = v72 - ((v72 * v53 + ((v72 * v53) >> 16) + 1) >> 16);
                *(_QWORD *)(v58 + v68) = ((unint64_t)(unsigned __int16)(v79
                                                                             - ((v79 * v53
                                                                               + ((v79 * v53) >> 16)
                                                                               + 1) >> 16)) << 32) | ((unint64_t)(v73 - ((v73 * v53 + ((v73 * v53) >> 16) + 1) >> 16)) << 48) | ((v77 - ((v77 * v53 + ((v77 * v53) >> 16) + 1) >> 16)) << 16) | (unint64_t)(unsigned __int16)(v74 - ((v74 * v53 + ((v74 * v53) >> 16) + 1) >> 16));
              }
              *(_WORD *)(v58 + v68 + 8) = v75;
            }
            v68 += 16;
            v69 += 5;
            ++v67;
          }
          while (v51 != (_DWORD)v67);
        }
      }
      else if (v496 == 0xFFFF)
      {
        v112 = 0;
        v113 = (_WORD *)(v58 + 8);
        do
        {
          if (v59[v112])
          {
            v114 = *(_QWORD *)(v65 + 8 * v112);
            HIDWORD(v115) = BYTE3(v114);
            LODWORD(v115) = v114;
            *((_QWORD *)v113 - 1) = ((unint64_t)(v114 | ((_DWORD)v114 << 8)) << 48) | ((unint64_t)(BYTE1(v114) | (BYTE1(v114) << 8)) << 32) | v114 & 0xFF0000 | ((unint64_t)BYTE2(v114) << 24) | (v115 >> 24);
            *v113 = BYTE4(v114) | (unsigned __int16)(WORD2(v114) << 8);
          }
          ++v112;
          v113 += 8;
        }
        while (v51 != (_DWORD)v112);
      }
      else
      {
        v86 = 0;
        v87 = (_WORD *)(v58 + 8);
        do
        {
          if (v59[v86])
          {
            v88 = v65 + 8 * v86;
            v89 = *(unsigned __int8 *)(v88 + 4);
            LODWORD(v88) = *(_DWORD *)v88;
            v90 = BYTE2(v88);
            v91 = BYTE1(v88);
            v92 = v88;
            HIDWORD(v93) = BYTE3(v88);
            LODWORD(v93) = v88;
            LODWORD(v88) = v93 >> 24;
            v94 = v90 | (v90 << 8);
            v95 = v91 | (v91 << 8);
            v96 = v92 | (v92 << 8);
            *((_QWORD *)v87 - 1) = ((unint64_t)(v96 - ((v96 * v53 + ((v96 * v53) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v95 - ((v95 * v53 + ((v95 * v53) >> 16) + 1) >> 16)) << 32) | ((v94 - ((v94 * v53 + ((v94 * v53) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v88 - (((_DWORD)v88 * v53 + ((v88 * v53) >> 16) + 1) >> 16));
            *v87 = (v89 | ((_WORD)v89 << 8))
                 - (((v89 | (v89 << 8)) * v53 + (((v89 | (v89 << 8)) * v53) >> 16) + 1) >> 16);
          }
          ++v86;
          v87 += 8;
        }
        while (v51 != (_DWORD)v86);
      }
    }
    switch((int)v50)
    {
      case 0:
        v116 = v44 != 0;
        if (v505)
        {
          v117 = v51;
          v118 = (unsigned __int8 *)v44;
          v119 = v501;
          do
          {
            v120 = *v59;
            if (*v59)
            {
              if (v44)
                v120 = ((unsigned __int16)(*v118 * (_WORD)v120 + ((*v118 * v120) >> 8) + 1) >> 8);
              if (v120)
              {
                if (v120 == 255)
                {
                  LOWORD(v121) = 0;
                  *v35 = 0;
                }
                else
                {
                  v122 = (unsigned __int16)*v31;
                  v123 = v120 | (v120 << 8);
                  v124 = vdup_n_s32(v123);
                  v125 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v35, (int8x8_t)0xFFFF0000FFFFLL), v124);
                  v126.i32[0] = HIWORD(v35->u32[0]);
                  v126.i32[1] = HIWORD(*(unint64_t *)v35);
                  v127 = (uint32x2_t)vmul_s32(v126, v124);
                  *v35 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v35, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v125, v125, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v126, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v127, v127, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  v121 = v122 - ((v123 * v122 + ((v123 * v122) >> 16) + 1) >> 16);
                }
                *v31 = v121;
              }
            }
            ++v59;
            v118 += v116;
            ++v35;
            ++v31;
            --v117;
          }
          while (v117);
        }
        else
        {
          v382 = v51;
          v118 = (unsigned __int8 *)v44;
          v119 = v501;
          do
          {
            v383 = *v59;
            if (*v59)
            {
              if (v44)
                v383 = ((unsigned __int16)(*v118 * (_WORD)v383 + ((*v118 * v383) >> 8) + 1) >> 8);
              if (v383)
              {
                if (v383 == 255)
                {
                  *v35 = 0;
                }
                else
                {
                  v384 = (int32x2_t)*v35;
                  v385.i32[0] = vshl_u32((uint32x2_t)*v35, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v386.i32[0] = v385.i32[0];
                  v386.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v35);
                  v387 = vdup_n_s32(v383 | (v383 << 8));
                  v388 = (uint32x2_t)vmul_s32(v386, v387);
                  v389.i32[0] = v35->u16[0];
                  v389.i32[1] = HIWORD(*(unint64_t *)v35);
                  v390 = (uint32x2_t)vmul_s32(v389, v387);
                  v385.i32[1] = HIDWORD(*(unint64_t *)v35);
                  v391 = (uint32x2_t)vsub_s32(v385, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v388, v388, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v384.i32[1] = v389.i32[1];
                  v392 = vsub_s32(v384, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v390, v390, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v393 = vshl_n_s32(v392, 0x10uLL);
                  v392.i16[1] = 0;
                  v392.i32[1] = v393.i32[1];
                  v394.i32[0] = vshl_u32(v391, (uint32x2_t)0xFFFF00000010).u32[0];
                  v394.i32[1] = v391.u16[2];
                  *v35 = vorr_s8(v394, (int8x8_t)v392);
                }
              }
            }
            ++v59;
            v118 += v116;
            ++v35;
            --v382;
          }
          while (v382);
        }
        v44 = (uint64_t)&v118[v493];
        v35 += v494;
        v31 += v495;
        goto LABEL_541;
      case 1:
        v128 = *v59;
        if (!v505)
        {
          v395 = v59 + 1;
          if (v44)
          {
            do
            {
              if (v128)
              {
                v396 = *(unsigned __int8 *)v44 * v128 + ((*(unsigned __int8 *)v44 * v128) >> 8) + 1;
                v397 = (int8x8_t *)v490;
                if (v490 >= (unint64_t)v35)
                  v397 = v35;
                if ((unint64_t)v397 >= *(_QWORD *)(v492 + 40))
                  v398 = (unsigned int *)v397;
                else
                  v398 = *(unsigned int **)(v492 + 40);
                if (BYTE1(v396))
                {
                  if (BYTE1(v396) == 255)
                  {
                    *(_QWORD *)v398 = *(_QWORD *)v58;
                  }
                  else
                  {
                    cmyk64_DMplusDM(v398, *(_QWORD *)v58, (unsigned __int16)(257 * (v396 >> 8)), *(_QWORD *)v398, (unsigned __int16)~(257 * (v396 >> 8)));
                    v50 = v503;
                  }
                }
              }
              else
              {
                v398 = (unsigned int *)v35;
              }
              v399 = *v395++;
              v128 = v399;
              v58 += 16;
              ++v44;
              v35 = (int8x8_t *)(v398 + 2);
              --v51;
            }
            while (v51);
            v44 += v493;
          }
          else
          {
            do
            {
              v400 = (int8x8_t *)v490;
              if (v490 >= (unint64_t)v35)
                v400 = v35;
              if ((unint64_t)v400 >= *(_QWORD *)(v492 + 40))
                v398 = (unsigned int *)v400;
              else
                v398 = *(unsigned int **)(v492 + 40);
              if (v128)
              {
                if (v128 == 255)
                {
                  *(_QWORD *)v398 = *(_QWORD *)v58;
                }
                else
                {
                  cmyk64_DMplusDM(v398, *(_QWORD *)v58, v128 | (v128 << 8), *(_QWORD *)v398, (v128 | (v128 << 8)) ^ 0xFFFF);
                  v50 = v503;
                }
              }
              v401 = *v395++;
              v128 = v401;
              v58 += 16;
              v35 = (int8x8_t *)(v398 + 2);
              --v51;
            }
            while (v51);
            v44 = 0;
          }
          goto LABEL_538;
        }
        v129 = 0;
        if (v44)
        {
          v130 = 0;
          v131 = 0;
          v132 = v59 + 1;
          do
          {
            if (v128)
            {
              v133 = *(unsigned __int8 *)(v44 + v131) * v128
                   + ((*(unsigned __int8 *)(v44 + v131) * v128) >> 8)
                   + 1;
              if (BYTE1(v133))
              {
                if (BYTE1(v133) == 255)
                {
                  v35[v131] = *(int8x8_t *)(v58 + 4 * v129);
                  v31[v131] = *(_WORD *)(v58 + 2 * v130 + 8);
                }
                else
                {
                  cmyk64_DAMplusDAM((unsigned int *)&v35[v130 / 8], &v31[v129], *(_QWORD *)(v58 + 4 * v129), *(unsigned __int16 *)(v58 + 2 * v130 + 8), (unsigned __int16)(257 * (v133 >> 8)), *(_QWORD *)&v35[v131], (unsigned __int16)v31[v131], (unsigned __int16)~(257 * (v133 >> 8)));
                }
              }
            }
            v128 = v132[v131++];
            v130 += 8;
            ++v129;
          }
          while ((_DWORD)v504 != (_DWORD)v131);
          v134 = (uint64_t)&v35[v130 / 8 - 1];
          v135 = (uint64_t)&v31[v129 - 1];
          v136 = v44 + v131;
          goto LABEL_149;
        }
        v455 = 0;
        v456 = v59 + 1;
        do
        {
          if (v128)
          {
            if (v128 == 255)
            {
              v35[v44] = *(int8x8_t *)(v58 + 4 * v129);
              v31[v44] = *(_WORD *)(v58 + 2 * v455 + 8);
            }
            else
            {
              cmyk64_DAMplusDAM((unsigned int *)&v35[v455 / 8], &v31[v129], *(_QWORD *)(v58 + 4 * v129), *(unsigned __int16 *)(v58 + 2 * v455 + 8), v128 | (v128 << 8), *(_QWORD *)&v35[v44], (unsigned __int16)v31[v44], (v128 | (v128 << 8)) ^ 0xFFFF);
              v50 = v503;
            }
          }
          v128 = v456[v44++];
          v455 += 8;
          ++v129;
        }
        while ((_DWORD)v504 != (_DWORD)v44);
        v44 = 0;
        v135 = (uint64_t)&v31[v129 - 1];
        v134 = (uint64_t)&v35[v455 / 8 - 1];
        goto LABEL_525;
      case 2:
        v137 = *v59;
        if (v505)
        {
          if (v44)
          {
            v138 = 0;
            v139 = 0;
            v140 = 0;
            v141 = v59 + 1;
            while (1)
            {
              if (!v137)
                goto LABEL_147;
              v142 = *(unsigned __int8 *)(v44 + v140) * v137
                   + ((*(unsigned __int8 *)(v44 + v140) * v137) >> 8)
                   + 1;
              if (!BYTE1(v142))
                goto LABEL_147;
              if (BYTE1(v142) == 255)
              {
                v143 = v58 + 2 * v138;
                v144 = *(unsigned __int16 *)(v143 + 8);
                if (*(_WORD *)(v143 + 8))
                {
                  if (v144 != 0xFFFF)
                  {
                    v150 = *(_QWORD *)(v58 + 4 * v139);
                    v149 = (unint64_t)v35[v140];
                    v151 = (unsigned __int16)v31[v140];
                    v152 = v144 ^ 0xFFFF;
                    goto LABEL_146;
                  }
                  v35[v140] = *(int8x8_t *)(v58 + 4 * v139);
                  v31[v140] = -1;
                }
              }
              else
              {
                v145 = *(unsigned __int16 *)(v58 + 2 * v138 + 8);
                v146 = (257 * (v142 >> 8)) ^ 0xFFFF;
                v147 = v145 - ((v146 * v145 + ((v146 * v145) >> 16) + 1) >> 16);
                if (v145 != (v146 * v145 + ((v146 * v145) >> 16) + 1) >> 16)
                {
                  v148 = *(_QWORD *)(v58 + 4 * v139);
                  v149 = (unint64_t)v35[v140];
                  v150 = ((HIWORD(v148) - ((v146 * HIWORD(v148) + ((v146 * HIWORD(v148)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v148) - ((WORD2(v148) * v146 + ((WORD2(v148) * v146) >> 16) + 1) >> 16)) << 32) | ((WORD1(v148) - ((WORD1(v148) * v146 + ((WORD1(v148) * v146) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v148 - (((unsigned __int16)v148 * v146 + (((unsigned __int16)v148 * v146) >> 16) + 1) >> 16));
                  v151 = (unsigned __int16)v31[v140];
                  v152 = (unsigned __int16)~(_WORD)v147;
                  LOWORD(v144) = v147;
LABEL_146:
                  cmyk64_DAplusDAM(&v35[v138 / 8], &v31[v139], v150, v144, v149, v151, v152);
                }
              }
LABEL_147:
              v137 = v141[v140++];
              ++v139;
              v138 += 8;
              if ((_DWORD)v504 == (_DWORD)v140)
              {
                v134 = (uint64_t)&v35[v138 / 8 - 1];
                v135 = (uint64_t)&v31[v139 - 1];
                v136 = v44 + v140;
LABEL_149:
                v44 = v136 + v493;
                v50 = v503;
                goto LABEL_525;
              }
            }
          }
          v457 = 0;
          v458 = 0;
          v459 = v59 + 1;
          while (1)
          {
            if (v137)
            {
              if (v137 == 255)
              {
                v460 = v58 + 2 * v457;
                v461 = *(unsigned __int16 *)(v460 + 8);
                if (*(_WORD *)(v460 + 8))
                {
                  if (v461 != 0xFFFF)
                  {
                    v467 = *(_QWORD *)(v58 + 4 * v458);
                    v466 = (unint64_t)v35[v44];
                    v468 = (unsigned __int16)v31[v44];
                    v469 = v461 ^ 0xFFFF;
                    goto LABEL_522;
                  }
                  v35[v44] = *(int8x8_t *)(v58 + 4 * v458);
                  v31[v44] = -1;
                }
              }
              else
              {
                v462 = *(unsigned __int16 *)(v58 + 2 * v457 + 8);
                v463 = (257 * v137) ^ 0xFFFF;
                v464 = v462 - ((v463 * v462 + ((v463 * v462) >> 16) + 1) >> 16);
                if (v462 != (v463 * v462 + ((v463 * v462) >> 16) + 1) >> 16)
                {
                  v465 = *(_QWORD *)(v58 + 4 * v458);
                  v466 = (unint64_t)v35[v44];
                  v467 = ((HIWORD(v465) - ((v463 * HIWORD(v465) + ((v463 * HIWORD(v465)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v465) - ((WORD2(v465) * v463 + ((WORD2(v465) * v463) >> 16) + 1) >> 16)) << 32) | ((WORD1(v465) - ((WORD1(v465) * v463 + ((WORD1(v465) * v463) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v465 - (((unsigned __int16)v465 * v463 + (((unsigned __int16)v465 * v463) >> 16) + 1) >> 16));
                  v468 = (unsigned __int16)v31[v44];
                  v469 = (unsigned __int16)~(_WORD)v464;
                  LOWORD(v461) = v464;
LABEL_522:
                  cmyk64_DAplusDAM(&v35[v457 / 8], &v31[v458], v467, v461, v466, v468, v469);
                }
              }
            }
            v137 = v459[v44++];
            ++v458;
            v457 += 8;
            if ((_DWORD)v504 == (_DWORD)v44)
            {
              v44 = 0;
              v135 = (uint64_t)&v31[v458 - 1];
              v134 = (uint64_t)&v35[v457 / 8 - 1];
              v50 = v503;
LABEL_525:
              v35 = (int8x8_t *)(v134 + 8 * v494 + 8);
              v31 = (__int16 *)(v135 + 2 * v495 + 2);
              goto LABEL_539;
            }
          }
        }
        if (!v44)
        {
          v470 = v59 + 1;
          while (1)
          {
            if (v137)
            {
              if (v137 == 255)
              {
                v471 = *(unsigned __int16 *)(v58 + 8);
                if (*(_WORD *)(v58 + 8))
                {
                  if (v471 != 0xFFFF)
                  {
                    v476 = *(_QWORD *)v58;
                    v477 = (unint64_t)*v35;
                    v478 = v471 ^ 0xFFFF;
                    goto LABEL_535;
                  }
                  *v35 = *(int8x8_t *)v58;
                }
              }
              else
              {
                v472 = *(unsigned __int16 *)(v58 + 8);
                v473 = (257 * v137) ^ 0xFFFF;
                v474 = v473 * v472 + ((v473 * v472) >> 16) + 1;
                if (v472 != HIWORD(v474))
                {
                  v475 = (unsigned __int16)WORD2(*(_QWORD *)v58) * v473;
                  v476 = ((HIWORD(*(_QWORD *)v58)
                         - ((v473 * HIWORD(*(_QWORD *)v58) + ((v473 * HIWORD(*(_QWORD *)v58)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v58) - ((v475 + HIWORD(v475) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v58) - ((WORD1(*(_QWORD *)v58) * v473 + ((WORD1(*(_QWORD *)v58) * v473) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v58 - (((unsigned __int16)*(_QWORD *)v58 * v473 + (((unsigned __int16)*(_QWORD *)v58 * v473) >> 16) + 1) >> 16));
                  v477 = (unint64_t)*v35;
                  v478 = (unsigned __int16)(~(_WORD)v472 + HIWORD(v474));
LABEL_535:
                  cmyk64_DplusDM(v35, v476, v477, v478);
                  v50 = v503;
                }
              }
            }
            v479 = *v470++;
            v137 = v479;
            v58 += 16;
            ++v35;
            if (!--v51)
            {
              v44 = 0;
              v398 = (unsigned int *)&v35[-1];
              goto LABEL_538;
            }
          }
        }
        v402 = 0;
        v403 = v59 + 1;
        v404 = v35;
        do
        {
          v398 = (unsigned int *)v404;
          if (v137)
          {
            v405 = *(unsigned __int8 *)(v44 + v402) * v137
                 + ((*(unsigned __int8 *)(v44 + v402) * v137) >> 8)
                 + 1;
            if (BYTE1(v405))
            {
              if (BYTE1(v405) == 255)
              {
                v406 = *(unsigned __int16 *)(v58 + 8);
                if (!*(_WORD *)(v58 + 8))
                  goto LABEL_466;
                if (v406 == 0xFFFF)
                {
                  v35[v402] = *(int8x8_t *)v58;
                  goto LABEL_466;
                }
                v412 = *(_QWORD *)v58;
                v413 = (unint64_t)v35[v402];
                v414 = v406 ^ 0xFFFF;
              }
              else
              {
                v407 = v405 >> 8;
                v408 = *(unsigned __int16 *)(v58 + 8);
                v409 = (257 * v407) ^ 0xFFFF;
                v410 = v409 * v408 + ((v409 * v408) >> 16) + 1;
                if (v408 == HIWORD(v410))
                  goto LABEL_466;
                v411 = (unsigned __int16)WORD2(*(_QWORD *)v58) * v409;
                v412 = ((HIWORD(*(_QWORD *)v58)
                       - ((v409 * HIWORD(*(_QWORD *)v58) + ((v409 * HIWORD(*(_QWORD *)v58)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v58) - ((v411 + HIWORD(v411) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v58) - ((WORD1(*(_QWORD *)v58) * v409 + ((WORD1(*(_QWORD *)v58) * v409) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v58 - (((unsigned __int16)*(_QWORD *)v58 * v409 + (((unsigned __int16)*(_QWORD *)v58 * v409) >> 16) + 1) >> 16));
                v413 = (unint64_t)v35[v402];
                v414 = (unsigned __int16)(~(_WORD)v408 + HIWORD(v410));
              }
              cmyk64_DplusDM(v398, v412, v413, v414);
              v50 = v503;
            }
          }
LABEL_466:
          v137 = v403[v402];
          v58 += 16;
          v404 = (int8x8_t *)(v398 + 2);
          ++v402;
        }
        while ((_DWORD)v504 != (_DWORD)v402);
        v44 += v402 + v493;
LABEL_538:
        v35 = (int8x8_t *)&v398[2 * v494 + 2];
        v31 += v495;
LABEL_539:
        v39 = v497;
        v51 = v504;
LABEL_540:
        v119 = v501;
LABEL_541:
        v454 = (int)v498;
LABEL_503:
        if (v500 != 1)
        {
          --v500;
          v55 = 0;
          v42 = v454 + 1;
          v40 = v39[16] + v119;
          v56 = v39[17] + v502;
          v46 = v499;
          if (v499)
          {
            v47 = v42;
            v502 += v39[17];
            v49 = v491;
            continue;
          }
          goto LABEL_23;
        }
        v41 = v499;
LABEL_543:
        if (v41)
          free(v41);
LABEL_545:
        if (v487)
          free(v487);
        return;
      case 3:
        v153 = v51;
        v154 = (unsigned __int16 *)(v58 + 8);
        v155 = v153;
        v156 = (unsigned __int8 *)v44;
        do
        {
          v157 = *v59;
          if (*v59)
          {
            if (v44)
              v157 = ((unsigned __int16)(*v156 * (_WORD)v157 + ((*v156 * v157) >> 8) + 1) >> 8);
            if (v157)
            {
              if (v157 == 255)
              {
                v158 = *(int32x2_t *)(v154 - 4);
                v159 = *v154;
                v160 = (unsigned __int16)*v31 ^ 0xFFFF;
                v161 = vdup_n_s32(v160);
                v162 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v158, (int8x8_t)0xFFFF0000FFFFLL), v161);
                v163 = vsub_s32(v158, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v162, v162, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v158.i32[0] = HIWORD(v158.i32[0]);
                v158.i32[1] = HIWORD(*((_QWORD *)v154 - 1));
                v164 = (uint32x2_t)vmul_s32(v158, v161);
                *v35 = (int8x8_t)vsli_n_s32(v163, vsub_s32(v158, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v164, v164, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                *v31 = v159 - ((v160 * v159 + ((v160 * v159) >> 16) + 1) >> 16);
              }
              else
              {
                cmyk64_DAMplusDAM((unsigned int *)v35, v31, *((_QWORD *)v154 - 1), *v154, ((unsigned __int16)*v31 * (v157 | (v157 << 8))+ (((unsigned __int16)*v31 * (v157 | (v157 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v157 | (v157 << 8)) ^ 0xFFFF);
              }
            }
          }
          ++v59;
          v156 += v44 != 0;
          ++v35;
          v154 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v155;
        }
        while (v155);
        goto LABEL_222;
      case 4:
        v165 = v51;
        v166 = (unsigned __int16 *)(v58 + 8);
        v167 = v165;
        v156 = (unsigned __int8 *)v44;
        do
        {
          v168 = *v59;
          if (*v59)
          {
            if (v44)
              v168 = ((unsigned __int16)(*v156 * (_WORD)v168 + ((*v156 * v168) >> 8) + 1) >> 8);
            if (v168)
            {
              if (v168 == 255)
              {
                v169 = *(int32x2_t *)(v166 - 4);
                v170 = *v166;
                v171 = (unsigned __int16)*v31;
                v172 = vdup_n_s32(v171);
                v173 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v169, (int8x8_t)0xFFFF0000FFFFLL), v172);
                v174 = vsub_s32(v169, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v173, v173, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v169.i32[0] = HIWORD(v169.i32[0]);
                v169.i32[1] = HIWORD(*((_QWORD *)v166 - 1));
                v175 = (uint32x2_t)vmul_s32(v169, v172);
                *v35 = (int8x8_t)vsli_n_s32(v174, vsub_s32(v169, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v175, v175, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                *v31 = v170 - ((v171 * v170 + ((v171 * v170) >> 16) + 1) >> 16);
              }
              else
              {
                cmyk64_DAMplusDAM((unsigned int *)v35, v31, *((_QWORD *)v166 - 1), *v166, (((unsigned __int16)*v31 ^ 0xFFFF) * (v168 | (v168 << 8))+ ((((unsigned __int16)*v31 ^ 0xFFFF) * (v168 | (v168 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v168 | (v168 << 8)) ^ 0xFFFF);
              }
            }
          }
          ++v59;
          v156 += v44 != 0;
          ++v35;
          v166 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v167;
        }
        while (v167);
        goto LABEL_222;
      case 5:
        v176 = v51;
        v177 = (unsigned __int16 *)(v58 + 8);
        v178 = v176;
        v156 = (unsigned __int8 *)v44;
        do
        {
          v179 = *v59;
          if (*v59)
          {
            if (!v44
              || (v179 = ((unsigned __int16)(*v156 * (_WORD)v179
                                                            + ((*v156 * v179) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v180 = *((_QWORD *)v177 - 1);
              v181 = (v179 | (v179 << 8)) ^ 0xFFFF;
              v182 = ((HIWORD(v180) - ((v181 * HIWORD(v180) + ((v181 * HIWORD(v180)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v180) - ((WORD2(v180) * v181 + ((WORD2(v180) * v181) >> 16) + 1) >> 16)) << 32) | ((WORD1(v180) - ((WORD1(v180) * v181 + ((WORD1(v180) * v181) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v180 - (((unsigned __int16)v180 * v181 + (((unsigned __int16)v180 * v181) >> 16) + 1) >> 16));
              v183 = *v177 - ((v181 * *v177 + ((v181 * *v177) >> 16) + 1) >> 16);
              cmyk64_DAMplusDAM((unsigned int *)v35, v31, v182, (unsigned __int16)v183, (unsigned __int16)*v31, (unint64_t)*v35, (unsigned __int16)*v31, (unsigned __int16)~(_WORD)v183);
            }
          }
          ++v59;
          v156 += v44 != 0;
          ++v35;
          v177 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v178;
        }
        while (v178);
        goto LABEL_222;
      case 6:
        v184 = v51;
        v185 = (unsigned __int16 *)(v58 + 8);
        v186 = v184;
        v156 = (unsigned __int8 *)v44;
        do
        {
          v187 = *v59;
          if (*v59)
          {
            if ((!v44
               || (v187 = ((unsigned __int16)(*v156 * (_WORD)v187
                                                             + ((*v156 * v187) >> 8)
                                                             + 1) >> 8)) != 0)
              && *v31 != -1)
            {
              if ((unsigned __int16)~*v31 == 0xFFFF)
              {
                v188 = *(int32x2_t *)(v185 - 4);
                v189 = *v185;
                v190 = (v187 | (v187 << 8)) ^ 0xFFFF;
                v191 = vdup_n_s32(v190);
                v192 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v188, (int8x8_t)0xFFFF0000FFFFLL), v191);
                v193 = vsub_s32(v188, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v192, v192, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v188.i32[0] = HIWORD(v188.i32[0]);
                v188.i32[1] = HIWORD(*((_QWORD *)v185 - 1));
                v194 = (uint32x2_t)vmul_s32(v188, v191);
                *v35 = (int8x8_t)vsli_n_s32(v193, vsub_s32(v188, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v194, v194, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                *v31 = v189 - ((v190 * v189 + ((v190 * v189) >> 16) + 1) >> 16);
              }
              else
              {
                cmyk64_DAplusDAM(v35, v31, (uint64_t)*v35, *v31, *((_QWORD *)v185 - 1), *v185, (257 * v187 * (unsigned __int16)~*v31+ ((257 * v187 * (unsigned __int16)~*v31) >> 16)+ 1) >> 16);
              }
            }
          }
          ++v59;
          v156 += v44 != 0;
          ++v35;
          v185 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v186;
        }
        while (v186);
        goto LABEL_222;
      case 7:
        v195 = v44 != 0;
        if (v505)
        {
          v196 = (unsigned __int16 *)(v58 + 8);
          v197 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v199 = *v59;
            if (*v59)
            {
              if (v44)
                v199 = ((unsigned __int16)(*v198 * (_WORD)v199 + ((*v198 * v199) >> 8) + 1) >> 8);
              if (v199)
              {
                if (v199 == 255)
                {
                  v200 = (unsigned __int16)*v31;
                  v201 = *v196 ^ 0xFFFF;
                  v202 = vdup_n_s32(v201);
                  v203 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v35, (int8x8_t)0xFFFF0000FFFFLL), v202);
                  v204.i32[0] = HIWORD(v35->u32[0]);
                  v204.i32[1] = HIWORD(*(unint64_t *)v35);
                  v205 = (uint32x2_t)vmul_s32(v204, v202);
                  *v35 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v35, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v203, v203, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v204, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v205, v205, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  *v31 = v200 - ((v201 * v200 + ((v201 * v200) >> 16) + 1) >> 16);
                }
                else
                {
                  cmyk64_DAMplusDAM((unsigned int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, (*v196 * (v199 | (v199 << 8)) + ((*v196 * (v199 | (v199 << 8))) >> 16) + 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v199 | (v199 << 8)) ^ 0xFFFF);
                }
              }
            }
            ++v59;
            v198 += v195;
            ++v35;
            ++v31;
            v196 += 8;
            --v197;
          }
          while (v197);
        }
        else
        {
          v415 = (unsigned __int16 *)(v58 + 8);
          v416 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v417 = *v59;
            if (*v59)
            {
              if (v44)
                v417 = ((unsigned __int16)(*v198 * (_WORD)v417 + ((*v198 * v417) >> 8) + 1) >> 8);
              if (v417)
              {
                if (v417 == 255)
                {
                  v418 = (int32x2_t)*v35;
                  v419.i32[0] = vshl_u32((uint32x2_t)*v35, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v420.i32[0] = v419.i32[0];
                  v420.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v35);
                  v421 = vdup_n_s32(*v415 ^ 0xFFFFu);
                  v422 = (uint32x2_t)vmul_s32(v420, v421);
                  v423.i32[0] = v35->u16[0];
                  v423.i32[1] = HIWORD(*(unint64_t *)v35);
                  v424 = (uint32x2_t)vmul_s32(v423, v421);
                  v419.i32[1] = HIDWORD(*(unint64_t *)v35);
                  v425 = (uint32x2_t)vsub_s32(v419, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v422, v422, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v418.i32[1] = v423.i32[1];
                  v426 = vsub_s32(v418, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v424, v424, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v427 = vshl_n_s32(v426, 0x10uLL);
                  v426.i16[1] = 0;
                  v426.i32[1] = v427.i32[1];
                  v428.i32[0] = vshl_u32(v425, (uint32x2_t)0xFFFF00000010).u32[0];
                  v428.i32[1] = v425.u16[2];
                  *v35 = vorr_s8(v428, (int8x8_t)v426);
                }
                else
                {
                  cmyk64_DMplusDM((unsigned int *)v35, (unint64_t)*v35, (*v415 * (v417 | (v417 << 8)) + ((*v415 * (v417 | (v417 << 8))) >> 16) + 1) >> 16, (unint64_t)*v35, (v417 | (v417 << 8)) ^ 0xFFFF);
                }
              }
            }
            ++v59;
            v198 += v195;
            ++v35;
            v415 += 8;
            --v416;
          }
          while (v416);
        }
        goto LABEL_501;
      case 8:
        v206 = v44 != 0;
        if (v505)
        {
          v207 = (unsigned __int16 *)(v58 + 8);
          v208 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v209 = *v59;
            if (*v59)
            {
              if (v44)
                v209 = ((unsigned __int16)(*v198 * (_WORD)v209 + ((*v198 * v209) >> 8) + 1) >> 8);
              if (v209)
              {
                if (v209 == 255)
                {
                  v210 = (unsigned __int16)*v31;
                  v211 = *v207;
                  v212 = vdup_n_s32(v211);
                  v213 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v35, (int8x8_t)0xFFFF0000FFFFLL), v212);
                  v214.i32[0] = HIWORD(v35->u32[0]);
                  v214.i32[1] = HIWORD(*(unint64_t *)v35);
                  v215 = (uint32x2_t)vmul_s32(v214, v212);
                  *v35 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v35, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v213, v213, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v214, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v215, v215, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  *v31 = v210 - ((v211 * v210 + ((v211 * v210) >> 16) + 1) >> 16);
                }
                else
                {
                  cmyk64_DAMplusDAM((unsigned int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, ((*v207 ^ 0xFFFF) * (v209 | (v209 << 8))+ (((*v207 ^ 0xFFFF) * (v209 | (v209 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v209 | (v209 << 8)) ^ 0xFFFF);
                }
              }
            }
            ++v59;
            v198 += v206;
            ++v35;
            ++v31;
            v207 += 8;
            --v208;
          }
          while (v208);
        }
        else
        {
          v429 = (unsigned __int16 *)(v58 + 8);
          v430 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v431 = *v59;
            if (*v59)
            {
              if (v44)
                v431 = ((unsigned __int16)(*v198 * (_WORD)v431 + ((*v198 * v431) >> 8) + 1) >> 8);
              if (v431)
              {
                if (v431 == 255)
                {
                  v432 = (int32x2_t)*v35;
                  v433.i32[0] = vshl_u32((uint32x2_t)*v35, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v434.i32[0] = v433.i32[0];
                  v434.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v35);
                  v435 = vdup_n_s32(*v429);
                  v436 = (uint32x2_t)vmul_s32(v434, v435);
                  v437.i32[0] = v35->u16[0];
                  v437.i32[1] = HIWORD(*(unint64_t *)v35);
                  v438 = (uint32x2_t)vmul_s32(v437, v435);
                  v433.i32[1] = HIDWORD(*(unint64_t *)v35);
                  v439 = (uint32x2_t)vsub_s32(v433, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v436, v436, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v432.i32[1] = v437.i32[1];
                  v440 = vsub_s32(v432, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v438, v438, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v441 = vshl_n_s32(v440, 0x10uLL);
                  v440.i16[1] = 0;
                  v440.i32[1] = v441.i32[1];
                  v442.i32[0] = vshl_u32(v439, (uint32x2_t)0xFFFF00000010).u32[0];
                  v442.i32[1] = v439.u16[2];
                  *v35 = vorr_s8(v442, (int8x8_t)v440);
                }
                else
                {
                  cmyk64_DMplusDM((unsigned int *)v35, (unint64_t)*v35, ((*v429 ^ 0xFFFF) * (v431 | (v431 << 8))+ (((*v429 ^ 0xFFFF) * (v431 | (v431 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (v431 | (v431 << 8)) ^ 0xFFFF);
                }
              }
            }
            ++v59;
            v198 += v206;
            ++v35;
            v429 += 8;
            --v430;
          }
          while (v430);
        }
        goto LABEL_501;
      case 9:
        v216 = v51;
        v217 = (unsigned __int16 *)(v58 + 8);
        v218 = v216;
        v156 = (unsigned __int8 *)v44;
        do
        {
          v219 = *v59;
          if (*v59)
          {
            if (!v44
              || (v219 = ((unsigned __int16)(*v156 * (_WORD)v219
                                                            + ((*v156 * v219) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v220 = *((_QWORD *)v217 - 1);
              v221 = ~(v219 | ((_WORD)v219 << 8));
              v222 = v221;
              v223 = ((HIWORD(v220) - ((HIWORD(v220) * v221 + ((HIWORD(v220) * v221) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v220) - ((WORD2(v220) * v222 + ((WORD2(v220) * v222) >> 16) + 1) >> 16)) << 32) | ((WORD1(v220) - ((WORD1(v220) * v222 + ((WORD1(v220) * v222) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v220 - (((unsigned __int16)v220 * v221 + (((unsigned __int16)v220 * v221) >> 16) + 1) >> 16));
              v224 = *v217 - ((*v217 * v222 + ((*v217 * v222) >> 16) + 1) >> 16);
              cmyk64_DAMplusDAM((unsigned int *)v35, v31, v223, (unsigned __int16)v224, (unsigned __int16)*v31 ^ 0xFFFF, (unint64_t)*v35, (unsigned __int16)*v31, (unsigned __int16)(v224 + v221));
            }
          }
          ++v59;
          v156 += v44 != 0;
          ++v35;
          v217 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v218;
        }
        while (v218);
        goto LABEL_222;
      case 10:
        v225 = v51;
        v226 = (unsigned __int16 *)(v58 + 8);
        v227 = v225;
        v156 = (unsigned __int8 *)v44;
        do
        {
          v228 = *v59;
          if (*v59)
          {
            if (!v44
              || (v228 = ((unsigned __int16)(*v156 * (_WORD)v228
                                                            + ((*v156 * v228) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v229 = *((_QWORD *)v226 - 1);
              v230 = (v228 | (v228 << 8)) ^ 0xFFFF;
              v231 = ((HIWORD(v229) - ((v230 * HIWORD(v229) + ((v230 * HIWORD(v229)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v229) - ((WORD2(v229) * v230 + ((WORD2(v229) * v230) >> 16) + 1) >> 16)) << 32) | ((WORD1(v229) - ((WORD1(v229) * v230 + ((WORD1(v229) * v230) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v229 - (((unsigned __int16)v229 * v230 + (((unsigned __int16)v229 * v230) >> 16) + 1) >> 16));
              v232 = *v226 - ((v230 * *v226 + ((v230 * *v226) >> 16) + 1) >> 16);
              cmyk64_DAMplusDAM((unsigned int *)v35, v31, v231, (unsigned __int16)v232, (unsigned __int16)*v31 ^ 0xFFFF, (unint64_t)*v35, (unsigned __int16)*v31, (unsigned __int16)~(_WORD)v232);
            }
          }
          ++v59;
          v156 += v44 != 0;
          ++v35;
          v226 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v227;
        }
        while (v227);
LABEL_222:
        v44 = (uint64_t)&v156[v493];
        goto LABEL_502;
      case 11:
        v233 = v44 != 0;
        if (v505)
        {
          v234 = (_WORD *)(v58 + 8);
          v235 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v236 = *v59;
            if (*v59)
            {
              if (!v44
                || (v236 = ((unsigned __int16)(*v198 * (_WORD)v236
                                                              + ((*v198 * v236) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                v237 = *((_QWORD *)v234 - 1);
                v238 = (v236 | (v236 << 8)) ^ 0xFFFF;
                v239 = (unsigned __int16)v237 * v238;
                cmyk64_DAplusdDA((int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, ((HIWORD(v237) - ((v238 * HIWORD(v237) + ((v238 * HIWORD(v237)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v237) - ((WORD2(v237) * v238 + ((WORD2(v237) * v238) >> 16) + 1) >> 16)) << 32) | ((WORD1(v237) - ((WORD1(v237) * v238 + ((WORD1(v237) * v238) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v237 - ((v239 + HIWORD(v239) + 1) >> 16)), (unsigned __int16)(*v234- ((v238 * (unsigned __int16)*v234+ ((v238 * (unsigned __int16)*v234) >> 16)+ 1) >> 16)));
              }
            }
            ++v59;
            v198 += v233;
            ++v35;
            ++v31;
            v234 += 8;
            --v235;
          }
          while (v235);
        }
        else
        {
          v443 = (_WORD *)(v58 + 8);
          v444 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v445 = *v59;
            if (*v59)
            {
              if (!v44
                || (v445 = ((unsigned __int16)(*v198 * (_WORD)v445
                                                              + ((*v198 * v445) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                v446 = *((_QWORD *)v443 - 1);
                v447 = (v445 | (v445 << 8)) ^ 0xFFFF;
                v448 = (unsigned __int16)v446 * v447;
                cmyk64_DplusdDA((int *)v35, (unint64_t)*v35, ((HIWORD(v446) - ((v447 * HIWORD(v446) + ((v447 * HIWORD(v446)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v446) - ((WORD2(v446) * v447 + ((WORD2(v446) * v447) >> 16) + 1) >> 16)) << 32) | ((WORD1(v446) - ((WORD1(v446) * v447 + ((WORD1(v446) * v447) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v446 - ((v448 + HIWORD(v448) + 1) >> 16)), (unsigned __int16)(*v443- ((v447 * (unsigned __int16)*v443+ ((v447 * (unsigned __int16)*v443) >> 16)+ 1) >> 16)));
              }
            }
            ++v59;
            v198 += v233;
            ++v35;
            v443 += 8;
            --v444;
          }
          while (v444);
        }
        goto LABEL_501;
      case 12:
        v240 = v44 != 0;
        if (v505)
        {
          v241 = (_WORD *)(v58 + 8);
          v242 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v243 = *v59;
            if (*v59)
            {
              if (!v44
                || (v243 = ((unsigned __int16)(*v198 * (_WORD)v243
                                                              + ((*v198 * v243) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                v244 = *((_QWORD *)v241 - 1);
                v245 = (v243 | (v243 << 8)) ^ 0xFFFF;
                v246 = (unsigned __int16)v244 * v245;
                cmyk64_DApluslDA((unsigned int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, ((HIWORD(v244) - ((v245 * HIWORD(v244) + ((v245 * HIWORD(v244)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v244) - ((WORD2(v244) * v245 + ((WORD2(v244) * v245) >> 16) + 1) >> 16)) << 32) | ((WORD1(v244) - ((WORD1(v244) * v245 + ((WORD1(v244) * v245) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v244 - ((v246 + HIWORD(v246) + 1) >> 16)), (unsigned __int16)(*v241- ((v245 * (unsigned __int16)*v241+ ((v245 * (unsigned __int16)*v241) >> 16)+ 1) >> 16)));
              }
            }
            ++v59;
            v198 += v240;
            ++v35;
            ++v31;
            v241 += 8;
            --v242;
          }
          while (v242);
        }
        else
        {
          v449 = v51;
          v198 = (unsigned __int8 *)v44;
          do
          {
            v450 = *v59;
            if (*v59)
            {
              if (!v44
                || (v450 = ((unsigned __int16)(*v198 * (_WORD)v450
                                                              + ((*v198 * v450) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                v451 = HIWORD(*(_QWORD *)v58);
                v452 = (v450 | (v450 << 8)) ^ 0xFFFF;
                v453 = (unsigned __int16)WORD2(*(_QWORD *)v58) * v452;
                cmyk64_DpluslD((unsigned int *)v35, (unint64_t)*v35, ((unint64_t)(v451- ((v452 * (_DWORD)v451 + ((v452 * v451) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v58) - ((v453 + HIWORD(v453) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v58) - ((WORD1(*(_QWORD *)v58) * v452 + ((WORD1(*(_QWORD *)v58) * v452) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v58 - (((unsigned __int16)*(_QWORD *)v58 * v452 + (((unsigned __int16)*(_QWORD *)v58 * v452) >> 16) + 1) >> 16)));
              }
            }
            ++v59;
            v58 += 16;
            v198 += v240;
            ++v35;
            --v449;
          }
          while (v449);
        }
LABEL_501:
        v44 = (uint64_t)&v198[v493];
        goto LABEL_502;
      case 13:
        v247 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v249 = *v59;
          if (*v59)
          {
            if (!v44
              || (v249 = ((unsigned __int16)(*v248 * (_WORD)v249
                                                            + ((*v248 * v249) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v250 = *v247;
              v251 = (v249 | (v249 << 8)) ^ 0xFFFF;
              v252 = v250 - ((v251 * v250 + ((v251 * v250) >> 16) + 1) >> 16);
              if (v250 != (v251 * v250 + ((v251 * v250) >> 16) + 1) >> 16)
              {
                v253 = *((_QWORD *)v247 - 1);
                v254 = ((HIWORD(v253) - ((v251 * HIWORD(v253) + ((v251 * HIWORD(v253)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v253) - ((WORD2(v253) * v251 + ((WORD2(v253) * v251) >> 16) + 1) >> 16)) << 32) | ((WORD1(v253) - ((WORD1(v253) * v251 + ((WORD1(v253) * v251) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v253 - (((unsigned __int16)v253 * v251 + (((unsigned __int16)v253 * v251) >> 16) + 1) >> 16));
                v255 = v252;
                if (v505)
                {
                  if (*v31)
                  {
                    v254 = PDAmultiplyPDA_10646((unint64_t)*v35, (unsigned __int16)*v31, v254, (unsigned __int16)v252);
                    v255 = v256;
                  }
                  *v35 = (int8x8_t)v254;
                  *v31 = v255;
                }
                else
                {
                  *v35 = (int8x8_t)PDAmultiplyPDA_10646((unint64_t)*v35, 0xFFFFu, v254, (unsigned __int16)v252);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v247 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 14:
        v257 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v258 = *v59;
          if (*v59)
          {
            if (!v44
              || (v258 = ((unsigned __int16)(*v248 * (_WORD)v258
                                                            + ((*v248 * v258) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v259 = *v257;
              v260 = (v258 | (v258 << 8)) ^ 0xFFFF;
              v261 = v259 - ((v260 * v259 + ((v260 * v259) >> 16) + 1) >> 16);
              if (v259 != (v260 * v259 + ((v260 * v259) >> 16) + 1) >> 16)
              {
                v262 = *((_QWORD *)v257 - 1);
                v263 = ((HIWORD(v262) - ((v260 * HIWORD(v262) + ((v260 * HIWORD(v262)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v262) - ((WORD2(v262) * v260 + ((WORD2(v262) * v260) >> 16) + 1) >> 16)) << 32) | ((WORD1(v262) - ((WORD1(v262) * v260 + ((WORD1(v262) * v260) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v262 - (((unsigned __int16)v262 * v260 + (((unsigned __int16)v262 * v260) >> 16) + 1) >> 16));
                v264 = v261;
                if (v505)
                {
                  if (*v31)
                  {
                    v263 = PDAscreenPDA_10647((unint64_t)*v35, (unsigned __int16)*v31, v263, (unsigned __int16)v261);
                    v264 = v265;
                  }
                  *v35 = (int8x8_t)v263;
                  *v31 = v264;
                }
                else
                {
                  *v35 = (int8x8_t)PDAscreenPDA_10647((unint64_t)*v35, 0xFFFFu, v263, (unsigned __int16)v261);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v257 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 15:
        v266 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v267 = *v59;
          if (*v59)
          {
            if (!v44
              || (v267 = ((unsigned __int16)(*v248 * (_WORD)v267
                                                            + ((*v248 * v267) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v268 = *v266;
              v269 = (v267 | (v267 << 8)) ^ 0xFFFF;
              v270 = v268 - ((v269 * v268 + ((v269 * v268) >> 16) + 1) >> 16);
              if (v268 != (v269 * v268 + ((v269 * v268) >> 16) + 1) >> 16)
              {
                v271 = *((_QWORD *)v266 - 1);
                v272 = ((HIWORD(v271) - ((v269 * HIWORD(v271) + ((v269 * HIWORD(v271)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v271) - ((WORD2(v271) * v269 + ((WORD2(v271) * v269) >> 16) + 1) >> 16)) << 32) | ((WORD1(v271) - ((WORD1(v271) * v269 + ((WORD1(v271) * v269) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v271 - (((unsigned __int16)v271 * v269 + (((unsigned __int16)v271 * v269) >> 16) + 1) >> 16));
                v273 = v270;
                if (v505)
                {
                  if (*v31)
                  {
                    v272 = PDAoverlayPDA_10648((unint64_t)*v35, (unsigned __int16)*v31, v272, (unsigned __int16)v270);
                    v273 = v274;
                  }
                  *v35 = (int8x8_t)v272;
                  *v31 = v273;
                }
                else
                {
                  *v35 = (int8x8_t)PDAoverlayPDA_10648((unint64_t)*v35, 0xFFFFu, v272, (unsigned __int16)v270);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v266 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 16:
        v275 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v276 = *v59;
          if (*v59)
          {
            if (!v44
              || (v276 = ((unsigned __int16)(*v248 * (_WORD)v276
                                                            + ((*v248 * v276) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v277 = *v275;
              v278 = (v276 | (v276 << 8)) ^ 0xFFFF;
              v279 = v277 - ((v278 * v277 + ((v278 * v277) >> 16) + 1) >> 16);
              if (v277 != (v278 * v277 + ((v278 * v277) >> 16) + 1) >> 16)
              {
                v280 = *((_QWORD *)v275 - 1);
                v281 = ((HIWORD(v280) - ((v278 * HIWORD(v280) + ((v278 * HIWORD(v280)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v280) - ((WORD2(v280) * v278 + ((WORD2(v280) * v278) >> 16) + 1) >> 16)) << 32) | ((WORD1(v280) - ((WORD1(v280) * v278 + ((WORD1(v280) * v278) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v280 - (((unsigned __int16)v280 * v278 + (((unsigned __int16)v280 * v278) >> 16) + 1) >> 16));
                v282 = v279;
                if (v505)
                {
                  if (*v31)
                  {
                    v281 = PDAdarkenPDA_10650((unint64_t)*v35, (unsigned __int16)*v31, v281, (unsigned __int16)v279);
                    v282 = v283;
                  }
                  *v35 = (int8x8_t)v281;
                  *v31 = v282;
                }
                else
                {
                  *v35 = (int8x8_t)PDAdarkenPDA_10650((unint64_t)*v35, 0xFFFFu, v281, (unsigned __int16)v279);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v275 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 17:
        v284 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v285 = *v59;
          if (*v59)
          {
            if (!v44
              || (v285 = ((unsigned __int16)(*v248 * (_WORD)v285
                                                            + ((*v248 * v285) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v286 = *v284;
              v287 = (v285 | (v285 << 8)) ^ 0xFFFF;
              v288 = v286 - ((v287 * v286 + ((v287 * v286) >> 16) + 1) >> 16);
              if (v286 != (v287 * v286 + ((v287 * v286) >> 16) + 1) >> 16)
              {
                v289 = *((_QWORD *)v284 - 1);
                v290 = ((HIWORD(v289) - ((v287 * HIWORD(v289) + ((v287 * HIWORD(v289)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v289) - ((WORD2(v289) * v287 + ((WORD2(v289) * v287) >> 16) + 1) >> 16)) << 32) | ((WORD1(v289) - ((WORD1(v289) * v287 + ((WORD1(v289) * v287) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v289 - (((unsigned __int16)v289 * v287 + (((unsigned __int16)v289 * v287) >> 16) + 1) >> 16));
                v291 = v288;
                if (v505)
                {
                  if (*v31)
                  {
                    v290 = PDAlightenPDA_10649((unint64_t)*v35, (unsigned __int16)*v31, v290, (unsigned __int16)v288);
                    v291 = v292;
                  }
                  *v35 = (int8x8_t)v290;
                  *v31 = v291;
                }
                else
                {
                  *v35 = (int8x8_t)PDAlightenPDA_10649((unint64_t)*v35, 0xFFFFu, v290, (unsigned __int16)v288);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v284 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 18:
        v293 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v294 = *v59;
          if (*v59)
          {
            if (!v44
              || (v294 = ((unsigned __int16)(*v248 * (_WORD)v294
                                                            + ((*v248 * v294) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v295 = *v293;
              v296 = (v294 | (v294 << 8)) ^ 0xFFFF;
              v297 = v295 - ((v296 * v295 + ((v296 * v295) >> 16) + 1) >> 16);
              if (v295 != (v296 * v295 + ((v296 * v295) >> 16) + 1) >> 16)
              {
                v298 = *((_QWORD *)v293 - 1);
                v299 = ((HIWORD(v298) - ((v296 * HIWORD(v298) + ((v296 * HIWORD(v298)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v298) - ((WORD2(v298) * v296 + ((WORD2(v298) * v296) >> 16) + 1) >> 16)) << 32) | ((WORD1(v298) - ((WORD1(v298) * v296 + ((WORD1(v298) * v296) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v298 - (((unsigned __int16)v298 * v296 + (((unsigned __int16)v298 * v296) >> 16) + 1) >> 16));
                v300 = v297;
                if (v505)
                {
                  if (*v31)
                  {
                    v299 = PDAcolordodgePDA_10651((unint64_t)*v35, (unsigned __int16)*v31, v299, (unsigned __int16)v297);
                    v300 = v301;
                  }
                  *v35 = (int8x8_t)v299;
                  *v31 = v300;
                }
                else
                {
                  *v35 = (int8x8_t)PDAcolordodgePDA_10651((unint64_t)*v35, 0xFFFFu, v299, (unsigned __int16)v297);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v293 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 19:
        v302 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v303 = *v59;
          if (*v59)
          {
            if (!v44
              || (v303 = ((unsigned __int16)(*v248 * (_WORD)v303
                                                            + ((*v248 * v303) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v304 = *v302;
              v305 = (v303 | (v303 << 8)) ^ 0xFFFF;
              v306 = v304 - ((v305 * v304 + ((v305 * v304) >> 16) + 1) >> 16);
              if (v304 != (v305 * v304 + ((v305 * v304) >> 16) + 1) >> 16)
              {
                v307 = *((_QWORD *)v302 - 1);
                v308 = ((HIWORD(v307) - ((v305 * HIWORD(v307) + ((v305 * HIWORD(v307)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v307) - ((WORD2(v307) * v305 + ((WORD2(v307) * v305) >> 16) + 1) >> 16)) << 32) | ((WORD1(v307) - ((WORD1(v307) * v305 + ((WORD1(v307) * v305) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v307 - (((unsigned __int16)v307 * v305 + (((unsigned __int16)v307 * v305) >> 16) + 1) >> 16));
                v309 = v306;
                if (v505)
                {
                  if (*v31)
                  {
                    v308 = PDAcolorburnPDA_10652((unint64_t)*v35, (unsigned __int16)*v31, v308, (unsigned __int16)v306);
                    v309 = v310;
                  }
                  *v35 = (int8x8_t)v308;
                  *v31 = v309;
                }
                else
                {
                  *v35 = (int8x8_t)PDAcolorburnPDA_10652((unint64_t)*v35, 0xFFFFu, v308, (unsigned __int16)v306);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v302 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 20:
        v311 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v312 = *v59;
          if (*v59)
          {
            if (!v44
              || (v312 = ((unsigned __int16)(*v248 * (_WORD)v312
                                                            + ((*v248 * v312) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v313 = *v311;
              v314 = (v312 | (v312 << 8)) ^ 0xFFFF;
              v315 = v313 - ((v314 * v313 + ((v314 * v313) >> 16) + 1) >> 16);
              if (v313 != (v314 * v313 + ((v314 * v313) >> 16) + 1) >> 16)
              {
                v316 = *((_QWORD *)v311 - 1);
                v317 = ((HIWORD(v316) - ((v314 * HIWORD(v316) + ((v314 * HIWORD(v316)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v316) - ((WORD2(v316) * v314 + ((WORD2(v316) * v314) >> 16) + 1) >> 16)) << 32) | ((WORD1(v316) - ((WORD1(v316) * v314 + ((WORD1(v316) * v314) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v316 - (((unsigned __int16)v316 * v314 + (((unsigned __int16)v316 * v314) >> 16) + 1) >> 16));
                v318 = v315;
                if (v505)
                {
                  if (*v31)
                  {
                    v317 = PDAsoftlightPDA_10654((unint64_t)*v35, (unsigned __int16)*v31, v317, (unsigned __int16)v315);
                    v318 = v319;
                  }
                  *v35 = (int8x8_t)v317;
                  *v31 = v318;
                }
                else
                {
                  *v35 = (int8x8_t)PDAsoftlightPDA_10654((unint64_t)*v35, 0xFFFFu, v317, (unsigned __int16)v315);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v311 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 21:
        v320 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v321 = *v59;
          if (*v59)
          {
            if (!v44
              || (v321 = ((unsigned __int16)(*v248 * (_WORD)v321
                                                            + ((*v248 * v321) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v322 = *v320;
              v323 = (v321 | (v321 << 8)) ^ 0xFFFF;
              v324 = v322 - ((v323 * v322 + ((v323 * v322) >> 16) + 1) >> 16);
              if (v322 != (v323 * v322 + ((v323 * v322) >> 16) + 1) >> 16)
              {
                v325 = *((_QWORD *)v320 - 1);
                v326 = ((HIWORD(v325) - ((v323 * HIWORD(v325) + ((v323 * HIWORD(v325)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v325) - ((WORD2(v325) * v323 + ((WORD2(v325) * v323) >> 16) + 1) >> 16)) << 32) | ((WORD1(v325) - ((WORD1(v325) * v323 + ((WORD1(v325) * v323) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v325 - (((unsigned __int16)v325 * v323 + (((unsigned __int16)v325 * v323) >> 16) + 1) >> 16));
                v327 = v324;
                if (v505)
                {
                  if (*v31)
                  {
                    v326 = PDAhardlightPDA_10653((unint64_t)*v35, (unsigned __int16)*v31, v326, (unsigned __int16)v324);
                    v327 = v328;
                  }
                  *v35 = (int8x8_t)v326;
                  *v31 = v327;
                }
                else
                {
                  *v35 = (int8x8_t)PDAhardlightPDA_10653((unint64_t)*v35, 0xFFFFu, v326, (unsigned __int16)v324);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v320 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 22:
        v329 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v330 = *v59;
          if (*v59)
          {
            if (!v44
              || (v330 = ((unsigned __int16)(*v248 * (_WORD)v330
                                                            + ((*v248 * v330) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v331 = *v329;
              v332 = (v330 | (v330 << 8)) ^ 0xFFFF;
              v333 = v331 - ((v332 * v331 + ((v332 * v331) >> 16) + 1) >> 16);
              if (v331 != (v332 * v331 + ((v332 * v331) >> 16) + 1) >> 16)
              {
                v334 = *((_QWORD *)v329 - 1);
                v335 = ((HIWORD(v334) - ((v332 * HIWORD(v334) + ((v332 * HIWORD(v334)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v334) - ((WORD2(v334) * v332 + ((WORD2(v334) * v332) >> 16) + 1) >> 16)) << 32) | ((WORD1(v334) - ((WORD1(v334) * v332 + ((WORD1(v334) * v332) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v334 - (((unsigned __int16)v334 * v332 + (((unsigned __int16)v334 * v332) >> 16) + 1) >> 16));
                v336 = v333;
                if (v505)
                {
                  if (*v31)
                  {
                    v335 = PDAdifferencePDA_10655((unint64_t)*v35, (unsigned __int16)*v31, v335, (unsigned __int16)v333);
                    v336 = v337;
                  }
                  *v35 = (int8x8_t)v335;
                  *v31 = v336;
                }
                else
                {
                  *v35 = (int8x8_t)PDAdifferencePDA_10655((unint64_t)*v35, 0xFFFFu, v335, (unsigned __int16)v333);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v329 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 23:
        v338 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v339 = *v59;
          if (*v59)
          {
            if (!v44
              || (v339 = ((unsigned __int16)(*v248 * (_WORD)v339
                                                            + ((*v248 * v339) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v340 = *v338;
              v341 = (v339 | (v339 << 8)) ^ 0xFFFF;
              v342 = v340 - ((v341 * v340 + ((v341 * v340) >> 16) + 1) >> 16);
              if (v340 != (v341 * v340 + ((v341 * v340) >> 16) + 1) >> 16)
              {
                v343 = *((_QWORD *)v338 - 1);
                v344 = ((HIWORD(v343) - ((v341 * HIWORD(v343) + ((v341 * HIWORD(v343)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v343) - ((WORD2(v343) * v341 + ((WORD2(v343) * v341) >> 16) + 1) >> 16)) << 32) | ((WORD1(v343) - ((WORD1(v343) * v341 + ((WORD1(v343) * v341) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v343 - (((unsigned __int16)v343 * v341 + (((unsigned __int16)v343 * v341) >> 16) + 1) >> 16));
                v345 = v342;
                if (v505)
                {
                  if (*v31)
                  {
                    v344 = PDAexclusionPDA_10656((unint64_t)*v35, (unsigned __int16)*v31, v344, (unsigned __int16)v342);
                    v345 = v346;
                  }
                  *v35 = (int8x8_t)v344;
                  *v31 = v345;
                }
                else
                {
                  *v35 = (int8x8_t)PDAexclusionPDA_10656((unint64_t)*v35, 0xFFFFu, v344, (unsigned __int16)v342);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v338 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 24:
        v347 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v348 = *v59;
          if (*v59)
          {
            if (!v44
              || (v348 = ((unsigned __int16)(*v248 * (_WORD)v348
                                                            + ((*v248 * v348) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v349 = *v347;
              v350 = (v348 | (v348 << 8)) ^ 0xFFFF;
              v351 = v349 - ((v350 * v349 + ((v350 * v349) >> 16) + 1) >> 16);
              if (v349 != (v350 * v349 + ((v350 * v349) >> 16) + 1) >> 16)
              {
                v352 = *((_QWORD *)v347 - 1);
                v353 = ((HIWORD(v352) - ((v350 * HIWORD(v352) + ((v350 * HIWORD(v352)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v352) - ((WORD2(v352) * v350 + ((WORD2(v352) * v350) >> 16) + 1) >> 16)) << 32) | ((WORD1(v352) - ((WORD1(v352) * v350 + ((WORD1(v352) * v350) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v352 - (((unsigned __int16)v352 * v350 + (((unsigned __int16)v352 * v350) >> 16) + 1) >> 16));
                v354 = v351;
                if (v505)
                {
                  if (*v31)
                  {
                    v353 = PDAhuePDA_10657((unint64_t)*v35, (unsigned __int16)*v31, v353, (unsigned __int16)v351);
                    v354 = v355;
                  }
                  *v35 = (int8x8_t)v353;
                  *v31 = v354;
                }
                else
                {
                  *v35 = (int8x8_t)PDAhuePDA_10657((unint64_t)*v35, 0xFFFFu, v353, (unsigned __int16)v351);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v347 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 25:
        v356 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v357 = *v59;
          if (*v59)
          {
            if (!v44
              || (v357 = ((unsigned __int16)(*v248 * (_WORD)v357
                                                            + ((*v248 * v357) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v358 = *v356;
              v359 = (v357 | (v357 << 8)) ^ 0xFFFF;
              v360 = v358 - ((v359 * v358 + ((v359 * v358) >> 16) + 1) >> 16);
              if (v358 != (v359 * v358 + ((v359 * v358) >> 16) + 1) >> 16)
              {
                v361 = *((_QWORD *)v356 - 1);
                v362 = ((HIWORD(v361) - ((v359 * HIWORD(v361) + ((v359 * HIWORD(v361)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v361) - ((WORD2(v361) * v359 + ((WORD2(v361) * v359) >> 16) + 1) >> 16)) << 32) | ((WORD1(v361) - ((WORD1(v361) * v359 + ((WORD1(v361) * v359) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v361 - (((unsigned __int16)v361 * v359 + (((unsigned __int16)v361 * v359) >> 16) + 1) >> 16));
                v363 = v360;
                if (v505)
                {
                  if (*v31)
                  {
                    v362 = PDAsaturationPDA_10658((unint64_t)*v35, (unsigned __int16)*v31, v362, (unsigned __int16)v360);
                    v363 = v364;
                  }
                  *v35 = (int8x8_t)v362;
                  *v31 = v363;
                }
                else
                {
                  *v35 = (int8x8_t)PDAsaturationPDA_10658((unint64_t)*v35, 0xFFFFu, v362, (unsigned __int16)v360);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v356 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 26:
        v365 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v366 = *v59;
          if (*v59)
          {
            if (!v44
              || (v366 = ((unsigned __int16)(*v248 * (_WORD)v366
                                                            + ((*v248 * v366) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v367 = *v365;
              v368 = (v366 | (v366 << 8)) ^ 0xFFFF;
              v369 = v367 - ((v368 * v367 + ((v368 * v367) >> 16) + 1) >> 16);
              if (v367 != (v368 * v367 + ((v368 * v367) >> 16) + 1) >> 16)
              {
                v370 = *((_QWORD *)v365 - 1);
                v371 = ((HIWORD(v370) - ((v368 * HIWORD(v370) + ((v368 * HIWORD(v370)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v370) - ((WORD2(v370) * v368 + ((WORD2(v370) * v368) >> 16) + 1) >> 16)) << 32) | ((WORD1(v370) - ((WORD1(v370) * v368 + ((WORD1(v370) * v368) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v370 - (((unsigned __int16)v370 * v368 + (((unsigned __int16)v370 * v368) >> 16) + 1) >> 16));
                v372 = v369;
                if (v505)
                {
                  if (*v31)
                    v371 = PDAluminosityPDA_10659(v371, (unsigned __int16)v369, (unint64_t)*v35, (unsigned __int16)*v31);
                  *v35 = (int8x8_t)v371;
                  *v31 = v372;
                }
                else
                {
                  *v35 = (int8x8_t)PDAluminosityPDA_10659(v371, (unsigned __int16)v369, (unint64_t)*v35, 0xFFFFu);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v365 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
        goto LABEL_418;
      case 27:
        v373 = (unsigned __int16 *)(v58 + 8);
        v248 = (unsigned __int8 *)v44;
        do
        {
          v374 = *v59;
          if (*v59)
          {
            if (!v44
              || (v374 = ((unsigned __int16)(*v248 * (_WORD)v374
                                                            + ((*v248 * v374) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              v375 = *v373;
              v376 = (v374 | (v374 << 8)) ^ 0xFFFF;
              v377 = v375 - ((v376 * v375 + ((v376 * v375) >> 16) + 1) >> 16);
              if (v375 != (v376 * v375 + ((v376 * v375) >> 16) + 1) >> 16)
              {
                v378 = *((_QWORD *)v373 - 1);
                v379 = ((HIWORD(v378) - ((v376 * HIWORD(v378) + ((v376 * HIWORD(v378)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v378) - ((WORD2(v378) * v376 + ((WORD2(v378) * v376) >> 16) + 1) >> 16)) << 32) | ((WORD1(v378) - ((WORD1(v378) * v376 + ((WORD1(v378) * v376) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v378 - (((unsigned __int16)v378 * v376 + (((unsigned __int16)v378 * v376) >> 16) + 1) >> 16));
                v380 = v377;
                if (v505)
                {
                  if (*v31)
                  {
                    v379 = PDAluminosityPDA_10659((unint64_t)*v35, (unsigned __int16)*v31, v379, (unsigned __int16)v377);
                    v380 = v381;
                  }
                  *v35 = (int8x8_t)v379;
                  *v31 = v380;
                }
                else
                {
                  *v35 = (int8x8_t)PDAluminosityPDA_10659((unint64_t)*v35, 0xFFFFu, v379, (unsigned __int16)v377);
                }
              }
            }
          }
          ++v59;
          v248 += v44 != 0;
          ++v35;
          v373 += 8;
          v31 = (__int16 *)((char *)v31 + v54);
          --v51;
        }
        while (v51);
LABEL_418:
        v44 = (uint64_t)&v248[v493];
LABEL_502:
        v35 += v494;
        v31 += v495;
        v50 = v503;
        v39 = v497;
        v51 = v504;
        v119 = v501;
        v454 = (int)v498;
        goto LABEL_503;
      default:
        goto LABEL_540;
    }
  }
}

unsigned int *cmyk64_DAMplusDAM(unsigned int *result, _WORD *a2, unint64_t a3, int a4, int a5, unint64_t a6, int a7, int a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v8 = WORD1(a3) * a5 + WORD1(a6) * a8;
  v9 = WORD2(a3) * a5 + WORD2(a6) * a8;
  v10 = a5 * HIWORD(a3) + a8 * HIWORD(a6);
  *result = (v8 + HIWORD(v8) + 1) & 0xFFFF0000 | (((unsigned __int16)a3 * a5
                                                 + (unsigned __int16)a6 * a8
                                                 + (((unsigned __int16)a3 * a5 + (unsigned __int16)a6 * a8) >> 16)
                                                 + 1) >> 16);
  result[1] = (v10 + HIWORD(v10) + 1) & 0xFFFF0000 | ((v9 + HIWORD(v9) + 1) >> 16);
  *a2 = (a5 * a4 + a8 * a7 + ((a5 * a4 + a8 * a7) >> 16) + 1) >> 16;
  return result;
}

unsigned int *cmyk64_DMplusDM(unsigned int *result, unint64_t a2, int a3, unint64_t a4, int a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v5 = WORD1(a2) * a3 + WORD1(a4) * a5;
  v6 = WORD2(a2) * a3 + WORD2(a4) * a5;
  v7 = HIWORD(a2) * a3 + HIWORD(a4) * a5;
  *result = (v5 + HIWORD(v5) + 1) & 0xFFFF0000 | (((unsigned __int16)a2 * a3
                                                 + (unsigned __int16)a4 * a5
                                                 + (((unsigned __int16)a2 * a3 + (unsigned __int16)a4 * a5) >> 16)
                                                 + 1) >> 16);
  result[1] = (v7 + HIWORD(v7) + 1) & 0xFFFF0000 | ((v6 + HIWORD(v6) + 1) >> 16);
  return result;
}

_QWORD *cmyk64_DAplusDAM(_QWORD *result, _WORD *a2, uint64_t a3, __int16 a4, unint64_t a5, int a6, int a7)
{
  *result = ((WORD1(a5) * a7 + ((WORD1(a5) * a7) >> 16) + 1) & 0xFFFF0000)
          + a3
          + (((unsigned __int16)a5 * a7 + (((unsigned __int16)a5 * a7) >> 16) + 1) >> 16)
          + ((unint64_t)((WORD2(a5) * a7 + ((WORD2(a5) * a7) >> 16) + 1) >> 16) << 32)
          + ((a7 * HIWORD(a5) + ((a7 * HIWORD(a5)) >> 16) + 1) >> 16 << 48);
  *a2 = a4 + ((a7 * a6 + ((a7 * a6) >> 16) + 1) >> 16);
  return result;
}

_QWORD *cmyk64_DplusDM(_QWORD *result, uint64_t a2, unint64_t a3, int a4)
{
  *result = ((WORD1(a3) * a4 + ((WORD1(a3) * a4) >> 16) + 1) & 0xFFFF0000)
          + a2
          + (((unsigned __int16)a3 * a4 + (((unsigned __int16)a3 * a4) >> 16) + 1) >> 16)
          + ((HIWORD(a3) * a4 + ((HIWORD(a3) * a4) >> 16) + 1) >> 16 << 48)
          + ((unint64_t)((WORD2(a3) * a4 + ((WORD2(a3) * a4) >> 16) + 1) >> 16) << 32);
  return result;
}

int *cmyk64_DAplusdDA(int *result, __int16 *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  int v6;
  int v7;
  int v8;
  __int16 v9;

  v6 = a4 - (WORD1(a3) + WORD1(a5)) + a6;
  v7 = a4 + a6 - (WORD2(a3) + WORD2(a5));
  v8 = a4 - (HIWORD(a3) + HIWORD(a5)) + a6;
  if (v6 >= 0xFFFF)
    LOWORD(v6) = -1;
  if (v7 >= 0xFFFF)
    LOWORD(v7) = -1;
  if (v8 >= 0xFFFF)
    LOWORD(v8) = -1;
  if ((a4 + a6) >= 0xFFFF)
    v9 = -1;
  else
    v9 = a4 + a6;
  *result = (unsigned __int16)(v9 - v6) | ((unsigned __int16)(v9 - v6) << 16);
  result[1] = (unsigned __int16)(v9 - v7) | ((unsigned __int16)(v9 - v8) << 16);
  *a2 = v9;
  return result;
}

int *cmyk64_DplusdDA(int *result, unint64_t a2, unint64_t a3, int a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unsigned __int16 v7;

  v4 = a4 - WORD2(a3) + (unsigned __int16)~WORD2(a2);
  v5 = a4 - HIWORD(a3) + (HIWORD(a2) ^ 0xFFFF);
  if ((int)(a4 - WORD1(a3) + (~(_DWORD)a2 >> 16)) >= 0xFFFF)
    LOWORD(v6) = -1;
  else
    v6 = a4 - WORD1(a3) + (~(_DWORD)a2 >> 16);
  v7 = ~(_WORD)v6;
  if (v4 >= 0xFFFF)
    LOWORD(v4) = -1;
  if (v5 >= 0xFFFF)
    LOWORD(v5) = -1;
  *result = v7 | (v7 << 16);
  result[1] = ((unsigned __int16)v4 | ((unsigned __int16)~(_WORD)v5 << 16)) ^ 0xFFFF;
  return result;
}

unsigned int *cmyk64_DApluslDA(unsigned int *result, _WORD *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v6 = (unsigned __int16)a5 + (unsigned __int16)a3;
  v7 = WORD1(a5) + WORD1(a3);
  v8 = WORD2(a5) + WORD2(a3);
  v9 = HIWORD(a5) + HIWORD(a3);
  v10 = a6 + a4;
  if (v6 >= 0xFFFF)
    v6 = 0xFFFF;
  if (v7 >= 0xFFFF)
    v7 = 0xFFFF;
  if (v8 >= 0xFFFF)
    v8 = 0xFFFF;
  if (v9 >= 0xFFFF)
    v9 = 0xFFFF;
  if (v10 >= 0xFFFF)
    LOWORD(v10) = -1;
  *result = v6 | (v7 << 16);
  result[1] = v8 | (v9 << 16);
  *a2 = v10;
  return result;
}

unsigned int *cmyk64_DpluslD(unsigned int *result, unint64_t a2, unint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  v3 = (unsigned __int16)a3 + (unsigned __int16)a2;
  v4 = WORD1(a3) + WORD1(a2);
  v5 = WORD2(a3) + WORD2(a2);
  v6 = HIWORD(a3) + HIWORD(a2);
  if (v3 >= 0xFFFF)
    v3 = 0xFFFF;
  if (v4 >= 0xFFFF)
    v4 = 0xFFFF;
  if (v5 >= 0xFFFF)
    v5 = 0xFFFF;
  if (v6 >= 0xFFFF)
    v6 = 0xFFFF;
  *result = v3 | (v4 << 16);
  result[1] = v5 | (v6 << 16);
  return result;
}

unint64_t PDAmultiplyPDA_10646(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  BOOL v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unsigned int v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;

  v4 = a4;
  v5 = a4 - (unsigned __int16)a3;
  v6 = a4 - WORD1(a3);
  v7 = a4 - WORD2(a3);
  v8 = a4 - HIWORD(a3);
  v9 = a4 == 0xFFFF;
  v10 = a4 ^ 0xFFFF;
  v11 = v5 + (a4 ^ 0xFFFF);
  v12 = v6 + v10;
  v13 = v7 + v10;
  v14 = v8 + v10;
  if (v9)
  {
    v11 = v5;
    v12 = v6;
    v13 = v7;
    v14 = v8;
  }
  v15 = v14 * (uint64_t)(int)(a2 - HIWORD(a1));
  v16 = (int)v13 * (uint64_t)(int)(a2 - WORD2(a1));
  v17 = (int)v12 * (uint64_t)(int)(a2 - WORD1(a1));
  v18 = (int)v11 * (uint64_t)(int)(a2 - (unsigned __int16)a1);
  v19 = v18 + (int)v5 * (uint64_t)(int)(a2 ^ 0xFFFF);
  v20 = v17 + (int)v6 * (uint64_t)(int)(a2 ^ 0xFFFF);
  v21 = v16 + (int)v7 * (uint64_t)(int)(a2 ^ 0xFFFF);
  v22 = v15 + (int)v8 * (uint64_t)(int)(a2 ^ 0xFFFF);
  if (a2 != 0xFFFF)
  {
    v18 = v19;
    v17 = v20;
    v16 = v21;
    v15 = v22;
  }
  v23 = 0xFFFF * (v4 + a2) - v4 * (unint64_t)a2;
  if (v18 <= 4294868992)
    v24 = v18 + 0x8000;
  else
    v24 = 4294868992;
  v25 = (v24 >> 16) + v24;
  if (v17 <= 4294868992)
    v26 = v17 + 0x8000;
  else
    v26 = 4294868992;
  v27 = (v26 >> 16) + v26;
  if (v16 <= 4294868992)
    v28 = v16 + 0x8000;
  else
    v28 = 4294868992;
  v29 = (v28 >> 16) + v28;
  if (v15 <= 4294868992)
    v30 = v15 + 0x8000;
  else
    v30 = 4294868992;
  v31 = (v30 >> 16) + v30;
  if (v23 <= 4294868992)
    v32 = v23 + 0x8000;
  else
    v32 = 4294868992;
  return ((unint64_t)(unsigned __int16)(((v32 + (v32 >> 16)) >> 16) - HIWORD(v29)) << 32) | ((unint64_t)(((v32 + (v32 >> 16)) >> 16) - HIWORD(v31)) << 48) | ((((v32 + (v32 >> 16)) >> 16) - HIWORD(v27)) << 16) | (unsigned __int16)(((v32 + (v32 >> 16)) >> 16) - HIWORD(v25));
}

unint64_t PDAscreenPDA_10647(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  int64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;

  v4 = (int)(a4 - (unsigned __int16)a3) * (uint64_t)(int)(0xFFFF - (a2 - (unsigned __int16)a1))
     - (a2
      - (unint64_t)(unsigned __int16)a1)
     + ((a2 - (unint64_t)(unsigned __int16)a1) << 16);
  v5 = (int)(a4 - WORD1(a3)) * (uint64_t)(int)(0xFFFF - (a2 - WORD1(a1)))
     - (a2
      - (unint64_t)WORD1(a1))
     + ((a2 - (unint64_t)WORD1(a1)) << 16);
  v6 = (int)(a4 - WORD2(a3)) * (uint64_t)(int)(0xFFFF - (a2 - WORD2(a1)))
     - (a2
      - (unint64_t)WORD2(a1))
     + ((a2 - (unint64_t)WORD2(a1)) << 16);
  v7 = (int)(a4 - HIWORD(a3)) * (uint64_t)(int)(0xFFFF - (a2 - HIWORD(a1)))
     - (a2
      - HIWORD(a1))
     + ((a2 - HIWORD(a1)) << 16);
  v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v4 <= 4294868992)
    v9 = v4 + 0x8000;
  else
    v9 = 4294868992;
  v10 = (v9 >> 16) + v9;
  if (v5 <= 4294868992)
    v11 = v5 + 0x8000;
  else
    v11 = 4294868992;
  v12 = (v11 >> 16) + v11;
  if (v6 <= 4294868992)
    v13 = v6 + 0x8000;
  else
    v13 = 4294868992;
  v14 = (v13 >> 16) + v13;
  if (v7 <= 4294868992)
    v15 = v7 + 0x8000;
  else
    v15 = 4294868992;
  v16 = (v15 >> 16) + v15;
  if (v8 <= 4294868992)
    v17 = v8 + 0x8000;
  else
    v17 = 4294868992;
  return ((unint64_t)(((v17 + (v17 >> 16)) >> 16) - HIWORD(v16)) << 48) | ((unint64_t)(unsigned __int16)(((v17 + (v17 >> 16)) >> 16) - HIWORD(v14)) << 32) | ((((v17 + (v17 >> 16)) >> 16) - HIWORD(v12)) << 16) | (unsigned __int16)(((v17 + (v17 >> 16)) >> 16) - HIWORD(v10));
}

unint64_t PDAoverlayPDA_10648(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  unint64_t v7;
  int64_t v8;
  uint64_t v9;
  unint64_t v10;
  int64_t v11;
  unint64_t v12;
  int64_t v13;
  unint64_t v14;
  int64_t v15;
  unint64_t v16;
  int64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  int64x2_t v27;
  int v28;
  int64x2_t v29;
  int8x16_t v30;
  int8x16_t v31;
  unint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;
  uint64x2_t v36;
  int8x16_t v37;

  v4 = a2;
  v5 = a2 - (unint64_t)WORD2(a1);
  v6 = a2 - HIWORD(a1);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v7 = a4;
  else
    v7 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v8 = a2;
  else
    v8 = a2 - (unint64_t)(unsigned __int16)a1;
  v9 = 2 * v8 * v7;
  if ((uint64_t)(a4 - (unint64_t)WORD1(a3)) >= a4)
    v10 = a4;
  else
    v10 = a4 - (unint64_t)WORD1(a3);
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2)
    v11 = a2;
  else
    v11 = a2 - (unint64_t)WORD1(a1);
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4)
    v12 = a4;
  else
    v12 = a4 - (unint64_t)WORD2(a3);
  if (v5 >= a2)
    v13 = a2;
  else
    v13 = v5;
  if ((uint64_t)(a4 - HIWORD(a3)) >= a4)
    v14 = a4;
  else
    v14 = a4 - HIWORD(a3);
  if (v6 >= a2)
    v15 = a2;
  else
    v15 = v6;
  v16 = a4 * (unint64_t)a2;
  v17 = ((unint64_t)a2 + 1) >> 1;
  if (v8 >= v17)
    v18 = v7 * (a2 + 0xFFFFLL) + (a4 + 0xFFFFLL) * v8 - (v16 + v9);
  else
    v18 = (a4 ^ 0xFFFFLL) * v8 + v7 * (a2 ^ 0xFFFFLL) + v9;
  v19 = 2 * v11 * v10;
  if (v11 >= v17)
    v20 = v10 * (a2 + 0xFFFFLL) + (a4 + 0xFFFFLL) * v11 - (v16 + v19);
  else
    v20 = (a4 ^ 0xFFFFLL) * v11 + v10 * (a2 ^ 0xFFFFLL) + v19;
  v21 = 2 * v13 * v12;
  if (v13 >= v17)
    v22 = v12 * (v4 + 0xFFFF) + (a4 + 0xFFFFLL) * v13 - (v16 + v21);
  else
    v22 = (a4 ^ 0xFFFFLL) * v13 + v12 * (v4 ^ 0xFFFF) + v21;
  v23 = 2 * v15 * v14;
  if (v15 >= v17)
    v24 = v14 * (v4 + 0xFFFF) + (a4 + 0xFFFFLL) * v15 - (v16 + v23);
  else
    v24 = (a4 ^ 0xFFFFLL) * v15 + v14 * (v4 ^ 0xFFFF) + v23;
  v25 = 0xFFFF * (a4 + v4) - v16;
  v26 = v18 + 0x8000;
  if (v18 > 4294868992)
    v26 = 4294868992;
  v27.i64[0] = v22;
  v27.i64[1] = v20;
  v28 = (v26 >> 16) + v26;
  v29 = vdupq_n_s64(0xFFFE8000uLL);
  v30 = (int8x16_t)vcgtq_s64(v27, v29);
  v31 = (int8x16_t)vaddq_s64(v27, vdupq_n_s64(0x8000uLL));
  if (v24 <= 4294868992)
    v32 = v24 + 0x8000;
  else
    v32 = 4294868992;
  v33 = (v32 >> 16) + v32;
  if (v25 <= 4294868992)
    v34 = v25 + 0x8000;
  else
    v34 = 4294868992;
  v35 = (v34 + (v34 >> 16)) >> 16;
  v36 = (uint64x2_t)vbslq_s8(v30, (int8x16_t)v29, v31);
  v37 = vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vsubq_s64(vdupq_n_s64(v35), (int64x2_t)vshrq_n_u64(vsraq_n_u64(v36, v36, 0x10uLL), 0x10uLL)), (uint64x2_t)xmmword_185004E00), (int8x16_t)xmmword_185004E10);
  return v37.i64[0] | ((unint64_t)(v35 - HIWORD(v33)) << 48) | (unsigned __int16)(v35 - HIWORD(v28)) | v37.i64[1];
}

unint64_t PDAlightenPDA_10649(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  int64_t v8;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  int64_t v13;
  int64_t v14;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int64_t v24;
  unint64_t v25;
  int v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;

  v4 = a2 - (unint64_t)(unsigned __int16)a1;
  v5 = a2 - (unint64_t)WORD1(a1);
  v6 = a2 - (unint64_t)WORD2(a1);
  v7 = a2 - HIWORD(a1);
  v8 = a4 - (unint64_t)(unsigned __int16)a3;
  v9 = a4 - (unint64_t)WORD1(a3);
  v10 = a4 - (unint64_t)WORD2(a3);
  v11 = a4 - HIWORD(a3);
  if (v8 >= a4)
    v8 = a4;
  if (v4 >= a2)
    v4 = a2;
  v12 = v4 * a4;
  if (v8 * a2 > v12)
    v12 = v8 * a2;
  if (v9 >= a4)
    v9 = a4;
  if (v5 >= a2)
    v5 = a2;
  v13 = v5 * a4;
  if (v9 * a2 > v13)
    v13 = v9 * a2;
  if (v10 >= a4)
    v10 = a4;
  if (v6 >= a2)
    v6 = a2;
  v14 = v6 * a4;
  if (v10 * a2 > v14)
    v14 = v10 * a2;
  if (v11 >= a4)
    v11 = a4;
  if (v7 >= a2)
    v7 = a2;
  v15 = v7 * a4;
  if (v11 * a2 > v15)
    v15 = v11 * a2;
  v16 = v12 + (a4 ^ 0xFFFFLL) * v4;
  v17 = v13 + (a4 ^ 0xFFFFLL) * v5;
  v18 = v14 + (a4 ^ 0xFFFFLL) * v6;
  v19 = v15 + (a4 ^ 0xFFFFLL) * v7;
  if (a4 == 0xFFFF)
  {
    v19 = v15;
    v18 = v14;
    v17 = v13;
    v16 = v12;
  }
  v20 = v16 + v8 * (a2 ^ 0xFFFFLL);
  v21 = v17 + v9 * (a2 ^ 0xFFFFLL);
  v22 = v18 + v10 * (a2 ^ 0xFFFFLL);
  v23 = v19 + v11 * (a2 ^ 0xFFFFLL);
  if (a2 != 0xFFFF)
  {
    v19 = v23;
    v18 = v22;
    v17 = v21;
    v16 = v20;
  }
  v24 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  v25 = v16 + 0x8000;
  if (v16 > 4294868992)
    v25 = 4294868992;
  v26 = (v25 >> 16) + v25;
  v27 = v17 + 0x8000;
  if (v17 > 4294868992)
    v27 = 4294868992;
  v28 = (v27 >> 16) + v27;
  if (v18 <= 4294868992)
    v29 = v18 + 0x8000;
  else
    v29 = 4294868992;
  v30 = (v29 >> 16) + v29;
  v31 = v19 + 0x8000;
  if (v19 > 4294868992)
    v31 = 4294868992;
  v32 = (v31 >> 16) + v31;
  if (v24 <= 4294868992)
    v33 = v24 + 0x8000;
  else
    v33 = 4294868992;
  return ((unint64_t)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v32)) << 48) | ((unint64_t)(unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v30)) << 32) | ((((v33 + (v33 >> 16)) >> 16) - HIWORD(v28)) << 16) | (unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v26));
}

unint64_t PDAdarkenPDA_10650(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  int64_t v8;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  int64_t v13;
  int64_t v14;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int64_t v24;
  unint64_t v25;
  int v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;

  v4 = a2 - (unint64_t)(unsigned __int16)a1;
  v5 = a2 - (unint64_t)WORD1(a1);
  v6 = a2 - (unint64_t)WORD2(a1);
  v7 = a2 - HIWORD(a1);
  v8 = a4 - (unint64_t)(unsigned __int16)a3;
  v9 = a4 - (unint64_t)WORD1(a3);
  v10 = a4 - (unint64_t)WORD2(a3);
  v11 = a4 - HIWORD(a3);
  if (v8 >= a4)
    v8 = a4;
  if (v4 >= a2)
    v4 = a2;
  v12 = v4 * a4;
  if (v8 * a2 < v12)
    v12 = v8 * a2;
  if (v9 >= a4)
    v9 = a4;
  if (v5 >= a2)
    v5 = a2;
  v13 = v5 * a4;
  if (v9 * a2 < v13)
    v13 = v9 * a2;
  if (v10 >= a4)
    v10 = a4;
  if (v6 >= a2)
    v6 = a2;
  v14 = v6 * a4;
  if (v10 * a2 < v14)
    v14 = v10 * a2;
  if (v11 >= a4)
    v11 = a4;
  if (v7 >= a2)
    v7 = a2;
  v15 = v7 * a4;
  if (v11 * a2 < v15)
    v15 = v11 * a2;
  v16 = v12 + (a4 ^ 0xFFFFLL) * v4;
  v17 = v13 + (a4 ^ 0xFFFFLL) * v5;
  v18 = v14 + (a4 ^ 0xFFFFLL) * v6;
  v19 = v15 + (a4 ^ 0xFFFFLL) * v7;
  if (a4 == 0xFFFF)
  {
    v19 = v15;
    v18 = v14;
    v17 = v13;
    v16 = v12;
  }
  v20 = v16 + v8 * (a2 ^ 0xFFFFLL);
  v21 = v17 + v9 * (a2 ^ 0xFFFFLL);
  v22 = v18 + v10 * (a2 ^ 0xFFFFLL);
  v23 = v19 + v11 * (a2 ^ 0xFFFFLL);
  if (a2 != 0xFFFF)
  {
    v19 = v23;
    v18 = v22;
    v17 = v21;
    v16 = v20;
  }
  v24 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  v25 = v16 + 0x8000;
  if (v16 > 4294868992)
    v25 = 4294868992;
  v26 = (v25 >> 16) + v25;
  v27 = v17 + 0x8000;
  if (v17 > 4294868992)
    v27 = 4294868992;
  v28 = (v27 >> 16) + v27;
  if (v18 <= 4294868992)
    v29 = v18 + 0x8000;
  else
    v29 = 4294868992;
  v30 = (v29 >> 16) + v29;
  v31 = v19 + 0x8000;
  if (v19 > 4294868992)
    v31 = 4294868992;
  v32 = (v31 >> 16) + v31;
  if (v24 <= 4294868992)
    v33 = v24 + 0x8000;
  else
    v33 = 4294868992;
  return ((unint64_t)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v32)) << 48) | ((unint64_t)(unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v30)) << 32) | ((((v33 + (v33 >> 16)) >> 16) - HIWORD(v28)) << 16) | (unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v26));
}

unint64_t PDAcolordodgePDA_10651(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4;
  int64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  int64_t v22;
  int64_t v23;
  int64_t v24;
  unint64_t v25;
  int v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;

  v4 = 4294836225;
  v5 = a2 - (unint64_t)WORD1(a1);
  v6 = a4 * (unint64_t)a4;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v7 = a2;
  else
    v7 = a2 - (unint64_t)(unsigned __int16)a1;
  if (v7)
  {
    v8 = 4294836225;
    if ((_WORD)a3)
      v8 = (uint64_t)(v6 * v7) / (unsigned __int16)a3;
  }
  else
  {
    v8 = 0;
  }
  v9 = a3 >> 16;
  v10 = HIDWORD(a3);
  if (v5 >= a2)
    v5 = a2;
  v11 = a2 - (unint64_t)WORD2(a1);
  if (v5)
  {
    v12 = 4294836225;
    if (WORD1(a3))
      v12 = (uint64_t)(v6 * v5) / WORD1(a3);
  }
  else
  {
    v12 = 0;
  }
  v13 = a2 - HIWORD(a1);
  v14 = HIWORD(a3);
  if (v11 >= a2)
    v15 = a2;
  else
    v15 = v11;
  if (v15)
  {
    v16 = 4294836225;
    if (WORD2(a3))
      v16 = (uint64_t)(v6 * v15) / WORD2(a3);
  }
  else
  {
    v16 = 0;
  }
  v17 = a4 - (unsigned __int16)a3;
  v18 = a4 - (unsigned __int16)v9;
  if (v13 >= a2)
    v19 = a2;
  else
    v19 = v13;
  v20 = a4 - (unsigned __int16)v10;
  if (v19)
  {
    if (v14)
      v4 = (uint64_t)(v6 * v19) / v14;
  }
  else
  {
    v4 = 0;
  }
  if (a4 != 0xFFFF)
  {
    v8 += (a4 ^ 0xFFFFLL) * v7;
    v12 += (a4 ^ 0xFFFFLL) * v5;
    v16 += (a4 ^ 0xFFFFLL) * v15;
    v4 += (a4 ^ 0xFFFFLL) * v19;
  }
  if (a2 == 0xFFFF)
  {
    v21 = v16;
  }
  else
  {
    v4 += (int)(a4 - v14) * (uint64_t)(int)(a2 ^ 0xFFFF);
    v21 = v16 + (int)v20 * (uint64_t)(int)(a2 ^ 0xFFFF);
  }
  if (a2 != 0xFFFF)
  {
    v12 += (int)v18 * (uint64_t)(int)(a2 ^ 0xFFFF);
    v8 += (int)v17 * (uint64_t)(int)(a2 ^ 0xFFFF);
  }
  v22 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v8 >= v22)
    v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v12 >= v22)
    v23 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  else
    v23 = v12;
  if (v21 >= v22)
    v24 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  else
    v24 = v21;
  if (v4 >= v22)
    v4 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v24 <= 4294868992)
    v25 = v24 + 0x8000;
  else
    v25 = 4294868992;
  v26 = (v25 >> 16) + v25;
  if (v23 <= 4294868992)
    v27 = v23 + 0x8000;
  else
    v27 = 4294868992;
  v28 = (v27 >> 16) + v27;
  if (v8 <= 4294868992)
    v29 = v8 + 0x8000;
  else
    v29 = 4294868992;
  v30 = (v29 >> 16) + v29;
  if (v4 <= 4294868992)
    v31 = v4 + 0x8000;
  else
    v31 = 4294868992;
  v32 = (v31 >> 16) + v31;
  if (v22 <= 4294868992)
    v33 = v22 + 0x8000;
  else
    v33 = 4294868992;
  return ((unint64_t)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v32)) << 48) | ((unint64_t)(unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v26)) << 32) | ((((v33 + (v33 >> 16)) >> 16) - HIWORD(v28)) << 16) | (unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v30));
}

unint64_t PDAcolorburnPDA_10652(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  unint64_t v9;
  int64_t v10;
  unint64_t v11;
  unint64_t v12;
  int64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  int64x2_t v31;
  int v32;
  int64x2_t v33;
  int8x16_t v34;
  int8x16_t v35;
  unint64_t v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  uint64x2_t v40;
  int8x16_t v41;

  v4 = a2;
  v5 = a2 - HIWORD(a1);
  v6 = a4;
  v7 = a4 - (unint64_t)WORD1(a3);
  v8 = a4 - HIWORD(a3);
  v9 = a4 * (unint64_t)a2;
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v10 = a4;
  else
    v10 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v11 = a2;
  else
    v11 = a2 - (unint64_t)(unsigned __int16)a1;
  if (v7 >= a4)
    v7 = a4;
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2)
    v12 = a2;
  else
    v12 = a2 - (unint64_t)WORD1(a1);
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4)
    v13 = a4;
  else
    v13 = a4 - (unint64_t)WORD2(a3);
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2)
    v14 = a2;
  else
    v14 = a2 - (unint64_t)WORD2(a1);
  if (v8 >= a4)
    v15 = a4;
  else
    v15 = v8;
  if (v5 >= a2)
    v5 = a2;
  v20 = a4 == 0xFFFF;
  v16 = v9 + (a4 ^ 0xFFFFLL) * v12;
  v17 = v9 + (v6 ^ 0xFFFF) * v14;
  v18 = v9 + (v6 ^ 0xFFFF) * v5;
  if (v20)
  {
    v18 = v9;
    v17 = v9;
    v16 = v9;
    v19 = v9;
  }
  else
  {
    v19 = v9 + (v6 ^ 0xFFFF) * v11;
  }
  v20 = a2 == 0xFFFF;
  v21 = v19 + v10 * (a2 ^ 0xFFFFLL);
  if (v20)
    v22 = v18;
  else
    v22 = v18 + v15 * (v4 ^ 0xFFFF);
  if (v20)
    v23 = v17;
  else
    v23 = v17 + v13 * (v4 ^ 0xFFFF);
  if (v20)
    v24 = v16;
  else
    v24 = v16 + v7 * (v4 ^ 0xFFFF);
  if (v20)
    v21 = v19;
  v25 = (v21 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v11)) / v10) & ~((v21 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v11)) / v10) >> 63);
  if (!v10)
    v25 = 0;
  if ((_WORD)a1)
    v21 = v25;
  if (!WORD1(a1))
  {
LABEL_44:
    if (WORD2(a1))
      goto LABEL_45;
    goto LABEL_50;
  }
  if (v7)
  {
    v26 = (uint64_t)(v6 * (unint64_t)v6 * (v4 - v12)) / v7;
    v24 = (v24 - v26) & ~((v24 - v26) >> 63);
    goto LABEL_44;
  }
  v24 = 0;
  if (WORD2(a1))
  {
LABEL_45:
    if (v13)
    {
      v27 = v23 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v14)) / v13;
      v23 = v27 & ~(v27 >> 63);
    }
    else
    {
      v23 = 0;
    }
  }
LABEL_50:
  if (v15)
    v28 = (v22 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v5)) / v15) & ~((v22 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v5)) / v15) >> 63);
  else
    v28 = 0;
  if (!HIWORD(a1))
    v28 = v22;
  v29 = 0xFFFF * (v6 + v4) - v9;
  v30 = v21 + 0x8000;
  if (v21 > 4294868992)
    v30 = 4294868992;
  v31.i64[0] = v23;
  v31.i64[1] = v24;
  v32 = (v30 >> 16) + v30;
  v33 = vdupq_n_s64(0xFFFE8000uLL);
  v34 = (int8x16_t)vcgtq_s64(v31, v33);
  v35 = (int8x16_t)vaddq_s64(v31, vdupq_n_s64(0x8000uLL));
  if (v28 <= 4294868992)
    v36 = v28 + 0x8000;
  else
    v36 = 4294868992;
  v37 = (v36 >> 16) + v36;
  if (v29 <= 4294868992)
    v38 = v29 + 0x8000;
  else
    v38 = 4294868992;
  v39 = (v38 + (v38 >> 16)) >> 16;
  v40 = (uint64x2_t)vbslq_s8(v34, (int8x16_t)v33, v35);
  v41 = vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vsubq_s64(vdupq_n_s64(v39), (int64x2_t)vshrq_n_u64(vsraq_n_u64(v40, v40, 0x10uLL), 0x10uLL)), (uint64x2_t)xmmword_185004E00), (int8x16_t)xmmword_185004E10);
  return v41.i64[0] | ((unint64_t)(v39 - HIWORD(v37)) << 48) | (unsigned __int16)(v39 - HIWORD(v32)) | v41.i64[1];
}

unint64_t PDAhardlightPDA_10653(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  int64_t v9;
  uint64_t v10;
  int64_t v11;
  unint64_t v12;
  uint64_t v13;
  int64_t v14;
  int64_t v15;
  uint64_t v16;
  int64_t v17;
  int64_t v18;
  uint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  int64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  int64x2_t v39;
  int v40;
  int64x2_t v41;
  int8x16_t v42;
  int8x16_t v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  uint64x2_t v48;
  int8x16_t v49;

  v4 = a2;
  v5 = a2 - (unint64_t)WORD1(a1);
  v6 = a2 - (unint64_t)WORD2(a1);
  v7 = a2 - HIWORD(a1);
  v8 = a4;
  v9 = a4 - (unint64_t)WORD2(a3);
  v10 = a4 - HIWORD(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v11 = a4;
  else
    v11 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v12 = a2;
  else
    v12 = a2 - (unint64_t)(unsigned __int16)a1;
  v13 = 2 * v12 * v11;
  if ((uint64_t)(a4 - (unint64_t)WORD1(a3)) >= a4)
    v14 = a4;
  else
    v14 = a4 - (unint64_t)WORD1(a3);
  if (v5 >= a2)
    v15 = a2;
  else
    v15 = v5;
  v16 = 2 * v15 * v14;
  if (v9 >= a4)
    v17 = a4;
  else
    v17 = v9;
  if (v6 >= a2)
    v18 = a2;
  else
    v18 = v6;
  v19 = 2 * v18 * v17;
  if (v10 >= a4)
    v20 = a4;
  else
    v20 = v10;
  if (v7 >= a2)
    v21 = a2;
  else
    v21 = v7;
  v22 = 2 * v21 * v20;
  v23 = a4 * (unint64_t)a2;
  v24 = ((unint64_t)a4 + 1) >> 1;
  if (v11 <= v24)
    v25 = (a4 ^ 0xFFFFLL) * v12 + v11 * (a2 ^ 0xFFFFLL) + v13;
  else
    v25 = v11 * (a2 + 0xFFFFLL) + (a4 + 0xFFFFLL) * v12 - (v23 + v13);
  v26 = a4 ^ 0xFFFFLL;
  v27 = v4 ^ 0xFFFF;
  v28 = (v8 ^ 0xFFFF) * v15 + v14 * (v4 ^ 0xFFFF) + v16;
  v29 = v14 * (v4 + 0xFFFF) + (v8 + 0xFFFF) * v15 - (v23 + v16);
  if (v14 > v24)
    v30 = v29;
  else
    v30 = v28;
  v31 = v26 * v18 + v17 * v27 + v19;
  v32 = v17 * (v4 + 0xFFFF) + (v8 + 0xFFFF) * v18 - (v23 + v19);
  if (v17 > v24)
    v33 = v32;
  else
    v33 = v31;
  v34 = v26 * v21 + v20 * v27 + v22;
  v35 = v20 * (v4 + 0xFFFF) + (v8 + 0xFFFF) * v21 - (v23 + v22);
  if (v20 > v24)
    v36 = v35;
  else
    v36 = v34;
  v37 = 0xFFFF * (v8 + v4) - v23;
  v38 = v25 + 0x8000;
  if (v25 > 4294868992)
    v38 = 4294868992;
  v39.i64[0] = v33;
  v39.i64[1] = v30;
  v40 = (v38 >> 16) + v38;
  v41 = vdupq_n_s64(0xFFFE8000uLL);
  v42 = (int8x16_t)vcgtq_s64(v39, v41);
  v43 = (int8x16_t)vaddq_s64(v39, vdupq_n_s64(0x8000uLL));
  if (v36 <= 4294868992)
    v44 = v36 + 0x8000;
  else
    v44 = 4294868992;
  v45 = (v44 >> 16) + v44;
  if (v37 <= 4294868992)
    v46 = v37 + 0x8000;
  else
    v46 = 4294868992;
  v47 = (v46 + (v46 >> 16)) >> 16;
  v48 = (uint64x2_t)vbslq_s8(v42, (int8x16_t)v41, v43);
  v49 = vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vsubq_s64(vdupq_n_s64(v47), (int64x2_t)vshrq_n_u64(vsraq_n_u64(v48, v48, 0x10uLL), 0x10uLL)), (uint64x2_t)xmmword_185004E00), (int8x16_t)xmmword_185004E10);
  return v49.i64[0] | ((unint64_t)(v47 - HIWORD(v45)) << 48) | (unsigned __int16)(v47 - HIWORD(v40)) | v49.i64[1];
}

unint64_t PDAsoftlightPDA_10654(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4;
  int64_t v5;
  uint64_t v6;
  int64_t v7;
  int64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int64_t v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;

  v4 = a2 - (unint64_t)WORD1(a1);
  v5 = a2 - (unint64_t)WORD2(a1);
  v6 = a2 - HIWORD(a1);
  v7 = a4 - (unint64_t)WORD1(a3);
  v8 = a4 - (unint64_t)WORD2(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v9 = a4;
  else
    v9 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v10 = a2;
  else
    v10 = a2 - (unint64_t)(unsigned __int16)a1;
  v11 = a4 - HIWORD(a3);
  if (a2)
  {
    v12 = (uint64_t)(v10 * v10 * (2 * v9 - a4)) / a2;
    v13 = (2 * v10 * v9 - v12) & ~((uint64_t)(2 * v10 * v9 - v12) >> 63);
    if (v7 >= a4)
      v7 = a4;
    if (v4 >= a2)
      v14 = a2;
    else
      v14 = a2 - (unint64_t)WORD1(a1);
    v15 = (uint64_t)(v14 * v14 * (2 * v7 - a4)) / a2;
    v16 = (2 * v14 * v7 - v15) & ~((uint64_t)(2 * v14 * v7 - v15) >> 63);
    if (v8 >= a4)
      v8 = a4;
    if (v5 >= a2)
      v5 = a2;
    v17 = v5 * v5 * (2 * v8 - a4) / a2;
    v18 = (2 * v5 * v8 - v17) & ~((2 * v5 * v8 - v17) >> 63);
    if (v11 >= a4)
      v11 = a4;
    if (v6 >= a2)
      v6 = a2;
    v19 = v6 * v6 * (2 * v11 - a4) / a2;
    v20 = (2 * v6 * v11 - v19) & ~((2 * v6 * v11 - v19) >> 63);
  }
  else
  {
    v18 = 0;
    v13 = 0;
    v16 = 0;
    v20 = 0;
    if (v7 >= a4)
      v7 = a4;
    if (v4 >= 0)
      v14 = 0;
    else
      v14 = -(uint64_t)WORD1(a1);
    if (v8 >= a4)
      v8 = a4;
    if (v5 >= 0)
      v5 = 0;
    if (v11 >= a4)
      v11 = a4;
    if (v6 >= 0)
      v6 = 0;
  }
  if (a4 != 0xFFFF)
  {
    v13 += (a4 ^ 0xFFFFLL) * v10;
    v16 += v14 * (a4 ^ 0xFFFFLL);
    v18 += v5 * (a4 ^ 0xFFFFLL);
    v20 += v6 * (a4 ^ 0xFFFFLL);
  }
  if (a2 != 0xFFFF)
  {
    v13 += v9 * (a2 ^ 0xFFFFLL);
    v16 += v7 * (a2 ^ 0xFFFFLL);
    v18 += v8 * (a2 ^ 0xFFFFLL);
    v20 += v11 * (a2 ^ 0xFFFFLL);
  }
  v21 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  v22 = v13 + 0x8000;
  if (v13 > 4294868992)
    v22 = 4294868992;
  v23 = (v22 >> 16) + v22;
  v24 = v16 + 0x8000;
  if (v16 > 4294868992)
    v24 = 4294868992;
  v25 = (v24 >> 16) + v24;
  v26 = v18 + 0x8000;
  if (v18 > 4294868992)
    v26 = 4294868992;
  v27 = (v26 >> 16) + v26;
  v28 = v20 + 0x8000;
  if (v20 > 4294868992)
    v28 = 4294868992;
  v29 = (v28 >> 16) + v28;
  if (v21 <= 4294868992)
    v30 = v21 + 0x8000;
  else
    v30 = 4294868992;
  return ((unint64_t)(((v30 + (v30 >> 16)) >> 16) - HIWORD(v29)) << 48) | ((unint64_t)(unsigned __int16)(((v30 + (v30 >> 16)) >> 16) - HIWORD(v27)) << 32) | ((((v30 + (v30 >> 16)) >> 16) - HIWORD(v25)) << 16) | (unsigned __int16)(((v30 + (v30 >> 16)) >> 16) - HIWORD(v23));
}

unint64_t PDAdifferencePDA_10655(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v7;
  int64_t v8;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  int64_t v12;
  int64_t v13;
  int64_t v14;
  BOOL v15;
  int64_t v16;
  int64_t v17;
  int64_t v18;
  uint64_t v19;
  int64_t v20;
  int64_t v21;
  int64_t v22;
  int64_t v23;
  int64_t v24;
  int64_t v25;
  uint64_t v26;
  int64_t v27;
  int64_t v28;
  int64_t v29;
  int64_t v30;
  int64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int64_t v43;
  unint64_t v44;
  int v45;
  unint64_t v46;
  unsigned int v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  unsigned int v51;
  uint64_t v52;

  v4 = a2 - (unint64_t)(unsigned __int16)a1;
  v5 = a2 - (unint64_t)WORD1(a1);
  v6 = a2 - (unint64_t)WORD2(a1);
  v7 = a2 - HIWORD(a1);
  v8 = a4 - (unint64_t)(unsigned __int16)a3;
  v9 = a4 - (unint64_t)WORD1(a3);
  v10 = a4 - (unint64_t)WORD2(a3);
  v11 = a4 - HIWORD(a3);
  if (v8 >= a4)
    v8 = a4;
  if (v4 >= a2)
    v4 = a2;
  v12 = v8 + v4;
  v13 = v4 * a4;
  v14 = v8 * a2;
  v16 = v13 - v14;
  v15 = v13 - v14 < 0;
  v17 = 0xFFFF * v12 - v14 - v13;
  if (v15)
    v18 = -v16;
  else
    v18 = v16;
  v19 = v17 + v18;
  if (v9 >= a4)
    v9 = a4;
  if (v5 >= a2)
    v5 = a2;
  v20 = v9 + v5;
  v21 = v5 * a4;
  v22 = v9 * a2;
  v23 = v21 - v22;
  v15 = v21 - v22 < 0;
  v24 = 0xFFFF * v20 - v22 - v21;
  if (v15)
    v25 = -v23;
  else
    v25 = v23;
  v26 = v24 + v25;
  if (v10 >= a4)
    v27 = a4;
  else
    v27 = v10;
  if (v6 >= a2)
    v6 = a2;
  v28 = v27 + v6;
  v29 = v6 * a4;
  v30 = v27 * a2;
  v31 = v29 - v30;
  v15 = v29 - v30 < 0;
  v32 = 0xFFFF * v28 - v30 - v29;
  if (v15)
    v33 = -v31;
  else
    v33 = v31;
  v34 = v32 + v33;
  if (v11 >= a4)
    v35 = a4;
  else
    v35 = v11;
  if (v7 >= a2)
    v7 = a2;
  v36 = v35 + v7;
  v37 = v7 * a4;
  v38 = v35 * a2;
  v39 = v37 - v38;
  v15 = v37 - v38 < 0;
  v40 = 0xFFFF * v36 - v38 - v37;
  if (v15)
    v41 = -v39;
  else
    v41 = v39;
  v42 = v40 + v41;
  v43 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v19 <= 4294868992)
    v44 = v19 + 0x8000;
  else
    v44 = 4294868992;
  v45 = (v44 >> 16) + v44;
  if (v26 <= 4294868992)
    v46 = v26 + 0x8000;
  else
    v46 = 4294868992;
  v47 = (v46 >> 16) + v46;
  if (v34 <= 4294868992)
    v48 = v34 + 0x8000;
  else
    v48 = 4294868992;
  v49 = (v48 >> 16) + v48;
  if (v42 <= 4294868992)
    v50 = v42 + 0x8000;
  else
    v50 = 4294868992;
  v51 = (v50 >> 16) + v50;
  if (v43 <= 4294868992)
    v52 = v43 + 0x8000;
  else
    v52 = 4294868992;
  return ((unint64_t)(((v52 + (v52 >> 16)) >> 16) - HIWORD(v51)) << 48) | ((unint64_t)(unsigned __int16)(((v52 + (v52 >> 16)) >> 16) - HIWORD(v49)) << 32) | ((((v52 + (v52 >> 16)) >> 16) - HIWORD(v47)) << 16) | (unsigned __int16)(((v52 + (v52 >> 16)) >> 16) - HIWORD(v45));
}

unint64_t PDAexclusionPDA_10656(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  unint64_t v4;
  int64_t v5;
  int64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;

  v4 = a2;
  v5 = a2 - (unint64_t)(unsigned __int16)a1;
  v6 = a2 - (unint64_t)WORD1(a1);
  v7 = a2 - (unint64_t)WORD2(a1);
  v8 = a4 - (unint64_t)(unsigned __int16)a3;
  v9 = a4 - (unint64_t)WORD1(a3);
  if (v8 >= a4)
    v8 = a4;
  if (v5 >= a2)
    v5 = a2;
  v10 = 0xFFFF * (v8 + v5) - 2 * v5 * v8;
  if (v9 >= a4)
    v9 = a4;
  if (v6 >= a2)
    v6 = a2;
  v11 = 0xFFFF * (v9 + v6) - 2 * v6 * v9;
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4)
    v12 = a4;
  else
    v12 = a4 - (unint64_t)WORD2(a3);
  if (v7 >= a2)
    v7 = a2;
  v13 = 0xFFFF * (v12 + v7) - 2 * v7 * v12;
  if ((uint64_t)(a4 - HIWORD(a3)) >= a4)
    v14 = a4;
  else
    v14 = a4 - HIWORD(a3);
  if ((uint64_t)(a2 - HIWORD(a1)) < a2)
    v4 = a2 - HIWORD(a1);
  v15 = 0xFFFF * (v14 + v4) - 2 * v4 * v14;
  v16 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v10 <= 4294868992)
    v17 = v10 + 0x8000;
  else
    v17 = 4294868992;
  v18 = (v17 >> 16) + v17;
  if (v11 <= 4294868992)
    v19 = v11 + 0x8000;
  else
    v19 = 4294868992;
  v20 = (v19 >> 16) + v19;
  if (v13 <= 4294868992)
    v21 = v13 + 0x8000;
  else
    v21 = 4294868992;
  v22 = (v21 >> 16) + v21;
  if (v15 <= 4294868992)
    v23 = v15 + 0x8000;
  else
    v23 = 4294868992;
  v24 = (v23 >> 16) + v23;
  if (v16 <= 4294868992)
    v25 = v16 + 0x8000;
  else
    v25 = 4294868992;
  return ((unint64_t)(((v25 + (v25 >> 16)) >> 16) - HIWORD(v24)) << 48) | ((unint64_t)(unsigned __int16)(((v25 + (v25 >> 16)) >> 16) - HIWORD(v22)) << 32) | ((((v25 + (v25 >> 16)) >> 16) - HIWORD(v20)) << 16) | (unsigned __int16)(((v25 + (v25 >> 16)) >> 16) - HIWORD(v18));
}

unint64_t PDAhuePDA_10657(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int64_t v35;
  uint64_t v36;
  uint64_t v37;
  int64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v6 = a4 - (unint64_t)WORD1(a3);
  v7 = a4 - (unint64_t)WORD2(a3);
  v8 = a4 - HIWORD(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v9 = a4;
  else
    v9 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v10 = a2;
  else
    v10 = a2 - (unint64_t)(unsigned __int16)a1;
  if (v6 >= a4)
    v11 = a4;
  else
    v11 = v6;
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2)
    v12 = a2;
  else
    v12 = a2 - (unint64_t)WORD1(a1);
  if (v7 >= a4)
    v13 = a4;
  else
    v13 = v7;
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2)
    v14 = a2;
  else
    v14 = a2 - (unint64_t)WORD2(a1);
  if (v8 >= a4)
    v8 = a4;
  v15 = a2 - HIWORD(a1);
  if (v15 >= a2)
    v15 = a2;
  if (a4 == 0xFFFF)
  {
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
  }
  else
  {
    v16 = (a4 ^ 0xFFFFLL) * v10;
    v10 = (v10 * a4 + 0x8000 + ((v10 * a4 + 0x8000) >> 16)) >> 16;
    v17 = (a4 ^ 0xFFFFLL) * v12;
    v12 = (v12 * a4 + 0x8000 + ((v12 * a4 + 0x8000) >> 16)) >> 16;
    v18 = (a4 ^ 0xFFFFLL) * v14;
    v14 = (v14 * a4 + 0x8000 + ((v14 * a4 + 0x8000) >> 16)) >> 16;
    v19 = (a4 ^ 0xFFFFLL) * v15;
    v15 = (v15 * a4 + 0x8000 + ((v15 * a4 + 0x8000) >> 16)) >> 16;
  }
  if (a2 != 0xFFFF)
  {
    v16 += v9 * (a2 ^ 0xFFFFLL);
    v9 = (v9 * a2 + 0x8000 + ((v9 * a2 + 0x8000) >> 16)) >> 16;
    v17 += v11 * (a2 ^ 0xFFFFLL);
    v11 = (v11 * a2 + 0x8000 + ((v11 * a2 + 0x8000) >> 16)) >> 16;
    v18 += v13 * (a2 ^ 0xFFFFLL);
    v13 = (v13 * a2 + 0x8000 + ((v13 * a2 + 0x8000) >> 16)) >> 16;
    v19 += (a2 ^ 0xFFFFLL) * v8;
  }
  v51 = v9;
  v52 = v11;
  v53 = v13;
  v20 = v9 < v11;
  v21 = v9 >= v11;
  if (v13 >= *(&v51 + v21))
  {
    v23 = v13 <= *(&v51 + v20);
    v22 = v9 >= v11;
    if (v23)
      v21 = 2;
    else
      v21 = v9 < v11;
    if (!v23)
      v20 = 2;
  }
  else
  {
    v22 = 2;
  }
  v24 = *(&v51 + v20);
  v25 = *(&v51 + v22);
  v26 = __OFSUB__(v24, v25);
  v27 = v24 - v25;
  if ((v27 < 0) ^ v26 | (v27 == 0))
  {
    *(&v51 + v20) = 0;
    *(&v51 + v21) = 0;
  }
  else
  {
    if (v10 >= v12)
      v28 = v12;
    else
      v28 = v10;
    if (v10 <= v12)
      v29 = v12;
    else
      v29 = v10;
    if (v14 <= v29)
      v30 = v29;
    else
      v30 = v14;
    if (v14 >= v28)
      v29 = v30;
    else
      v28 = v14;
    v31 = v29 - v28;
    *(&v51 + v20) = v31;
    *(&v51 + v21) = ((*(&v51 + v21) - *(&v51 + v22)) * ((v31 << 16) / v27) + 0x8000) >> 16;
  }
  *(&v51 + v22) = 0;
  v32 = 77 * (v10 - v51) + 151 * (v12 - v52) + 28 * (v14 - v53);
  v33 = v51 + ((v32 + 128) >> 8);
  v34 = v52 + ((v32 + 128) >> 8);
  v35 = (a4 * (unint64_t)a2 + 0x8000 + ((a4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  v36 = v53 + ((v32 + 128) >> 8);
  if (v32 != (char)v32)
  {
    if (v51 >= v52)
      v37 = v52 + ((v32 + 128) >> 8);
    else
      v37 = v51 + ((v32 + 128) >> 8);
    if (v51 >= v52)
      v38 = v51 + ((v32 + 128) >> 8);
    else
      v38 = v52 + ((v32 + 128) >> 8);
    if (v36 <= v38)
      v39 = v38;
    else
      v39 = v53 + ((v32 + 128) >> 8);
    if (v36 >= v37)
      v40 = v37;
    else
      v40 = v53 + ((v32 + 128) >> 8);
    if (v36 >= v37)
      v38 = v39;
    if (v38 > v35 || v40 < 0)
    {
      v41 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      if (v32 > -129)
      {
        v42 = v38 - v41;
        if (v38 == v41)
          goto LABEL_73;
        v43 = v35 - v41;
      }
      else
      {
        v42 = v41 - v40;
        if (v41 == v40)
          goto LABEL_73;
        v43 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      }
      v44 = (v43 << 16) / v42;
      v33 = v41 + ((v44 * (v33 - v41) + 0x8000) >> 16);
      v34 = v41 + ((v44 * (v34 - v41) + 0x8000) >> 16);
      v36 = v41 + ((v44 * (v36 - v41) + 0x8000) >> 16);
    }
  }
LABEL_73:
  v45 = v19 + 0x8000;
  if (v19 > 4294868992)
    v45 = 4294868992;
  if (v18 <= 4294868992)
    v46 = v18 + 0x8000;
  else
    v46 = 4294868992;
  if (v17 <= 4294868992)
    v47 = v17 + 0x8000;
  else
    v47 = 4294868992;
  if (v16 <= 4294868992)
    v48 = v16 + 0x8000;
  else
    v48 = 4294868992;
  v49 = a4 + a2 - v35;
  return ((unint64_t)(v49 - (v15 + (((v45 >> 16) + v45) >> 16))) << 48) | ((unint64_t)(unsigned __int16)(v49 - (v36 + (((v46 >> 16) + v46) >> 16))) << 32) | ((v49 - (v34 + (((v47 >> 16) + v47) >> 16))) << 16) | (unsigned __int16)(v49 - (v33 + (((v48 >> 16) + v48) >> 16)));
}

unint64_t PDAsaturationPDA_10658(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int64_t v33;
  uint64_t v34;
  uint64_t v35;
  int64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v6 = a4 - (unint64_t)WORD1(a3);
  v7 = a4 - (unint64_t)WORD2(a3);
  v8 = a4 - HIWORD(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v9 = a4;
  else
    v9 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v10 = a2;
  else
    v10 = a2 - (unint64_t)(unsigned __int16)a1;
  if (v6 >= a4)
    v11 = a4;
  else
    v11 = v6;
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2)
    v12 = a2;
  else
    v12 = a2 - (unint64_t)WORD1(a1);
  if (v7 >= a4)
    v13 = a4;
  else
    v13 = v7;
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2)
    v14 = a2;
  else
    v14 = a2 - (unint64_t)WORD2(a1);
  if (v8 >= a4)
    v8 = a4;
  v15 = a2 - HIWORD(a1);
  if (v15 >= a2)
    v15 = a2;
  if (a4 == 0xFFFF)
  {
    v19 = 0;
    v18 = 0;
    v17 = 0;
    v16 = 0;
  }
  else
  {
    v16 = (a4 ^ 0xFFFFLL) * v10;
    v10 = (v10 * a4 + 0x8000 + ((v10 * a4 + 0x8000) >> 16)) >> 16;
    v17 = (a4 ^ 0xFFFFLL) * v12;
    v12 = (v12 * a4 + 0x8000 + ((v12 * a4 + 0x8000) >> 16)) >> 16;
    v18 = (a4 ^ 0xFFFFLL) * v14;
    v14 = (v14 * a4 + 0x8000 + ((v14 * a4 + 0x8000) >> 16)) >> 16;
    v19 = (a4 ^ 0xFFFFLL) * v15;
    v15 = (v15 * a4 + 0x8000 + ((v15 * a4 + 0x8000) >> 16)) >> 16;
  }
  if (a2 != 0xFFFF)
  {
    v16 += v9 * (a2 ^ 0xFFFFLL);
    v9 = (v9 * a2 + 0x8000 + ((v9 * a2 + 0x8000) >> 16)) >> 16;
    v17 += v11 * (a2 ^ 0xFFFFLL);
    v11 = (v11 * a2 + 0x8000 + ((v11 * a2 + 0x8000) >> 16)) >> 16;
    v18 += v13 * (a2 ^ 0xFFFFLL);
    v13 = (v13 * a2 + 0x8000 + ((v13 * a2 + 0x8000) >> 16)) >> 16;
    v19 += (a2 ^ 0xFFFFLL) * v8;
  }
  v49 = v10;
  v50 = v12;
  v51 = v14;
  v20 = v10 < v12;
  v21 = v10 >= v12;
  if (v14 >= *(&v49 + v21))
  {
    v22 = v10 >= v12;
    if (v14 <= *(&v49 + v20))
      v21 = 2;
    else
      v21 = v10 < v12;
    if (v14 > *(&v49 + v20))
      v20 = 2;
  }
  else
  {
    v22 = 2;
  }
  v23 = *(&v49 + v20);
  v24 = *(&v49 + v22);
  v25 = __OFSUB__(v23, v24);
  v26 = v23 - v24;
  if ((v26 < 0) ^ v25 | (v26 == 0))
  {
    *(&v49 + v20) = 0;
    *(&v49 + v21) = 0;
  }
  else
  {
    if (v9 >= v11)
      v27 = v11;
    else
      v27 = v9;
    if (v9 <= v11)
      v9 = v11;
    if (v13 <= v9)
      v28 = v9;
    else
      v28 = v13;
    if (v13 >= v27)
    {
      v13 = v27;
      v9 = v28;
    }
    v29 = v9 - v13;
    *(&v49 + v20) = v29;
    *(&v49 + v21) = ((*(&v49 + v21) - *(&v49 + v22)) * ((v29 << 16) / v26) + 0x8000) >> 16;
  }
  *(&v49 + v22) = 0;
  v30 = 77 * (v10 - v49) + 151 * (v12 - v50) + 28 * (v14 - v51);
  v31 = v49 + ((v30 + 128) >> 8);
  v32 = v50 + ((v30 + 128) >> 8);
  v33 = (a4 * (unint64_t)a2 + 0x8000 + ((a4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  v34 = v51 + ((v30 + 128) >> 8);
  if (v30 != (char)v30)
  {
    if (v49 >= v50)
      v35 = v50 + ((v30 + 128) >> 8);
    else
      v35 = v49 + ((v30 + 128) >> 8);
    if (v49 >= v50)
      v36 = v49 + ((v30 + 128) >> 8);
    else
      v36 = v50 + ((v30 + 128) >> 8);
    if (v34 <= v36)
      v37 = v36;
    else
      v37 = v51 + ((v30 + 128) >> 8);
    if (v34 >= v35)
      v38 = v35;
    else
      v38 = v51 + ((v30 + 128) >> 8);
    if (v34 >= v35)
      v36 = v37;
    if (v36 > v33 || v38 < 0)
    {
      v39 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      if (v30 > -129)
      {
        v40 = v36 - v39;
        if (v36 == v39)
          goto LABEL_71;
        v41 = v33 - v39;
      }
      else
      {
        v40 = v39 - v38;
        if (v39 == v38)
          goto LABEL_71;
        v41 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      }
      v42 = (v41 << 16) / v40;
      v31 = v39 + ((v42 * (v31 - v39) + 0x8000) >> 16);
      v32 = v39 + ((v42 * (v32 - v39) + 0x8000) >> 16);
      v34 = v39 + ((v42 * (v34 - v39) + 0x8000) >> 16);
    }
  }
LABEL_71:
  v43 = v19 + 0x8000;
  if (v19 > 4294868992)
    v43 = 4294868992;
  if (v18 <= 4294868992)
    v44 = v18 + 0x8000;
  else
    v44 = 4294868992;
  if (v17 <= 4294868992)
    v45 = v17 + 0x8000;
  else
    v45 = 4294868992;
  if (v16 <= 4294868992)
    v46 = v16 + 0x8000;
  else
    v46 = 4294868992;
  v47 = a4 + a2 - v33;
  return ((unint64_t)(v47 - (v15 + (((v43 >> 16) + v43) >> 16))) << 48) | ((unint64_t)(unsigned __int16)(v47 - (v34 + (((v44 >> 16) + v44) >> 16))) << 32) | ((v47 - (v32 + (((v45 >> 16) + v45) >> 16))) << 16) | (unsigned __int16)(v47 - (v31 + (((v46 >> 16) + v46) >> 16)));
}

unint64_t PDAluminosityPDA_10659(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  int64_t v25;
  int64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unint64_t v33;
  unsigned int v34;
  unint64_t v35;
  int v36;
  unint64_t v37;
  unsigned int v38;
  unint64_t v39;

  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4)
    v6 = a4;
  else
    v6 = a4 - (unint64_t)(unsigned __int16)a3;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2)
    v7 = a2;
  else
    v7 = a2 - (unint64_t)(unsigned __int16)a1;
  if ((uint64_t)(a4 - (unint64_t)WORD1(a3)) >= a4)
    v8 = a4;
  else
    v8 = a4 - (unint64_t)WORD1(a3);
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2)
    v9 = a2;
  else
    v9 = a2 - (unint64_t)WORD1(a1);
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4)
    v10 = a4;
  else
    v10 = a4 - (unint64_t)WORD2(a3);
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2)
    v11 = a2;
  else
    v11 = a2 - (unint64_t)WORD2(a1);
  v12 = a4 - HIWORD(a3);
  if (v12 >= a4)
    v12 = a4;
  if (a4 == 0xFFFF)
  {
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
  }
  else
  {
    if ((uint64_t)(a2 - HIWORD(a1)) >= a2)
      v13 = a2;
    else
      v13 = a2 - HIWORD(a1);
    v14 = (a4 ^ 0xFFFFLL) * v7;
    v7 = (v7 * a4 + 0x8000 + ((v7 * a4 + 0x8000) >> 16)) >> 16;
    v15 = (a4 ^ 0xFFFFLL) * v9;
    v9 = (v9 * a4 + 0x8000 + ((v9 * a4 + 0x8000) >> 16)) >> 16;
    v16 = (a4 ^ 0xFFFFLL) * v11;
    v11 = (v11 * a4 + 0x8000 + ((v11 * a4 + 0x8000) >> 16)) >> 16;
    v17 = (a4 ^ 0xFFFFLL) * v13;
  }
  if (a2 != 0xFFFF)
  {
    v14 += v6 * (a2 ^ 0xFFFFLL);
    v6 = (v6 * a2 + 0x8000 + ((v6 * a2 + 0x8000) >> 16)) >> 16;
    v15 += v8 * (a2 ^ 0xFFFFLL);
    v8 = (v8 * a2 + 0x8000 + ((v8 * a2 + 0x8000) >> 16)) >> 16;
    v16 += v10 * (a2 ^ 0xFFFFLL);
    v10 = (v10 * a2 + 0x8000 + ((v10 * a2 + 0x8000) >> 16)) >> 16;
    v17 += v12 * (a2 ^ 0xFFFFLL);
    v12 = (v12 * a2 + 0x8000 + ((v12 * a2 + 0x8000) >> 16)) >> 16;
  }
  v18 = 28 * (v10 - v11) + 151 * (v8 - v9) + 77 * (v6 - v7);
  v19 = v7 + ((v18 + 128) >> 8);
  v20 = v9 + ((v18 + 128) >> 8);
  v21 = (a4 * (unint64_t)a2 + 0x8000 + ((a4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  v22 = v11 + ((v18 + 128) >> 8);
  if (v18 != (char)v18)
  {
    v23 = v7 < v9;
    if (v7 >= v9)
      v24 = v9 + ((v18 + 128) >> 8);
    else
      v24 = v7 + ((v18 + 128) >> 8);
    if (v23)
      v25 = v9 + ((v18 + 128) >> 8);
    else
      v25 = v19;
    if (v22 <= v25)
      v26 = v25;
    else
      v26 = v22;
    if (v22 >= v24)
      v27 = v24;
    else
      v27 = v22;
    if (v22 >= v24)
      v25 = v26;
    if (v25 > v21 || v27 < 0)
    {
      v28 = (77 * v19 + 151 * v20 + 28 * v22 + 128) >> 8;
      if (v18 > -129)
      {
        v29 = v25 - v28;
        if (v25 == v28)
          goto LABEL_52;
        v30 = v21 - v28;
      }
      else
      {
        v29 = v28 - v27;
        if (!v29)
          goto LABEL_52;
        v30 = (77 * v19 + 151 * v20 + 28 * v22 + 128) >> 8;
      }
      v31 = (v30 << 16) / v29;
      v19 = v28 + ((v31 * (v19 - v28) + 0x8000) >> 16);
      v20 = v28 + ((v31 * (v20 - v28) + 0x8000) >> 16);
      v22 = v28 + ((v31 * (v22 - v28) + 0x8000) >> 16);
    }
  }
LABEL_52:
  v32 = a4 + a2 - v21;
  v33 = v17 + 0x8000;
  if (v17 > 4294868992)
    v33 = 4294868992;
  v34 = (v33 >> 16) + v33;
  if (v16 <= 4294868992)
    v35 = v16 + 0x8000;
  else
    v35 = 4294868992;
  v36 = (v35 >> 16) + v35;
  if (v15 <= 4294868992)
    v37 = v15 + 0x8000;
  else
    v37 = 4294868992;
  v38 = (v37 >> 16) + v37;
  if (v14 <= 4294868992)
    v39 = v14 + 0x8000;
  else
    v39 = 4294868992;
  return ((unint64_t)(v32 - (v12 + HIWORD(v34))) << 48) | ((unint64_t)(unsigned __int16)(v32 - (v22 + HIWORD(v36))) << 32) | ((v32 - (v20 + HIWORD(v38))) << 16) | (unsigned __int16)(v32 - (v19 + (((v39 >> 16) + v39) >> 16)));
}

_QWORD *cmyk64_image_mark_W8(_QWORD *result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v8;
  uint64_t *v9;
  unsigned __int16 *v10;
  uint64_t v11;
  unsigned __int16 v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;

  v8 = *((unsigned __int16 *)a2 + 4);
  v9 = (uint64_t *)*((_QWORD *)a2 + 2);
  v10 = (unsigned __int16 *)*((_QWORD *)a2 + 4);
  if (v10)
    v20 = *((_QWORD *)a2 + 5) - a5;
  else
    v20 = 0;
  v19 = *a2;
  v18 = *((_QWORD *)a2 + 3) - a5;
  if (v8 == 0xFFFF)
    v11 = 0xFEFE000000000000;
  else
    v11 = (unint64_t)(65278 - ((65278 * (v8 ^ 0xFFFF) + ((65278 * (v8 ^ 0xFFFFu)) >> 16) + 1) >> 16)) << 48;
  if (v8 == 0xFFFF)
    v12 = -1;
  else
    v12 = ~(0xFFFF * (v8 ^ 0xFFFF) + ((0xFFFF * (v8 ^ 0xFFFFu)) >> 16) + 1) >> 16;
  v13 = 2 * (v10 != 0);
  if (result[22])
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          v14 = a5;
          do
          {
            if (v10)
              *v10 = v12;
            *v9++ = v11;
            v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v14;
          }
          while (v14);
        }
      }
      else
      {
        v15 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (v12)
              {
                if (v12 == 0xFFFF)
                {
                  *v9 = v11;
                  *v10 = -1;
                }
                else
                {
                  result = cmyk64_DAplusDAM(v9, v10, v11, v12, *v9, *v10, (unsigned __int16)~v12);
                }
              }
            }
            else if (v12)
            {
              if (v12 == 0xFFFF)
                *v9 = v11;
              else
                result = cmyk64_DplusDM(v9, v11, *v9, (unsigned __int16)~v12);
            }
            ++v9;
            v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v15;
          }
          while (v15);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  else
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          v16 = a5;
          do
          {
            if (v10)
              *v10 = v12;
            *v9++ = v11;
            v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        v17 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (v12)
              {
                if (v12 == 0xFFFF)
                {
                  *v9 = v11;
                  *v10 = -1;
                }
                else
                {
                  result = cmyk64_DAplusDAM(v9, v10, v11, v12, *v9, *v10, (unsigned __int16)~v12);
                }
              }
            }
            else if (v12)
            {
              if (v12 == 0xFFFF)
                *v9 = v11;
              else
                result = cmyk64_DplusDM(v9, v11, *v9, (unsigned __int16)~v12);
            }
            ++v9;
            v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v17;
          }
          while (v17);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  return result;
}

void cmyk64_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(_QWORD, _QWORD))
{
  __n128 v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  unint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  int v49;
  int v50;
  int *v51;
  int v52;
  void *v53;
  void *v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(_QWORD, _QWORD);
  char *v65;
  uint64_t *v66;
  _DWORD v67[2];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  int v77;
  int v78;
  _QWORD v79[3];

  v79[1] = *MEMORY[0x1E0C80C00];
  v8.n128_u32[1] = 0;
  v8.n128_u64[1] = 0;
  v68 = 0u;
  v69 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v70 = 0u;
  v8.n128_f32[0] = (float)(*(float *)(a2 + 184) * 65535.0) + 0.5;
  v67[0] = a3;
  v67[1] = a4;
  LOWORD(v68) = (int)v8.n128_f32[0];
  v9 = (unint64_t)*(int *)(a1 + 28) >> 3;
  *(_QWORD *)&v69 = v9;
  if (*(_QWORD *)(a1 + 48))
    v10 = (unint64_t)*(int *)(a1 + 32) >> 1;
  else
    v10 = 0;
  *(_QWORD *)&v70 = v10;
  v11 = *(_QWORD *)(a2 + 120);
  v12 = *(_DWORD *)(a2 + 20);
  v13 = HIBYTE(v12);
  v14 = BYTE2(v12);
  if (v11)
  {
    v15 = *(int *)(a2 + 24);
    v16 = (uint64_t *)(a2 + 104);
    v17 = (uint64_t *)(a2 + 72);
    v18 = (uint64_t *)(a2 + 88);
    v19 = v13;
  }
  else
  {
    v15 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v16 = (uint64_t *)(a2 + 96);
    v17 = (uint64_t *)(a2 + 64);
    v18 = (uint64_t *)(a2 + 80);
    v11 = *(_QWORD *)(a2 + 112);
    v19 = v14;
  }
  v20 = *v18;
  v21 = *v17;
  v22 = *v16;
  v23 = v19;
  *((_QWORD *)&v71 + 1) = v19;
  *((_QWORD *)&v70 + 1) = v22;
  *((_QWORD *)&v75 + 1) = v15;
  *((_QWORD *)&v74 + 1) = v20;
  *((_QWORD *)&v73 + 1) = v21;
  *((_QWORD *)&v72 + 1) = v11;
  v24 = *(_QWORD *)(a2 + 128);
  if (v24)
  {
    v25 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v26 = (uint64_t *)(a2 + 96);
    v27 = (uint64_t *)(a2 + 64);
    v28 = (uint64_t *)(a2 + 80);
    v13 = v14;
  }
  else
  {
    v25 = *(int *)(a2 + 24);
    v26 = (uint64_t *)(a2 + 104);
    v27 = (uint64_t *)(a2 + 72);
    v28 = (uint64_t *)(a2 + 88);
    v24 = *(_QWORD *)(a2 + 136);
  }
  v66 = &v62;
  v29 = *v28;
  v30 = *v27;
  v31 = *v26;
  *(_QWORD *)&v72 = v13;
  *(_QWORD *)&v71 = v31;
  *(_QWORD *)&v76 = v25;
  *(_QWORD *)&v75 = v29;
  *(_QWORD *)&v74 = v30;
  *(_QWORD *)&v73 = v24;
  v32 = *(int *)(a1 + 4);
  MEMORY[0x1E0C80A78](a1, v8);
  v65 = (char *)&v62 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL)
    v37 = (char *)&v62 - v34 - 15;
  else
    v37 = 0;
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    v63 = v33;
    v64 = a5;
    v38 = v36;
    v37 = (char *)malloc_type_malloc(16 * v32, 0x1B1F656EuLL);
    v33 = v63;
    v36 = v38;
    a5 = v64;
  }
  *((_QWORD *)&v76 + 1) = v37;
  if (v37)
  {
    v39 = v32;
    if (*(_QWORD *)(a2 + 176))
    {
      if ((int)v32 >= 1)
      {
        v40 = (uint64_t *)(v37 + 8);
        v41 = -v33;
        v42 = v36 - v22;
        do
        {
          if (((v41 + v22) | v42) < 0)
          {
            v45 = 0;
            v46 = 0;
          }
          else
          {
            v43 = ((v22 & (unint64_t)~(-1 << v23)) >> (v23 - 4)) & 0xF;
            v44 = weights_19497[v43];
            if (v43 - 7 >= 9)
              v45 = -(uint64_t)v15;
            else
              v45 = v15;
            v46 = v44 & 0xF;
          }
          v33 = v15 * (v22 >> v23);
          *(v40 - 1) = v33;
          *v40 = v46 | (16 * v45);
          v40 += 2;
          v22 += v11;
          v42 -= v11;
          --v39;
        }
        while (v39);
      }
    }
    else if ((int)v32 >= 1)
    {
      v47 = v37 + 8;
      do
      {
        *(v47 - 1) = v15 * (v22 >> v23);
        *v47 = 0;
        v47 += 2;
        v22 += v11;
        --v39;
      }
      while (v39);
    }
    v48 = v37;
    v49 = *(_DWORD *)(a1 + 4);
    v50 = *(_DWORD *)(a1 + 8);
    v77 = v50;
    v78 = v49;
    v51 = *(int **)(a1 + 136);
    if (v51)
    {
      v52 = *(_DWORD *)(a1 + 104);
      LODWORD(v79[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v79[0]) = v52;
      shape_enum_clip_alloc((uint64_t)v37, v33, v51, 1, 1, 1, v52, v79[0], v49, v50);
      v54 = v53;
      if (v53)
        goto LABEL_36;
    }
    v55 = 0;
    v56 = 0;
    v54 = 0;
    v79[0] = 0;
    while (1)
    {
      v57 = *(int *)(a1 + 16) + (uint64_t)v56;
      v58 = *(_QWORD *)(a1 + 48);
      v59 = v55 + *(_DWORD *)(a1 + 12);
      v60 = *(_QWORD *)(a1 + 40) + 8 * v9 * v57 + 8 * v59;
      v61 = v58 + 2 * v10 * v57 + 2 * v59;
      if (!v58)
        v61 = 0;
      *((_QWORD *)&v68 + 1) = v60;
      *((_QWORD *)&v69 + 1) = v61;
      a5(a2, v67);
      if (!v54)
        break;
LABEL_36:
      if (!shape_enum_clip_next((uint64_t)v54, (int *)v79 + 1, v79, &v78, &v77))
      {
        free(v54);
        break;
      }
      v56 = v79[0];
      v55 = HIDWORD(v79[0]);
      v9 = v69;
      v10 = v70;
    }
    if (v48 != v65)
      free(v48);
  }
}

_QWORD *cmyk64_image_mark_RGB24(_QWORD *result, int *a2, int a3, int a4, int a5, int a6)
{
  unint64_t *v6;
  __int16 *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned int v28;
  char v29;
  unsigned __int8 *v30;
  int v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 *v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned __int8 *v40;
  unsigned int v41;
  int v42;
  int v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unsigned int v57;
  __int16 v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unsigned int v65;
  char v66;
  unsigned __int8 *v67;
  int v68;
  unsigned __int8 *v69;
  unsigned __int8 *v70;
  int v71;
  unsigned __int8 *v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned __int8 *v77;
  unsigned int v78;
  int v79;
  int v80;
  unsigned int v81;
  unint64_t v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unsigned int v94;
  uint64_t v95;
  unsigned __int8 *v96;
  int v97;
  unsigned __int8 *v98;
  unsigned __int8 *v99;
  uint64_t v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  unsigned __int8 *v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unsigned int v118;
  unsigned __int16 v119;
  __int16 v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t v123;
  unsigned __int8 *v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unsigned int v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v147;
  char v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  int v154;
  int v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t *v159;
  uint64_t v160;
  int v161;
  _QWORD *v162;

  v162 = result;
  v6 = (unint64_t *)*((_QWORD *)a2 + 2);
  v7 = (__int16 *)*((_QWORD *)a2 + 4);
  if (v7)
    v152 = *((_QWORD *)a2 + 5) - a5;
  else
    v152 = 0;
  v8 = *((unsigned __int16 *)a2 + 4);
  v151 = *a2;
  v150 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v9 = *((_QWORD *)a2 + 18);
  v11 = *((_QWORD *)a2 + 9);
  v147 = *((_QWORD *)a2 + 11);
  v12 = *((_QWORD *)a2 + 7) + v147 * a4;
  v13 = (unsigned __int8 *)result[4];
  v14 = &v13[(*((_DWORD *)result + 65) - 1) * *((_DWORD *)result + 6)
           + (((*((_DWORD *)result + 2) >> 22) * *((_DWORD *)result + 64)) >> 3)];
  v15 = 2 * (v7 != 0);
  v161 = v8;
  v148 = v11;
  v149 = v10;
  v160 = v15;
  if (result[22])
  {
    v145 = *((_QWORD *)a2 + 13);
    v144 = *((_QWORD *)a2 + 15);
    v143 = ~(-1 << v11);
    v142 = v11 - 4;
    v16 = v14 - 3;
    v17 = v8 ^ 0xFFFF;
    v140 = a5;
    v141 = -v10;
    v139 = v9 + 16 * a3 + 8;
    while (1)
    {
      v154 = a6;
      if (((v144 - v12) | (v12 - v145)) < 0)
      {
        v20 = 0;
        v19 = 0;
      }
      else
      {
        v18 = ((v12 & (unint64_t)v143) >> v142) & 0xF;
        v19 = (unint64_t)(v18 - 7) >= 9 ? v141 : v10;
        v20 = weights_19497[v18] & 0xF;
      }
      v153 = v12;
      v21 = v162[4] + (v12 >> v11) * v10;
      if (v151 != 1)
        break;
      if (a5 >= 1)
      {
        v22 = (uint64_t *)v139;
        v23 = v140;
        while (1)
        {
          v24 = *(v22 - 1);
          v25 = *v22;
          v26 = v21 + v24;
          if ((unint64_t)v16 >= v21 + v24)
            v27 = (unsigned __int8 *)(v21 + v24);
          else
            v27 = v16;
          if (v27 < v13)
            v27 = v13;
          v28 = (*v27 << 24) | (v27[1] << 16) | (v27[2] << 8);
          v29 = v25 & 0xF;
          if ((v25 & 0xF) != 0)
            break;
          if (v20)
          {
            v40 = (unsigned __int8 *)(v26 + v19);
            if ((unint64_t)v16 < v26 + v19)
              v40 = v16;
            if (v40 < v13)
              v40 = v13;
            v41 = BLEND8_19499[v20];
            v38 = v28 - ((v41 & v28) >> v20);
            v39 = (((*v40 << 24) | (v40[1] << 16) | (v40[2] << 8)) & v41) >> v20;
            goto LABEL_43;
          }
LABEL_44:
          v42 = BYTE2(v28);
          v43 = BYTE1(v28);
          HIDWORD(v45) = HIBYTE(v28);
          LODWORD(v45) = v28;
          v44 = v45 >> 24;
          v46 = v42 | (v42 << 8);
          v47 = v43 | (v43 << 8);
          if (v44 <= v46)
            v48 = v46;
          else
            v48 = v44;
          if (v47 > v48)
            v48 = v47;
          v49 = v48 - v44;
          v50 = v48 - v46;
          v51 = v48 - v47;
          v52 = v48 ^ 0xFFFF;
          v53 = v52 << 48;
          v54 = (unint64_t)(unsigned __int16)v51 << 32;
          result = (_QWORD *)(v50 - ((v50 * v17 + ((v50 * v17) >> 16) + 1) >> 16));
          v55 = (unint64_t)(v52
                                 - (((_DWORD)v52 * v17 + ((v52 * v17) >> 16) + 1) >> 16)) << 48;
          v56 = (unint64_t)(unsigned __int16)(v51 - ((v51 * v17 + ((v51 * v17) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
          {
            v56 = v53;
            v55 = v54;
            v57 = v50;
          }
          else
          {
            v57 = v50 - ((v50 * v17 + ((v50 * v17) >> 16) + 1) >> 16);
          }
          if (v8 == 0xFFFF)
          {
            v58 = -1;
          }
          else
          {
            LOWORD(v49) = v49 - ((v49 * v17 + ((v49 * v17) >> 16) + 1) >> 16);
            v58 = ~(0xFFFF * v17 + ((0xFFFF * v17) >> 16) + 1) >> 16;
          }
          if (v7)
            *v7 = v58;
          v22 += 2;
          *v6++ = v55 | v56 | (v57 << 16) | (unsigned __int16)v49;
          v7 = (__int16 *)((char *)v7 + v15);
          if (!--v23)
            goto LABEL_109;
        }
        v30 = (unsigned __int8 *)(v26 + (v25 >> 4));
        if (v16 < v30)
          v30 = v16;
        if (v30 < v13)
          v30 = v13;
        v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
        if (v20)
        {
          v32 = (unsigned __int8 *)(v26 + v19);
          if (v16 >= v32)
            v33 = v32;
          else
            v33 = v16;
          if (v33 < v13)
            v33 = v13;
          v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
          v35 = &v32[v25 >> 4];
          if (v16 < v35)
            v35 = v16;
          if (v35 < v13)
            v35 = v13;
          v36 = BLEND8_19499[v20];
          v28 = v28 - ((v36 & v28) >> v20) + ((v36 & v34) >> v20);
          v31 = v31 - ((v36 & v31) >> v20) + ((((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8)) & v36) >> v20);
        }
        v37 = BLEND8_19499[*v22 & 0xF];
        v38 = v28 - ((v37 & v28) >> v29);
        v39 = (v37 & v31) >> v29;
LABEL_43:
        v28 = v38 + v39;
        goto LABEL_44;
      }
LABEL_109:
      v10 = v149;
      v6 += v150;
      LOBYTE(v11) = v148;
      v12 = v153 + v147;
      v7 += v152;
      a6 = v154 - 1;
      if (v154 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_109;
    v59 = (uint64_t *)v139;
    v60 = v140;
    v158 = v19;
    v156 = v162[4] + (v12 >> v11) * v10;
    while (1)
    {
      v61 = *(v59 - 1);
      v62 = *v59;
      v63 = v21 + v61;
      if ((unint64_t)v16 >= v21 + v61)
        v64 = (unsigned __int8 *)(v21 + v61);
      else
        v64 = v16;
      if (v64 < v13)
        v64 = v13;
      v65 = (*v64 << 24) | (v64[1] << 16) | (v64[2] << 8);
      v66 = v62 & 0xF;
      if ((v62 & 0xF) != 0)
      {
        v67 = (unsigned __int8 *)(v63 + (v62 >> 4));
        if (v16 < v67)
          v67 = v16;
        if (v67 < v13)
          v67 = v13;
        v68 = (*v67 << 24) | (v67[1] << 16) | (v67[2] << 8);
        if (v20)
        {
          v69 = (unsigned __int8 *)(v63 + v19);
          if (v16 >= v69)
            v70 = v69;
          else
            v70 = v16;
          if (v70 < v13)
            v70 = v13;
          v71 = (*v70 << 24) | (v70[1] << 16) | (v70[2] << 8);
          v72 = &v69[v62 >> 4];
          if (v16 < v72)
            v72 = v16;
          if (v72 < v13)
            v72 = v13;
          v73 = BLEND8_19499[v20];
          v65 = v65 - ((v73 & v65) >> v20) + ((v73 & v71) >> v20);
          v68 = v68 - ((v73 & v68) >> v20) + ((((*v72 << 24) | (v72[1] << 16) | (v72[2] << 8)) & v73) >> v20);
        }
        v74 = BLEND8_19499[*v59 & 0xF];
        v75 = v65 - ((v74 & v65) >> v66);
        v76 = (v74 & v68) >> v66;
      }
      else
      {
        if (!v20)
          goto LABEL_90;
        v77 = (unsigned __int8 *)(v63 + v19);
        if ((unint64_t)v16 < v63 + v19)
          v77 = v16;
        if (v77 < v13)
          v77 = v13;
        v78 = BLEND8_19499[v20];
        v75 = v65 - ((v78 & v65) >> v20);
        v76 = (((*v77 << 24) | (v77[1] << 16) | (v77[2] << 8)) & v78) >> v20;
      }
      v65 = v75 + v76;
LABEL_90:
      v79 = BYTE2(v65);
      v80 = BYTE1(v65);
      HIDWORD(v82) = HIBYTE(v65);
      LODWORD(v82) = v65;
      v81 = v82 >> 24;
      v83 = v79 | (v79 << 8);
      v84 = v80 | (v80 << 8);
      if (v81 <= v83)
        v85 = v83;
      else
        v85 = v81;
      if (v84 > v85)
        v85 = v84;
      v86 = v85 - v81;
      v87 = v85 - v83;
      v88 = v85 - v84;
      v89 = v85 ^ 0xFFFF;
      v90 = v89 << 48;
      v91 = (unint64_t)(unsigned __int16)v88 << 32;
      v92 = (unint64_t)(v89 - (((_DWORD)v89 * v17 + ((v89 * v17) >> 16) + 1) >> 16)) << 48;
      v93 = (unint64_t)(unsigned __int16)(v88 - ((v88 * v17 + ((v88 * v17) >> 16) + 1) >> 16)) << 32;
      if (v8 == 0xFFFF)
      {
        v93 = v90;
        v92 = v91;
        v94 = 0xFFFF;
      }
      else
      {
        v87 -= (v87 * v17 + ((v87 * v17) >> 16) + 1) >> 16;
        LOWORD(v86) = v86 - ((v86 * v17 + ((v86 * v17) >> 16) + 1) >> 16);
        v94 = ~(0xFFFF * v17 + ((0xFFFF * v17) >> 16) + 1) >> 16;
      }
      v95 = v92 | v93 | (v87 << 16) | (unsigned __int16)v86;
      if (v7)
      {
        if (v94)
        {
          if (v94 != 0xFFFF)
          {
            result = cmyk64_DAplusDAM(v6, v7, v95, v94, *v6, (unsigned __int16)*v7, v94 ^ 0xFFFF);
LABEL_107:
            v21 = v156;
            v19 = v158;
            v15 = v160;
            v8 = v161;
            goto LABEL_108;
          }
          *v6 = v95;
          *v7 = -1;
        }
      }
      else if (v94)
      {
        if (v94 != 0xFFFF)
        {
          result = cmyk64_DplusDM(v6, v95, *v6, v94 ^ 0xFFFF);
          goto LABEL_107;
        }
        *v6 = v95;
      }
LABEL_108:
      v59 += 2;
      ++v6;
      v7 = (__int16 *)((char *)v7 + v15);
      if (!--v60)
        goto LABEL_109;
    }
  }
  v159 = (uint64_t *)(v9 + 16 * a3);
  v96 = v14 - 3;
  v97 = v8 ^ 0xFFFF;
  v157 = a5;
  do
  {
    v98 = (unsigned __int8 *)v162[4];
    v99 = &v98[(v12 >> v11) * v10];
    v155 = a6;
    if (v151 != 1)
    {
      v100 = v12;
      v121 = v159;
      v122 = v157;
      if (a5 < 1)
        goto LABEL_167;
      while (1)
      {
        v123 = *v121;
        v121 += 2;
        v124 = &v99[v123];
        if (v96 < &v99[v123])
          v124 = v96;
        if ((unint64_t)v124 < v162[4])
          v124 = (unsigned __int8 *)v162[4];
        v125 = *v124 | (*v124 << 8);
        v126 = v124[1] | (v124[1] << 8);
        v127 = v124[2] | (v124[2] << 8);
        if (v125 <= v126)
          v128 = v126;
        else
          v128 = v125;
        if (v127 > v128)
          v128 = v127;
        v129 = v128 - v125;
        v130 = v128 - v126;
        v131 = v128 - v127;
        v132 = v128 ^ 0xFFFF;
        v133 = v132 << 48;
        v134 = (unint64_t)(unsigned __int16)v131 << 32;
        v135 = (unint64_t)(v132
                                - (((_DWORD)v132 * v97 + ((v132 * v97) >> 16) + 1) >> 16)) << 48;
        v136 = (unint64_t)(unsigned __int16)(v131 - ((v131 * v97 + ((v131 * v97) >> 16) + 1) >> 16)) << 32;
        if (v8 == 0xFFFF)
        {
          v136 = v133;
          v135 = v134;
          v137 = 0xFFFF;
        }
        else
        {
          v130 -= (v130 * v97 + ((v130 * v97) >> 16) + 1) >> 16;
          LOWORD(v129) = v129 - ((v129 * v97 + ((v129 * v97) >> 16) + 1) >> 16);
          v137 = ~(0xFFFF * v97 + ((0xFFFF * v97) >> 16) + 1) >> 16;
        }
        v138 = v135 | v136 | (v130 << 16) | (unsigned __int16)v129;
        if (v7)
        {
          if (v137)
          {
            if (v137 != 0xFFFF)
            {
              result = cmyk64_DAplusDAM(v6, v7, v138, v137, *v6, (unsigned __int16)*v7, v137 ^ 0xFFFF);
LABEL_165:
              v15 = v160;
              v8 = v161;
              goto LABEL_166;
            }
            *v6 = v138;
            *v7 = -1;
          }
        }
        else if (v137)
        {
          if (v137 != 0xFFFF)
          {
            result = cmyk64_DplusDM(v6, v138, *v6, v137 ^ 0xFFFF);
            goto LABEL_165;
          }
          *v6 = v138;
        }
LABEL_166:
        ++v6;
        v7 = (__int16 *)((char *)v7 + v15);
        if (!--v122)
          goto LABEL_167;
      }
    }
    v100 = v12;
    if (a5 >= 1)
    {
      v101 = v159;
      v102 = v157;
      do
      {
        v103 = *v101;
        v101 += 2;
        v104 = &v99[v103];
        if (v96 < &v99[v103])
          v104 = v96;
        if (v104 < v98)
          v104 = v98;
        v105 = *v104 | (*v104 << 8);
        v106 = v104[1] | (v104[1] << 8);
        v107 = v104[2] | (v104[2] << 8);
        if (v105 <= v106)
          v108 = v106;
        else
          v108 = v105;
        if (v107 > v108)
          v108 = v107;
        v109 = v108 - v105;
        v110 = v108 - v106;
        v111 = v108 - v107;
        v112 = v108 ^ 0xFFFF;
        v113 = (unint64_t)(unsigned __int16)v111 << 32;
        result = (_QWORD *)(v110 - ((v110 * v97 + ((v110 * v97) >> 16) + 1) >> 16));
        v114 = (unint64_t)(v112
                                - (((_DWORD)v112 * v97 + ((v112 * v97) >> 16) + 1) >> 16)) << 48;
        v115 = (unint64_t)(unsigned __int16)(v111 - ((v111 * v97 + ((v111 * v97) >> 16) + 1) >> 16)) << 32;
        if (v8 == 0xFFFF)
          v116 = v112 << 48;
        else
          v116 = v115;
        if (v8 == 0xFFFF)
          v117 = v113;
        else
          v117 = v114;
        if (v8 == 0xFFFF)
          v118 = v110;
        else
          v118 = v110 - ((v110 * v97 + ((v110 * v97) >> 16) + 1) >> 16);
        if (v8 == 0xFFFF)
          v119 = v109;
        else
          v119 = v109 - ((v109 * v97 + ((v109 * v97) >> 16) + 1) >> 16);
        if (v8 == 0xFFFF)
          v120 = -1;
        else
          v120 = ~(0xFFFF * v97 + ((0xFFFF * v97) >> 16) + 1) >> 16;
        if (v7)
          *v7 = v120;
        *v6++ = v117 | v116 | (v118 << 16) | v119;
        v7 = (__int16 *)((char *)v7 + v15);
        --v102;
      }
      while (v102);
    }
LABEL_167:
    v10 = v149;
    v6 += v150;
    LOBYTE(v11) = v148;
    v12 = v100 + v147;
    v7 += v152;
    a6 = v155 - 1;
  }
  while (v155 != 1);
  return result;
}

unint64_t cmyk64_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unint64_t *v7;
  unsigned __int16 *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  uint64_t v17;
  unsigned int *v18;
  char v19;
  int v20;
  uint64_t v21;
  char v22;
  BOOL v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  char v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int *v40;
  int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int *v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  unint64_t v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int *v67;
  unsigned int v68;
  char v69;
  unsigned int *v70;
  unsigned int v71;
  unsigned int *v72;
  unsigned int *v73;
  unsigned int v74;
  unsigned int *v75;
  int v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int *v80;
  int v81;
  unsigned int v82;
  int v83;
  int v84;
  int v85;
  unsigned int v86;
  unint64_t v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unint64_t v97;
  unsigned int *v98;
  char v99;
  int v100;
  unsigned int *v101;
  char *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int *v107;
  unsigned int v108;
  unsigned int v109;
  int v110;
  int v111;
  int v112;
  unsigned int v113;
  unint64_t v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  uint64_t v123;
  uint64_t *v124;
  uint64_t v125;
  uint64_t v126;
  unsigned int *v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  int v131;
  int v132;
  unsigned int v133;
  unint64_t v134;
  unsigned int v135;
  unsigned int v136;
  int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v153;
  char v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  uint64_t v162;
  char v163;
  int v164;
  int v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t *v169;

  v167 = result;
  if (*(_QWORD *)(result + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (unint64_t *)*((_QWORD *)a2 + 2);
  v8 = (unsigned __int16 *)*((_QWORD *)a2 + 4);
  if (v8)
    v158 = *((_QWORD *)a2 + 5) - a5;
  else
    v158 = 0;
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = a2[1];
  v157 = *a2;
  v156 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v153 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v153 * a4;
  v15 = *(unsigned int **)(result + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v17 = 2 * (v8 != 0);
  v164 = v9;
  v165 = v6;
  v163 = v10;
  v154 = v13;
  v155 = v12;
  v162 = v17;
  if (*(_QWORD *)(result + 176))
  {
    v149 = ~(-1 << v13);
    v150 = *((_QWORD *)a2 + 15);
    v151 = *((_QWORD *)a2 + 13);
    v148 = v13 - 4;
    v18 = (unsigned int *)(v16 - 4);
    v19 = 32 - v10;
    v20 = v9 ^ 0xFFFF;
    v146 = a5;
    v147 = -v12;
    v145 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v150 - v14) | (v14 - v151)) < 0)
      {
        v25 = 0;
        v168 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)v149) >> v148) & 0xF;
        v22 = weights_19497[v21];
        v23 = (unint64_t)(v21 - 7) >= 9;
        v24 = v147;
        if (!v23)
          v24 = v12;
        v168 = v24;
        v25 = v22 & 0xF;
      }
      v26 = *(_QWORD *)(v167 + 32) + (v14 >> v13) * v12;
      v160 = a6;
      v159 = v14;
      if (v157 != 1)
        break;
      if (a5 >= 1)
      {
        v27 = (uint64_t *)v145;
        v28 = v146;
        while (1)
        {
          v29 = *(v27 - 1);
          v30 = *v27;
          v31 = v26 + v29;
          if ((unint64_t)v18 >= v26 + v29)
            v32 = (unsigned int *)(v26 + v29);
          else
            v32 = v18;
          if (v32 < v15)
            v32 = v15;
          v33 = bswap32(*v32);
          v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0)
            break;
          if (v25)
          {
            v45 = (unsigned int *)(v31 + v168);
            if ((unint64_t)v18 < v31 + v168)
              v45 = v18;
            if (v45 < v15)
              v45 = v15;
            v46 = BLEND8_19499[v25];
            v43 = v33 - ((v46 & v33) >> v25);
            v44 = (bswap32(*v45) & v46) >> v25;
            goto LABEL_45;
          }
LABEL_46:
          v47 = (v33 << v10) | (v33 >> v19);
          v48 = BYTE2(v47);
          v49 = BYTE1(v47);
          v50 = v47 | v6;
          HIDWORD(v52) = HIBYTE(v47);
          LODWORD(v52) = v47;
          v51 = v52 >> 24;
          v53 = v48 | (v48 << 8);
          v54 = v49 | (v49 << 8);
          v55 = v50 | (v50 << 8);
          if (v51 <= v53)
            v56 = v53;
          else
            v56 = v51;
          if (v54 <= v56)
            v57 = v56;
          else
            v57 = v54;
          v58 = v57 - v51;
          v59 = v57 - v53;
          v60 = v57 - v54;
          v61 = v55 - v57;
          if (v9 != 0xFFFF)
          {
            result = v60 * v20 + ((v60 * v20) >> 16) + 1;
            v58 -= (v58 * v20 + ((v58 * v20) >> 16) + 1) >> 16;
            v59 -= (v59 * v20 + ((v59 * v20) >> 16) + 1) >> 16;
            v60 -= WORD1(result);
            v61 = v61 - (((_DWORD)v61 * v20 + ((v61 * v20) >> 16) + 1) >> 16);
            v55 -= (v55 * v20 + ((v55 * v20) >> 16) + 1) >> 16;
          }
          if (v8)
            *v8 = v55;
          v27 += 2;
          *v7++ = ((unint64_t)(unsigned __int16)v60 << 32) | (v61 << 48) | (v59 << 16) | (unint64_t)(unsigned __int16)v58;
          v8 = (unsigned __int16 *)((char *)v8 + v17);
          if (!--v28)
            goto LABEL_108;
        }
        v35 = (unsigned int *)(v31 + (v30 >> 4));
        if (v18 < v35)
          v35 = v18;
        if (v35 < v15)
          v35 = v15;
        v36 = bswap32(*v35);
        if (v25)
        {
          v37 = (unsigned int *)(v31 + v168);
          if (v18 >= v37)
            v38 = v37;
          else
            v38 = v18;
          if (v38 < v15)
            v38 = v15;
          v39 = bswap32(*v38);
          v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v18 < v40)
            v40 = v18;
          if (v40 < v15)
            v40 = v15;
          v41 = BLEND8_19499[v25];
          result = (v41 & v36) >> v25;
          v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          v36 = v36 - result + ((bswap32(*v40) & v41) >> v25);
        }
        v42 = BLEND8_19499[*v27 & 0xF];
        v43 = v33 - ((v42 & v33) >> v34);
        v44 = (v42 & v36) >> v34;
LABEL_45:
        v33 = v43 + v44;
        goto LABEL_46;
      }
LABEL_108:
      v12 = v155;
      v7 += v156;
      LOBYTE(v13) = v154;
      v14 = v159 + v153;
      v8 += v158;
      a6 = v160 - 1;
      if (v160 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_108;
    v63 = (uint64_t *)v145;
    v62 = v146;
    result = (unint64_t)BLEND8_19499;
    while (1)
    {
      v64 = *(v63 - 1);
      v65 = *v63;
      v66 = v26 + v64;
      if ((unint64_t)v18 >= v26 + v64)
        v67 = (unsigned int *)(v26 + v64);
      else
        v67 = v18;
      if (v67 < v15)
        v67 = v15;
      v68 = bswap32(*v67);
      v69 = v65 & 0xF;
      if ((v65 & 0xF) != 0)
      {
        v70 = (unsigned int *)(v66 + (v65 >> 4));
        if (v18 < v70)
          v70 = v18;
        if (v70 < v15)
          v70 = v15;
        v71 = bswap32(*v70);
        if (v25)
        {
          v72 = (unsigned int *)(v66 + v168);
          if (v18 >= v72)
            v73 = v72;
          else
            v73 = v18;
          if (v73 < v15)
            v73 = v15;
          v74 = bswap32(*v73);
          v75 = (unsigned int *)((char *)v72 + (v65 >> 4));
          if (v18 < v75)
            v75 = v18;
          if (v75 < v15)
            v75 = v15;
          v76 = BLEND8_19499[v25];
          v68 = v68 - ((v76 & v68) >> v25) + ((v76 & v74) >> v25);
          v71 = v71 - ((v76 & v71) >> v25) + ((bswap32(*v75) & v76) >> v25);
        }
        v77 = BLEND8_19499[*v63 & 0xF];
        v78 = v68 - ((v77 & v68) >> v69);
        v79 = (v77 & v71) >> v69;
      }
      else
      {
        if (!v25)
          goto LABEL_89;
        v80 = (unsigned int *)(v66 + v168);
        if ((unint64_t)v18 < v66 + v168)
          v80 = v18;
        if (v80 < v15)
          v80 = v15;
        v81 = BLEND8_19499[v25];
        v78 = v68 - ((v81 & v68) >> v25);
        v79 = (bswap32(*v80) & v81) >> v25;
      }
      v68 = v78 + v79;
LABEL_89:
      v82 = (v68 << v10) | (v68 >> v19);
      v83 = BYTE2(v82);
      v84 = BYTE1(v82);
      v85 = v82 | v6;
      HIDWORD(v87) = HIBYTE(v82);
      LODWORD(v87) = v82;
      v86 = v87 >> 24;
      v88 = v83 | (v83 << 8);
      v89 = v84 | (v84 << 8);
      v90 = v85 | (v85 << 8);
      if (v86 <= v88)
        v91 = v88;
      else
        v91 = v86;
      if (v89 <= v91)
        v92 = v91;
      else
        v92 = v89;
      v93 = v92 - v86;
      v94 = v92 - v88;
      v95 = v92 - v89;
      v96 = v90 - v92;
      if (v9 != 0xFFFF)
      {
        v93 -= (v93 * v20 + ((v93 * v20) >> 16) + 1) >> 16;
        v94 -= (v94 * v20 + ((v94 * v20) >> 16) + 1) >> 16;
        v95 -= (v95 * v20 + ((v95 * v20) >> 16) + 1) >> 16;
        v96 = v96 - (((_DWORD)v96 * v20 + ((v96 * v20) >> 16) + 1) >> 16);
        v90 -= (v90 * v20 + ((v90 * v20) >> 16) + 1) >> 16;
      }
      v97 = ((unint64_t)(unsigned __int16)v95 << 32) | (v96 << 48) | (v94 << 16) | (unint64_t)(unsigned __int16)v93;
      if (v8)
      {
        if ((_WORD)v90)
        {
          if ((unsigned __int16)v90 != 0xFFFF)
          {
            cmyk64_DAplusDAM(v7, v8, v97, v90, *v7, *v8, (unsigned __int16)~(_WORD)v90);
LABEL_106:
            result = (unint64_t)BLEND8_19499;
            v17 = v162;
            LOBYTE(v10) = v163;
            v9 = v164;
            v6 = v165;
            goto LABEL_107;
          }
          *v7 = v97;
          *v8 = -1;
        }
      }
      else if ((_WORD)v90)
      {
        if ((unsigned __int16)v90 != 0xFFFF)
        {
          cmyk64_DplusDM(v7, v97, *v7, (unsigned __int16)~(_WORD)v90);
          goto LABEL_106;
        }
        *v7 = v97;
      }
LABEL_107:
      v63 += 2;
      ++v7;
      v8 = (unsigned __int16 *)((char *)v8 + v17);
      if (!--v62)
        goto LABEL_108;
    }
  }
  v169 = (uint64_t *)(v11 + 16 * a3);
  v98 = (unsigned int *)(v16 - 4);
  v99 = 32 - v10;
  v100 = v9 ^ 0xFFFF;
  v166 = a5;
  do
  {
    v101 = *(unsigned int **)(v167 + 32);
    v102 = (char *)v101 + (v14 >> v13) * v12;
    v161 = a6;
    if (v157 != 1)
    {
      v103 = v14;
      v124 = v169;
      v125 = v166;
      if (a5 < 1)
        goto LABEL_154;
      while (1)
      {
        v126 = *v124;
        v124 += 2;
        v127 = (unsigned int *)&v102[v126];
        if (v98 < (unsigned int *)&v102[v126])
          v127 = v98;
        if ((unint64_t)v127 < *(_QWORD *)(v167 + 32))
          v127 = *(unsigned int **)(v167 + 32);
        v128 = bswap32(*v127);
        v129 = (v128 << v10) | (v128 >> v99);
        v130 = BYTE2(v129);
        v131 = BYTE1(v129);
        v132 = v129 | v6;
        HIDWORD(v134) = HIBYTE(v129);
        LODWORD(v134) = v129;
        v133 = v134 >> 24;
        v135 = v130 | (v130 << 8);
        v136 = v131 | (v131 << 8);
        v137 = v132 | (v132 << 8);
        if (v133 <= v135)
          v138 = v135;
        else
          v138 = v133;
        if (v136 <= v138)
          v139 = v138;
        else
          v139 = v136;
        v140 = v139 - v133;
        v141 = v139 - v135;
        v142 = v139 - v136;
        v143 = v137 - v139;
        if (v9 != 0xFFFF)
        {
          v140 -= (v140 * v100 + ((v140 * v100) >> 16) + 1) >> 16;
          v141 -= (v141 * v100 + ((v141 * v100) >> 16) + 1) >> 16;
          v142 -= (v142 * v100 + ((v142 * v100) >> 16) + 1) >> 16;
          v143 = v143 - (((_DWORD)v143 * v100 + ((v143 * v100) >> 16) + 1) >> 16);
          v137 -= (v137 * v100 + ((v137 * v100) >> 16) + 1) >> 16;
        }
        v144 = ((unint64_t)(unsigned __int16)v142 << 32) | (v143 << 48) | (v141 << 16) | (unint64_t)(unsigned __int16)v140;
        if (v8)
        {
          if ((_WORD)v137)
          {
            if ((unsigned __int16)v137 != 0xFFFF)
            {
              result = (unint64_t)cmyk64_DAplusDAM(v7, v8, v144, v137, *v7, *v8, (unsigned __int16)~(_WORD)v137);
LABEL_152:
              v17 = v162;
              LOBYTE(v10) = v163;
              v9 = v164;
              v6 = v165;
              goto LABEL_153;
            }
            *v7 = v144;
            *v8 = -1;
          }
        }
        else if ((_WORD)v137)
        {
          if ((unsigned __int16)v137 != 0xFFFF)
          {
            result = (unint64_t)cmyk64_DplusDM(v7, v144, *v7, (unsigned __int16)~(_WORD)v137);
            goto LABEL_152;
          }
          *v7 = v144;
        }
LABEL_153:
        ++v7;
        v8 = (unsigned __int16 *)((char *)v8 + v17);
        if (!--v125)
          goto LABEL_154;
      }
    }
    v103 = v14;
    if (a5 >= 1)
    {
      v104 = v169;
      v105 = v166;
      do
      {
        v106 = *v104;
        v104 += 2;
        v107 = (unsigned int *)&v102[v106];
        if (v98 < (unsigned int *)&v102[v106])
          v107 = v98;
        if (v107 < v101)
          v107 = v101;
        v108 = bswap32(*v107);
        v109 = (v108 << v10) | (v108 >> v99);
        v110 = BYTE2(v109);
        v111 = BYTE1(v109);
        v112 = v109 | v6;
        HIDWORD(v114) = HIBYTE(v109);
        LODWORD(v114) = v109;
        v113 = v114 >> 24;
        v115 = v110 | (v110 << 8);
        v116 = v111 | (v111 << 8);
        v117 = v112 | (v112 << 8);
        if (v113 <= v115)
          v118 = v115;
        else
          v118 = v113;
        if (v116 <= v118)
          v119 = v118;
        else
          v119 = v116;
        v120 = v119 - v113;
        v121 = v119 - v115;
        v122 = v119 - v116;
        v123 = v117 - v119;
        if (v9 != 0xFFFF)
        {
          result = v122 * v100 + ((v122 * v100) >> 16) + 1;
          v120 -= (v120 * v100 + ((v120 * v100) >> 16) + 1) >> 16;
          v121 -= (v121 * v100 + ((v121 * v100) >> 16) + 1) >> 16;
          v122 -= WORD1(result);
          v123 = v123 - (((_DWORD)v123 * v100 + ((v123 * v100) >> 16) + 1) >> 16);
          v117 -= (v117 * v100 + ((v117 * v100) >> 16) + 1) >> 16;
        }
        if (v8)
          *v8 = v117;
        *v7++ = ((unint64_t)(unsigned __int16)v122 << 32) | (v123 << 48) | (v121 << 16) | (unint64_t)(unsigned __int16)v120;
        v8 = (unsigned __int16 *)((char *)v8 + v17);
        --v105;
      }
      while (v105);
    }
LABEL_154:
    v12 = v155;
    v7 += v156;
    LOBYTE(v13) = v154;
    v14 = v103 + v153;
    v8 += v158;
    a6 = v161 - 1;
  }
  while (v161 != 1);
  return result;
}

unint64_t cmyk64_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unint64_t *v7;
  unsigned __int16 *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  uint64_t v17;
  unsigned int *v18;
  char v19;
  int v20;
  uint64_t v21;
  char v22;
  BOOL v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  char v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int *v40;
  int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int *v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  unint64_t v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int *v67;
  unsigned int v68;
  char v69;
  unsigned int *v70;
  unsigned int v71;
  unsigned int *v72;
  unsigned int *v73;
  unsigned int v74;
  unsigned int *v75;
  int v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int *v80;
  int v81;
  unsigned int v82;
  int v83;
  int v84;
  int v85;
  unsigned int v86;
  unint64_t v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char v99;
  int v100;
  char *v101;
  char *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  unsigned int v108;
  int v109;
  int v110;
  int v111;
  unsigned int v112;
  unint64_t v113;
  unsigned int v114;
  unsigned int v115;
  int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  unsigned int v127;
  int v128;
  int v129;
  int v130;
  unsigned int v131;
  unint64_t v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int v140;
  uint64_t v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  char v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v151;
  char v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  int v159;
  uint64_t v160;
  char v161;
  int v162;
  int v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t *v167;

  v165 = result;
  if (*(_QWORD *)(result + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (unint64_t *)*((_QWORD *)a2 + 2);
  v8 = (unsigned __int16 *)*((_QWORD *)a2 + 4);
  if (v8)
    v156 = *((_QWORD *)a2 + 5) - a5;
  else
    v156 = 0;
  v9 = *((unsigned __int16 *)a2 + 4);
  v10 = a2[1];
  v155 = *a2;
  v154 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v151 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v151 * a4;
  v15 = *(unsigned int **)(result + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v17 = 2 * (v8 != 0);
  v162 = v9;
  v163 = v6;
  v161 = v10;
  v152 = v13;
  v153 = v12;
  v160 = v17;
  if (*(_QWORD *)(result + 176))
  {
    v147 = ~(-1 << v13);
    v148 = *((_QWORD *)a2 + 15);
    v149 = *((_QWORD *)a2 + 13);
    v146 = v13 - 4;
    v18 = (unsigned int *)(v16 - 4);
    v19 = 32 - v10;
    v20 = v9 ^ 0xFFFF;
    v144 = a5;
    v145 = -v12;
    v143 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v148 - v14) | (v14 - v149)) < 0)
      {
        v25 = 0;
        v166 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)v147) >> v146) & 0xF;
        v22 = weights_19497[v21];
        v23 = (unint64_t)(v21 - 7) >= 9;
        v24 = v145;
        if (!v23)
          v24 = v12;
        v166 = v24;
        v25 = v22 & 0xF;
      }
      v26 = *(_QWORD *)(v165 + 32) + (v14 >> v13) * v12;
      v158 = a6;
      v157 = v14;
      if (v155 != 1)
        break;
      if (a5 >= 1)
      {
        v27 = (uint64_t *)v143;
        v28 = v144;
        while (1)
        {
          v29 = *(v27 - 1);
          v30 = *v27;
          v31 = v26 + v29;
          if ((unint64_t)v18 >= v26 + v29)
            v32 = (unsigned int *)(v26 + v29);
          else
            v32 = v18;
          if (v32 < v15)
            v32 = v15;
          v33 = *v32;
          v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0)
            break;
          if (v25)
          {
            v45 = (unsigned int *)(v31 + v166);
            if ((unint64_t)v18 < v31 + v166)
              v45 = v18;
            if (v45 < v15)
              v45 = v15;
            v46 = BLEND8_19499[v25];
            v43 = v33 - ((v46 & v33) >> v25);
            v44 = (v46 & *v45) >> v25;
            goto LABEL_45;
          }
LABEL_46:
          v47 = (v33 << v10) | (v33 >> v19);
          v48 = BYTE2(v47);
          v49 = BYTE1(v47);
          v50 = v47 | v6;
          HIDWORD(v52) = HIBYTE(v47);
          LODWORD(v52) = v47;
          v51 = v52 >> 24;
          v53 = v48 | (v48 << 8);
          v54 = v49 | (v49 << 8);
          v55 = v50 | (v50 << 8);
          if (v51 <= v53)
            v56 = v53;
          else
            v56 = v51;
          if (v54 <= v56)
            v57 = v56;
          else
            v57 = v54;
          v58 = v57 - v51;
          v59 = v57 - v53;
          v60 = v57 - v54;
          v61 = v55 - v57;
          if (v9 != 0xFFFF)
          {
            result = v60 * v20 + ((v60 * v20) >> 16) + 1;
            v58 -= (v58 * v20 + ((v58 * v20) >> 16) + 1) >> 16;
            v59 -= (v59 * v20 + ((v59 * v20) >> 16) + 1) >> 16;
            v60 -= WORD1(result);
            v61 = v61 - (((_DWORD)v61 * v20 + ((v61 * v20) >> 16) + 1) >> 16);
            v55 -= (v55 * v20 + ((v55 * v20) >> 16) + 1) >> 16;
          }
          if (v8)
            *v8 = v55;
          v27 += 2;
          *v7++ = ((unint64_t)(unsigned __int16)v60 << 32) | (v61 << 48) | (v59 << 16) | (unint64_t)(unsigned __int16)v58;
          v8 = (unsigned __int16 *)((char *)v8 + v17);
          if (!--v28)
            goto LABEL_108;
        }
        v35 = (unsigned int *)(v31 + (v30 >> 4));
        if (v18 < v35)
          v35 = v18;
        if (v35 < v15)
          v35 = v15;
        v36 = *v35;
        if (v25)
        {
          v37 = (unsigned int *)(v31 + v166);
          if (v18 >= v37)
            v38 = v37;
          else
            v38 = v18;
          if (v38 < v15)
            v38 = v15;
          v39 = *v38;
          v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v18 < v40)
            v40 = v18;
          if (v40 < v15)
            v40 = v15;
          v41 = BLEND8_19499[v25];
          result = (v41 & v36) >> v25;
          v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          v36 = v36 - result + ((v41 & *v40) >> v25);
        }
        v42 = BLEND8_19499[*v27 & 0xF];
        v43 = v33 - ((v42 & v33) >> v34);
        v44 = (v42 & v36) >> v34;
LABEL_45:
        v33 = v43 + v44;
        goto LABEL_46;
      }
LABEL_108:
      v12 = v153;
      v7 += v154;
      LOBYTE(v13) = v152;
      v14 = v157 + v151;
      v8 += v156;
      a6 = v158 - 1;
      if (v158 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_108;
    v63 = (uint64_t *)v143;
    v62 = v144;
    result = (unint64_t)BLEND8_19499;
    while (1)
    {
      v64 = *(v63 - 1);
      v65 = *v63;
      v66 = v26 + v64;
      if ((unint64_t)v18 >= v26 + v64)
        v67 = (unsigned int *)(v26 + v64);
      else
        v67 = v18;
      if (v67 < v15)
        v67 = v15;
      v68 = *v67;
      v69 = v65 & 0xF;
      if ((v65 & 0xF) != 0)
      {
        v70 = (unsigned int *)(v66 + (v65 >> 4));
        if (v18 < v70)
          v70 = v18;
        if (v70 < v15)
          v70 = v15;
        v71 = *v70;
        if (v25)
        {
          v72 = (unsigned int *)(v66 + v166);
          if (v18 >= v72)
            v73 = v72;
          else
            v73 = v18;
          if (v73 < v15)
            v73 = v15;
          v74 = *v73;
          v75 = (unsigned int *)((char *)v72 + (v65 >> 4));
          if (v18 < v75)
            v75 = v18;
          if (v75 < v15)
            v75 = v15;
          v76 = BLEND8_19499[v25];
          v68 = v68 - ((v76 & v68) >> v25) + ((v76 & v74) >> v25);
          v71 = v71 - ((v76 & v71) >> v25) + ((v76 & *v75) >> v25);
        }
        v77 = BLEND8_19499[*v63 & 0xF];
        v78 = v68 - ((v77 & v68) >> v69);
        v79 = (v77 & v71) >> v69;
      }
      else
      {
        if (!v25)
          goto LABEL_89;
        v80 = (unsigned int *)(v66 + v166);
        if ((unint64_t)v18 < v66 + v166)
          v80 = v18;
        if (v80 < v15)
          v80 = v15;
        v81 = BLEND8_19499[v25];
        v78 = v68 - ((v81 & v68) >> v25);
        v79 = (v81 & *v80) >> v25;
      }
      v68 = v78 + v79;
LABEL_89:
      v82 = (v68 << v10) | (v68 >> v19);
      v83 = BYTE2(v82);
      v84 = BYTE1(v82);
      v85 = v82 | v6;
      HIDWORD(v87) = HIBYTE(v82);
      LODWORD(v87) = v82;
      v86 = v87 >> 24;
      v88 = v83 | (v83 << 8);
      v89 = v84 | (v84 << 8);
      v90 = v85 | (v85 << 8);
      if (v86 <= v88)
        v91 = v88;
      else
        v91 = v86;
      if (v89 <= v91)
        v92 = v91;
      else
        v92 = v89;
      v93 = v92 - v86;
      v94 = v92 - v88;
      v95 = v92 - v89;
      v96 = v90 - v92;
      if (v9 != 0xFFFF)
      {
        v93 -= (v93 * v20 + ((v93 * v20) >> 16) + 1) >> 16;
        v94 -= (v94 * v20 + ((v94 * v20) >> 16) + 1) >> 16;
        v95 -= (v95 * v20 + ((v95 * v20) >> 16) + 1) >> 16;
        v96 = v96 - (((_DWORD)v96 * v20 + ((v96 * v20) >> 16) + 1) >> 16);
        v90 -= (v90 * v20 + ((v90 * v20) >> 16) + 1) >> 16;
      }
      v97 = ((unint64_t)(unsigned __int16)v95 << 32) | (v96 << 48) | (v94 << 16) | (unint64_t)(unsigned __int16)v93;
      if (v8)
      {
        if ((_WORD)v90)
        {
          if ((unsigned __int16)v90 != 0xFFFF)
          {
            cmyk64_DAplusDAM(v7, v8, v97, v90, *v7, *v8, (unsigned __int16)~(_WORD)v90);
LABEL_106:
            result = (unint64_t)BLEND8_19499;
            v17 = v160;
            LOBYTE(v10) = v161;
            v9 = v162;
            v6 = v163;
            goto LABEL_107;
          }
          *v7 = v97;
          *v8 = -1;
        }
      }
      else if ((_WORD)v90)
      {
        if ((unsigned __int16)v90 != 0xFFFF)
        {
          cmyk64_DplusDM(v7, v97, *v7, (unsigned __int16)~(_WORD)v90);
          goto LABEL_106;
        }
        *v7 = v97;
      }
LABEL_107:
      v63 += 2;
      ++v7;
      v8 = (unsigned __int16 *)((char *)v8 + v17);
      if (!--v62)
        goto LABEL_108;
    }
  }
  v167 = (uint64_t *)(v11 + 16 * a3);
  v98 = v16 - 4;
  v99 = 32 - v10;
  v100 = v9 ^ 0xFFFF;
  v164 = a5;
  do
  {
    v101 = *(char **)(v165 + 32);
    v102 = &v101[(v14 >> v13) * v12];
    v159 = a6;
    if (v155 != 1)
    {
      v103 = v14;
      v123 = v167;
      v124 = v164;
      if (a5 < 1)
        goto LABEL_154;
      while (1)
      {
        v125 = *v123;
        v123 += 2;
        v126 = &v102[v125];
        if (v98 < &v102[v125])
          v126 = v98;
        if ((unint64_t)v126 < *(_QWORD *)(v165 + 32))
          v126 = *(char **)(v165 + 32);
        v127 = (*(_DWORD *)v126 << v10) | (*(_DWORD *)v126 >> v99);
        v128 = BYTE2(v127);
        v129 = BYTE1(v127);
        v130 = v127 | v6;
        HIDWORD(v132) = HIBYTE(v127);
        LODWORD(v132) = v127;
        v131 = v132 >> 24;
        v133 = v128 | (v128 << 8);
        v134 = v129 | (v129 << 8);
        v135 = v130 | (v130 << 8);
        if (v131 <= v133)
          v136 = v133;
        else
          v136 = v131;
        if (v134 <= v136)
          v137 = v136;
        else
          v137 = v134;
        v138 = v137 - v131;
        v139 = v137 - v133;
        v140 = v137 - v134;
        v141 = v135 - v137;
        if (v9 != 0xFFFF)
        {
          v138 -= (v138 * v100 + ((v138 * v100) >> 16) + 1) >> 16;
          v139 -= (v139 * v100 + ((v139 * v100) >> 16) + 1) >> 16;
          v140 -= (v140 * v100 + ((v140 * v100) >> 16) + 1) >> 16;
          v141 = v141 - (((_DWORD)v141 * v100 + ((v141 * v100) >> 16) + 1) >> 16);
          v135 -= (v135 * v100 + ((v135 * v100) >> 16) + 1) >> 16;
        }
        v142 = ((unint64_t)(unsigned __int16)v140 << 32) | (v141 << 48) | (v139 << 16) | (unint64_t)(unsigned __int16)v138;
        if (v8)
        {
          if ((_WORD)v135)
          {
            if ((unsigned __int16)v135 != 0xFFFF)
            {
              result = (unint64_t)cmyk64_DAplusDAM(v7, v8, v142, v135, *v7, *v8, (unsigned __int16)~(_WORD)v135);
LABEL_152:
              v17 = v160;
              LOBYTE(v10) = v161;
              v9 = v162;
              v6 = v163;
              goto LABEL_153;
            }
            *v7 = v142;
            *v8 = -1;
          }
        }
        else if ((_WORD)v135)
        {
          if ((unsigned __int16)v135 != 0xFFFF)
          {
            result = (unint64_t)cmyk64_DplusDM(v7, v142, *v7, (unsigned __int16)~(_WORD)v135);
            goto LABEL_152;
          }
          *v7 = v142;
        }
LABEL_153:
        ++v7;
        v8 = (unsigned __int16 *)((char *)v8 + v17);
        if (!--v124)
          goto LABEL_154;
      }
    }
    v103 = v14;
    if (a5 >= 1)
    {
      v104 = v167;
      v105 = v164;
      do
      {
        v106 = *v104;
        v104 += 2;
        v107 = &v102[v106];
        if (v98 < &v102[v106])
          v107 = v98;
        if (v107 < v101)
          v107 = v101;
        v108 = (*(_DWORD *)v107 << v10) | (*(_DWORD *)v107 >> v99);
        v109 = BYTE2(v108);
        v110 = BYTE1(v108);
        v111 = v108 | v6;
        HIDWORD(v113) = HIBYTE(v108);
        LODWORD(v113) = v108;
        v112 = v113 >> 24;
        v114 = v109 | (v109 << 8);
        v115 = v110 | (v110 << 8);
        v116 = v111 | (v111 << 8);
        if (v112 <= v114)
          v117 = v114;
        else
          v117 = v112;
        if (v115 <= v117)
          v118 = v117;
        else
          v118 = v115;
        v119 = v118 - v112;
        v120 = v118 - v114;
        v121 = v118 - v115;
        v122 = v116 - v118;
        if (v9 != 0xFFFF)
        {
          result = v121 * v100 + ((v121 * v100) >> 16) + 1;
          v119 -= (v119 * v100 + ((v119 * v100) >> 16) + 1) >> 16;
          v120 -= (v120 * v100 + ((v120 * v100) >> 16) + 1) >> 16;
          v121 -= WORD1(result);
          v122 = v122 - (((_DWORD)v122 * v100 + ((v122 * v100) >> 16) + 1) >> 16);
          v116 -= (v116 * v100 + ((v116 * v100) >> 16) + 1) >> 16;
        }
        if (v8)
          *v8 = v116;
        *v7++ = ((unint64_t)(unsigned __int16)v121 << 32) | (v122 << 48) | (v120 << 16) | (unint64_t)(unsigned __int16)v119;
        v8 = (unsigned __int16 *)((char *)v8 + v17);
        --v105;
      }
      while (v105);
    }
LABEL_154:
    v12 = v153;
    v7 += v154;
    LOBYTE(v13) = v152;
    v14 = v103 + v151;
    v8 += v156;
    a6 = v159 - 1;
  }
  while (v159 != 1);
  return result;
}

unint64_t cmyk64_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t result;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  char *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int8x16_t v30;
  int16x8_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  uint64_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int8x16_t v49;
  int64x2_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int8x16_t v55;
  int8x16_t v60;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int8x16_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int16x8_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unsigned __int16 *v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unsigned int v90;
  uint64_t v91;
  int8x8_t *v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int v99;
  int v100;
  unsigned int v101;
  int32x2_t v102;
  uint32x2_t v103;
  int32x2_t v104;
  uint32x2_t v105;
  unsigned int v106;
  int v107;
  int8x8_t *v108;
  unsigned __int16 *v109;
  char v110;
  int v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  int v115;
  char v116;
  unsigned int *v117;
  int v118;
  unsigned int v119;
  unsigned int v120;
  uint64_t v121;
  int v122;
  int v123;
  int8x8_t *v124;
  int8x8_t v125;
  int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  int v131;
  int8x8_t *v132;
  int8x8_t v133;
  int v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  unint64_t v140;
  int v141;
  uint64_t v142;
  int8x8_t *v143;
  int8x8_t v144;
  int32x2_t v145;
  uint64_t v146;
  int v147;
  int v148;
  int32x2_t v149;
  int v150;
  unsigned int v151;
  uint32x2_t v152;
  int32x2_t v153;
  uint32x2_t v154;
  int v155;
  unsigned int v156;
  int32x2_t v157;
  int v158;
  int32x2_t v159;
  uint64_t v160;
  int v161;
  int v162;
  int v163;
  unsigned int v164;
  uint32x2_t v165;
  int32x2_t v166;
  uint32x2_t v167;
  unsigned int v168;
  int32x2_t v169;
  uint64_t v170;
  int v171;
  unsigned int v172;
  uint64_t v173;
  int v174;
  uint64_t v175;
  int v176;
  int v177;
  uint64_t v178;
  int v179;
  int v180;
  uint64_t v181;
  int v182;
  uint64_t v183;
  unsigned int v184;
  unint64_t v185;
  __int16 v186;
  uint64_t v187;
  int v188;
  uint64_t v189;
  unsigned int v190;
  unint64_t v191;
  __int16 v192;
  uint64_t v193;
  int v194;
  uint64_t v195;
  unsigned int v196;
  unint64_t v197;
  __int16 v198;
  uint64_t v199;
  int v200;
  uint64_t v201;
  unsigned int v202;
  unint64_t v203;
  __int16 v204;
  uint64_t v205;
  int v206;
  uint64_t v207;
  unsigned int v208;
  unint64_t v209;
  __int16 v210;
  uint64_t v211;
  int v212;
  uint64_t v213;
  unsigned int v214;
  unint64_t v215;
  __int16 v216;
  uint64_t v217;
  int v218;
  uint64_t v219;
  unsigned int v220;
  unint64_t v221;
  __int16 v222;
  uint64_t v223;
  int v224;
  uint64_t v225;
  unsigned int v226;
  unint64_t v227;
  __int16 v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  unsigned int v232;
  unint64_t v233;
  __int16 v234;
  uint64_t v235;
  int v236;
  uint64_t v237;
  unsigned int v238;
  unint64_t v239;
  __int16 v240;
  uint64_t v241;
  int v242;
  uint64_t v243;
  unsigned int v244;
  unint64_t v245;
  __int16 v246;
  uint64_t v247;
  int v248;
  uint64_t v249;
  unsigned int v250;
  unint64_t v251;
  __int16 v252;
  uint64_t v253;
  int v254;
  uint64_t v255;
  unsigned int v256;
  unint64_t v257;
  __int16 v258;
  uint64_t v259;
  int v260;
  uint64_t v261;
  unsigned int v262;
  uint64_t v263;
  int v264;
  uint64_t v265;
  unsigned int v266;
  unint64_t v267;
  __int16 v268;
  int v269;
  int v270;
  int32x2_t v271;
  int32x2_t v272;
  int32x2_t v273;
  int32x2_t v274;
  uint32x2_t v275;
  int32x2_t v276;
  uint32x2_t v277;
  uint32x2_t v278;
  int32x2_t v279;
  int8x8_t v280;
  unint64_t v281;
  int v282;
  char v283;
  int v284;
  unsigned int *v285;
  int v286;
  unsigned int v287;
  unsigned int v288;
  int v289;
  int8x8_t *v290;
  char v291;
  int v292;
  int v293;
  unsigned int v294;
  unsigned int v295;
  unsigned int v296;
  int v297;
  int v298;
  int32x2_t v299;
  int32x2_t v300;
  uint32x2_t v301;
  int32x2_t v302;
  uint32x2_t v303;
  int32x2_t v304;
  int32x2_t v305;
  int32x2_t v306;
  uint32x2_t v307;
  int32x2_t v308;
  uint32x2_t v309;
  int8x8_t v310;
  int8x8_t v311;
  int v312;
  int v313;
  int32x2_t v314;
  int32x2_t v315;
  uint32x2_t v316;
  int32x2_t v317;
  uint32x2_t v318;
  int32x2_t v319;
  int32x2_t v320;
  int32x2_t v321;
  uint32x2_t v322;
  int32x2_t v323;
  uint32x2_t v324;
  int8x8_t v325;
  int8x8_t v326;
  int16x4_t v327;
  unsigned int v328;
  int v329;
  unsigned int v330;
  uint64_t *v331;
  unsigned __int16 *v332;
  uint64_t *v333;
  unsigned __int16 *v334;
  unsigned __int16 *v335;
  unsigned int v336;
  int v337;
  unsigned int v338;
  unsigned int v339;
  int v340;
  int8x8_t *v341;
  unint64_t v342;
  _WORD *v343;
  int v344;
  uint64_t v345;
  int v346;
  int v347;
  uint64_t v348;
  int v349;
  int v350;
  unsigned int v351;
  int v352;
  unsigned int v353;
  uint64_t *v354;
  uint64_t *v355;
  int v356;
  int v357;
  unsigned int v358;
  unsigned int v359;
  int v360;
  int8x8_t *v361;
  unint64_t v362;
  uint64_t v363;
  int v364;
  uint64_t v365;
  int v366;
  unint64_t v367;
  unint64_t v368;
  int v369;
  int v370;
  unint64_t v371;
  int v372;
  unint64_t v373;
  unint64_t v374;
  unint64_t v375;
  int v376;
  unsigned __int16 v377;
  unint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  int v385;
  unsigned int v386;
  unsigned int v387;
  int v388;
  int v389;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned __int16 **)(a1 + 96);
  if (v4)
    v6 = *v4;
  else
    v6 = 0xFFFF;
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 136);
  v9 = **(_QWORD **)(a1 + 88);
  v375 = *(int *)(a1 + 28);
  v379 = *(_QWORD *)(a1 + 40);
  v385 = *(_DWORD *)(a1 + 4);
  pthread_mutex_lock(&cmyk64_cacheColorLock);
  v10 = cmyk64_cacheColor;
  if (!cmyk64_cacheColor
    || *(_QWORD *)(cmyk64_cacheColor + 16) != v9
    || *(unsigned __int16 *)(cmyk64_cacheColor + 24) != v6)
  {
    v13 = 0;
    while (1)
    {
      if (!v10)
        goto LABEL_14;
      v14 = v10;
      v15 = v13;
      if (*(_QWORD *)(v10 + 16) == v9 && *(unsigned __int16 *)(v10 + 24) == v6)
        break;
      v10 = *(_QWORD *)v10;
      v13 = (_QWORD *)v14;
      if (!*(_QWORD *)v14)
      {
        if (cmyk64_cacheColorCount > 6)
        {
          *v15 = 0;
        }
        else
        {
LABEL_14:
          v16 = (char *)cmyk64_cacheColorBase;
          if (cmyk64_cacheColorBase)
          {
            v17 = cmyk64_cacheColorCount;
          }
          else
          {
            v16 = (char *)malloc_type_calloc(1uLL, 0x70E0uLL, 0x102004053D502F9uLL);
            v17 = 0;
            cmyk64_cacheColorBase = (uint64_t)v16;
          }
          v14 = (uint64_t)&v16[32 * v17];
          *(_QWORD *)(v14 + 8) = &v16[4096 * (unint64_t)v17 + 224];
          cmyk64_cacheColorCount = v17 + 1;
        }
        v18 = 0;
        *(_QWORD *)v14 = cmyk64_cacheColor;
        cmyk64_cacheColor = v14;
        *(_QWORD *)(v14 + 16) = v9;
        *(_WORD *)(v14 + 24) = v6;
        *(_DWORD *)(v14 + 26) = 0;
        *(_WORD *)(v14 + 30) = 0;
        v20 = *(_QWORD *)(v14 + 8);
        v12 = v14 + 8;
        v19 = v20;
        v21 = vdupq_n_s32((unsigned __int16)v9);
        v22 = vdupq_n_s32(WORD1(v9));
        v23 = vdupq_n_s32(WORD2(v9));
        v24 = vdupq_n_s32(HIWORD(v9));
        v25 = vdupq_n_s32(v6);
        v26 = vdupq_n_s32(v9);
        v27 = vdupq_n_s32(HIDWORD(v9));
        v28 = (int32x4_t)xmmword_185004E20;
        v29 = (int32x4_t)xmmword_185004DC0;
        v30.i64[0] = 0xFFFF0000FFFFLL;
        v30.i64[1] = 0xFFFF0000FFFFLL;
        v31 = vdupq_n_s16(v6);
        v32.i64[0] = 0x800000008;
        v32.i64[1] = 0x800000008;
        v33 = vdupq_n_s32(0x101u);
        do
        {
          v34 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v28, v33), v30);
          v35 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v29, v33), v30);
          v36 = (int8x16_t)vmulq_s32(v35, v21);
          v37 = (int8x16_t)vmulq_s32(v34, v21);
          v38 = (int8x16_t)vmulq_s32(v34, v22);
          v39 = (int8x16_t)vmulq_s32(v35, v22);
          v40 = (int8x16_t)vmulq_s32(v34, v23);
          v41 = (int8x16_t)vmulq_s32(v35, v23);
          v42 = (int8x16_t)vmulq_s32(v35, v24);
          v43 = (int8x16_t)vmulq_s32(v34, v24);
          v44 = (int8x16_t)vmulq_s32(v35, v25);
          v45 = (int8x16_t)vmulq_s32(v34, v25);
          v46 = v19 + v18;
          v47 = vsubq_s32(v24, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x10uLL), (int32x4_t)vmvnq_s8(v42)), 0x10uLL));
          v48 = vsubq_s32(v24, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x10uLL), (int32x4_t)vmvnq_s8(v43)), 0x10uLL));
          v49.i64[0] = v48.u32[2];
          v49.i64[1] = v48.u32[3];
          v50 = (int64x2_t)v49;
          v49.i64[0] = v48.u32[0];
          v49.i64[1] = v48.u32[1];
          v51 = (int64x2_t)v49;
          v49.i64[0] = v47.u32[2];
          v49.i64[1] = v47.u32[3];
          v52 = (int64x2_t)v49;
          v49.i64[0] = v47.u32[0];
          v49.i64[1] = v47.u32[1];
          _Q28 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v41, 0x10uLL), (int32x4_t)vmvnq_s8(v41)), 0x10uLL)), v30);
          _Q27 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x10uLL), (int32x4_t)vmvnq_s8(v40)), 0x10uLL)), v30);
          v55 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q28.i8, 0x20uLL);
          __asm { SHLL2           V28.2D, V28.4S, #0x20 ; ' ' }
          v60 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q27.i8, 0x20uLL);
          __asm { SHLL2           V27.2D, V27.4S, #0x20 ; ' ' }
          v61 = vorrq_s8((int8x16_t)vshlq_n_s64(v50, 0x30uLL), _Q27);
          v62 = vorrq_s8((int8x16_t)vshlq_n_s64(v51, 0x30uLL), v60);
          v63 = vorrq_s8((int8x16_t)vshlq_n_s64(v52, 0x30uLL), _Q28);
          v64 = vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v49, 0x30uLL), v55);
          v65 = vshlq_n_s32(vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x10uLL), (int32x4_t)vmvnq_s8(v39)), 0x10uLL)), 0x10uLL);
          v66 = vshlq_n_s32(vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x10uLL), (int32x4_t)vmvnq_s8(v38)), 0x10uLL)), 0x10uLL);
          v49.i64[0] = v66.u32[2];
          v49.i64[1] = v66.u32[3];
          v67 = v49;
          v49.i64[0] = v66.u32[0];
          v49.i64[1] = v66.u32[1];
          v68 = v49;
          v49.i64[0] = v65.u32[2];
          v49.i64[1] = v65.u32[3];
          v69 = v49;
          v49.i64[0] = v65.u32[0];
          v49.i64[1] = v65.u32[1];
          v70 = v49;
          v71 = vandq_s8((int8x16_t)vsubq_s32(v26, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x10uLL), (int32x4_t)vmvnq_s8(v37)), 0x10uLL)), v30);
          v72 = vandq_s8((int8x16_t)vsubq_s32(v26, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x10uLL), (int32x4_t)vmvnq_s8(v36)), 0x10uLL)), v30);
          v49.i64[0] = v72.u32[0];
          v49.i64[1] = v72.u32[1];
          v73 = v49;
          v49.i64[0] = v72.u32[2];
          v49.i64[1] = v72.u32[3];
          v74 = v49;
          v49.i64[0] = v71.u32[0];
          v49.i64[1] = v71.u32[1];
          v75 = v49;
          v49.i64[0] = v71.u32[2];
          v49.i64[1] = v71.u32[3];
          v76 = vorrq_s8(v64, vorrq_s8(v70, v73));
          *(_QWORD *)v46 = v76.i64[0];
          v77 = vorrq_s8(v63, vorrq_s8(v69, v74));
          *(_QWORD *)(v46 + 32) = v77.i64[0];
          v78 = vorrq_s8(v62, vorrq_s8(v68, v75));
          *(_QWORD *)(v46 + 64) = v78.i64[0];
          v79 = vorrq_s8(v61, vorrq_s8(v67, v49));
          *(_QWORD *)(v46 + 96) = v79.i64[0];
          v80 = vsubq_s16(v31, vsubhn_high_s32(vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v44, 0x10uLL), (int32x4_t)vmvnq_s8(v44)), (int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x10uLL), (int32x4_t)vmvnq_s8(v45)));
          *(_WORD *)(v46 + 8) = v80.i16[0];
          *(_QWORD *)(v19 + v18 + 16) = v76.i64[1];
          *(_QWORD *)(v19 + v18 + 48) = v77.i64[1];
          *(_QWORD *)(v19 + v18 + 80) = v78.i64[1];
          *(_QWORD *)(v19 + v18 + 112) = v79.i64[1];
          *(_WORD *)(v19 + v18 + 24) = v80.i16[1];
          *(_WORD *)(v19 + v18 + 40) = v80.i16[2];
          *(_WORD *)(v19 + v18 + 56) = v80.i16[3];
          *(_WORD *)(v19 + v18 + 72) = v80.i16[4];
          *(_WORD *)(v19 + v18 + 88) = v80.i16[5];
          *(_WORD *)(v19 + v18 + 104) = v80.i16[6];
          *(_WORD *)(v19 + v18 + 120) = v80.i16[7];
          v29 = vaddq_s32(v29, v32);
          v18 += 128;
          v28 = vaddq_s32(v28, v32);
        }
        while (v18 != 4096);
        result = pthread_mutex_unlock(&cmyk64_cacheColorLock);
        goto LABEL_25;
      }
    }
    if (v13)
    {
      *v13 = *(_QWORD *)v10;
      *(_QWORD *)v10 = cmyk64_cacheColor;
      cmyk64_cacheColor = v10;
    }
  }
  result = pthread_mutex_unlock(&cmyk64_cacheColorLock);
  v12 = v10 + 8;
LABEL_25:
  v81 = a2;
  v83 = *(int *)(a1 + 12);
  v82 = *(int *)(a1 + 16);
  if (v3)
  {
    v84 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v85 = (unsigned __int16 *)(v3 + 2 * (v83 + v84 * v82));
    v86 = 1;
    if (!v8)
      return result;
  }
  else
  {
    v85 = 0;
    v84 = 0;
    v86 = 0;
    if (!v8)
      return result;
  }
  v87 = v84 - v385;
  if (v3)
    v88 = v84 - v385;
  else
    v88 = v84;
  v89 = *(_QWORD *)v12;
  v90 = *(unsigned __int16 *)(*(_QWORD *)v12 + 4088);
  v91 = *(_QWORD *)(*(_QWORD *)v12 + 4080);
  v92 = (int8x8_t *)(v379 + 8 * (v83 + (v375 >> 3) * v82));
  v93 = *(int *)(a1 + 124);
  v94 = v8 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v93;
  v380 = v93 - v385;
  v95 = (v375 >> 3) - v385;
  switch(v81)
  {
    case 0:
      if (v3)
      {
        v96 = 2 * v86;
        do
        {
          v97 = v385;
          do
          {
            v98 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v98 == 255)
              {
                LOWORD(v99) = 0;
                *v92 = 0;
              }
              else
              {
                v100 = *v85;
                v101 = (v98 ^ 0xFF | ((v98 ^ 0xFF) << 8)) ^ 0xFFFF;
                v102 = vdup_n_s32(v101);
                v103 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v102);
                v104.i32[0] = HIWORD(v92->u32[0]);
                v104.i32[1] = HIWORD(*(unint64_t *)v92);
                v105 = (uint32x2_t)vmul_s32(v104, v102);
                *v92 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v92, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v103, v103, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v104, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v105, v105, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                v99 = v100 - ((v101 * v100 + ((v101 * v100) >> 16) + 1) >> 16);
              }
              *v85 = v99;
            }
            ++v94;
            ++v92;
            v85 = (unsigned __int16 *)((char *)v85 + v96);
            --v97;
          }
          while (v97);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v269 = v385;
          do
          {
            v270 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v270 == 255)
              {
                *v92 = 0;
              }
              else
              {
                v271 = (int32x2_t)*v92;
                v272.i32[0] = vshl_u32((uint32x2_t)*v92, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v273.i32[0] = v272.i32[0];
                v273.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v92);
                v274 = vdup_n_s32((v270 ^ 0xFF | ((v270 ^ 0xFF) << 8)) ^ 0xFFFFu);
                v275 = (uint32x2_t)vmul_s32(v273, v274);
                v276.i32[0] = v92->u16[0];
                v276.i32[1] = HIWORD(*(unint64_t *)v92);
                v277 = (uint32x2_t)vmul_s32(v276, v274);
                v272.i32[1] = HIDWORD(*(unint64_t *)v92);
                v278 = (uint32x2_t)vsub_s32(v272, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v275, v275, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v271.i32[1] = v276.i32[1];
                v279 = vsub_s32(v271, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v277, v277, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v280 = (int8x8_t)vshl_n_s32(v279, 0x10uLL);
                v279.i16[1] = 0;
                v279.i32[1] = v280.i32[1];
                v280.i32[0] = vshl_u32(v278, (uint32x2_t)0xFFFF00000010).u32[0];
                v280.i32[1] = v278.u16[2];
                *v92 = vorr_s8(v280, (int8x8_t)v279);
              }
            }
            ++v94;
            ++v92;
            --v269;
          }
          while (v269);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 1:
      v106 = v94 & 3;
      if (v3)
      {
        v107 = v106 + v385;
        v108 = &v92[-(v94 & 3)];
        v109 = &v85[-(v94 & 3)];
        if ((v94 & 3) != 0)
          v110 = v94 & 0xFC;
        else
          v110 = v94;
        if ((v94 & 3) != 0)
          result = (-1 << (8 * v106));
        else
          result = 0xFFFFFFFFLL;
        if ((v94 & 3) != 0)
        {
          v94 &= 0xFFFFFFFFFFFFFFFCLL;
          v85 = v109;
          v92 = v108;
        }
        else
        {
          v107 = v385;
        }
        if ((((_BYTE)v107 + v110) & 3) != 0)
        {
          v111 = 4 - (((_BYTE)v107 + v110) & 3);
          v106 += v111;
          v112 = 0xFFFFFFFF >> (8 * v111);
          if (v107 >= 4)
            v113 = 0xFFFFFFFF >> (8 * v111);
          else
            v113 = 0;
          v386 = v113;
          if (v107 >= 4)
            v112 = -1;
          result = v112 & result;
          v376 = result;
        }
        else
        {
          v376 = result;
          v386 = 0;
        }
        v381 = v380 - v106;
        v373 = v95 - v106;
        v370 = v107 >> 2;
        v327 = vdup_n_s16(v90);
        v368 = v87 - v106;
        do
        {
          v328 = *(_DWORD *)v94 & v376;
          v329 = v370;
          v330 = v386;
          if (!v328)
            goto LABEL_442;
LABEL_424:
          if (v328 == -1)
          {
            *v92 = (int8x8_t)v91;
            v92[1] = (int8x8_t)v91;
            v92[2] = (int8x8_t)v91;
            v92[3] = (int8x8_t)v91;
            *(int16x4_t *)v85 = v327;
            goto LABEL_442;
          }
          while (1)
          {
            if ((_BYTE)v328)
            {
              if (v328 == 255)
              {
                *v92 = (int8x8_t)v91;
                *v85 = v90;
              }
              else
              {
                cmyk64_DAplusDAM(v92, v85, *(_QWORD *)(v89 + 16 * v328), *(_WORD *)(v89 + 16 * v328 + 8), (unint64_t)*v92, *v85, (v328 | (v328 << 8)) ^ 0xFFFF);
              }
            }
            if (BYTE1(v328))
            {
              v331 = (uint64_t *)&v92[1];
              v332 = v85 + 1;
              if (BYTE1(v328) == 255)
              {
                *v331 = v91;
                *v332 = v90;
              }
              else
              {
                cmyk64_DAplusDAM(v331, v332, *(_QWORD *)(v89 + 16 * BYTE1(v328)), *(_WORD *)(v89 + 16 * BYTE1(v328) + 8), *v331, *v332, (BYTE1(v328) | (BYTE1(v328) << 8)) ^ 0xFFFF);
              }
            }
            if (BYTE2(v328))
            {
              v333 = (uint64_t *)&v92[2];
              v334 = v85 + 2;
              if (BYTE2(v328) == 255)
              {
                *v333 = v91;
                *v334 = v90;
              }
              else
              {
                cmyk64_DAplusDAM(v333, v334, *(_QWORD *)(v89 + 16 * BYTE2(v328)), *(_WORD *)(v89 + 16 * BYTE2(v328) + 8), *v333, *v334, (BYTE2(v328) | (BYTE2(v328) << 8)) ^ 0xFFFF);
              }
            }
            result = (unint64_t)&v92[3];
            v335 = v85 + 3;
            v336 = HIBYTE(v328);
            if (HIBYTE(v328) == 255)
            {
              *(_QWORD *)result = v91;
              *v335 = v90;
            }
            else if (v336)
            {
              result = (unint64_t)cmyk64_DAplusDAM((_QWORD *)result, v335, *(_QWORD *)(v89 + 16 * v336), *(_WORD *)(v89 + 16 * v336 + 8), *(_QWORD *)result, *v335, (__PAIR64__(v336, v328) >> 24) ^ 0xFFFF);
            }
LABEL_442:
            while (1)
            {
              v337 = v329;
              v92 += 4;
              v85 += 4;
              --v329;
              v94 += 4;
              if (v337 < 2)
                break;
              v328 = *(_DWORD *)v94;
              if (*(_DWORD *)v94)
                goto LABEL_424;
            }
            if (!v330)
              break;
            v330 = 0;
            v328 = *(_DWORD *)v94 & v386;
          }
          v94 += v381;
          v92 += v373;
          v85 += v368;
          --v7;
        }
        while (v7);
      }
      else
      {
        v281 = (v375 >> 3) - v385;
        v282 = v106 + v385;
        if ((v94 & 3) != 0)
          v283 = v94 & 0xFC;
        else
          v283 = v94;
        if ((v94 & 3) != 0)
          v284 = -1 << (8 * v106);
        else
          v284 = -1;
        if ((v94 & 3) != 0)
          v285 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
        else
          v285 = (unsigned int *)v94;
        if ((v94 & 3) != 0)
          v92 -= v94 & 3;
        else
          v282 = v385;
        if ((((_BYTE)v282 + v283) & 3) != 0)
        {
          v286 = 4 - (((_BYTE)v282 + v283) & 3);
          v106 += v286;
          v287 = 0xFFFFFFFF >> (8 * v286);
          if (v282 >= 4)
            v288 = 0xFFFFFFFF >> (8 * v286);
          else
            v288 = 0;
          if (v282 >= 4)
            v287 = -1;
          v388 = v287 & v284;
        }
        else
        {
          v388 = v284;
          v288 = 0;
        }
        v350 = v282 >> 2;
        v378 = v281 - v106;
        v383 = v380 - v106;
        do
        {
          v351 = *v285 & v388;
          v352 = v350;
          v353 = v288;
          if (!v351)
            goto LABEL_491;
LABEL_473:
          if (v351 == -1)
          {
            *v92 = (int8x8_t)v91;
            v92[1] = (int8x8_t)v91;
            v92[2] = (int8x8_t)v91;
            v92[3] = (int8x8_t)v91;
            goto LABEL_491;
          }
          while (1)
          {
            if ((_BYTE)v351)
            {
              if (v351 == 255)
                *v92 = (int8x8_t)v91;
              else
                cmyk64_DplusDM(v92, *(_QWORD *)(v89 + 16 * v351), (unint64_t)*v92, (v351 | (v351 << 8)) ^ 0xFFFF);
            }
            if (BYTE1(v351))
            {
              v354 = (uint64_t *)&v92[1];
              if (BYTE1(v351) == 255)
                *v354 = v91;
              else
                cmyk64_DplusDM(v354, *(_QWORD *)(v89 + 16 * BYTE1(v351)), *v354, (BYTE1(v351) | (BYTE1(v351) << 8)) ^ 0xFFFF);
            }
            if (BYTE2(v351))
            {
              v355 = (uint64_t *)&v92[2];
              if (BYTE2(v351) == 255)
                *v355 = v91;
              else
                cmyk64_DplusDM(v355, *(_QWORD *)(v89 + 16 * BYTE2(v351)), *v355, (BYTE2(v351) | (BYTE2(v351) << 8)) ^ 0xFFFF);
            }
            result = (unint64_t)&v92[3];
            if (HIBYTE(v351) == 255)
            {
              *(_QWORD *)result = v91;
            }
            else if (HIBYTE(v351))
            {
              result = (unint64_t)cmyk64_DplusDM((_QWORD *)result, *(_QWORD *)(v89 + 16 * HIBYTE(v351)), *(_QWORD *)result, (__PAIR64__(HIBYTE(v351), v351) >> 24) ^ 0xFFFF);
            }
LABEL_491:
            while (1)
            {
              v356 = v352;
              v92 += 4;
              --v352;
              ++v285;
              if (v356 < 2)
                break;
              v351 = *v285;
              if (*v285)
                goto LABEL_473;
            }
            if (!v353)
              break;
            v353 = 0;
            v351 = *v285 & v288;
          }
          v285 = (unsigned int *)((char *)v285 + v383);
          v92 += v378;
          --v7;
        }
        while (v7);
      }
      return result;
    case 2:
      v377 = ~(_WORD)v90;
      v114 = v94 & 3;
      if (!v3)
      {
        v289 = v114 + v385;
        v290 = &v92[-(v94 & 3)];
        if ((v94 & 3) != 0)
          v291 = v94 & 0xFC;
        else
          v291 = v94;
        if ((v94 & 3) != 0)
          v292 = -1 << (8 * v114);
        else
          v292 = -1;
        if ((v94 & 3) != 0)
        {
          v94 &= 0xFFFFFFFFFFFFFFFCLL;
          v92 = v290;
        }
        else
        {
          v289 = v385;
        }
        if ((((_BYTE)v289 + v291) & 3) != 0)
        {
          v293 = 4 - (((_BYTE)v289 + v291) & 3);
          v114 += v293;
          v294 = 0xFFFFFFFF >> (8 * v293);
          if (v289 >= 4)
            v295 = -1;
          else
            v295 = 0xFFFFFFFF >> (8 * v293);
          v389 = v295 & v292;
          if (v289 >= 4)
            v296 = v294;
          else
            v296 = 0;
        }
        else
        {
          v389 = v292;
          v296 = 0;
        }
        v384 = v380 - v114;
        v357 = v289 >> 2;
        v374 = v95 - v114;
        while (1)
        {
          v358 = *(_DWORD *)v94 & v389;
          v359 = v296;
          v360 = v357;
          if (!v358)
            goto LABEL_512;
LABEL_501:
          if (v358 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v358)
              result = (unint64_t)cmyk64_DplusDM(v92, *(_QWORD *)(v89 + 16 * v358), (unint64_t)*v92, *(unsigned __int16 *)(v89 + 16 * v358 + 8) ^ 0xFFFFu);
            if ((v358 & 0xFF00) != 0)
              result = (unint64_t)cmyk64_DplusDM(&v92[1], *(_QWORD *)(v89 + 16 * BYTE1(v358)), *(_QWORD *)&v92[1], *(unsigned __int16 *)(v89 + 16 * BYTE1(v358) + 8) ^ 0xFFFFu);
            if ((v358 & 0xFF0000) != 0)
              result = (unint64_t)cmyk64_DplusDM(&v92[2], *(_QWORD *)(v89 + 16 * BYTE2(v358)), *(_QWORD *)&v92[2], *(unsigned __int16 *)(v89 + 16 * BYTE2(v358) + 8) ^ 0xFFFFu);
            if (HIBYTE(v358))
            {
              v365 = v89 + 16 * HIBYTE(v358);
              v363 = *(_QWORD *)v365;
              v361 = v92 + 3;
              v362 = (unint64_t)v92[3];
              v364 = *(unsigned __int16 *)(v365 + 8) ^ 0xFFFF;
              goto LABEL_511;
            }
LABEL_512:
            while (1)
            {
              v366 = v360;
              v92 += 4;
              --v360;
              v94 += 4;
              if (v366 < 2)
                break;
              v358 = *(_DWORD *)v94;
              if (*(_DWORD *)v94)
                goto LABEL_501;
            }
            if (!v359)
              break;
            v359 = 0;
            v358 = *(_DWORD *)v94 & v296;
          }
          v94 += v384;
          v92 += v374;
          if (!--v7)
            return result;
        }
        cmyk64_DplusDM(v92, v91, (unint64_t)*v92, v377);
        cmyk64_DplusDM(&v92[1], v91, *(_QWORD *)&v92[1], v377);
        cmyk64_DplusDM(&v92[2], v91, *(_QWORD *)&v92[2], v377);
        v361 = v92 + 3;
        v362 = (unint64_t)v92[3];
        v363 = v91;
        v364 = v377;
LABEL_511:
        result = (unint64_t)cmyk64_DplusDM(v361, v363, v362, v364);
        goto LABEL_512;
      }
      v115 = v114 + v385;
      if ((v94 & 3) != 0)
        v116 = v94 & 0xFC;
      else
        v116 = v94;
      if ((v94 & 3) != 0)
        result = (-1 << (8 * v114));
      else
        result = 0xFFFFFFFFLL;
      if ((v94 & 3) != 0)
        v117 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
      else
        v117 = (unsigned int *)v94;
      if ((v94 & 3) != 0)
      {
        v85 -= v94 & 3;
        v92 -= v94 & 3;
      }
      else
      {
        v115 = v385;
      }
      if ((((_BYTE)v115 + v116) & 3) != 0)
      {
        v118 = 4 - (((_BYTE)v115 + v116) & 3);
        v114 += v118;
        v119 = 0xFFFFFFFF >> (8 * v118);
        if (v115 >= 4)
          v120 = -1;
        else
          v120 = 0xFFFFFFFF >> (8 * v118);
        result = v120 & result;
        v372 = result;
        if (v115 < 4)
          v119 = 0;
        v387 = v119;
      }
      else
      {
        v372 = result;
        v387 = 0;
      }
      v382 = v380 - v114;
      v371 = v95 - v114;
      v369 = v115 >> 2;
      v367 = v87 - v114;
      do
      {
        v338 = *v117 & v372;
        v339 = v387;
        v340 = v369;
        if (!v338)
          goto LABEL_463;
LABEL_452:
        if (v338 == -1)
        {
          cmyk64_DAplusDAM(v92, v85, v91, v90, (unint64_t)*v92, *v85, (unsigned __int16)~(_WORD)v90);
          cmyk64_DAplusDAM(&v92[1], v85 + 1, v91, v90, *(_QWORD *)&v92[1], v85[1], (unsigned __int16)~(_WORD)v90);
          cmyk64_DAplusDAM(&v92[2], v85 + 2, v91, v90, *(_QWORD *)&v92[2], v85[2], (unsigned __int16)~(_WORD)v90);
          v341 = v92 + 3;
          v342 = (unint64_t)v92[3];
          v343 = v85 + 3;
          v344 = v85[3];
          v345 = v91;
          LOWORD(v346) = v90;
          v347 = (unsigned __int16)~(_WORD)v90;
LABEL_462:
          result = (unint64_t)cmyk64_DAplusDAM(v341, v343, v345, v346, v342, v344, v347);
          goto LABEL_463;
        }
        while (1)
        {
          if ((_BYTE)v338)
            result = (unint64_t)cmyk64_DAplusDAM(v92, v85, *(_QWORD *)(v89 + 16 * v338), *(_WORD *)(v89 + 16 * v338 + 8), (unint64_t)*v92, *v85, *(unsigned __int16 *)(v89 + 16 * v338 + 8) ^ 0xFFFFu);
          if ((v338 & 0xFF00) != 0)
            result = (unint64_t)cmyk64_DAplusDAM(&v92[1], v85 + 1, *(_QWORD *)(v89 + 16 * BYTE1(v338)), *(_WORD *)(v89 + 16 * BYTE1(v338) + 8), *(_QWORD *)&v92[1], v85[1], *(unsigned __int16 *)(v89 + 16 * BYTE1(v338) + 8) ^ 0xFFFFu);
          if ((v338 & 0xFF0000) != 0)
            result = (unint64_t)cmyk64_DAplusDAM(&v92[2], v85 + 2, *(_QWORD *)(v89 + 16 * BYTE2(v338)), *(_WORD *)(v89 + 16 * BYTE2(v338) + 8), *(_QWORD *)&v92[2], v85[2], *(unsigned __int16 *)(v89 + 16 * BYTE2(v338) + 8) ^ 0xFFFFu);
          if (HIBYTE(v338))
          {
            v348 = v89 + 16 * HIBYTE(v338);
            v345 = *(_QWORD *)v348;
            v346 = *(unsigned __int16 *)(v348 + 8);
            v341 = v92 + 3;
            v342 = (unint64_t)v92[3];
            v343 = v85 + 3;
            v344 = v85[3];
            v347 = v346 ^ 0xFFFF;
            goto LABEL_462;
          }
LABEL_463:
          while (1)
          {
            v349 = v340;
            v92 += 4;
            v85 += 4;
            --v340;
            ++v117;
            if (v349 < 2)
              break;
            v338 = *v117;
            if (*v117)
              goto LABEL_452;
          }
          if (!v339)
            break;
          v339 = 0;
          v338 = *v117 & v387;
        }
        v117 = (unsigned int *)((char *)v117 + v382);
        v92 += v371;
        v85 += v367;
        --v7;
      }
      while (v7);
      return result;
    case 3:
      v121 = 2 * v86;
      do
      {
        v122 = v385;
        do
        {
          v123 = *(unsigned __int8 *)v94;
          if (*(_BYTE *)v94)
          {
            if (v123 == 255)
            {
              v124 = (int8x8_t *)(v89 + (((unint64_t)*v85 >> 4) & 0xFF0));
              v125 = *v124;
              LOWORD(v124) = v124[1].i16[0];
              *v92 = v125;
              *v85 = (unsigned __int16)v124;
            }
            else
            {
              v126 = v123 | (v123 << 8);
              v127 = *v85;
              v128 = v89 + 16 * ((v127 * v126 + ((v127 * v126) >> 16) + 1) >> 24);
              result = (unint64_t)cmyk64_DAplusDAM(v92, v85, *(_QWORD *)v128, *(_WORD *)(v128 + 8), (unint64_t)*v92, v127, v126 ^ 0xFFFFu);
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v121);
          --v122;
        }
        while (v122);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 4:
      v129 = 2 * v86;
      do
      {
        v130 = v385;
        do
        {
          v131 = *(unsigned __int8 *)v94;
          if (*(_BYTE *)v94)
          {
            if (v131 == 255)
            {
              v132 = (int8x8_t *)(v89 + 16 * ((unsigned __int16)~*v85 >> 8));
              v133 = *v132;
              LOWORD(v132) = v132[1].i16[0];
              *v92 = v133;
              *v85 = (unsigned __int16)v132;
            }
            else
            {
              v134 = v131 | (v131 << 8);
              v135 = *v85;
              v136 = v89 + 16 * (((v135 ^ 0xFFFF) * v134 + (((v135 ^ 0xFFFFu) * v134) >> 16) + 1) >> 24);
              result = (unint64_t)cmyk64_DAplusDAM(v92, v85, *(_QWORD *)v136, *(_WORD *)(v136 + 8), (unint64_t)*v92, v135, v134 ^ 0xFFFFu);
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v129);
          --v130;
        }
        while (v130);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 5:
      v137 = 2 * v86;
      do
      {
        v138 = v385;
        do
        {
          if (*(_BYTE *)v94)
            result = (unint64_t)cmyk64_DAMplusDAM((unsigned int *)v92, v85, *(_QWORD *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8), *v85, (unint64_t)*v92, *v85, *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8) ^ 0xFFFFu);
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v137);
          --v138;
        }
        while (v138);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 6:
      v139 = 2 * v86;
      do
      {
        v140 = v95;
        v141 = v385;
        do
        {
          v142 = *(unsigned __int8 *)v94;
          if (*(_BYTE *)v94 && *v85 != 0xFFFF)
          {
            if ((unsigned __int16)~*v85 == 0xFFFF)
            {
              v143 = (int8x8_t *)(v89 + 16 * v142);
              v144 = *v143;
              LOWORD(v143) = v143[1].i16[0];
              *v92 = v144;
              *v85 = (unsigned __int16)v143;
            }
            else
            {
              result = (unint64_t)cmyk64_DAplusDAM(v92, v85, (uint64_t)*v92, *v85, *(_QWORD *)(v89 + 16 * v142), *(unsigned __int16 *)(v89 + 16 * v142 + 8), (unsigned __int16)~*v85);
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v139);
          --v141;
        }
        while (v141);
        v94 += v380;
        v95 = v140;
        v92 += v140;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 7:
      v145 = vdup_n_s32(v90 ^ 0xFFFF);
      if (v3)
      {
        v146 = 2 * v86;
        do
        {
          v147 = v385;
          do
          {
            v148 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v148 == 255)
              {
                v149 = (int32x2_t)*v92;
                v150 = *v85;
                v151 = (v90 ^ 0xFFFF) * v150 + (((v90 ^ 0xFFFF) * v150) >> 16) + 1;
                v152 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v145);
                v153.i32[0] = HIWORD(v92->u32[0]);
                v153.i32[1] = HIWORD(*(unint64_t *)v92);
                v154 = (uint32x2_t)vmul_s32(v153, v145);
              }
              else
              {
                v155 = v148 | (v148 << 8);
                v149 = (int32x2_t)*v92;
                v150 = *v85;
                v156 = (unsigned __int16)(v155 - ((v155 * v90 + ((v155 * v90) >> 16) + 1) >> 16));
                v151 = v156 * v150 + ((v156 * v150) >> 16) + 1;
                v157 = vdup_n_s32(v156);
                v152 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v157);
                v153.i32[0] = HIWORD(v92->u32[0]);
                v153.i32[1] = HIWORD(*(unint64_t *)v92);
                v154 = (uint32x2_t)vmul_s32(v153, v157);
              }
              *v92 = (int8x8_t)vsli_n_s32(vsub_s32(v149, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v152, v152, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v153, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v154, v154, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *v85 = v150 - HIWORD(v151);
            }
            ++v94;
            ++v92;
            v85 = (unsigned __int16 *)((char *)v85 + v146);
            --v147;
          }
          while (v147);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v297 = v385;
          do
          {
            v298 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              v299 = (int32x2_t)*v92;
              v300.i32[0] = vshr_n_u32((uint32x2_t)*v92, 0x10uLL).u32[0];
              v300.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v92);
              if (v298 == 255)
              {
                v301 = (uint32x2_t)vmul_s32(v300, v145);
                v302.i32[0] = v92->u16[0];
                v302.i32[1] = HIWORD(*(unint64_t *)v92);
                v303 = (uint32x2_t)vmul_s32(v302, v145);
                v300.i32[1] = HIDWORD(*(unint64_t *)v92);
                v304 = vsub_s32(v300, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v301, v301, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v299.i32[1] = HIWORD(*(unint64_t *)v92);
                v305 = vsub_s32(v299, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v303, v303, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              else
              {
                v306 = vdup_n_s32((unsigned __int16)((v298 | ((_WORD)v298 << 8))
                                                   - (((v298 | (v298 << 8)) * v90
                                                     + (((v298 | (v298 << 8)) * v90) >> 16)
                                                     + 1) >> 16)));
                v307 = (uint32x2_t)vmul_s32(v300, v306);
                v308.i32[0] = v92->u16[0];
                v308.i32[1] = HIWORD(*(unint64_t *)v92);
                v309 = (uint32x2_t)vmul_s32(v308, v306);
                v300.i32[1] = HIDWORD(*(unint64_t *)v92);
                v304 = vsub_s32(v300, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v307, v307, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v299.i32[1] = v308.i32[1];
                v305 = vsub_s32(v299, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v309, v309, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              v310.i32[0] = v305.u16[0];
              v310.i32[1] = vshl_n_s32(v305, 0x10uLL).i32[1];
              v311.i32[0] = vshl_n_s32(v304, 0x10uLL).u32[0];
              v311.i32[1] = v304.u16[2];
              *v92 = vorr_s8(v311, v310);
            }
            ++v94;
            ++v92;
            --v297;
          }
          while (v297);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 8:
      v158 = 257 * v90;
      v159 = vdup_n_s32(v90);
      if (v3)
      {
        v160 = 2 * v86;
        do
        {
          v161 = v385;
          do
          {
            v162 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              v163 = *v85;
              if (v162 == 255)
              {
                v164 = v90 * v163 + ((v90 * v163) >> 16) + 1;
                v165 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v159);
                v166.i32[0] = HIWORD(v92->u32[0]);
                v166.i32[1] = HIWORD(*(unint64_t *)v92);
                v167 = (uint32x2_t)vmul_s32(v166, v159);
              }
              else
              {
                v168 = (v158 * v162 + ((v158 * v162) >> 16) + 1) >> 16;
                v164 = v168 * v163 + ((v168 * v163) >> 16) + 1;
                v169 = vdup_n_s32(v168);
                v165 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v169);
                v166.i32[0] = HIWORD(v92->u32[0]);
                v166.i32[1] = HIWORD(*(unint64_t *)v92);
                v167 = (uint32x2_t)vmul_s32(v166, v169);
              }
              *v92 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v92, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v165, v165, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v166, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v167, v167, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *v85 = v163 - HIWORD(v164);
            }
            ++v94;
            ++v92;
            v85 = (unsigned __int16 *)((char *)v85 + v160);
            --v161;
          }
          while (v161);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v312 = v385;
          do
          {
            v313 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              v314 = (int32x2_t)*v92;
              v315.i32[0] = vshr_n_u32((uint32x2_t)*v92, 0x10uLL).u32[0];
              v315.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v92);
              if (v313 == 255)
              {
                v316 = (uint32x2_t)vmul_s32(v315, v159);
                v317.i32[0] = v92->u16[0];
                v317.i32[1] = HIWORD(*(unint64_t *)v92);
                v318 = (uint32x2_t)vmul_s32(v317, v159);
                v315.i32[1] = HIDWORD(*(unint64_t *)v92);
                v319 = vsub_s32(v315, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v316, v316, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v314.i32[1] = HIWORD(*(unint64_t *)v92);
                v320 = vsub_s32(v314, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v318, v318, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              else
              {
                v321 = vdup_n_s32((v158 * v313 + ((v158 * v313) >> 16) + 1) >> 16);
                v322 = (uint32x2_t)vmul_s32(v315, v321);
                v323.i32[0] = v92->u16[0];
                v323.i32[1] = HIWORD(*(unint64_t *)v92);
                v324 = (uint32x2_t)vmul_s32(v323, v321);
                v315.i32[1] = HIDWORD(*(unint64_t *)v92);
                v319 = vsub_s32(v315, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v322, v322, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v314.i32[1] = v323.i32[1];
                v320 = vsub_s32(v314, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v324, v324, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              v325.i32[0] = v320.u16[0];
              v325.i32[1] = vshl_n_s32(v320, 0x10uLL).i32[1];
              v326.i32[0] = vshl_n_s32(v319, 0x10uLL).u32[0];
              v326.i32[1] = v319.u16[2];
              *v92 = vorr_s8(v326, v325);
            }
            ++v94;
            ++v92;
            --v312;
          }
          while (v312);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 9:
      v170 = 2 * v86;
      do
      {
        v171 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v172 = *(unsigned __int8 *)v94;
            result = (unint64_t)cmyk64_DAMplusDAM((unsigned int *)v92, v85, *(_QWORD *)(v89 + 16 * v172), *(unsigned __int16 *)(v89 + 16 * v172 + 8), *v85 ^ 0xFFFFu, (unint64_t)*v92, *v85, (unsigned __int16)(*(_WORD *)(v89 + 16 * v172 + 8)+ ~(v172 | ((_WORD)v172 << 8))));
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v170);
          --v171;
        }
        while (v171);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 10:
      v173 = 2 * v86;
      do
      {
        v174 = v385;
        do
        {
          if (*(_BYTE *)v94)
            result = (unint64_t)cmyk64_DAMplusDAM((unsigned int *)v92, v85, *(_QWORD *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8), *v85 ^ 0xFFFFu, (unint64_t)*v92, *v85, *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8) ^ 0xFFFFu);
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v173);
          --v174;
        }
        while (v174);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 11:
      if (v3)
      {
        v175 = 2 * v86;
        do
        {
          v176 = v385;
          do
          {
            if (*(_BYTE *)v94)
              result = (unint64_t)cmyk64_DAplusdDA((int *)v92, (__int16 *)v85, (unint64_t)*v92, *v85, *(_QWORD *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8));
            ++v94;
            ++v92;
            v85 = (unsigned __int16 *)((char *)v85 + v175);
            --v176;
          }
          while (v176);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v177 = v385;
          do
          {
            if (*(_BYTE *)v94)
              result = (unint64_t)cmyk64_DplusdDA((int *)v92, (unint64_t)*v92, *(_QWORD *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8));
            ++v94;
            ++v92;
            --v177;
          }
          while (v177);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 12:
      if (v3)
      {
        v178 = 2 * v86;
        do
        {
          v179 = v385;
          do
          {
            if (*(_BYTE *)v94)
              result = (unint64_t)cmyk64_DApluslDA((unsigned int *)v92, v85, (unint64_t)*v92, *v85, *(_QWORD *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8));
            ++v94;
            ++v92;
            v85 = (unsigned __int16 *)((char *)v85 + v178);
            --v179;
          }
          while (v179);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v180 = v385;
          do
          {
            if (*(_BYTE *)v94)
              result = (unint64_t)cmyk64_DpluslD((unsigned int *)v92, (unint64_t)*v92, *(_QWORD *)(v89 + 16 * *(unsigned __int8 *)v94));
            ++v94;
            ++v92;
            --v180;
          }
          while (v180);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 13:
      v181 = 2 * v86;
      do
      {
        v182 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v183 = v89 + 16 * *(unsigned __int8 *)v94;
            v184 = *(unsigned __int16 *)(v183 + 8);
            if (*(_WORD *)(v183 + 8))
            {
              v185 = *(_QWORD *)v183;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAmultiplyPDA_10646((unint64_t)*v92, *v85, v185, v184);
                  v185 = result;
                  LOWORD(v184) = v186;
                }
                *v92 = (int8x8_t)v185;
                *v85 = v184;
              }
              else
              {
                result = PDAmultiplyPDA_10646((unint64_t)*v92, 0xFFFFu, v185, v184);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v181);
          --v182;
        }
        while (v182);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 14:
      v187 = 2 * v86;
      do
      {
        v188 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v189 = v89 + 16 * *(unsigned __int8 *)v94;
            v190 = *(unsigned __int16 *)(v189 + 8);
            if (*(_WORD *)(v189 + 8))
            {
              v191 = *(_QWORD *)v189;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAscreenPDA_10647((unint64_t)*v92, *v85, v191, v190);
                  v191 = result;
                  LOWORD(v190) = v192;
                }
                *v92 = (int8x8_t)v191;
                *v85 = v190;
              }
              else
              {
                result = PDAscreenPDA_10647((unint64_t)*v92, 0xFFFFu, v191, v190);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v187);
          --v188;
        }
        while (v188);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 15:
      v193 = 2 * v86;
      do
      {
        v194 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v195 = v89 + 16 * *(unsigned __int8 *)v94;
            v196 = *(unsigned __int16 *)(v195 + 8);
            if (*(_WORD *)(v195 + 8))
            {
              v197 = *(_QWORD *)v195;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAoverlayPDA_10648((unint64_t)*v92, *v85, v197, v196);
                  v197 = result;
                  LOWORD(v196) = v198;
                }
                *v92 = (int8x8_t)v197;
                *v85 = v196;
              }
              else
              {
                result = PDAoverlayPDA_10648((unint64_t)*v92, 0xFFFFu, v197, v196);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v193);
          --v194;
        }
        while (v194);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 16:
      v199 = 2 * v86;
      do
      {
        v200 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v201 = v89 + 16 * *(unsigned __int8 *)v94;
            v202 = *(unsigned __int16 *)(v201 + 8);
            if (*(_WORD *)(v201 + 8))
            {
              v203 = *(_QWORD *)v201;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAdarkenPDA_10650((unint64_t)*v92, *v85, v203, v202);
                  v203 = result;
                  LOWORD(v202) = v204;
                }
                *v92 = (int8x8_t)v203;
                *v85 = v202;
              }
              else
              {
                result = PDAdarkenPDA_10650((unint64_t)*v92, 0xFFFFu, v203, v202);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v199);
          --v200;
        }
        while (v200);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 17:
      v205 = 2 * v86;
      do
      {
        v206 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v207 = v89 + 16 * *(unsigned __int8 *)v94;
            v208 = *(unsigned __int16 *)(v207 + 8);
            if (*(_WORD *)(v207 + 8))
            {
              v209 = *(_QWORD *)v207;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAlightenPDA_10649((unint64_t)*v92, *v85, v209, v208);
                  v209 = result;
                  LOWORD(v208) = v210;
                }
                *v92 = (int8x8_t)v209;
                *v85 = v208;
              }
              else
              {
                result = PDAlightenPDA_10649((unint64_t)*v92, 0xFFFFu, v209, v208);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v205);
          --v206;
        }
        while (v206);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 18:
      v211 = 2 * v86;
      do
      {
        v212 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v213 = v89 + 16 * *(unsigned __int8 *)v94;
            v214 = *(unsigned __int16 *)(v213 + 8);
            if (*(_WORD *)(v213 + 8))
            {
              v215 = *(_QWORD *)v213;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAcolordodgePDA_10651((unint64_t)*v92, *v85, v215, v214);
                  v215 = result;
                  LOWORD(v214) = v216;
                }
                *v92 = (int8x8_t)v215;
                *v85 = v214;
              }
              else
              {
                result = PDAcolordodgePDA_10651((unint64_t)*v92, 0xFFFFu, v215, v214);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v211);
          --v212;
        }
        while (v212);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 19:
      v217 = 2 * v86;
      do
      {
        v218 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v219 = v89 + 16 * *(unsigned __int8 *)v94;
            v220 = *(unsigned __int16 *)(v219 + 8);
            if (*(_WORD *)(v219 + 8))
            {
              v221 = *(_QWORD *)v219;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAcolorburnPDA_10652((unint64_t)*v92, *v85, v221, v220);
                  v221 = result;
                  LOWORD(v220) = v222;
                }
                *v92 = (int8x8_t)v221;
                *v85 = v220;
              }
              else
              {
                result = PDAcolorburnPDA_10652((unint64_t)*v92, 0xFFFFu, v221, v220);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v217);
          --v218;
        }
        while (v218);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 20:
      v223 = 2 * v86;
      do
      {
        v224 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v225 = v89 + 16 * *(unsigned __int8 *)v94;
            v226 = *(unsigned __int16 *)(v225 + 8);
            if (*(_WORD *)(v225 + 8))
            {
              v227 = *(_QWORD *)v225;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAsoftlightPDA_10654((unint64_t)*v92, *v85, v227, v226);
                  v227 = result;
                  LOWORD(v226) = v228;
                }
                *v92 = (int8x8_t)v227;
                *v85 = v226;
              }
              else
              {
                result = PDAsoftlightPDA_10654((unint64_t)*v92, 0xFFFFu, v227, v226);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v223);
          --v224;
        }
        while (v224);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 21:
      v229 = 2 * v86;
      do
      {
        v230 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v231 = v89 + 16 * *(unsigned __int8 *)v94;
            v232 = *(unsigned __int16 *)(v231 + 8);
            if (*(_WORD *)(v231 + 8))
            {
              v233 = *(_QWORD *)v231;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAhardlightPDA_10653((unint64_t)*v92, *v85, v233, v232);
                  v233 = result;
                  LOWORD(v232) = v234;
                }
                *v92 = (int8x8_t)v233;
                *v85 = v232;
              }
              else
              {
                result = PDAhardlightPDA_10653((unint64_t)*v92, 0xFFFFu, v233, v232);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v229);
          --v230;
        }
        while (v230);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 22:
      v235 = 2 * v86;
      do
      {
        v236 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v237 = v89 + 16 * *(unsigned __int8 *)v94;
            v238 = *(unsigned __int16 *)(v237 + 8);
            if (*(_WORD *)(v237 + 8))
            {
              v239 = *(_QWORD *)v237;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAdifferencePDA_10655((unint64_t)*v92, *v85, v239, v238);
                  v239 = result;
                  LOWORD(v238) = v240;
                }
                *v92 = (int8x8_t)v239;
                *v85 = v238;
              }
              else
              {
                result = PDAdifferencePDA_10655((unint64_t)*v92, 0xFFFFu, v239, v238);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v235);
          --v236;
        }
        while (v236);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 23:
      v241 = 2 * v86;
      do
      {
        v242 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v243 = v89 + 16 * *(unsigned __int8 *)v94;
            v244 = *(unsigned __int16 *)(v243 + 8);
            if (*(_WORD *)(v243 + 8))
            {
              v245 = *(_QWORD *)v243;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAexclusionPDA_10656((unint64_t)*v92, *v85, v245, v244);
                  v245 = result;
                  LOWORD(v244) = v246;
                }
                *v92 = (int8x8_t)v245;
                *v85 = v244;
              }
              else
              {
                result = PDAexclusionPDA_10656((unint64_t)*v92, 0xFFFFu, v245, v244);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v241);
          --v242;
        }
        while (v242);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 24:
      v247 = 2 * v86;
      do
      {
        v248 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v249 = v89 + 16 * *(unsigned __int8 *)v94;
            v250 = *(unsigned __int16 *)(v249 + 8);
            if (*(_WORD *)(v249 + 8))
            {
              v251 = *(_QWORD *)v249;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAhuePDA_10657((unint64_t)*v92, *v85, v251, v250);
                  v251 = result;
                  LOWORD(v250) = v252;
                }
                *v92 = (int8x8_t)v251;
                *v85 = v250;
              }
              else
              {
                result = PDAhuePDA_10657((unint64_t)*v92, 0xFFFFu, v251, v250);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v247);
          --v248;
        }
        while (v248);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 25:
      v253 = 2 * v86;
      do
      {
        v254 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v255 = v89 + 16 * *(unsigned __int8 *)v94;
            v256 = *(unsigned __int16 *)(v255 + 8);
            if (*(_WORD *)(v255 + 8))
            {
              v257 = *(_QWORD *)v255;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAsaturationPDA_10658((unint64_t)*v92, *v85, v257, v256);
                  v257 = result;
                  LOWORD(v256) = v258;
                }
                *v92 = (int8x8_t)v257;
                *v85 = v256;
              }
              else
              {
                result = PDAsaturationPDA_10658((unint64_t)*v92, 0xFFFFu, v257, v256);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v253);
          --v254;
        }
        while (v254);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 26:
      v259 = 2 * v86;
      do
      {
        v260 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v261 = v89 + 16 * *(unsigned __int8 *)v94;
            v262 = *(unsigned __int16 *)(v261 + 8);
            if (*(_WORD *)(v261 + 8))
            {
              result = *(_QWORD *)v261;
              if (v3)
              {
                if (*v85)
                  result = PDAluminosityPDA_10659(result, v262, (unint64_t)*v92, *v85);
                *v92 = (int8x8_t)result;
                *v85 = v262;
              }
              else
              {
                result = PDAluminosityPDA_10659(result, v262, (unint64_t)*v92, 0xFFFFu);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v259);
          --v260;
        }
        while (v260);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 27:
      v263 = 2 * v86;
      do
      {
        v264 = v385;
        do
        {
          if (*(_BYTE *)v94)
          {
            v265 = v89 + 16 * *(unsigned __int8 *)v94;
            v266 = *(unsigned __int16 *)(v265 + 8);
            if (*(_WORD *)(v265 + 8))
            {
              v267 = *(_QWORD *)v265;
              if (v3)
              {
                if (*v85)
                {
                  result = PDAluminosityPDA_10659((unint64_t)*v92, *v85, v267, v266);
                  v267 = result;
                  LOWORD(v266) = v268;
                }
                *v92 = (int8x8_t)v267;
                *v85 = v266;
              }
              else
              {
                result = PDAluminosityPDA_10659((unint64_t)*v92, 0xFFFFu, v267, v266);
                *v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          v85 = (unsigned __int16 *)((char *)v85 + v263);
          --v264;
        }
        while (v264);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    default:
      return result;
  }
}

uint64_t cmyk64_mark_pixelmask(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __int16 *v7;
  int v8;
  int v9;
  int v10;
  __int16 *v11;
  unint64_t v12;
  unint64_t v13;
  int8x8_t *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  unint64_t *v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  unint64_t *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int32x2_t v35;
  uint32x2_t v36;
  int32x2_t v37;
  uint32x2_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int16 *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  unint64_t *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  uint64_t v64;
  unint64_t v65;
  int v66;
  int v67;
  unint64_t *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int16 *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  int32x2_t v84;
  uint32x2_t v85;
  int32x2_t v86;
  uint32x2_t v87;
  unint64_t *v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned __int16 *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  int v101;
  int v102;
  unsigned int v103;
  int32x2_t v104;
  uint32x2_t v105;
  int32x2_t v106;
  uint32x2_t v107;
  unint64_t *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unsigned __int16 *v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  int v118;
  unsigned int v119;
  unint64_t v120;
  unsigned int v121;
  unint64_t v122;
  unint64_t *v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unsigned __int16 *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  int v136;
  int v137;
  unsigned int v138;
  int32x2_t v139;
  uint32x2_t v140;
  int32x2_t v141;
  uint32x2_t v142;
  unint64_t *v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unsigned __int16 *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  int v154;
  int v155;
  int v156;
  unsigned int v157;
  int32x2_t v158;
  uint32x2_t v159;
  int32x2_t v160;
  uint32x2_t v161;
  uint64_t v162;
  uint64_t v163;
  unint64_t *v164;
  uint64_t v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unsigned __int16 *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  int v177;
  __int16 *v178;
  int v179;
  int32x2_t v180;
  int v181;
  unsigned int v182;
  int32x2_t v183;
  uint32x2_t v184;
  int32x2_t v185;
  uint32x2_t v186;
  unint64_t *v187;
  unsigned __int16 *v188;
  unint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unsigned __int16 *v193;
  uint64_t v194;
  uint64_t v195;
  int v196;
  unint64_t v197;
  unsigned __int16 v198;
  int v199;
  unsigned int v200;
  unint64_t v201;
  unsigned int v202;
  unint64_t *v203;
  uint64_t v204;
  unint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unsigned __int16 *v209;
  uint64_t v210;
  uint64_t v211;
  int v212;
  unint64_t v213;
  int v214;
  unsigned int v215;
  unint64_t v216;
  unsigned int v217;
  unint64_t *v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  unsigned __int16 *v224;
  uint64_t v225;
  int v226;
  unint64_t v227;
  int v228;
  int v229;
  unsigned int v230;
  unint64_t *v231;
  uint64_t v232;
  unint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  unsigned __int16 *v237;
  uint64_t v238;
  int v239;
  unint64_t v240;
  int v241;
  int v242;
  unsigned int v243;
  unint64_t *v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  unsigned __int16 *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  int v255;
  int v256;
  int v257;
  unsigned int v258;
  __int16 v259;
  unint64_t v260;
  unsigned int v261;
  unint64_t v262;
  unint64_t *v263;
  uint64_t v264;
  unint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  unsigned __int16 *v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  int v274;
  int v275;
  int v276;
  unsigned int v277;
  __int16 v278;
  unint64_t v279;
  unsigned int v280;
  unint64_t v281;
  unint64_t *v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  unsigned __int16 *v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  int v293;
  int v294;
  int v295;
  unsigned int v296;
  __int16 v297;
  unint64_t v298;
  unsigned int v299;
  unint64_t v300;
  unint64_t *v301;
  uint64_t v302;
  unint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  unsigned __int16 *v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  int v312;
  int v313;
  int v314;
  unsigned int v315;
  __int16 v316;
  unint64_t v317;
  unsigned int v318;
  unint64_t v319;
  unint64_t *v320;
  uint64_t v321;
  unint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  unsigned __int16 *v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  int v331;
  int v332;
  int v333;
  unsigned int v334;
  __int16 v335;
  unint64_t v336;
  unsigned int v337;
  unint64_t v338;
  unint64_t *v339;
  uint64_t v340;
  unint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  unsigned __int16 *v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  int v350;
  int v351;
  int v352;
  unsigned int v353;
  __int16 v354;
  unint64_t v355;
  unsigned int v356;
  unint64_t v357;
  unint64_t *v358;
  uint64_t v359;
  unint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  unsigned __int16 *v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  int v369;
  int v370;
  int v371;
  unsigned int v372;
  __int16 v373;
  unint64_t v374;
  unsigned int v375;
  unint64_t v376;
  unint64_t *v377;
  uint64_t v378;
  unint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  unsigned __int16 *v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  int v388;
  int v389;
  int v390;
  unsigned int v391;
  __int16 v392;
  unint64_t v393;
  unsigned int v394;
  unint64_t v395;
  unint64_t *v396;
  uint64_t v397;
  unint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  unsigned __int16 *v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  int v407;
  int v408;
  int v409;
  unsigned int v410;
  __int16 v411;
  unint64_t v412;
  unsigned int v413;
  unint64_t v414;
  unint64_t *v415;
  uint64_t v416;
  unint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  unsigned __int16 *v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  int v426;
  int v427;
  int v428;
  unsigned int v429;
  __int16 v430;
  unint64_t v431;
  unsigned int v432;
  unint64_t v433;
  unint64_t *v434;
  uint64_t v435;
  unint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  unsigned __int16 *v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  int v445;
  int v446;
  int v447;
  unsigned int v448;
  __int16 v449;
  unint64_t v450;
  unsigned int v451;
  unint64_t v452;
  unint64_t *v453;
  uint64_t v454;
  unint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  unsigned __int16 *v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  int v464;
  int v465;
  int v466;
  unsigned int v467;
  __int16 v468;
  unint64_t v469;
  unsigned int v470;
  unint64_t v471;
  unint64_t *v472;
  uint64_t v473;
  unint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  unsigned __int16 *v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  int v483;
  int v484;
  int v485;
  unsigned int v486;
  __int16 v487;
  unint64_t v488;
  unsigned int v489;
  unint64_t v490;
  unint64_t *v491;
  uint64_t v492;
  unint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  unsigned __int16 *v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  int v502;
  int v503;
  int v504;
  __int16 v505;
  unint64_t v506;
  unsigned int v507;
  unint64_t *v508;
  uint64_t v509;
  unint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  unsigned __int16 *v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  int v519;
  int v520;
  int v521;
  unsigned int v522;
  __int16 v523;
  unint64_t v524;
  unsigned int v525;
  unint64_t v526;
  unint64_t *v527;
  uint64_t v528;
  unint64_t v529;
  uint64_t v530;
  uint64_t v531;
  int v532;
  int v533;
  int v534;
  int32x2_t v535;
  int32x2_t v536;
  int32x2_t v537;
  int32x2_t v538;
  uint32x2_t v539;
  int32x2_t v540;
  uint32x2_t v541;
  uint32x2_t v542;
  int32x2_t v543;
  int8x8_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  int v548;
  int v549;
  int v550;
  unint64_t v551;
  unint64_t *v552;
  uint64_t v553;
  unint64_t v554;
  unint64_t v555;
  uint64_t v556;
  unint64_t *v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  __int16 *v561;
  int v562;
  unint64_t v563;
  int v564;
  int v565;
  int v566;
  int v567;
  unsigned int v568;
  unsigned int v569;
  uint64_t v570;
  unint64_t v571;
  int v572;
  unint64_t *v573;
  uint64_t v574;
  unint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  unsigned __int16 *v580;
  int v581;
  int v582;
  int32x2_t v583;
  int32x2_t v584;
  int32x2_t v585;
  int32x2_t v586;
  uint32x2_t v587;
  int32x2_t v588;
  uint32x2_t v589;
  uint32x2_t v590;
  int32x2_t v591;
  int8x8_t v592;
  unint64_t v593;
  unint64_t *v594;
  uint64_t v595;
  unint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  unsigned __int16 *v603;
  int v604;
  int v605;
  __int16 *v606;
  int v607;
  unsigned int v608;
  int32x2_t v609;
  int32x2_t v610;
  int32x2_t v611;
  int32x2_t v612;
  uint32x2_t v613;
  int32x2_t v614;
  uint32x2_t v615;
  uint32x2_t v616;
  int32x2_t v617;
  int8x8_t v618;
  unint64_t *v619;
  unsigned __int16 *v620;
  uint64_t v621;
  unint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  unsigned __int16 *v627;
  int v628;
  unint64_t v629;
  int v630;
  int v631;
  unsigned int v632;
  unint64_t *v633;
  uint64_t v634;
  unint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  int v639;
  int v640;
  unint64_t v641;
  int v642;
  unsigned int v643;
  unint64_t v644;
  unint64_t *v645;
  uint64_t v646;
  unint64_t v647;
  unint64_t v648;
  uint64_t v649;
  unint64_t *v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  int v654;
  int v655;
  unint64_t v656;
  unint64_t *v657;
  uint64_t v658;
  unint64_t v659;
  unint64_t v660;
  uint64_t v661;
  unint64_t *v662;
  uint64_t v663;
  BOOL v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  unint64_t v726;
  unint64_t v727;
  unint64_t v728;
  uint64_t v729;
  unint64_t v730;
  int v731;
  uint64_t v732;
  __int16 *v733;
  unint64_t v734;
  int v735;
  int v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  int v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  unint64_t v758;
  unint64_t v759;
  unint64_t v760;
  unint64_t v761;
  uint64_t v762;
  unint64_t v763;
  unint64_t v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  unint64_t v769;
  unint64_t v770;
  unint64_t v771;
  unint64_t v772;
  unint64_t v773;
  unint64_t v774;
  unint64_t v775;
  unint64_t v776;
  unint64_t v777;
  unint64_t v778;
  unint64_t v779;
  unint64_t v780;
  unint64_t v781;
  unint64_t v782;
  unint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;

  v2 = *(_QWORD *)(result + 48);
  v3 = *(_QWORD *)(result + 136);
  v5 = *(int *)(result + 12);
  v4 = *(int *)(result + 16);
  if (v2)
  {
    v6 = (unint64_t)*(int *)(result + 32) >> 1;
    v7 = (__int16 *)(v2 + 2 * (v5 + v6 * v4));
    v8 = -1;
    if (!v3)
      return result;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return result;
  }
  v9 = *(_DWORD *)(result + 4);
  v10 = *(_DWORD *)(result + 8);
  v12 = *(_QWORD *)(result + 88);
  v11 = *(__int16 **)(result + 96);
  v13 = (unint64_t)*(int *)(result + 28) >> 3;
  v14 = (int8x8_t *)(*(_QWORD *)(result + 40) + 8 * (v5 + v13 * v4));
  v15 = *(int *)(result + 124);
  v16 = (_BYTE *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(result + 56);
  v18 = *(int *)(result + 60);
  v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    v21 = *(_DWORD *)(result + 64);
    v22 = *(_DWORD *)(result + 68);
    v732 = v19 >> 3;
    if (v11)
    {
      v730 = (unint64_t)*(int *)(result + 80) >> 1;
      v20 = 1;
    }
    else
    {
      v730 = 0;
      v20 = 0;
    }
    result = v12 + 8 * v732 * v22;
    v8 &= 1u;
    v25 = 1;
    v734 = v12;
    v23 = (unint64_t *)v12;
    goto LABEL_19;
  }
  v732 = v19 >> 3;
  if (v11)
  {
    v730 = (unint64_t)*(int *)(result + 80) >> 1;
    v11 += v17 + v730 * v18;
    v20 = -1;
  }
  else
  {
    v730 = 0;
    v20 = 0;
  }
  v23 = (unint64_t *)(v12 + 8 * (v17 + v732 * v18));
  if (v732 == v13 && (char *)v14 - (char *)v23 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v23) >> 3))
    {
      v14 += v9 - 1;
      v23 += v9 - 1;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      v25 = -1;
      v732 = (unint64_t)*(int *)(result + 28) >> 3;
      v11 += v20 & (v9 - 1);
      goto LABEL_16;
    }
    v24 = v10 - 1;
    if (v14 <= (int8x8_t *)&v23[v13 * v24 - 1 + v9])
    {
      v14 += v13 * v24;
      v16 += v15 * v24;
      v15 = -v15;
      v7 += v6 * v24;
      v6 = -(uint64_t)v6;
      v8 &= 1u;
      v11 += v730 * v24;
      v730 = -(uint64_t)v730;
      v20 &= 1u;
      v25 = 1;
      v23 += v13 * v24;
      v732 = -(uint64_t)v13;
      v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  v25 = 1;
LABEL_16:
  result = 0;
  v734 = 0;
  v12 = -1;
  v22 = v730;
  v21 = v732;
LABEL_19:
  v26 = v25 * v9;
  v731 = v9;
  v727 = result;
  v735 = v10;
  if (result)
  {
    v27 = (int)v18 % v22;
    v28 = &v23[v732 * v27];
    result = (int)v17 % v21;
    v23 = &v28[result];
    v12 = (unint64_t)&v28[v21];
    if ((v20 & 1) != 0)
      v11 += v730 * v27 + result;
    v733 = v11;
    v734 = (unint64_t)&v28[result];
  }
  else
  {
    v732 -= v26;
    v733 = v11;
    v730 -= v20 * v9;
  }
  v729 = v15 - v26;
  v728 = v13 - v26;
  v726 = v6 - v8 * v9;
  v736 = v8;
  v750 = v20;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          v29 = v9;
          v30 = v735;
          do
          {
            v31 = *v16;
            if (*v16)
            {
              if (v31 == 255)
              {
                LOWORD(v32) = 0;
                *v14 = 0;
              }
              else
              {
                v33 = (unsigned __int16)*v7;
                v34 = v31 | (v31 << 8);
                v35 = vdup_n_s32(v34);
                v36 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v14, (int8x8_t)0xFFFF0000FFFFLL), v35);
                v37.i32[0] = HIWORD(v14->u32[0]);
                v37.i32[1] = HIWORD(*(unint64_t *)v14);
                v38 = (uint32x2_t)vmul_s32(v37, v35);
                *v14 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v14, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v36, v36, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v37, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v38, v38, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                v32 = v33 - ((v34 * v33 + ((v34 * v33) >> 16) + 1) >> 16);
              }
              *v7 = v32;
            }
            v16 += v25;
            v7 += v8;
            v14 += v25;
            --v29;
          }
          while (v29);
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v30 != 1);
      }
      else
      {
        do
        {
          v532 = v9;
          v533 = v735;
          do
          {
            v534 = *v16;
            if (*v16)
            {
              if (v534 == 255)
              {
                *v14 = 0;
              }
              else
              {
                v535 = (int32x2_t)*v14;
                v536.i32[0] = vshl_u32((uint32x2_t)*v14, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v537.i32[0] = v536.i32[0];
                v537.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v14);
                v538 = vdup_n_s32(v534 | (v534 << 8));
                v539 = (uint32x2_t)vmul_s32(v537, v538);
                v540.i32[0] = v14->u16[0];
                v540.i32[1] = HIWORD(*(unint64_t *)v14);
                v541 = (uint32x2_t)vmul_s32(v540, v538);
                v536.i32[1] = HIDWORD(*(unint64_t *)v14);
                v542 = (uint32x2_t)vsub_s32(v536, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v539, v539, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v535.i32[1] = v540.i32[1];
                v543 = vsub_s32(v535, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v541, v541, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v544 = (int8x8_t)vshl_n_s32(v543, 0x10uLL);
                v543.i16[1] = 0;
                v543.i32[1] = v544.i32[1];
                v544.i32[0] = vshl_u32(v542, (uint32x2_t)0xFFFF00000010).u32[0];
                v544.i32[1] = v542.u16[2];
                *v14 = vorr_s8(v544, (int8x8_t)v543);
              }
            }
            v16 += v25;
            v14 += v25;
            --v532;
          }
          while (v532);
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v533 != 1);
      }
      return result;
    case 1:
      if (v8)
      {
        v39 = v25;
        if (v20)
        {
          v40 = v20;
          v41 = -(uint64_t)v21;
          v42 = v733;
          v737 = -(v732 * v22);
          v751 = v25;
          v700 = -(uint64_t)(v730 * v22);
          v43 = 2 * v8;
          v44 = 8 * v39;
          do
          {
            v45 = v731;
            v758 = v12;
            do
            {
              v46 = *v16;
              if (*v16)
              {
                if (v46 == 255)
                {
                  *v14 = (int8x8_t)*v23;
                  *v7 = *v42;
                }
                else
                {
                  v47 = v43;
                  result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, (unsigned __int16)*v42, v46 | (v46 << 8), (unint64_t)*v14, (unsigned __int16)*v7, (v46 | (v46 << 8)) ^ 0xFFFFu);
                  v43 = v47;
                  v39 = v751;
                  v12 = v758;
                }
              }
              v16 += v39;
              v48 = &v23[v39];
              if ((unint64_t)v48 >= v12)
                v49 = v41;
              else
                v49 = 0;
              v42 += v40 + v49;
              v23 = &v48[v49];
              v7 = (__int16 *)((char *)v7 + v43);
              v14 = (int8x8_t *)((char *)v14 + v44);
              --v45;
            }
            while (v45);
            if (v727)
            {
              v50 = v734 + 8 * v732;
              v51 = v700;
              if (v50 < v727)
                v51 = 0;
              v42 = &v733[v730 + v51];
              v52 = v737;
              if (v50 < v727)
                v52 = 0;
              v23 = (unint64_t *)(v50 + 8 * v52);
              v12 += 8 * v52 + 8 * v732;
              v733 += v730 + v51;
              v734 = (unint64_t)v23;
            }
            else
            {
              v23 += v732;
              v42 += v730;
            }
            v16 += v729;
            v14 += v728;
            v7 += v726;
            --v735;
          }
          while (v735);
        }
        else
        {
          v652 = -(uint64_t)v21;
          v789 = -(v732 * v22);
          v653 = 2 * v8;
          do
          {
            v654 = v731;
            do
            {
              v655 = *v16;
              if (*v16)
              {
                if (v655 == 255)
                {
                  *v14 = (int8x8_t)*v23;
                  *v7 = -1;
                }
                else
                {
                  v656 = v12;
                  result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, 0xFFFF, v655 | (v655 << 8), (unint64_t)*v14, (unsigned __int16)*v7, (v655 | (v655 << 8)) ^ 0xFFFFu);
                  v12 = v656;
                }
              }
              v16 += v39;
              v657 = &v23[v39];
              if ((unint64_t)v657 >= v12)
                v658 = v652;
              else
                v658 = 0;
              v23 = &v657[v658];
              v7 = (__int16 *)((char *)v7 + v653);
              v14 += v39;
              --v654;
            }
            while (v654);
            v16 += v729;
            v14 += v728;
            v7 += v726;
            v659 = v734;
            v660 = v734 + 8 * v732;
            v661 = v789;
            if (v660 < v727)
              v661 = 0;
            v662 = (unint64_t *)(v660 + 8 * v661);
            v663 = v12 + 8 * v661 + 8 * v732;
            if (v727)
            {
              v12 = v663;
              v659 = (unint64_t)v662;
              v23 = v662;
            }
            else
            {
              v23 += v732;
            }
            v664 = v735 == 1;
            v734 = v659;
            --v735;
          }
          while (!v664);
        }
      }
      else
      {
        v545 = v25;
        v546 = -(uint64_t)v21;
        v784 = -(v732 * v22);
        v547 = 8 * v25;
        do
        {
          v548 = v731;
          v549 = v735;
          do
          {
            v550 = *v16;
            if (*v16)
            {
              if (v550 == 255)
              {
                *v14 = (int8x8_t)*v23;
              }
              else
              {
                v551 = v12;
                result = (uint64_t)cmyk64_DMplusDM((unsigned int *)v14, *v23, v550 | (v550 << 8), (unint64_t)*v14, (v550 | (v550 << 8)) ^ 0xFFFFu);
                v12 = v551;
              }
            }
            v16 += v545;
            v552 = &v23[v545];
            if ((unint64_t)v552 >= v12)
              v553 = v546;
            else
              v553 = 0;
            v23 = &v552[v553];
            v14 = (int8x8_t *)((char *)v14 + v547);
            --v548;
          }
          while (v548);
          v16 += v729;
          v14 += v728;
          v554 = v734;
          v555 = v734 + 8 * v732;
          v556 = v784;
          if (v555 < v727)
            v556 = 0;
          v557 = (unint64_t *)(v555 + 8 * v556);
          v558 = v12 + 8 * v556 + 8 * v732;
          if (v727)
          {
            v12 = v558;
            v554 = (unint64_t)v557;
            v23 = v557;
          }
          else
          {
            v23 += v732;
          }
          v734 = v554;
          --v735;
        }
        while (v549 != 1);
      }
      return result;
    case 2:
      v53 = v25;
      if (v8)
      {
        v54 = v20;
        v55 = v733;
        v738 = -(v732 * v22);
        v752 = v20;
        v701 = -(uint64_t)(v730 * v22);
        v56 = 2 * v8;
        v57 = -(uint64_t)v21;
        while (1)
        {
          v58 = v731;
          v759 = v12;
          do
          {
            v59 = *v16;
            if (!*v16)
              goto LABEL_70;
            if (v59 == 255)
            {
              v60 = (unsigned __int16)*v55;
              if (!*v55)
                goto LABEL_70;
              if (v60 == 0xFFFF)
              {
                *v14 = (int8x8_t)*v23;
                *v7 = -1;
                goto LABEL_70;
              }
              v64 = *v23;
              v65 = (unint64_t)*v14;
              v66 = (unsigned __int16)*v7;
              v67 = v60 ^ 0xFFFF;
            }
            else
            {
              v61 = (unsigned __int16)*v55;
              v62 = (v59 | (v59 << 8)) ^ 0xFFFF;
              if (v61 == (v62 * v61 + ((v62 * v61) >> 16) + 1) >> 16)
                goto LABEL_70;
              v63 = (unsigned __int16)WORD2(*v23) * v62;
              v64 = ((HIWORD(*v23) - ((v62 * HIWORD(*v23) + ((v62 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v63 + HIWORD(v63) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v62 + ((WORD1(*v23) * v62) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v62 + (((unsigned __int16)*v23 * v62) >> 16) + 1) >> 16));
              v65 = (unint64_t)*v14;
              v66 = (unsigned __int16)*v7;
              v67 = (unsigned __int16)~(v61 - ((v62 * v61 + ((v62 * v61) >> 16) + 1) >> 16));
              LOWORD(v60) = v61 - ((v62 * v61 + ((v62 * v61) >> 16) + 1) >> 16);
            }
            result = (uint64_t)cmyk64_DAplusDAM(v14, v7, v64, v60, v65, v66, v67);
            v54 = v752;
            v12 = v759;
LABEL_70:
            v16 += v53;
            v68 = &v23[v53];
            if ((unint64_t)v68 >= v12)
              v69 = v57;
            else
              v69 = 0;
            v55 += v54 + v69;
            v23 = &v68[v69];
            v7 = (__int16 *)((char *)v7 + v56);
            v14 += v53;
            --v58;
          }
          while (v58);
          if (v727)
          {
            v70 = v734 + 8 * v732;
            v71 = v701;
            if (v70 < v727)
              v71 = 0;
            v55 = &v733[v730 + v71];
            v72 = v738;
            if (v70 < v727)
              v72 = 0;
            v23 = (unint64_t *)(v70 + 8 * v72);
            v12 += 8 * v72 + 8 * v732;
            v733 += v730 + v71;
            v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v55 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          if (!--v735)
            return result;
        }
      }
      v559 = v20;
      v560 = -(uint64_t)v21;
      v561 = v733;
      v757 = -(uint64_t)(v730 * v22);
      v785 = -(v732 * v22);
      break;
    case 3:
      v73 = v25;
      v74 = v20;
      v75 = (unsigned __int16 *)v733;
      v702 = -(v732 * v22);
      v680 = -(uint64_t)(v730 * v22);
      v76 = 2 * v8;
      v77 = 8 * v25;
      v78 = -(uint64_t)v21;
      v739 = v20;
      do
      {
        v79 = v731;
        v760 = v12;
        do
        {
          v80 = *v16;
          if (*v16)
          {
            if (v80 == 255)
            {
              if (v20)
                v81 = *v75;
              else
                v81 = 0xFFFF;
              v83 = (unsigned __int16)*v7 ^ 0xFFFF;
              v84 = vdup_n_s32(v83);
              v85 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v23, (int8x8_t)0xFFFF0000FFFFLL), v84);
              v86.i32[0] = WORD1(*v23);
              v86.i32[1] = HIWORD(*v23);
              v87 = (uint32x2_t)vmul_s32(v86, v84);
              *v14 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v23, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v85, v85, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v86, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v87, v87, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *v7 = v81 - ((v83 * v81 + ((v83 * v81) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20)
                v82 = *v75;
              else
                v82 = 0xFFFF;
              result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, v82, ((unsigned __int16)*v7 * (v80 | (v80 << 8))+ (((unsigned __int16)*v7 * (v80 | (v80 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (unsigned __int16)*v7, (v80 | (v80 << 8)) ^ 0xFFFFu);
              v20 = v750;
              v12 = v760;
              v74 = v739;
            }
          }
          v16 += v73;
          v88 = &v23[v73];
          if ((unint64_t)v88 >= v12)
            v89 = v78;
          else
            v89 = 0;
          v75 += v74 + v89;
          v23 = &v88[v89];
          v7 = (__int16 *)((char *)v7 + v76);
          v14 = (int8x8_t *)((char *)v14 + v77);
          --v79;
        }
        while (v79);
        if (v727)
        {
          v90 = v734 + 8 * v732;
          v91 = v680;
          if (v90 < v727)
            v91 = 0;
          v75 = (unsigned __int16 *)&v733[v730 + v91];
          v92 = v702;
          if (v90 < v727)
            v92 = 0;
          v23 = (unint64_t *)(v90 + 8 * v92);
          v12 += 8 * v92 + 8 * v732;
          v733 += v730 + v91;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v75 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 4:
      v93 = v25;
      v94 = v20;
      v95 = (unsigned __int16 *)v733;
      v703 = -(v732 * v22);
      v681 = -(uint64_t)(v730 * v22);
      v96 = 2 * v8;
      v97 = 8 * v25;
      v98 = -(uint64_t)v21;
      v740 = v20;
      do
      {
        v99 = v731;
        v761 = v12;
        do
        {
          v100 = *v16;
          if (*v16)
          {
            if (v100 == 255)
            {
              if (v20)
                v101 = *v95;
              else
                v101 = 0xFFFF;
              v103 = (unsigned __int16)*v7;
              v104 = vdup_n_s32(v103);
              v105 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v23, (int8x8_t)0xFFFF0000FFFFLL), v104);
              v106.i32[0] = WORD1(*v23);
              v106.i32[1] = HIWORD(*v23);
              v107 = (uint32x2_t)vmul_s32(v106, v104);
              *v14 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v23, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v105, v105, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v106, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v107, v107, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *v7 = v101 - ((v103 * v101 + ((v103 * v101) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20)
                v102 = *v95;
              else
                v102 = 0xFFFF;
              result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, v102, (((unsigned __int16)*v7 ^ 0xFFFF) * (v100 | (v100 << 8))+ ((((unsigned __int16)*v7 ^ 0xFFFF) * (v100 | (v100 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (unsigned __int16)*v7, (v100 | (v100 << 8)) ^ 0xFFFFu);
              v20 = v750;
              v12 = v761;
              v94 = v740;
            }
          }
          v16 += v93;
          v108 = &v23[v93];
          if ((unint64_t)v108 >= v12)
            v109 = v98;
          else
            v109 = 0;
          v95 += v94 + v109;
          v23 = &v108[v109];
          v7 = (__int16 *)((char *)v7 + v96);
          v14 = (int8x8_t *)((char *)v14 + v97);
          --v99;
        }
        while (v99);
        if (v727)
        {
          v110 = v734 + 8 * v732;
          v111 = v681;
          if (v110 < v727)
            v111 = 0;
          v95 = (unsigned __int16 *)&v733[v730 + v111];
          v112 = v703;
          if (v110 < v727)
            v112 = 0;
          v23 = (unint64_t *)(v110 + 8 * v112);
          v12 += 8 * v112 + 8 * v732;
          v733 += v730 + v111;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v95 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 5:
      v113 = v25;
      v753 = -(uint64_t)v21;
      v762 = v20;
      v114 = (unsigned __int16 *)v733;
      v741 = -(v732 * v22);
      v704 = -(uint64_t)(v730 * v22);
      v115 = 2 * v8;
      v116 = 8 * v25;
      do
      {
        v117 = v731;
        do
        {
          if (*v16)
          {
            v118 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v119 = (unsigned __int16)WORD2(*v23) * v118;
            v120 = ((HIWORD(*v23) - ((v118 * HIWORD(*v23) + ((v118 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v119 + HIWORD(v119) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v118 + ((WORD1(*v23) * v118) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v118 + (((unsigned __int16)*v23 * v118) >> 16) + 1) >> 16));
            v121 = *v114 - ((v118 * *v114 + ((v118 * *v114) >> 16) + 1) >> 16);
            v122 = v12;
            result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, v120, (unsigned __int16)v121, (unsigned __int16)*v7, (unint64_t)*v14, (unsigned __int16)*v7, (unsigned __int16)~(_WORD)v121);
            v12 = v122;
          }
          v16 += v113;
          v123 = &v23[v113];
          v124 = v753;
          if ((unint64_t)v123 < v12)
            v124 = 0;
          v114 += v762 + v124;
          v23 = &v123[v124];
          v7 = (__int16 *)((char *)v7 + v115);
          v14 = (int8x8_t *)((char *)v14 + v116);
          --v117;
        }
        while (v117);
        if (v727)
        {
          v125 = v734 + 8 * v732;
          v126 = v704;
          if (v125 < v727)
            v126 = 0;
          v114 = (unsigned __int16 *)&v733[v730 + v126];
          v127 = v741;
          if (v125 < v727)
            v127 = 0;
          v23 = (unint64_t *)(v125 + 8 * v127);
          v12 += 8 * v127 + 8 * v732;
          v733 += v730 + v126;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v114 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 6:
      v128 = v25;
      v129 = v20;
      v130 = (unsigned __int16 *)v733;
      v705 = -(v732 * v22);
      v682 = -(uint64_t)(v730 * v22);
      v131 = 2 * v8;
      v132 = 8 * v25;
      v133 = -(uint64_t)v21;
      v742 = v20;
      do
      {
        v134 = v731;
        v763 = v12;
        do
        {
          v135 = *v16;
          if (*v16 && *v7 != -1)
          {
            if ((unsigned __int16)~*v7 == 0xFFFF)
            {
              if (v20)
                v136 = *v130;
              else
                v136 = 0xFFFF;
              v138 = (v135 | (v135 << 8)) ^ 0xFFFF;
              v139 = vdup_n_s32(v138);
              v140 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v23, (int8x8_t)0xFFFF0000FFFFLL), v139);
              v141.i32[0] = WORD1(*v23);
              v141.i32[1] = HIWORD(*v23);
              v142 = (uint32x2_t)vmul_s32(v141, v139);
              *v14 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v23, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v140, v140, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v141, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v142, v142, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *v7 = v136 - ((v138 * v136 + ((v138 * v136) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20)
                v137 = *v130;
              else
                v137 = 0xFFFF;
              result = (uint64_t)cmyk64_DAplusDAM(v14, v7, (uint64_t)*v14, *v7, *v23, v137, (257 * v135 * (unsigned __int16)~*v7+ ((257 * v135 * (unsigned __int16)~*v7) >> 16)+ 1) >> 16);
              v20 = v750;
              v12 = v763;
              v129 = v742;
            }
          }
          v16 += v128;
          v143 = &v23[v128];
          if ((unint64_t)v143 >= v12)
            v144 = v133;
          else
            v144 = 0;
          v130 += v129 + v144;
          v23 = &v143[v144];
          v7 = (__int16 *)((char *)v7 + v131);
          v14 = (int8x8_t *)((char *)v14 + v132);
          --v134;
        }
        while (v134);
        if (v727)
        {
          v145 = v734 + 8 * v732;
          v146 = v682;
          if (v145 < v727)
            v146 = 0;
          v130 = (unsigned __int16 *)&v733[v730 + v146];
          v147 = v705;
          if (v145 < v727)
            v147 = 0;
          v23 = (unint64_t *)(v145 + 8 * v147);
          v12 += 8 * v147 + 8 * v732;
          v733 += v730 + v146;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v130 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 7:
      v148 = v25;
      if (v8)
      {
        v149 = v20;
        v150 = (unsigned __int16 *)v733;
        v743 = -(v732 * v22);
        v754 = v25;
        v706 = -(uint64_t)(v730 * v22);
        v151 = 2 * v8;
        v152 = 8 * v25;
        v153 = -(uint64_t)v21;
        do
        {
          v154 = v731;
          v764 = v12;
          do
          {
            v155 = *v16;
            if (*v16)
            {
              if (v155 == 255)
              {
                v156 = (unsigned __int16)*v7;
                v157 = *v150 ^ 0xFFFF;
                v158 = vdup_n_s32(v157);
                v159 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v14, (int8x8_t)0xFFFF0000FFFFLL), v158);
                v160.i32[0] = HIWORD(v14->u32[0]);
                v160.i32[1] = HIWORD(*(unint64_t *)v14);
                v161 = (uint32x2_t)vmul_s32(v160, v158);
                *v14 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v14, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v159, v159, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v160, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v161, v161, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                *v7 = v156 - ((v157 * v156 + ((v157 * v156) >> 16) + 1) >> 16);
              }
              else
              {
                v162 = v152;
                v163 = v153;
                result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, (unint64_t)*v14, (unsigned __int16)*v7, (*v150 * (v155 | (v155 << 8))+ ((*v150 * (v155 | (v155 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (unsigned __int16)*v7, (v155 | (v155 << 8)) ^ 0xFFFFu);
                v153 = v163;
                v152 = v162;
                v148 = v754;
                v12 = v764;
              }
            }
            v16 += v148;
            v164 = &v23[v148];
            if ((unint64_t)v164 >= v12)
              v165 = v153;
            else
              v165 = 0;
            v150 += v149 + v165;
            v23 = &v164[v165];
            v7 = (__int16 *)((char *)v7 + v151);
            v14 = (int8x8_t *)((char *)v14 + v152);
            --v154;
          }
          while (v154);
          if (v727)
          {
            v166 = v734 + 8 * v732;
            v167 = v706;
            if (v166 < v727)
              v167 = 0;
            v150 = (unsigned __int16 *)&v733[v730 + v167];
            v168 = v743;
            if (v166 < v727)
              v168 = 0;
            v23 = (unint64_t *)(v166 + 8 * v168);
            v12 += 8 * v168 + 8 * v732;
            v733 += v730 + v167;
            v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v150 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v735);
      }
      else
      {
        v578 = v20;
        v579 = -(uint64_t)v21;
        v580 = (unsigned __int16 *)v733;
        v786 = -(v732 * v22);
        v748 = -(uint64_t)(v730 * v22);
        do
        {
          v581 = v731;
          do
          {
            v582 = *v16;
            if (*v16)
            {
              if (v582 == 255)
              {
                v583 = (int32x2_t)*v14;
                v584.i32[0] = vshl_u32((uint32x2_t)*v14, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v585.i32[0] = v584.i32[0];
                v585.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v14);
                v586 = vdup_n_s32(*v580 ^ 0xFFFFu);
                v587 = (uint32x2_t)vmul_s32(v585, v586);
                v588.i32[0] = v14->u16[0];
                v588.i32[1] = HIWORD(*(unint64_t *)v14);
                v589 = (uint32x2_t)vmul_s32(v588, v586);
                v584.i32[1] = HIDWORD(*(unint64_t *)v14);
                v590 = (uint32x2_t)vsub_s32(v584, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v587, v587, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v583.i32[1] = v588.i32[1];
                v591 = vsub_s32(v583, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v589, v589, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v592 = (int8x8_t)vshl_n_s32(v591, 0x10uLL);
                v591.i16[1] = 0;
                v591.i32[1] = v592.i32[1];
                v592.i32[0] = vshl_u32(v590, (uint32x2_t)0xFFFF00000010).u32[0];
                v592.i32[1] = v590.u16[2];
                *v14 = vorr_s8(v592, (int8x8_t)v591);
              }
              else
              {
                v593 = v12;
                result = (uint64_t)cmyk64_DMplusDM((unsigned int *)v14, (unint64_t)*v14, (*v580 * (v582 | (v582 << 8))+ ((*v580 * (v582 | (v582 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (v582 | (v582 << 8)) ^ 0xFFFFu);
                v12 = v593;
              }
            }
            v16 += v148;
            v594 = &v23[v148];
            if ((unint64_t)v594 >= v12)
              v595 = v579;
            else
              v595 = 0;
            v580 += v578 + v595;
            v23 = &v594[v595];
            v14 += v148;
            --v581;
          }
          while (v581);
          if (v727)
          {
            v596 = v734 + 8 * v732;
            v597 = v748;
            if (v596 < v727)
              v597 = 0;
            v580 = (unsigned __int16 *)&v733[v730 + v597];
            v598 = v786;
            if (v596 < v727)
              v598 = 0;
            v23 = (unint64_t *)(v596 + 8 * v598);
            v12 += 8 * v598 + 8 * v732;
            v733 += v730 + v597;
            v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v580 += v730;
          }
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v735);
      }
      return result;
    case 8:
      v169 = v25;
      if (v8)
      {
        v170 = v20;
        v171 = v22;
        v172 = (unsigned __int16 *)v733;
        v173 = -(v732 * v22);
        v174 = -(uint64_t)(v730 * v171);
        v175 = -(uint64_t)v21;
        do
        {
          v176 = v731;
          v177 = v735;
          v178 = v733;
          do
          {
            v179 = *v16;
            if (*v16)
            {
              v180 = (int32x2_t)*v14;
              v181 = (unsigned __int16)*v7;
              if (v179 == 255)
                v182 = *v172;
              else
                v182 = (257 * v179 * *v172 + ((257 * v179 * *v172) >> 16) + 1) >> 16;
              v183 = vdup_n_s32(v182);
              v184 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8((int8x8_t)v180, (int8x8_t)0xFFFF0000FFFFLL), v183);
              v185.i32[0] = HIWORD(v180.i32[0]);
              v185.i32[1] = HIWORD(*(unint64_t *)v14);
              v186 = (uint32x2_t)vmul_s32(v185, v183);
              *v14 = (int8x8_t)vsli_n_s32(vsub_s32(v180, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v184, v184, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v185, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v186, v186, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *v7 = v181 - ((v182 * v181 + ((v182 * v181) >> 16) + 1) >> 16);
            }
            v16 += v169;
            v187 = &v23[v169];
            v188 = &v172[v170];
            if ((unint64_t)v187 >= v12)
              result = v175;
            else
              result = 0;
            v172 = &v188[result];
            v23 = &v187[result];
            v7 += v8;
            v14 += v169;
            --v176;
          }
          while (v176);
          if (v727)
          {
            result = v732;
            v189 = v734 + 8 * v732;
            if (v189 >= v727)
              v190 = v174;
            else
              v190 = 0;
            if (v189 >= v727)
              v191 = v173;
            else
              v191 = 0;
            v23 = (unint64_t *)(v189 + 8 * v191);
            v12 += 8 * v191 + 8 * v732;
            v733 += v730 + v190;
            v734 = (unint64_t)v23;
            v172 = (unsigned __int16 *)&v178[v730 + v190];
          }
          else
          {
            v23 += v732;
            v172 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v177 != 1);
      }
      else
      {
        v599 = -(uint64_t)v21;
        v600 = v22;
        v601 = -(v732 * v22);
        v602 = -(uint64_t)(v730 * v600);
        v603 = (unsigned __int16 *)v733;
        do
        {
          v604 = v9;
          v605 = v735;
          v606 = v733;
          do
          {
            v607 = *v16;
            if (*v16)
            {
              if (v607 == 255)
                v608 = *v603;
              else
                v608 = (257 * v607 * *v603 + ((257 * v607 * *v603) >> 16) + 1) >> 16;
              result = HIWORD(*(unint64_t *)v14);
              v609 = (int32x2_t)*v14;
              v610.i32[0] = vshl_u32((uint32x2_t)*v14, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
              v611.i32[0] = v610.i32[0];
              v611.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v14);
              v612 = vdup_n_s32(v608);
              v613 = (uint32x2_t)vmul_s32(v611, v612);
              v614.i32[0] = v14->u16[0];
              v614.i32[1] = result;
              v615 = (uint32x2_t)vmul_s32(v614, v612);
              v610.i32[1] = HIDWORD(*(unint64_t *)v14);
              v616 = (uint32x2_t)vsub_s32(v610, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v613, v613, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              v609.i32[1] = result;
              v617 = vsub_s32(v609, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v615, v615, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              v618 = (int8x8_t)vshl_n_s32(v617, 0x10uLL);
              v617.i16[1] = 0;
              v617.i32[1] = v618.i32[1];
              v618.i32[0] = vshl_u32(v616, (uint32x2_t)0xFFFF00000010).u32[0];
              v618.i32[1] = v616.u16[2];
              *v14 = vorr_s8(v618, (int8x8_t)v617);
            }
            v16 += v169;
            v619 = &v23[v169];
            v620 = &v603[v20];
            if ((unint64_t)v619 >= v12)
              v621 = v599;
            else
              v621 = 0;
            v603 = &v620[v621];
            v23 = &v619[v621];
            v14 += v169;
            --v604;
          }
          while (v604);
          if (v727)
          {
            v622 = v734 + 8 * v732;
            if (v622 >= v727)
              v623 = v602;
            else
              v623 = 0;
            result = (uint64_t)&v733[v730 + v623];
            if (v622 >= v727)
              v624 = v601;
            else
              v624 = 0;
            v23 = (unint64_t *)(v622 + 8 * v624);
            v12 += 8 * v624 + 8 * v732;
            v733 += v730 + v623;
            v734 = (unint64_t)v23;
            v603 = (unsigned __int16 *)&v606[v730 + v623];
          }
          else
          {
            v23 += v732;
            v603 += v730;
          }
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v605 != 1);
      }
      return result;
    case 9:
      v192 = v25;
      v755 = -(uint64_t)v21;
      v765 = v20;
      v193 = (unsigned __int16 *)v733;
      v744 = -(v732 * v22);
      v707 = -(uint64_t)(v730 * v22);
      v194 = 2 * v8;
      v195 = 8 * v25;
      do
      {
        v196 = v731;
        do
        {
          if (*v16)
          {
            v197 = v12;
            v198 = ~(*v16 | (*v16 << 8));
            v199 = v198;
            v200 = (unsigned __int16)WORD2(*v23) * v198;
            v201 = ((HIWORD(*v23) - ((HIWORD(*v23) * v199 + ((HIWORD(*v23) * v199) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v200 + HIWORD(v200) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v199 + ((WORD1(*v23) * v199) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v199 + (((unsigned __int16)*v23 * v199) >> 16) + 1) >> 16));
            v202 = *v193 - ((*v193 * v199 + ((*v193 * v199) >> 16) + 1) >> 16);
            result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, v201, (unsigned __int16)v202, (unsigned __int16)*v7 ^ 0xFFFFu, (unint64_t)*v14, (unsigned __int16)*v7, (unsigned __int16)(v202 + v198));
            v12 = v197;
          }
          v16 += v192;
          v203 = &v23[v192];
          v204 = v755;
          if ((unint64_t)v203 < v12)
            v204 = 0;
          v193 += v765 + v204;
          v23 = &v203[v204];
          v7 = (__int16 *)((char *)v7 + v194);
          v14 = (int8x8_t *)((char *)v14 + v195);
          --v196;
        }
        while (v196);
        if (v727)
        {
          v205 = v734 + 8 * v732;
          v206 = v707;
          if (v205 < v727)
            v206 = 0;
          v193 = (unsigned __int16 *)&v733[v730 + v206];
          v207 = v744;
          if (v205 < v727)
            v207 = 0;
          v23 = (unint64_t *)(v205 + 8 * v207);
          v12 += 8 * v207 + 8 * v732;
          v733 += v730 + v206;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v193 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 10:
      v208 = v25;
      v756 = -(uint64_t)v21;
      v766 = v20;
      v209 = (unsigned __int16 *)v733;
      v745 = -(v732 * v22);
      v708 = -(uint64_t)(v730 * v22);
      v210 = 2 * v8;
      v211 = 8 * v25;
      do
      {
        v212 = v731;
        do
        {
          if (*v16)
          {
            v213 = v12;
            v214 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v215 = (unsigned __int16)WORD2(*v23) * v214;
            v216 = ((HIWORD(*v23) - ((v214 * HIWORD(*v23) + ((v214 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v215 + HIWORD(v215) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v214 + ((WORD1(*v23) * v214) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v214 + (((unsigned __int16)*v23 * v214) >> 16) + 1) >> 16));
            v217 = *v209 - ((v214 * *v209 + ((v214 * *v209) >> 16) + 1) >> 16);
            result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, v216, (unsigned __int16)v217, (unsigned __int16)*v7 ^ 0xFFFFu, (unint64_t)*v14, (unsigned __int16)*v7, (unsigned __int16)~(_WORD)v217);
            v12 = v213;
          }
          v16 += v208;
          v218 = &v23[v208];
          v219 = v756;
          if ((unint64_t)v218 < v12)
            v219 = 0;
          v209 += v766 + v219;
          v23 = &v218[v219];
          v7 = (__int16 *)((char *)v7 + v210);
          v14 = (int8x8_t *)((char *)v14 + v211);
          --v212;
        }
        while (v212);
        if (v727)
        {
          v220 = v734 + 8 * v732;
          v221 = v708;
          if (v220 < v727)
            v221 = 0;
          v209 = (unsigned __int16 *)&v733[v730 + v221];
          v222 = v745;
          if (v220 < v727)
            v222 = 0;
          v23 = (unint64_t *)(v220 + 8 * v222);
          v12 += 8 * v222 + 8 * v732;
          v733 += v730 + v221;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v209 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 11:
      v223 = v25;
      if (v8)
      {
        v767 = v20;
        v224 = (unsigned __int16 *)v733;
        v709 = -(v732 * v22);
        v683 = -(uint64_t)(v730 * v22);
        v746 = 2 * v8;
        v225 = -(uint64_t)v21;
        do
        {
          v226 = v731;
          v227 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
                v228 = *v224;
              else
                v228 = 0xFFFF;
              v229 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v230 = (unsigned __int16)WORD2(*v23) * v229;
              result = (uint64_t)cmyk64_DAplusdDA((int *)v14, v7, (unint64_t)*v14, (unsigned __int16)*v7, ((HIWORD(*v23)- ((v229 * HIWORD(*v23) + ((v229 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v230 + HIWORD(v230) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v229 + ((WORD1(*v23) * v229) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v229 + (((unsigned __int16)*v23 * v229) >> 16) + 1) >> 16)), (unsigned __int16)(v228- ((v228 * v229 + ((v228 * v229) >> 16) + 1) >> 16)));
              v12 = v227;
              v20 = v750;
            }
            v16 += v223;
            v231 = &v23[v223];
            if ((unint64_t)v231 >= v12)
              v232 = v225;
            else
              v232 = 0;
            v224 += v767 + v232;
            v23 = &v231[v232];
            v7 = (__int16 *)((char *)v7 + v746);
            v14 += v223;
            --v226;
          }
          while (v226);
          if (v727)
          {
            v233 = v734 + 8 * v732;
            v234 = v683;
            if (v233 < v727)
              v234 = 0;
            v224 = (unsigned __int16 *)&v733[v730 + v234];
            v235 = v709;
            if (v233 < v727)
              v235 = 0;
            v23 = (unint64_t *)(v233 + 8 * v235);
            v12 += 8 * v235 + 8 * v732;
            v733 += v730 + v234;
            v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v224 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v735);
      }
      else
      {
        v625 = v20;
        v626 = -(uint64_t)v21;
        v627 = (unsigned __int16 *)v733;
        v787 = -(v732 * v22);
        v749 = -(uint64_t)(v730 * v22);
        do
        {
          v628 = v731;
          v629 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
                v630 = *v627;
              else
                v630 = 0xFFFF;
              v631 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v632 = (unsigned __int16)WORD2(*v23) * v631;
              result = (uint64_t)cmyk64_DplusdDA((int *)v14, (unint64_t)*v14, ((HIWORD(*v23)- ((v631 * HIWORD(*v23) + ((v631 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v632 + HIWORD(v632) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v631 + ((WORD1(*v23) * v631) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v631 + (((unsigned __int16)*v23 * v631) >> 16) + 1) >> 16)), (unsigned __int16)(v630- ((v630 * v631 + ((v630 * v631) >> 16) + 1) >> 16)));
              v12 = v629;
              v20 = v750;
            }
            v16 += v223;
            v633 = &v23[v223];
            if ((unint64_t)v633 >= v12)
              v634 = v626;
            else
              v634 = 0;
            v627 += v625 + v634;
            v23 = &v633[v634];
            v14 += v223;
            --v628;
          }
          while (v628);
          if (v727)
          {
            v635 = v734 + 8 * v732;
            v636 = v749;
            if (v635 < v727)
              v636 = 0;
            v627 = (unsigned __int16 *)&v733[v730 + v636];
            v637 = v787;
            if (v635 < v727)
              v637 = 0;
            v23 = (unint64_t *)(v635 + 8 * v637);
            v12 += 8 * v637 + 8 * v732;
            v733 += v730 + v636;
            v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v627 += v730;
          }
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v735);
      }
      return result;
    case 12:
      v236 = v25;
      if (v8)
      {
        v768 = v20;
        v237 = (unsigned __int16 *)v733;
        v710 = -(v732 * v22);
        v684 = -(uint64_t)(v730 * v22);
        v747 = 2 * v8;
        v238 = -(uint64_t)v21;
        do
        {
          v239 = v731;
          v240 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
                v241 = *v237;
              else
                v241 = 0xFFFF;
              v242 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v243 = (unsigned __int16)WORD2(*v23) * v242;
              result = (uint64_t)cmyk64_DApluslDA((unsigned int *)v14, v7, (unint64_t)*v14, (unsigned __int16)*v7, ((HIWORD(*v23)- ((v242 * HIWORD(*v23) + ((v242 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v243 + HIWORD(v243) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v242 + ((WORD1(*v23) * v242) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v242 + (((unsigned __int16)*v23 * v242) >> 16) + 1) >> 16)), (unsigned __int16)(v241- ((v241 * v242 + ((v241 * v242) >> 16) + 1) >> 16)));
              v12 = v240;
              v20 = v750;
            }
            v16 += v236;
            v244 = &v23[v236];
            if ((unint64_t)v244 >= v12)
              v245 = v238;
            else
              v245 = 0;
            v237 += v768 + v245;
            v23 = &v244[v245];
            v7 = (__int16 *)((char *)v7 + v747);
            v14 += v236;
            --v239;
          }
          while (v239);
          if (v727)
          {
            v246 = v734 + 8 * v732;
            v247 = v684;
            if (v246 < v727)
              v247 = 0;
            v237 = (unsigned __int16 *)&v733[v730 + v247];
            v248 = v710;
            if (v246 < v727)
              v248 = 0;
            v23 = (unint64_t *)(v246 + 8 * v248);
            v12 += 8 * v248 + 8 * v732;
            v733 += v730 + v247;
            v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v237 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v735);
      }
      else
      {
        v638 = -(uint64_t)v21;
        v788 = -(v732 * v22);
        do
        {
          v639 = v731;
          v640 = v735;
          do
          {
            if (*v16)
            {
              v641 = HIWORD(*v23);
              v642 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              v643 = (unsigned __int16)WORD2(*v23) * v642;
              v644 = v12;
              result = (uint64_t)cmyk64_DpluslD((unsigned int *)v14, (unint64_t)*v14, ((unint64_t)(v641- ((v642 * (_DWORD)v641 + ((v642 * v641) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v643 + HIWORD(v643) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v642 + ((WORD1(*v23) * v642) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v642 + (((unsigned __int16)*v23 * v642) >> 16) + 1) >> 16)));
              v12 = v644;
            }
            v16 += v236;
            v645 = &v23[v236];
            if ((unint64_t)v645 >= v12)
              v646 = v638;
            else
              v646 = 0;
            v23 = &v645[v646];
            v14 += v236;
            --v639;
          }
          while (v639);
          v16 += v729;
          v14 += v728;
          v647 = v734;
          v648 = v734 + 8 * v732;
          v649 = v788;
          if (v648 < v727)
            v649 = 0;
          v650 = (unint64_t *)(v648 + 8 * v649);
          v651 = v12 + 8 * v649 + 8 * v732;
          if (v727)
          {
            v12 = v651;
            v647 = (unint64_t)v650;
            v23 = v650;
          }
          else
          {
            v23 += v732;
          }
          v734 = v647;
          --v735;
        }
        while (v640 != 1);
      }
      return result;
    case 13:
      v249 = v25;
      v250 = v20;
      v251 = (unsigned __int16 *)v733;
      v685 = -(v732 * v22);
      v711 = v20;
      v665 = -(uint64_t)(v730 * v22);
      v252 = 2 * v8;
      v253 = 8 * v25;
      v254 = -(uint64_t)v21;
      do
      {
        v255 = v731;
        v769 = v12;
        do
        {
          if (*v16)
          {
            v256 = v20 ? *v251 : 0xFFFF;
            v257 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v258 = v256 - ((v256 * v257 + ((v256 * v257) >> 16) + 1) >> 16);
            v259 = v258;
            if ((_WORD)v258)
            {
              v260 = HIWORD(*v23);
              v261 = (unsigned __int16)WORD2(*v23) * v257;
              v262 = ((unint64_t)(v260
                                       - ((v257 * (_DWORD)v260 + ((v257 * v260) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v261 + HIWORD(v261) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v257 + ((WORD1(*v23) * v257) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v257 + (((unsigned __int16)*v23 * v257) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAmultiplyPDA_10646((unint64_t)*v14, (unsigned __int16)*v7, v262, (unsigned __int16)v258);
                  v250 = v711;
                  v8 = v736;
                  v20 = v750;
                  v12 = v769;
                  v262 = result;
                }
                *v14 = (int8x8_t)v262;
                *v7 = v259;
              }
              else
              {
                result = PDAmultiplyPDA_10646((unint64_t)*v14, 0xFFFFu, v262, (unsigned __int16)v258);
                v250 = v711;
                v8 = v736;
                v20 = v750;
                v12 = v769;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v249;
          v263 = &v23[v249];
          if ((unint64_t)v263 >= v12)
            v264 = v254;
          else
            v264 = 0;
          v251 += v250 + v264;
          v23 = &v263[v264];
          v7 = (__int16 *)((char *)v7 + v252);
          v14 = (int8x8_t *)((char *)v14 + v253);
          --v255;
        }
        while (v255);
        if (v727)
        {
          v265 = v734 + 8 * v732;
          v266 = v665;
          if (v265 < v727)
            v266 = 0;
          v251 = (unsigned __int16 *)&v733[v730 + v266];
          v267 = v685;
          if (v265 < v727)
            v267 = 0;
          v23 = (unint64_t *)(v265 + 8 * v267);
          v12 += 8 * v267 + 8 * v732;
          v733 += v730 + v266;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v251 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 14:
      v268 = v25;
      v269 = v20;
      v270 = (unsigned __int16 *)v733;
      v686 = -(v732 * v22);
      v712 = v20;
      v666 = -(uint64_t)(v730 * v22);
      v271 = 2 * v8;
      v272 = 8 * v25;
      v273 = -(uint64_t)v21;
      do
      {
        v274 = v731;
        v770 = v12;
        do
        {
          if (*v16)
          {
            v275 = v20 ? *v270 : 0xFFFF;
            v276 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v277 = v275 - ((v275 * v276 + ((v275 * v276) >> 16) + 1) >> 16);
            v278 = v277;
            if ((_WORD)v277)
            {
              v279 = HIWORD(*v23);
              v280 = (unsigned __int16)WORD2(*v23) * v276;
              v281 = ((unint64_t)(v279
                                       - ((v276 * (_DWORD)v279 + ((v276 * v279) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v280 + HIWORD(v280) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v276 + ((WORD1(*v23) * v276) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v276 + (((unsigned __int16)*v23 * v276) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAscreenPDA_10647((unint64_t)*v14, (unsigned __int16)*v7, v281, (unsigned __int16)v277);
                  v269 = v712;
                  v8 = v736;
                  v20 = v750;
                  v12 = v770;
                  v281 = result;
                }
                *v14 = (int8x8_t)v281;
                *v7 = v278;
              }
              else
              {
                result = PDAscreenPDA_10647((unint64_t)*v14, 0xFFFFu, v281, (unsigned __int16)v277);
                v269 = v712;
                v8 = v736;
                v20 = v750;
                v12 = v770;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v268;
          v282 = &v23[v268];
          if ((unint64_t)v282 >= v12)
            v283 = v273;
          else
            v283 = 0;
          v270 += v269 + v283;
          v23 = &v282[v283];
          v7 = (__int16 *)((char *)v7 + v271);
          v14 = (int8x8_t *)((char *)v14 + v272);
          --v274;
        }
        while (v274);
        if (v727)
        {
          v284 = v734 + 8 * v732;
          v285 = v666;
          if (v284 < v727)
            v285 = 0;
          v270 = (unsigned __int16 *)&v733[v730 + v285];
          v286 = v686;
          if (v284 < v727)
            v286 = 0;
          v23 = (unint64_t *)(v284 + 8 * v286);
          v12 += 8 * v286 + 8 * v732;
          v733 += v730 + v285;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v270 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 15:
      v287 = v25;
      v288 = v20;
      v289 = (unsigned __int16 *)v733;
      v687 = -(v732 * v22);
      v713 = v20;
      v667 = -(uint64_t)(v730 * v22);
      v290 = 2 * v8;
      v291 = 8 * v25;
      v292 = -(uint64_t)v21;
      do
      {
        v293 = v731;
        v771 = v12;
        do
        {
          if (*v16)
          {
            v294 = v20 ? *v289 : 0xFFFF;
            v295 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v296 = v294 - ((v294 * v295 + ((v294 * v295) >> 16) + 1) >> 16);
            v297 = v296;
            if ((_WORD)v296)
            {
              v298 = HIWORD(*v23);
              v299 = (unsigned __int16)WORD2(*v23) * v295;
              v300 = ((unint64_t)(v298
                                       - ((v295 * (_DWORD)v298 + ((v295 * v298) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v299 + HIWORD(v299) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v295 + ((WORD1(*v23) * v295) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v295 + (((unsigned __int16)*v23 * v295) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAoverlayPDA_10648((unint64_t)*v14, (unsigned __int16)*v7, v300, (unsigned __int16)v296);
                  v288 = v713;
                  v8 = v736;
                  v20 = v750;
                  v12 = v771;
                  v300 = result;
                }
                *v14 = (int8x8_t)v300;
                *v7 = v297;
              }
              else
              {
                result = PDAoverlayPDA_10648((unint64_t)*v14, 0xFFFFu, v300, (unsigned __int16)v296);
                v288 = v713;
                v8 = v736;
                v20 = v750;
                v12 = v771;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v287;
          v301 = &v23[v287];
          if ((unint64_t)v301 >= v12)
            v302 = v292;
          else
            v302 = 0;
          v289 += v288 + v302;
          v23 = &v301[v302];
          v7 = (__int16 *)((char *)v7 + v290);
          v14 = (int8x8_t *)((char *)v14 + v291);
          --v293;
        }
        while (v293);
        if (v727)
        {
          v303 = v734 + 8 * v732;
          v304 = v667;
          if (v303 < v727)
            v304 = 0;
          v289 = (unsigned __int16 *)&v733[v730 + v304];
          v305 = v687;
          if (v303 < v727)
            v305 = 0;
          v23 = (unint64_t *)(v303 + 8 * v305);
          v12 += 8 * v305 + 8 * v732;
          v733 += v730 + v304;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v289 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 16:
      v306 = v25;
      v307 = v20;
      v308 = (unsigned __int16 *)v733;
      v688 = -(v732 * v22);
      v714 = v20;
      v668 = -(uint64_t)(v730 * v22);
      v309 = 2 * v8;
      v310 = 8 * v25;
      v311 = -(uint64_t)v21;
      do
      {
        v312 = v731;
        v772 = v12;
        do
        {
          if (*v16)
          {
            v313 = v20 ? *v308 : 0xFFFF;
            v314 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v315 = v313 - ((v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16);
            v316 = v315;
            if ((_WORD)v315)
            {
              v317 = HIWORD(*v23);
              v318 = (unsigned __int16)WORD2(*v23) * v314;
              v319 = ((unint64_t)(v317
                                       - ((v314 * (_DWORD)v317 + ((v314 * v317) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v318 + HIWORD(v318) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v314 + ((WORD1(*v23) * v314) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v314 + (((unsigned __int16)*v23 * v314) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAdarkenPDA_10650((unint64_t)*v14, (unsigned __int16)*v7, v319, (unsigned __int16)v315);
                  v307 = v714;
                  v8 = v736;
                  v20 = v750;
                  v12 = v772;
                  v319 = result;
                }
                *v14 = (int8x8_t)v319;
                *v7 = v316;
              }
              else
              {
                result = PDAdarkenPDA_10650((unint64_t)*v14, 0xFFFFu, v319, (unsigned __int16)v315);
                v307 = v714;
                v8 = v736;
                v20 = v750;
                v12 = v772;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v306;
          v320 = &v23[v306];
          if ((unint64_t)v320 >= v12)
            v321 = v311;
          else
            v321 = 0;
          v308 += v307 + v321;
          v23 = &v320[v321];
          v7 = (__int16 *)((char *)v7 + v309);
          v14 = (int8x8_t *)((char *)v14 + v310);
          --v312;
        }
        while (v312);
        if (v727)
        {
          v322 = v734 + 8 * v732;
          v323 = v668;
          if (v322 < v727)
            v323 = 0;
          v308 = (unsigned __int16 *)&v733[v730 + v323];
          v324 = v688;
          if (v322 < v727)
            v324 = 0;
          v23 = (unint64_t *)(v322 + 8 * v324);
          v12 += 8 * v324 + 8 * v732;
          v733 += v730 + v323;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v308 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 17:
      v325 = v25;
      v326 = v20;
      v327 = (unsigned __int16 *)v733;
      v689 = -(v732 * v22);
      v715 = v20;
      v669 = -(uint64_t)(v730 * v22);
      v328 = 2 * v8;
      v329 = 8 * v25;
      v330 = -(uint64_t)v21;
      do
      {
        v331 = v731;
        v773 = v12;
        do
        {
          if (*v16)
          {
            v332 = v20 ? *v327 : 0xFFFF;
            v333 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v334 = v332 - ((v332 * v333 + ((v332 * v333) >> 16) + 1) >> 16);
            v335 = v334;
            if ((_WORD)v334)
            {
              v336 = HIWORD(*v23);
              v337 = (unsigned __int16)WORD2(*v23) * v333;
              v338 = ((unint64_t)(v336
                                       - ((v333 * (_DWORD)v336 + ((v333 * v336) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v337 + HIWORD(v337) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v333 + ((WORD1(*v23) * v333) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v333 + (((unsigned __int16)*v23 * v333) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAlightenPDA_10649((unint64_t)*v14, (unsigned __int16)*v7, v338, (unsigned __int16)v334);
                  v326 = v715;
                  v8 = v736;
                  v20 = v750;
                  v12 = v773;
                  v338 = result;
                }
                *v14 = (int8x8_t)v338;
                *v7 = v335;
              }
              else
              {
                result = PDAlightenPDA_10649((unint64_t)*v14, 0xFFFFu, v338, (unsigned __int16)v334);
                v326 = v715;
                v8 = v736;
                v20 = v750;
                v12 = v773;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v325;
          v339 = &v23[v325];
          if ((unint64_t)v339 >= v12)
            v340 = v330;
          else
            v340 = 0;
          v327 += v326 + v340;
          v23 = &v339[v340];
          v7 = (__int16 *)((char *)v7 + v328);
          v14 = (int8x8_t *)((char *)v14 + v329);
          --v331;
        }
        while (v331);
        if (v727)
        {
          v341 = v734 + 8 * v732;
          v342 = v669;
          if (v341 < v727)
            v342 = 0;
          v327 = (unsigned __int16 *)&v733[v730 + v342];
          v343 = v689;
          if (v341 < v727)
            v343 = 0;
          v23 = (unint64_t *)(v341 + 8 * v343);
          v12 += 8 * v343 + 8 * v732;
          v733 += v730 + v342;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v327 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 18:
      v344 = v25;
      v345 = v20;
      v346 = (unsigned __int16 *)v733;
      v690 = -(v732 * v22);
      v716 = v20;
      v670 = -(uint64_t)(v730 * v22);
      v347 = 2 * v8;
      v348 = 8 * v25;
      v349 = -(uint64_t)v21;
      do
      {
        v350 = v731;
        v774 = v12;
        do
        {
          if (*v16)
          {
            v351 = v20 ? *v346 : 0xFFFF;
            v352 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v353 = v351 - ((v351 * v352 + ((v351 * v352) >> 16) + 1) >> 16);
            v354 = v353;
            if ((_WORD)v353)
            {
              v355 = HIWORD(*v23);
              v356 = (unsigned __int16)WORD2(*v23) * v352;
              v357 = ((unint64_t)(v355
                                       - ((v352 * (_DWORD)v355 + ((v352 * v355) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v356 + HIWORD(v356) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v352 + ((WORD1(*v23) * v352) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v352 + (((unsigned __int16)*v23 * v352) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAcolordodgePDA_10651((unint64_t)*v14, (unsigned __int16)*v7, v357, (unsigned __int16)v353);
                  v345 = v716;
                  v8 = v736;
                  v20 = v750;
                  v12 = v774;
                  v357 = result;
                }
                *v14 = (int8x8_t)v357;
                *v7 = v354;
              }
              else
              {
                result = PDAcolordodgePDA_10651((unint64_t)*v14, 0xFFFFu, v357, (unsigned __int16)v353);
                v345 = v716;
                v8 = v736;
                v20 = v750;
                v12 = v774;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v344;
          v358 = &v23[v344];
          if ((unint64_t)v358 >= v12)
            v359 = v349;
          else
            v359 = 0;
          v346 += v345 + v359;
          v23 = &v358[v359];
          v7 = (__int16 *)((char *)v7 + v347);
          v14 = (int8x8_t *)((char *)v14 + v348);
          --v350;
        }
        while (v350);
        if (v727)
        {
          v360 = v734 + 8 * v732;
          v361 = v670;
          if (v360 < v727)
            v361 = 0;
          v346 = (unsigned __int16 *)&v733[v730 + v361];
          v362 = v690;
          if (v360 < v727)
            v362 = 0;
          v23 = (unint64_t *)(v360 + 8 * v362);
          v12 += 8 * v362 + 8 * v732;
          v733 += v730 + v361;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v346 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 19:
      v363 = v25;
      v364 = v20;
      v365 = (unsigned __int16 *)v733;
      v691 = -(v732 * v22);
      v717 = v20;
      v671 = -(uint64_t)(v730 * v22);
      v366 = 2 * v8;
      v367 = 8 * v25;
      v368 = -(uint64_t)v21;
      do
      {
        v369 = v731;
        v775 = v12;
        do
        {
          if (*v16)
          {
            v370 = v20 ? *v365 : 0xFFFF;
            v371 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v372 = v370 - ((v370 * v371 + ((v370 * v371) >> 16) + 1) >> 16);
            v373 = v372;
            if ((_WORD)v372)
            {
              v374 = HIWORD(*v23);
              v375 = (unsigned __int16)WORD2(*v23) * v371;
              v376 = ((unint64_t)(v374
                                       - ((v371 * (_DWORD)v374 + ((v371 * v374) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v375 + HIWORD(v375) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v371 + ((WORD1(*v23) * v371) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v371 + (((unsigned __int16)*v23 * v371) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAcolorburnPDA_10652((unint64_t)*v14, (unsigned __int16)*v7, v376, (unsigned __int16)v372);
                  v364 = v717;
                  v8 = v736;
                  v20 = v750;
                  v12 = v775;
                  v376 = result;
                }
                *v14 = (int8x8_t)v376;
                *v7 = v373;
              }
              else
              {
                result = PDAcolorburnPDA_10652((unint64_t)*v14, 0xFFFFu, v376, (unsigned __int16)v372);
                v364 = v717;
                v8 = v736;
                v20 = v750;
                v12 = v775;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v363;
          v377 = &v23[v363];
          if ((unint64_t)v377 >= v12)
            v378 = v368;
          else
            v378 = 0;
          v365 += v364 + v378;
          v23 = &v377[v378];
          v7 = (__int16 *)((char *)v7 + v366);
          v14 = (int8x8_t *)((char *)v14 + v367);
          --v369;
        }
        while (v369);
        if (v727)
        {
          v379 = v734 + 8 * v732;
          v380 = v671;
          if (v379 < v727)
            v380 = 0;
          v365 = (unsigned __int16 *)&v733[v730 + v380];
          v381 = v691;
          if (v379 < v727)
            v381 = 0;
          v23 = (unint64_t *)(v379 + 8 * v381);
          v12 += 8 * v381 + 8 * v732;
          v733 += v730 + v380;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v365 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 20:
      v382 = v25;
      v383 = v20;
      v384 = (unsigned __int16 *)v733;
      v692 = -(v732 * v22);
      v718 = v20;
      v672 = -(uint64_t)(v730 * v22);
      v385 = 2 * v8;
      v386 = 8 * v25;
      v387 = -(uint64_t)v21;
      do
      {
        v388 = v731;
        v776 = v12;
        do
        {
          if (*v16)
          {
            v389 = v20 ? *v384 : 0xFFFF;
            v390 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v391 = v389 - ((v389 * v390 + ((v389 * v390) >> 16) + 1) >> 16);
            v392 = v391;
            if ((_WORD)v391)
            {
              v393 = HIWORD(*v23);
              v394 = (unsigned __int16)WORD2(*v23) * v390;
              v395 = ((unint64_t)(v393
                                       - ((v390 * (_DWORD)v393 + ((v390 * v393) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v394 + HIWORD(v394) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v390 + ((WORD1(*v23) * v390) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v390 + (((unsigned __int16)*v23 * v390) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAsoftlightPDA_10654((unint64_t)*v14, (unsigned __int16)*v7, v395, (unsigned __int16)v391);
                  v383 = v718;
                  v8 = v736;
                  v20 = v750;
                  v12 = v776;
                  v395 = result;
                }
                *v14 = (int8x8_t)v395;
                *v7 = v392;
              }
              else
              {
                result = PDAsoftlightPDA_10654((unint64_t)*v14, 0xFFFFu, v395, (unsigned __int16)v391);
                v383 = v718;
                v8 = v736;
                v20 = v750;
                v12 = v776;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v382;
          v396 = &v23[v382];
          if ((unint64_t)v396 >= v12)
            v397 = v387;
          else
            v397 = 0;
          v384 += v383 + v397;
          v23 = &v396[v397];
          v7 = (__int16 *)((char *)v7 + v385);
          v14 = (int8x8_t *)((char *)v14 + v386);
          --v388;
        }
        while (v388);
        if (v727)
        {
          v398 = v734 + 8 * v732;
          v399 = v672;
          if (v398 < v727)
            v399 = 0;
          v384 = (unsigned __int16 *)&v733[v730 + v399];
          v400 = v692;
          if (v398 < v727)
            v400 = 0;
          v23 = (unint64_t *)(v398 + 8 * v400);
          v12 += 8 * v400 + 8 * v732;
          v733 += v730 + v399;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v384 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 21:
      v401 = v25;
      v402 = v20;
      v403 = (unsigned __int16 *)v733;
      v693 = -(v732 * v22);
      v719 = v20;
      v673 = -(uint64_t)(v730 * v22);
      v404 = 2 * v8;
      v405 = 8 * v25;
      v406 = -(uint64_t)v21;
      do
      {
        v407 = v731;
        v777 = v12;
        do
        {
          if (*v16)
          {
            v408 = v20 ? *v403 : 0xFFFF;
            v409 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v410 = v408 - ((v408 * v409 + ((v408 * v409) >> 16) + 1) >> 16);
            v411 = v410;
            if ((_WORD)v410)
            {
              v412 = HIWORD(*v23);
              v413 = (unsigned __int16)WORD2(*v23) * v409;
              v414 = ((unint64_t)(v412
                                       - ((v409 * (_DWORD)v412 + ((v409 * v412) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v413 + HIWORD(v413) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v409 + ((WORD1(*v23) * v409) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v409 + (((unsigned __int16)*v23 * v409) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAhardlightPDA_10653((unint64_t)*v14, (unsigned __int16)*v7, v414, (unsigned __int16)v410);
                  v402 = v719;
                  v8 = v736;
                  v20 = v750;
                  v12 = v777;
                  v414 = result;
                }
                *v14 = (int8x8_t)v414;
                *v7 = v411;
              }
              else
              {
                result = PDAhardlightPDA_10653((unint64_t)*v14, 0xFFFFu, v414, (unsigned __int16)v410);
                v402 = v719;
                v8 = v736;
                v20 = v750;
                v12 = v777;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v401;
          v415 = &v23[v401];
          if ((unint64_t)v415 >= v12)
            v416 = v406;
          else
            v416 = 0;
          v403 += v402 + v416;
          v23 = &v415[v416];
          v7 = (__int16 *)((char *)v7 + v404);
          v14 = (int8x8_t *)((char *)v14 + v405);
          --v407;
        }
        while (v407);
        if (v727)
        {
          v417 = v734 + 8 * v732;
          v418 = v673;
          if (v417 < v727)
            v418 = 0;
          v403 = (unsigned __int16 *)&v733[v730 + v418];
          v419 = v693;
          if (v417 < v727)
            v419 = 0;
          v23 = (unint64_t *)(v417 + 8 * v419);
          v12 += 8 * v419 + 8 * v732;
          v733 += v730 + v418;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v403 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 22:
      v420 = v25;
      v421 = v20;
      v422 = (unsigned __int16 *)v733;
      v694 = -(v732 * v22);
      v720 = v20;
      v674 = -(uint64_t)(v730 * v22);
      v423 = 2 * v8;
      v424 = 8 * v25;
      v425 = -(uint64_t)v21;
      do
      {
        v426 = v731;
        v778 = v12;
        do
        {
          if (*v16)
          {
            v427 = v20 ? *v422 : 0xFFFF;
            v428 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v429 = v427 - ((v427 * v428 + ((v427 * v428) >> 16) + 1) >> 16);
            v430 = v429;
            if ((_WORD)v429)
            {
              v431 = HIWORD(*v23);
              v432 = (unsigned __int16)WORD2(*v23) * v428;
              v433 = ((unint64_t)(v431
                                       - ((v428 * (_DWORD)v431 + ((v428 * v431) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v432 + HIWORD(v432) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v428 + ((WORD1(*v23) * v428) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v428 + (((unsigned __int16)*v23 * v428) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAdifferencePDA_10655((unint64_t)*v14, (unsigned __int16)*v7, v433, (unsigned __int16)v429);
                  v421 = v720;
                  v8 = v736;
                  v20 = v750;
                  v12 = v778;
                  v433 = result;
                }
                *v14 = (int8x8_t)v433;
                *v7 = v430;
              }
              else
              {
                result = PDAdifferencePDA_10655((unint64_t)*v14, 0xFFFFu, v433, (unsigned __int16)v429);
                v421 = v720;
                v8 = v736;
                v20 = v750;
                v12 = v778;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v420;
          v434 = &v23[v420];
          if ((unint64_t)v434 >= v12)
            v435 = v425;
          else
            v435 = 0;
          v422 += v421 + v435;
          v23 = &v434[v435];
          v7 = (__int16 *)((char *)v7 + v423);
          v14 = (int8x8_t *)((char *)v14 + v424);
          --v426;
        }
        while (v426);
        if (v727)
        {
          v436 = v734 + 8 * v732;
          v437 = v674;
          if (v436 < v727)
            v437 = 0;
          v422 = (unsigned __int16 *)&v733[v730 + v437];
          v438 = v694;
          if (v436 < v727)
            v438 = 0;
          v23 = (unint64_t *)(v436 + 8 * v438);
          v12 += 8 * v438 + 8 * v732;
          v733 += v730 + v437;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v422 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 23:
      v439 = v25;
      v440 = v20;
      v441 = (unsigned __int16 *)v733;
      v695 = -(v732 * v22);
      v721 = v20;
      v675 = -(uint64_t)(v730 * v22);
      v442 = 2 * v8;
      v443 = 8 * v25;
      v444 = -(uint64_t)v21;
      do
      {
        v445 = v731;
        v779 = v12;
        do
        {
          if (*v16)
          {
            v446 = v20 ? *v441 : 0xFFFF;
            v447 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v448 = v446 - ((v446 * v447 + ((v446 * v447) >> 16) + 1) >> 16);
            v449 = v448;
            if ((_WORD)v448)
            {
              v450 = HIWORD(*v23);
              v451 = (unsigned __int16)WORD2(*v23) * v447;
              v452 = ((unint64_t)(v450
                                       - ((v447 * (_DWORD)v450 + ((v447 * v450) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v451 + HIWORD(v451) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v447 + ((WORD1(*v23) * v447) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v447 + (((unsigned __int16)*v23 * v447) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAexclusionPDA_10656((unint64_t)*v14, (unsigned __int16)*v7, v452, (unsigned __int16)v448);
                  v440 = v721;
                  v8 = v736;
                  v20 = v750;
                  v12 = v779;
                  v452 = result;
                }
                *v14 = (int8x8_t)v452;
                *v7 = v449;
              }
              else
              {
                result = PDAexclusionPDA_10656((unint64_t)*v14, 0xFFFFu, v452, (unsigned __int16)v448);
                v440 = v721;
                v8 = v736;
                v20 = v750;
                v12 = v779;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v439;
          v453 = &v23[v439];
          if ((unint64_t)v453 >= v12)
            v454 = v444;
          else
            v454 = 0;
          v441 += v440 + v454;
          v23 = &v453[v454];
          v7 = (__int16 *)((char *)v7 + v442);
          v14 = (int8x8_t *)((char *)v14 + v443);
          --v445;
        }
        while (v445);
        if (v727)
        {
          v455 = v734 + 8 * v732;
          v456 = v675;
          if (v455 < v727)
            v456 = 0;
          v441 = (unsigned __int16 *)&v733[v730 + v456];
          v457 = v695;
          if (v455 < v727)
            v457 = 0;
          v23 = (unint64_t *)(v455 + 8 * v457);
          v12 += 8 * v457 + 8 * v732;
          v733 += v730 + v456;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v441 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 24:
      v458 = v25;
      v459 = v20;
      v460 = (unsigned __int16 *)v733;
      v696 = -(v732 * v22);
      v722 = v20;
      v676 = -(uint64_t)(v730 * v22);
      v461 = 2 * v8;
      v462 = 8 * v25;
      v463 = -(uint64_t)v21;
      do
      {
        v464 = v731;
        v780 = v12;
        do
        {
          if (*v16)
          {
            v465 = v20 ? *v460 : 0xFFFF;
            v466 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v467 = v465 - ((v465 * v466 + ((v465 * v466) >> 16) + 1) >> 16);
            v468 = v467;
            if ((_WORD)v467)
            {
              v469 = HIWORD(*v23);
              v470 = (unsigned __int16)WORD2(*v23) * v466;
              v471 = ((unint64_t)(v469
                                       - ((v466 * (_DWORD)v469 + ((v466 * v469) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v470 + HIWORD(v470) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v466 + ((WORD1(*v23) * v466) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v466 + (((unsigned __int16)*v23 * v466) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAhuePDA_10657((unint64_t)*v14, (unsigned __int16)*v7, v471, (unsigned __int16)v467);
                  v459 = v722;
                  v8 = v736;
                  v20 = v750;
                  v12 = v780;
                  v471 = result;
                }
                *v14 = (int8x8_t)v471;
                *v7 = v468;
              }
              else
              {
                result = PDAhuePDA_10657((unint64_t)*v14, 0xFFFFu, v471, (unsigned __int16)v467);
                v459 = v722;
                v8 = v736;
                v20 = v750;
                v12 = v780;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v458;
          v472 = &v23[v458];
          if ((unint64_t)v472 >= v12)
            v473 = v463;
          else
            v473 = 0;
          v460 += v459 + v473;
          v23 = &v472[v473];
          v7 = (__int16 *)((char *)v7 + v461);
          v14 = (int8x8_t *)((char *)v14 + v462);
          --v464;
        }
        while (v464);
        if (v727)
        {
          v474 = v734 + 8 * v732;
          v475 = v676;
          if (v474 < v727)
            v475 = 0;
          v460 = (unsigned __int16 *)&v733[v730 + v475];
          v476 = v696;
          if (v474 < v727)
            v476 = 0;
          v23 = (unint64_t *)(v474 + 8 * v476);
          v12 += 8 * v476 + 8 * v732;
          v733 += v730 + v475;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v460 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 25:
      v477 = v25;
      v478 = v20;
      v479 = (unsigned __int16 *)v733;
      v697 = -(v732 * v22);
      v723 = v20;
      v677 = -(uint64_t)(v730 * v22);
      v480 = 2 * v8;
      v481 = 8 * v25;
      v482 = -(uint64_t)v21;
      do
      {
        v483 = v731;
        v781 = v12;
        do
        {
          if (*v16)
          {
            v484 = v20 ? *v479 : 0xFFFF;
            v485 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v486 = v484 - ((v484 * v485 + ((v484 * v485) >> 16) + 1) >> 16);
            v487 = v486;
            if ((_WORD)v486)
            {
              v488 = HIWORD(*v23);
              v489 = (unsigned __int16)WORD2(*v23) * v485;
              v490 = ((unint64_t)(v488
                                       - ((v485 * (_DWORD)v488 + ((v485 * v488) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v489 + HIWORD(v489) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v485 + ((WORD1(*v23) * v485) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v485 + (((unsigned __int16)*v23 * v485) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAsaturationPDA_10658((unint64_t)*v14, (unsigned __int16)*v7, v490, (unsigned __int16)v486);
                  v478 = v723;
                  v8 = v736;
                  v20 = v750;
                  v12 = v781;
                  v490 = result;
                }
                *v14 = (int8x8_t)v490;
                *v7 = v487;
              }
              else
              {
                result = PDAsaturationPDA_10658((unint64_t)*v14, 0xFFFFu, v490, (unsigned __int16)v486);
                v478 = v723;
                v8 = v736;
                v20 = v750;
                v12 = v781;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v477;
          v491 = &v23[v477];
          if ((unint64_t)v491 >= v12)
            v492 = v482;
          else
            v492 = 0;
          v479 += v478 + v492;
          v23 = &v491[v492];
          v7 = (__int16 *)((char *)v7 + v480);
          v14 = (int8x8_t *)((char *)v14 + v481);
          --v483;
        }
        while (v483);
        if (v727)
        {
          v493 = v734 + 8 * v732;
          v494 = v677;
          if (v493 < v727)
            v494 = 0;
          v479 = (unsigned __int16 *)&v733[v730 + v494];
          v495 = v697;
          if (v493 < v727)
            v495 = 0;
          v23 = (unint64_t *)(v493 + 8 * v495);
          v12 += 8 * v495 + 8 * v732;
          v733 += v730 + v494;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v479 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 26:
      v496 = v25;
      v497 = v20;
      v498 = (unsigned __int16 *)v733;
      v698 = -(v732 * v22);
      v724 = v20;
      v678 = -(uint64_t)(v730 * v22);
      v499 = 2 * v8;
      v500 = 8 * v25;
      v501 = -(uint64_t)v21;
      do
      {
        v502 = v731;
        v782 = v12;
        do
        {
          if (*v16)
          {
            v503 = v20 ? *v498 : 0xFFFF;
            v504 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v505 = v503 - ((v503 * v504 + ((v503 * v504) >> 16) + 1) >> 16);
            if (v505)
            {
              v506 = HIWORD(*v23);
              v507 = (unsigned __int16)WORD2(*v23) * v504;
              result = ((unint64_t)(v506
                                         - ((v504 * (_DWORD)v506 + ((v504 * v506) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v507 + HIWORD(v507) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v504 + ((WORD1(*v23) * v504) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v504 + (((unsigned __int16)*v23 * v504) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAluminosityPDA_10659(result, (unsigned __int16)(v503 - ((v503 * v504 + ((v503 * v504) >> 16) + 1) >> 16)), (unint64_t)*v14, (unsigned __int16)*v7);
                  v497 = v724;
                  v8 = v736;
                  v20 = v750;
                  v12 = v782;
                }
                *v14 = (int8x8_t)result;
                *v7 = v505;
              }
              else
              {
                result = PDAluminosityPDA_10659(result, (unsigned __int16)(v503 - ((v503 * v504 + ((v503 * v504) >> 16) + 1) >> 16)), (unint64_t)*v14, 0xFFFFu);
                v497 = v724;
                v8 = v736;
                v20 = v750;
                v12 = v782;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v496;
          v508 = &v23[v496];
          if ((unint64_t)v508 >= v12)
            v509 = v501;
          else
            v509 = 0;
          v498 += v497 + v509;
          v23 = &v508[v509];
          v7 = (__int16 *)((char *)v7 + v499);
          v14 = (int8x8_t *)((char *)v14 + v500);
          --v502;
        }
        while (v502);
        if (v727)
        {
          v510 = v734 + 8 * v732;
          v511 = v678;
          if (v510 < v727)
            v511 = 0;
          v498 = (unsigned __int16 *)&v733[v730 + v511];
          v512 = v698;
          if (v510 < v727)
            v512 = 0;
          v23 = (unint64_t *)(v510 + 8 * v512);
          v12 += 8 * v512 + 8 * v732;
          v733 += v730 + v511;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v498 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 27:
      v513 = v25;
      v514 = v20;
      v515 = (unsigned __int16 *)v733;
      v699 = -(v732 * v22);
      v725 = v20;
      v679 = -(uint64_t)(v730 * v22);
      v516 = 2 * v8;
      v517 = 8 * v25;
      v518 = -(uint64_t)v21;
      do
      {
        v519 = v731;
        v783 = v12;
        do
        {
          if (*v16)
          {
            v520 = v20 ? *v515 : 0xFFFF;
            v521 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v522 = v520 - ((v520 * v521 + ((v520 * v521) >> 16) + 1) >> 16);
            v523 = v522;
            if ((_WORD)v522)
            {
              v524 = HIWORD(*v23);
              v525 = (unsigned __int16)WORD2(*v23) * v521;
              v526 = ((unint64_t)(v524
                                       - ((v521 * (_DWORD)v524 + ((v521 * v524) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v525 + HIWORD(v525) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v521 + ((WORD1(*v23) * v521) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v521 + (((unsigned __int16)*v23 * v521) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  result = PDAluminosityPDA_10659((unint64_t)*v14, (unsigned __int16)*v7, v526, (unsigned __int16)v522);
                  v514 = v725;
                  v8 = v736;
                  v20 = v750;
                  v12 = v783;
                  v526 = result;
                }
                *v14 = (int8x8_t)v526;
                *v7 = v523;
              }
              else
              {
                result = PDAluminosityPDA_10659((unint64_t)*v14, 0xFFFFu, v526, (unsigned __int16)v522);
                v514 = v725;
                v8 = v736;
                v20 = v750;
                v12 = v783;
                *v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v513;
          v527 = &v23[v513];
          if ((unint64_t)v527 >= v12)
            v528 = v518;
          else
            v528 = 0;
          v515 += v514 + v528;
          v23 = &v527[v528];
          v7 = (__int16 *)((char *)v7 + v516);
          v14 = (int8x8_t *)((char *)v14 + v517);
          --v519;
        }
        while (v519);
        if (v727)
        {
          v529 = v734 + 8 * v732;
          v530 = v679;
          if (v529 < v727)
            v530 = 0;
          v515 = (unsigned __int16 *)&v733[v730 + v530];
          v531 = v699;
          if (v529 < v727)
            v531 = 0;
          v23 = (unint64_t *)(v529 + 8 * v531);
          v12 += 8 * v531 + 8 * v732;
          v733 += v730 + v530;
          v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v515 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    default:
      return result;
  }
  do
  {
    v562 = v731;
    v563 = v12;
    do
    {
      v564 = *v16;
      if (!*v16)
        goto LABEL_703;
      if (v564 == 255)
      {
        v565 = (unsigned __int16)*v561;
        if (!*v561)
          goto LABEL_703;
        if (v565 == 0xFFFF)
        {
          *v14 = (int8x8_t)*v23;
          goto LABEL_703;
        }
        v570 = *v23;
        v571 = (unint64_t)*v14;
        v572 = v565 ^ 0xFFFF;
      }
      else
      {
        v566 = (unsigned __int16)*v561;
        v567 = (v564 | (v564 << 8)) ^ 0xFFFF;
        v568 = v567 * v566 + ((v567 * v566) >> 16) + 1;
        if (v566 == HIWORD(v568))
          goto LABEL_703;
        v569 = (unsigned __int16)WORD2(*v23) * v567;
        v570 = ((HIWORD(*v23) - ((v567 * HIWORD(*v23) + ((v567 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v569 + HIWORD(v569) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v567 + ((WORD1(*v23) * v567) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v567 + (((unsigned __int16)*v23 * v567) >> 16) + 1) >> 16));
        v571 = (unint64_t)*v14;
        v572 = (unsigned __int16)(~(_WORD)v566 + HIWORD(v568));
      }
      result = (uint64_t)cmyk64_DplusDM(v14, v570, v571, v572);
      v12 = v563;
LABEL_703:
      v16 += v53;
      v573 = &v23[v53];
      if ((unint64_t)v573 >= v12)
        v574 = v560;
      else
        v574 = 0;
      v561 += v559 + v574;
      v23 = &v573[v574];
      v14 += v53;
      --v562;
    }
    while (v562);
    if (v727)
    {
      v575 = v734 + 8 * v732;
      v576 = v757;
      if (v575 < v727)
        v576 = 0;
      v561 = &v733[v730 + v576];
      v577 = v785;
      if (v575 < v727)
        v577 = 0;
      v23 = (unint64_t *)(v575 + 8 * v577);
      v12 += 8 * v577 + 8 * v732;
      v733 += v730 + v576;
      v734 = (unint64_t)v23;
    }
    else
    {
      v23 += v732;
      v561 += v730;
    }
    v16 += v729;
    v14 += v728;
    --v735;
  }
  while (v735);
  return result;
}

unint64_t PIXELCONSTANT_10663(float *a1, int a2, float32x2_t *a3, float a4, double a5, double a6, double a7)
{
  float v7;
  float v8;
  float v9;
  int v10;
  float v11;
  float32x2_t v12;
  float32x2_t v13;
  int8x8_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  uint64_t v32;
  float v33;

  *(float *)&a7 = *a1;
  *(float *)&a6 = a1[1];
  v7 = *(float *)&a6;
  if (*(float *)&a6 >= a4)
  {
    v7 = a4;
    if (*(float *)&a7 > a4)
      v7 = *a1;
  }
  v8 = a1[3];
  v9 = v7 * a1[2];
  if (a3)
    v10 = a2;
  else
    v10 = 0;
  if (v10 == 1)
  {
    v33 = a1[1];
    if (a3->f32[0] <= *(float *)&a6)
    {
      v33 = a3->f32[0];
      if (a3->f32[0] < *(float *)&a7)
        v33 = *a1;
    }
    LOWORD(v19) = 0;
    v20 = 0;
    LOWORD(v21) = 0;
    v32 = (float)(v8 + (float)((float)(*(float *)&a6 - v33) * v9));
  }
  else
  {
    if (v10 == 4)
    {
      v23 = a3->f32[1];
      v24 = a3[1].f32[0];
      v25 = a3[1].f32[1];
      if (a3->f32[0] < *(float *)&a7)
        v26 = *a1;
      else
        v26 = a3->f32[0];
      if (a3->f32[0] <= *(float *)&a6)
        v27 = v26;
      else
        v27 = a1[1];
      if (v23 < *(float *)&a7)
        v28 = *a1;
      else
        v28 = a3->f32[1];
      if (v23 <= *(float *)&a6)
        v29 = v28;
      else
        v29 = a1[1];
      if (v24 < *(float *)&a7)
        v30 = *a1;
      else
        v30 = a3[1].f32[0];
      if (v24 <= *(float *)&a6)
        v31 = v30;
      else
        v31 = a1[1];
      if (v25 >= *(float *)&a7)
        LODWORD(a7) = a3[1].i32[1];
      if (v25 <= *(float *)&a6)
        *(float *)&a6 = *(float *)&a7;
      v19 = (float)(v8 + (float)(v27 * v9));
      v20 = (float)(v8 + (float)(v29 * v9));
      v21 = (float)(v8 + (float)(v31 * v9));
      v22 = v8 + (float)(*(float *)&a6 * v9);
    }
    else
    {
      if (v10 != 3)
      {
        LOWORD(v19) = 0;
        v20 = 0;
        LOWORD(v21) = 0;
        v32 = (float)(v8 + v9);
        return ((unint64_t)(unsigned __int16)v21 << 32) | (v32 << 48) | (v20 << 16) | (unint64_t)(unsigned __int16)v19;
      }
      v11 = a3[1].f32[0];
      v12 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
      v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0);
      v14 = vbsl_s8((int8x8_t)vcgt_f32(*a3, v12), (int8x8_t)v13, (int8x8_t)vsub_f32(v12, (float32x2_t)vbic_s8((int8x8_t)*a3, (int8x8_t)vcgt_f32(v13, *a3))));
      v15 = 0.0;
      if (v11 >= *(float *)&a7)
        v15 = a3[1].f32[0];
      v16 = *(float *)&a6 - v15;
      if (v11 <= *(float *)&a6)
        v17 = v16;
      else
        v17 = *a1;
      if (*(float *)v14.i32 >= *(float *)&v14.i32[1])
        v18 = *(float *)&v14.i32[1];
      else
        v18 = *(float *)v14.i32;
      if (v17 < v18)
        v18 = v17;
      v19 = (float)(v8 + (float)((float)(*(float *)v14.i32 - v18) * v9));
      v20 = (float)(v8 + (float)((float)(*(float *)&v14.i32[1] - v18) * v9));
      v21 = (float)(v8 + (float)((float)(v17 - v18) * v9));
      v22 = v8 + (float)(v18 * v9);
    }
    v32 = v22;
  }
  return ((unint64_t)(unsigned __int16)v21 << 32) | (v32 << 48) | (v20 << 16) | (unint64_t)(unsigned __int16)v19;
}

_DWORD *CMYK64_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned int v14;

  v11 = PIXELCONSTANT_10663(*(float **)(*(_QWORD *)a1 + 64), a4, a5, a6, a7, a8, a9);
  v13 = v12;
  if (a2 && a3 > 0xB || (a2 = malloc_type_malloc(0x3CuLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_185004D80;
    a2[6] = 0;
    v14 = bswap32(v11);
    *((_WORD *)a2 + 24) = HIWORD(v14);
    *((_QWORD *)a2 + 2) = 1;
    *((_QWORD *)a2 + 4) = a2 + 12;
    *((_WORD *)a2 + 25) = v14;
    *((_WORD *)a2 + 26) = bswap32(HIDWORD(v11)) >> 16;
    *((_WORD *)a2 + 27) = __rev16(HIWORD(v11));
    if (v13 == 0xFFFF)
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    else
    {
      a2[14] = bswap32(v13 | (v13 << 16));
      *((_QWORD *)a2 + 5) = a2 + 14;
    }
  }
  return a2;
}

uint64_t CMYK64_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  int8x8_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  int v10;
  uint16x4_t *v11;
  int v12;
  unsigned __int16 *v13;
  int32x2_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  size_t v20;
  _BYTE *v21;
  _BYTE *v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int16 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  int8x8_t *v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  void *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  int8x8_t *v54;
  int v55;
  unsigned int v56;
  int32x4_t v57;
  int32x2_t v58;
  uint32x4_t v59;
  int v60;
  unsigned int v61;
  int32x4_t v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  int32x4_t v67;
  uint32x4_t v68;
  unsigned int v69;
  unsigned int v70;
  uint32x4_t v71;
  unsigned int v72;
  unsigned int v73;
  uint32x4_t v74;
  unsigned int v75;
  unsigned int v76;
  uint32x4_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  int32x4_t v81;
  uint32x4_t v82;
  __int16 v83;
  int v84;
  int v85;
  unsigned int v86;
  __int16 v87;
  int v88;
  int v89;
  unsigned int v90;
  int v91;
  int v92;
  unsigned int v93;
  __int16 v94;
  int32x4_t v95;
  int v96;
  int32x4_t v97;
  int v98;
  unsigned int v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unint64_t v103;
  uint32x4_t v104;
  int32x2_t v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  unsigned int v112;
  int v113;
  int v114;
  unsigned int v115;
  int v116;
  uint64_t v117;
  int v118;
  int v119;
  int v120;
  uint64_t v121;
  int v122;
  int v123;
  __int16 v124;
  int v125;
  int v126;
  unsigned int v127;
  unint64_t v128;
  unsigned int v129;
  unsigned int v130;
  __int16 v131;
  int v132;
  int v133;
  unsigned int v134;
  unint64_t v135;
  unsigned int v136;
  unsigned int v137;
  __int16 v138;
  int v139;
  int v140;
  unsigned int v141;
  unint64_t v142;
  unsigned int v143;
  unsigned int v144;
  __int16 v145;
  int v146;
  int v147;
  unsigned int v148;
  unint64_t v149;
  unsigned int v150;
  unsigned int v151;
  __int16 v152;
  int v153;
  int v154;
  unsigned int v155;
  unint64_t v156;
  unsigned int v157;
  unsigned int v158;
  __int16 v159;
  int v160;
  int v161;
  unsigned int v162;
  unint64_t v163;
  unsigned int v164;
  unsigned int v165;
  __int16 v166;
  int v167;
  int v168;
  unsigned int v169;
  unint64_t v170;
  unsigned int v171;
  unsigned int v172;
  __int16 v173;
  int v174;
  int v175;
  unsigned int v176;
  unint64_t v177;
  unsigned int v178;
  unsigned int v179;
  __int16 v180;
  int v181;
  int v182;
  unsigned int v183;
  unint64_t v184;
  unsigned int v185;
  unsigned int v186;
  __int16 v187;
  int v188;
  int v189;
  unsigned int v190;
  unint64_t v191;
  unsigned int v192;
  unsigned int v193;
  __int16 v194;
  int v195;
  int v196;
  unsigned int v197;
  unint64_t v198;
  unsigned int v199;
  unsigned int v200;
  __int16 v201;
  int v202;
  int v203;
  unsigned int v204;
  unint64_t v205;
  unsigned int v206;
  unsigned int v207;
  __int16 v208;
  int v209;
  int v210;
  unsigned int v211;
  unint64_t v212;
  unsigned int v213;
  unsigned int v214;
  __int16 v215;
  int v216;
  int v217;
  unsigned int v218;
  unint64_t v219;
  unsigned int v220;
  unsigned int v221;
  __int16 v222;
  int v223;
  int v224;
  unsigned int v225;
  unint64_t v226;
  unsigned int v227;
  unsigned int v228;
  char *v229;
  int *v230;
  uint64_t v231;
  uint64_t v232;
  int32x4_t v233;
  int v234;
  unsigned int v235;
  unsigned int v236;
  int32x4_t v237;
  uint32x4_t v238;
  unsigned int v239;
  int32x4_t v240;
  int32x4_t v241;
  unsigned int v242;
  uint32x4_t v243;
  int32x4_t v244;
  unsigned int v245;
  uint32x4_t v246;
  unsigned int v247;
  unsigned int v248;
  int32x4_t v249;
  uint32x4_t v250;
  int32x4_t v251;
  int v252;
  int32x4_t v253;
  int v254;
  unsigned int v255;
  int32x4_t v256;
  uint32x4_t v257;
  int32x4_t v258;
  int v259;
  int32x4_t v260;
  int v261;
  unsigned int v262;
  int32x4_t v263;
  uint32x4_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  int32x2_t v268;
  int v269;
  unint64_t v270;
  uint64_t v271;
  unsigned int v272;
  char *v273;
  unint64_t v274;
  uint64_t v275;
  uint64_t v276;
  int v277;
  int v278;
  unint64_t v279;
  unsigned int v280;
  unsigned int v281;
  unsigned int v282;
  unsigned int v283;
  uint64_t v284;
  int v285[4];
  __int128 v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  _DWORD v295[1024];
  uint64_t v296;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v296 = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int16 **)(v3 + 96);
  v6 = *(_QWORD *)(v3 + 48);
  v7 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                       + 16 * *(_DWORD *)v3
                       + 8 * (v5 == 0)
                       + 4 * (v6 == 0));
  if ((int)v7 > 27)
    return 0xFFFFFFFFLL;
  v9 = *(unsigned int *)(v3 + 4);
  if ((int)v9 < 1)
    return 0;
  v10 = *(_DWORD *)(v3 + 8);
  if (v10 < 1)
    return 0;
  v11 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) != 0x50000 && v11)
  {
    v12 = *(_DWORD *)(v3 + 128);
    if ((v12 | 8) == 8)
    {
      if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
        CMYK64_mark_constmask(v3, v7);
      else
        CMYK64_mark_pixelmask(v3, v7);
    }
    else
    {
      v16 = *(_DWORD *)(v3 + 112);
      v17 = *(_DWORD *)(v3 + 116);
      v18 = v3;
      v19 = (v16 + 15) & 0xFFFFFFF0;
      v20 = v19 * v17;
      if ((int)v20 <= 4096)
      {
        v22 = v295;
      }
      else
      {
        v21 = malloc_type_malloc(v20, 0x8303D2FuLL);
        if (!v21)
          return 1;
        v22 = v21;
        v11 = *(uint16x4_t **)(v18 + 136);
        v12 = *(_DWORD *)(v18 + 128);
      }
      CGSConvertBitsToMask(v11, *(_DWORD *)(v18 + 124), v22, v19, v16, v17, v12);
      v36 = *(_OWORD *)(v18 + 112);
      v291 = *(_OWORD *)(v18 + 96);
      v292 = v36;
      v37 = *(_OWORD *)(v18 + 144);
      v293 = *(_OWORD *)(v18 + 128);
      v294 = v37;
      v38 = *(_OWORD *)(v18 + 48);
      v287 = *(_OWORD *)(v18 + 32);
      v288 = v38;
      v39 = *(_OWORD *)(v18 + 80);
      v289 = *(_OWORD *)(v18 + 64);
      v290 = v39;
      v40 = *(_OWORD *)(v18 + 16);
      *(_OWORD *)v285 = *(_OWORD *)v18;
      v286 = v40;
      HIDWORD(v292) = (v16 + 15) & 0xFFFFFFF0;
      *((_QWORD *)&v293 + 1) = v22;
      if (BYTE1(v285[0]) << 8 == 1024)
        CMYK64_mark_constmask((uint64_t)v285, v7);
      else
        CMYK64_mark_pixelmask((uint64_t)v285, v7);
      if (v22 != (_BYTE *)v295)
      {
        v41 = v22;
        goto LABEL_354;
      }
    }
    return 1;
  }
  if ((*(_DWORD *)v3 & 0xFF00) != 0x400)
  {
    CMYK64_mark_pixelshape(v3, v7, v4);
    return 1;
  }
  v295[0] = *(_DWORD *)(v3 + 4);
  v285[0] = v10;
  v13 = *(unsigned __int16 **)(v3 + 88);
  v283 = *v13;
  v282 = v13[1];
  v281 = v13[2];
  v266 = __rev16(v281);
  v280 = v13[3];
  v265 = __rev16(v280);
  v14 = (int32x2_t)(__PAIR64__(__rev16(v282), bswap32(v283)) >> 16);
  if (v5)
    v15 = bswap32(*v5) >> 16;
  else
    v15 = 0xFFFF;
  v268 = v14;
  v23 = (v266 << 32) | (v265 << 48) | *(_QWORD *)&v14;
  v24 = *(_QWORD *)(v3 + 40);
  v25 = (unint64_t)*(int *)(v3 + 28) >> 3;
  v27 = *(int *)(v3 + 12);
  v26 = *(int *)(v3 + 16);
  if (v6)
  {
    v274 = (unint64_t)*(int *)(v3 + 32) >> 1;
    v272 = 1;
    v273 = (char *)(v6 + 2 * (v27 + v274 * v26));
  }
  else
  {
    v273 = 0;
    v274 = 0;
    v272 = 0;
  }
  v28 = ~(_WORD)v15;
  v29 = v24 + 8 * (v27 + v26 * v25);
  v269 = v7;
  v270 = (unint64_t)*(int *)(v3 + 28) >> 3;
  v267 = v3;
  v271 = v29;
  if (v11)
  {
    shape_enum_clip_alloc(v2, v3, (int *)v11, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v9, v10);
    v31 = v30;
    v32 = v273;
    v279 = v274;
    if (v30)
      goto LABEL_36;
    return 1;
  }
  v31 = 0;
  if (v6)
    v33 = v9;
  else
    v33 = 0;
  v32 = v273;
  v278 = v9;
  v279 = v274 - v33;
  v34 = v9;
  v35 = (int8x8_t *)(v24 + 8 * (v27 + v26 * v25));
  while (2)
  {
    v276 = v25 - v34;
    switch((int)v7)
    {
      case 0:
        v275 = v31;
        v43 = v276 + v278;
        v44 = v285[0] - 1;
        v45 = (v43 * v44) & (v43 >> 63);
        if (v43 < 0)
          v43 = -v43;
        v277 = v285[0];
        CGBlt_fillBytes(8 * v278, v285[0], 0, (char *)&v35[v45], 8 * v43);
        if (!v6)
          goto LABEL_350;
        v46 = v279 + v278;
        v47 = (v46 * v44) & (v46 >> 63);
        if (v46 < 0)
          v46 = -v46;
        v32 += 2 * v47;
        v48 = 2 * v278;
        v279 = v46;
        v49 = 2 * v46;
        v50 = v277;
        v51 = 0;
        goto LABEL_364;
      case 1:
        v275 = v31;
        v52 = v276 + v278;
        if (v52 < 0)
        {
          v35 += v52 * (v285[0] - 1);
          v52 = -v52;
        }
        v53 = *(_QWORD *)(v267 + 88);
        if (v53)
        {
          v54 = v35;
          v55 = v285[0];
          CGSFillDRAM64(v54, 8 * v52, 8 * v278, v285[0], v53, 8, 8, 1, 0, 0);
        }
        else
        {
          v229 = (char *)v35;
          v55 = v285[0];
          CGBlt_fillBytes(8 * v278, v285[0], 0, v229, 8 * v52);
        }
        if (v6)
        {
          v230 = *(int **)(v267 + 96);
          if (!v230)
            v230 = (int *)&PIXELALPHAPLANARCONSTANT_15938;
          v231 = v279 + v278;
          if (v231 >= 0)
            v232 = v279 + v278;
          else
            v232 = -v231;
          v32 += 2 * (((v279 + v278) * (v55 - 1)) & (v231 >> 63));
          v51 = *v230;
          v48 = 2 * v278;
          v279 = v232;
          v49 = 2 * v232;
          v50 = v55;
LABEL_364:
          CGBlt_fillBytes(v48, v50, v51, v32, v49);
        }
        goto LABEL_350;
      case 2:
        v56 = v278 >> 2;
        v57 = vdupq_n_s32(v28);
        v58.i32[0] = v268.i32[0];
        v58.i32[1] = v268.u16[1];
        v59 = (uint32x4_t)vmovn_hight_s64(v58, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v23), (uint64x2_t)xmmword_185004DA0));
        v60 = v285[0];
        if (v6)
        {
          v61 = v56 + 1;
          v62.i64[0] = 0x100000001;
          v62.i64[1] = 0x100000001;
          do
          {
            v63 = v278;
            if (v278 >= 4)
            {
              v64 = v61;
              do
              {
                v65 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                v66 = bswap32(*(unsigned __int16 *)v32);
                v67.i32[0] = (unsigned __int16)v65;
                v67.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v65), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v67.i32[2] = bswap32(v35->u16[2]) >> 16;
                v67.i32[3] = bswap32(v35->u16[3]) >> 16;
                v68 = (uint32x4_t)vmulq_s32(v67, v57);
                *v35 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v68, v68, 0x10uLL), v62), 0x10uLL)));
                *(_WORD *)v32 = bswap32(v15 + ((v28 * HIWORD(v66) + ((v28 * HIWORD(v66)) >> 16) + 1) >> 16)) >> 16;
                v69 = bswap32(v35[1].u16[1] | (v35[1].u16[0] << 16));
                v70 = bswap32(*((unsigned __int16 *)v32 + 1));
                v67.i32[0] = (unsigned __int16)v69;
                v67.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v69), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v67.i32[2] = bswap32(v35[1].u16[2]) >> 16;
                v67.i32[3] = bswap32(v35[1].u16[3]) >> 16;
                v71 = (uint32x4_t)vmulq_s32(v67, v57);
                v35[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v71, v71, 0x10uLL), v62), 0x10uLL)));
                *((_WORD *)v32 + 1) = bswap32(v15+ ((v28 * HIWORD(v70) + ((v28 * HIWORD(v70)) >> 16) + 1) >> 16)) >> 16;
                v72 = bswap32(v35[2].u16[1] | (v35[2].u16[0] << 16));
                v73 = bswap32(*((unsigned __int16 *)v32 + 2));
                v67.i32[0] = (unsigned __int16)v72;
                v67.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v72), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v67.i32[2] = bswap32(v35[2].u16[2]) >> 16;
                v67.i32[3] = bswap32(v35[2].u16[3]) >> 16;
                v74 = (uint32x4_t)vmulq_s32(v67, v57);
                v35[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v74, v74, 0x10uLL), v62), 0x10uLL)));
                *((_WORD *)v32 + 2) = bswap32(v15+ ((v28 * HIWORD(v73) + ((v28 * HIWORD(v73)) >> 16) + 1) >> 16)) >> 16;
                v75 = bswap32(v35[3].u16[1] | (v35[3].u16[0] << 16));
                v76 = bswap32(*((unsigned __int16 *)v32 + 3));
                v67.i32[0] = (unsigned __int16)v75;
                v67.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v75), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v67.i64[1] = __PAIR64__(bswap32(v35[3].u16[3]) >> 16, bswap32(v35[3].u16[2]) >> 16);
                v77 = (uint32x4_t)vmulq_s32(v67, v57);
                v35[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v77, v77, 0x10uLL), v62), 0x10uLL)));
                *((_WORD *)v32 + 3) = bswap32(v15+ ((v28 * HIWORD(v76) + ((v28 * HIWORD(v76)) >> 16) + 1) >> 16)) >> 16;
                v35 += 4;
                v32 += 8 * v272;
                --v64;
              }
              while (v64 > 1);
              v63 = v278 & 3;
            }
            if (v63 >= 1)
            {
              v78 = v63 + 1;
              do
              {
                v79 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                v80 = bswap32(*(unsigned __int16 *)v32);
                v81.i32[0] = (unsigned __int16)v79;
                v81.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v79), 0x10uLL).i32[1];
                v81.i64[1] = __PAIR64__(bswap32(v35->u16[3]) >> 16, bswap32(v35->u16[2]) >> 16);
                v82 = (uint32x4_t)vmulq_s32(v81, v57);
                *v35++ = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v82, v82, 0x10uLL), v62), 0x10uLL)));
                *(_WORD *)v32 = bswap32(v15 + ((v28 * HIWORD(v80) + ((v28 * HIWORD(v80)) >> 16) + 1) >> 16)) >> 16;
                --v78;
                v32 += 2 * v272;
              }
              while (v78 > 1);
            }
            v35 += v276;
            v32 += 2 * v279;
            --v60;
          }
          while (v60);
        }
        else
        {
          v233.i64[0] = 0x100000001;
          v233.i64[1] = 0x100000001;
          do
          {
            v234 = v278;
            if (v278 >= 4)
            {
              v235 = v56 + 1;
              do
              {
                v236 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                v237.i32[0] = (unsigned __int16)v236;
                v237.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v236), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v237.i32[2] = bswap32(v35->u16[2]) >> 16;
                v237.i32[3] = bswap32(v35->u16[3]) >> 16;
                v238 = (uint32x4_t)vmulq_s32(v237, v57);
                v239 = bswap32(v35[1].u16[1] | (v35[1].u16[0] << 16));
                v240.i32[0] = (unsigned __int16)v239;
                v240.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v239), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v240.i32[2] = bswap32(v35[1].u16[2]) >> 16;
                v240.i32[3] = bswap32(v35[1].u16[3]) >> 16;
                v241 = vmulq_s32(v240, v57);
                *v35 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v238, v238, 0x10uLL), v233), 0x10uLL)));
                v35[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32((uint32x4_t)v241, (uint32x4_t)v241, 0x10uLL), v233), 0x10uLL)));
                v242 = bswap32(v35[2].u16[1] | (v35[2].u16[0] << 16));
                v241.i32[0] = (unsigned __int16)v242;
                v241.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v242), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v241.i32[2] = bswap32(v35[2].u16[2]) >> 16;
                v241.i32[3] = bswap32(v35[2].u16[3]) >> 16;
                v243 = (uint32x4_t)vmulq_s32(v241, v57);
                v244 = (int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v243, v243, 0x10uLL), v233), 0x10uLL);
                v245 = bswap32(v35[3].u16[1] | (v35[3].u16[0] << 16));
                v240.i32[0] = (unsigned __int16)v245;
                v240.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v245), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v240.i32[2] = bswap32(v35[3].u16[2]) >> 16;
                v240.i32[3] = bswap32(v35[3].u16[3]) >> 16;
                v246 = (uint32x4_t)vmulq_s32(v240, v57);
                v35[2] = vrev16_s8((int8x8_t)vmovn_s32(v244));
                v35[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v246, v246, 0x10uLL), v233), 0x10uLL)));
                v35 += 4;
                v32 += 8 * v272;
                --v235;
              }
              while (v235 > 1);
              v234 = v278 & 3;
            }
            if (v234 >= 1)
            {
              v247 = v234 + 1;
              do
              {
                v248 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                v249.i32[0] = (unsigned __int16)v248;
                v249.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v248), 0x10uLL).i32[1];
                v249.i64[1] = __PAIR64__(bswap32(v35->u16[3]) >> 16, bswap32(v35->u16[2]) >> 16);
                v250 = (uint32x4_t)vmulq_s32(v249, v57);
                *v35++ = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v59, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v250, v250, 0x10uLL), v233), 0x10uLL)));
                --v247;
                v32 += 2 * v272;
              }
              while (v247 > 1);
            }
            v35 += v276;
            v32 += 2 * v279;
            --v60;
          }
          while (v60);
        }
        goto LABEL_384;
      case 3:
        v275 = v31;
        v83 = __rev16(v15);
        v84 = v285[0];
        do
        {
          v85 = v278;
          do
          {
            v86 = bswap32(*(unsigned __int16 *)v32) >> 16;
            if (v86 == 0xFFFF)
            {
              v35->i16[0] = v283;
              v35->i16[1] = v282;
              v35->i16[2] = v281;
              v35->i16[3] = v280;
              *(_WORD *)v32 = v83;
            }
            else if (v86)
            {
              CMYK64_DAM(v35, v32, v23, v15, v86);
            }
            else
            {
              *v35 = 0;
              *(_WORD *)v32 = 0;
            }
            ++v35;
            v32 += 2 * v272;
            --v85;
          }
          while (v85);
          v35 += v276;
          v32 += 2 * v279;
          --v84;
        }
        while (v84);
        goto LABEL_81;
      case 4:
        v275 = v31;
        v87 = __rev16(v15);
        v88 = v285[0];
        do
        {
          v89 = v278;
          do
          {
            v90 = bswap32(~*(unsigned __int16 *)v32) >> 16;
            if (v90 == 0xFFFF)
            {
              v35->i16[0] = v283;
              v35->i16[1] = v282;
              v35->i16[2] = v281;
              v35->i16[3] = v280;
              *(_WORD *)v32 = v87;
            }
            else if (v90)
            {
              CMYK64_DAM(v35, v32, v23, v15, v90);
            }
            else
            {
              *v35 = 0;
              *(_WORD *)v32 = 0;
            }
            ++v35;
            v32 += 2 * v272;
            --v89;
          }
          while (v89);
          v35 += v276;
          v32 += 2 * v279;
          --v88;
        }
        while (v88);
LABEL_81:
        v285[0] = 0;
        LODWORD(v7) = v269;
        goto LABEL_347;
      case 5:
        v275 = v31;
        v91 = v285[0];
        do
        {
          v92 = v278;
          do
          {
            v93 = bswap32(*(unsigned __int16 *)v32) >> 16;
            CMYK64_DAMplusDAM(v35, v32, v23, v15, v93, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v93, (unsigned __int16)~(_WORD)v15);
            ++v35;
            v32 += 2 * v272;
            --v92;
          }
          while (v92);
          v35 += v276;
          v32 += 2 * v279;
          --v91;
        }
        while (v91);
        goto LABEL_118;
      case 6:
        v94 = __rev16(v15);
        v95.i32[0] = v268.u16[0];
        v95.i32[1] = vshr_n_u32((uint32x2_t)vdup_lane_s32(v268, 0), 0x10uLL).i32[1];
        v95.i64[1] = __PAIR64__(v265, v266);
        v96 = v285[0];
        v97.i64[0] = 0x100000001;
        v97.i64[1] = 0x100000001;
        do
        {
          v98 = v278;
          do
          {
            v99 = bswap32(*(unsigned __int16 *)v32);
            if (HIWORD(v99) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v99) == 0xFFFF)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                LOWORD(v100) = v94;
                v35->i16[3] = v280;
              }
              else
              {
                v101 = HIWORD(v99);
                v102 = ~HIWORD(v99);
                v103 = ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16);
                v104 = (uint32x4_t)vmulq_s32(v95, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v102)));
                v105.i32[0] = v103;
                v105.i32[1] = WORD1(v103);
                *v35 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v105, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v103), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v104, v104, 0x10uLL), v97), 0x10uLL)));
                v100 = bswap32(v101+ (((unsigned __int16)v102 * v15 + (((unsigned __int16)v102 * v15) >> 16) + 1) >> 16)) >> 16;
              }
              *(_WORD *)v32 = v100;
            }
            ++v35;
            v32 += 2 * v272;
            --v98;
          }
          while (v98);
          v35 += v276;
          v32 += 2 * v279;
          --v96;
        }
        while (v96);
        goto LABEL_384;
      case 7:
        if (v6)
        {
          v275 = v31;
          v106 = v285[0];
          do
          {
            v107 = v278;
            do
            {
              CMYK64_DAM(v35, v32, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v32) >> 16, v15);
              ++v35;
              v32 += 2 * v272;
              --v107;
            }
            while (v107);
            v35 += v276;
            v32 += 2 * v279;
            --v106;
          }
          while (v106);
LABEL_136:
          v285[0] = 0;
          goto LABEL_348;
        }
        v251 = vdupq_n_s32(v28);
        v252 = v285[0];
        v253.i64[0] = 0x100000001;
        v253.i64[1] = 0x100000001;
        do
        {
          v254 = v278;
          do
          {
            v255 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
            v256.i32[0] = (unsigned __int16)v255;
            v256.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v255), 0x10uLL).i32[1];
            v256.i32[2] = bswap32(v35->u16[2]) >> 16;
            v256.i32[3] = bswap32(v35->u16[3]) >> 16;
            v257 = (uint32x4_t)vmulq_s32(v256, v251);
            v256.i32[0] = v255;
            *v35++ = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v256, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v257, v257, 0x10uLL), v253), 0x10uLL))));
            v32 += 2 * v272;
            --v254;
          }
          while (v254);
          v35 += v276;
          v32 += 2 * v279;
          --v252;
        }
        while (v252);
        goto LABEL_384;
      case 8:
        if (v6)
        {
          v275 = v31;
          v108 = v285[0];
          do
          {
            v109 = v278;
            do
            {
              CMYK64_DAM(v35, v32, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v32) >> 16, (unsigned __int16)~(_WORD)v15);
              ++v35;
              v32 += 2 * v272;
              --v109;
            }
            while (v109);
            v35 += v276;
            v32 += 2 * v279;
            --v108;
          }
          while (v108);
LABEL_118:
          v285[0] = 0;
          v28 = ~(_WORD)v15;
          LODWORD(v7) = v269;
          goto LABEL_349;
        }
        v258 = vdupq_n_s32(v15);
        v259 = v285[0];
        v260.i64[0] = 0x100000001;
        v260.i64[1] = 0x100000001;
        do
        {
          v261 = v278;
          do
          {
            v262 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
            v263.i32[0] = (unsigned __int16)v262;
            v263.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v262), 0x10uLL).i32[1];
            v263.i32[2] = bswap32(v35->u16[2]) >> 16;
            v263.i32[3] = bswap32(v35->u16[3]) >> 16;
            v264 = (uint32x4_t)vmulq_s32(v263, v258);
            v263.i32[0] = v262;
            *v35++ = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v263, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v264, v264, 0x10uLL), v260), 0x10uLL))));
            v32 += 2 * v272;
            --v261;
          }
          while (v261);
          v35 += v276;
          v32 += 2 * v279;
          --v259;
        }
        while (v259);
LABEL_384:
        v285[0] = 0;
        if (!v31)
          return 1;
        goto LABEL_352;
      case 9:
        v275 = v31;
        v110 = v285[0];
        do
        {
          v111 = v278;
          do
          {
            v112 = bswap32(*(unsigned __int16 *)v32) >> 16;
            CMYK64_DAMplusDAM(v35, v32, v23, v15, v112 ^ 0xFFFF, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v112, v15);
            ++v35;
            v32 += 2 * v272;
            --v111;
          }
          while (v111);
          v35 += v276;
          v32 += 2 * v279;
          --v110;
        }
        while (v110);
        goto LABEL_136;
      case 10:
        v275 = v31;
        v113 = v285[0];
        do
        {
          v114 = v278;
          do
          {
            v115 = bswap32(*(unsigned __int16 *)v32) >> 16;
            CMYK64_DAMplusDAM(v35, v32, v23, v15, v115 ^ 0xFFFF, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v115, (unsigned __int16)~(_WORD)v15);
            ++v35;
            v32 += 2 * v272;
            --v114;
          }
          while (v114);
          v35 += v276;
          v32 += 2 * v279;
          --v113;
        }
        while (v113);
        goto LABEL_118;
      case 11:
        v275 = v31;
        v116 = v285[0];
        v117 = 2 * v272;
        if (v6)
        {
          do
          {
            v118 = v278;
            do
            {
              CMYK64_DAplusdDA((int *)v35, v32, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v32) >> 16, v23, v15);
              ++v35;
              v32 += v117;
              --v118;
            }
            while (v118);
            v35 += v276;
            v32 += 2 * v279;
            --v116;
          }
          while (v116);
        }
        else
        {
          do
          {
            v119 = v278;
            do
            {
              CMYK64_DplusdDA(v35, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v23, v15);
              ++v35;
              v32 += v117;
              --v119;
            }
            while (v119);
            v35 += v276;
            v32 += 2 * v279;
            --v116;
          }
          while (v116);
        }
        goto LABEL_136;
      case 12:
        v275 = v31;
        v120 = v285[0];
        v121 = 2 * v272;
        if (v6)
        {
          do
          {
            v122 = v278;
            do
            {
              CMYK64_DApluslDA((unsigned int *)v35, v32, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v32) >> 16, v23, v15);
              ++v35;
              v32 += v121;
              --v122;
            }
            while (v122);
            v35 += v276;
            v32 += 2 * v279;
            --v120;
          }
          while (v120);
        }
        else
        {
          do
          {
            v123 = v278;
            do
            {
              CMYK64_DpluslD(v35, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v23);
              ++v35;
              v32 += v121;
              --v123;
            }
            while (v123);
            v35 += v276;
            v32 += 2 * v279;
            --v120;
          }
          while (v120);
        }
        goto LABEL_136;
      case 13:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v124 = __rev16(v15);
        v125 = v285[0];
        while (1)
        {
          v126 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v124;
                goto LABEL_148;
              }
              v127 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v127 = 0xFFFF;
            }
            v128 = PDAmultiplyPDA_10646(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v127, v23, v15);
            v130 = bswap32(v128);
            v35->i16[0] = HIWORD(v130);
            v35->i16[1] = v130;
            v35->i16[2] = bswap32(HIDWORD(v128)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v128));
            if (v6)
              *(_WORD *)v32 = bswap32(v129) >> 16;
LABEL_148:
            ++v35;
            v32 += 2 * v272;
            --v126;
          }
          while (v126);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v125)
            goto LABEL_346;
        }
      case 14:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v131 = __rev16(v15);
        v132 = v285[0];
        while (1)
        {
          v133 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v131;
                goto LABEL_162;
              }
              v134 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v134 = 0xFFFF;
            }
            v135 = PDAscreenPDA_10647(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v134, v23, v15);
            v137 = bswap32(v135);
            v35->i16[0] = HIWORD(v137);
            v35->i16[1] = v137;
            v35->i16[2] = bswap32(HIDWORD(v135)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v135));
            if (v6)
              *(_WORD *)v32 = bswap32(v136) >> 16;
LABEL_162:
            ++v35;
            v32 += 2 * v272;
            --v133;
          }
          while (v133);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v132)
            goto LABEL_346;
        }
      case 15:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v138 = __rev16(v15);
        v139 = v285[0];
        while (1)
        {
          v140 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v138;
                goto LABEL_176;
              }
              v141 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v141 = 0xFFFF;
            }
            v142 = PDAoverlayPDA_10648(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v141, v23, v15);
            v144 = bswap32(v142);
            v35->i16[0] = HIWORD(v144);
            v35->i16[1] = v144;
            v35->i16[2] = bswap32(HIDWORD(v142)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v142));
            if (v6)
              *(_WORD *)v32 = bswap32(v143) >> 16;
LABEL_176:
            ++v35;
            v32 += 2 * v272;
            --v140;
          }
          while (v140);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v139)
            goto LABEL_346;
        }
      case 16:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v145 = __rev16(v15);
        v146 = v285[0];
        while (1)
        {
          v147 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v145;
                goto LABEL_190;
              }
              v148 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v148 = 0xFFFF;
            }
            v149 = PDAdarkenPDA_10650(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v148, v23, v15);
            v151 = bswap32(v149);
            v35->i16[0] = HIWORD(v151);
            v35->i16[1] = v151;
            v35->i16[2] = bswap32(HIDWORD(v149)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v149));
            if (v6)
              *(_WORD *)v32 = bswap32(v150) >> 16;
LABEL_190:
            ++v35;
            v32 += 2 * v272;
            --v147;
          }
          while (v147);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v146)
            goto LABEL_346;
        }
      case 17:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v152 = __rev16(v15);
        v153 = v285[0];
        while (1)
        {
          v154 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v152;
                goto LABEL_204;
              }
              v155 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v155 = 0xFFFF;
            }
            v156 = PDAlightenPDA_10649(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v155, v23, v15);
            v158 = bswap32(v156);
            v35->i16[0] = HIWORD(v158);
            v35->i16[1] = v158;
            v35->i16[2] = bswap32(HIDWORD(v156)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v156));
            if (v6)
              *(_WORD *)v32 = bswap32(v157) >> 16;
LABEL_204:
            ++v35;
            v32 += 2 * v272;
            --v154;
          }
          while (v154);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v153)
            goto LABEL_346;
        }
      case 18:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v159 = __rev16(v15);
        v160 = v285[0];
        while (1)
        {
          v161 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v159;
                goto LABEL_218;
              }
              v162 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v162 = 0xFFFF;
            }
            v163 = PDAcolordodgePDA_10651(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v162, v23, v15);
            v165 = bswap32(v163);
            v35->i16[0] = HIWORD(v165);
            v35->i16[1] = v165;
            v35->i16[2] = bswap32(HIDWORD(v163)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v163));
            if (v6)
              *(_WORD *)v32 = bswap32(v164) >> 16;
LABEL_218:
            ++v35;
            v32 += 2 * v272;
            --v161;
          }
          while (v161);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v160)
            goto LABEL_346;
        }
      case 19:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v166 = __rev16(v15);
        v167 = v285[0];
        while (1)
        {
          v168 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v166;
                goto LABEL_232;
              }
              v169 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v169 = 0xFFFF;
            }
            v170 = PDAcolorburnPDA_10652(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v169, v23, v15);
            v172 = bswap32(v170);
            v35->i16[0] = HIWORD(v172);
            v35->i16[1] = v172;
            v35->i16[2] = bswap32(HIDWORD(v170)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v170));
            if (v6)
              *(_WORD *)v32 = bswap32(v171) >> 16;
LABEL_232:
            ++v35;
            v32 += 2 * v272;
            --v168;
          }
          while (v168);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v167)
            goto LABEL_346;
        }
      case 20:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v173 = __rev16(v15);
        v174 = v285[0];
        while (1)
        {
          v175 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v173;
                goto LABEL_246;
              }
              v176 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v176 = 0xFFFF;
            }
            v177 = PDAsoftlightPDA_10654(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v176, v23, v15);
            v179 = bswap32(v177);
            v35->i16[0] = HIWORD(v179);
            v35->i16[1] = v179;
            v35->i16[2] = bswap32(HIDWORD(v177)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v177));
            if (v6)
              *(_WORD *)v32 = bswap32(v178) >> 16;
LABEL_246:
            ++v35;
            v32 += 2 * v272;
            --v175;
          }
          while (v175);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v174)
            goto LABEL_346;
        }
      case 21:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v180 = __rev16(v15);
        v181 = v285[0];
        while (1)
        {
          v182 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v180;
                goto LABEL_260;
              }
              v183 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v183 = 0xFFFF;
            }
            v184 = PDAhardlightPDA_10653(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v183, v23, v15);
            v186 = bswap32(v184);
            v35->i16[0] = HIWORD(v186);
            v35->i16[1] = v186;
            v35->i16[2] = bswap32(HIDWORD(v184)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v184));
            if (v6)
              *(_WORD *)v32 = bswap32(v185) >> 16;
LABEL_260:
            ++v35;
            v32 += 2 * v272;
            --v182;
          }
          while (v182);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v181)
            goto LABEL_346;
        }
      case 22:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v187 = __rev16(v15);
        v188 = v285[0];
        while (1)
        {
          v189 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v187;
                goto LABEL_274;
              }
              v190 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v190 = 0xFFFF;
            }
            v191 = PDAdifferencePDA_10655(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v190, v23, v15);
            v193 = bswap32(v191);
            v35->i16[0] = HIWORD(v193);
            v35->i16[1] = v193;
            v35->i16[2] = bswap32(HIDWORD(v191)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v191));
            if (v6)
              *(_WORD *)v32 = bswap32(v192) >> 16;
LABEL_274:
            ++v35;
            v32 += 2 * v272;
            --v189;
          }
          while (v189);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v188)
            goto LABEL_346;
        }
      case 23:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v194 = __rev16(v15);
        v195 = v285[0];
        while (1)
        {
          v196 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v194;
                goto LABEL_288;
              }
              v197 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v197 = 0xFFFF;
            }
            v198 = PDAexclusionPDA_10656(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v197, v23, v15);
            v200 = bswap32(v198);
            v35->i16[0] = HIWORD(v200);
            v35->i16[1] = v200;
            v35->i16[2] = bswap32(HIDWORD(v198)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v198));
            if (v6)
              *(_WORD *)v32 = bswap32(v199) >> 16;
LABEL_288:
            ++v35;
            v32 += 2 * v272;
            --v196;
          }
          while (v196);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v195)
            goto LABEL_346;
        }
      case 24:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v201 = __rev16(v15);
        v202 = v285[0];
        while (1)
        {
          v203 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v201;
                goto LABEL_302;
              }
              v204 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v204 = 0xFFFF;
            }
            v205 = PDAhuePDA_10657(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v204, v23, v15);
            v207 = bswap32(v205);
            v35->i16[0] = HIWORD(v207);
            v35->i16[1] = v207;
            v35->i16[2] = bswap32(HIDWORD(v205)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v205));
            if (v6)
              *(_WORD *)v32 = bswap32(v206) >> 16;
LABEL_302:
            ++v35;
            v32 += 2 * v272;
            --v203;
          }
          while (v203);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v202)
            goto LABEL_346;
        }
      case 25:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v208 = __rev16(v15);
        v209 = v285[0];
        while (1)
        {
          v210 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v208;
                goto LABEL_316;
              }
              v211 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v211 = 0xFFFF;
            }
            v212 = PDAsaturationPDA_10658(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v211, v23, v15);
            v214 = bswap32(v212);
            v35->i16[0] = HIWORD(v214);
            v35->i16[1] = v214;
            v35->i16[2] = bswap32(HIDWORD(v212)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v212));
            if (v6)
              *(_WORD *)v32 = bswap32(v213) >> 16;
LABEL_316:
            ++v35;
            v32 += 2 * v272;
            --v210;
          }
          while (v210);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v209)
            goto LABEL_346;
        }
      case 26:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v215 = __rev16(v15);
        v216 = v285[0];
        while (1)
        {
          v217 = v278;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v32)
              {
                v35->i16[0] = v283;
                v35->i16[1] = v282;
                v35->i16[2] = v281;
                v35->i16[3] = v280;
                *(_WORD *)v32 = v215;
                goto LABEL_330;
              }
              v218 = __rev16(*(unsigned __int16 *)v32);
            }
            else
            {
              v218 = 0xFFFF;
            }
            v219 = PDAluminosityPDA_10659(v23, v15, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v218);
            v221 = bswap32(v219);
            v35->i16[0] = HIWORD(v221);
            v35->i16[1] = v221;
            v35->i16[2] = bswap32(HIDWORD(v219)) >> 16;
            v35->i16[3] = __rev16(HIWORD(v219));
            if (v6)
              *(_WORD *)v32 = bswap32(v220) >> 16;
LABEL_330:
            ++v35;
            v32 += 2 * v272;
            --v217;
          }
          while (v217);
          v35 += v276;
          v32 += 2 * v279;
          if (!--v216)
            goto LABEL_346;
        }
      case 27:
        if (!v15)
          goto LABEL_351;
        v275 = v31;
        v222 = __rev16(v15);
        v223 = v285[0];
        break;
      default:
        goto LABEL_351;
    }
    do
    {
      v224 = v278;
      do
      {
        if (v6)
        {
          if (!*(_WORD *)v32)
          {
            v35->i16[0] = v283;
            v35->i16[1] = v282;
            v35->i16[2] = v281;
            v35->i16[3] = v280;
            *(_WORD *)v32 = v222;
            goto LABEL_344;
          }
          v225 = __rev16(*(unsigned __int16 *)v32);
        }
        else
        {
          v225 = 0xFFFF;
        }
        v226 = PDAluminosityPDA_10659(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v225, v23, v15);
        v228 = bswap32(v226);
        v35->i16[0] = HIWORD(v228);
        v35->i16[1] = v228;
        v35->i16[2] = bswap32(HIDWORD(v226)) >> 16;
        v35->i16[3] = __rev16(HIWORD(v226));
        if (v6)
          *(_WORD *)v32 = bswap32(v227) >> 16;
LABEL_344:
        ++v35;
        v32 += 2 * v272;
        --v224;
      }
      while (v224);
      v35 += v276;
      v32 += 2 * v279;
      --v223;
    }
    while (v223);
LABEL_346:
    v285[0] = 0;
LABEL_347:
    v25 = v270;
LABEL_348:
    v28 = ~(_WORD)v15;
LABEL_349:
    v29 = v271;
LABEL_350:
    v31 = v275;
LABEL_351:
    if (!v31)
      return 1;
LABEL_352:
    v284 = 0;
LABEL_36:
    if (shape_enum_clip_next(v31, (int *)&v284 + 1, &v284, v295, v285))
    {
      v35 = (int8x8_t *)(v29 + 8 * v25 * (int)v284 + 8 * SHIDWORD(v284));
      v34 = v295[0];
      v42 = v279;
      if (v6)
      {
        v42 = v274 - v295[0];
        v32 = &v273[2 * v274 * (int)v284 + 2 * SHIDWORD(v284)];
      }
      v278 = v295[0];
      v279 = v42;
      continue;
    }
    break;
  }
  v41 = (void *)v31;
LABEL_354:
  free(v41);
  return 1;
}

uint64_t CMYK64_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL4 v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  unsigned int v18;
  unsigned int v19;
  char v20;
  int v21;
  int v22;
  int v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  int v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _OWORD v46[64];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  memset(v46, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*(_QWORD *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v29, (uint64_t)v46) < 1)
    return 0xFFFFFFFFLL;
  v18 = *(_DWORD *)a3;
  *((_QWORD *)&v29 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v18 != 269501444)
  {
    v19 = SAMPLEINDEX(v18, v10, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      if (v19 > 0xB)
      {
LABEL_20:
        v21 = 255;
        v20 = 1;
      }
      else
      {
        v20 = 0;
        v21 = 0;
        switch(v19)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v20 = 0;
            v21 = 16;
            break;
          case 5u:
            v20 = 0;
            v21 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v20 = 0;
            v21 = 32;
            break;
          case 8u:
            v20 = 0;
            v21 = 8;
            break;
          case 9u:
            v20 = 0;
            v21 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(_QWORD *)&v29 = *(_QWORD *)&CMYK16_image_sample[2 * v19 + 2];
      if ((_QWORD)v29)
      {
        v22 = 269501476;
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(_QWORD *)&v29 = *(_QWORD *)&CMYK8_image_sample[2 * v19 + 2];
        if ((_QWORD)v29)
        {
          v22 = 134759444;
          v23 = 8;
LABEL_28:
          LODWORD(v30) = v23;
LABEL_29:
          DWORD2(v29) = v22;
          if ((v20 & 1) == 0
            && (v8 - 1) <= 1
            && (BYTE4(v30) & 7) == 3
            && (a2[2] == 5 || !a2[2])
            && v19 <= 0xB)
          {
            HIDWORD(v24) = v21;
            LODWORD(v24) = v21;
            switch((v24 >> 3))
            {
              case 0u:
                DWORD2(v29) = *(_DWORD *)a3;
                v25 = CMYK64_image_mark_RGB32;
                goto LABEL_52;
              case 1u:
                DWORD2(v29) = *(_DWORD *)a3;
                v25 = CMYK64_image_mark_RGB32;
                goto LABEL_54;
              case 2u:
                DWORD2(v29) = *(_DWORD *)a3;
                v25 = CMYK64_image_mark_W8;
                goto LABEL_52;
              case 3u:
                DWORD2(v29) = *(_DWORD *)a3;
                v25 = CMYK64_image_mark_RGB24;
                goto LABEL_52;
              case 4u:
                DWORD2(v29) = *(_DWORD *)a3;
                v25 = CMYK64_image_mark_rgb32;
LABEL_52:
                v26 = (uint64_t)a2;
                v27 = v8;
                v28 = 0;
                break;
              case 5u:
                DWORD2(v29) = *(_DWORD *)a3;
                v25 = CMYK64_image_mark_rgb32;
LABEL_54:
                v26 = (uint64_t)a2;
                v27 = v8;
                v28 = 8;
                break;
              default:
                goto LABEL_30;
            }
            cmyk64_image_mark_image(v26, (uint64_t)&v29, v27, v28, (void (*)(_QWORD, _QWORD))v25);
            return 1;
          }
          goto LABEL_30;
        }
      }
      *(_QWORD *)&v29 = *(_QWORD *)&CMYKF_image_sample[2 * v19 + 2];
      if ((_QWORD)v29)
      {
        v22 = 538985509;
        v23 = 20;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(_QWORD)v40 && (~DWORD1(v30) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((BYTE4(v30) & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      CMYK64_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(_QWORD *)&v29 = cmyk64_sample_CMYK64;
LABEL_30:
  CMYK64_image_mark((uint64_t)a2, (uint64_t)&v29, v8, v17);
  return 1;
}

uint64_t CMYK64_shade(uint64_t a1, __n128 a2)
{
  uint64_t *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __n128 v13;
  void *v14;
  unint64_t v15;
  _BYTE *v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38[2];
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[2];
  int v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[40];
  uint64_t v47;

  v2 = (uint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v7 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v8 = *v2;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  v9 = *(_QWORD *)(v8 + 56);
  v10 = *v3;
  if (!*((_QWORD *)v3 + 12))
  {
    if (*(_QWORD *)(v4 + 72))
      v7 = 0;
    else
      v7 = *(float *)(v4 + 4) >= 1.0;
  }
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v11 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(_QWORD *)(v5 + 16))
    {
      v14 = cmyk64_shade_radial_CMYK;
    }
    else if (*(_QWORD *)(v5 + 24))
    {
      v14 = cmyk64_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      v14 = cmyk64_shade_axial_CMYK;
    }
    else
    {
      v14 = cmyk64_shade_custom_CMYK;
    }
    *(_QWORD *)&v17[0] = v14;
    if ((_QWORD)v40)
    {
      *((_QWORD *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    v15 = *((_QWORD *)&v19 + 1) * v19;
    if ((uint64_t)(*((_QWORD *)&v19 + 1) * v19) <= 384)
    {
      v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(_BYTE *)(v5 + 1))
        *(_QWORD *)&v39 = &_blt_shade_samples_noise;
      goto LABEL_29;
    }
    v16 = malloc_type_malloc(10 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      v15 = *((_QWORD *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)&v17[0])
    return 0xFFFFFFFFLL;
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  CMYK64_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1]))
    free(v38[1]);
  return 1;
}

void CMYK64_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  unint64_t v4;
  uint64_t v6;
  uint64_t v7;
  float v8;
  int *v9;
  unint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned __int16 *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int8x8_t *v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  int v44;
  uint64_t v45;
  unsigned __int8 *v46;
  void *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int8 *v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned __int8 *v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  void *v61;
  void (*v62)(_QWORD *, uint64_t, uint64_t, uint64_t);
  int8x16_t v63;
  uint64_t v64;
  _BYTE *v65;
  unsigned int v66;
  int v67;
  _BYTE *v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  float v77;
  int v78;
  int v79;
  int v80;
  unsigned int v81;
  float v82;
  int v83;
  float v84;
  int v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  _WORD *v93;
  uint64_t v94;
  int v95;
  int v96;
  int v97;
  int v98;
  unint64_t v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  float v107;
  int v108;
  float v109;
  int v110;
  float v111;
  int v112;
  float v113;
  uint64_t v114;
  uint64_t v115;
  _WORD *v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unsigned __int8 *v121;
  int v122;
  int v123;
  uint64_t v124;
  unsigned __int16 *v125;
  _BYTE *v126;
  unsigned __int16 *v127;
  uint64_t v128;
  unsigned __int16 *v129;
  unsigned int v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  int8x8_t *v137;
  int v138;
  unsigned int v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  unsigned int v143;
  int v144;
  int v145;
  int v146;
  unsigned int v147;
  unint64_t v148;
  unsigned int v149;
  int32x4_t v150;
  unsigned int v151;
  uint32x4_t v152;
  int32x4_t v153;
  uint32x4_t v154;
  unsigned int v155;
  unsigned int v156;
  int32x4_t v157;
  unsigned int v158;
  uint32x4_t v159;
  int32x4_t v160;
  uint32x4_t v161;
  uint64_t v162;
  unsigned __int16 *v163;
  int v164;
  unsigned __int8 *v165;
  uint64_t v166;
  int v167;
  int v168;
  unsigned int v169;
  uint64_t v170;
  unsigned __int16 *v171;
  int v172;
  int v173;
  int v174;
  unsigned int v175;
  uint64_t v176;
  unsigned __int16 *v177;
  int v178;
  int v179;
  unint64_t v180;
  int v181;
  unint64_t v182;
  unsigned int v183;
  unsigned int v184;
  int v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  int v189;
  unsigned __int8 *v190;
  int v191;
  unsigned int v192;
  unint64_t v193;
  int32x4_t v194;
  unsigned int v195;
  uint32x2_t v196;
  unsigned int v197;
  uint32x4_t v198;
  int32x4_t v199;
  uint32x4_t v200;
  uint64_t v201;
  unsigned __int16 *v202;
  unsigned __int8 *v203;
  int v204;
  unint64_t v205;
  unsigned int v206;
  uint64_t v207;
  unsigned __int16 *v208;
  int v209;
  unint64_t v210;
  unsigned int v211;
  uint64_t v212;
  unsigned __int16 *v213;
  int v214;
  int v215;
  unsigned int v216;
  unint64_t v217;
  unsigned __int16 v218;
  int v219;
  unint64_t v220;
  unsigned int v221;
  uint64_t v222;
  unsigned __int16 *v223;
  int v224;
  int v225;
  unsigned int v226;
  unint64_t v227;
  int v228;
  unint64_t v229;
  unsigned int v230;
  uint64_t v231;
  _WORD *v232;
  int v233;
  unint64_t v234;
  int v235;
  unsigned int v236;
  uint64_t v237;
  _WORD *v238;
  int v239;
  unint64_t v240;
  int v241;
  unsigned int v242;
  uint64_t v243;
  unsigned __int16 *v244;
  unsigned __int8 *v245;
  int v246;
  int v247;
  int v248;
  int v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  unsigned int v253;
  unsigned __int16 *v254;
  unint64_t v255;
  int v256;
  unsigned int v257;
  unsigned int v258;
  uint64_t v259;
  unsigned __int16 *v260;
  int v261;
  int v262;
  int v263;
  int v264;
  unint64_t v265;
  unint64_t v266;
  unint64_t v267;
  unsigned int v268;
  unsigned __int16 *v269;
  unint64_t v270;
  int v271;
  unsigned int v272;
  unsigned int v273;
  uint64_t v274;
  unsigned __int16 *v275;
  int v276;
  int v277;
  int v278;
  int v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  unsigned int v283;
  unsigned __int16 *v284;
  unint64_t v285;
  int v286;
  unsigned int v287;
  unsigned int v288;
  uint64_t v289;
  unsigned __int16 *v290;
  int v291;
  int v292;
  int v293;
  int v294;
  unint64_t v295;
  unint64_t v296;
  unint64_t v297;
  unsigned int v298;
  unsigned __int16 *v299;
  unint64_t v300;
  int v301;
  unsigned int v302;
  unsigned int v303;
  uint64_t v304;
  unsigned __int16 *v305;
  int v306;
  int v307;
  int v308;
  int v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unsigned int v313;
  unsigned __int16 *v314;
  unint64_t v315;
  int v316;
  unsigned int v317;
  unsigned int v318;
  uint64_t v319;
  unsigned __int16 *v320;
  int v321;
  int v322;
  int v323;
  int v324;
  unint64_t v325;
  unint64_t v326;
  unint64_t v327;
  unsigned int v328;
  unsigned __int16 *v329;
  unint64_t v330;
  int v331;
  unsigned int v332;
  unsigned int v333;
  uint64_t v334;
  unsigned __int16 *v335;
  int v336;
  int v337;
  int v338;
  int v339;
  unint64_t v340;
  unint64_t v341;
  unint64_t v342;
  unsigned int v343;
  unsigned __int16 *v344;
  unint64_t v345;
  int v346;
  unsigned int v347;
  unsigned int v348;
  uint64_t v349;
  unsigned __int16 *v350;
  int v351;
  int v352;
  int v353;
  int v354;
  unint64_t v355;
  unint64_t v356;
  unint64_t v357;
  unsigned int v358;
  unsigned __int16 *v359;
  unint64_t v360;
  int v361;
  unsigned int v362;
  unsigned int v363;
  uint64_t v364;
  unsigned __int16 *v365;
  int v366;
  int v367;
  int v368;
  int v369;
  unint64_t v370;
  unint64_t v371;
  unint64_t v372;
  unsigned int v373;
  unsigned __int16 *v374;
  unint64_t v375;
  int v376;
  unsigned int v377;
  unsigned int v378;
  uint64_t v379;
  unsigned __int16 *v380;
  int v381;
  int v382;
  int v383;
  int v384;
  unint64_t v385;
  unint64_t v386;
  unint64_t v387;
  unsigned int v388;
  unsigned __int16 *v389;
  unint64_t v390;
  int v391;
  unsigned int v392;
  unsigned int v393;
  uint64_t v394;
  unsigned __int16 *v395;
  int v396;
  int v397;
  int v398;
  int v399;
  unint64_t v400;
  unint64_t v401;
  unint64_t v402;
  unsigned int v403;
  unsigned __int16 *v404;
  unint64_t v405;
  int v406;
  unsigned int v407;
  unsigned int v408;
  uint64_t v409;
  unsigned __int16 *v410;
  int v411;
  int v412;
  int v413;
  int v414;
  unint64_t v415;
  unint64_t v416;
  unint64_t v417;
  unsigned int v418;
  unsigned __int16 *v419;
  unint64_t v420;
  int v421;
  unsigned int v422;
  unsigned int v423;
  uint64_t v424;
  unsigned __int16 *v425;
  int v426;
  int v427;
  int v428;
  int v429;
  unint64_t v430;
  unint64_t v431;
  unint64_t v432;
  unsigned int v433;
  unsigned __int16 *v434;
  unint64_t v435;
  int v436;
  unsigned int v437;
  unsigned int v438;
  uint64_t v439;
  unsigned __int16 *v440;
  int v441;
  int v442;
  int v443;
  int v444;
  unint64_t v445;
  unint64_t v446;
  unint64_t v447;
  unsigned int v448;
  unsigned __int16 *v449;
  unsigned int v450;
  unsigned int v451;
  uint64_t v452;
  unsigned __int16 *v453;
  int v454;
  int v455;
  int v456;
  int v457;
  unint64_t v458;
  unint64_t v459;
  unint64_t v460;
  unsigned int v461;
  unsigned __int16 *v462;
  unint64_t v463;
  int v464;
  unsigned int v465;
  unsigned int v466;
  int v467;
  unsigned __int8 *v468;
  int v469;
  unsigned int v470;
  int32x4_t v471;
  uint32x4_t v472;
  int32x4_t v473;
  unsigned __int8 *v474;
  int v475;
  unsigned int v476;
  int8x8_t *v477;
  int8x8_t *v478;
  uint64_t v479;
  uint64_t v480;
  unsigned int v481;
  unsigned int v482;
  int8x8_t v483;
  int32x4_t v484;
  int32x4_t v485;
  int32x4_t v486;
  int32x4_t v487;
  int8x16_t v488;
  int v489;
  uint64_t v490;
  unsigned int v491;
  int v492;
  uint64_t v493;
  uint64_t v494;
  unsigned int v495;
  unsigned int v496;
  int v497;
  int v498;
  unsigned int v499;
  unsigned int v500;
  unint64_t v501;
  unsigned int v502;
  int32x4_t v503;
  int64x2_t v504;
  uint32x4_t v505;
  int32x4_t v506;
  int32x4_t v507;
  int32x2_t v508;
  unsigned int v509;
  int32x4_t v510;
  uint32x4_t v511;
  unsigned __int16 *v512;
  int v513;
  unsigned __int8 *v514;
  int v515;
  unsigned int v516;
  int32x4_t v517;
  uint32x4_t v518;
  int32x4_t v519;
  int32x4_t v520;
  int v521;
  unsigned int v522;
  int32x4_t v523;
  int8x8_t v524;
  int32x4_t v525;
  int32x4_t v526;
  int8x16_t v527;
  const __int16 *v528;
  int v529;
  int v530;
  unsigned int v531;
  int32x4_t v532;
  uint16x4_t v533;
  uint32x4_t v534;
  int32x4_t v535;
  int32x4_t v536;
  int v537;
  unsigned int v538;
  int32x4_t v539;
  int8x8_t v540;
  int32x4_t v541;
  int32x4_t v542;
  int8x16_t v543;
  _WORD *v544;
  int v545;
  unint64_t v546;
  int v547;
  unsigned int v548;
  int v549;
  int v550;
  unsigned __int8 *v551;
  int v552;
  unsigned int v553;
  uint64_t v554;
  int v555;
  unsigned int v556;
  uint64_t v557;
  unint64_t v558;
  unsigned __int8 *v559;
  unsigned __int16 *v560;
  unint64_t v561;
  unint64_t v562;
  unint64_t v563;
  int8x8_t *v564;
  int v565;
  unint64_t v566;
  uint64_t v567;
  unsigned __int8 *v568;
  int v569;
  int v570;
  unint64_t v571;
  unint64_t v572;
  unint64_t v573;
  int8x8_t *v574;
  unsigned int v575;
  int v576;
  int v577;
  int v578;
  unint64_t v579;
  unint64_t v580;
  unsigned int v581;
  int32x4_t v582;
  unsigned int v583;
  uint32x4_t v584;
  int32x4_t v585;
  uint32x4_t v586;
  unsigned int v587;
  unint64_t v588;
  unsigned int v589;
  int32x4_t v590;
  unsigned int v591;
  uint32x4_t v592;
  int32x4_t v593;
  uint32x4_t v594;
  int v595;
  int8x8_t *v596;
  unsigned __int8 *v597;
  int v598;
  uint64_t v599;
  uint64_t v600;
  unsigned int v601;
  unsigned int v602;
  int32x4_t v603;
  int32x4_t v604;
  int32x4_t v605;
  int32x4_t v606;
  int v607;
  unsigned __int8 *v608;
  int v609;
  int v610;
  uint64_t v611;
  uint64_t v612;
  unsigned int v613;
  int v614;
  int v615;
  unsigned int v616;
  unsigned int v617;
  unint64_t v618;
  unsigned int v619;
  int32x4_t v620;
  int64x2_t v621;
  uint32x4_t v622;
  int32x4_t v623;
  int32x4_t v624;
  int32x2_t v625;
  unsigned int v626;
  int32x4_t v627;
  uint32x4_t v628;
  int v629;
  uint64_t v630;
  unint64_t v631;
  uint64_t v632;
  uint64_t v633;
  void *v634;
  uint64_t v635;
  uint64_t v636;
  int8x8_t *v637;
  uint64_t v638;
  uint64_t v639;
  int v640;
  uint64_t v641;
  _QWORD *v642;
  uint64_t v643;
  uint64_t v644;
  int v645;
  uint64_t v646;
  void *v647;
  uint64_t v648;
  int v649;
  int v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  unsigned __int8 *v654;
  uint64_t v655;

  v640 = a3;
  v655 = *MEMORY[0x1E0C80C00];
  v646 = *(unsigned int *)(a1 + 4);
  v639 = (int)v646;
  v4 = ((int)v646 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 <= 0x1FFFFFF)
  {
    v7 = *(_QWORD *)(a1 + 40);
    v6 = *(_QWORD *)(a1 + 48);
    v8 = *(float *)(a2 + 184);
    v9 = *(int **)(a1 + 136);
    v648 = *(_QWORD *)(a2 + 96);
    v651 = *(_QWORD *)(a2 + 104);
    v11 = *(int *)(a1 + 24);
    v10 = *(int *)(a1 + 28);
    v13 = *(int *)(a1 + 16);
    v12 = (unsigned __int8 *)*(int *)(a1 + 20);
    v653 = v6;
    v654 = v12;
    v14 = *(int *)(a1 + 12);
    v650 = *(_DWORD *)(a1 + 8);
    v642 = (_QWORD *)a2;
    v15 = *(int *)(a2 + 16);
    v16 = (v15 + 18) * v4;
    if (v16 > 65439)
    {
      v19 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
      v18 = v19;
      v21 = v19;
      v22 = v642;
      if (!v19)
        return;
    }
    else
    {
      MEMORY[0x1E0C80A78](a1, a4);
      v18 = (char *)&v630 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v18, v17);
      v21 = 0;
      v22 = v642;
    }
    v634 = v21;
    v638 = a1;
    v23 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
    v24 = v23 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    v22[20] = v24;
    if ((_DWORD)v15)
      v25 = 16 * v4;
    else
      v25 = 0;
    v26 = v24 + v25;
    v27 = v7 + (v11 - 1) * v10;
    v28 = v10 >> 3;
    v22[18] = v23;
    v22[19] = v26;
    if (v653)
    {
      v29 = v638;
      v30 = (unint64_t)*(int *)(v638 + 32) >> 1;
      v31 = (unsigned __int16 *)(v653 + 2 * (v14 + v30 * v13));
      v644 = v30 - v639;
      v32 = v639;
      v33 = 1;
    }
    else
    {
      v31 = 0;
      v644 = 0;
      v33 = 0;
      v29 = v638;
      v32 = v639;
    }
    v645 = (int)(float)((float)(v8 * 65535.0) + 0.5);
    v34 = v27 + 8 * (_QWORD)v654;
    v35 = (int8x8_t *)(v7 + 8 * (v14 + v28 * v13));
    v643 = v28 - v32;
    v36 = *(int *)(v29 + 104);
    v37 = *(_DWORD *)(v29 + 108);
    v38 = *(unsigned __int8 *)(v29 + 2);
    if (v38 == 6 || v38 == 1)
    {
      v39 = v640;
      v40 = v642;
      v41 = v646;
      v42 = v648;
      if (!v9)
        goto LABEL_625;
      v631 = v28;
      v43 = 0;
      v44 = 0;
      v45 = *(int *)(v638 + 124);
      v46 = (unsigned __int8 *)v9 + v36 + (int)v45 * (uint64_t)v37;
      v32 = v639;
      v641 = v45 - v639;
      goto LABEL_21;
    }
    v631 = v28;
    v39 = v640;
    v40 = v642;
    v41 = v646;
    if (!v9)
    {
      v46 = 0;
      v43 = 0;
      v641 = 0;
      v44 = 0;
      v42 = v648;
LABEL_21:
      v51 = v651;
LABEL_32:
      v649 = v44;
      v60 = v645 ^ 0xFFFF;
      v636 = (v41 - 1) + 1;
      v635 = -v32;
      v632 = v34;
      v637 = (int8x8_t *)(v34 - 8);
      v633 = v33;
      v61 = v43;
      v652 = 2 * v33;
      while (2)
      {
        v654 = v46;
        v647 = v61;
        v62 = (void (*)(_QWORD *, uint64_t, uint64_t, uint64_t))*v40;
        v651 = v51;
        v62(v40, v42, v51, v41);
        v64 = v40[20];
        v65 = (_BYTE *)v40[18];
        v66 = *((_DWORD *)v40 + 2);
        if (v66 == *((_DWORD *)v40 + 3))
        {
          if (v645 == 0xFFFF)
          {
            v69 = v652;
            v46 = v654;
          }
          else
          {
            v67 = v41;
            v68 = (_BYTE *)v40[18];
            v69 = v652;
            v46 = v654;
            do
            {
              if (*v68)
              {
                v70 = *(unsigned __int16 *)(v64 + 8);
                v71 = (unsigned __int16)WORD2(*(_QWORD *)v64) * v60;
                *(_QWORD *)v64 = ((HIWORD(*(_QWORD *)v64)
                                 - ((HIWORD(*(_QWORD *)v64) * v60
                                   + ((HIWORD(*(_QWORD *)v64) * v60) >> 16)
                                   + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v64)
                                                                                             - ((v71 + HIWORD(v71) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v64) - ((WORD1(*(_QWORD *)v64) * v60 + ((WORD1(*(_QWORD *)v64) * v60) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v64 - (((unsigned __int16)*(_QWORD *)v64 * v60 + (((unsigned __int16)*(_QWORD *)v64 * v60) >> 16) + 1) >> 16));
                *(_WORD *)(v64 + 8) = v70 - ((v70 * v60 + ((v70 * v60) >> 16) + 1) >> 16);
              }
              ++v68;
              v64 += 16;
              --v67;
            }
            while (v67);
            v64 += 16 * v635;
            v65 += v636 + v635;
          }
        }
        else
        {
          v72 = v40[19];
          v73 = HIWORD(v66) & 0x3F;
          if (v73 == 16)
          {
            v69 = v652;
            v46 = v654;
            v87 = 0;
            v88 = 0;
            if (v645 == 0xFFFF)
            {
              do
              {
                if (v65[v87])
                  *(_OWORD *)(v64 + v88) = *(_OWORD *)(v72 + v88);
                v88 += 16;
                ++v87;
              }
              while ((_DWORD)v41 != (_DWORD)v87);
            }
            else
            {
              do
              {
                if (v65[v87])
                {
                  v89 = *(unsigned __int16 *)(v72 + v88 + 8);
                  v90 = *(_QWORD *)(v72 + v88);
                  v91 = v64 + v88;
                  *(_QWORD *)v91 = ((HIWORD(v90)
                                   - ((HIWORD(v90) * v60 + ((HIWORD(v90) * v60) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v90) - ((WORD2(v90) * v60 + ((WORD2(v90) * v60) >> 16) + 1) >> 16)) << 32) | ((WORD1(v90) - ((WORD1(v90) * v60 + ((WORD1(v90) * v60) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v90 - (((unsigned __int16)v90 * v60 + (((unsigned __int16)v90 * v60) >> 16) + 1) >> 16));
                  *(_WORD *)(v91 + 8) = v89 - ((v89 * v60 + ((v89 * v60) >> 16) + 1) >> 16);
                }
                v88 += 16;
                ++v87;
              }
              while ((_DWORD)v41 != (_DWORD)v87);
            }
          }
          else
          {
            v69 = v652;
            v46 = v654;
            if (v73 == 32)
            {
              if (v645 == 0xFFFF)
              {
                v103 = 0;
                v104 = 0;
                v105 = v72 + 8;
                do
                {
                  if (v65[v103])
                  {
                    v63.i32[0] = *(_DWORD *)(v105 + 8);
                    if (*(float *)v63.i32 <= 0.0)
                    {
                      LOWORD(v106) = 0;
                      *(_QWORD *)(v64 + v104) = 0;
                    }
                    else
                    {
                      LODWORD(v106) = (int)(float)((float)(*(float *)v63.i32 * 65535.0) + 0.5);
                      v107 = *(float *)(v105 - 8);
                      if (*(float *)v63.i32 <= 1.0)
                        v106 = v106;
                      else
                        v106 = 0xFFFFLL;
                      if (*(float *)v63.i32 > 1.0)
                        *(float *)v63.i32 = 1.0;
                      LOWORD(v108) = v106;
                      if (v107 <= *(float *)v63.i32)
                      {
                        if (v107 >= 0.0)
                          v108 = (int)(float)((float)(v107 * 65535.0) + 0.5);
                        else
                          LOWORD(v108) = 0;
                      }
                      v109 = *(float *)(v105 - 4);
                      v110 = v106;
                      if (v109 <= *(float *)v63.i32)
                      {
                        if (v109 >= 0.0)
                          v110 = (int)(float)((float)(v109 * 65535.0) + 0.5);
                        else
                          v110 = 0;
                      }
                      v111 = *(float *)v105;
                      LOWORD(v112) = v106;
                      if (*(float *)v105 <= *(float *)v63.i32)
                      {
                        if (v111 >= 0.0)
                          v112 = (int)(float)((float)(v111 * 65535.0) + 0.5);
                        else
                          LOWORD(v112) = 0;
                      }
                      v113 = *(float *)(v105 + 4);
                      v114 = v106;
                      if (v113 <= *(float *)v63.i32)
                      {
                        if (v113 >= 0.0)
                          v114 = (int)(float)((float)(v113 * 65535.0) + 0.5);
                        else
                          v114 = 0;
                      }
                      *(_QWORD *)(v64 + v104) = ((unint64_t)(unsigned __int16)v112 << 32) | (v114 << 48) | (v110 << 16) | (unint64_t)(unsigned __int16)v108;
                    }
                    *(_WORD *)(v64 + v104 + 8) = v106;
                  }
                  v104 += 16;
                  v105 += 20;
                  ++v103;
                }
                while ((_DWORD)v41 != (_DWORD)v103);
              }
              else
              {
                v74 = 0;
                v75 = 0;
                v76 = v72 + 8;
                do
                {
                  if (v65[v74])
                  {
                    v63.i32[0] = *(_DWORD *)(v76 + 8);
                    if (*(float *)v63.i32 <= 0.0)
                    {
                      LOWORD(v81) = 0;
                      *(_QWORD *)(v64 + v75) = 0;
                    }
                    else
                    {
                      v77 = *(float *)(v76 - 8);
                      v78 = (int)(float)((float)(*(float *)v63.i32 * 65535.0) + 0.5);
                      if (*(float *)v63.i32 > 1.0)
                        v78 = 0xFFFF;
                      v79 = v78;
                      if (*(float *)v63.i32 > 1.0)
                        *(float *)v63.i32 = 1.0;
                      v80 = v78;
                      if (v77 <= *(float *)v63.i32)
                      {
                        if (v77 >= 0.0)
                          v80 = (int)(float)((float)(v77 * 65535.0) + 0.5);
                        else
                          v80 = 0;
                      }
                      v82 = *(float *)(v76 - 4);
                      v83 = v78;
                      if (v82 <= *(float *)v63.i32)
                      {
                        if (v82 >= 0.0)
                          v83 = (int)(float)((float)(v82 * 65535.0) + 0.5);
                        else
                          v83 = 0;
                      }
                      v84 = *(float *)v76;
                      v85 = v78;
                      if (*(float *)v76 <= *(float *)v63.i32)
                      {
                        if (v84 >= 0.0)
                          v85 = (int)(float)((float)(v84 * 65535.0) + 0.5);
                        else
                          v85 = 0;
                      }
                      v86 = *(float *)(v76 + 4);
                      if (v86 <= *(float *)v63.i32)
                      {
                        if (v86 >= 0.0)
                          v79 = (int)(float)((float)(v86 * 65535.0) + 0.5);
                        else
                          v79 = 0;
                      }
                      v81 = v78 - ((v78 * v60 + ((v78 * v60) >> 16) + 1) >> 16);
                      *(_QWORD *)(v64 + v75) = ((unint64_t)(unsigned __int16)(v85
                                                                                   - ((v85 * v60
                                                                                     + ((v85 * v60) >> 16)
                                                                                     + 1) >> 16)) << 32) | ((unint64_t)(v79 - ((v79 * v60 + ((v79 * v60) >> 16) + 1) >> 16)) << 48) | ((v83 - ((v83 * v60 + ((v83 * v60) >> 16) + 1) >> 16)) << 16) | (unint64_t)(unsigned __int16)(v80 - ((v80 * v60 + ((v80 * v60) >> 16) + 1) >> 16));
                    }
                    *(_WORD *)(v64 + v75 + 8) = v81;
                  }
                  v75 += 16;
                  v76 += 20;
                  ++v74;
                }
                while ((_DWORD)v41 != (_DWORD)v74);
              }
            }
            else if (v645 == 0xFFFF)
            {
              v115 = 0;
              v116 = (_WORD *)(v64 + 8);
              do
              {
                if (v65[v115])
                {
                  v117 = *(_QWORD *)(v72 + 8 * v115);
                  HIDWORD(v118) = BYTE3(v117);
                  LODWORD(v118) = v117;
                  *((_QWORD *)v116 - 1) = ((unint64_t)(v117 | ((_DWORD)v117 << 8)) << 48) | ((unint64_t)(BYTE1(v117) | (BYTE1(v117) << 8)) << 32) | v117 & 0xFF0000 | ((unint64_t)BYTE2(v117) << 24) | (v118 >> 24);
                  *v116 = BYTE4(v117) | (unsigned __int16)(WORD2(v117) << 8);
                }
                ++v115;
                v116 += 8;
              }
              while ((_DWORD)v41 != (_DWORD)v115);
            }
            else
            {
              v92 = 0;
              v93 = (_WORD *)(v64 + 8);
              do
              {
                if (v65[v92])
                {
                  v94 = v72 + 8 * v92;
                  v95 = *(unsigned __int8 *)(v94 + 4);
                  LODWORD(v94) = *(_DWORD *)v94;
                  v96 = BYTE2(v94);
                  v97 = BYTE1(v94);
                  v98 = v94;
                  HIDWORD(v99) = BYTE3(v94);
                  LODWORD(v99) = v94;
                  LODWORD(v94) = v99 >> 24;
                  v100 = v96 | (v96 << 8);
                  v101 = v97 | (v97 << 8);
                  v102 = v98 | (v98 << 8);
                  *((_QWORD *)v93 - 1) = ((unint64_t)(v102
                                                           - ((v102 * v60 + ((v102 * v60) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v101 - ((v101 * v60 + ((v101 * v60) >> 16) + 1) >> 16)) << 32) | ((v100 - ((v100 * v60 + ((v100 * v60) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v94 - (((_DWORD)v94 * v60 + ((v94 * v60) >> 16) + 1) >> 16));
                  *v93 = (v95 | ((_WORD)v95 << 8))
                       - (((v95 | (v95 << 8)) * v60 + (((v95 | (v95 << 8)) * v60) >> 16) + 1) >> 16);
                }
                ++v92;
                v93 += 8;
              }
              while ((_DWORD)v41 != (_DWORD)v92);
            }
          }
        }
        switch(v39)
        {
          case 0:
            v119 = v42;
            v120 = v46 != 0;
            if (v653)
            {
              v121 = v46;
              do
              {
                v122 = *v65;
                if (*v65)
                {
                  if (v46)
                    v122 = ((unsigned __int16)(*v121 * (_WORD)v122
                                                              + ((*v121 * v122) >> 8)
                                                              + 1) >> 8);
                  if (v122)
                  {
                    if (v122 == 255)
                    {
                      *v35 = 0;
                      *v31 = 0;
                    }
                    else
                    {
                      CMYK64_DAM(v35, v31, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*v31) >> 16, (v122 | (v122 << 8)) ^ 0xFFFF);
                      v46 = v654;
                    }
                  }
                }
                ++v65;
                v121 += v120;
                ++v35;
                ++v31;
                LODWORD(v41) = v41 - 1;
              }
              while ((_DWORD)v41);
              v46 = &v121[v641];
              v35 += v643;
              v31 += v644;
              v41 = v646;
            }
            else
            {
              v467 = v41;
              v468 = v46;
              do
              {
                v469 = *v65;
                if (*v65)
                {
                  if (v46)
                    v469 = ((unsigned __int16)(*v468 * (_WORD)v469
                                                              + ((*v468 * v469) >> 8)
                                                              + 1) >> 8);
                  if (v469)
                  {
                    if (v469 == 255)
                    {
                      *v35 = 0;
                    }
                    else
                    {
                      v470 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                      v471.i32[0] = (unsigned __int16)v470;
                      v471.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v470), 0x10uLL).i32[1];
                      v471.i64[1] = __PAIR64__(bswap32(v35->u16[3]) >> 16, bswap32(v35->u16[2]) >> 16);
                      v472 = (uint32x4_t)vmulq_s32(v471, vdupq_n_s32(v469 | (v469 << 8)));
                      v473.i64[0] = 0x100000001;
                      v473.i64[1] = 0x100000001;
                      v471.i32[0] = v470;
                      *v35 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v471, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v472, v472, 0x10uLL), v473), 0x10uLL))));
                    }
                  }
                }
                ++v65;
                v468 += v120;
                ++v35;
                --v467;
              }
              while (v467);
              v46 = &v468[v641];
              v35 += v643;
              v31 += v644;
            }
            v42 = v119;
            goto LABEL_494;
          case 1:
            v123 = *v65;
            if (v653)
            {
              v648 = v42;
              if (v46)
              {
                v124 = 0;
                v125 = (unsigned __int16 *)(v64 + 8);
                v126 = v65 + 1;
                v127 = v31;
                do
                {
                  v128 = (uint64_t)v35;
                  v129 = v127;
                  if (v123)
                  {
                    v130 = v46[v124] * v123 + ((v46[v124] * v123) >> 8) + 1;
                    if (BYTE1(v130))
                    {
                      if (BYTE1(v130) == 255)
                      {
                        v131 = *((_QWORD *)v125 - 1);
                        v132 = HIDWORD(v131);
                        v133 = HIWORD(v131);
                        LODWORD(v131) = bswap32(v131);
                        v35->i16[0] = WORD1(v131);
                        v35->i16[1] = v131;
                        v35->i16[2] = bswap32(v132) >> 16;
                        v35->i16[3] = __rev16(v133);
                        v31[v124] = bswap32(*v125) >> 16;
                      }
                      else
                      {
                        CMYK64_DAMplusDAM(v35, v129, *((_QWORD *)v125 - 1), *v125, (unsigned __int16)(257 * (v130 >> 8)), ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(v31[v124]) >> 16, (unsigned __int16)~(257 * (v130 >> 8)));
                        v46 = v654;
                      }
                    }
                  }
                  v123 = v126[v124];
                  ++v35;
                  v127 = v129 + 1;
                  ++v124;
                  v125 += 8;
                }
                while ((_DWORD)v646 != (_DWORD)v124);
                v46 += v124 + v641;
              }
              else
              {
                v557 = 0;
                v558 = 0;
                v559 = v65 + 1;
                do
                {
                  if (v123)
                  {
                    v560 = &v31[v557];
                    if (v123 == 255)
                    {
                      v561 = *(_QWORD *)(v64 + 4 * v557);
                      v562 = HIDWORD(v561);
                      v563 = HIWORD(v561);
                      LODWORD(v561) = bswap32(v561);
                      v564 = &v35[v558 / 8];
                      v564->i16[0] = WORD1(v561);
                      v564->i16[1] = v561;
                      v564->i16[2] = bswap32(v562) >> 16;
                      v564->i16[3] = __rev16(v563);
                      *v560 = bswap32(*(unsigned __int16 *)(v64 + 2 * v558 + 8)) >> 16;
                    }
                    else
                    {
                      CMYK64_DAMplusDAM(&v35[v558 / 8], v560, *(_QWORD *)(v64 + 4 * v557), *(unsigned __int16 *)(v64 + 2 * v558 + 8), v123 | (v123 << 8), ((unint64_t)(bswap32(v35[v558 / 8].u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[v558 / 8].u16[3]) >> 16) << 48) | bswap32(v35[v558 / 8].u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35[v558 / 8].u16[0]) >> 16), bswap32(*v560) >> 16, (v123 | (v123 << 8)) ^ 0xFFFF);
                    }
                  }
                  v565 = *v559++;
                  v123 = v565;
                  v558 += 8;
                  ++v557;
                  LODWORD(v41) = v41 - 1;
                }
                while ((_DWORD)v41);
                v46 = 0;
                v129 = &v31[v557 - 1];
                v128 = (uint64_t)&v35[v558 / 8 - 1];
              }
              v35 = (int8x8_t *)(v128 + 8 * v643 + 8);
              v31 = &v129[v644 + 1];
              goto LABEL_492;
            }
            if (v46)
            {
              v474 = v65 + 1;
              v475 = v41;
              v138 = v650;
              do
              {
                if (v123)
                {
                  v476 = *v46 * v123 + ((*v46 * v123) >> 8) + 1;
                  v477 = *(int8x8_t **)(v638 + 40);
                  v478 = v637;
                  if (v637 >= v35)
                    v478 = v35;
                  if (v478 >= v477)
                    v477 = v478;
                  if (BYTE1(v476))
                  {
                    if (BYTE1(v476) == 255)
                    {
                      v479 = HIDWORD(*(_QWORD *)v64);
                      v480 = HIWORD(*(_QWORD *)v64);
                      v481 = bswap32(*(_QWORD *)v64);
                      v477->i16[0] = HIWORD(v481);
                      v477->i16[1] = v481;
                      v477->i16[2] = bswap32(v479) >> 16;
                      v477->i16[3] = __rev16(v480);
                    }
                    else
                    {
                      v482 = bswap32(v477->u16[1] | (v477->u16[0] << 16));
                      v483.i32[0] = 257 * (v476 >> 8);
                      v483.i32[1] = ~v483.i32[0];
                      *(int8x8_t *)v484.i8 = vand_s8(v483, (int8x8_t)0xFFFF0000FFFFLL);
                      v485.i64[0] = v484.i64[0];
                      v485.i64[1] = v484.i64[0];
                      v486.i32[0] = (unsigned __int16)v482;
                      v486.i32[1] = WORD1(*(_QWORD *)v64);
                      v486.i32[2] = bswap32(v477->u16[2]) >> 16;
                      v486.i32[3] = HIWORD(*(_QWORD *)v64);
                      v484.i64[1] = v484.i64[0];
                      v487 = vmulq_s32(v486, vrev64q_s32(v484));
                      v486.i32[0] = (unsigned __int16)*(_QWORD *)v64;
                      v486.i32[1] = HIWORD(v482);
                      v486.i32[2] = (unsigned __int16)WORD2(*(_QWORD *)v64);
                      v486.i32[3] = bswap32(v477->u16[3]) >> 16;
                      v488 = (int8x16_t)vmlaq_s32(v487, v486, v485);
                      *v477 = vrev16_s8((int8x8_t)vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v488, 0x10uLL), (int32x4_t)vmvnq_s8(v488)));
                    }
                  }
                }
                else
                {
                  v477 = v35;
                }
                v489 = *v474++;
                v123 = v489;
                v64 += 16;
                ++v46;
                v35 = v477 + 1;
                --v475;
              }
              while (v475);
              v46 += v641;
              goto LABEL_620;
            }
            v596 = *(int8x8_t **)(v638 + 40);
            v597 = v65 + 1;
            v598 = v41;
            v138 = v650;
            do
            {
              v477 = v637;
              if (v637 >= v35)
                v477 = v35;
              if (v477 < v596)
                v477 = v596;
              if (v123)
              {
                if (v123 == 255)
                {
                  v599 = HIDWORD(*(_QWORD *)v64);
                  v600 = HIWORD(*(_QWORD *)v64);
                  v601 = bswap32(*(_QWORD *)v64);
                  v477->i16[0] = HIWORD(v601);
                  v477->i16[1] = v601;
                  v477->i16[2] = bswap32(v599) >> 16;
                  v477->i16[3] = __rev16(v600);
                }
                else
                {
                  v602 = bswap32(v477->u16[1] | (v477->u16[0] << 16));
                  v63.i8[0] = v123;
                  v63.i8[1] = v123;
                  v63.i32[1] = ~v63.i32[0];
                  *(int8x8_t *)v603.i8 = vand_s8(*(int8x8_t *)v63.i8, (int8x8_t)0xFFFF0000FFFFLL);
                  v604.i64[0] = v603.i64[0];
                  v604.i64[1] = v603.i64[0];
                  v605.i32[0] = (unsigned __int16)v602;
                  v605.i32[1] = WORD1(*(_QWORD *)v64);
                  v605.i32[2] = bswap32(v477->u16[2]) >> 16;
                  v605.i32[3] = HIWORD(*(_QWORD *)v64);
                  v603.i64[1] = v603.i64[0];
                  v606 = vmulq_s32(v605, vrev64q_s32(v603));
                  v605.i32[0] = (unsigned __int16)*(_QWORD *)v64;
                  v605.i32[1] = HIWORD(v602);
                  v605.i32[2] = (unsigned __int16)WORD2(*(_QWORD *)v64);
                  v605.i32[3] = bswap32(v477->u16[3]) >> 16;
                  v63 = (int8x16_t)vmlaq_s32(v606, v605, v604);
                  *v477 = vrev16_s8((int8x8_t)vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v63, 0x10uLL), (int32x4_t)vmvnq_s8(v63)));
                }
              }
              v607 = *v597++;
              v123 = v607;
              v64 += 16;
              v35 = v477 + 1;
              --v598;
            }
            while (v598);
            goto LABEL_619;
          case 2:
            v134 = *v65;
            if (v653)
            {
              if (v46)
              {
                v135 = 0;
                v136 = (uint64_t)(v31 - 1);
                v137 = v35 - 1;
                v138 = v650;
                while (1)
                {
                  if (!v134)
                    goto LABEL_156;
                  v139 = v46[v135] * v134 + ((v46[v135] * v134) >> 8) + 1;
                  if (!BYTE1(v139))
                    goto LABEL_156;
                  if (BYTE1(v139) == 255)
                  {
                    v140 = *(unsigned __int16 *)(v64 + 8);
                    if (*(_WORD *)(v64 + 8))
                    {
                      if (v140 == 0xFFFF)
                      {
                        v141 = HIDWORD(*(_QWORD *)v64);
                        v142 = HIWORD(*(_QWORD *)v64);
                        v143 = bswap32(*(_QWORD *)v64);
                        v137[1].i16[0] = HIWORD(v143);
                        v137[1].i16[1] = v143;
                        v137[1].i16[2] = bswap32(v141) >> 16;
                        v137[1].i16[3] = __rev16(v142);
                        LOWORD(v143) = -1;
                      }
                      else
                      {
                        v156 = bswap32(v137[1].u16[1] | (v137[1].u16[0] << 16));
                        v157.i32[0] = (unsigned __int16)v156;
                        v157.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v156), 0x10uLL).i32[1];
                        v158 = (unsigned __int16)~(_WORD)v140 * (bswap32(v31[v135]) >> 16);
                        v157.i64[1] = __PAIR64__(bswap32(v137[1].u16[3]) >> 16, bswap32(v137[1].u16[2]) >> 16);
                        v159 = (uint32x4_t)vmulq_s32(v157, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v140)));
                        v160.i64[0] = 0x100000001;
                        v160.i64[1] = 0x100000001;
                        v161 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v159, v159, 0x10uLL), v160);
                        v160.i32[0] = *(_QWORD *)v64;
                        v160.i32[1] = v160.u16[1];
                        v137[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v160.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v64), (uint64x2_t)xmmword_185004DA0)), v161, 0x10uLL)));
                        v155 = v140 + ((v158 + HIWORD(v158) + 1) >> 16);
LABEL_154:
                        v143 = bswap32(v155) >> 16;
                      }
                      v31[v135] = v143;
                    }
                  }
                  else
                  {
                    v144 = *(unsigned __int16 *)(v64 + 8);
                    v145 = (257 * (v139 >> 8)) ^ 0xFFFF;
                    v146 = v144 - ((v145 * v144 + ((v145 * v144) >> 16) + 1) >> 16);
                    if (v144 != (v145 * v144 + ((v145 * v144) >> 16) + 1) >> 16)
                    {
                      v147 = (unsigned __int16)WORD2(*(_QWORD *)v64) * v145;
                      v148 = ((HIWORD(*(_QWORD *)v64)
                             - ((v145 * HIWORD(*(_QWORD *)v64)
                               + ((v145 * HIWORD(*(_QWORD *)v64)) >> 16)
                               + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v64)
                                                                                         - ((v147 + HIWORD(v147) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v64) - ((WORD1(*(_QWORD *)v64) * v145 + ((WORD1(*(_QWORD *)v64) * v145) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v64 - (((unsigned __int16)*(_QWORD *)v64 * v145 + (((unsigned __int16)*(_QWORD *)v64 * v145) >> 16) + 1) >> 16));
                      v149 = bswap32(v137[1].u16[1] | (v137[1].u16[0] << 16));
                      v150.i32[0] = (unsigned __int16)v149;
                      v150.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v149), 0x10uLL).i32[1];
                      v151 = (unsigned __int16)~(_WORD)v146 * (bswap32(v31[v135]) >> 16);
                      v150.i64[1] = __PAIR64__(bswap32(v137[1].u16[3]) >> 16, bswap32(v137[1].u16[2]) >> 16);
                      v152 = (uint32x4_t)vmulq_s32(v150, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v146)));
                      v153.i64[0] = 0x100000001;
                      v153.i64[1] = 0x100000001;
                      v154 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v152, v152, 0x10uLL), v153);
                      v153.i32[0] = v148;
                      v153.i32[1] = WORD1(v148);
                      v137[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v153.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v148), (uint64x2_t)xmmword_185004DA0)), v154, 0x10uLL)));
                      v155 = v146 + ((v151 + HIWORD(v151) + 1) >> 16);
                      goto LABEL_154;
                    }
                  }
LABEL_156:
                  v134 = v65[v135 + 1];
                  v64 += 16;
                  ++v135;
                  v136 += 2;
                  ++v137;
                  if ((_DWORD)v41 == (_DWORD)v135)
                  {
                    v46 += v135 + v641;
LABEL_596:
                    v35 = &v137[v643 + 1];
                    v31 = (unsigned __int16 *)(v136 + 2 * v644 + 2);
                    goto LABEL_621;
                  }
                }
              }
              v566 = 0;
              v567 = 0;
              v568 = v65 + 1;
              v569 = v41;
              v138 = v650;
              while (1)
              {
                if (v134)
                {
                  if (v134 == 255)
                  {
                    v570 = *(unsigned __int16 *)(v64 + 2 * v566 + 8);
                    if (*(_WORD *)(v64 + 2 * v566 + 8))
                    {
                      if (v570 == 0xFFFF)
                      {
                        v571 = *(_QWORD *)(v64 + 4 * v567);
                        v572 = HIDWORD(v571);
                        v573 = HIWORD(v571);
                        v575 = bswap32(v571);
                        v574 = &v35[v566 / 8];
                        v574->i16[0] = HIWORD(v575);
                        v574->i16[1] = v575;
                        v574->i16[2] = bswap32(v572) >> 16;
                        v574->i16[3] = __rev16(v573);
                        LOWORD(v575) = -1;
                      }
                      else
                      {
                        v588 = *(_QWORD *)(v64 + 4 * v567);
                        v589 = bswap32(v35[v566 / 8].u16[1] | (v35[v566 / 8].u16[0] << 16));
                        v590.i32[0] = (unsigned __int16)v589;
                        v590.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v589), 0x10uLL).i32[1];
                        v591 = (unsigned __int16)~(_WORD)v570 * (bswap32(v31[v567]) >> 16);
                        v590.i64[1] = __PAIR64__(bswap32(v35[v566 / 8].u16[3]) >> 16, bswap32(v35[v566 / 8].u16[2]) >> 16);
                        v592 = (uint32x4_t)vmulq_s32(v590, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v570)));
                        v593.i64[0] = 0x100000001;
                        v593.i64[1] = 0x100000001;
                        v594 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v592, v592, 0x10uLL), v593);
                        v593.i32[0] = v588;
                        v593.i32[1] = WORD1(v588);
                        v35[v566 / 8] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v593.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v588), (uint64x2_t)xmmword_185004DA0)), v594, 0x10uLL)));
                        v587 = v570 + ((v591 + HIWORD(v591) + 1) >> 16);
LABEL_592:
                        v575 = bswap32(v587) >> 16;
                      }
                      v31[v567] = v575;
                    }
                  }
                  else
                  {
                    v576 = *(unsigned __int16 *)(v64 + 2 * v566 + 8);
                    v577 = (257 * v134) ^ 0xFFFF;
                    v578 = v576 - ((v577 * v576 + ((v577 * v576) >> 16) + 1) >> 16);
                    if (v576 != (v577 * v576 + ((v577 * v576) >> 16) + 1) >> 16)
                    {
                      v579 = *(_QWORD *)(v64 + 4 * v567);
                      v580 = ((HIWORD(v579)
                             - ((v577 * HIWORD(v579) + ((v577 * HIWORD(v579)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v579) - ((WORD2(v579) * v577 + ((WORD2(v579) * v577) >> 16) + 1) >> 16)) << 32) | ((WORD1(v579) - ((WORD1(v579) * v577 + ((WORD1(v579) * v577) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v579 - (((unsigned __int16)v579 * v577 + (((unsigned __int16)v579 * v577) >> 16) + 1) >> 16));
                      v581 = bswap32(v35[v566 / 8].u16[1] | (v35[v566 / 8].u16[0] << 16));
                      v582.i32[0] = (unsigned __int16)v581;
                      v582.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v581), 0x10uLL).i32[1];
                      v583 = (unsigned __int16)~(_WORD)v578 * (bswap32(v31[v567]) >> 16);
                      v582.i64[1] = __PAIR64__(bswap32(v35[v566 / 8].u16[3]) >> 16, bswap32(v35[v566 / 8].u16[2]) >> 16);
                      v584 = (uint32x4_t)vmulq_s32(v582, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v578)));
                      v585.i64[0] = 0x100000001;
                      v585.i64[1] = 0x100000001;
                      v586 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v584, v584, 0x10uLL), v585);
                      v585.i32[0] = v580;
                      v585.i32[1] = WORD1(v580);
                      v35[v566 / 8] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v585.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v580), (uint64x2_t)xmmword_185004DA0)), v586, 0x10uLL)));
                      v587 = v578 + ((v583 + HIWORD(v583) + 1) >> 16);
                      goto LABEL_592;
                    }
                  }
                }
                v595 = *v568++;
                v134 = v595;
                ++v567;
                v566 += 8;
                if (!--v569)
                {
                  v46 = 0;
                  v136 = (uint64_t)&v31[v567 - 1];
                  v137 = &v35[v566 / 8 - 1];
                  goto LABEL_596;
                }
              }
            }
            if (!v46)
            {
              v608 = v65 + 1;
              v477 = v35 - 1;
              v609 = v41;
              v138 = v650;
              while (1)
              {
                if (v134)
                {
                  if (v134 == 255)
                  {
                    v610 = *(unsigned __int16 *)(v64 + 8);
                    if (*(_WORD *)(v64 + 8))
                    {
                      if (v610 != 0xFFFF)
                      {
                        v626 = bswap32(v477[1].u16[1] | (v477[1].u16[0] << 16));
                        v627.i32[0] = (unsigned __int16)v626;
                        v627.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v626), 0x10uLL).i32[1];
                        v627.i64[1] = __PAIR64__(bswap32(v477[1].u16[3]) >> 16, bswap32(v477[1].u16[2]) >> 16);
                        v621 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v64), (uint64x2_t)xmmword_185004DA0);
                        v628 = (uint32x4_t)vmulq_s32(v627, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v610)));
                        v623 = (int32x4_t)vsraq_n_u32(v628, v628, 0x10uLL);
                        v624.i64[0] = 0x100000001;
                        v624.i64[1] = 0x100000001;
                        v625.i32[0] = *(_QWORD *)v64;
                        v625.i32[1] = v625.u16[1];
                        goto LABEL_617;
                      }
                      v611 = HIDWORD(*(_QWORD *)v64);
                      v612 = HIWORD(*(_QWORD *)v64);
                      v613 = bswap32(*(_QWORD *)v64);
                      v477[1].i16[0] = HIWORD(v613);
                      v477[1].i16[1] = v613;
                      v477[1].i16[2] = bswap32(v611) >> 16;
                      v477[1].i16[3] = __rev16(v612);
                    }
                  }
                  else
                  {
                    v614 = *(unsigned __int16 *)(v64 + 8);
                    v615 = (257 * v134) ^ 0xFFFF;
                    v616 = v615 * v614 + ((v615 * v614) >> 16) + 1;
                    if (v614 != HIWORD(v616))
                    {
                      v617 = (unsigned __int16)WORD2(*(_QWORD *)v64) * v615;
                      v618 = ((HIWORD(*(_QWORD *)v64)
                             - ((v615 * HIWORD(*(_QWORD *)v64)
                               + ((v615 * HIWORD(*(_QWORD *)v64)) >> 16)
                               + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v64)
                                                                                         - ((v617 + HIWORD(v617) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v64) - ((WORD1(*(_QWORD *)v64) * v615 + ((WORD1(*(_QWORD *)v64) * v615) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v64 - (((unsigned __int16)*(_QWORD *)v64 * v615 + (((unsigned __int16)*(_QWORD *)v64 * v615) >> 16) + 1) >> 16));
                      v619 = bswap32(v477[1].u16[1] | (v477[1].u16[0] << 16));
                      v620.i32[0] = (unsigned __int16)v619;
                      v620.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v619), 0x10uLL).i32[1];
                      v620.i64[1] = __PAIR64__(bswap32(v477[1].u16[3]) >> 16, bswap32(v477[1].u16[2]) >> 16);
                      v621 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v618), (uint64x2_t)xmmword_185004DA0);
                      v622 = (uint32x4_t)vmulq_s32(v620, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v614 + HIWORD(v616))));
                      v623 = (int32x4_t)vsraq_n_u32(v622, v622, 0x10uLL);
                      v624.i64[0] = 0x100000001;
                      v624.i64[1] = 0x100000001;
                      v625.i32[0] = v618;
                      v625.i32[1] = WORD1(v618);
LABEL_617:
                      v477[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v625, v621), (uint32x4_t)vaddq_s32(v623, v624), 0x10uLL)));
                    }
                  }
                }
                v629 = *v608++;
                v134 = v629;
                v64 += 16;
                ++v477;
                if (!--v609)
                {
LABEL_619:
                  v46 = 0;
                  goto LABEL_620;
                }
              }
            }
            v490 = 0;
            v477 = v35 - 1;
            v138 = v650;
            do
            {
              if (v134)
              {
                v491 = v46[v490] * v134 + ((v46[v490] * v134) >> 8) + 1;
                if (BYTE1(v491))
                {
                  if (BYTE1(v491) == 255)
                  {
                    v492 = *(unsigned __int16 *)(v64 + 8);
                    if (!*(_WORD *)(v64 + 8))
                      goto LABEL_532;
                    if (v492 == 0xFFFF)
                    {
                      v493 = HIDWORD(*(_QWORD *)v64);
                      v494 = HIWORD(*(_QWORD *)v64);
                      v495 = bswap32(*(_QWORD *)v64);
                      v477[1].i16[0] = HIWORD(v495);
                      v477[1].i16[1] = v495;
                      v477[1].i16[2] = bswap32(v493) >> 16;
                      v477[1].i16[3] = __rev16(v494);
                      goto LABEL_532;
                    }
                    v509 = bswap32(v477[1].u16[1] | (v477[1].u16[0] << 16));
                    v510.i32[0] = (unsigned __int16)v509;
                    v510.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v509), 0x10uLL).i32[1];
                    v510.i64[1] = __PAIR64__(bswap32(v477[1].u16[3]) >> 16, bswap32(v477[1].u16[2]) >> 16);
                    v504 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v64), (uint64x2_t)xmmword_185004DA0);
                    v511 = (uint32x4_t)vmulq_s32(v510, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v492)));
                    v506 = (int32x4_t)vsraq_n_u32(v511, v511, 0x10uLL);
                    v507.i64[0] = 0x100000001;
                    v507.i64[1] = 0x100000001;
                    v508.i32[0] = *(_QWORD *)v64;
                    v508.i32[1] = v508.u16[1];
                  }
                  else
                  {
                    v496 = v491 >> 8;
                    v497 = *(unsigned __int16 *)(v64 + 8);
                    v498 = (257 * v496) ^ 0xFFFF;
                    v499 = v498 * v497 + ((v498 * v497) >> 16) + 1;
                    if (v497 == HIWORD(v499))
                      goto LABEL_532;
                    v500 = (unsigned __int16)WORD2(*(_QWORD *)v64) * v498;
                    v501 = ((HIWORD(*(_QWORD *)v64)
                           - ((v498 * HIWORD(*(_QWORD *)v64) + ((v498 * HIWORD(*(_QWORD *)v64)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v64) - ((v500 + HIWORD(v500) + 1) >> 16)) << 32) | ((WORD1(*(_QWORD *)v64) - ((WORD1(*(_QWORD *)v64) * v498 + ((WORD1(*(_QWORD *)v64) * v498) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v64 - (((unsigned __int16)*(_QWORD *)v64 * v498 + (((unsigned __int16)*(_QWORD *)v64 * v498) >> 16) + 1) >> 16));
                    v502 = bswap32(v477[1].u16[1] | (v477[1].u16[0] << 16));
                    v503.i32[0] = (unsigned __int16)v502;
                    v503.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v502), 0x10uLL).i32[1];
                    v503.i64[1] = __PAIR64__(bswap32(v477[1].u16[3]) >> 16, bswap32(v477[1].u16[2]) >> 16);
                    v504 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v501), (uint64x2_t)xmmword_185004DA0);
                    v505 = (uint32x4_t)vmulq_s32(v503, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v497 + HIWORD(v499))));
                    v506 = (int32x4_t)vsraq_n_u32(v505, v505, 0x10uLL);
                    v507.i64[0] = 0x100000001;
                    v507.i64[1] = 0x100000001;
                    v508.i32[0] = v501;
                    v508.i32[1] = WORD1(v501);
                  }
                  v477[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v508, v504), (uint32x4_t)vaddq_s32(v506, v507), 0x10uLL)));
                }
              }
LABEL_532:
              v134 = v65[v490 + 1];
              v64 += 16;
              ++v490;
              ++v477;
            }
            while ((_DWORD)v41 != (_DWORD)v490);
            v46 += v490 + v641;
LABEL_620:
            v35 = &v477[v643 + 1];
            v31 += v644;
LABEL_621:
            v166 = v651;
LABEL_565:
            v549 = v138 - 1;
            if (!v549)
            {
              v43 = v647;
LABEL_623:
              if (v43)
                free(v43);
              goto LABEL_625;
            }
            v61 = 0;
            ++v649;
            v650 = v549;
            v42 += v40[16];
            v51 = v40[17] + v166;
            v43 = v647;
            if (!v647)
              continue;
            v648 = v42;
            v50 = v639;
            v44 = v649;
LABEL_22:
            v52 = v46 - 16;
            v53 = v644 + v50;
            while (1)
            {
              while (1)
              {
                v54 = *(_DWORD *)v52;
                v55 = *(_DWORD *)v52 - v44;
                if (*(_DWORD *)v52 <= v44)
                  break;
                v650 -= v55;
                if (v650 < 1)
                  goto LABEL_623;
                v58 = v40[17];
                v648 += v40[16] * v55;
                v51 += v58 * v55;
                v35 += v631 * v55;
                v59 = v53 * v55;
                if (!v653)
                  v59 = 0;
                v31 += v59;
                v44 = v54;
              }
              if (v44 < *((_DWORD *)v46 - 3) + v54)
                break;
              v56 = v46;
              v57 = shape_enum_clip_scan((uint64_t)v43, v52);
              v46 = v56;
              if (!v57)
                goto LABEL_623;
            }
            v32 = v639;
            v42 = v648;
            v33 = v633;
            v34 = v632;
            v39 = v640;
            goto LABEL_32;
          case 3:
            v648 = v42;
            v162 = v46 != 0;
            v163 = (unsigned __int16 *)(v64 + 8);
            v164 = v41;
            v165 = v46;
            v166 = v651;
            do
            {
              v167 = *v65;
              if (*v65)
              {
                if (v46)
                  v167 = ((unsigned __int16)(*v165 * (_WORD)v167
                                                            + ((*v165 * v167) >> 8)
                                                            + 1) >> 8);
                if (v167)
                {
                  if (v167 == 255)
                  {
                    CMYK64_DAM(v35, v31, *((_QWORD *)v163 - 1), *v163, bswap32(*v31) >> 16);
                  }
                  else
                  {
                    v168 = v167 | (v167 << 8);
                    v169 = bswap32(*v31) >> 16;
                    CMYK64_DAMplusDAM(v35, v31, *((_QWORD *)v163 - 1), *v163, (v169 * v168 + ((v169 * v168) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v169, v168 ^ 0xFFFF);
                  }
                  v69 = v652;
                  v46 = v654;
                }
              }
              ++v65;
              v165 += v162;
              ++v35;
              v163 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              --v164;
            }
            while (v164);
            goto LABEL_234;
          case 4:
            v648 = v42;
            v170 = v46 != 0;
            v171 = (unsigned __int16 *)(v64 + 8);
            v172 = v41;
            v165 = v46;
            v166 = v651;
            do
            {
              v173 = *v65;
              if (*v65)
              {
                if (v46)
                  v173 = ((unsigned __int16)(*v165 * (_WORD)v173
                                                            + ((*v165 * v173) >> 8)
                                                            + 1) >> 8);
                if (v173)
                {
                  if (v173 == 255)
                  {
                    CMYK64_DAM(v35, v31, *((_QWORD *)v171 - 1), *v171, bswap32(~*v31) >> 16);
                  }
                  else
                  {
                    v174 = v173 | (v173 << 8);
                    v175 = bswap32(*v31) >> 16;
                    CMYK64_DAMplusDAM(v35, v31, *((_QWORD *)v171 - 1), *v171, ((v175 ^ 0xFFFF) * v174 + (((v175 ^ 0xFFFF) * v174) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v175, v174 ^ 0xFFFF);
                  }
                  v69 = v652;
                  v46 = v654;
                }
              }
              ++v65;
              v165 += v170;
              ++v35;
              v171 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              --v172;
            }
            while (v172);
            goto LABEL_234;
          case 5:
            v648 = v42;
            v176 = v46 != 0;
            v177 = (unsigned __int16 *)(v64 + 8);
            v178 = v41;
            v165 = v46;
            v166 = v651;
            do
            {
              v179 = *v65;
              if (*v65)
              {
                if (!v46
                  || (v179 = ((unsigned __int16)(*v165 * (_WORD)v179
                                                                + ((*v165 * v179) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  v180 = *((_QWORD *)v177 - 1);
                  v181 = (v179 | (v179 << 8)) ^ 0xFFFF;
                  v182 = ((HIWORD(v180) - ((v181 * HIWORD(v180) + ((v181 * HIWORD(v180)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v180) - ((WORD2(v180) * v181 + ((WORD2(v180) * v181) >> 16) + 1) >> 16)) << 32) | ((WORD1(v180) - ((WORD1(v180) * v181 + ((WORD1(v180) * v181) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v180 - (((unsigned __int16)v180 * v181 + (((unsigned __int16)v180 * v181) >> 16) + 1) >> 16));
                  v183 = *v177 - ((v181 * *v177 + ((v181 * *v177) >> 16) + 1) >> 16);
                  v184 = bswap32(*v31) >> 16;
                  CMYK64_DAMplusDAM(v35, v31, v182, (unsigned __int16)v183, v184, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v184, (unsigned __int16)~(_WORD)v183);
                  v46 = v654;
                  v69 = v652;
                }
              }
              ++v65;
              v165 += v176;
              ++v35;
              v177 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              --v178;
            }
            while (v178);
            goto LABEL_234;
          case 6:
            v648 = v42;
            v185 = v41;
            v186 = 0;
            v187 = 0;
            v188 = v46 != 0;
            v189 = v185;
            v190 = v46;
            do
            {
              v191 = *v65;
              if (*v65)
              {
                if (!v46
                  || (v191 = ((unsigned __int16)(*v190 * (_WORD)v191
                                                                + ((*v190 * v191) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  v192 = bswap32(*v31);
                  if (HIWORD(v192) != 0xFFFF)
                  {
                    if ((unsigned __int16)~HIWORD(v192) == 0xFFFF)
                    {
                      CMYK64_DAM(&v35[v187 / 8], v31, *(_QWORD *)(v64 + v186), *(unsigned __int16 *)(v64 + 2 * v187 + 8), v191 | (v191 << 8));
                      v46 = v654;
                      v69 = v652;
                    }
                    else
                    {
                      v193 = ((unint64_t)(bswap32(v35[v187 / 8].u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[v187 / 8].u16[3]) >> 16) << 48) | bswap32(v35[v187 / 8].u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35[v187 / 8].u16[0]) >> 16);
                      v194.i64[0] = *(_QWORD *)(v64 + v186);
                      v195 = (257 * v191 * (unsigned __int16)~HIWORD(v192)
                            + ((257 * v191 * (unsigned __int16)~HIWORD(v192)) >> 16)
                            + 1) >> 16;
                      v196 = (uint32x2_t)vdup_lane_s32(*(int32x2_t *)v194.i8, 0);
                      v194.i16[1] = 0;
                      v194.i32[1] = vshr_n_u32(v196, 0x10uLL).i32[1];
                      v197 = v195 * *(unsigned __int16 *)(v64 + 2 * v187 + 8);
                      v194.i64[1] = __PAIR64__(HIWORD(*(_QWORD *)(v64 + v186)), (unsigned __int16)WORD2(*(_QWORD *)(v64 + v186)));
                      v198 = (uint32x4_t)vmulq_s32(v194, vdupq_n_s32(v195));
                      v199.i64[0] = 0x100000001;
                      v199.i64[1] = 0x100000001;
                      v200 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v198, v198, 0x10uLL), v199);
                      v199.i32[0] = v193;
                      v199.i32[1] = WORD1(v193);
                      v35[v187 / 8] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v199.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v193), (uint64x2_t)xmmword_185004DA0)), v200, 0x10uLL)));
                      *v31 = bswap32(HIWORD(v192) + ((v197 + HIWORD(v197) + 1) >> 16)) >> 16;
                    }
                  }
                }
              }
              ++v65;
              v190 += v188;
              v187 += 8;
              v186 += 16;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              --v189;
            }
            while (v189);
            v46 = &v190[v641];
            v35 = (int8x8_t *)((char *)v35 + 8 * v643 + v187);
            v31 += v644;
            v39 = v640;
            goto LABEL_491;
          case 7:
            v201 = v46 != 0;
            if (v653)
            {
              v648 = v42;
              v202 = (unsigned __int16 *)(v64 + 8);
              v203 = v46;
              v166 = v651;
              do
              {
                v204 = *v65;
                if (*v65)
                {
                  if (v46)
                    v204 = ((unsigned __int16)(*v203 * (_WORD)v204
                                                              + ((*v203 * v204) >> 8)
                                                              + 1) >> 8);
                  if (v204)
                  {
                    if (v204 == 255)
                    {
                      CMYK64_DAM(v35, v31, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*v31) >> 16, *v202);
                    }
                    else
                    {
                      v205 = ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16);
                      v206 = bswap32(*v31) >> 16;
                      CMYK64_DAMplusDAM(v35, v31, v205, v206, (*v202 * (v204 | (v204 << 8)) + ((*v202 * (v204 | (v204 << 8))) >> 16) + 1) >> 16, v205, v206, (v204 | (v204 << 8)) ^ 0xFFFF);
                    }
                    v46 = v654;
                  }
                }
                ++v65;
                v203 += v201;
                ++v35;
                ++v31;
                v202 += 8;
                LODWORD(v41) = v41 - 1;
              }
              while ((_DWORD)v41);
              goto LABEL_562;
            }
            v512 = (unsigned __int16 *)(v64 + 8);
            v513 = v41;
            v514 = v46;
            v166 = v651;
            do
            {
              v515 = *v65;
              if (*v65)
              {
                if (v46)
                  v515 = ((unsigned __int16)(*v514 * (_WORD)v515
                                                            + ((*v514 * v515) >> 8)
                                                            + 1) >> 8);
                if (v515)
                {
                  if (v515 == 255)
                  {
                    v516 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                    v517.i32[0] = (unsigned __int16)v516;
                    v517.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v516), 0x10uLL).i32[1];
                    v517.i64[1] = __PAIR64__(bswap32(v35->u16[3]) >> 16, bswap32(v35->u16[2]) >> 16);
                    v518 = (uint32x4_t)vmulq_s32(v517, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*v512)));
                    v519.i64[0] = 0x100000001;
                    v519.i64[1] = 0x100000001;
                    v517.i32[0] = v516;
                    v520 = vsubq_s32(v517, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v518, v518, 0x10uLL), v519), 0x10uLL));
                  }
                  else
                  {
                    v521 = v515 | (v515 << 8);
                    v522 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                    v523.i32[0] = (unsigned __int16)v522;
                    v523.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v522), 0x10uLL).i32[1];
                    v524.i32[0] = (*v512 * v521 + ((*v512 * v521) >> 16) + 1) >> 16;
                    v524.i32[1] = ~v521;
                    *(int8x8_t *)v525.i8 = vand_s8(v524, (int8x8_t)0xFFFF0000FFFFLL);
                    v526.i64[0] = v525.i64[0];
                    v526.i64[1] = v525.i64[0];
                    v523.i32[2] = bswap32(v35->u16[2]) >> 16;
                    v523.i32[3] = bswap32(v35->u16[3]) >> 16;
                    v525.i64[1] = v525.i64[0];
                    v527 = (int8x16_t)vmulq_s32(v523, vaddq_s32(v526, vrev64q_s32(v525)));
                    v520 = (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v527, 0x10uLL), (int32x4_t)vmvnq_s8(v527)), 0x10uLL);
                  }
                  *v35 = vrev16_s8((int8x8_t)vmovn_s32(v520));
                }
              }
              ++v65;
              v514 += v201;
              ++v35;
              v512 += 8;
              --v513;
            }
            while (v513);
            goto LABEL_555;
          case 8:
            v207 = v46 != 0;
            if (v653)
            {
              v648 = v42;
              v208 = (unsigned __int16 *)(v64 + 8);
              v203 = v46;
              v166 = v651;
              do
              {
                v209 = *v65;
                if (*v65)
                {
                  if (v46)
                    v209 = ((unsigned __int16)(*v203 * (_WORD)v209
                                                              + ((*v203 * v209) >> 8)
                                                              + 1) >> 8);
                  if (v209)
                  {
                    if (v209 == 255)
                    {
                      CMYK64_DAM(v35, v31, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*v31) >> 16, *v208 ^ 0xFFFF);
                    }
                    else
                    {
                      v210 = ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16);
                      v211 = bswap32(*v31) >> 16;
                      CMYK64_DAMplusDAM(v35, v31, v210, v211, ((*v208 ^ 0xFFFF) * (v209 | (v209 << 8))+ (((*v208 ^ 0xFFFF) * (v209 | (v209 << 8))) >> 16)+ 1) >> 16, v210, v211, (v209 | (v209 << 8)) ^ 0xFFFF);
                    }
                    v46 = v654;
                  }
                }
                ++v65;
                v203 += v207;
                ++v35;
                ++v31;
                v208 += 8;
                LODWORD(v41) = v41 - 1;
              }
              while ((_DWORD)v41);
              goto LABEL_562;
            }
            v528 = (const __int16 *)(v64 + 8);
            v529 = v41;
            v514 = v46;
            v166 = v651;
            do
            {
              v530 = *v65;
              if (*v65)
              {
                if (v46)
                  v530 = ((unsigned __int16)(*v514 * (_WORD)v530
                                                            + ((*v514 * v530) >> 8)
                                                            + 1) >> 8);
                if (v530)
                {
                  if (v530 == 255)
                  {
                    v531 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                    v532.i32[0] = (unsigned __int16)v531;
                    v532.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v531), 0x10uLL).i32[1];
                    v532.i64[1] = __PAIR64__(bswap32(v35->u16[3]) >> 16, bswap32(v35->u16[2]) >> 16);
                    v533 = (uint16x4_t)vld1_dup_s16(v528);
                    v534 = (uint32x4_t)vmulq_s32(v532, (int32x4_t)vmovl_u16(v533));
                    v535.i64[0] = 0x100000001;
                    v535.i64[1] = 0x100000001;
                    v532.i32[0] = v531;
                    v536 = vsubq_s32(v532, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v534, v534, 0x10uLL), v535), 0x10uLL));
                  }
                  else
                  {
                    v537 = v530 | (v530 << 8);
                    v538 = bswap32(v35->u16[1] | (v35->u16[0] << 16));
                    v539.i32[0] = (unsigned __int16)v538;
                    v539.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v538), 0x10uLL).i32[1];
                    v540.i32[0] = ((*(unsigned __int16 *)v528 ^ 0xFFFF) * v537
                                 + (((*(unsigned __int16 *)v528 ^ 0xFFFFu) * v537) >> 16)
                                 + 1) >> 16;
                    v540.i32[1] = ~v537;
                    *(int8x8_t *)v541.i8 = vand_s8(v540, (int8x8_t)0xFFFF0000FFFFLL);
                    v542.i64[0] = v541.i64[0];
                    v542.i64[1] = v541.i64[0];
                    v539.i32[2] = bswap32(v35->u16[2]) >> 16;
                    v539.i32[3] = bswap32(v35->u16[3]) >> 16;
                    v541.i64[1] = v541.i64[0];
                    v543 = (int8x16_t)vmulq_s32(v539, vaddq_s32(v542, vrev64q_s32(v541)));
                    v536 = (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v543, 0x10uLL), (int32x4_t)vmvnq_s8(v543)), 0x10uLL);
                  }
                  *v35 = vrev16_s8((int8x8_t)vmovn_s32(v536));
                }
              }
              ++v65;
              v514 += v207;
              ++v35;
              v528 += 8;
              --v529;
            }
            while (v529);
LABEL_555:
            v40 = v642;
            v46 = &v514[v641];
            v35 += v643;
            v31 += v644;
            goto LABEL_564;
          case 9:
            v648 = v42;
            v212 = v46 != 0;
            v213 = (unsigned __int16 *)(v64 + 8);
            v214 = v41;
            v165 = v46;
            v166 = v651;
            do
            {
              v215 = *v65;
              if (*v65)
              {
                if (!v46
                  || (v215 = ((unsigned __int16)(*v165 * (_WORD)v215
                                                                + ((*v165 * v215) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  v216 = bswap32(*v31) >> 16;
                  v217 = *((_QWORD *)v213 - 1);
                  v218 = ~(v215 | ((_WORD)v215 << 8));
                  v219 = v218;
                  v220 = ((HIWORD(v217) - ((HIWORD(v217) * v219 + ((HIWORD(v217) * v219) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v217) - ((WORD2(v217) * v219 + ((WORD2(v217) * v219) >> 16) + 1) >> 16)) << 32) | ((WORD1(v217) - ((WORD1(v217) * v219 + ((WORD1(v217) * v219) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v217 - (((unsigned __int16)v217 * v218 + (((unsigned __int16)v217 * v218) >> 16) + 1) >> 16));
                  v221 = *v213 - ((*v213 * v219 + ((*v213 * v219) >> 16) + 1) >> 16);
                  CMYK64_DAMplusDAM(v35, v31, v220, (unsigned __int16)v221, v216 ^ 0xFFFF, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v216, (unsigned __int16)(v221 + v218));
                  v46 = v654;
                  v69 = v652;
                }
              }
              ++v65;
              v165 += v212;
              ++v35;
              v213 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              --v214;
            }
            while (v214);
            goto LABEL_234;
          case 10:
            v648 = v42;
            v222 = v46 != 0;
            v223 = (unsigned __int16 *)(v64 + 8);
            v224 = v41;
            v165 = v46;
            v166 = v651;
            do
            {
              v225 = *v65;
              if (*v65)
              {
                if (!v46
                  || (v225 = ((unsigned __int16)(*v165 * (_WORD)v225
                                                                + ((*v165 * v225) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  v226 = bswap32(*v31) >> 16;
                  v227 = *((_QWORD *)v223 - 1);
                  v228 = (v225 | (v225 << 8)) ^ 0xFFFF;
                  v229 = ((HIWORD(v227) - ((v228 * HIWORD(v227) + ((v228 * HIWORD(v227)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v227) - ((WORD2(v227) * v228 + ((WORD2(v227) * v228) >> 16) + 1) >> 16)) << 32) | ((WORD1(v227) - ((WORD1(v227) * v228 + ((WORD1(v227) * v228) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v227 - (((unsigned __int16)v227 * v228 + (((unsigned __int16)v227 * v228) >> 16) + 1) >> 16));
                  v230 = *v223 - ((v228 * *v223 + ((v228 * *v223) >> 16) + 1) >> 16);
                  CMYK64_DAMplusDAM(v35, v31, v229, (unsigned __int16)v230, v226 ^ 0xFFFF, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v226, (unsigned __int16)~(_WORD)v230);
                  v46 = v654;
                  v69 = v652;
                }
              }
              ++v65;
              v165 += v222;
              ++v35;
              v223 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              --v224;
            }
            while (v224);
LABEL_234:
            v46 = &v165[v641];
            v35 += v643;
            v31 += v644;
            v39 = v640;
            goto LABEL_563;
          case 11:
            v648 = v42;
            v231 = v46 != 0;
            if (v653)
            {
              v232 = (_WORD *)(v64 + 8);
              v203 = v46;
              v166 = v651;
              do
              {
                v233 = *v65;
                if (*v65)
                {
                  if (!v46
                    || (v233 = ((unsigned __int16)(*v203 * (_WORD)v233
                                                                  + ((*v203 * v233) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v234 = *((_QWORD *)v232 - 1);
                    v235 = (v233 | (v233 << 8)) ^ 0xFFFF;
                    v236 = (unsigned __int16)v234 * v235;
                    CMYK64_DAplusdDA((int *)v35, v31, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*v31) >> 16, ((HIWORD(v234) - ((v235 * HIWORD(v234) + ((v235 * HIWORD(v234)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v234) - ((WORD2(v234) * v235 + ((WORD2(v234) * v235) >> 16) + 1) >> 16)) << 32) | ((WORD1(v234) - ((WORD1(v234) * v235 + ((WORD1(v234) * v235) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v234 - ((v236 + HIWORD(v236) + 1) >> 16)), (unsigned __int16)(*v232- ((v235 * (unsigned __int16)*v232+ ((v235 * (unsigned __int16)*v232) >> 16)+ 1) >> 16)));
                    v46 = v654;
                  }
                }
                ++v65;
                v203 += v231;
                ++v35;
                ++v31;
                v232 += 8;
                LODWORD(v41) = v41 - 1;
              }
              while ((_DWORD)v41);
            }
            else
            {
              v544 = (_WORD *)(v64 + 8);
              v203 = v46;
              v166 = v651;
              do
              {
                v545 = *v65;
                if (*v65)
                {
                  if (!v46
                    || (v545 = ((unsigned __int16)(*v203 * (_WORD)v545
                                                                  + ((*v203 * v545) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v546 = *((_QWORD *)v544 - 1);
                    v547 = (v545 | (v545 << 8)) ^ 0xFFFF;
                    v548 = (unsigned __int16)v546 * v547;
                    CMYK64_DplusdDA(v35, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), ((HIWORD(v546) - ((v547 * HIWORD(v546) + ((v547 * HIWORD(v546)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v546) - ((WORD2(v546) * v547 + ((WORD2(v546) * v547) >> 16) + 1) >> 16)) << 32) | ((WORD1(v546) - ((WORD1(v546) * v547 + ((WORD1(v546) * v547) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v546 - ((v548 + HIWORD(v548) + 1) >> 16)), (unsigned __int16)(*v544- ((v547 * (unsigned __int16)*v544+ ((v547 * (unsigned __int16)*v544) >> 16)+ 1) >> 16)));
                    v46 = v654;
                  }
                }
                ++v65;
                v203 += v231;
                ++v35;
                v544 += 8;
                LODWORD(v41) = v41 - 1;
              }
              while ((_DWORD)v41);
            }
            goto LABEL_562;
          case 12:
            v648 = v42;
            v237 = v46 != 0;
            if (!v653)
            {
              v550 = v41;
              v551 = v46;
              do
              {
                v552 = *v65;
                if (*v65)
                {
                  if (!v46
                    || (v552 = ((unsigned __int16)(*v551 * (_WORD)v552
                                                                  + ((*v551 * v552) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    v553 = WORD1(*(_QWORD *)v64);
                    v554 = HIWORD(*(_QWORD *)v64);
                    v555 = (v552 | (v552 << 8)) ^ 0xFFFF;
                    v556 = (unsigned __int16)WORD2(*(_QWORD *)v64) * v555;
                    CMYK64_DpluslD(v35, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), ((unint64_t)(v554- ((v555 * (_DWORD)v554 + ((v555 * v554) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(_QWORD *)v64) - ((v556 + HIWORD(v556) + 1) >> 16)) << 32) | ((v553 - ((v553 * v555 + ((v553 * v555) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(_QWORD *)v64 - (((unsigned __int16)*(_QWORD *)v64 * v555 + (((unsigned __int16)*(_QWORD *)v64 * v555) >> 16) + 1) >> 16)));
                    v46 = v654;
                  }
                }
                ++v65;
                v64 += 16;
                v551 += v237;
                ++v35;
                --v550;
              }
              while (v550);
              v40 = v642;
              v46 = &v551[v641];
              v35 += v643;
              v31 += v644;
              goto LABEL_493;
            }
            v238 = (_WORD *)(v64 + 8);
            v203 = v46;
            v166 = v651;
            do
            {
              v239 = *v65;
              if (*v65)
              {
                if (!v46
                  || (v239 = ((unsigned __int16)(*v203 * (_WORD)v239
                                                                + ((*v203 * v239) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  v240 = *((_QWORD *)v238 - 1);
                  v241 = (v239 | (v239 << 8)) ^ 0xFFFF;
                  v242 = (unsigned __int16)v240 * v241;
                  CMYK64_DApluslDA((unsigned int *)v35, v31, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), bswap32(*v31) >> 16, ((HIWORD(v240) - ((v241 * HIWORD(v240) + ((v241 * HIWORD(v240)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v240) - ((WORD2(v240) * v241 + ((WORD2(v240) * v241) >> 16) + 1) >> 16)) << 32) | ((WORD1(v240) - ((WORD1(v240) * v241 + ((WORD1(v240) * v241) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v240 - ((v242 + HIWORD(v242) + 1) >> 16)), (unsigned __int16)(*v238- ((v241 * (unsigned __int16)*v238+ ((v241 * (unsigned __int16)*v238) >> 16)+ 1) >> 16)));
                  v46 = v654;
                }
              }
              ++v65;
              v203 += v237;
              ++v35;
              ++v31;
              v238 += 8;
              LODWORD(v41) = v41 - 1;
            }
            while ((_DWORD)v41);
LABEL_562:
            v40 = v642;
            v46 = &v203[v641];
            v35 += v643;
            v31 += v644;
LABEL_563:
            v41 = v646;
            v42 = v648;
            goto LABEL_564;
          case 13:
            v648 = v42;
            v243 = v46 != 0;
            v244 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v246 = *v65;
              if (!*v65)
                goto LABEL_265;
              if (v46)
              {
                v246 = ((unsigned __int16)(*v245 * (_WORD)v246 + ((*v245 * v246) >> 8) + 1) >> 8);
                if (!v246)
                  goto LABEL_265;
              }
              v247 = *v244;
              v248 = (v246 | (v246 << 8)) ^ 0xFFFF;
              v249 = v247 - ((v248 * v247 + ((v248 * v247) >> 16) + 1) >> 16);
              if (v247 == (v248 * v247 + ((v248 * v247) >> 16) + 1) >> 16)
                goto LABEL_265;
              v250 = *((_QWORD *)v244 - 1);
              v251 = ((HIWORD(v250) - ((v248 * HIWORD(v250) + ((v248 * HIWORD(v250)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v250) - ((WORD2(v250) * v248 + ((WORD2(v250) * v248) >> 16) + 1) >> 16)) << 32) | ((WORD1(v250) - ((WORD1(v250) * v248 + ((WORD1(v250) * v248) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v250 - (((unsigned __int16)v250 * v248 + (((unsigned __int16)v250 * v248) >> 16) + 1) >> 16));
              LODWORD(v252) = (unsigned __int16)v249;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_262;
                v253 = __rev16(*v31);
              }
              else
              {
                v253 = 0xFFFF;
              }
              v254 = (unsigned __int16 *)v35 + 3;
              v255 = PDAmultiplyPDA_10646(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v253, v251, (unsigned __int16)v249);
              v251 = v255;
              if (!v653)
              {
                v252 = HIWORD(v255);
                v258 = bswap32(v255);
                v35->i16[0] = HIWORD(v258);
                v35->i16[1] = v258;
                v35->i16[2] = bswap32(HIDWORD(v255)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_264;
              }
              LODWORD(v252) = v256;
              v69 = v652;
              v46 = v654;
LABEL_262:
              v257 = bswap32(v251);
              v35->i16[0] = HIWORD(v257);
              v35->i16[1] = v257;
              v35->i16[2] = bswap32(HIDWORD(v251)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v251));
              v254 = v31;
LABEL_264:
              *v254 = bswap32(v252) >> 16;
LABEL_265:
              ++v65;
              v245 += v243;
              ++v35;
              v244 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 14:
            v648 = v42;
            v259 = v46 != 0;
            v260 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v261 = *v65;
              if (!*v65)
                goto LABEL_281;
              if (v46)
              {
                v261 = ((unsigned __int16)(*v245 * (_WORD)v261 + ((*v245 * v261) >> 8) + 1) >> 8);
                if (!v261)
                  goto LABEL_281;
              }
              v262 = *v260;
              v263 = (v261 | (v261 << 8)) ^ 0xFFFF;
              v264 = v262 - ((v263 * v262 + ((v263 * v262) >> 16) + 1) >> 16);
              if (v262 == (v263 * v262 + ((v263 * v262) >> 16) + 1) >> 16)
                goto LABEL_281;
              v265 = *((_QWORD *)v260 - 1);
              v266 = ((HIWORD(v265) - ((v263 * HIWORD(v265) + ((v263 * HIWORD(v265)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v265) - ((WORD2(v265) * v263 + ((WORD2(v265) * v263) >> 16) + 1) >> 16)) << 32) | ((WORD1(v265) - ((WORD1(v265) * v263 + ((WORD1(v265) * v263) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v265 - (((unsigned __int16)v265 * v263 + (((unsigned __int16)v265 * v263) >> 16) + 1) >> 16));
              LODWORD(v267) = (unsigned __int16)v264;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_278;
                v268 = __rev16(*v31);
              }
              else
              {
                v268 = 0xFFFF;
              }
              v269 = (unsigned __int16 *)v35 + 3;
              v270 = PDAscreenPDA_10647(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v268, v266, (unsigned __int16)v264);
              v266 = v270;
              if (!v653)
              {
                v267 = HIWORD(v270);
                v273 = bswap32(v270);
                v35->i16[0] = HIWORD(v273);
                v35->i16[1] = v273;
                v35->i16[2] = bswap32(HIDWORD(v270)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_280;
              }
              LODWORD(v267) = v271;
              v69 = v652;
              v46 = v654;
LABEL_278:
              v272 = bswap32(v266);
              v35->i16[0] = HIWORD(v272);
              v35->i16[1] = v272;
              v35->i16[2] = bswap32(HIDWORD(v266)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v266));
              v269 = v31;
LABEL_280:
              *v269 = bswap32(v267) >> 16;
LABEL_281:
              ++v65;
              v245 += v259;
              ++v35;
              v260 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 15:
            v648 = v42;
            v274 = v46 != 0;
            v275 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v276 = *v65;
              if (!*v65)
                goto LABEL_297;
              if (v46)
              {
                v276 = ((unsigned __int16)(*v245 * (_WORD)v276 + ((*v245 * v276) >> 8) + 1) >> 8);
                if (!v276)
                  goto LABEL_297;
              }
              v277 = *v275;
              v278 = (v276 | (v276 << 8)) ^ 0xFFFF;
              v279 = v277 - ((v278 * v277 + ((v278 * v277) >> 16) + 1) >> 16);
              if (v277 == (v278 * v277 + ((v278 * v277) >> 16) + 1) >> 16)
                goto LABEL_297;
              v280 = *((_QWORD *)v275 - 1);
              v281 = ((HIWORD(v280) - ((v278 * HIWORD(v280) + ((v278 * HIWORD(v280)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v280) - ((WORD2(v280) * v278 + ((WORD2(v280) * v278) >> 16) + 1) >> 16)) << 32) | ((WORD1(v280) - ((WORD1(v280) * v278 + ((WORD1(v280) * v278) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v280 - (((unsigned __int16)v280 * v278 + (((unsigned __int16)v280 * v278) >> 16) + 1) >> 16));
              LODWORD(v282) = (unsigned __int16)v279;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_294;
                v283 = __rev16(*v31);
              }
              else
              {
                v283 = 0xFFFF;
              }
              v284 = (unsigned __int16 *)v35 + 3;
              v285 = PDAoverlayPDA_10648(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v283, v281, (unsigned __int16)v279);
              v281 = v285;
              if (!v653)
              {
                v282 = HIWORD(v285);
                v288 = bswap32(v285);
                v35->i16[0] = HIWORD(v288);
                v35->i16[1] = v288;
                v35->i16[2] = bswap32(HIDWORD(v285)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_296;
              }
              LODWORD(v282) = v286;
              v69 = v652;
              v46 = v654;
LABEL_294:
              v287 = bswap32(v281);
              v35->i16[0] = HIWORD(v287);
              v35->i16[1] = v287;
              v35->i16[2] = bswap32(HIDWORD(v281)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v281));
              v284 = v31;
LABEL_296:
              *v284 = bswap32(v282) >> 16;
LABEL_297:
              ++v65;
              v245 += v274;
              ++v35;
              v275 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 16:
            v648 = v42;
            v289 = v46 != 0;
            v290 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v291 = *v65;
              if (!*v65)
                goto LABEL_313;
              if (v46)
              {
                v291 = ((unsigned __int16)(*v245 * (_WORD)v291 + ((*v245 * v291) >> 8) + 1) >> 8);
                if (!v291)
                  goto LABEL_313;
              }
              v292 = *v290;
              v293 = (v291 | (v291 << 8)) ^ 0xFFFF;
              v294 = v292 - ((v293 * v292 + ((v293 * v292) >> 16) + 1) >> 16);
              if (v292 == (v293 * v292 + ((v293 * v292) >> 16) + 1) >> 16)
                goto LABEL_313;
              v295 = *((_QWORD *)v290 - 1);
              v296 = ((HIWORD(v295) - ((v293 * HIWORD(v295) + ((v293 * HIWORD(v295)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v295) - ((WORD2(v295) * v293 + ((WORD2(v295) * v293) >> 16) + 1) >> 16)) << 32) | ((WORD1(v295) - ((WORD1(v295) * v293 + ((WORD1(v295) * v293) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v295 - (((unsigned __int16)v295 * v293 + (((unsigned __int16)v295 * v293) >> 16) + 1) >> 16));
              LODWORD(v297) = (unsigned __int16)v294;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_310;
                v298 = __rev16(*v31);
              }
              else
              {
                v298 = 0xFFFF;
              }
              v299 = (unsigned __int16 *)v35 + 3;
              v300 = PDAdarkenPDA_10650(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v298, v296, (unsigned __int16)v294);
              v296 = v300;
              if (!v653)
              {
                v297 = HIWORD(v300);
                v303 = bswap32(v300);
                v35->i16[0] = HIWORD(v303);
                v35->i16[1] = v303;
                v35->i16[2] = bswap32(HIDWORD(v300)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_312;
              }
              LODWORD(v297) = v301;
              v69 = v652;
              v46 = v654;
LABEL_310:
              v302 = bswap32(v296);
              v35->i16[0] = HIWORD(v302);
              v35->i16[1] = v302;
              v35->i16[2] = bswap32(HIDWORD(v296)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v296));
              v299 = v31;
LABEL_312:
              *v299 = bswap32(v297) >> 16;
LABEL_313:
              ++v65;
              v245 += v289;
              ++v35;
              v290 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 17:
            v648 = v42;
            v304 = v46 != 0;
            v305 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v306 = *v65;
              if (!*v65)
                goto LABEL_329;
              if (v46)
              {
                v306 = ((unsigned __int16)(*v245 * (_WORD)v306 + ((*v245 * v306) >> 8) + 1) >> 8);
                if (!v306)
                  goto LABEL_329;
              }
              v307 = *v305;
              v308 = (v306 | (v306 << 8)) ^ 0xFFFF;
              v309 = v307 - ((v308 * v307 + ((v308 * v307) >> 16) + 1) >> 16);
              if (v307 == (v308 * v307 + ((v308 * v307) >> 16) + 1) >> 16)
                goto LABEL_329;
              v310 = *((_QWORD *)v305 - 1);
              v311 = ((HIWORD(v310) - ((v308 * HIWORD(v310) + ((v308 * HIWORD(v310)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v310) - ((WORD2(v310) * v308 + ((WORD2(v310) * v308) >> 16) + 1) >> 16)) << 32) | ((WORD1(v310) - ((WORD1(v310) * v308 + ((WORD1(v310) * v308) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v310 - (((unsigned __int16)v310 * v308 + (((unsigned __int16)v310 * v308) >> 16) + 1) >> 16));
              LODWORD(v312) = (unsigned __int16)v309;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_326;
                v313 = __rev16(*v31);
              }
              else
              {
                v313 = 0xFFFF;
              }
              v314 = (unsigned __int16 *)v35 + 3;
              v315 = PDAlightenPDA_10649(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v313, v311, (unsigned __int16)v309);
              v311 = v315;
              if (!v653)
              {
                v312 = HIWORD(v315);
                v318 = bswap32(v315);
                v35->i16[0] = HIWORD(v318);
                v35->i16[1] = v318;
                v35->i16[2] = bswap32(HIDWORD(v315)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_328;
              }
              LODWORD(v312) = v316;
              v69 = v652;
              v46 = v654;
LABEL_326:
              v317 = bswap32(v311);
              v35->i16[0] = HIWORD(v317);
              v35->i16[1] = v317;
              v35->i16[2] = bswap32(HIDWORD(v311)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v311));
              v314 = v31;
LABEL_328:
              *v314 = bswap32(v312) >> 16;
LABEL_329:
              ++v65;
              v245 += v304;
              ++v35;
              v305 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 18:
            v648 = v42;
            v319 = v46 != 0;
            v320 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v321 = *v65;
              if (!*v65)
                goto LABEL_345;
              if (v46)
              {
                v321 = ((unsigned __int16)(*v245 * (_WORD)v321 + ((*v245 * v321) >> 8) + 1) >> 8);
                if (!v321)
                  goto LABEL_345;
              }
              v322 = *v320;
              v323 = (v321 | (v321 << 8)) ^ 0xFFFF;
              v324 = v322 - ((v323 * v322 + ((v323 * v322) >> 16) + 1) >> 16);
              if (v322 == (v323 * v322 + ((v323 * v322) >> 16) + 1) >> 16)
                goto LABEL_345;
              v325 = *((_QWORD *)v320 - 1);
              v326 = ((HIWORD(v325) - ((v323 * HIWORD(v325) + ((v323 * HIWORD(v325)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v325) - ((WORD2(v325) * v323 + ((WORD2(v325) * v323) >> 16) + 1) >> 16)) << 32) | ((WORD1(v325) - ((WORD1(v325) * v323 + ((WORD1(v325) * v323) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v325 - (((unsigned __int16)v325 * v323 + (((unsigned __int16)v325 * v323) >> 16) + 1) >> 16));
              LODWORD(v327) = (unsigned __int16)v324;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_342;
                v328 = __rev16(*v31);
              }
              else
              {
                v328 = 0xFFFF;
              }
              v329 = (unsigned __int16 *)v35 + 3;
              v330 = PDAcolordodgePDA_10651(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v328, v326, (unsigned __int16)v324);
              v326 = v330;
              if (!v653)
              {
                v327 = HIWORD(v330);
                v333 = bswap32(v330);
                v35->i16[0] = HIWORD(v333);
                v35->i16[1] = v333;
                v35->i16[2] = bswap32(HIDWORD(v330)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_344;
              }
              LODWORD(v327) = v331;
              v69 = v652;
              v46 = v654;
LABEL_342:
              v332 = bswap32(v326);
              v35->i16[0] = HIWORD(v332);
              v35->i16[1] = v332;
              v35->i16[2] = bswap32(HIDWORD(v326)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v326));
              v329 = v31;
LABEL_344:
              *v329 = bswap32(v327) >> 16;
LABEL_345:
              ++v65;
              v245 += v319;
              ++v35;
              v320 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 19:
            v648 = v42;
            v334 = v46 != 0;
            v335 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v336 = *v65;
              if (!*v65)
                goto LABEL_361;
              if (v46)
              {
                v336 = ((unsigned __int16)(*v245 * (_WORD)v336 + ((*v245 * v336) >> 8) + 1) >> 8);
                if (!v336)
                  goto LABEL_361;
              }
              v337 = *v335;
              v338 = (v336 | (v336 << 8)) ^ 0xFFFF;
              v339 = v337 - ((v338 * v337 + ((v338 * v337) >> 16) + 1) >> 16);
              if (v337 == (v338 * v337 + ((v338 * v337) >> 16) + 1) >> 16)
                goto LABEL_361;
              v340 = *((_QWORD *)v335 - 1);
              v341 = ((HIWORD(v340) - ((v338 * HIWORD(v340) + ((v338 * HIWORD(v340)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v340) - ((WORD2(v340) * v338 + ((WORD2(v340) * v338) >> 16) + 1) >> 16)) << 32) | ((WORD1(v340) - ((WORD1(v340) * v338 + ((WORD1(v340) * v338) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v340 - (((unsigned __int16)v340 * v338 + (((unsigned __int16)v340 * v338) >> 16) + 1) >> 16));
              LODWORD(v342) = (unsigned __int16)v339;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_358;
                v343 = __rev16(*v31);
              }
              else
              {
                v343 = 0xFFFF;
              }
              v344 = (unsigned __int16 *)v35 + 3;
              v345 = PDAcolorburnPDA_10652(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v343, v341, (unsigned __int16)v339);
              v341 = v345;
              if (!v653)
              {
                v342 = HIWORD(v345);
                v348 = bswap32(v345);
                v35->i16[0] = HIWORD(v348);
                v35->i16[1] = v348;
                v35->i16[2] = bswap32(HIDWORD(v345)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_360;
              }
              LODWORD(v342) = v346;
              v69 = v652;
              v46 = v654;
LABEL_358:
              v347 = bswap32(v341);
              v35->i16[0] = HIWORD(v347);
              v35->i16[1] = v347;
              v35->i16[2] = bswap32(HIDWORD(v341)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v341));
              v344 = v31;
LABEL_360:
              *v344 = bswap32(v342) >> 16;
LABEL_361:
              ++v65;
              v245 += v334;
              ++v35;
              v335 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 20:
            v648 = v42;
            v349 = v46 != 0;
            v350 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v351 = *v65;
              if (!*v65)
                goto LABEL_377;
              if (v46)
              {
                v351 = ((unsigned __int16)(*v245 * (_WORD)v351 + ((*v245 * v351) >> 8) + 1) >> 8);
                if (!v351)
                  goto LABEL_377;
              }
              v352 = *v350;
              v353 = (v351 | (v351 << 8)) ^ 0xFFFF;
              v354 = v352 - ((v353 * v352 + ((v353 * v352) >> 16) + 1) >> 16);
              if (v352 == (v353 * v352 + ((v353 * v352) >> 16) + 1) >> 16)
                goto LABEL_377;
              v355 = *((_QWORD *)v350 - 1);
              v356 = ((HIWORD(v355) - ((v353 * HIWORD(v355) + ((v353 * HIWORD(v355)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v355) - ((WORD2(v355) * v353 + ((WORD2(v355) * v353) >> 16) + 1) >> 16)) << 32) | ((WORD1(v355) - ((WORD1(v355) * v353 + ((WORD1(v355) * v353) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v355 - (((unsigned __int16)v355 * v353 + (((unsigned __int16)v355 * v353) >> 16) + 1) >> 16));
              LODWORD(v357) = (unsigned __int16)v354;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_374;
                v358 = __rev16(*v31);
              }
              else
              {
                v358 = 0xFFFF;
              }
              v359 = (unsigned __int16 *)v35 + 3;
              v360 = PDAsoftlightPDA_10654(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v358, v356, (unsigned __int16)v354);
              v356 = v360;
              if (!v653)
              {
                v357 = HIWORD(v360);
                v363 = bswap32(v360);
                v35->i16[0] = HIWORD(v363);
                v35->i16[1] = v363;
                v35->i16[2] = bswap32(HIDWORD(v360)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_376;
              }
              LODWORD(v357) = v361;
              v69 = v652;
              v46 = v654;
LABEL_374:
              v362 = bswap32(v356);
              v35->i16[0] = HIWORD(v362);
              v35->i16[1] = v362;
              v35->i16[2] = bswap32(HIDWORD(v356)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v356));
              v359 = v31;
LABEL_376:
              *v359 = bswap32(v357) >> 16;
LABEL_377:
              ++v65;
              v245 += v349;
              ++v35;
              v350 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 21:
            v648 = v42;
            v364 = v46 != 0;
            v365 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v366 = *v65;
              if (!*v65)
                goto LABEL_393;
              if (v46)
              {
                v366 = ((unsigned __int16)(*v245 * (_WORD)v366 + ((*v245 * v366) >> 8) + 1) >> 8);
                if (!v366)
                  goto LABEL_393;
              }
              v367 = *v365;
              v368 = (v366 | (v366 << 8)) ^ 0xFFFF;
              v369 = v367 - ((v368 * v367 + ((v368 * v367) >> 16) + 1) >> 16);
              if (v367 == (v368 * v367 + ((v368 * v367) >> 16) + 1) >> 16)
                goto LABEL_393;
              v370 = *((_QWORD *)v365 - 1);
              v371 = ((HIWORD(v370) - ((v368 * HIWORD(v370) + ((v368 * HIWORD(v370)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v370) - ((WORD2(v370) * v368 + ((WORD2(v370) * v368) >> 16) + 1) >> 16)) << 32) | ((WORD1(v370) - ((WORD1(v370) * v368 + ((WORD1(v370) * v368) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v370 - (((unsigned __int16)v370 * v368 + (((unsigned __int16)v370 * v368) >> 16) + 1) >> 16));
              LODWORD(v372) = (unsigned __int16)v369;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_390;
                v373 = __rev16(*v31);
              }
              else
              {
                v373 = 0xFFFF;
              }
              v374 = (unsigned __int16 *)v35 + 3;
              v375 = PDAhardlightPDA_10653(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v373, v371, (unsigned __int16)v369);
              v371 = v375;
              if (!v653)
              {
                v372 = HIWORD(v375);
                v378 = bswap32(v375);
                v35->i16[0] = HIWORD(v378);
                v35->i16[1] = v378;
                v35->i16[2] = bswap32(HIDWORD(v375)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_392;
              }
              LODWORD(v372) = v376;
              v69 = v652;
              v46 = v654;
LABEL_390:
              v377 = bswap32(v371);
              v35->i16[0] = HIWORD(v377);
              v35->i16[1] = v377;
              v35->i16[2] = bswap32(HIDWORD(v371)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v371));
              v374 = v31;
LABEL_392:
              *v374 = bswap32(v372) >> 16;
LABEL_393:
              ++v65;
              v245 += v364;
              ++v35;
              v365 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 22:
            v648 = v42;
            v379 = v46 != 0;
            v380 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v381 = *v65;
              if (!*v65)
                goto LABEL_409;
              if (v46)
              {
                v381 = ((unsigned __int16)(*v245 * (_WORD)v381 + ((*v245 * v381) >> 8) + 1) >> 8);
                if (!v381)
                  goto LABEL_409;
              }
              v382 = *v380;
              v383 = (v381 | (v381 << 8)) ^ 0xFFFF;
              v384 = v382 - ((v383 * v382 + ((v383 * v382) >> 16) + 1) >> 16);
              if (v382 == (v383 * v382 + ((v383 * v382) >> 16) + 1) >> 16)
                goto LABEL_409;
              v385 = *((_QWORD *)v380 - 1);
              v386 = ((HIWORD(v385) - ((v383 * HIWORD(v385) + ((v383 * HIWORD(v385)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v385) - ((WORD2(v385) * v383 + ((WORD2(v385) * v383) >> 16) + 1) >> 16)) << 32) | ((WORD1(v385) - ((WORD1(v385) * v383 + ((WORD1(v385) * v383) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v385 - (((unsigned __int16)v385 * v383 + (((unsigned __int16)v385 * v383) >> 16) + 1) >> 16));
              LODWORD(v387) = (unsigned __int16)v384;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_406;
                v388 = __rev16(*v31);
              }
              else
              {
                v388 = 0xFFFF;
              }
              v389 = (unsigned __int16 *)v35 + 3;
              v390 = PDAdifferencePDA_10655(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v388, v386, (unsigned __int16)v384);
              v386 = v390;
              if (!v653)
              {
                v387 = HIWORD(v390);
                v393 = bswap32(v390);
                v35->i16[0] = HIWORD(v393);
                v35->i16[1] = v393;
                v35->i16[2] = bswap32(HIDWORD(v390)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_408;
              }
              LODWORD(v387) = v391;
              v69 = v652;
              v46 = v654;
LABEL_406:
              v392 = bswap32(v386);
              v35->i16[0] = HIWORD(v392);
              v35->i16[1] = v392;
              v35->i16[2] = bswap32(HIDWORD(v386)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v386));
              v389 = v31;
LABEL_408:
              *v389 = bswap32(v387) >> 16;
LABEL_409:
              ++v65;
              v245 += v379;
              ++v35;
              v380 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 23:
            v648 = v42;
            v394 = v46 != 0;
            v395 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v396 = *v65;
              if (!*v65)
                goto LABEL_425;
              if (v46)
              {
                v396 = ((unsigned __int16)(*v245 * (_WORD)v396 + ((*v245 * v396) >> 8) + 1) >> 8);
                if (!v396)
                  goto LABEL_425;
              }
              v397 = *v395;
              v398 = (v396 | (v396 << 8)) ^ 0xFFFF;
              v399 = v397 - ((v398 * v397 + ((v398 * v397) >> 16) + 1) >> 16);
              if (v397 == (v398 * v397 + ((v398 * v397) >> 16) + 1) >> 16)
                goto LABEL_425;
              v400 = *((_QWORD *)v395 - 1);
              v401 = ((HIWORD(v400) - ((v398 * HIWORD(v400) + ((v398 * HIWORD(v400)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v400) - ((WORD2(v400) * v398 + ((WORD2(v400) * v398) >> 16) + 1) >> 16)) << 32) | ((WORD1(v400) - ((WORD1(v400) * v398 + ((WORD1(v400) * v398) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v400 - (((unsigned __int16)v400 * v398 + (((unsigned __int16)v400 * v398) >> 16) + 1) >> 16));
              LODWORD(v402) = (unsigned __int16)v399;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_422;
                v403 = __rev16(*v31);
              }
              else
              {
                v403 = 0xFFFF;
              }
              v404 = (unsigned __int16 *)v35 + 3;
              v405 = PDAexclusionPDA_10656(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v403, v401, (unsigned __int16)v399);
              v401 = v405;
              if (!v653)
              {
                v402 = HIWORD(v405);
                v408 = bswap32(v405);
                v35->i16[0] = HIWORD(v408);
                v35->i16[1] = v408;
                v35->i16[2] = bswap32(HIDWORD(v405)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_424;
              }
              LODWORD(v402) = v406;
              v69 = v652;
              v46 = v654;
LABEL_422:
              v407 = bswap32(v401);
              v35->i16[0] = HIWORD(v407);
              v35->i16[1] = v407;
              v35->i16[2] = bswap32(HIDWORD(v401)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v401));
              v404 = v31;
LABEL_424:
              *v404 = bswap32(v402) >> 16;
LABEL_425:
              ++v65;
              v245 += v394;
              ++v35;
              v395 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 24:
            v648 = v42;
            v409 = v46 != 0;
            v410 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v411 = *v65;
              if (!*v65)
                goto LABEL_441;
              if (v46)
              {
                v411 = ((unsigned __int16)(*v245 * (_WORD)v411 + ((*v245 * v411) >> 8) + 1) >> 8);
                if (!v411)
                  goto LABEL_441;
              }
              v412 = *v410;
              v413 = (v411 | (v411 << 8)) ^ 0xFFFF;
              v414 = v412 - ((v413 * v412 + ((v413 * v412) >> 16) + 1) >> 16);
              if (v412 == (v413 * v412 + ((v413 * v412) >> 16) + 1) >> 16)
                goto LABEL_441;
              v415 = *((_QWORD *)v410 - 1);
              v416 = ((HIWORD(v415) - ((v413 * HIWORD(v415) + ((v413 * HIWORD(v415)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v415) - ((WORD2(v415) * v413 + ((WORD2(v415) * v413) >> 16) + 1) >> 16)) << 32) | ((WORD1(v415) - ((WORD1(v415) * v413 + ((WORD1(v415) * v413) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v415 - (((unsigned __int16)v415 * v413 + (((unsigned __int16)v415 * v413) >> 16) + 1) >> 16));
              LODWORD(v417) = (unsigned __int16)v414;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_438;
                v418 = __rev16(*v31);
              }
              else
              {
                v418 = 0xFFFF;
              }
              v419 = (unsigned __int16 *)v35 + 3;
              v420 = PDAhuePDA_10657(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v418, v416, (unsigned __int16)v414);
              v416 = v420;
              if (!v653)
              {
                v417 = HIWORD(v420);
                v423 = bswap32(v420);
                v35->i16[0] = HIWORD(v423);
                v35->i16[1] = v423;
                v35->i16[2] = bswap32(HIDWORD(v420)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_440;
              }
              LODWORD(v417) = v421;
              v69 = v652;
              v46 = v654;
LABEL_438:
              v422 = bswap32(v416);
              v35->i16[0] = HIWORD(v422);
              v35->i16[1] = v422;
              v35->i16[2] = bswap32(HIDWORD(v416)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v416));
              v419 = v31;
LABEL_440:
              *v419 = bswap32(v417) >> 16;
LABEL_441:
              ++v65;
              v245 += v409;
              ++v35;
              v410 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 25:
            v648 = v42;
            v424 = v46 != 0;
            v425 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v426 = *v65;
              if (!*v65)
                goto LABEL_457;
              if (v46)
              {
                v426 = ((unsigned __int16)(*v245 * (_WORD)v426 + ((*v245 * v426) >> 8) + 1) >> 8);
                if (!v426)
                  goto LABEL_457;
              }
              v427 = *v425;
              v428 = (v426 | (v426 << 8)) ^ 0xFFFF;
              v429 = v427 - ((v428 * v427 + ((v428 * v427) >> 16) + 1) >> 16);
              if (v427 == (v428 * v427 + ((v428 * v427) >> 16) + 1) >> 16)
                goto LABEL_457;
              v430 = *((_QWORD *)v425 - 1);
              v431 = ((HIWORD(v430) - ((v428 * HIWORD(v430) + ((v428 * HIWORD(v430)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v430) - ((WORD2(v430) * v428 + ((WORD2(v430) * v428) >> 16) + 1) >> 16)) << 32) | ((WORD1(v430) - ((WORD1(v430) * v428 + ((WORD1(v430) * v428) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v430 - (((unsigned __int16)v430 * v428 + (((unsigned __int16)v430 * v428) >> 16) + 1) >> 16));
              LODWORD(v432) = (unsigned __int16)v429;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_454;
                v433 = __rev16(*v31);
              }
              else
              {
                v433 = 0xFFFF;
              }
              v434 = (unsigned __int16 *)v35 + 3;
              v435 = PDAsaturationPDA_10658(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v433, v431, (unsigned __int16)v429);
              v431 = v435;
              if (!v653)
              {
                v432 = HIWORD(v435);
                v438 = bswap32(v435);
                v35->i16[0] = HIWORD(v438);
                v35->i16[1] = v438;
                v35->i16[2] = bswap32(HIDWORD(v435)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_456;
              }
              LODWORD(v432) = v436;
              v69 = v652;
              v46 = v654;
LABEL_454:
              v437 = bswap32(v431);
              v35->i16[0] = HIWORD(v437);
              v35->i16[1] = v437;
              v35->i16[2] = bswap32(HIDWORD(v431)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v431));
              v434 = v31;
LABEL_456:
              *v434 = bswap32(v432) >> 16;
LABEL_457:
              ++v65;
              v245 += v424;
              ++v35;
              v425 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 26:
            v648 = v42;
            v439 = v46 != 0;
            v440 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            while (1)
            {
              v441 = *v65;
              if (!*v65)
                goto LABEL_473;
              if (v46)
              {
                v441 = ((unsigned __int16)(*v245 * (_WORD)v441 + ((*v245 * v441) >> 8) + 1) >> 8);
                if (!v441)
                  goto LABEL_473;
              }
              v442 = *v440;
              v443 = (v441 | (v441 << 8)) ^ 0xFFFF;
              v444 = v442 - ((v443 * v442 + ((v443 * v442) >> 16) + 1) >> 16);
              if (v442 == (v443 * v442 + ((v443 * v442) >> 16) + 1) >> 16)
                goto LABEL_473;
              v445 = *((_QWORD *)v440 - 1);
              v446 = ((HIWORD(v445) - ((v443 * HIWORD(v445) + ((v443 * HIWORD(v445)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v445) - ((WORD2(v445) * v443 + ((WORD2(v445) * v443) >> 16) + 1) >> 16)) << 32) | ((WORD1(v445) - ((WORD1(v445) * v443 + ((WORD1(v445) * v443) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v445 - (((unsigned __int16)v445 * v443 + (((unsigned __int16)v445 * v443) >> 16) + 1) >> 16));
              LODWORD(v447) = (unsigned __int16)v444;
              if (v653)
              {
                if (!*v31)
                  goto LABEL_470;
                v448 = __rev16(*v31);
              }
              else
              {
                v448 = 0xFFFF;
              }
              v449 = (unsigned __int16 *)v35 + 3;
              v446 = PDAluminosityPDA_10659(v446, (unsigned __int16)v444, ((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v448);
              if (!v653)
              {
                v447 = HIWORD(v446);
                v451 = bswap32(v446);
                v35->i16[0] = HIWORD(v451);
                v35->i16[1] = v451;
                v35->i16[2] = bswap32(HIDWORD(v446)) >> 16;
                v69 = v652;
                v46 = v654;
                goto LABEL_472;
              }
              v69 = v652;
              v46 = v654;
LABEL_470:
              v450 = bswap32(v446);
              v35->i16[0] = HIWORD(v450);
              v35->i16[1] = v450;
              v35->i16[2] = bswap32(HIDWORD(v446)) >> 16;
              v35->i16[3] = __rev16(HIWORD(v446));
              v449 = v31;
LABEL_472:
              *v449 = bswap32(v447) >> 16;
LABEL_473:
              ++v65;
              v245 += v439;
              ++v35;
              v440 += 8;
              v31 = (unsigned __int16 *)((char *)v31 + v69);
              LODWORD(v41) = v41 - 1;
              if (!(_DWORD)v41)
                goto LABEL_490;
            }
          case 27:
            v648 = v42;
            v452 = v46 != 0;
            v453 = (unsigned __int16 *)(v64 + 8);
            v245 = v46;
            break;
          default:
            goto LABEL_494;
        }
        break;
      }
      while (1)
      {
        v454 = *v65;
        if (!*v65)
          goto LABEL_489;
        if (v46)
        {
          v454 = ((unsigned __int16)(*v245 * (_WORD)v454 + ((*v245 * v454) >> 8) + 1) >> 8);
          if (!v454)
            goto LABEL_489;
        }
        v455 = *v453;
        v456 = (v454 | (v454 << 8)) ^ 0xFFFF;
        v457 = v455 - ((v456 * v455 + ((v456 * v455) >> 16) + 1) >> 16);
        if (v455 == (v456 * v455 + ((v456 * v455) >> 16) + 1) >> 16)
          goto LABEL_489;
        v458 = *((_QWORD *)v453 - 1);
        v459 = ((HIWORD(v458) - ((v456 * HIWORD(v458) + ((v456 * HIWORD(v458)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v458) - ((WORD2(v458) * v456 + ((WORD2(v458) * v456) >> 16) + 1) >> 16)) << 32) | ((WORD1(v458) - ((WORD1(v458) * v456 + ((WORD1(v458) * v456) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v458 - (((unsigned __int16)v458 * v456 + (((unsigned __int16)v458 * v456) >> 16) + 1) >> 16));
        LODWORD(v460) = (unsigned __int16)v457;
        if (v653)
        {
          if (!*v31)
            goto LABEL_486;
          v461 = __rev16(*v31);
        }
        else
        {
          v461 = 0xFFFF;
        }
        v462 = (unsigned __int16 *)v35 + 3;
        v463 = PDAluminosityPDA_10659(((unint64_t)(bswap32(v35->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35->u16[3]) >> 16) << 48) | bswap32(v35->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v35->u16[0]) >> 16), v461, v459, (unsigned __int16)v457);
        v459 = v463;
        if (!v653)
        {
          v460 = HIWORD(v463);
          v466 = bswap32(v463);
          v35->i16[0] = HIWORD(v466);
          v35->i16[1] = v466;
          v35->i16[2] = bswap32(HIDWORD(v463)) >> 16;
          v69 = v652;
          v46 = v654;
          goto LABEL_488;
        }
        LODWORD(v460) = v464;
        v69 = v652;
        v46 = v654;
LABEL_486:
        v465 = bswap32(v459);
        v35->i16[0] = HIWORD(v465);
        v35->i16[1] = v465;
        v35->i16[2] = bswap32(HIDWORD(v459)) >> 16;
        v35->i16[3] = __rev16(HIWORD(v459));
        v462 = v31;
LABEL_488:
        *v462 = bswap32(v460) >> 16;
LABEL_489:
        ++v65;
        v245 += v452;
        ++v35;
        v453 += 8;
        v31 = (unsigned __int16 *)((char *)v31 + v69);
        LODWORD(v41) = v41 - 1;
        if (!(_DWORD)v41)
        {
LABEL_490:
          v46 = &v245[v641];
          v35 += v643;
          v31 += v644;
LABEL_491:
          v40 = v642;
LABEL_492:
          v41 = v646;
LABEL_493:
          v42 = v648;
LABEL_494:
          v166 = v651;
LABEL_564:
          v138 = v650;
          goto LABEL_565;
        }
      }
    }
    v632 = v34;
    v633 = v33;
    shape_enum_clip_alloc((uint64_t)v19, v20, v9, 1, 1, 1, v36, v37, v646, v650);
    if (v47)
    {
      v48 = (int)((v15 * v4 + 15) & 0xFFFFFFF0);
      if (!(_DWORD)v15)
        v48 = 16 * v4;
      v49 = v26 + v48;
      v44 = 0;
      v50 = v639;
      v641 = -v639;
      v46 = (unsigned __int8 *)(v49 + 16);
      v51 = v651;
      v43 = v47;
      goto LABEL_22;
    }
LABEL_625:
    if (v634)
      free(v634);
  }
}

int8x8_t CMYK64_DAM(int8x8_t *a1, _WORD *a2, unint64_t a3, int a4, int a5)
{
  int32x4_t v5;
  uint32x4_t v6;
  int32x4_t v7;
  int8x8_t result;

  v5.i32[0] = (unsigned __int16)a3;
  v5.i32[1] = vshr_n_u32((uint32x2_t)vdup_lane_s32((int32x2_t)a3, 0), 0x10uLL).i32[1];
  v5.i32[2] = WORD2(a3);
  v5.i32[3] = HIWORD(a3);
  v6 = (uint32x4_t)vmulq_s32(v5, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~a5)));
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  v5.i32[2] = HIDWORD(a3);
  v5.i32[0] = a3;
  result = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v5, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v6, v6, 0x10uLL), v7), 0x10uLL))));
  *a1 = result;
  *a2 = bswap32(a4- (((unsigned __int16)~(_WORD)a5 * a4 + (((unsigned __int16)~(_WORD)a5 * a4) >> 16) + 1) >> 16)) >> 16;
  return result;
}

_WORD *CMYK64_DAMplusDAM(_WORD *result, _WORD *a2, unint64_t a3, int a4, int a5, unint64_t a6, int a7, int a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v8 = WORD1(a3) * a5 + WORD1(a6) * a8;
  v9 = WORD2(a3) * a5 + WORD2(a6) * a8;
  v10 = a5 * HIWORD(a3) + a8 * HIWORD(a6);
  *result = bswap32((unsigned __int16)a3 * a5+ (unsigned __int16)a6 * a8+ (((unsigned __int16)a3 * a5 + (unsigned __int16)a6 * a8) >> 16)+ 1);
  result[1] = bswap32(v8 + HIWORD(v8) + 1);
  result[2] = bswap32(v9 + HIWORD(v9) + 1);
  result[3] = bswap32(v10 + HIWORD(v10) + 1);
  *a2 = bswap32(a5 * a4 + a8 * a7 + ((a5 * a4 + a8 * a7) >> 16) + 1);
  return result;
}

int *CMYK64_DAplusdDA(int *result, _WORD *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  v6 = a4 - (WORD1(a3) + WORD1(a5)) + a6;
  v7 = a4 + a6 - (WORD2(a3) + WORD2(a5));
  v8 = a4 - (HIWORD(a3) + HIWORD(a5)) + a6;
  if (v6 >= 0xFFFF)
    LOWORD(v6) = -1;
  if (v7 >= 0xFFFF)
    LOWORD(v7) = -1;
  if (v8 >= 0xFFFF)
    LOWORD(v8) = -1;
  if ((a4 + a6) >= 0xFFFF)
    v9 = 0xFFFF;
  else
    v9 = a4 + a6;
  *result = (unsigned __int16)(v9 - v6) | ((unsigned __int16)(v9 - v6) << 16);
  result[1] = (unsigned __int16)(v9 - v7) | ((unsigned __int16)(v9 - v8) << 16);
  *a2 = bswap32(v9) >> 16;
  return result;
}

_WORD *CMYK64_DplusdDA(_WORD *result, unint64_t a2, unint64_t a3, int a4)
{
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;

  v4 = a4 - WORD2(a3) + (unsigned __int16)~WORD2(a2);
  v5 = a4 - HIWORD(a3) + (HIWORD(a2) ^ 0xFFFF);
  if ((int)(a4 - WORD1(a3) + (~(_DWORD)a2 >> 16)) >= 0xFFFF)
    v6 = 0xFFFF;
  else
    v6 = a4 - WORD1(a3) + (~(_DWORD)a2 >> 16);
  if (v4 >= 0xFFFF)
    v4 = 0xFFFF;
  if (v5 >= 0xFFFF)
    v5 = 0xFFFF;
  v7 = bswap32(~v6) >> 16;
  *result = v7;
  result[1] = v7;
  result[2] = bswap32(~v4) >> 16;
  result[3] = bswap32(~v5) >> 16;
  return result;
}

unsigned int *CMYK64_DApluslDA(unsigned int *result, _WORD *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v6 = (unsigned __int16)a5 + (unsigned __int16)a3;
  v7 = WORD1(a5) + WORD1(a3);
  v8 = WORD2(a5) + WORD2(a3);
  v9 = HIWORD(a5) + HIWORD(a3);
  v10 = a6 + a4;
  if (v6 >= 0xFFFF)
    v6 = 0xFFFF;
  if (v7 >= 0xFFFF)
    v7 = 0xFFFF;
  if (v8 >= 0xFFFF)
    v8 = 0xFFFF;
  if (v9 >= 0xFFFF)
    v9 = 0xFFFF;
  if (v10 >= 0xFFFF)
    v10 = 0xFFFF;
  *result = v6 | (v7 << 16);
  result[1] = v8 | (v9 << 16);
  *a2 = bswap32(v10) >> 16;
  return result;
}

_WORD *CMYK64_DpluslD(_WORD *result, unint64_t a2, unint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  v3 = (unsigned __int16)a3 + (unsigned __int16)a2;
  v4 = WORD1(a3) + WORD1(a2);
  v5 = WORD2(a3) + WORD2(a2);
  v6 = HIWORD(a3) + HIWORD(a2);
  if (v3 >= 0xFFFF)
    v3 = 0xFFFF;
  if (v4 >= 0xFFFF)
    v4 = 0xFFFF;
  if (v5 >= 0xFFFF)
    v5 = 0xFFFF;
  if (v6 >= 0xFFFF)
    v6 = 0xFFFF;
  *result = bswap32(v3) >> 16;
  result[1] = bswap32(v4) >> 16;
  result[2] = bswap32(v5) >> 16;
  result[3] = bswap32(v6) >> 16;
  return result;
}

uint64_t CMYK64_image_mark_W8(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6;
  unsigned __int16 *v7;
  _WORD *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _BOOL8 v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unsigned __int16 v16;
  unsigned int v17;
  unsigned int v18;
  int32x4_t v19;
  uint32x4_t v20;
  uint64_t result;
  int32x4_t v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int32x4_t v27;
  uint32x4_t v28;
  unsigned int v29;
  int32x4_t v30;
  uint32x4_t v31;
  int32x4_t v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int32x4_t v37;
  uint32x4_t v38;
  unsigned int v39;
  int32x4_t v40;
  uint32x4_t v41;

  v6 = *((unsigned __int16 *)a2 + 4);
  v7 = (unsigned __int16 *)*((_QWORD *)a2 + 2);
  v8 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v8)
    v9 = *((_QWORD *)a2 + 5) - a5;
  else
    v9 = 0;
  v10 = *a2;
  v11 = *((_QWORD *)a2 + 3) - a5;
  v12 = v8 != 0;
  v13 = *(_QWORD *)(a1 + 176);
  if (v6 == 0xFFFF)
    v14 = 0xFEFE000000000000;
  else
    v14 = (unint64_t)(65278 - ((65278 * (v6 ^ 0xFFFF) + ((65278 * (v6 ^ 0xFFFFu)) >> 16) + 1) >> 16)) << 48;
  if (v6 == 0xFFFF)
    v15 = -1;
  else
    v15 = ~(0xFFFF * (v6 ^ 0xFFFF) + ((0xFFFF * (v6 ^ 0xFFFFu)) >> 16) + 1) >> 16;
  v16 = __rev16(HIWORD(v14));
  v17 = bswap32(v15) >> 16;
  v18 = (unsigned __int16)~(_WORD)v15;
  v19 = vdupq_n_s32(v18);
  v20 = (uint32x4_t)vmovn_hight_s64(0, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v14), (uint64x2_t)xmmword_185004DA0));
  if (v13)
  {
    result = 2 * v12;
    v22.i64[0] = 0x100000001;
    v22.i64[1] = 0x100000001;
    do
    {
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          v23 = a5;
          do
          {
            *(_DWORD *)v7 = 0;
            v7[2] = 0;
            v7[3] = v16;
            if (v8)
              *v8 = v17;
            v7 += 4;
            v8 = (_WORD *)((char *)v8 + result);
            --v23;
          }
          while (v23);
        }
      }
      else
      {
        v24 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v8)
            {
              if ((_WORD)v15)
              {
                if ((unsigned __int16)v15 == 0xFFFF)
                {
                  *(_DWORD *)v7 = 0;
                  v7[2] = 0;
                  v7[3] = v16;
                  *v8 = -1;
                }
                else
                {
                  v25 = bswap32(v7[1] | (*v7 << 16));
                  v26 = bswap32((unsigned __int16)*v8);
                  v27.i32[0] = (unsigned __int16)v25;
                  v27.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v25), 0x10uLL).i32[1];
                  v27.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                  v28 = (uint32x4_t)vmulq_s32(v27, v19);
                  *(int8x8_t *)v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v28, v28, 0x10uLL), v22), 0x10uLL)));
                  *v8 = bswap32(v15 + ((v18 * HIWORD(v26) + ((v18 * HIWORD(v26)) >> 16) + 1) >> 16)) >> 16;
                }
              }
            }
            else if ((_WORD)v15)
            {
              if ((unsigned __int16)v15 == 0xFFFF)
              {
                *(_DWORD *)v7 = 0;
                v7[2] = 0;
                v7[3] = v16;
              }
              else
              {
                v29 = bswap32(v7[1] | (*v7 << 16));
                v30.i32[0] = (unsigned __int16)v29;
                v30.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v29), 0x10uLL).i32[1];
                v30.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                v31 = (uint32x4_t)vmulq_s32(v30, v19);
                *(int8x8_t *)v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v31, v31, 0x10uLL), v22), 0x10uLL)));
              }
            }
            v7 += 4;
            v8 = (_WORD *)((char *)v8 + result);
            --v24;
          }
          while (v24);
        }
      }
      v7 += 4 * v11;
      v8 += v9;
      --a6;
    }
    while (a6);
  }
  else
  {
    result = 2 * v12;
    v32.i64[0] = 0x100000001;
    v32.i64[1] = 0x100000001;
    do
    {
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          v33 = a5;
          do
          {
            *(_DWORD *)v7 = 0;
            v7[2] = 0;
            v7[3] = v16;
            if (v8)
              *v8 = v17;
            v7 += 4;
            v8 = (_WORD *)((char *)v8 + result);
            --v33;
          }
          while (v33);
        }
      }
      else
      {
        v34 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v8)
            {
              if ((_WORD)v15)
              {
                if ((unsigned __int16)v15 == 0xFFFF)
                {
                  *(_DWORD *)v7 = 0;
                  v7[2] = 0;
                  v7[3] = v16;
                  *v8 = -1;
                }
                else
                {
                  v35 = bswap32(v7[1] | (*v7 << 16));
                  v36 = bswap32((unsigned __int16)*v8);
                  v37.i32[0] = (unsigned __int16)v35;
                  v37.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v35), 0x10uLL).i32[1];
                  v37.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                  v38 = (uint32x4_t)vmulq_s32(v37, v19);
                  *(int8x8_t *)v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v38, v38, 0x10uLL), v32), 0x10uLL)));
                  *v8 = bswap32(v15 + ((v18 * HIWORD(v36) + ((v18 * HIWORD(v36)) >> 16) + 1) >> 16)) >> 16;
                }
              }
            }
            else if ((_WORD)v15)
            {
              if ((unsigned __int16)v15 == 0xFFFF)
              {
                *(_DWORD *)v7 = 0;
                v7[2] = 0;
                v7[3] = v16;
              }
              else
              {
                v39 = bswap32(v7[1] | (*v7 << 16));
                v40.i32[0] = (unsigned __int16)v39;
                v40.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v39), 0x10uLL).i32[1];
                v40.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                v41 = (uint32x4_t)vmulq_s32(v40, v19);
                *(int8x8_t *)v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v41, v41, 0x10uLL), v32), 0x10uLL)));
              }
            }
            v7 += 4;
            v8 = (_WORD *)((char *)v8 + result);
            --v34;
          }
          while (v34);
        }
      }
      v7 += 4 * v11;
      v8 += v9;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t CMYK64_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int8x8_t *v6;
  _WORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t result;
  unsigned __int8 *v17;
  int v18;
  int32x4_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned int v30;
  char v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned __int8 *v41;
  unsigned int v42;
  int v43;
  int v44;
  unsigned int v45;
  unint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unsigned int v57;
  unsigned int v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unsigned __int8 *v65;
  unsigned int v66;
  char v67;
  unsigned __int8 *v68;
  int v69;
  unsigned __int8 *v70;
  int v71;
  unsigned __int8 *v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned __int8 *v77;
  unsigned int v78;
  int v79;
  int v80;
  unsigned int v81;
  unint64_t v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  unsigned int v100;
  int32x4_t v101;
  unsigned int v102;
  uint32x4_t v103;
  unsigned int v104;
  int32x4_t v105;
  uint32x4_t v106;
  uint64_t *v107;
  unsigned __int8 *v108;
  int v109;
  unsigned int v110;
  uint64_t v111;
  int32x4_t v112;
  unsigned __int8 *v113;
  uint64_t *v114;
  uint64_t v115;
  uint64_t v116;
  unsigned __int8 *v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unsigned int v130;
  unint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  uint64_t v134;
  unsigned __int8 *v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unsigned int v146;
  unint64_t v147;
  unint64_t v148;
  unsigned int v149;
  int v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  unsigned int v154;
  int32x4_t v155;
  unsigned int v156;
  uint32x4_t v157;
  unsigned int v158;
  int32x4_t v159;
  uint32x4_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char v164;
  uint64_t v165;
  unsigned int v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  char v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  uint64_t v174;
  int v175;

  v6 = (int8x8_t *)*((_QWORD *)a2 + 2);
  v7 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v7)
    v174 = *((_QWORD *)a2 + 5) - a5;
  else
    v174 = 0;
  v8 = *((unsigned __int16 *)a2 + 4);
  v173 = *a2;
  v172 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v9 = *((_QWORD *)a2 + 18);
  v11 = *((_QWORD *)a2 + 9);
  v169 = *((_QWORD *)a2 + 11);
  v170 = v11;
  v12 = *((_QWORD *)a2 + 7) + v169 * a4;
  v13 = *(unsigned __int8 **)(a1 + 32);
  v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v15 = *(_QWORD *)(a1 + 176);
  result = 2 * (v7 != 0);
  v175 = a5;
  v171 = v10;
  if (v15)
  {
    v168 = *((_QWORD *)a2 + 13);
    v167 = *((_QWORD *)a2 + 15);
    v165 = ~(-1 << v11);
    v164 = v11 - 4;
    v17 = v14 - 3;
    v18 = v8 ^ 0xFFFF;
    v166 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1);
    v162 = a5;
    v163 = -v10;
    v161 = v9 + 16 * a3 + 8;
    v19.i64[0] = 0x100000001;
    v19.i64[1] = 0x100000001;
    while (1)
    {
      if (((v167 - v12) | (v12 - v168)) < 0)
      {
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v20 = ((v12 & (unint64_t)v165) >> v164) & 0xF;
        v21 = (unint64_t)(v20 - 7) >= 9 ? v163 : v10;
        v22 = weights_19497[v20] & 0xF;
      }
      v23 = &v13[(v12 >> v11) * v10];
      if (v173 != 1)
        break;
      if (a5 >= 1)
      {
        v24 = (uint64_t *)v161;
        v25 = v162;
        while (1)
        {
          v26 = *(v24 - 1);
          v27 = *v24;
          v28 = &v23[v26];
          if (v17 >= &v23[v26])
            v29 = &v23[v26];
          else
            v29 = v17;
          if (v29 < v13)
            v29 = v13;
          v30 = (*v29 << 24) | (v29[1] << 16) | (v29[2] << 8);
          v31 = v27 & 0xF;
          if ((v27 & 0xF) != 0)
            break;
          if (v22)
          {
            v41 = &v28[v21];
            if (v17 < &v28[v21])
              v41 = v17;
            if (v41 < v13)
              v41 = v13;
            v42 = BLEND8_19499[v22];
            v39 = v30 - ((v42 & v30) >> v22);
            v40 = (((*v41 << 24) | (v41[1] << 16) | (v41[2] << 8)) & v42) >> v22;
            goto LABEL_43;
          }
LABEL_44:
          v43 = BYTE2(v30);
          v44 = BYTE1(v30);
          HIDWORD(v46) = HIBYTE(v30);
          LODWORD(v46) = v30;
          v45 = v46 >> 24;
          v47 = v43 | (v43 << 8);
          v48 = v44 | (v44 << 8);
          if (v45 <= v47)
            v49 = v47;
          else
            v49 = v45;
          if (v48 > v49)
            v49 = v48;
          v50 = v49 - v45;
          v51 = v49 - v47;
          v52 = v49 - v48;
          v53 = v49 ^ 0xFFFF;
          v54 = (unint64_t)(unsigned __int16)v52 << 32;
          v55 = (unint64_t)(v53
                                 - (((_DWORD)v53 * v18 + ((v53 * v18) >> 16) + 1) >> 16)) << 48;
          v56 = (unint64_t)(unsigned __int16)(v52 - ((v52 * v18 + ((v52 * v18) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
          {
            v56 = v53 << 48;
            v55 = v54;
            v57 = v50;
          }
          else
          {
            v51 -= (v51 * v18 + ((v51 * v18) >> 16) + 1) >> 16;
            v57 = v50 - ((v50 * v18 + ((v50 * v18) >> 16) + 1) >> 16);
          }
          if (v8 == 0xFFFF)
            v58 = 0xFFFF;
          else
            v58 = HIWORD(v166);
          v59 = v55 | v56;
          v6->i16[0] = bswap32(v57) >> 16;
          v6->i16[1] = bswap32(v51) >> 16;
          v6->i16[2] = bswap32(HIDWORD(v59)) >> 16;
          v6->i16[3] = __rev16(HIWORD(v59));
          if (v7)
            *v7 = __rev16(v58);
          v24 += 2;
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          if (!--v25)
            goto LABEL_114;
        }
        v32 = &v28[v27 >> 4];
        if (v17 < v32)
          v32 = v17;
        if (v32 < v13)
          v32 = v13;
        v33 = (*v32 << 24) | (v32[1] << 16) | (v32[2] << 8);
        if (v22)
        {
          v34 = &v28[v21];
          if (v17 >= &v28[v21])
            v35 = &v28[v21];
          else
            v35 = v17;
          if (v35 < v13)
            v35 = v13;
          v36 = &v34[v27 >> 4];
          if (v17 < v36)
            v36 = v17;
          if (v36 < v13)
            v36 = v13;
          v37 = BLEND8_19499[v22];
          v30 = v30 - ((v37 & v30) >> v22) + ((v37 & ((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8))) >> v22);
          v33 = v33 - ((v37 & v33) >> v22) + ((((*v36 << 24) | (v36[1] << 16) | (v36[2] << 8)) & v37) >> v22);
        }
        v38 = BLEND8_19499[*v24 & 0xF];
        v39 = v30 - ((v38 & v30) >> v31);
        v40 = (v38 & v33) >> v31;
LABEL_43:
        v30 = v39 + v40;
        goto LABEL_44;
      }
LABEL_114:
      v10 = v171;
      v6 += v172;
      LOBYTE(v11) = v170;
      v12 += v169;
      a5 = v175;
      v7 += v174;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_114;
    v61 = (uint64_t *)v161;
    v60 = v162;
    while (1)
    {
      v62 = *(v61 - 1);
      v63 = *v61;
      v64 = &v23[v62];
      if (v17 >= &v23[v62])
        v65 = &v23[v62];
      else
        v65 = v17;
      if (v65 < v13)
        v65 = v13;
      v66 = (*v65 << 24) | (v65[1] << 16) | (v65[2] << 8);
      v67 = v63 & 0xF;
      if ((v63 & 0xF) != 0)
        break;
      if (v22)
      {
        v77 = &v64[v21];
        if (v17 < &v64[v21])
          v77 = v17;
        if (v77 < v13)
          v77 = v13;
        v78 = BLEND8_19499[v22];
        v75 = v66 - ((v78 & v66) >> v22);
        v76 = (((*v77 << 24) | (v77[1] << 16) | (v77[2] << 8)) & v78) >> v22;
        goto LABEL_89;
      }
LABEL_90:
      v79 = BYTE2(v66);
      v80 = BYTE1(v66);
      HIDWORD(v82) = HIBYTE(v66);
      LODWORD(v82) = v66;
      v81 = v82 >> 24;
      v83 = v79 | (v79 << 8);
      v84 = v80 | (v80 << 8);
      if (v81 <= v83)
        v85 = v83;
      else
        v85 = v81;
      if (v84 > v85)
        v85 = v84;
      v86 = v85 - v81;
      v87 = v85 - v83;
      v88 = v85 - v84;
      v89 = v85 ^ 0xFFFF;
      v90 = v89 << 48;
      v91 = (unint64_t)(unsigned __int16)v88 << 32;
      v92 = (unint64_t)(v89 - (((_DWORD)v89 * v18 + ((v89 * v18) >> 16) + 1) >> 16)) << 48;
      v93 = (unint64_t)(unsigned __int16)(v88 - ((v88 * v18 + ((v88 * v18) >> 16) + 1) >> 16)) << 32;
      if (v8 == 0xFFFF)
      {
        v93 = v90;
        v92 = v91;
        v94 = v87;
      }
      else
      {
        v94 = v87 - ((v87 * v18 + ((v87 * v18) >> 16) + 1) >> 16);
      }
      if (v8 == 0xFFFF)
        v95 = v86;
      else
        v95 = v86 - ((v86 * v18 + ((v86 * v18) >> 16) + 1) >> 16);
      if (v8 == 0xFFFF)
        v96 = 0xFFFF;
      else
        v96 = HIWORD(v166);
      v97 = v92 | v93;
      v98 = (unsigned __int16)v95 | ((unsigned __int16)v94 << 16);
      v99 = v92 | v93 | v98;
      if (v7)
      {
        if (v96)
        {
          if (v96 == 0xFFFF)
          {
            v6->i16[0] = bswap32(v95) >> 16;
            v6->i16[1] = bswap32(v94) >> 16;
            v6->i16[2] = bswap32(HIDWORD(v97)) >> 16;
            v6->i16[3] = __rev16(HIWORD(v97));
            *v7 = -1;
          }
          else
          {
            v100 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
            v101.i32[0] = (unsigned __int16)v100;
            v101.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v100), 0x10uLL).i32[1];
            v102 = (unsigned __int16)~(_WORD)v96 * (bswap32((unsigned __int16)*v7) >> 16);
            v101.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
            v103 = (uint32x4_t)vmulq_s32(v101, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v96)));
            *v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v94, v98), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v99), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v103, v103, 0x10uLL), v19), 0x10uLL)));
            *v7 = bswap32(v96 + ((v102 + HIWORD(v102) + 1) >> 16)) >> 16;
          }
        }
      }
      else if (v96)
      {
        if (v96 == 0xFFFF)
        {
          v6->i16[0] = bswap32(v95) >> 16;
          v6->i16[1] = bswap32(v94) >> 16;
          v6->i16[2] = bswap32(HIDWORD(v97)) >> 16;
          v6->i16[3] = __rev16(HIWORD(v97));
        }
        else
        {
          v104 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
          v105.i32[0] = (unsigned __int16)v104;
          v105.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v104), 0x10uLL).i32[1];
          v105.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
          v106 = (uint32x4_t)vmulq_s32(v105, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v96)));
          *v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v94, v98), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v99), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v106, v106, 0x10uLL), v19), 0x10uLL)));
        }
      }
      v61 += 2;
      ++v6;
      v7 = (_WORD *)((char *)v7 + result);
      if (!--v60)
        goto LABEL_114;
    }
    v68 = &v64[v63 >> 4];
    if (v17 < v68)
      v68 = v17;
    if (v68 < v13)
      v68 = v13;
    v69 = (*v68 << 24) | (v68[1] << 16) | (v68[2] << 8);
    if (v22)
    {
      if (v17 >= &v64[v21])
        v70 = &v64[v21];
      else
        v70 = v17;
      if (v70 < v13)
        v70 = v13;
      v71 = (*v70 << 24) | (v70[1] << 16) | (v70[2] << 8);
      v72 = &v64[v21 + (v63 >> 4)];
      if (v17 < v72)
        v72 = v17;
      if (v72 < v13)
        v72 = v13;
      v73 = BLEND8_19499[v22];
      v66 = v66 - ((v73 & v66) >> v22) + ((v73 & v71) >> v22);
      v69 = v69 - ((v73 & v69) >> v22) + ((((*v72 << 24) | (v72[1] << 16) | (v72[2] << 8)) & v73) >> v22);
    }
    v74 = BLEND8_19499[*v61 & 0xF];
    v75 = v66 - ((v74 & v66) >> v67);
    v76 = (v74 & v69) >> v67;
LABEL_89:
    v66 = v75 + v76;
    goto LABEL_90;
  }
  v107 = (uint64_t *)(v9 + 16 * a3);
  v108 = v14 - 3;
  v109 = v8 ^ 0xFFFF;
  v110 = ~(0xFFFF * v109 + ((0xFFFF * v109) >> 16) + 1);
  v111 = a5;
  v112.i64[0] = 0x100000001;
  v112.i64[1] = 0x100000001;
  do
  {
    v113 = &v13[(v12 >> v11) * v10];
    if (v173 == 1)
    {
      if (a5 >= 1)
      {
        v114 = v107;
        v115 = v111;
        do
        {
          v116 = *v114;
          v114 += 2;
          v117 = &v113[v116];
          if (v108 < &v113[v116])
            v117 = v108;
          if (v117 < v13)
            v117 = v13;
          v118 = *v117 | (*v117 << 8);
          v119 = v117[1] | (v117[1] << 8);
          v120 = v117[2] | (v117[2] << 8);
          if (v118 <= v119)
            v121 = v119;
          else
            v121 = v118;
          if (v120 > v121)
            v121 = v120;
          v122 = v121 - v118;
          v123 = v121 - v119;
          v124 = v121 - v120;
          v125 = v121 ^ 0xFFFF;
          v126 = v125 << 48;
          v127 = (unint64_t)(unsigned __int16)v124 << 32;
          v128 = (unint64_t)(v125
                                  - (((_DWORD)v125 * v109 + ((v125 * v109) >> 16) + 1) >> 16)) << 48;
          v129 = (unint64_t)(unsigned __int16)(v124 - ((v124 * v109 + ((v124 * v109) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
            v128 = v127;
          else
            v126 = v129;
          if (v8 == 0xFFFF)
          {
            v130 = 0xFFFF;
          }
          else
          {
            v123 -= (v123 * v109 + ((v123 * v109) >> 16) + 1) >> 16;
            v122 -= (v122 * v109 + ((v122 * v109) >> 16) + 1) >> 16;
            v130 = HIWORD(v110);
          }
          v131 = v128 | v126;
          v6->i16[0] = bswap32(v122) >> 16;
          v6->i16[1] = bswap32(v123) >> 16;
          v6->i16[2] = bswap32(HIDWORD(v131)) >> 16;
          v6->i16[3] = __rev16(HIWORD(v131));
          if (v7)
            *v7 = __rev16(v130);
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          --v115;
        }
        while (v115);
      }
    }
    else
    {
      v132 = v107;
      v133 = v111;
      if (a5 >= 1)
      {
        do
        {
          v134 = *v132;
          v132 += 2;
          v135 = &v113[v134];
          if (v108 < &v113[v134])
            v135 = v108;
          if (v135 < v13)
            v135 = v13;
          v136 = *v135 | (*v135 << 8);
          v137 = v135[1] | (v135[1] << 8);
          v138 = v135[2] | (v135[2] << 8);
          if (v136 <= v137)
            v139 = v137;
          else
            v139 = v136;
          if (v138 > v139)
            v139 = v138;
          v140 = v139 - v136;
          v141 = v139 - v137;
          v142 = v139 - v138;
          v143 = v139 ^ 0xFFFF;
          v144 = v143 << 48;
          v145 = (unint64_t)(unsigned __int16)v142 << 32;
          v146 = v141 - ((v141 * v109 + ((v141 * v109) >> 16) + 1) >> 16);
          v147 = (unint64_t)(v143
                                  - (((_DWORD)v143 * v109 + ((v143 * v109) >> 16) + 1) >> 16)) << 48;
          v148 = (unint64_t)(unsigned __int16)(v142 - ((v142 * v109 + ((v142 * v109) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
          {
            v148 = v144;
            v147 = v145;
            v146 = v141;
            v149 = v140;
          }
          else
          {
            v149 = v140 - ((v140 * v109 + ((v140 * v109) >> 16) + 1) >> 16);
          }
          if (v8 == 0xFFFF)
            v150 = 0xFFFF;
          else
            v150 = HIWORD(v110);
          v151 = v147 | v148;
          v152 = (unsigned __int16)v149 | ((unsigned __int16)v146 << 16);
          v153 = v151 | v152;
          if (v7)
          {
            if (v150)
            {
              if (v150 == 0xFFFF)
              {
                v6->i16[0] = bswap32(v149) >> 16;
                v6->i16[1] = bswap32(v146) >> 16;
                v6->i16[2] = bswap32(HIDWORD(v151)) >> 16;
                v6->i16[3] = __rev16(HIWORD(v151));
                *v7 = -1;
              }
              else
              {
                v154 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
                v155.i32[0] = (unsigned __int16)v154;
                v155.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v154), 0x10uLL).i32[1];
                v156 = (unsigned __int16)~(_WORD)v150 * (bswap32((unsigned __int16)*v7) >> 16);
                v155.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
                v157 = (uint32x4_t)vmulq_s32(v155, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v150)));
                *v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v146, v152), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v153), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v157, v157, 0x10uLL), v112), 0x10uLL)));
                *v7 = bswap32(v150 + ((v156 + HIWORD(v156) + 1) >> 16)) >> 16;
              }
            }
          }
          else if (v150)
          {
            if (v150 == 0xFFFF)
            {
              v6->i16[0] = bswap32(v149) >> 16;
              v6->i16[1] = bswap32(v146) >> 16;
              v6->i16[2] = bswap32(HIDWORD(v151)) >> 16;
              v6->i16[3] = __rev16(HIWORD(v151));
            }
            else
            {
              v158 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
              v159.i32[0] = (unsigned __int16)v158;
              v159.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v158), 0x10uLL).i32[1];
              v159.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
              v160 = (uint32x4_t)vmulq_s32(v159, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v150)));
              *v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v146, v152), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v153), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v160, v160, 0x10uLL), v112), 0x10uLL)));
            }
          }
          ++v6;
          v7 = (_WORD *)((char *)v7 + result);
          --v133;
        }
        while (v133);
      }
    }
    v10 = v171;
    v6 += v172;
    LOBYTE(v11) = v170;
    v12 += v169;
    a5 = v175;
    v7 += v174;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t CMYK64_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9, int32x4_t a10)
{
  int v10;
  int8x8_t *v11;
  _WORD *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  char *v20;
  uint64_t v21;
  uint64_t result;
  unsigned int *v23;
  int v24;
  int32x4_t v25;
  int32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  unsigned int *v36;
  unsigned int v37;
  char v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int *v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int *v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unint64_t v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned __int32 v57;
  int32x4_t v58;
  int32x4_t v59;
  int8x16_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  unsigned int *v66;
  unsigned int v67;
  char v68;
  unsigned int *v69;
  unsigned int v70;
  char *v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int *v74;
  int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int *v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  unint64_t v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  unsigned __int32 v87;
  int32x4_t v88;
  int32x4_t v89;
  int8x16_t v90;
  unsigned __int32 v91;
  uint64_t v92;
  unint64_t v93;
  unsigned int v94;
  unsigned int v95;
  int32x4_t v96;
  uint32x4_t v97;
  unsigned int v98;
  int32x4_t v99;
  uint32x4_t v100;
  uint64_t *v101;
  unsigned int *v102;
  int v103;
  int32x4_t v104;
  int32x4_t v105;
  uint64_t v106;
  char *v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int *v111;
  unsigned int v112;
  unsigned int v113;
  unint64_t v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  unsigned __int32 v118;
  int32x4_t v119;
  int32x4_t v120;
  int8x16_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  unsigned int *v125;
  unsigned int v126;
  unsigned int v127;
  unint64_t v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  unsigned __int32 v132;
  int32x4_t v133;
  int32x4_t v134;
  int8x16_t v135;
  unsigned __int32 v136;
  uint64_t v137;
  unint64_t v138;
  unsigned int v139;
  unsigned int v140;
  int32x4_t v141;
  uint32x4_t v142;
  unsigned int v143;
  int32x4_t v144;
  uint32x4_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  char v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v154;
  char v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  uint64_t v159;

  if (*(_QWORD *)(a1 + 40))
    v10 = 0;
  else
    v10 = 255;
  v11 = (int8x8_t *)*((_QWORD *)a2 + 2);
  v12 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v12)
    v159 = *((_QWORD *)a2 + 5) - a5;
  else
    v159 = 0;
  v13 = *((unsigned __int16 *)a2 + 4);
  v14 = a2[1];
  v158 = *a2;
  v157 = *((_QWORD *)a2 + 3) - a5;
  v16 = *((_QWORD *)a2 + 17);
  v15 = *((_QWORD *)a2 + 18);
  v17 = *((_QWORD *)a2 + 9);
  v154 = *((_QWORD *)a2 + 11);
  v18 = *((_QWORD *)a2 + 7) + v154 * a4;
  v19 = *(unsigned int **)(a1 + 32);
  v20 = (char *)v19
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  v21 = *(_QWORD *)(a1 + 176);
  result = 2 * (v12 != 0);
  v155 = v17;
  v156 = v16;
  if (v21)
  {
    v151 = *((_QWORD *)a2 + 15);
    v152 = *((_QWORD *)a2 + 13);
    v150 = ~(-1 << v17);
    v148 = -v16;
    v149 = v17 - 4;
    v23 = (unsigned int *)(v20 - 4);
    v24 = v13 ^ 0xFFFF;
    v25 = vdupq_n_s32(v13 ^ 0xFFFFu);
    v146 = v15 + 16 * a3 + 8;
    v147 = a5;
    v26.i64[0] = 0x100000001;
    v26.i64[1] = 0x100000001;
    while (1)
    {
      if (((v151 - v18) | (v18 - v152)) < 0)
      {
        v29 = 0;
        v28 = 0;
      }
      else
      {
        v27 = ((v18 & (unint64_t)v150) >> v149) & 0xF;
        v28 = (unint64_t)(v27 - 7) >= 9 ? v148 : v16;
        v29 = weights_19497[v27] & 0xF;
      }
      v30 = (char *)v19 + (v18 >> v17) * v16;
      if (v158 != 1)
        break;
      if (a5 >= 1)
      {
        v31 = (uint64_t *)v146;
        v32 = v147;
        while (1)
        {
          v33 = *(v31 - 1);
          v34 = *v31;
          v35 = &v30[v33];
          if (v23 >= (unsigned int *)&v30[v33])
            v36 = (unsigned int *)&v30[v33];
          else
            v36 = v23;
          if (v36 < v19)
            v36 = v19;
          v37 = bswap32(*v36);
          v38 = v34 & 0xF;
          if ((v34 & 0xF) != 0)
            break;
          if (v29)
          {
            v49 = (unsigned int *)&v35[v28];
            if (v23 < (unsigned int *)&v35[v28])
              v49 = v23;
            if (v49 < v19)
              v49 = v19;
            v50 = BLEND8_19499[v29];
            v47 = v37 - ((v50 & v37) >> v29);
            v48 = (bswap32(*v49) & v50) >> v29;
            goto LABEL_46;
          }
LABEL_47:
          v51 = __ROL4__(v37, v14);
          HIDWORD(v53) = HIBYTE(v51);
          LODWORD(v53) = v51;
          v52 = v53 >> 24;
          v54 = BYTE2(v51) | (BYTE2(v51) << 8);
          v55 = BYTE1(v51) | (BYTE1(v51) << 8);
          v56 = v51 | v10 | ((v51 | v10) << 8);
          if (v52 <= v54)
            v57 = v54;
          else
            v57 = v52;
          if (v55 > v57)
            v57 = v55;
          a10.i64[0] = __PAIR64__(v56, v57);
          v58 = vzip1q_s32(a10, a10);
          v58.i32[2] = v57;
          v59.i64[0] = __PAIR64__(v54, v52);
          v59.i64[1] = __PAIR64__(v57, v55);
          a10 = vsubq_s32(v58, v59);
          if (v13 != 0xFFFF)
          {
            v60 = (int8x16_t)vmulq_s32(a10, v25);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v60, 0x10uLL), (int32x4_t)vmvnq_s8(v60)), 0x10uLL));
            v56 -= (v56 * v24 + ((v56 * v24) >> 16) + 1) >> 16;
          }
          *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12)
            *v12 = bswap32(v56) >> 16;
          v31 += 2;
          ++v11;
          v12 = (_WORD *)((char *)v12 + result);
          if (!--v32)
            goto LABEL_107;
        }
        v39 = (unsigned int *)&v35[v34 >> 4];
        if (v23 < v39)
          v39 = v23;
        if (v39 < v19)
          v39 = v19;
        v40 = bswap32(*v39);
        if (v29)
        {
          v41 = (unsigned int *)&v35[v28];
          if (v23 >= v41)
            v42 = v41;
          else
            v42 = v23;
          if (v42 < v19)
            v42 = v19;
          v43 = bswap32(*v42);
          v44 = (unsigned int *)((char *)v41 + (v34 >> 4));
          if (v23 < v44)
            v44 = v23;
          if (v44 < v19)
            v44 = v19;
          v45 = BLEND8_19499[v29];
          v37 = v37 - ((v45 & v37) >> v29) + ((v45 & v43) >> v29);
          v40 = v40 - ((v45 & v40) >> v29) + ((bswap32(*v44) & v45) >> v29);
        }
        v46 = BLEND8_19499[*v31 & 0xF];
        v47 = v37 - ((v46 & v37) >> v38);
        v48 = (v46 & v40) >> v38;
LABEL_46:
        v37 = v47 + v48;
        goto LABEL_47;
      }
LABEL_107:
      v16 = v156;
      v11 += v157;
      LOBYTE(v17) = v155;
      v18 += v154;
      v12 += v159;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_107;
    v62 = (uint64_t *)v146;
    v61 = v147;
    while (1)
    {
      v63 = *(v62 - 1);
      v64 = *v62;
      v65 = &v30[v63];
      if (v23 >= (unsigned int *)&v30[v63])
        v66 = (unsigned int *)&v30[v63];
      else
        v66 = v23;
      if (v66 < v19)
        v66 = v19;
      v67 = bswap32(*v66);
      v68 = v64 & 0xF;
      if ((v64 & 0xF) != 0)
        break;
      if (v29)
      {
        v79 = (unsigned int *)&v65[v28];
        if (v23 < (unsigned int *)&v65[v28])
          v79 = v23;
        if (v79 < v19)
          v79 = v19;
        v80 = BLEND8_19499[v29];
        v77 = v67 - ((v80 & v67) >> v29);
        v78 = (bswap32(*v79) & v80) >> v29;
        goto LABEL_88;
      }
LABEL_89:
      v81 = __ROL4__(v67, v14);
      HIDWORD(v83) = HIBYTE(v81);
      LODWORD(v83) = v81;
      v82 = v83 >> 24;
      v84 = BYTE2(v81) | (BYTE2(v81) << 8);
      v85 = BYTE1(v81) | (BYTE1(v81) << 8);
      v86 = v81 | v10 | ((v81 | v10) << 8);
      if (v82 <= v84)
        v87 = v84;
      else
        v87 = v82;
      if (v85 > v87)
        v87 = v85;
      a10.i64[0] = __PAIR64__(v86, v87);
      v88 = vzip1q_s32(a10, a10);
      v88.i32[2] = v87;
      v89.i64[0] = __PAIR64__(v84, v82);
      v89.i64[1] = __PAIR64__(v87, v85);
      a10 = vsubq_s32(v88, v89);
      if (v13 != 0xFFFF)
      {
        v90 = (int8x16_t)vmulq_s32(a10, v25);
        a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x10uLL), (int32x4_t)vmvnq_s8(v90)), 0x10uLL));
        v86 -= (v86 * v24 + ((v86 * v24) >> 16) + 1) >> 16;
      }
      v91 = a10.u32[1];
      v92 = a10.u16[0] | (a10.u16[2] << 16);
      v93 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v92;
      if (v12)
      {
        if ((_WORD)v86)
        {
          if ((unsigned __int16)v86 == 0xFFFF)
          {
            *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
            *v12 = -1;
          }
          else
          {
            v94 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
            v95 = bswap32((unsigned __int16)*v12);
            v96.i32[0] = (unsigned __int16)v94;
            v96.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v94), 0x10uLL).i32[1];
            a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_185004DA0);
            v96.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
            v97 = (uint32x4_t)vmulq_s32(v96, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
            *v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v97, v97, 0x10uLL), v26), 0x10uLL)));
            *v12 = bswap32(v86+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)) >> 16)+ 1) >> 16)) >> 16;
          }
        }
      }
      else if ((_WORD)v86)
      {
        if ((unsigned __int16)v86 == 0xFFFF)
        {
          *(int16x4_t *)a10.i8 = vmovn_s32(a10);
        }
        else
        {
          v98 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
          v99.i32[0] = (unsigned __int16)v98;
          v99.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v98), 0x10uLL).i32[1];
          a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_185004DA0);
          v99.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
          v100 = (uint32x4_t)vmulq_s32(v99, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
          *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v100, v100, 0x10uLL), v26), 0x10uLL));
        }
        *v11 = vrev16_s8(*(int8x8_t *)a10.i8);
      }
      v62 += 2;
      ++v11;
      v12 = (_WORD *)((char *)v12 + result);
      if (!--v61)
        goto LABEL_107;
    }
    v69 = (unsigned int *)&v65[v64 >> 4];
    if (v23 < v69)
      v69 = v23;
    if (v69 < v19)
      v69 = v19;
    v70 = bswap32(*v69);
    if (v29)
    {
      v71 = &v65[v28];
      if (v23 >= (unsigned int *)&v65[v28])
        v72 = (unsigned int *)&v65[v28];
      else
        v72 = v23;
      if (v72 < v19)
        v72 = v19;
      v73 = bswap32(*v72);
      v74 = (unsigned int *)&v71[v64 >> 4];
      if (v23 < v74)
        v74 = v23;
      if (v74 < v19)
        v74 = v19;
      v75 = BLEND8_19499[v29];
      v67 = v67 - ((v75 & v67) >> v29) + ((v75 & v73) >> v29);
      v70 = v70 - ((v75 & v70) >> v29) + ((bswap32(*v74) & v75) >> v29);
    }
    v76 = BLEND8_19499[*v62 & 0xF];
    v77 = v67 - ((v76 & v67) >> v68);
    v78 = (v76 & v70) >> v68;
LABEL_88:
    v67 = v77 + v78;
    goto LABEL_89;
  }
  v101 = (uint64_t *)(v15 + 16 * a3);
  v102 = (unsigned int *)(v20 - 4);
  v103 = v13 ^ 0xFFFF;
  v104 = vdupq_n_s32(v13 ^ 0xFFFFu);
  v105.i64[0] = 0x100000001;
  v105.i64[1] = 0x100000001;
  v106 = a5;
  do
  {
    v107 = (char *)v19 + (v18 >> v17) * v16;
    if (v158 == 1)
    {
      if (a5 >= 1)
      {
        v108 = v101;
        v109 = v106;
        do
        {
          v110 = *v108;
          v108 += 2;
          v111 = (unsigned int *)&v107[v110];
          if (v102 < (unsigned int *)&v107[v110])
            v111 = v102;
          if (v111 < v19)
            v111 = v19;
          v112 = __ROL4__(bswap32(*v111), v14);
          HIDWORD(v114) = HIBYTE(v112);
          LODWORD(v114) = v112;
          v113 = v114 >> 24;
          v115 = BYTE2(v112) | (BYTE2(v112) << 8);
          v116 = BYTE1(v112) | (BYTE1(v112) << 8);
          v117 = v112 | v10 | ((v112 | v10) << 8);
          if (v113 <= v115)
            v118 = v115;
          else
            v118 = v113;
          if (v116 > v118)
            v118 = v116;
          a10.i64[0] = __PAIR64__(v117, v118);
          v119 = vzip1q_s32(a10, a10);
          v119.i32[2] = v118;
          v120.i64[0] = __PAIR64__(v115, v113);
          v120.i64[1] = __PAIR64__(v118, v116);
          a10 = vsubq_s32(v119, v120);
          if (v13 != 0xFFFF)
          {
            v121 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x10uLL), (int32x4_t)vmvnq_s8(v121)), 0x10uLL));
            v117 -= (v117 * v103 + ((v117 * v103) >> 16) + 1) >> 16;
          }
          *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12)
            *v12 = bswap32(v117) >> 16;
          ++v11;
          v12 = (_WORD *)((char *)v12 + result);
          --v109;
        }
        while (v109);
      }
    }
    else
    {
      v122 = v101;
      v123 = v106;
      if (a5 >= 1)
      {
        do
        {
          v124 = *v122;
          v122 += 2;
          v125 = (unsigned int *)&v107[v124];
          if (v102 < (unsigned int *)&v107[v124])
            v125 = v102;
          if (v125 < v19)
            v125 = v19;
          v126 = __ROL4__(bswap32(*v125), v14);
          HIDWORD(v128) = HIBYTE(v126);
          LODWORD(v128) = v126;
          v127 = v128 >> 24;
          v129 = BYTE2(v126) | (BYTE2(v126) << 8);
          v130 = BYTE1(v126) | (BYTE1(v126) << 8);
          v131 = v126 | v10 | ((v126 | v10) << 8);
          if (v127 <= v129)
            v132 = v129;
          else
            v132 = v127;
          if (v130 > v132)
            v132 = v130;
          a10.i64[0] = __PAIR64__(v131, v132);
          v133 = vzip1q_s32(a10, a10);
          v133.i32[2] = v132;
          v134.i64[0] = __PAIR64__(v129, v127);
          v134.i64[1] = __PAIR64__(v132, v130);
          a10 = vsubq_s32(v133, v134);
          if (v13 != 0xFFFF)
          {
            v135 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v135, 0x10uLL), (int32x4_t)vmvnq_s8(v135)), 0x10uLL));
            v131 -= (v131 * v103 + ((v131 * v103) >> 16) + 1) >> 16;
          }
          v136 = a10.u32[1];
          v137 = a10.u16[0] | (a10.u16[2] << 16);
          v138 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v137;
          if (v12)
          {
            if ((_WORD)v131)
            {
              if ((unsigned __int16)v131 == 0xFFFF)
              {
                *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
                *v12 = -1;
              }
              else
              {
                v139 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
                v140 = bswap32((unsigned __int16)*v12);
                v141.i32[0] = (unsigned __int16)v139;
                v141.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v139), 0x10uLL).i32[1];
                a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_185004DA0);
                v141.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
                v142 = (uint32x4_t)vmulq_s32(v141, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
                *v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v142, v142, 0x10uLL), v105), 0x10uLL)));
                *v12 = bswap32(v131+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)) >> 16)+ 1) >> 16)) >> 16;
              }
            }
          }
          else if ((_WORD)v131)
          {
            if ((unsigned __int16)v131 == 0xFFFF)
            {
              *(int16x4_t *)a10.i8 = vmovn_s32(a10);
            }
            else
            {
              v143 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
              v144.i32[0] = (unsigned __int16)v143;
              v144.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v143), 0x10uLL).i32[1];
              a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_185004DA0);
              v144.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
              v145 = (uint32x4_t)vmulq_s32(v144, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
              *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v145, v145, 0x10uLL), v105), 0x10uLL));
            }
            *v11 = vrev16_s8(*(int8x8_t *)a10.i8);
          }
          ++v11;
          v12 = (_WORD *)((char *)v12 + result);
          --v123;
        }
        while (v123);
      }
    }
    v16 = v156;
    v11 += v157;
    LOBYTE(v17) = v155;
    v18 += v154;
    v12 += v159;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t CMYK64_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9, int32x4_t a10)
{
  int v10;
  int8x8_t *v11;
  _WORD *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  char *v20;
  uint64_t v21;
  uint64_t result;
  unsigned int *v23;
  int v24;
  int32x4_t v25;
  int32x4_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  unsigned int *v36;
  unsigned int v37;
  char v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int *v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int *v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unint64_t v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned __int32 v57;
  int32x4_t v58;
  int32x4_t v59;
  int8x16_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  unsigned int *v66;
  unsigned int v67;
  char v68;
  unsigned int *v69;
  unsigned int v70;
  char *v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int *v74;
  int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int *v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  unint64_t v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  unsigned __int32 v87;
  int32x4_t v88;
  int32x4_t v89;
  int8x16_t v90;
  unsigned __int32 v91;
  uint64_t v92;
  unint64_t v93;
  unsigned int v94;
  unsigned int v95;
  int32x4_t v96;
  uint32x4_t v97;
  unsigned int v98;
  int32x4_t v99;
  uint32x4_t v100;
  uint64_t *v101;
  char *v102;
  int v103;
  int32x4_t v104;
  int32x4_t v105;
  uint64_t v106;
  char *v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int *v111;
  unsigned int v112;
  unsigned int v113;
  unint64_t v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  unsigned __int32 v118;
  int32x4_t v119;
  int32x4_t v120;
  int8x16_t v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  unsigned int *v125;
  unsigned int v126;
  unsigned int v127;
  unint64_t v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  unsigned __int32 v132;
  int32x4_t v133;
  int32x4_t v134;
  int8x16_t v135;
  unsigned __int32 v136;
  uint64_t v137;
  unint64_t v138;
  unsigned int v139;
  unsigned int v140;
  int32x4_t v141;
  uint32x4_t v142;
  unsigned int v143;
  int32x4_t v144;
  uint32x4_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  char v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v154;
  char v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  uint64_t v159;

  if (*(_QWORD *)(a1 + 40))
    v10 = 0;
  else
    v10 = 255;
  v11 = (int8x8_t *)*((_QWORD *)a2 + 2);
  v12 = (_WORD *)*((_QWORD *)a2 + 4);
  if (v12)
    v159 = *((_QWORD *)a2 + 5) - a5;
  else
    v159 = 0;
  v13 = *((unsigned __int16 *)a2 + 4);
  v14 = a2[1];
  v158 = *a2;
  v157 = *((_QWORD *)a2 + 3) - a5;
  v16 = *((_QWORD *)a2 + 17);
  v15 = *((_QWORD *)a2 + 18);
  v17 = *((_QWORD *)a2 + 9);
  v154 = *((_QWORD *)a2 + 11);
  v18 = *((_QWORD *)a2 + 7) + v154 * a4;
  v19 = *(unsigned int **)(a1 + 32);
  v20 = (char *)v19
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  v21 = *(_QWORD *)(a1 + 176);
  result = 2 * (v12 != 0);
  v155 = v17;
  v156 = v16;
  if (v21)
  {
    v151 = *((_QWORD *)a2 + 15);
    v152 = *((_QWORD *)a2 + 13);
    v150 = ~(-1 << v17);
    v148 = -v16;
    v149 = v17 - 4;
    v23 = (unsigned int *)(v20 - 4);
    v24 = v13 ^ 0xFFFF;
    v25 = vdupq_n_s32(v13 ^ 0xFFFFu);
    v146 = v15 + 16 * a3 + 8;
    v147 = a5;
    v26.i64[0] = 0x100000001;
    v26.i64[1] = 0x100000001;
    while (1)
    {
      if (((v151 - v18) | (v18 - v152)) < 0)
      {
        v29 = 0;
        v28 = 0;
      }
      else
      {
        v27 = ((v18 & (unint64_t)v150) >> v149) & 0xF;
        v28 = (unint64_t)(v27 - 7) >= 9 ? v148 : v16;
        v29 = weights_19497[v27] & 0xF;
      }
      v30 = (char *)v19 + (v18 >> v17) * v16;
      if (v158 != 1)
        break;
      if (a5 >= 1)
      {
        v31 = (uint64_t *)v146;
        v32 = v147;
        while (1)
        {
          v33 = *(v31 - 1);
          v34 = *v31;
          v35 = &v30[v33];
          if (v23 >= (unsigned int *)&v30[v33])
            v36 = (unsigned int *)&v30[v33];
          else
            v36 = v23;
          if (v36 < v19)
            v36 = v19;
          v37 = *v36;
          v38 = v34 & 0xF;
          if ((v34 & 0xF) != 0)
            break;
          if (v29)
          {
            v49 = (unsigned int *)&v35[v28];
            if (v23 < (unsigned int *)&v35[v28])
              v49 = v23;
            if (v49 < v19)
              v49 = v19;
            v50 = BLEND8_19499[v29];
            v47 = v37 - ((v50 & v37) >> v29);
            v48 = (v50 & *v49) >> v29;
            goto LABEL_46;
          }
LABEL_47:
          v51 = __ROL4__(v37, v14);
          HIDWORD(v53) = HIBYTE(v51);
          LODWORD(v53) = v51;
          v52 = v53 >> 24;
          v54 = BYTE2(v51) | (BYTE2(v51) << 8);
          v55 = BYTE1(v51) | (BYTE1(v51) << 8);
          v56 = v51 | v10 | ((v51 | v10) << 8);
          if (v52 <= v54)
            v57 = v54;
          else
            v57 = v52;
          if (v55 > v57)
            v57 = v55;
          a10.i64[0] = __PAIR64__(v56, v57);
          v58 = vzip1q_s32(a10, a10);
          v58.i32[2] = v57;
          v59.i64[0] = __PAIR64__(v54, v52);
          v59.i64[1] = __PAIR64__(v57, v55);
          a10 = vsubq_s32(v58, v59);
          if (v13 != 0xFFFF)
          {
            v60 = (int8x16_t)vmulq_s32(a10, v25);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v60, 0x10uLL), (int32x4_t)vmvnq_s8(v60)), 0x10uLL));
            v56 -= (v56 * v24 + ((v56 * v24) >> 16) + 1) >> 16;
          }
          *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12)
            *v12 = bswap32(v56) >> 16;
          v31 += 2;
          ++v11;
          v12 = (_WORD *)((char *)v12 + result);
          if (!--v32)
            goto LABEL_107;
        }
        v39 = (unsigned int *)&v35[v34 >> 4];
        if (v23 < v39)
          v39 = v23;
        if (v39 < v19)
          v39 = v19;
        v40 = *v39;
        if (v29)
        {
          v41 = (unsigned int *)&v35[v28];
          if (v23 >= v41)
            v42 = v41;
          else
            v42 = v23;
          if (v42 < v19)
            v42 = v19;
          v43 = *v42;
          v44 = (unsigned int *)((char *)v41 + (v34 >> 4));
          if (v23 < v44)
            v44 = v23;
          if (v44 < v19)
            v44 = v19;
          v45 = BLEND8_19499[v29];
          v37 = v37 - ((v45 & v37) >> v29) + ((v45 & v43) >> v29);
          v40 = v40 - ((v45 & v40) >> v29) + ((v45 & *v44) >> v29);
        }
        v46 = BLEND8_19499[*v31 & 0xF];
        v47 = v37 - ((v46 & v37) >> v38);
        v48 = (v46 & v40) >> v38;
LABEL_46:
        v37 = v47 + v48;
        goto LABEL_47;
      }
LABEL_107:
      v16 = v156;
      v11 += v157;
      LOBYTE(v17) = v155;
      v18 += v154;
      v12 += v159;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_107;
    v62 = (uint64_t *)v146;
    v61 = v147;
    while (1)
    {
      v63 = *(v62 - 1);
      v64 = *v62;
      v65 = &v30[v63];
      if (v23 >= (unsigned int *)&v30[v63])
        v66 = (unsigned int *)&v30[v63];
      else
        v66 = v23;
      if (v66 < v19)
        v66 = v19;
      v67 = *v66;
      v68 = v64 & 0xF;
      if ((v64 & 0xF) != 0)
        break;
      if (v29)
      {
        v79 = (unsigned int *)&v65[v28];
        if (v23 < (unsigned int *)&v65[v28])
          v79 = v23;
        if (v79 < v19)
          v79 = v19;
        v80 = BLEND8_19499[v29];
        v77 = v67 - ((v80 & v67) >> v29);
        v78 = (v80 & *v79) >> v29;
        goto LABEL_88;
      }
LABEL_89:
      v81 = __ROL4__(v67, v14);
      HIDWORD(v83) = HIBYTE(v81);
      LODWORD(v83) = v81;
      v82 = v83 >> 24;
      v84 = BYTE2(v81) | (BYTE2(v81) << 8);
      v85 = BYTE1(v81) | (BYTE1(v81) << 8);
      v86 = v81 | v10 | ((v81 | v10) << 8);
      if (v82 <= v84)
        v87 = v84;
      else
        v87 = v82;
      if (v85 > v87)
        v87 = v85;
      a10.i64[0] = __PAIR64__(v86, v87);
      v88 = vzip1q_s32(a10, a10);
      v88.i32[2] = v87;
      v89.i64[0] = __PAIR64__(v84, v82);
      v89.i64[1] = __PAIR64__(v87, v85);
      a10 = vsubq_s32(v88, v89);
      if (v13 != 0xFFFF)
      {
        v90 = (int8x16_t)vmulq_s32(a10, v25);
        a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x10uLL), (int32x4_t)vmvnq_s8(v90)), 0x10uLL));
        v86 -= (v86 * v24 + ((v86 * v24) >> 16) + 1) >> 16;
      }
      v91 = a10.u32[1];
      v92 = a10.u16[0] | (a10.u16[2] << 16);
      v93 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v92;
      if (v12)
      {
        if ((_WORD)v86)
        {
          if ((unsigned __int16)v86 == 0xFFFF)
          {
            *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
            *v12 = -1;
          }
          else
          {
            v94 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
            v95 = bswap32((unsigned __int16)*v12);
            v96.i32[0] = (unsigned __int16)v94;
            v96.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v94), 0x10uLL).i32[1];
            a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_185004DA0);
            v96.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
            v97 = (uint32x4_t)vmulq_s32(v96, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
            *v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v97, v97, 0x10uLL), v26), 0x10uLL)));
            *v12 = bswap32(v86+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)) >> 16)+ 1) >> 16)) >> 16;
          }
        }
      }
      else if ((_WORD)v86)
      {
        if ((unsigned __int16)v86 == 0xFFFF)
        {
          *(int16x4_t *)a10.i8 = vmovn_s32(a10);
        }
        else
        {
          v98 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
          v99.i32[0] = (unsigned __int16)v98;
          v99.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v98), 0x10uLL).i32[1];
          a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_185004DA0);
          v99.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
          v100 = (uint32x4_t)vmulq_s32(v99, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
          *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v100, v100, 0x10uLL), v26), 0x10uLL));
        }
        *v11 = vrev16_s8(*(int8x8_t *)a10.i8);
      }
      v62 += 2;
      ++v11;
      v12 = (_WORD *)((char *)v12 + result);
      if (!--v61)
        goto LABEL_107;
    }
    v69 = (unsigned int *)&v65[v64 >> 4];
    if (v23 < v69)
      v69 = v23;
    if (v69 < v19)
      v69 = v19;
    v70 = *v69;
    if (v29)
    {
      v71 = &v65[v28];
      if (v23 >= (unsigned int *)&v65[v28])
        v72 = (unsigned int *)&v65[v28];
      else
        v72 = v23;
      if (v72 < v19)
        v72 = v19;
      v73 = *v72;
      v74 = (unsigned int *)&v71[v64 >> 4];
      if (v23 < v74)
        v74 = v23;
      if (v74 < v19)
        v74 = v19;
      v75 = BLEND8_19499[v29];
      v67 = v67 - ((v75 & v67) >> v29) + ((v75 & v73) >> v29);
      v70 = v70 - ((v75 & v70) >> v29) + ((v75 & *v74) >> v29);
    }
    v76 = BLEND8_19499[*v62 & 0xF];
    v77 = v67 - ((v76 & v67) >> v68);
    v78 = (v76 & v70) >> v68;
LABEL_88:
    v67 = v77 + v78;
    goto LABEL_89;
  }
  v101 = (uint64_t *)(v15 + 16 * a3);
  v102 = v20 - 4;
  v103 = v13 ^ 0xFFFF;
  v104 = vdupq_n_s32(v13 ^ 0xFFFFu);
  v105.i64[0] = 0x100000001;
  v105.i64[1] = 0x100000001;
  v106 = a5;
  do
  {
    v107 = (char *)v19 + (v18 >> v17) * v16;
    if (v158 == 1)
    {
      if (a5 >= 1)
      {
        v108 = v101;
        v109 = v106;
        do
        {
          v110 = *v108;
          v108 += 2;
          v111 = (unsigned int *)&v107[v110];
          if (v102 < &v107[v110])
            v111 = (unsigned int *)v102;
          if (v111 < v19)
            v111 = v19;
          v112 = __ROL4__(*v111, v14);
          HIDWORD(v114) = HIBYTE(v112);
          LODWORD(v114) = v112;
          v113 = v114 >> 24;
          v115 = BYTE2(v112) | (BYTE2(v112) << 8);
          v116 = BYTE1(v112) | (BYTE1(v112) << 8);
          v117 = v112 | v10 | ((v112 | v10) << 8);
          if (v113 <= v115)
            v118 = v115;
          else
            v118 = v113;
          if (v116 > v118)
            v118 = v116;
          a10.i64[0] = __PAIR64__(v117, v118);
          v119 = vzip1q_s32(a10, a10);
          v119.i32[2] = v118;
          v120.i64[0] = __PAIR64__(v115, v113);
          v120.i64[1] = __PAIR64__(v118, v116);
          a10 = vsubq_s32(v119, v120);
          if (v13 != 0xFFFF)
          {
            v121 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x10uLL), (int32x4_t)vmvnq_s8(v121)), 0x10uLL));
            v117 -= (v117 * v103 + ((v117 * v103) >> 16) + 1) >> 16;
          }
          *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12)
            *v12 = bswap32(v117) >> 16;
          ++v11;
          v12 = (_WORD *)((char *)v12 + result);
          --v109;
        }
        while (v109);
      }
    }
    else
    {
      v122 = v101;
      v123 = v106;
      if (a5 >= 1)
      {
        do
        {
          v124 = *v122;
          v122 += 2;
          v125 = (unsigned int *)&v107[v124];
          if (v102 < &v107[v124])
            v125 = (unsigned int *)v102;
          if (v125 < v19)
            v125 = v19;
          v126 = __ROL4__(*v125, v14);
          HIDWORD(v128) = HIBYTE(v126);
          LODWORD(v128) = v126;
          v127 = v128 >> 24;
          v129 = BYTE2(v126) | (BYTE2(v126) << 8);
          v130 = BYTE1(v126) | (BYTE1(v126) << 8);
          v131 = v126 | v10 | ((v126 | v10) << 8);
          if (v127 <= v129)
            v132 = v129;
          else
            v132 = v127;
          if (v130 > v132)
            v132 = v130;
          a10.i64[0] = __PAIR64__(v131, v132);
          v133 = vzip1q_s32(a10, a10);
          v133.i32[2] = v132;
          v134.i64[0] = __PAIR64__(v129, v127);
          v134.i64[1] = __PAIR64__(v132, v130);
          a10 = vsubq_s32(v133, v134);
          if (v13 != 0xFFFF)
          {
            v135 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v135, 0x10uLL), (int32x4_t)vmvnq_s8(v135)), 0x10uLL));
            v131 -= (v131 * v103 + ((v131 * v103) >> 16) + 1) >> 16;
          }
          v136 = a10.u32[1];
          v137 = a10.u16[0] | (a10.u16[2] << 16);
          v138 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v137;
          if (v12)
          {
            if ((_WORD)v131)
            {
              if ((unsigned __int16)v131 == 0xFFFF)
              {
                *v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
                *v12 = -1;
              }
              else
              {
                v139 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
                v140 = bswap32((unsigned __int16)*v12);
                v141.i32[0] = (unsigned __int16)v139;
                v141.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v139), 0x10uLL).i32[1];
                a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_185004DA0);
                v141.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
                v142 = (uint32x4_t)vmulq_s32(v141, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
                *v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v142, v142, 0x10uLL), v105), 0x10uLL)));
                *v12 = bswap32(v131+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)) >> 16)+ 1) >> 16)) >> 16;
              }
            }
          }
          else if ((_WORD)v131)
          {
            if ((unsigned __int16)v131 == 0xFFFF)
            {
              *(int16x4_t *)a10.i8 = vmovn_s32(a10);
            }
            else
            {
              v143 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
              v144.i32[0] = (unsigned __int16)v143;
              v144.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v143), 0x10uLL).i32[1];
              a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_185004DA0);
              v144.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
              v145 = (uint32x4_t)vmulq_s32(v144, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
              *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v145, v145, 0x10uLL), v105), 0x10uLL));
            }
            *v11 = vrev16_s8(*(int8x8_t *)a10.i8);
          }
          ++v11;
          v12 = (_WORD *)((char *)v12 + result);
          --v123;
        }
        while (v123);
      }
    }
    v16 = v156;
    v11 += v157;
    LOBYTE(v17) = v155;
    v18 += v154;
    v12 += v159;
    --a6;
  }
  while (a6);
  return result;
}

void CMYK64_mark_pixelshape(uint64_t a1, uint64_t a2, int8x8_t a3)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int *v12;
  int v13;
  int v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int8x8_t *v22;
  void *v23;
  void *v24;
  char *v25;
  _WORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  int8x8_t *v36;
  uint64_t v37;
  int v38;
  char *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  unsigned __int16 *v46;
  uint64_t v47;
  int8x8_t *v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  _WORD *v57;
  uint64_t v58;
  char *v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  int32x4_t v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unint64_t v70;
  _WORD *v71;
  unsigned int v72;
  unsigned int v73;
  int32x4_t v74;
  unsigned int v75;
  uint32x4_t v76;
  int32x2_t v77;
  unsigned __int16 *v78;
  uint64_t v79;
  unsigned __int16 *v80;
  BOOL v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  int v88;
  unsigned int v89;
  unint64_t v90;
  _WORD *v91;
  unsigned __int16 *v92;
  uint64_t v93;
  unint64_t v94;
  BOOL v95;
  uint64_t v96;
  int8x8_t *v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  unsigned int v106;
  unsigned int v107;
  _WORD *v108;
  unsigned int v109;
  unsigned __int16 *v110;
  uint64_t v111;
  unint64_t v112;
  BOOL v113;
  uint64_t v114;
  int8x8_t *v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  unsigned int v123;
  unint64_t v124;
  unsigned int v125;
  unsigned __int16 *v126;
  uint64_t v127;
  unint64_t v128;
  BOOL v129;
  uint64_t v130;
  int8x8_t *v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unsigned int v135;
  uint64_t v136;
  int32x4_t v137;
  int8x8_t *v138;
  int v139;
  unint64_t v140;
  unsigned int v141;
  unsigned int v142;
  _WORD *v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  unint64_t v147;
  unsigned int v148;
  int32x4_t v149;
  uint32x4_t v150;
  int32x2_t v151;
  unsigned __int16 *v152;
  uint64_t v153;
  unint64_t v154;
  BOOL v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  unsigned int v160;
  uint64_t v161;
  int v162;
  unsigned int v163;
  unint64_t v164;
  _WORD *v165;
  unsigned __int16 *v166;
  uint64_t v167;
  unint64_t v168;
  BOOL v169;
  uint64_t v170;
  int8x8_t *v171;
  unint64_t v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int v175;
  uint64_t v176;
  int v177;
  unsigned int v178;
  unint64_t v179;
  _WORD *v180;
  unsigned __int16 *v181;
  uint64_t v182;
  unint64_t v183;
  BOOL v184;
  uint64_t v185;
  int8x8_t *v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unsigned int v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  int v194;
  char *v195;
  unsigned int v196;
  unsigned int v197;
  char *v198;
  unint64_t v199;
  uint64_t v200;
  unsigned __int16 *v201;
  uint64_t v202;
  unint64_t v203;
  BOOL v204;
  uint64_t v205;
  int8x8_t *v206;
  unint64_t v207;
  uint64_t v208;
  uint64_t v209;
  unsigned int v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  int v214;
  unsigned int v215;
  unsigned int v216;
  unint64_t v217;
  char *v218;
  char *v219;
  uint64_t v220;
  unsigned __int16 *v221;
  uint64_t v222;
  unint64_t v223;
  BOOL v224;
  uint64_t v225;
  int8x8_t *v226;
  unint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  unsigned int v231;
  uint64_t v232;
  int v233;
  unint64_t v234;
  _WORD *v235;
  unsigned int v236;
  unsigned __int16 *v237;
  uint64_t v238;
  unint64_t v239;
  BOOL v240;
  uint64_t v241;
  int8x8_t *v242;
  unint64_t v243;
  uint64_t v244;
  uint64_t v245;
  unsigned int v246;
  uint64_t v247;
  uint64_t v248;
  int v249;
  unint64_t v250;
  _WORD *v251;
  unsigned int v252;
  unsigned __int16 *v253;
  uint64_t v254;
  unint64_t v255;
  BOOL v256;
  uint64_t v257;
  int8x8_t *v258;
  unint64_t v259;
  uint64_t v260;
  uint64_t v261;
  unsigned int v262;
  uint64_t v263;
  uint64_t v264;
  int v265;
  unint64_t v266;
  _WORD *v267;
  unsigned int v268;
  char *v269;
  unint64_t v270;
  int v271;
  unsigned int v272;
  unsigned int v273;
  unsigned __int16 *v274;
  uint64_t v275;
  unint64_t v276;
  BOOL v277;
  uint64_t v278;
  int8x8_t *v279;
  unint64_t v280;
  uint64_t v281;
  uint64_t v282;
  unsigned int v283;
  uint64_t v284;
  uint64_t v285;
  int v286;
  unint64_t v287;
  _WORD *v288;
  unsigned int v289;
  char *v290;
  unint64_t v291;
  int v292;
  unsigned int v293;
  unsigned int v294;
  unsigned __int16 *v295;
  uint64_t v296;
  unint64_t v297;
  BOOL v298;
  uint64_t v299;
  int8x8_t *v300;
  unint64_t v301;
  uint64_t v302;
  uint64_t v303;
  unsigned int v304;
  uint64_t v305;
  uint64_t v306;
  int v307;
  unint64_t v308;
  _WORD *v309;
  unsigned int v310;
  char *v311;
  unint64_t v312;
  int v313;
  unsigned int v314;
  unsigned int v315;
  unsigned __int16 *v316;
  uint64_t v317;
  unint64_t v318;
  BOOL v319;
  uint64_t v320;
  int8x8_t *v321;
  unint64_t v322;
  uint64_t v323;
  uint64_t v324;
  unsigned int v325;
  uint64_t v326;
  uint64_t v327;
  int v328;
  unint64_t v329;
  _WORD *v330;
  unsigned int v331;
  char *v332;
  unint64_t v333;
  int v334;
  unsigned int v335;
  unsigned int v336;
  unsigned __int16 *v337;
  uint64_t v338;
  unint64_t v339;
  BOOL v340;
  uint64_t v341;
  int8x8_t *v342;
  unint64_t v343;
  uint64_t v344;
  uint64_t v345;
  unsigned int v346;
  uint64_t v347;
  uint64_t v348;
  int v349;
  unint64_t v350;
  _WORD *v351;
  unsigned int v352;
  char *v353;
  unint64_t v354;
  int v355;
  unsigned int v356;
  unsigned int v357;
  unsigned __int16 *v358;
  uint64_t v359;
  unint64_t v360;
  BOOL v361;
  uint64_t v362;
  int8x8_t *v363;
  unint64_t v364;
  uint64_t v365;
  uint64_t v366;
  unsigned int v367;
  uint64_t v368;
  uint64_t v369;
  int v370;
  unint64_t v371;
  _WORD *v372;
  unsigned int v373;
  char *v374;
  unint64_t v375;
  int v376;
  unsigned int v377;
  unsigned int v378;
  unsigned __int16 *v379;
  uint64_t v380;
  unint64_t v381;
  BOOL v382;
  uint64_t v383;
  int8x8_t *v384;
  unint64_t v385;
  uint64_t v386;
  uint64_t v387;
  unsigned int v388;
  uint64_t v389;
  uint64_t v390;
  int v391;
  unint64_t v392;
  _WORD *v393;
  unsigned int v394;
  char *v395;
  unint64_t v396;
  int v397;
  unsigned int v398;
  unsigned int v399;
  unsigned __int16 *v400;
  uint64_t v401;
  unint64_t v402;
  BOOL v403;
  uint64_t v404;
  int8x8_t *v405;
  unint64_t v406;
  uint64_t v407;
  uint64_t v408;
  unsigned int v409;
  uint64_t v410;
  uint64_t v411;
  int v412;
  unint64_t v413;
  _WORD *v414;
  unsigned int v415;
  char *v416;
  unint64_t v417;
  int v418;
  unsigned int v419;
  unsigned int v420;
  unsigned __int16 *v421;
  uint64_t v422;
  unint64_t v423;
  BOOL v424;
  uint64_t v425;
  int8x8_t *v426;
  unint64_t v427;
  uint64_t v428;
  uint64_t v429;
  unsigned int v430;
  uint64_t v431;
  uint64_t v432;
  int v433;
  unint64_t v434;
  _WORD *v435;
  unsigned int v436;
  char *v437;
  unint64_t v438;
  int v439;
  unsigned int v440;
  unsigned int v441;
  unsigned __int16 *v442;
  uint64_t v443;
  unint64_t v444;
  BOOL v445;
  uint64_t v446;
  int8x8_t *v447;
  unint64_t v448;
  uint64_t v449;
  uint64_t v450;
  unsigned int v451;
  uint64_t v452;
  uint64_t v453;
  int v454;
  unint64_t v455;
  _WORD *v456;
  unsigned int v457;
  char *v458;
  unint64_t v459;
  int v460;
  unsigned int v461;
  unsigned int v462;
  unsigned __int16 *v463;
  uint64_t v464;
  unint64_t v465;
  BOOL v466;
  uint64_t v467;
  int8x8_t *v468;
  unint64_t v469;
  uint64_t v470;
  uint64_t v471;
  unsigned int v472;
  uint64_t v473;
  uint64_t v474;
  int v475;
  unint64_t v476;
  _WORD *v477;
  unsigned int v478;
  char *v479;
  unint64_t v480;
  int v481;
  unsigned int v482;
  unsigned int v483;
  unsigned __int16 *v484;
  uint64_t v485;
  unint64_t v486;
  BOOL v487;
  uint64_t v488;
  int8x8_t *v489;
  unint64_t v490;
  uint64_t v491;
  uint64_t v492;
  unsigned int v493;
  uint64_t v494;
  uint64_t v495;
  int v496;
  unint64_t v497;
  _WORD *v498;
  unsigned int v499;
  char *v500;
  unint64_t v501;
  int v502;
  unsigned int v503;
  unsigned int v504;
  unsigned __int16 *v505;
  uint64_t v506;
  unint64_t v507;
  BOOL v508;
  uint64_t v509;
  int8x8_t *v510;
  unint64_t v511;
  uint64_t v512;
  uint64_t v513;
  unsigned int v514;
  uint64_t v515;
  uint64_t v516;
  int v517;
  unint64_t v518;
  _WORD *v519;
  unsigned int v520;
  char *v521;
  unint64_t v522;
  int v523;
  unsigned int v524;
  unsigned int v525;
  unsigned __int16 *v526;
  uint64_t v527;
  unint64_t v528;
  BOOL v529;
  uint64_t v530;
  int8x8_t *v531;
  unint64_t v532;
  uint64_t v533;
  uint64_t v534;
  unsigned int v535;
  uint64_t v536;
  uint64_t v537;
  int v538;
  unint64_t v539;
  _WORD *v540;
  unsigned int v541;
  char *v542;
  unint64_t v543;
  unsigned int v544;
  unsigned int v545;
  unsigned __int16 *v546;
  uint64_t v547;
  unint64_t v548;
  BOOL v549;
  uint64_t v550;
  int8x8_t *v551;
  unint64_t v552;
  uint64_t v553;
  uint64_t v554;
  unsigned int v555;
  uint64_t v556;
  uint64_t v557;
  int v558;
  unint64_t v559;
  _WORD *v560;
  unsigned int v561;
  char *v562;
  unint64_t v563;
  int v564;
  unsigned int v565;
  unsigned int v566;
  unsigned __int16 *v567;
  uint64_t v568;
  unint64_t v569;
  BOOL v570;
  uint64_t v571;
  int8x8_t *v572;
  unint64_t v573;
  uint64_t v574;
  unsigned int v575;
  int32x4_t v576;
  int v577;
  unsigned int v578;
  unint64_t v579;
  unsigned int v580;
  int32x4_t v581;
  uint32x4_t v582;
  int32x2_t v583;
  unsigned __int16 *v584;
  uint64_t v585;
  unsigned __int16 *v586;
  BOOL v587;
  uint64_t v588;
  unint64_t v589;
  uint64_t v590;
  unsigned int v591;
  uint64_t v592;
  int32x4_t v593;
  int v594;
  unsigned int v595;
  unsigned int v596;
  int32x4_t v597;
  uint32x4_t v598;
  unsigned __int16 *v599;
  uint64_t v600;
  unint64_t v601;
  BOOL v602;
  uint64_t v603;
  int8x8_t *v604;
  unint64_t v605;
  uint64_t v606;
  unsigned int v607;
  int32x4_t v608;
  int v609;
  unsigned int v610;
  unsigned int v611;
  int32x4_t v612;
  uint32x4_t v613;
  unsigned __int16 *v614;
  uint64_t v615;
  unint64_t v616;
  BOOL v617;
  uint64_t v618;
  int8x8_t *v619;
  unint64_t v620;
  uint64_t v621;
  unsigned int v622;
  int32x4_t v623;
  int v624;
  unsigned int v625;
  unsigned int v626;
  int32x4_t v627;
  uint32x4_t v628;
  unsigned __int16 *v629;
  uint64_t v630;
  unint64_t v631;
  BOOL v632;
  uint64_t v633;
  int8x8_t *v634;
  unint64_t v635;
  uint64_t v636;
  unsigned int v637;
  int v638;
  unint64_t v639;
  unsigned int v640;
  _WORD *v641;
  unsigned __int16 *v642;
  uint64_t v643;
  unint64_t v644;
  BOOL v645;
  uint64_t v646;
  int8x8_t *v647;
  unint64_t v648;
  uint64_t v649;
  _WORD *v650;
  uint64_t v651;
  int v652;
  uint64_t v653;
  unint64_t v654;
  int v655;
  int v656;
  unint64_t v657;
  uint64_t v658;
  unint64_t v659;
  unint64_t v660;
  uint64_t v661;
  unsigned int v662;
  uint64_t v663;
  int v664;
  unint64_t v665;
  _WORD *v666;
  unsigned __int16 *v667;
  uint64_t v668;
  unint64_t v669;
  BOOL v670;
  uint64_t v671;
  unint64_t v672;
  uint64_t v673;
  uint8x8_t v674;
  _WORD *v675;
  unsigned int v676;
  unsigned int v677;
  uint64_t v678;
  int v679;
  unsigned __int16 *v680;
  uint64_t v681;
  unsigned __int16 *v682;
  BOOL v683;
  uint64_t v684;
  unint64_t v685;
  uint64_t v686;
  unsigned int v687;
  int v688;
  unsigned __int16 *v689;
  uint64_t v690;
  unsigned __int16 *v691;
  BOOL v692;
  uint64_t v693;
  unint64_t v694;
  uint64_t v695;
  unsigned int v696;
  int v697;
  unsigned __int16 *v698;
  uint64_t v699;
  unsigned __int16 *v700;
  BOOL v701;
  uint64_t v702;
  unint64_t v703;
  uint64_t v704;
  uint64_t v705;
  char *v706;
  uint64_t v707;
  int v708;
  int v709;
  unsigned int v711;
  unint64_t v712;
  uint64_t v713;
  int v714;
  unint64_t v715;
  unint64_t v716;
  char *v717;
  uint64_t v718;
  int v719;
  int v720;
  void *v721;
  unsigned int v722;
  unsigned int v723;
  unsigned int v724;
  unsigned int v725;
  unsigned int v726;
  unsigned int v727;
  unsigned int v728;
  unsigned int v729;
  unsigned int v730;
  unsigned int v731;
  unsigned int v732;
  unsigned int v733;
  unsigned int v734;
  unsigned int v735;
  unsigned int v736;
  int v737;
  int v738;
  int v739;
  int v740;
  int v741;
  int v742;
  int v743;
  int v744;
  int v745;
  int v746;
  int v747;
  int v748;
  int v749;
  int v750;
  int v751;
  int v752;
  int v753;
  int v754;
  int v755;
  int v756;
  uint64_t v757;
  unint64_t v758;
  unint64_t v759;
  unint64_t v760;
  unint64_t v761;
  int8x8_t *v762;
  int8x8_t *v763;
  _WORD *v764;
  _WORD *v765;
  unsigned int v766;
  _WORD *v767;
  _WORD *v768;
  _WORD *v769;
  unsigned int v770;
  unsigned int v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  int v787;
  uint64_t v788;
  unsigned int v789;
  unint64_t v790;
  unsigned int v791;
  unsigned int v792;
  unsigned int v793;
  uint64_t v794;
  uint64_t v795;
  unint64_t v796;
  unint64_t v797;
  unint64_t v798;
  unint64_t v799;
  unint64_t v800;
  unint64_t v801;
  unint64_t v802;
  unint64_t v803;
  unint64_t v804;
  unint64_t v805;
  unint64_t v806;
  unint64_t v807;
  unint64_t v808;
  unint64_t v809;
  unint64_t v810;
  unsigned int v811;
  int v812;
  int8x8_t *v813;
  int8x8_t *v814;
  uint64_t v815;
  unsigned int v816;
  int v817[3];

  v4 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 4);
  v5 = *(int *)(a1 + 8);
  v6 = *(int *)(a1 + 12);
  v816 = *(_DWORD *)(a1 + 8);
  v817[0] = v3;
  v7 = *(_QWORD *)(a1 + 48);
  v8 = *(_QWORD *)(a1 + 96);
  v9 = *(int *)(a1 + 16);
  v10 = (unint64_t)*(int *)(a1 + 28) >> 3;
  if (v7)
  {
    v716 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v717 = (char *)(v7 + 2 * (v6 + v716 * v9));
    v11 = -1;
  }
  else
  {
    v716 = 0;
    v717 = 0;
    v11 = 0;
  }
  v718 = *(_QWORD *)(a1 + 88);
  v12 = *(int **)(a1 + 136);
  v715 = *(_QWORD *)(a1 + 40) + 8 * (v6 + v10 * v9);
  v14 = *(_DWORD *)(a1 + 56);
  v13 = *(_DWORD *)(a1 + 60);
  v15 = *(int *)(a1 + 76);
  if ((v4 & 0xFF00) == 0x100)
  {
    v760 = v15 >> 3;
    if (v8)
    {
      v761 = (unint64_t)*(int *)(a1 + 80) >> 1;
      v8 += 2 * (v14 + v761 * v13);
      v16 = -1;
    }
    else
    {
      v761 = 0;
      v16 = 0;
    }
    v718 += 8 * (v14 + v760 * v13);
    if (v760 == v10 && (uint64_t)(v715 - v718) >= 1)
    {
      if (v3 >= (uint64_t)((v715 - v718) >> 3))
      {
        v17 = a2;
        v18 = v3;
        v715 += 8 * (v3 - 1);
        v718 += 8 * (v3 - 1);
        v717 += 2 * (v11 & (v3 - 1));
        v32 = v16 & (v3 - 1);
        v21 = -1;
        v760 = (unint64_t)*(int *)(a1 + 28) >> 3;
        v8 += 2 * v32;
        goto LABEL_15;
      }
      v19 = v5 - 1;
      v20 = v10 * (v5 - 1);
      if (v715 <= v718 + 8 * v20 + 8 * (v3 - 1))
      {
        v17 = a2;
        v18 = v3;
        v715 += 8 * v20;
        v10 = -(uint64_t)v10;
        v33 = &v717[2 * v716 * v19];
        v716 = -(uint64_t)v716;
        v717 = v33;
        v8 += 2 * v761 * v19;
        v11 &= 1u;
        v761 = -(uint64_t)v761;
        v16 &= 1u;
        v21 = 1;
        v718 += 8 * v20;
        v760 = v10;
        goto LABEL_15;
      }
    }
    v17 = a2;
    v18 = v3;
    v11 &= 1u;
    v16 &= 1u;
    v21 = 1;
LABEL_15:
    v22 = 0;
    v758 = 0;
    v788 = -1;
    v719 = v761;
    v720 = v760;
    goto LABEL_18;
  }
  v720 = *(_DWORD *)(a1 + 64);
  v719 = *(_DWORD *)(a1 + 68);
  v760 = v15 >> 3;
  v17 = a2;
  v18 = v3;
  if (v8)
  {
    v761 = (unint64_t)*(int *)(a1 + 80) >> 1;
    v16 = 1;
  }
  else
  {
    v761 = 0;
    v16 = 0;
  }
  v758 = v718 + 8 * v760 * v719;
  v11 &= 1u;
  v21 = 1;
  v22 = *(int8x8_t **)(a1 + 88);
  v788 = (uint64_t)v22;
LABEL_18:
  v787 = v11;
  v812 = v16;
  v711 = v17;
  v712 = v10;
  v713 = v8;
  v714 = v21;
  if (!v12)
  {
    v27 = v21 * v18;
    v759 = v716 - v11 * v18;
    if (v758)
    {
      v28 = v718 + 8 * v760 * (v13 % v719);
      v29 = v14 % v720;
      v22 = (int8x8_t *)(v28 + 8 * v29);
      v30 = v28 + 8 * v720;
      v31 = v8 + 2 * v761 * (v13 % v719) + 2 * v29;
      v721 = 0;
      if ((v16 & 1) != 0)
        v26 = (_WORD *)(v8 + 2 * v761 * (v13 % v719) + 2 * v29);
      else
        v26 = (_WORD *)v8;
      if ((v16 & 1) == 0)
        v31 = v8;
      v764 = (_WORD *)v31;
      v814 = (int8x8_t *)v715;
      v25 = v717;
      v813 = (int8x8_t *)(v28 + 8 * v29);
      v708 = v14 % v720;
      v709 = v13 % v719;
      goto LABEL_33;
    }
    v708 = *(_DWORD *)(a1 + 56);
    v709 = *(_DWORD *)(a1 + 60);
    v721 = 0;
    v760 -= v27;
    v761 -= v16 * v18;
    v814 = (int8x8_t *)v715;
    v25 = v717;
    v813 = (int8x8_t *)v718;
    v26 = (_WORD *)v8;
    v764 = (_WORD *)v8;
    goto LABEL_32;
  }
  v708 = *(_DWORD *)(a1 + 56);
  v709 = *(_DWORD *)(a1 + 60);
  shape_enum_clip_alloc(a1, a2, v12, v21, v10, 1, *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108), v18, v5);
  v24 = v23;
  v25 = v717;
  v759 = v716;
  v26 = (_WORD *)v8;
  v764 = (_WORD *)v8;
  if (v23)
  {
    while (2)
    {
      v650 = v26;
      if (!shape_enum_clip_next((uint64_t)v24, (int *)&v815 + 1, &v815, v817, &v816))
      {
        free(v24);
        return;
      }
      v721 = v24;
      if (v758)
      {
        v814 = (int8x8_t *)(v715 + 8 * v10 * (int)v815 + 8 * SHIDWORD(v815));
        v651 = ((int)v815 + *(_DWORD *)(a1 + 60)) % v719;
        v709 = ((int)v815 + *(_DWORD *)(a1 + 60)) % v719;
        v27 = v817[0];
        v18 = v817[0];
        v652 = (HIDWORD(v815) + *(_DWORD *)(a1 + 56)) % v720;
        v653 = v718 + 8 * v760 * v651;
        v813 = (int8x8_t *)(v653 + 8 * v652);
        v30 = v653 + 8 * v720;
        v11 = v787;
        v654 = v759;
        if (v787)
          v654 = v716 - v817[0];
        v759 = v654;
        if (v787)
          v25 = &v717[2 * v716 * (int)v815 + 2 * SHIDWORD(v815)];
        v16 = v812;
        if (v812)
        {
          v26 = (_WORD *)(v8 + 2 * v761 * v651 + 2 * v652);
          v22 = (int8x8_t *)(v653 + 8 * v652);
          v764 = v26;
          v708 = (HIDWORD(v815) + *(_DWORD *)(a1 + 56)) % v720;
        }
        else
        {
          v22 = (int8x8_t *)(v653 + 8 * v652);
          v708 = (HIDWORD(v815) + *(_DWORD *)(a1 + 56)) % v720;
          v26 = v650;
        }
        v34 = v17;
        v21 = v714;
      }
      else
      {
        v21 = v714;
        v655 = HIDWORD(v815) * v714;
        v18 = v817[0];
        v656 = v817[0] * v714;
        v814 = (int8x8_t *)(v715 + 8 * v10 * (int)v815 + 8 * HIDWORD(v815) * v714);
        v27 = v817[0] * v714;
        v813 = (int8x8_t *)(v718 + 8 * (int)v815 * v720 + 8 * HIDWORD(v815) * v714);
        v760 = v720 - v817[0] * v714;
        v11 = v787;
        v657 = v759;
        if (v787)
          v657 = v716 - v656;
        v759 = v657;
        if (v787)
          v25 = &v717[2 * v716 * (int)v815 + 2 * v655];
        v658 = v8 + 2 * (int)v815 * v719 + 2 * v655;
        v659 = v719 - v656;
        v16 = v812;
        v660 = v761;
        if (v812)
          v660 = v659;
        v761 = v660;
        if (v812)
          v26 = (_WORD *)v658;
        else
          v26 = v650;
LABEL_32:
        v30 = v788;
LABEL_33:
        v34 = v17;
      }
      v757 = v10 - v27;
      switch((int)v34)
      {
        case 0:
          v17 = v34;
          v765 = v26;
          v762 = v22;
          v788 = v30;
          v35 = v757 - v18;
          v36 = &v814[-v18 + 1];
          if (v21 >= 0)
          {
            v36 = v814;
            v35 = v757 + v18;
          }
          v37 = (int)v816;
          v38 = v21;
          v39 = (char *)&v36[(v35 * ((int)v816 - 1)) & (v35 >> 63)];
          if (v35 < 0)
            v35 = -v35;
          CGBlt_fillBytes(8 * v18, v816, 0, v39, 8 * v35);
          if (v787)
          {
            v40 = v759 - v18;
            v41 = &v25[-2 * v18 + 2];
            if (v38 >= 0)
            {
              v40 = v759 + v18;
              v41 = v25;
            }
            v42 = (v40 * (v37 - 1)) & (v40 >> 63);
            if (v40 < 0)
              v40 = -v40;
            v759 = v40;
            v25 = &v41[2 * v42];
            CGBlt_fillBytes(2 * v18, v37, 0, v25, 2 * v40);
          }
          goto LABEL_45;
        case 1:
          v43 = *(unsigned __int8 *)(a1 + 1);
          if (v43 == 2)
          {
            if (v18 >= 4 && (8 * v720) <= 0x40)
            {
              a3.i32[0] = 8 * v720;
              v674 = (uint8x8_t)vcnt_s8(a3);
              v674.i16[0] = vaddlv_u8(v674);
              if (v674.i32[0] <= 1u)
              {
                v17 = v34;
                v675 = v26;
                v788 = v30;
                v676 = v816;
                CGSFillDRAM64(v814, 8 * (v18 + v757), 8 * v18, v816, v718, 8 * v760, 8 * v720, v719, 8 * v708, v709);
                if (v787)
                {
                  if (v812)
                    CGSFillDRAM64(v25, 2 * (v18 + v759), 2 * v18, v676, v8, 2 * v761, 2 * v720, v719, 2 * v708, v709);
                  else
                    CGBlt_fillBytes(2 * v18, v676, -1, v25, 2 * (v18 + v759));
                }
                v24 = v721;
                v26 = v675;
                goto LABEL_814;
              }
            }
LABEL_857:
            if (v11)
            {
              if (v16)
              {
                v677 = v816;
                v678 = 2 * v11;
                do
                {
                  v679 = v18;
                  do
                  {
                    *v814 = *v813;
                    *(_WORD *)v25 = *v26;
                    v680 = (unsigned __int16 *)&v813[v21];
                    if ((unint64_t)v680 >= v30)
                      v681 = -(uint64_t)v720;
                    else
                      v681 = 0;
                    v26 += v16 + v681;
                    v813 = (int8x8_t *)&v680[4 * v681];
                    v814 += v21;
                    v25 += v678;
                    --v679;
                  }
                  while (v679);
                  if (v758)
                  {
                    v682 = (unsigned __int16 *)&v22[v760];
                    v683 = (unint64_t)v682 >= v758;
                    if ((unint64_t)v682 >= v758)
                      v684 = -(uint64_t)(v760 * v719);
                    else
                      v684 = 0;
                    v22 = (int8x8_t *)&v682[4 * v684];
                    v685 = v30 + 8 * v684;
                    if (v683)
                      v686 = -(uint64_t)(v761 * v719);
                    else
                      v686 = 0;
                    v26 = &v764[v761 + v686];
                    v30 = v685 + 8 * v760;
                    v813 = v22;
                    v764 = v26;
                  }
                  else
                  {
                    v813 += v760;
                    v26 += v761;
                  }
                  v814 += v757;
                  v25 += 2 * v759;
                  --v677;
                }
                while (v677);
              }
              else
              {
                v696 = v816;
                do
                {
                  v697 = v18;
                  do
                  {
                    *v814 = *v813;
                    *(_WORD *)v25 = -1;
                    v698 = (unsigned __int16 *)&v813[v21];
                    if ((unint64_t)v698 >= v30)
                      v699 = -(uint64_t)v720;
                    else
                      v699 = 0;
                    v26 += v699;
                    v813 = (int8x8_t *)&v698[4 * v699];
                    v814 += v21;
                    v25 += 2 * v11;
                    --v697;
                  }
                  while (v697);
                  if (v758)
                  {
                    v700 = (unsigned __int16 *)&v22[v760];
                    v701 = (unint64_t)v700 >= v758;
                    if ((unint64_t)v700 >= v758)
                      v702 = -(uint64_t)(v760 * v719);
                    else
                      v702 = 0;
                    v22 = (int8x8_t *)&v700[4 * v702];
                    v703 = v30 + 8 * v702;
                    if (v701)
                      v704 = -(uint64_t)(v761 * v719);
                    else
                      v704 = 0;
                    v26 = &v764[v761 + v704];
                    v30 = v703 + 8 * v760;
                    v813 = v22;
                    v764 = v26;
                  }
                  else
                  {
                    v813 += v760;
                    v26 += v761;
                  }
                  v814 += v757;
                  v25 += 2 * v759;
                  --v696;
                }
                while (v696);
              }
            }
            else
            {
              v687 = v816;
              do
              {
                v688 = v18;
                do
                {
                  *v814 = *v813;
                  v689 = (unsigned __int16 *)&v813[v21];
                  if ((unint64_t)v689 >= v30)
                    v690 = -(uint64_t)v720;
                  else
                    v690 = 0;
                  v26 += v16 + v690;
                  v813 = (int8x8_t *)&v689[4 * v690];
                  v814 += v21;
                  --v688;
                }
                while (v688);
                if (v758)
                {
                  v691 = (unsigned __int16 *)&v22[v760];
                  v692 = (unint64_t)v691 >= v758;
                  if ((unint64_t)v691 >= v758)
                    v693 = -(uint64_t)(v760 * v719);
                  else
                    v693 = 0;
                  v22 = (int8x8_t *)&v691[4 * v693];
                  v694 = v30 + 8 * v693;
                  if (v692)
                    v695 = -(uint64_t)(v761 * v719);
                  else
                    v695 = 0;
                  v26 = &v764[v761 + v695];
                  v30 = v694 + 8 * v760;
                  v813 = v22;
                  v764 = v26;
                }
                else
                {
                  v813 += v760;
                  v26 += v761;
                }
                v814 += v757;
                v25 += 2 * v759;
                --v687;
              }
              while (v687);
            }
            v17 = v34;
            v788 = v30;
            v816 = 0;
            goto LABEL_910;
          }
          if (v43 != 1)
            goto LABEL_857;
          v17 = v34;
          v765 = v26;
          v762 = v22;
          v788 = v30;
          v44 = v760 - v18;
          v45 = v18 - 1;
          v46 = (unsigned __int16 *)&v813[-v18 + 1];
          v47 = v757 - v18;
          v48 = &v814[-v18 + 1];
          v49 = v21;
          if (v21 >= 0)
          {
            v44 = v760 + v18;
            v48 = v814;
            v46 = (unsigned __int16 *)v813;
            v47 = v757 + v18;
          }
          v50 = v816;
          v51 = (int)v816 - 1;
          if (v44 >= 0)
            v52 = v44;
          else
            v52 = -v44;
          v53 = (char *)&v46[4 * ((v44 * ((int)v816 - 1)) & (v44 >> 63))];
          if (v47 >= 0)
            LODWORD(v54) = v47;
          else
            v54 = -v47;
          v760 = v52;
          CGBlt_copyBytes(8 * v18, v816, v53, (char *)&v48[(v47 * v51) & (v47 >> 63)], 8 * v52, 8 * v54);
          if (v787)
          {
            v55 = 2 * v18;
            if (v812)
            {
              v56 = v761 - v18;
              v57 = &v765[-v45];
              v58 = v759 - v18;
              v59 = &v25[-2 * v45];
              if (v49 >= 0)
              {
                v56 = v761 + v18;
                v58 = v759 + v18;
                v59 = v25;
                v57 = v765;
              }
              if (v56 >= 0)
                v60 = v56;
              else
                v60 = -v56;
              v61 = (char *)&v57[(v56 * v51) & (v56 >> 63)];
              if (v58 >= 0)
                v62 = v58;
              else
                v62 = -v58;
              v761 = v60;
              v759 = v62;
              v25 = &v59[2 * ((v58 * v51) & (v58 >> 63))];
              CGBlt_copyBytes(v55, v50, v61, v25, 2 * v60, 2 * v62);
              v26 = v61;
            }
            else
            {
              v705 = v759 - v18;
              v706 = &v25[-2 * v45];
              if (v49 >= 0)
              {
                v705 = v759 + v18;
                v706 = v25;
              }
              if (v705 >= 0)
                v707 = v705;
              else
                v707 = -v705;
              v759 = v707;
              v25 = &v706[2 * ((v705 * v51) & (v705 >> 63))];
              CGBlt_fillBytes(v55, v50, -1, v25, 2 * v707);
              v26 = v765;
            }
            goto LABEL_812;
          }
          v10 = v712;
          v8 = v713;
LABEL_45:
          v24 = v721;
          v22 = v762;
          v26 = v765;
LABEL_814:
          if (!v24)
            return;
          v815 = 0;
          continue;
        case 2:
          v63 = v21;
          v64 = 8 * v21;
          if (v11)
          {
            v65 = v816;
            v66.i64[0] = 0x100000001;
            v66.i64[1] = 0x100000001;
            do
            {
              v67 = v18;
              do
              {
                v68 = (unsigned __int16)*v26;
                v69 = __rev16(v68);
                if (v69)
                {
                  if (v69 == 0xFFFF)
                  {
                    *v814 = *v813;
                  }
                  else
                  {
                    v70 = ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16);
                    v71 = v26;
                    v72 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                    v73 = bswap32(*(unsigned __int16 *)v25);
                    v74.i32[0] = (unsigned __int16)v72;
                    v74.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v72), 0x10uLL).i32[1];
                    v74.i32[2] = bswap32(v814->u16[2]) >> 16;
                    v74.i32[3] = bswap32(v814->u16[3]) >> 16;
                    v75 = (unsigned __int16)~(_WORD)v69 * HIWORD(v73)
                        + (((unsigned __int16)~(_WORD)v69 * HIWORD(v73)) >> 16)
                        + 1;
                    v26 = v71;
                    v76 = (uint32x4_t)vmulq_s32(v74, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v69)));
                    v77.i32[0] = v70;
                    v77.i32[1] = WORD1(v70);
                    *v814 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v77, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v70), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v76, v76, 0x10uLL), v66), 0x10uLL)));
                    v68 = bswap32(v69 + HIWORD(v75)) >> 16;
                  }
                  *(_WORD *)v25 = v68;
                }
                v78 = (unsigned __int16 *)&v813[v63];
                if ((unint64_t)v78 >= v30)
                  v79 = -(uint64_t)v720;
                else
                  v79 = 0;
                v26 += v16 + v79;
                v813 = (int8x8_t *)&v78[4 * v79];
                v814 = (int8x8_t *)((char *)v814 + v64);
                v25 += 2 * v11;
                --v67;
              }
              while (v67);
              if (v758)
              {
                v80 = (unsigned __int16 *)&v22[v760];
                v81 = (unint64_t)v80 >= v758;
                if ((unint64_t)v80 >= v758)
                  v82 = -(uint64_t)(v760 * v719);
                else
                  v82 = 0;
                v22 = (int8x8_t *)&v80[4 * v82];
                v83 = v30 + 8 * v82;
                if (v81)
                  v84 = -(uint64_t)(v761 * v719);
                else
                  v84 = 0;
                v26 = &v764[v761 + v84];
                v30 = v83 + 8 * v760;
                v813 = v22;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v65;
            }
            while (v65);
          }
          else
          {
            v575 = v816;
            v576.i64[0] = 0x100000001;
            v576.i64[1] = 0x100000001;
            do
            {
              v577 = v18;
              do
              {
                v578 = bswap32((unsigned __int16)*v26) >> 16;
                if (v578)
                {
                  if (v578 == 0xFFFF)
                  {
                    *v814 = *v813;
                  }
                  else
                  {
                    v579 = ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16);
                    v580 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                    v581.i32[0] = (unsigned __int16)v580;
                    v581.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v580), 0x10uLL).i32[1];
                    v581.i64[1] = __PAIR64__(bswap32(v814->u16[3]) >> 16, bswap32(v814->u16[2]) >> 16);
                    v582 = (uint32x4_t)vmulq_s32(v581, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v578)));
                    v583.i32[0] = v579;
                    v583.i32[1] = WORD1(v579);
                    *v814 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v583, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v579), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v582, v582, 0x10uLL), v576), 0x10uLL)));
                  }
                }
                v584 = (unsigned __int16 *)&v813[v21];
                if ((unint64_t)v584 >= v30)
                  v585 = -(uint64_t)v720;
                else
                  v585 = 0;
                v813 = (int8x8_t *)&v584[4 * v585];
                v26 += v16 + v585;
                v814 = (int8x8_t *)((char *)v814 + v64);
                --v577;
              }
              while (v577);
              if (v758)
              {
                v586 = (unsigned __int16 *)&v22[v760];
                v587 = (unint64_t)v586 >= v758;
                if ((unint64_t)v586 >= v758)
                  v588 = -(uint64_t)(v760 * v719);
                else
                  v588 = 0;
                v22 = (int8x8_t *)&v586[4 * v588];
                v589 = v30 + 8 * v588;
                if (v587)
                  v590 = -(uint64_t)(v761 * v719);
                else
                  v590 = 0;
                v26 = &v764[v761 + v590];
                v30 = v589 + 8 * v760;
                v813 = v22;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v575;
            }
            while (v575);
          }
          v17 = v34;
          goto LABEL_729;
        case 3:
          v762 = v22;
          v85 = v21;
          if (!v16)
          {
            v591 = v816;
            v592 = 2 * v11;
            v593.i64[0] = 0x100000001;
            v593.i64[1] = 0x100000001;
            do
            {
              v594 = v18;
              do
              {
                v595 = bswap32(*(unsigned __int16 *)v25) >> 16;
                if (v595 == 0xFFFF)
                {
                  *v814 = *v813;
                }
                else if (v595)
                {
                  v596 = bswap32(v813->u16[1] | (v813->u16[0] << 16));
                  v597.i32[0] = (unsigned __int16)v596;
                  v597.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v596), 0x10uLL).i32[1];
                  v597.i64[1] = __PAIR64__(bswap32(v813->u16[3]) >> 16, bswap32(v813->u16[2]) >> 16);
                  v598 = (uint32x4_t)vmulq_s32(v597, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v595)));
                  v597.i32[0] = v596;
                  *v814 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v597, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v598, v598, 0x10uLL), v593), 0x10uLL))));
                }
                else
                {
                  *v814 = 0;
                }
                v599 = (unsigned __int16 *)&v813[v21];
                if ((unint64_t)v599 >= v30)
                  v600 = -(uint64_t)v720;
                else
                  v600 = 0;
                v813 = (int8x8_t *)&v599[4 * v600];
                v26 += v600;
                v814 += v21;
                v25 += v592;
                --v594;
              }
              while (v594);
              if (v758)
              {
                v601 = (unint64_t)&v762[v760];
                v602 = v601 >= v758;
                if (v601 >= v758)
                  v603 = -(uint64_t)(v760 * v719);
                else
                  v603 = 0;
                v604 = (int8x8_t *)(v601 + 8 * v603);
                v605 = v30 + 8 * v603;
                if (v602)
                  v606 = -(uint64_t)(v761 * v719);
                else
                  v606 = 0;
                v26 = &v764[v761 + v606];
                v30 = v605 + 8 * v760;
                v813 = v604;
                v762 = v604;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v591;
            }
            while (v591);
            goto LABEL_793;
          }
          v86 = v816;
          v87 = 2 * v11;
          do
          {
            v789 = v86;
            v88 = v18;
            do
            {
              v89 = bswap32(*(unsigned __int16 *)v25) >> 16;
              if (v89 == 0xFFFF)
              {
                *v814 = *v813;
                *(_WORD *)v25 = *v26;
              }
              else if (v89)
              {
                v90 = v30;
                v91 = v26;
                CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), bswap32((unsigned __int16)*v26) >> 16, v89);
                v26 = v91;
                v30 = v90;
              }
              else
              {
                *v814 = 0;
                *(_WORD *)v25 = 0;
              }
              v92 = (unsigned __int16 *)&v813[v85];
              if ((unint64_t)v92 >= v30)
                v93 = -(uint64_t)v720;
              else
                v93 = 0;
              v26 += v16 + v93;
              v813 = (int8x8_t *)&v92[4 * v93];
              v814 += v85;
              v25 += v87;
              --v88;
            }
            while (v88);
            if (v758)
            {
              v94 = (unint64_t)&v762[v760];
              v95 = v94 >= v758;
              v96 = -(uint64_t)(v760 * v719);
              if (v94 < v758)
                v96 = 0;
              v97 = (int8x8_t *)(v94 + 8 * v96);
              v98 = v30 + 8 * v96;
              v99 = -(uint64_t)(v761 * v719);
              if (!v95)
                v99 = 0;
              v26 = &v764[v761 + v99];
              v30 = v98 + 8 * v760;
              v813 = v97;
              v762 = v97;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v86 = v789 - 1;
          }
          while (v789 != 1);
          goto LABEL_811;
        case 4:
          v762 = v22;
          v100 = v21;
          v101 = v16;
          v102 = v816;
          v103 = 8 * v21;
          v104 = 2 * v11;
          do
          {
            v766 = v102;
            v105 = v18;
            v790 = v30;
            do
            {
              v106 = bswap32(~*(unsigned __int16 *)v25) >> 16;
              if (v106 == 0xFFFF)
              {
                if (v16)
                  v107 = bswap32((unsigned __int16)*v26) >> 16;
                else
                  v107 = 0xFFFF;
                *(_WORD *)v25 = __rev16(v107);
              }
              else if (v106)
              {
                v108 = v26;
                if (v16)
                  v109 = bswap32((unsigned __int16)*v26) >> 16;
                else
                  v109 = 0xFFFF;
                CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v109, v106);
                v30 = v790;
                v16 = v812;
                v26 = v108;
              }
              else
              {
                *v814 = 0;
                *(_WORD *)v25 = 0;
              }
              v110 = (unsigned __int16 *)&v813[v100];
              if ((unint64_t)v110 >= v30)
                v111 = -(uint64_t)v720;
              else
                v111 = 0;
              v26 += v101 + v111;
              v813 = (int8x8_t *)&v110[4 * v111];
              v814 = (int8x8_t *)((char *)v814 + v103);
              v25 += v104;
              --v105;
            }
            while (v105);
            if (v758)
            {
              v112 = (unint64_t)&v762[v760];
              v113 = v112 >= v758;
              v114 = -(uint64_t)(v760 * v719);
              if (v112 < v758)
                v114 = 0;
              v115 = (int8x8_t *)(v112 + 8 * v114);
              v116 = v30 + 8 * v114;
              v117 = -(uint64_t)(v761 * v719);
              if (!v113)
                v117 = 0;
              v26 = &v764[v761 + v117];
              v30 = v116 + 8 * v760;
              v813 = v115;
              v762 = v115;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v102 = v766 - 1;
          }
          while (v766 != 1);
          goto LABEL_811;
        case 5:
          v762 = v22;
          v118 = v21;
          v737 = v18;
          v119 = v816;
          v120 = 8 * v21;
          v121 = 2 * v11;
          do
          {
            v791 = v119;
            v122 = v737;
            do
            {
              v767 = v26;
              v123 = bswap32((unsigned __int16)*v26) >> 16;
              v124 = v30;
              v125 = bswap32(*(unsigned __int16 *)v25) >> 16;
              CMYK64_DAMplusDAM(v814, v25, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v123, v125, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v125, v123 ^ 0xFFFF);
              v30 = v124;
              v126 = (unsigned __int16 *)&v813[v118];
              if ((unint64_t)v126 >= v124)
                v127 = -(uint64_t)v720;
              else
                v127 = 0;
              v26 = &v767[v16 + v127];
              v813 = (int8x8_t *)&v126[4 * v127];
              v814 = (int8x8_t *)((char *)v814 + v120);
              v25 += v121;
              --v122;
            }
            while (v122);
            if (v758)
            {
              v128 = (unint64_t)&v762[v760];
              v129 = v128 >= v758;
              v130 = -(uint64_t)(v760 * v719);
              if (v128 < v758)
                v130 = 0;
              v131 = (int8x8_t *)(v128 + 8 * v130);
              v132 = v124 + 8 * v130;
              v133 = -(uint64_t)(v761 * v719);
              if (!v129)
                v133 = 0;
              v26 = &v764[v761 + v133];
              v30 = v132 + 8 * v760;
              v813 = v131;
              v762 = v131;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v119 = v791 - 1;
          }
          while (v791 != 1);
          goto LABEL_811;
        case 6:
          v17 = v34;
          v134 = v21;
          v135 = v816;
          v136 = 8 * v21;
          v137.i64[0] = 0x100000001;
          v137.i64[1] = 0x100000001;
          do
          {
            v138 = v22;
            v139 = v18;
            v140 = v30;
            do
            {
              v141 = bswap32(*(unsigned __int16 *)v25);
              if (HIWORD(v141) != 0xFFFF)
              {
                if ((unsigned __int16)~HIWORD(v141) == 0xFFFF)
                {
                  *v814 = *v813;
                  if (v16)
                    v142 = bswap32((unsigned __int16)*v26) >> 16;
                  else
                    v142 = 0xFFFF;
                }
                else
                {
                  v143 = v26;
                  if (v16)
                    v144 = bswap32((unsigned __int16)*v26) >> 16;
                  else
                    v144 = 0xFFFF;
                  v145 = HIWORD(v141);
                  v146 = ~HIWORD(v141);
                  v147 = ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16);
                  v148 = bswap32(v813->u16[1] | (v813->u16[0] << 16));
                  v149.i32[0] = (unsigned __int16)v148;
                  v149.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v148), 0x10uLL).i32[1];
                  v149.i32[2] = bswap32(v813->u16[2]) >> 16;
                  v149.i32[3] = bswap32(v813->u16[3]) >> 16;
                  v150 = (uint32x4_t)vmulq_s32(v149, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v146)));
                  v151.i32[0] = v147;
                  v151.i32[1] = WORD1(v147);
                  *v814 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v151, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v147), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v150, v150, 0x10uLL), v137), 0x10uLL)));
                  v142 = v145 + (((unsigned __int16)v146 * v144 + (((unsigned __int16)v146 * v144) >> 16) + 1) >> 16);
                  v30 = v140;
                  v26 = v143;
                }
                *(_WORD *)v25 = bswap32(v142) >> 16;
              }
              v152 = (unsigned __int16 *)&v813[v134];
              if ((unint64_t)v152 >= v30)
                v153 = -(uint64_t)v720;
              else
                v153 = 0;
              v26 += v16 + v153;
              v813 = (int8x8_t *)&v152[4 * v153];
              v814 = (int8x8_t *)((char *)v814 + v136);
              v25 += 2 * v11;
              --v139;
            }
            while (v139);
            if (v758)
            {
              v154 = (unint64_t)&v138[v760];
              v155 = v154 >= v758;
              if (v154 >= v758)
                v156 = -(uint64_t)(v760 * v719);
              else
                v156 = 0;
              v22 = (int8x8_t *)(v154 + 8 * v156);
              v157 = v30 + 8 * v156;
              if (v155)
                v158 = -(uint64_t)(v761 * v719);
              else
                v158 = 0;
              v26 = &v764[v761 + v158];
              v30 = v157 + 8 * v760;
              v813 = v22;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
              v22 = v138;
            }
            v814 += v757;
            v25 += 2 * v759;
            --v135;
          }
          while (v135);
LABEL_729:
          v788 = v30;
          v816 = 0;
          v24 = v721;
          v8 = v713;
          goto LABEL_814;
        case 7:
          v762 = v22;
          v159 = v21;
          if (v11)
          {
            v160 = v816;
            v161 = 2 * v11;
            do
            {
              v162 = v18;
              do
              {
                v163 = bswap32((unsigned __int16)*v26) >> 16;
                if (v163 != 0xFFFF)
                {
                  if (v163)
                  {
                    v164 = v30;
                    v165 = v26;
                    CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, v163);
                    v26 = v165;
                    v30 = v164;
                  }
                  else
                  {
                    *v814 = 0;
                    *(_WORD *)v25 = 0;
                  }
                }
                v166 = (unsigned __int16 *)&v813[v159];
                if ((unint64_t)v166 >= v30)
                  v167 = -(uint64_t)v720;
                else
                  v167 = 0;
                v26 += v16 + v167;
                v813 = (int8x8_t *)&v166[4 * v167];
                v814 += v159;
                v25 += v161;
                --v162;
              }
              while (v162);
              if (v758)
              {
                v168 = (unint64_t)&v762[v760];
                v169 = v168 >= v758;
                v170 = -(uint64_t)(v760 * v719);
                if (v168 < v758)
                  v170 = 0;
                v171 = (int8x8_t *)(v168 + 8 * v170);
                v172 = v30 + 8 * v170;
                v173 = -(uint64_t)(v761 * v719);
                if (!v169)
                  v173 = 0;
                v26 = &v764[v761 + v173];
                v30 = v172 + 8 * v760;
                v813 = v171;
                v762 = v171;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v160;
            }
            while (v160);
            goto LABEL_811;
          }
          v607 = v816;
          v608.i64[0] = 0x100000001;
          v608.i64[1] = 0x100000001;
          do
          {
            v609 = v18;
            do
            {
              v610 = bswap32((unsigned __int16)*v26) >> 16;
              if (v610 != 0xFFFF)
              {
                if (v610)
                {
                  v611 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                  v612.i32[0] = (unsigned __int16)v611;
                  v612.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v611), 0x10uLL).i32[1];
                  v612.i64[1] = __PAIR64__(bswap32(v814->u16[3]) >> 16, bswap32(v814->u16[2]) >> 16);
                  v613 = (uint32x4_t)vmulq_s32(v612, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v610)));
                  v612.i32[0] = v611;
                  *v814 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v612, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v613, v613, 0x10uLL), v608), 0x10uLL))));
                }
                else
                {
                  *v814 = 0;
                }
              }
              v614 = (unsigned __int16 *)&v813[v21];
              if ((unint64_t)v614 >= v30)
                v615 = -(uint64_t)v720;
              else
                v615 = 0;
              v813 = (int8x8_t *)&v614[4 * v615];
              v26 += v16 + v615;
              v814 += v21;
              --v609;
            }
            while (v609);
            if (v758)
            {
              v616 = (unint64_t)&v762[v760];
              v617 = v616 >= v758;
              if (v616 >= v758)
                v618 = -(uint64_t)(v760 * v719);
              else
                v618 = 0;
              v619 = (int8x8_t *)(v616 + 8 * v618);
              v620 = v30 + 8 * v618;
              if (v617)
                v621 = -(uint64_t)(v761 * v719);
              else
                v621 = 0;
              v26 = &v764[v761 + v621];
              v30 = v620 + 8 * v760;
              v813 = v619;
              v762 = v619;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            --v607;
          }
          while (v607);
          goto LABEL_793;
        case 8:
          v762 = v22;
          v174 = v21;
          if (v11)
          {
            v175 = v816;
            v176 = 2 * v11;
            do
            {
              v177 = v18;
              do
              {
                v178 = bswap32(~(unsigned __int16)*v26) >> 16;
                if (v178 != 0xFFFF)
                {
                  if (v178)
                  {
                    v179 = v30;
                    v180 = v26;
                    CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, v178);
                    v26 = v180;
                    v30 = v179;
                  }
                  else
                  {
                    *v814 = 0;
                    *(_WORD *)v25 = 0;
                  }
                }
                v181 = (unsigned __int16 *)&v813[v174];
                if ((unint64_t)v181 >= v30)
                  v182 = -(uint64_t)v720;
                else
                  v182 = 0;
                v26 += v16 + v182;
                v813 = (int8x8_t *)&v181[4 * v182];
                v814 += v174;
                v25 += v176;
                --v177;
              }
              while (v177);
              if (v758)
              {
                v183 = (unint64_t)&v762[v760];
                v184 = v183 >= v758;
                v185 = -(uint64_t)(v760 * v719);
                if (v183 < v758)
                  v185 = 0;
                v186 = (int8x8_t *)(v183 + 8 * v185);
                v187 = v30 + 8 * v185;
                v188 = -(uint64_t)(v761 * v719);
                if (!v184)
                  v188 = 0;
                v26 = &v764[v761 + v188];
                v30 = v187 + 8 * v760;
                v813 = v186;
                v762 = v186;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v175;
            }
            while (v175);
            goto LABEL_811;
          }
          v622 = v816;
          v623.i64[0] = 0x100000001;
          v623.i64[1] = 0x100000001;
          do
          {
            v624 = v18;
            do
            {
              v625 = bswap32(~(unsigned __int16)*v26) >> 16;
              if (v625 != 0xFFFF)
              {
                if (v625)
                {
                  v626 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                  v627.i32[0] = (unsigned __int16)v626;
                  v627.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v626), 0x10uLL).i32[1];
                  v627.i64[1] = __PAIR64__(bswap32(v814->u16[3]) >> 16, bswap32(v814->u16[2]) >> 16);
                  v628 = (uint32x4_t)vmulq_s32(v627, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v625)));
                  v627.i32[0] = v626;
                  *v814 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v627, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v628, v628, 0x10uLL), v623), 0x10uLL))));
                }
                else
                {
                  *v814 = 0;
                }
              }
              v629 = (unsigned __int16 *)&v813[v21];
              if ((unint64_t)v629 >= v30)
                v630 = -(uint64_t)v720;
              else
                v630 = 0;
              v813 = (int8x8_t *)&v629[4 * v630];
              v26 += v16 + v630;
              v814 += v21;
              --v624;
            }
            while (v624);
            if (v758)
            {
              v631 = (unint64_t)&v762[v760];
              v632 = v631 >= v758;
              if (v631 >= v758)
                v633 = -(uint64_t)(v760 * v719);
              else
                v633 = 0;
              v634 = (int8x8_t *)(v631 + 8 * v633);
              v635 = v30 + 8 * v633;
              if (v632)
                v636 = -(uint64_t)(v761 * v719);
              else
                v636 = 0;
              v26 = &v764[v761 + v636];
              v30 = v635 + 8 * v760;
              v813 = v634;
              v762 = v634;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            --v622;
          }
          while (v622);
LABEL_793:
          v17 = v34;
          v788 = v30;
          v816 = 0;
          goto LABEL_813;
        case 9:
          v762 = v22;
          v189 = v21;
          v738 = v18;
          v190 = v816;
          v191 = 8 * v21;
          v192 = 2 * v11;
          v193 = -(uint64_t)v720;
          do
          {
            v792 = v190;
            v194 = v738;
            do
            {
              v768 = v26;
              v195 = v25;
              v196 = bswap32(*(unsigned __int16 *)v25) >> 16;
              v197 = bswap32((unsigned __int16)*v26) >> 16;
              v198 = v25;
              v199 = v30;
              v200 = v193;
              CMYK64_DAMplusDAM(v814, v198, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v197, v196 ^ 0xFFFF, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v196, v197);
              v193 = v200;
              v30 = v199;
              v201 = (unsigned __int16 *)&v813[v189];
              if ((unint64_t)v201 >= v199)
                v202 = v200;
              else
                v202 = 0;
              v26 = &v768[v16 + v202];
              v813 = (int8x8_t *)&v201[4 * v202];
              v814 = (int8x8_t *)((char *)v814 + v191);
              v25 = &v195[v192];
              --v194;
            }
            while (v194);
            if (v758)
            {
              v203 = (unint64_t)&v762[v760];
              v204 = v203 >= v758;
              v205 = -(uint64_t)(v760 * v719);
              if (v203 < v758)
                v205 = 0;
              v206 = (int8x8_t *)(v203 + 8 * v205);
              v207 = v199 + 8 * v205;
              v208 = -(uint64_t)(v761 * v719);
              if (!v204)
                v208 = 0;
              v26 = &v764[v761 + v208];
              v30 = v207 + 8 * v760;
              v813 = v206;
              v762 = v206;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v190 = v792 - 1;
          }
          while (v792 != 1);
          goto LABEL_811;
        case 10:
          v762 = v22;
          v209 = v21;
          v739 = v18;
          v210 = v816;
          v211 = 8 * v21;
          v212 = 2 * v11;
          v213 = -(uint64_t)v720;
          do
          {
            v793 = v210;
            v214 = v739;
            do
            {
              v769 = v26;
              v215 = bswap32(*(unsigned __int16 *)v25) >> 16;
              v216 = bswap32((unsigned __int16)*v26) >> 16;
              v217 = v30;
              v218 = v25;
              v219 = v25;
              v220 = v213;
              CMYK64_DAMplusDAM(v814, v218, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v216, v215 ^ 0xFFFF, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v215, v216 ^ 0xFFFF);
              v213 = v220;
              v30 = v217;
              v221 = (unsigned __int16 *)&v813[v209];
              if ((unint64_t)v221 >= v217)
                v222 = v220;
              else
                v222 = 0;
              v26 = &v769[v16 + v222];
              v813 = (int8x8_t *)&v221[4 * v222];
              v814 = (int8x8_t *)((char *)v814 + v211);
              v25 = &v219[v212];
              --v214;
            }
            while (v214);
            if (v758)
            {
              v223 = (unint64_t)&v762[v760];
              v224 = v223 >= v758;
              v225 = -(uint64_t)(v760 * v719);
              if (v223 < v758)
                v225 = 0;
              v226 = (int8x8_t *)(v223 + 8 * v225);
              v227 = v217 + 8 * v225;
              v228 = -(uint64_t)(v761 * v719);
              if (!v224)
                v228 = 0;
              v26 = &v764[v761 + v228];
              v30 = v227 + 8 * v760;
              v813 = v226;
              v762 = v226;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v210 = v793 - 1;
          }
          while (v793 != 1);
          goto LABEL_811;
        case 11:
          v762 = v22;
          v740 = v18;
          v229 = v21;
          v794 = 8 * v21;
          v230 = v16;
          if (v11)
          {
            v231 = v816;
            v232 = 2 * v11;
            do
            {
              v770 = v231;
              v233 = v740;
              v234 = v30;
              do
              {
                v235 = v26;
                if (v16)
                  v236 = bswap32((unsigned __int16)*v26) >> 16;
                else
                  v236 = 0xFFFF;
                CMYK64_DAplusdDA((int *)v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v236);
                v237 = (unsigned __int16 *)&v813[v229];
                if ((unint64_t)v237 >= v234)
                  v238 = -(uint64_t)v720;
                else
                  v238 = 0;
                v26 = &v235[v230 + v238];
                v16 = v812;
                v813 = (int8x8_t *)&v237[4 * v238];
                v814 = (int8x8_t *)((char *)v814 + v794);
                v25 += v232;
                --v233;
              }
              while (v233);
              v30 = v234;
              if (v758)
              {
                v239 = (unint64_t)&v762[v760];
                v240 = v239 >= v758;
                v241 = -(uint64_t)(v760 * v719);
                if (v239 < v758)
                  v241 = 0;
                v242 = (int8x8_t *)(v239 + 8 * v241);
                v243 = v234 + 8 * v241;
                v244 = -(uint64_t)(v761 * v719);
                if (!v240)
                  v244 = 0;
                v26 = &v764[v761 + v244];
                v30 = v243 + 8 * v760;
                v813 = v242;
                v762 = v242;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              v231 = v770 - 1;
            }
            while (v770 != 1);
          }
          else
          {
            v637 = v816;
            do
            {
              v638 = v740;
              v639 = v30;
              do
              {
                if (v16)
                  v640 = bswap32((unsigned __int16)*v26) >> 16;
                else
                  v640 = 0xFFFF;
                v641 = v26;
                CMYK64_DplusdDA(v814, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v640);
                v642 = (unsigned __int16 *)&v813[v229];
                if ((unint64_t)v642 >= v639)
                  v643 = -(uint64_t)v720;
                else
                  v643 = 0;
                v26 = &v641[v230 + v643];
                v16 = v812;
                v813 = (int8x8_t *)&v642[4 * v643];
                v814 = (int8x8_t *)((char *)v814 + v794);
                --v638;
              }
              while (v638);
              v30 = v639;
              if (v758)
              {
                v644 = (unint64_t)&v762[v760];
                v645 = v644 >= v758;
                v646 = -(uint64_t)(v760 * v719);
                if (v644 < v758)
                  v646 = 0;
                v647 = (int8x8_t *)(v644 + 8 * v646);
                v648 = v639 + 8 * v646;
                v649 = -(uint64_t)(v761 * v719);
                if (!v645)
                  v649 = 0;
                v26 = &v764[v761 + v649];
                v30 = v648 + 8 * v760;
                v813 = v647;
                v762 = v647;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v637;
            }
            while (v637);
          }
          goto LABEL_811;
        case 12:
          v741 = v18;
          if (v11)
          {
            v762 = v22;
            v795 = v21;
            v245 = v16;
            v246 = v816;
            v247 = 8 * v21;
            v248 = 2 * v11;
            do
            {
              v771 = v246;
              v249 = v18;
              v250 = v30;
              do
              {
                v251 = v26;
                if (v16)
                  v252 = bswap32((unsigned __int16)*v26) >> 16;
                else
                  v252 = 0xFFFF;
                CMYK64_DApluslDA((unsigned int *)v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v252);
                v16 = v812;
                v253 = (unsigned __int16 *)&v813[v795];
                if ((unint64_t)v253 >= v250)
                  v254 = -(uint64_t)v720;
                else
                  v254 = 0;
                v26 = &v251[v245 + v254];
                v813 = (int8x8_t *)&v253[4 * v254];
                v814 = (int8x8_t *)((char *)v814 + v247);
                v25 += v248;
                --v249;
              }
              while (v249);
              v30 = v250;
              if (v758)
              {
                v255 = (unint64_t)&v762[v760];
                v256 = v255 >= v758;
                v257 = -(uint64_t)(v760 * v719);
                if (v255 < v758)
                  v257 = 0;
                v258 = (int8x8_t *)(v255 + 8 * v257);
                v259 = v250 + 8 * v257;
                v260 = -(uint64_t)(v761 * v719);
                if (!v256)
                  v260 = 0;
                v26 = &v764[v761 + v260];
                v30 = v259 + 8 * v760;
                v813 = v258;
                v762 = v258;
                v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              v246 = v771 - 1;
            }
            while (v771 != 1);
            goto LABEL_811;
          }
          v661 = v21;
          v662 = v816;
          v663 = 8 * v21;
          do
          {
            v811 = v662;
            v763 = v22;
            v664 = v741;
            do
            {
              v665 = v30;
              v666 = v26;
              CMYK64_DpluslD(v814, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16));
              v30 = v665;
              v667 = (unsigned __int16 *)&v813[v661];
              if ((unint64_t)v667 >= v665)
                v668 = -(uint64_t)v720;
              else
                v668 = 0;
              v26 = &v666[v16 + v668];
              v813 = (int8x8_t *)&v667[4 * v668];
              v814 = (int8x8_t *)((char *)v814 + v663);
              --v664;
            }
            while (v664);
            if (v758)
            {
              v669 = (unint64_t)&v763[v760];
              v670 = v669 >= v758;
              v671 = -(uint64_t)(v760 * v719);
              if (v669 < v758)
                v671 = 0;
              v22 = (int8x8_t *)(v669 + 8 * v671);
              v672 = v665 + 8 * v671;
              v673 = -(uint64_t)(v761 * v719);
              if (!v670)
                v673 = 0;
              v26 = &v764[v761 + v673];
              v30 = v672 + 8 * v760;
              v813 = v22;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v22 = v763;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v662 = v811 - 1;
          }
          while (v811 != 1);
          v788 = v30;
          v816 = 0;
          v17 = v711;
          v10 = v712;
          v8 = v713;
LABEL_910:
          v24 = v721;
          goto LABEL_814;
        case 13:
          v762 = v22;
          v742 = v18;
          v772 = v21;
          v261 = v16;
          v262 = v816;
          v263 = 8 * v21;
          v264 = 2 * v11;
          while (1)
          {
            v722 = v262;
            v265 = v742;
            v796 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_303;
                LODWORD(v266) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_296:
                  v267 = v26;
                  v268 = 0xFFFF;
                  goto LABEL_297;
                }
              }
              else
              {
                LODWORD(v266) = 0xFFFF;
                if (!v11)
                  goto LABEL_296;
              }
              if (*(_WORD *)v25)
              {
                v267 = v26;
                v268 = __rev16(*(unsigned __int16 *)v25);
LABEL_297:
                v269 = (char *)v814 + 6;
                v270 = PDAmultiplyPDA_10646(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v268, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v266);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v266) = v271;
                  v272 = bswap32(v270);
                  v814->i16[0] = HIWORD(v272);
                  v814->i16[1] = v272;
                  v814->i16[2] = bswap32(HIDWORD(v270)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v270));
                  v269 = v25;
                }
                else
                {
                  v266 = HIWORD(v270);
                  v273 = bswap32(v270);
                  v814->i16[0] = HIWORD(v273);
                  v814->i16[1] = v273;
                  v814->i16[2] = bswap32(HIDWORD(v270)) >> 16;
                }
                v30 = v796;
                v16 = v812;
                v26 = v267;
                goto LABEL_302;
              }
              *v814 = *v813;
              v269 = v25;
LABEL_302:
              *(_WORD *)v269 = bswap32(v266) >> 16;
LABEL_303:
              v25 += v264;
              v274 = (unsigned __int16 *)&v813[v772];
              if ((unint64_t)v274 >= v30)
                v275 = -(uint64_t)v720;
              else
                v275 = 0;
              v26 += v261 + v275;
              v813 = (int8x8_t *)&v274[4 * v275];
              v814 = (int8x8_t *)((char *)v814 + v263);
              --v265;
            }
            while (v265);
            if (v758)
            {
              v276 = (unint64_t)&v762[v760];
              v277 = v276 >= v758;
              v278 = -(uint64_t)(v760 * v719);
              if (v276 < v758)
                v278 = 0;
              v279 = (int8x8_t *)(v276 + 8 * v278);
              v280 = v30 + 8 * v278;
              v281 = -(uint64_t)(v761 * v719);
              if (!v277)
                v281 = 0;
              v26 = &v764[v761 + v281];
              v30 = v280 + 8 * v760;
              v813 = v279;
              v762 = v279;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v262 = v722 - 1;
            if (v722 == 1)
              goto LABEL_811;
          }
        case 14:
          v762 = v22;
          v743 = v18;
          v773 = v21;
          v282 = v16;
          v283 = v816;
          v284 = 8 * v21;
          v285 = 2 * v11;
          while (1)
          {
            v723 = v283;
            v286 = v743;
            v797 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_331;
                LODWORD(v287) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_324:
                  v288 = v26;
                  v289 = 0xFFFF;
                  goto LABEL_325;
                }
              }
              else
              {
                LODWORD(v287) = 0xFFFF;
                if (!v11)
                  goto LABEL_324;
              }
              if (*(_WORD *)v25)
              {
                v288 = v26;
                v289 = __rev16(*(unsigned __int16 *)v25);
LABEL_325:
                v290 = (char *)v814 + 6;
                v291 = PDAscreenPDA_10647(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v289, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v287);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v287) = v292;
                  v293 = bswap32(v291);
                  v814->i16[0] = HIWORD(v293);
                  v814->i16[1] = v293;
                  v814->i16[2] = bswap32(HIDWORD(v291)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v291));
                  v290 = v25;
                }
                else
                {
                  v294 = bswap32(v291);
                  v814->i16[0] = HIWORD(v294);
                  v814->i16[1] = v294;
                  v814->i16[2] = bswap32(HIDWORD(v291)) >> 16;
                  v287 = HIWORD(v291);
                }
                v30 = v797;
                v16 = v812;
                v26 = v288;
                goto LABEL_330;
              }
              *v814 = *v813;
              v290 = v25;
LABEL_330:
              *(_WORD *)v290 = bswap32(v287) >> 16;
LABEL_331:
              v25 += v285;
              v295 = (unsigned __int16 *)&v813[v773];
              if ((unint64_t)v295 >= v30)
                v296 = -(uint64_t)v720;
              else
                v296 = 0;
              v26 += v282 + v296;
              v813 = (int8x8_t *)&v295[4 * v296];
              v814 = (int8x8_t *)((char *)v814 + v284);
              --v286;
            }
            while (v286);
            if (v758)
            {
              v297 = (unint64_t)&v762[v760];
              v298 = v297 >= v758;
              v299 = -(uint64_t)(v760 * v719);
              if (v297 < v758)
                v299 = 0;
              v300 = (int8x8_t *)(v297 + 8 * v299);
              v301 = v30 + 8 * v299;
              v302 = -(uint64_t)(v761 * v719);
              if (!v298)
                v302 = 0;
              v26 = &v764[v761 + v302];
              v30 = v301 + 8 * v760;
              v813 = v300;
              v762 = v300;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v283 = v723 - 1;
            if (v723 == 1)
              goto LABEL_811;
          }
        case 15:
          v762 = v22;
          v744 = v18;
          v774 = v21;
          v303 = v16;
          v304 = v816;
          v305 = 8 * v21;
          v306 = 2 * v11;
          while (1)
          {
            v724 = v304;
            v307 = v744;
            v798 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_359;
                LODWORD(v308) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_352:
                  v309 = v26;
                  v310 = 0xFFFF;
                  goto LABEL_353;
                }
              }
              else
              {
                LODWORD(v308) = 0xFFFF;
                if (!v11)
                  goto LABEL_352;
              }
              if (*(_WORD *)v25)
              {
                v309 = v26;
                v310 = __rev16(*(unsigned __int16 *)v25);
LABEL_353:
                v311 = (char *)v814 + 6;
                v312 = PDAoverlayPDA_10648(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v310, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v308);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v308) = v313;
                  v314 = bswap32(v312);
                  v814->i16[0] = HIWORD(v314);
                  v814->i16[1] = v314;
                  v814->i16[2] = bswap32(HIDWORD(v312)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v312));
                  v311 = v25;
                }
                else
                {
                  v315 = bswap32(v312);
                  v814->i16[0] = HIWORD(v315);
                  v814->i16[1] = v315;
                  v814->i16[2] = bswap32(HIDWORD(v312)) >> 16;
                  v308 = HIWORD(v312);
                }
                v30 = v798;
                v16 = v812;
                v26 = v309;
                goto LABEL_358;
              }
              *v814 = *v813;
              v311 = v25;
LABEL_358:
              *(_WORD *)v311 = bswap32(v308) >> 16;
LABEL_359:
              v25 += v306;
              v316 = (unsigned __int16 *)&v813[v774];
              if ((unint64_t)v316 >= v30)
                v317 = -(uint64_t)v720;
              else
                v317 = 0;
              v26 += v303 + v317;
              v813 = (int8x8_t *)&v316[4 * v317];
              v814 = (int8x8_t *)((char *)v814 + v305);
              --v307;
            }
            while (v307);
            if (v758)
            {
              v318 = (unint64_t)&v762[v760];
              v319 = v318 >= v758;
              v320 = -(uint64_t)(v760 * v719);
              if (v318 < v758)
                v320 = 0;
              v321 = (int8x8_t *)(v318 + 8 * v320);
              v322 = v30 + 8 * v320;
              v323 = -(uint64_t)(v761 * v719);
              if (!v319)
                v323 = 0;
              v26 = &v764[v761 + v323];
              v30 = v322 + 8 * v760;
              v813 = v321;
              v762 = v321;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v304 = v724 - 1;
            if (v724 == 1)
              goto LABEL_811;
          }
        case 16:
          v762 = v22;
          v745 = v18;
          v775 = v21;
          v324 = v16;
          v325 = v816;
          v326 = 8 * v21;
          v327 = 2 * v11;
          while (1)
          {
            v725 = v325;
            v328 = v745;
            v799 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_387;
                LODWORD(v329) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_380:
                  v330 = v26;
                  v331 = 0xFFFF;
                  goto LABEL_381;
                }
              }
              else
              {
                LODWORD(v329) = 0xFFFF;
                if (!v11)
                  goto LABEL_380;
              }
              if (*(_WORD *)v25)
              {
                v330 = v26;
                v331 = __rev16(*(unsigned __int16 *)v25);
LABEL_381:
                v332 = (char *)v814 + 6;
                v333 = PDAdarkenPDA_10650(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v331, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v329);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v329) = v334;
                  v335 = bswap32(v333);
                  v814->i16[0] = HIWORD(v335);
                  v814->i16[1] = v335;
                  v814->i16[2] = bswap32(HIDWORD(v333)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v333));
                  v332 = v25;
                }
                else
                {
                  v336 = bswap32(v333);
                  v814->i16[0] = HIWORD(v336);
                  v814->i16[1] = v336;
                  v814->i16[2] = bswap32(HIDWORD(v333)) >> 16;
                  v329 = HIWORD(v333);
                }
                v30 = v799;
                v16 = v812;
                v26 = v330;
                goto LABEL_386;
              }
              *v814 = *v813;
              v332 = v25;
LABEL_386:
              *(_WORD *)v332 = bswap32(v329) >> 16;
LABEL_387:
              v25 += v327;
              v337 = (unsigned __int16 *)&v813[v775];
              if ((unint64_t)v337 >= v30)
                v338 = -(uint64_t)v720;
              else
                v338 = 0;
              v26 += v324 + v338;
              v813 = (int8x8_t *)&v337[4 * v338];
              v814 = (int8x8_t *)((char *)v814 + v326);
              --v328;
            }
            while (v328);
            if (v758)
            {
              v339 = (unint64_t)&v762[v760];
              v340 = v339 >= v758;
              v341 = -(uint64_t)(v760 * v719);
              if (v339 < v758)
                v341 = 0;
              v342 = (int8x8_t *)(v339 + 8 * v341);
              v343 = v30 + 8 * v341;
              v344 = -(uint64_t)(v761 * v719);
              if (!v340)
                v344 = 0;
              v26 = &v764[v761 + v344];
              v30 = v343 + 8 * v760;
              v813 = v342;
              v762 = v342;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v325 = v725 - 1;
            if (v725 == 1)
              goto LABEL_811;
          }
        case 17:
          v762 = v22;
          v746 = v18;
          v776 = v21;
          v345 = v16;
          v346 = v816;
          v347 = 8 * v21;
          v348 = 2 * v11;
          while (1)
          {
            v726 = v346;
            v349 = v746;
            v800 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_415;
                LODWORD(v350) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_408:
                  v351 = v26;
                  v352 = 0xFFFF;
                  goto LABEL_409;
                }
              }
              else
              {
                LODWORD(v350) = 0xFFFF;
                if (!v11)
                  goto LABEL_408;
              }
              if (*(_WORD *)v25)
              {
                v351 = v26;
                v352 = __rev16(*(unsigned __int16 *)v25);
LABEL_409:
                v353 = (char *)v814 + 6;
                v354 = PDAlightenPDA_10649(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v352, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v350);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v350) = v355;
                  v356 = bswap32(v354);
                  v814->i16[0] = HIWORD(v356);
                  v814->i16[1] = v356;
                  v814->i16[2] = bswap32(HIDWORD(v354)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v354));
                  v353 = v25;
                }
                else
                {
                  v350 = HIWORD(v354);
                  v357 = bswap32(v354);
                  v814->i16[0] = HIWORD(v357);
                  v814->i16[1] = v357;
                  v814->i16[2] = bswap32(HIDWORD(v354)) >> 16;
                }
                v30 = v800;
                v16 = v812;
                v26 = v351;
                goto LABEL_414;
              }
              *v814 = *v813;
              v353 = v25;
LABEL_414:
              *(_WORD *)v353 = bswap32(v350) >> 16;
LABEL_415:
              v25 += v348;
              v358 = (unsigned __int16 *)&v813[v776];
              if ((unint64_t)v358 >= v30)
                v359 = -(uint64_t)v720;
              else
                v359 = 0;
              v26 += v345 + v359;
              v813 = (int8x8_t *)&v358[4 * v359];
              v814 = (int8x8_t *)((char *)v814 + v347);
              --v349;
            }
            while (v349);
            if (v758)
            {
              v360 = (unint64_t)&v762[v760];
              v361 = v360 >= v758;
              v362 = -(uint64_t)(v760 * v719);
              if (v360 < v758)
                v362 = 0;
              v363 = (int8x8_t *)(v360 + 8 * v362);
              v364 = v30 + 8 * v362;
              v365 = -(uint64_t)(v761 * v719);
              if (!v361)
                v365 = 0;
              v26 = &v764[v761 + v365];
              v30 = v364 + 8 * v760;
              v813 = v363;
              v762 = v363;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v346 = v726 - 1;
            if (v726 == 1)
              goto LABEL_811;
          }
        case 18:
          v762 = v22;
          v747 = v18;
          v777 = v21;
          v366 = v16;
          v367 = v816;
          v368 = 8 * v21;
          v369 = 2 * v11;
          while (1)
          {
            v727 = v367;
            v370 = v747;
            v801 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_443;
                LODWORD(v371) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_436:
                  v372 = v26;
                  v373 = 0xFFFF;
                  goto LABEL_437;
                }
              }
              else
              {
                LODWORD(v371) = 0xFFFF;
                if (!v11)
                  goto LABEL_436;
              }
              if (*(_WORD *)v25)
              {
                v372 = v26;
                v373 = __rev16(*(unsigned __int16 *)v25);
LABEL_437:
                v374 = (char *)v814 + 6;
                v375 = PDAcolordodgePDA_10651(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v373, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v371);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v371) = v376;
                  v377 = bswap32(v375);
                  v814->i16[0] = HIWORD(v377);
                  v814->i16[1] = v377;
                  v814->i16[2] = bswap32(HIDWORD(v375)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v375));
                  v374 = v25;
                }
                else
                {
                  v371 = HIWORD(v375);
                  v378 = bswap32(v375);
                  v814->i16[0] = HIWORD(v378);
                  v814->i16[1] = v378;
                  v814->i16[2] = bswap32(HIDWORD(v375)) >> 16;
                }
                v30 = v801;
                v16 = v812;
                v26 = v372;
                goto LABEL_442;
              }
              *v814 = *v813;
              v374 = v25;
LABEL_442:
              *(_WORD *)v374 = bswap32(v371) >> 16;
LABEL_443:
              v25 += v369;
              v379 = (unsigned __int16 *)&v813[v777];
              if ((unint64_t)v379 >= v30)
                v380 = -(uint64_t)v720;
              else
                v380 = 0;
              v26 += v366 + v380;
              v813 = (int8x8_t *)&v379[4 * v380];
              v814 = (int8x8_t *)((char *)v814 + v368);
              --v370;
            }
            while (v370);
            if (v758)
            {
              v381 = (unint64_t)&v762[v760];
              v382 = v381 >= v758;
              v383 = -(uint64_t)(v760 * v719);
              if (v381 < v758)
                v383 = 0;
              v384 = (int8x8_t *)(v381 + 8 * v383);
              v385 = v30 + 8 * v383;
              v386 = -(uint64_t)(v761 * v719);
              if (!v382)
                v386 = 0;
              v26 = &v764[v761 + v386];
              v30 = v385 + 8 * v760;
              v813 = v384;
              v762 = v384;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v367 = v727 - 1;
            if (v727 == 1)
              goto LABEL_811;
          }
        case 19:
          v762 = v22;
          v748 = v18;
          v778 = v21;
          v387 = v16;
          v388 = v816;
          v389 = 8 * v21;
          v390 = 2 * v11;
          while (1)
          {
            v728 = v388;
            v391 = v748;
            v802 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_471;
                LODWORD(v392) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_464:
                  v393 = v26;
                  v394 = 0xFFFF;
                  goto LABEL_465;
                }
              }
              else
              {
                LODWORD(v392) = 0xFFFF;
                if (!v11)
                  goto LABEL_464;
              }
              if (*(_WORD *)v25)
              {
                v393 = v26;
                v394 = __rev16(*(unsigned __int16 *)v25);
LABEL_465:
                v395 = (char *)v814 + 6;
                v396 = PDAcolorburnPDA_10652(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v394, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v392);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v392) = v397;
                  v398 = bswap32(v396);
                  v814->i16[0] = HIWORD(v398);
                  v814->i16[1] = v398;
                  v814->i16[2] = bswap32(HIDWORD(v396)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v396));
                  v395 = v25;
                }
                else
                {
                  v392 = HIWORD(v396);
                  v399 = bswap32(v396);
                  v814->i16[0] = HIWORD(v399);
                  v814->i16[1] = v399;
                  v814->i16[2] = bswap32(HIDWORD(v396)) >> 16;
                }
                v30 = v802;
                v16 = v812;
                v26 = v393;
                goto LABEL_470;
              }
              *v814 = *v813;
              v395 = v25;
LABEL_470:
              *(_WORD *)v395 = bswap32(v392) >> 16;
LABEL_471:
              v25 += v390;
              v400 = (unsigned __int16 *)&v813[v778];
              if ((unint64_t)v400 >= v30)
                v401 = -(uint64_t)v720;
              else
                v401 = 0;
              v26 += v387 + v401;
              v813 = (int8x8_t *)&v400[4 * v401];
              v814 = (int8x8_t *)((char *)v814 + v389);
              --v391;
            }
            while (v391);
            if (v758)
            {
              v402 = (unint64_t)&v762[v760];
              v403 = v402 >= v758;
              v404 = -(uint64_t)(v760 * v719);
              if (v402 < v758)
                v404 = 0;
              v405 = (int8x8_t *)(v402 + 8 * v404);
              v406 = v30 + 8 * v404;
              v407 = -(uint64_t)(v761 * v719);
              if (!v403)
                v407 = 0;
              v26 = &v764[v761 + v407];
              v30 = v406 + 8 * v760;
              v813 = v405;
              v762 = v405;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v388 = v728 - 1;
            if (v728 == 1)
              goto LABEL_811;
          }
        case 20:
          v762 = v22;
          v749 = v18;
          v779 = v21;
          v408 = v16;
          v409 = v816;
          v410 = 8 * v21;
          v411 = 2 * v11;
          while (1)
          {
            v729 = v409;
            v412 = v749;
            v803 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_499;
                LODWORD(v413) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_492:
                  v414 = v26;
                  v415 = 0xFFFF;
                  goto LABEL_493;
                }
              }
              else
              {
                LODWORD(v413) = 0xFFFF;
                if (!v11)
                  goto LABEL_492;
              }
              if (*(_WORD *)v25)
              {
                v414 = v26;
                v415 = __rev16(*(unsigned __int16 *)v25);
LABEL_493:
                v416 = (char *)v814 + 6;
                v417 = PDAsoftlightPDA_10654(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v415, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v413);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v413) = v418;
                  v419 = bswap32(v417);
                  v814->i16[0] = HIWORD(v419);
                  v814->i16[1] = v419;
                  v814->i16[2] = bswap32(HIDWORD(v417)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v417));
                  v416 = v25;
                }
                else
                {
                  v413 = HIWORD(v417);
                  v420 = bswap32(v417);
                  v814->i16[0] = HIWORD(v420);
                  v814->i16[1] = v420;
                  v814->i16[2] = bswap32(HIDWORD(v417)) >> 16;
                }
                v30 = v803;
                v16 = v812;
                v26 = v414;
                goto LABEL_498;
              }
              *v814 = *v813;
              v416 = v25;
LABEL_498:
              *(_WORD *)v416 = bswap32(v413) >> 16;
LABEL_499:
              v25 += v411;
              v421 = (unsigned __int16 *)&v813[v779];
              if ((unint64_t)v421 >= v30)
                v422 = -(uint64_t)v720;
              else
                v422 = 0;
              v26 += v408 + v422;
              v813 = (int8x8_t *)&v421[4 * v422];
              v814 = (int8x8_t *)((char *)v814 + v410);
              --v412;
            }
            while (v412);
            if (v758)
            {
              v423 = (unint64_t)&v762[v760];
              v424 = v423 >= v758;
              v425 = -(uint64_t)(v760 * v719);
              if (v423 < v758)
                v425 = 0;
              v426 = (int8x8_t *)(v423 + 8 * v425);
              v427 = v30 + 8 * v425;
              v428 = -(uint64_t)(v761 * v719);
              if (!v424)
                v428 = 0;
              v26 = &v764[v761 + v428];
              v30 = v427 + 8 * v760;
              v813 = v426;
              v762 = v426;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v409 = v729 - 1;
            if (v729 == 1)
              goto LABEL_811;
          }
        case 21:
          v762 = v22;
          v750 = v18;
          v780 = v21;
          v429 = v16;
          v430 = v816;
          v431 = 8 * v21;
          v432 = 2 * v11;
          while (1)
          {
            v730 = v430;
            v433 = v750;
            v804 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_527;
                LODWORD(v434) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_520:
                  v435 = v26;
                  v436 = 0xFFFF;
                  goto LABEL_521;
                }
              }
              else
              {
                LODWORD(v434) = 0xFFFF;
                if (!v11)
                  goto LABEL_520;
              }
              if (*(_WORD *)v25)
              {
                v435 = v26;
                v436 = __rev16(*(unsigned __int16 *)v25);
LABEL_521:
                v437 = (char *)v814 + 6;
                v438 = PDAhardlightPDA_10653(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v436, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v434);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v434) = v439;
                  v440 = bswap32(v438);
                  v814->i16[0] = HIWORD(v440);
                  v814->i16[1] = v440;
                  v814->i16[2] = bswap32(HIDWORD(v438)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v438));
                  v437 = v25;
                }
                else
                {
                  v434 = HIWORD(v438);
                  v441 = bswap32(v438);
                  v814->i16[0] = HIWORD(v441);
                  v814->i16[1] = v441;
                  v814->i16[2] = bswap32(HIDWORD(v438)) >> 16;
                }
                v30 = v804;
                v16 = v812;
                v26 = v435;
                goto LABEL_526;
              }
              *v814 = *v813;
              v437 = v25;
LABEL_526:
              *(_WORD *)v437 = bswap32(v434) >> 16;
LABEL_527:
              v25 += v432;
              v442 = (unsigned __int16 *)&v813[v780];
              if ((unint64_t)v442 >= v30)
                v443 = -(uint64_t)v720;
              else
                v443 = 0;
              v26 += v429 + v443;
              v813 = (int8x8_t *)&v442[4 * v443];
              v814 = (int8x8_t *)((char *)v814 + v431);
              --v433;
            }
            while (v433);
            if (v758)
            {
              v444 = (unint64_t)&v762[v760];
              v445 = v444 >= v758;
              v446 = -(uint64_t)(v760 * v719);
              if (v444 < v758)
                v446 = 0;
              v447 = (int8x8_t *)(v444 + 8 * v446);
              v448 = v30 + 8 * v446;
              v449 = -(uint64_t)(v761 * v719);
              if (!v445)
                v449 = 0;
              v26 = &v764[v761 + v449];
              v30 = v448 + 8 * v760;
              v813 = v447;
              v762 = v447;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v430 = v730 - 1;
            if (v730 == 1)
              goto LABEL_811;
          }
        case 22:
          v762 = v22;
          v751 = v18;
          v781 = v21;
          v450 = v16;
          v451 = v816;
          v452 = 8 * v21;
          v453 = 2 * v11;
          while (1)
          {
            v731 = v451;
            v454 = v751;
            v805 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_555;
                LODWORD(v455) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_548:
                  v456 = v26;
                  v457 = 0xFFFF;
                  goto LABEL_549;
                }
              }
              else
              {
                LODWORD(v455) = 0xFFFF;
                if (!v11)
                  goto LABEL_548;
              }
              if (*(_WORD *)v25)
              {
                v456 = v26;
                v457 = __rev16(*(unsigned __int16 *)v25);
LABEL_549:
                v458 = (char *)v814 + 6;
                v459 = PDAdifferencePDA_10655(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v457, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v455);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v455) = v460;
                  v461 = bswap32(v459);
                  v814->i16[0] = HIWORD(v461);
                  v814->i16[1] = v461;
                  v814->i16[2] = bswap32(HIDWORD(v459)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v459));
                  v458 = v25;
                }
                else
                {
                  v455 = HIWORD(v459);
                  v462 = bswap32(v459);
                  v814->i16[0] = HIWORD(v462);
                  v814->i16[1] = v462;
                  v814->i16[2] = bswap32(HIDWORD(v459)) >> 16;
                }
                v30 = v805;
                v16 = v812;
                v26 = v456;
                goto LABEL_554;
              }
              *v814 = *v813;
              v458 = v25;
LABEL_554:
              *(_WORD *)v458 = bswap32(v455) >> 16;
LABEL_555:
              v25 += v453;
              v463 = (unsigned __int16 *)&v813[v781];
              if ((unint64_t)v463 >= v30)
                v464 = -(uint64_t)v720;
              else
                v464 = 0;
              v26 += v450 + v464;
              v813 = (int8x8_t *)&v463[4 * v464];
              v814 = (int8x8_t *)((char *)v814 + v452);
              --v454;
            }
            while (v454);
            if (v758)
            {
              v465 = (unint64_t)&v762[v760];
              v466 = v465 >= v758;
              v467 = -(uint64_t)(v760 * v719);
              if (v465 < v758)
                v467 = 0;
              v468 = (int8x8_t *)(v465 + 8 * v467);
              v469 = v30 + 8 * v467;
              v470 = -(uint64_t)(v761 * v719);
              if (!v466)
                v470 = 0;
              v26 = &v764[v761 + v470];
              v30 = v469 + 8 * v760;
              v813 = v468;
              v762 = v468;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v451 = v731 - 1;
            if (v731 == 1)
              goto LABEL_811;
          }
        case 23:
          v762 = v22;
          v752 = v18;
          v782 = v21;
          v471 = v16;
          v472 = v816;
          v473 = 8 * v21;
          v474 = 2 * v11;
          while (1)
          {
            v732 = v472;
            v475 = v752;
            v806 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_583;
                LODWORD(v476) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_576:
                  v477 = v26;
                  v478 = 0xFFFF;
                  goto LABEL_577;
                }
              }
              else
              {
                LODWORD(v476) = 0xFFFF;
                if (!v11)
                  goto LABEL_576;
              }
              if (*(_WORD *)v25)
              {
                v477 = v26;
                v478 = __rev16(*(unsigned __int16 *)v25);
LABEL_577:
                v479 = (char *)v814 + 6;
                v480 = PDAexclusionPDA_10656(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v478, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v476);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v476) = v481;
                  v482 = bswap32(v480);
                  v814->i16[0] = HIWORD(v482);
                  v814->i16[1] = v482;
                  v814->i16[2] = bswap32(HIDWORD(v480)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v480));
                  v479 = v25;
                }
                else
                {
                  v476 = HIWORD(v480);
                  v483 = bswap32(v480);
                  v814->i16[0] = HIWORD(v483);
                  v814->i16[1] = v483;
                  v814->i16[2] = bswap32(HIDWORD(v480)) >> 16;
                }
                v30 = v806;
                v16 = v812;
                v26 = v477;
                goto LABEL_582;
              }
              *v814 = *v813;
              v479 = v25;
LABEL_582:
              *(_WORD *)v479 = bswap32(v476) >> 16;
LABEL_583:
              v25 += v474;
              v484 = (unsigned __int16 *)&v813[v782];
              if ((unint64_t)v484 >= v30)
                v485 = -(uint64_t)v720;
              else
                v485 = 0;
              v26 += v471 + v485;
              v813 = (int8x8_t *)&v484[4 * v485];
              v814 = (int8x8_t *)((char *)v814 + v473);
              --v475;
            }
            while (v475);
            if (v758)
            {
              v486 = (unint64_t)&v762[v760];
              v487 = v486 >= v758;
              v488 = -(uint64_t)(v760 * v719);
              if (v486 < v758)
                v488 = 0;
              v489 = (int8x8_t *)(v486 + 8 * v488);
              v490 = v30 + 8 * v488;
              v491 = -(uint64_t)(v761 * v719);
              if (!v487)
                v491 = 0;
              v26 = &v764[v761 + v491];
              v30 = v490 + 8 * v760;
              v813 = v489;
              v762 = v489;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v472 = v732 - 1;
            if (v732 == 1)
              goto LABEL_811;
          }
        case 24:
          v762 = v22;
          v753 = v18;
          v783 = v21;
          v492 = v16;
          v493 = v816;
          v494 = 8 * v21;
          v495 = 2 * v11;
          while (1)
          {
            v733 = v493;
            v496 = v753;
            v807 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_611;
                LODWORD(v497) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_604:
                  v498 = v26;
                  v499 = 0xFFFF;
                  goto LABEL_605;
                }
              }
              else
              {
                LODWORD(v497) = 0xFFFF;
                if (!v11)
                  goto LABEL_604;
              }
              if (*(_WORD *)v25)
              {
                v498 = v26;
                v499 = __rev16(*(unsigned __int16 *)v25);
LABEL_605:
                v500 = (char *)v814 + 6;
                v501 = PDAhuePDA_10657(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v499, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v497);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v497) = v502;
                  v503 = bswap32(v501);
                  v814->i16[0] = HIWORD(v503);
                  v814->i16[1] = v503;
                  v814->i16[2] = bswap32(HIDWORD(v501)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v501));
                  v500 = v25;
                }
                else
                {
                  v504 = bswap32(v501);
                  v814->i16[0] = HIWORD(v504);
                  v814->i16[1] = v504;
                  v814->i16[2] = bswap32(HIDWORD(v501)) >> 16;
                  v497 = HIWORD(v501);
                }
                v30 = v807;
                v16 = v812;
                v26 = v498;
                goto LABEL_610;
              }
              *v814 = *v813;
              v500 = v25;
LABEL_610:
              *(_WORD *)v500 = bswap32(v497) >> 16;
LABEL_611:
              v25 += v495;
              v505 = (unsigned __int16 *)&v813[v783];
              if ((unint64_t)v505 >= v30)
                v506 = -(uint64_t)v720;
              else
                v506 = 0;
              v26 += v492 + v506;
              v813 = (int8x8_t *)&v505[4 * v506];
              v814 = (int8x8_t *)((char *)v814 + v494);
              --v496;
            }
            while (v496);
            if (v758)
            {
              v507 = (unint64_t)&v762[v760];
              v508 = v507 >= v758;
              v509 = -(uint64_t)(v760 * v719);
              if (v507 < v758)
                v509 = 0;
              v510 = (int8x8_t *)(v507 + 8 * v509);
              v511 = v30 + 8 * v509;
              v512 = -(uint64_t)(v761 * v719);
              if (!v508)
                v512 = 0;
              v26 = &v764[v761 + v512];
              v30 = v511 + 8 * v760;
              v813 = v510;
              v762 = v510;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v493 = v733 - 1;
            if (v733 == 1)
              goto LABEL_811;
          }
        case 25:
          v762 = v22;
          v754 = v18;
          v784 = v21;
          v513 = v16;
          v514 = v816;
          v515 = 8 * v21;
          v516 = 2 * v11;
          while (1)
          {
            v734 = v514;
            v517 = v754;
            v808 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_639;
                LODWORD(v518) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_632:
                  v519 = v26;
                  v520 = 0xFFFF;
                  goto LABEL_633;
                }
              }
              else
              {
                LODWORD(v518) = 0xFFFF;
                if (!v11)
                  goto LABEL_632;
              }
              if (*(_WORD *)v25)
              {
                v519 = v26;
                v520 = __rev16(*(unsigned __int16 *)v25);
LABEL_633:
                v521 = (char *)v814 + 6;
                v522 = PDAsaturationPDA_10658(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v520, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v518);
                v11 = v787;
                if (v787)
                {
                  LODWORD(v518) = v523;
                  v524 = bswap32(v522);
                  v814->i16[0] = HIWORD(v524);
                  v814->i16[1] = v524;
                  v814->i16[2] = bswap32(HIDWORD(v522)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v522));
                  v521 = v25;
                }
                else
                {
                  v525 = bswap32(v522);
                  v814->i16[0] = HIWORD(v525);
                  v814->i16[1] = v525;
                  v814->i16[2] = bswap32(HIDWORD(v522)) >> 16;
                  v518 = HIWORD(v522);
                }
                v30 = v808;
                v16 = v812;
                v26 = v519;
                goto LABEL_638;
              }
              *v814 = *v813;
              v521 = v25;
LABEL_638:
              *(_WORD *)v521 = bswap32(v518) >> 16;
LABEL_639:
              v25 += v516;
              v526 = (unsigned __int16 *)&v813[v784];
              if ((unint64_t)v526 >= v30)
                v527 = -(uint64_t)v720;
              else
                v527 = 0;
              v26 += v513 + v527;
              v813 = (int8x8_t *)&v526[4 * v527];
              v814 = (int8x8_t *)((char *)v814 + v515);
              --v517;
            }
            while (v517);
            if (v758)
            {
              v528 = (unint64_t)&v762[v760];
              v529 = v528 >= v758;
              v530 = -(uint64_t)(v760 * v719);
              if (v528 < v758)
                v530 = 0;
              v531 = (int8x8_t *)(v528 + 8 * v530);
              v532 = v30 + 8 * v530;
              v533 = -(uint64_t)(v761 * v719);
              if (!v529)
                v533 = 0;
              v26 = &v764[v761 + v533];
              v30 = v532 + 8 * v760;
              v813 = v531;
              v762 = v531;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v514 = v734 - 1;
            if (v734 == 1)
              goto LABEL_811;
          }
        case 26:
          v762 = v22;
          v755 = v18;
          v785 = v21;
          v534 = v16;
          v535 = v816;
          v536 = 8 * v21;
          v537 = 2 * v11;
          while (1)
          {
            v735 = v535;
            v538 = v755;
            v809 = v30;
            do
            {
              if (v16)
              {
                if (!*v26)
                  goto LABEL_667;
                LODWORD(v539) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_660:
                  v540 = v26;
                  v541 = 0xFFFF;
                  goto LABEL_661;
                }
              }
              else
              {
                LODWORD(v539) = 0xFFFF;
                if (!v11)
                  goto LABEL_660;
              }
              if (*(_WORD *)v25)
              {
                v540 = v26;
                v541 = __rev16(*(unsigned __int16 *)v25);
LABEL_661:
                v542 = (char *)v814 + 6;
                v543 = PDAluminosityPDA_10659(((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v539, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v541);
                v11 = v787;
                if (v787)
                {
                  v544 = bswap32(v543);
                  v814->i16[0] = HIWORD(v544);
                  v814->i16[1] = v544;
                  v814->i16[2] = bswap32(HIDWORD(v543)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v543));
                  v542 = v25;
                }
                else
                {
                  v539 = HIWORD(v543);
                  v545 = bswap32(v543);
                  v814->i16[0] = HIWORD(v545);
                  v814->i16[1] = v545;
                  v814->i16[2] = bswap32(HIDWORD(v543)) >> 16;
                }
                v30 = v809;
                v16 = v812;
                v26 = v540;
                goto LABEL_666;
              }
              *v814 = *v813;
              v542 = v25;
LABEL_666:
              *(_WORD *)v542 = bswap32(v539) >> 16;
LABEL_667:
              v25 += v537;
              v546 = (unsigned __int16 *)&v813[v785];
              if ((unint64_t)v546 >= v30)
                v547 = -(uint64_t)v720;
              else
                v547 = 0;
              v26 += v534 + v547;
              v813 = (int8x8_t *)&v546[4 * v547];
              v814 = (int8x8_t *)((char *)v814 + v536);
              --v538;
            }
            while (v538);
            if (v758)
            {
              v548 = (unint64_t)&v762[v760];
              v549 = v548 >= v758;
              v550 = -(uint64_t)(v760 * v719);
              if (v548 < v758)
                v550 = 0;
              v551 = (int8x8_t *)(v548 + 8 * v550);
              v552 = v30 + 8 * v550;
              v553 = -(uint64_t)(v761 * v719);
              if (!v549)
                v553 = 0;
              v26 = &v764[v761 + v553];
              v30 = v552 + 8 * v760;
              v813 = v551;
              v762 = v551;
              v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            v535 = v735 - 1;
            if (v735 == 1)
              goto LABEL_811;
          }
        case 27:
          v762 = v22;
          v756 = v18;
          v786 = v21;
          v554 = v16;
          v555 = v816;
          v556 = 8 * v21;
          v557 = 2 * v11;
          break;
        default:
          v17 = v34;
          v788 = v30;
          goto LABEL_910;
      }
      break;
    }
LABEL_681:
    v736 = v555;
    v558 = v756;
    v810 = v30;
    while (v16)
    {
      if (*v26)
      {
        LODWORD(v559) = __rev16((unsigned __int16)*v26);
        if (v11)
          goto LABEL_685;
LABEL_688:
        v560 = v26;
        v561 = 0xFFFF;
LABEL_689:
        v562 = (char *)v814 + 6;
        v563 = PDAluminosityPDA_10659(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v561, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v559);
        v11 = v787;
        if (v787)
        {
          LODWORD(v559) = v564;
          v565 = bswap32(v563);
          v814->i16[0] = HIWORD(v565);
          v814->i16[1] = v565;
          v814->i16[2] = bswap32(HIDWORD(v563)) >> 16;
          v814->i16[3] = __rev16(HIWORD(v563));
          v562 = v25;
        }
        else
        {
          v566 = bswap32(v563);
          v814->i16[0] = HIWORD(v566);
          v814->i16[1] = v566;
          v814->i16[2] = bswap32(HIDWORD(v563)) >> 16;
          v559 = HIWORD(v563);
        }
        v30 = v810;
        v16 = v812;
        v26 = v560;
        goto LABEL_694;
      }
LABEL_695:
      v25 += v557;
      v567 = (unsigned __int16 *)&v813[v786];
      if ((unint64_t)v567 >= v30)
        v568 = -(uint64_t)v720;
      else
        v568 = 0;
      v26 += v554 + v568;
      v813 = (int8x8_t *)&v567[4 * v568];
      v814 = (int8x8_t *)((char *)v814 + v556);
      if (!--v558)
      {
        if (v758)
        {
          v569 = (unint64_t)&v762[v760];
          v570 = v569 >= v758;
          v571 = -(uint64_t)(v760 * v719);
          if (v569 < v758)
            v571 = 0;
          v572 = (int8x8_t *)(v569 + 8 * v571);
          v573 = v30 + 8 * v571;
          v574 = -(uint64_t)(v761 * v719);
          if (!v570)
            v574 = 0;
          v26 = &v764[v761 + v574];
          v30 = v573 + 8 * v760;
          v813 = v572;
          v762 = v572;
          v764 = v26;
        }
        else
        {
          v813 += v760;
          v26 += v761;
        }
        v814 += v757;
        v25 += 2 * v759;
        v555 = v736 - 1;
        if (v736 == 1)
        {
LABEL_811:
          v788 = v30;
          v816 = 0;
          v17 = v711;
LABEL_812:
          v10 = v712;
          v8 = v713;
LABEL_813:
          v24 = v721;
          v22 = v762;
          goto LABEL_814;
        }
        goto LABEL_681;
      }
    }
    LODWORD(v559) = 0xFFFF;
    if (!v11)
      goto LABEL_688;
LABEL_685:
    if (*(_WORD *)v25)
    {
      v560 = v26;
      v561 = __rev16(*(unsigned __int16 *)v25);
      goto LABEL_689;
    }
    *v814 = *v813;
    v562 = v25;
LABEL_694:
    *(_WORD *)v562 = bswap32(v559) >> 16;
    goto LABEL_695;
  }
}

void CMYK64_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  char *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int8x16_t v31;
  int16x8_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint64_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int8x16_t v50;
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int8x16_t v56;
  int8x16_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  int32x4_t v66;
  int32x4_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t v70;
  int8x16_t v71;
  int8x16_t v72;
  int8x16_t v73;
  int8x16_t v74;
  int8x16_t v75;
  int8x16_t v76;
  int8x16_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int16x8_t v81;
  uint64_t v82;
  unint64_t v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unsigned __int16 *v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  int8x8_t *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  unsigned int v98;
  int v99;
  int v100;
  unint64_t v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  uint64_t v106;
  unint64_t v107;
  __int16 v108;
  unsigned __int16 v109;
  unint64_t v110;
  int32x4_t v111;
  unsigned int v112;
  unsigned int v113;
  int v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  uint64_t v118;
  unint64_t v119;
  unsigned int v120;
  int32x4_t v121;
  unsigned int v122;
  unsigned int v123;
  uint32x4_t v124;
  int32x2_t v125;
  unsigned int v126;
  int v127;
  uint64_t v128;
  unint64_t v129;
  unsigned int v130;
  int32x4_t v131;
  unsigned int v132;
  unsigned int v133;
  uint32x4_t v134;
  int32x2_t v135;
  unsigned int v136;
  int v137;
  uint64_t v138;
  unint64_t v139;
  unsigned int v140;
  int32x4_t v141;
  unsigned int v142;
  unsigned int v143;
  uint32x4_t v144;
  int32x2_t v145;
  unsigned int v146;
  unsigned int v147;
  uint64_t v148;
  unint64_t v149;
  unsigned int v150;
  int32x4_t v151;
  unsigned int v152;
  uint32x4_t v153;
  int32x2_t v154;
  int v155;
  unsigned int v156;
  int v157;
  int8x8_t *v158;
  char v159;
  unsigned int *v160;
  unsigned __int16 *v161;
  int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  uint64_t v166;
  int32x4_t v167;
  int v168;
  int v169;
  unint64_t *v170;
  unint64_t v171;
  unsigned int v172;
  unint64_t v173;
  unint64_t v174;
  int v175;
  unsigned int v176;
  uint64_t v177;
  unint64_t v178;
  unsigned int v179;
  int32x4_t v180;
  uint32x4_t v181;
  int32x2_t v182;
  uint64_t v183;
  int32x4_t v184;
  int v185;
  int v186;
  unint64_t *v187;
  unint64_t v188;
  unsigned int v189;
  unint64_t v190;
  unint64_t v191;
  int v192;
  unsigned int v193;
  uint64_t v194;
  unint64_t v195;
  unsigned int v196;
  int32x4_t v197;
  uint32x4_t v198;
  int32x2_t v199;
  uint64_t v200;
  int v201;
  uint64_t v202;
  unsigned int v203;
  uint64_t v204;
  int32x4_t v205;
  int v206;
  uint64_t v207;
  unsigned int v208;
  unint64_t *v209;
  unint64_t v210;
  unsigned int v211;
  unint64_t v212;
  unint64_t v213;
  unsigned int v214;
  unsigned int v215;
  int32x2_t *v216;
  unsigned int v217;
  unint64_t v218;
  int32x4_t v219;
  unint64_t v220;
  uint32x4_t v221;
  int32x2_t v222;
  uint64_t v223;
  int v224;
  int v225;
  unint64_t v226;
  unsigned int v227;
  int8x8_t *v228;
  unsigned __int16 *v229;
  int v230;
  int v231;
  uint64_t v232;
  unsigned int v233;
  int v234;
  int v235;
  unint64_t v236;
  unsigned int v237;
  int8x8_t *v238;
  unsigned __int16 *v239;
  unsigned int v240;
  uint64_t v241;
  int v242;
  unsigned int v243;
  uint64_t v244;
  uint64_t v245;
  int v246;
  unsigned int v247;
  uint64_t v248;
  uint64_t v249;
  int v250;
  int v251;
  uint64_t v252;
  int v253;
  int v254;
  uint64_t v255;
  int v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  unsigned int v260;
  unsigned __int16 *v261;
  unint64_t v262;
  int v263;
  unsigned int v264;
  unsigned int v265;
  uint64_t v266;
  int v267;
  uint64_t v268;
  unint64_t v269;
  unint64_t v270;
  unsigned int v271;
  unsigned __int16 *v272;
  unint64_t v273;
  int v274;
  unsigned int v275;
  unsigned int v276;
  uint64_t v277;
  int v278;
  uint64_t v279;
  unint64_t v280;
  unint64_t v281;
  unsigned int v282;
  unsigned __int16 *v283;
  unint64_t v284;
  int v285;
  unsigned int v286;
  unsigned int v287;
  uint64_t v288;
  int v289;
  uint64_t v290;
  unint64_t v291;
  unint64_t v292;
  unsigned int v293;
  unsigned __int16 *v294;
  unint64_t v295;
  int v296;
  unsigned int v297;
  unsigned int v298;
  uint64_t v299;
  int v300;
  uint64_t v301;
  unint64_t v302;
  unint64_t v303;
  unsigned int v304;
  unsigned __int16 *v305;
  unint64_t v306;
  int v307;
  unsigned int v308;
  unsigned int v309;
  uint64_t v310;
  int v311;
  uint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unsigned int v315;
  unsigned __int16 *v316;
  unint64_t v317;
  int v318;
  unsigned int v319;
  unsigned int v320;
  uint64_t v321;
  int v322;
  uint64_t v323;
  unint64_t v324;
  unint64_t v325;
  unsigned int v326;
  unsigned __int16 *v327;
  unint64_t v328;
  int v329;
  unsigned int v330;
  unsigned int v331;
  uint64_t v332;
  int v333;
  uint64_t v334;
  unint64_t v335;
  unint64_t v336;
  unsigned int v337;
  unsigned __int16 *v338;
  unint64_t v339;
  int v340;
  unsigned int v341;
  unsigned int v342;
  uint64_t v343;
  int v344;
  uint64_t v345;
  unint64_t v346;
  unint64_t v347;
  unsigned int v348;
  unsigned __int16 *v349;
  unint64_t v350;
  int v351;
  unsigned int v352;
  unsigned int v353;
  uint64_t v354;
  int v355;
  uint64_t v356;
  unint64_t v357;
  unint64_t v358;
  unsigned int v359;
  unsigned __int16 *v360;
  unint64_t v361;
  int v362;
  unsigned int v363;
  unsigned int v364;
  uint64_t v365;
  int v366;
  uint64_t v367;
  unint64_t v368;
  unint64_t v369;
  unsigned int v370;
  unsigned __int16 *v371;
  unint64_t v372;
  int v373;
  unsigned int v374;
  unsigned int v375;
  uint64_t v376;
  int v377;
  uint64_t v378;
  unint64_t v379;
  unint64_t v380;
  unsigned int v381;
  unsigned __int16 *v382;
  unint64_t v383;
  int v384;
  unsigned int v385;
  unsigned int v386;
  uint64_t v387;
  int v388;
  uint64_t v389;
  unint64_t v390;
  unint64_t v391;
  unsigned int v392;
  unsigned __int16 *v393;
  unint64_t v394;
  int v395;
  unsigned int v396;
  unsigned int v397;
  uint64_t v398;
  int v399;
  uint64_t v400;
  unint64_t v401;
  unint64_t v402;
  unsigned int v403;
  unsigned __int16 *v404;
  unsigned int v405;
  unsigned int v406;
  uint64_t v407;
  int v408;
  uint64_t v409;
  unint64_t v410;
  unint64_t v411;
  unsigned int v412;
  unsigned __int16 *v413;
  unint64_t v414;
  int v415;
  unsigned int v416;
  unsigned int v417;
  int32x4_t v418;
  int v419;
  int v420;
  unsigned int v421;
  int32x4_t v422;
  uint32x4_t v423;
  int v424;
  int v425;
  char v426;
  unsigned int *v427;
  int8x8_t *v428;
  int v429;
  unsigned int v430;
  unsigned int v431;
  int v432;
  char v433;
  unsigned int *v434;
  int8x8_t *v435;
  int v436;
  int v437;
  unsigned int v438;
  unsigned int v439;
  int32x4_t v440;
  int32x4_t v441;
  int v442;
  int v443;
  unsigned int v444;
  int32x4_t v445;
  uint32x4_t v446;
  int32x4_t v447;
  unsigned int v448;
  int32x4_t v449;
  uint32x4_t v450;
  int32x4_t v451;
  int32x4_t v452;
  int v453;
  int v454;
  unsigned int v455;
  __int16 v456;
  __int16 v457;
  uint32x4_t v458;
  int32x4_t v459;
  int32x4_t v460;
  unsigned int v461;
  __int16 v462;
  __int16 v463;
  uint32x4_t v464;
  uint64_t v465;
  unint64_t v466;
  unint64_t v467;
  int v468;
  unsigned int v469;
  int32x4_t v470;
  int32x2_t v471;
  uint32x4_t v472;
  int32x4_t v473;
  unsigned int v474;
  unsigned int v475;
  int v476;
  unsigned int v477;
  unsigned int v478;
  int32x4_t v479;
  uint32x4_t v480;
  unsigned int v481;
  unsigned int v482;
  uint32x4_t v483;
  unsigned int v484;
  unsigned int v485;
  uint32x4_t v486;
  unsigned int v487;
  unsigned int v488;
  unsigned int v489;
  uint32x4_t v490;
  int32x4_t v491;
  unsigned int v492;
  uint64_t v493;
  unint64_t v494;
  unsigned int v495;
  int32x4_t v496;
  unsigned int v497;
  uint32x4_t v498;
  int32x2_t v499;
  uint64_t v500;
  unint64_t v501;
  unsigned int v502;
  int32x4_t v503;
  unsigned int v504;
  uint32x4_t v505;
  int32x2_t v506;
  uint64_t v507;
  unint64_t v508;
  unsigned int v509;
  int32x4_t v510;
  unsigned int v511;
  uint32x4_t v512;
  int32x2_t v513;
  unsigned int v514;
  uint64_t v515;
  unint64_t v516;
  unsigned int v517;
  int32x4_t v518;
  unsigned int v519;
  uint32x4_t v520;
  uint32x4_t v521;
  int v522;
  int v523;
  unsigned int v524;
  uint64_t v525;
  unsigned int v526;
  unsigned __int16 v527;
  int32x4_t v528;
  unint64_t v529;
  unsigned int v530;
  int v531;
  unsigned int v532;
  unint64_t v533;
  unsigned int v534;
  int32x4_t v535;
  uint32x4_t v536;
  int32x2_t v537;
  unint64_t v538;
  unsigned int v539;
  int32x4_t v540;
  uint32x4_t v541;
  int32x2_t v542;
  unint64_t v543;
  unsigned int v544;
  int32x4_t v545;
  uint32x4_t v546;
  int32x2_t v547;
  unsigned int v548;
  int v549;
  unint64_t v550;
  unsigned int v551;
  int32x4_t v552;
  uint32x4_t v553;
  int32x2_t v554;
  int v555;
  uint64_t v556;
  unint64_t v557;
  int v558;
  int32x4_t v559;
  int32x2_t v560;
  uint32x4_t v561;
  int32x4_t v562;
  unsigned int v563;
  unsigned int v564;
  int v565;
  unsigned int v566;
  int32x4_t v567;
  uint32x4_t v568;
  int32x4_t v569;
  unsigned int v570;
  int32x4_t v571;
  uint32x4_t v572;
  unsigned int v573;
  int32x4_t v574;
  uint32x4_t v575;
  unsigned int v576;
  uint32x4_t v577;
  uint32x4_t v578;
  uint32x4_t v579;
  uint64_t v580;
  unsigned int v581;
  int32x4_t v582;
  uint32x4_t v583;
  int32x2_t v584;
  uint64_t v585;
  unsigned int v586;
  int32x4_t v587;
  uint32x4_t v588;
  int32x2_t v589;
  uint64_t v590;
  unsigned int v591;
  int32x4_t v592;
  uint32x4_t v593;
  int32x2_t v594;
  unsigned int v595;
  uint64_t v596;
  unsigned int v597;
  int32x4_t v598;
  uint32x4_t v599;
  int v600;
  unint64_t v601;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  unint64_t v606;
  int v607;

  v3 = *(_QWORD *)(a1 + 48);
  v5 = *(unsigned __int16 **)(a1 + 88);
  v4 = *(unsigned __int16 **)(a1 + 96);
  v6 = bswap32(v5[3]) >> 16;
  v7 = ((unint64_t)(bswap32(v5[2]) >> 16) << 32) | (v6 << 48);
  v8 = (__PAIR64__(bswap32(v5[1]) >> 16, bswap32(*v5)) >> 16);
  if (v4)
    v9 = bswap32(*v4) >> 16;
  else
    v9 = 0xFFFF;
  v10 = *(_DWORD *)(a1 + 8);
  v605 = *(_QWORD *)(a1 + 136);
  v607 = *(_DWORD *)(a1 + 4);
  v11 = v7 | v8;
  v601 = *(int *)(a1 + 28);
  v603 = *(_QWORD *)(a1 + 40);
  pthread_mutex_lock(&CMYK64_cacheColorLock);
  v12 = CMYK64_cacheColor;
  if (!CMYK64_cacheColor
    || *(_QWORD *)(CMYK64_cacheColor + 16) != v11
    || *(unsigned __int16 *)(CMYK64_cacheColor + 24) != v9)
  {
    v14 = 0;
    while (1)
    {
      if (!v12)
        goto LABEL_14;
      v15 = v12;
      v16 = v14;
      if (*(_QWORD *)(v12 + 16) == v11 && *(unsigned __int16 *)(v12 + 24) == v9)
        break;
      v12 = *(_QWORD *)v12;
      v14 = (_QWORD *)v15;
      if (!*(_QWORD *)v15)
      {
        if (CMYK64_cacheColorCount > 6)
        {
          *v16 = 0;
        }
        else
        {
LABEL_14:
          v17 = (char *)CMYK64_cacheColorBase;
          if (CMYK64_cacheColorBase)
          {
            v18 = CMYK64_cacheColorCount;
          }
          else
          {
            v17 = (char *)malloc_type_calloc(1uLL, 0x70E0uLL, 0x102004053D502F9uLL);
            v18 = 0;
            CMYK64_cacheColorBase = (uint64_t)v17;
          }
          v15 = (uint64_t)&v17[32 * v18];
          *(_QWORD *)(v15 + 8) = &v17[4096 * (unint64_t)v18 + 224];
          CMYK64_cacheColorCount = v18 + 1;
        }
        v19 = 0;
        *(_QWORD *)v15 = CMYK64_cacheColor;
        CMYK64_cacheColor = v15;
        *(_QWORD *)(v15 + 16) = v11;
        *(_WORD *)(v15 + 24) = v9;
        *(_DWORD *)(v15 + 26) = 0;
        *(_WORD *)(v15 + 30) = 0;
        v21 = *(_QWORD *)(v15 + 8);
        v13 = v15 + 8;
        v20 = v21;
        v22 = vdupq_n_s32((unsigned __int16)v8);
        v23 = vdupq_n_s32(WORD1(v8));
        v24 = vdupq_n_s32(WORD2(v7));
        v25 = vdupq_n_s32(v6);
        v26 = vdupq_n_s32(v9);
        v27 = vdupq_n_s32(v8);
        v28 = vdupq_n_s32(HIDWORD(v7));
        v29 = (int32x4_t)xmmword_185004E20;
        v30 = (int32x4_t)xmmword_185004DC0;
        v31.i64[0] = 0xFFFF0000FFFFLL;
        v31.i64[1] = 0xFFFF0000FFFFLL;
        v32 = vdupq_n_s16(v9);
        v33.i64[0] = 0x800000008;
        v33.i64[1] = 0x800000008;
        v34 = vdupq_n_s32(0x101u);
        do
        {
          v35 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v29, v34), v31);
          v36 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v30, v34), v31);
          v37 = (int8x16_t)vmulq_s32(v36, v22);
          v38 = (int8x16_t)vmulq_s32(v35, v22);
          v39 = (int8x16_t)vmulq_s32(v35, v23);
          v40 = (int8x16_t)vmulq_s32(v36, v23);
          v41 = (int8x16_t)vmulq_s32(v35, v24);
          v42 = (int8x16_t)vmulq_s32(v36, v24);
          v43 = (int8x16_t)vmulq_s32(v36, v25);
          v44 = (int8x16_t)vmulq_s32(v35, v25);
          v45 = (int8x16_t)vmulq_s32(v36, v26);
          v46 = (int8x16_t)vmulq_s32(v35, v26);
          v47 = v20 + v19;
          v48 = vsubq_s32(v25, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x10uLL), (int32x4_t)vmvnq_s8(v43)), 0x10uLL));
          v49 = vsubq_s32(v25, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v44, 0x10uLL), (int32x4_t)vmvnq_s8(v44)), 0x10uLL));
          v50.i64[0] = v49.u32[2];
          v50.i64[1] = v49.u32[3];
          v51 = (int64x2_t)v50;
          v50.i64[0] = v49.u32[0];
          v50.i64[1] = v49.u32[1];
          v52 = (int64x2_t)v50;
          v50.i64[0] = v48.u32[2];
          v50.i64[1] = v48.u32[3];
          v53 = (int64x2_t)v50;
          v50.i64[0] = v48.u32[0];
          v50.i64[1] = v48.u32[1];
          _Q28 = vandq_s8((int8x16_t)vsubq_s32(v28, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x10uLL), (int32x4_t)vmvnq_s8(v42)), 0x10uLL)), v31);
          _Q27 = vandq_s8((int8x16_t)vsubq_s32(v28, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v41, 0x10uLL), (int32x4_t)vmvnq_s8(v41)), 0x10uLL)), v31);
          v56 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q28.i8, 0x20uLL);
          __asm { SHLL2           V28.2D, V28.4S, #0x20 ; ' ' }
          v61 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q27.i8, 0x20uLL);
          __asm { SHLL2           V27.2D, V27.4S, #0x20 ; ' ' }
          v62 = vorrq_s8((int8x16_t)vshlq_n_s64(v51, 0x30uLL), _Q27);
          v63 = vorrq_s8((int8x16_t)vshlq_n_s64(v52, 0x30uLL), v61);
          v64 = vorrq_s8((int8x16_t)vshlq_n_s64(v53, 0x30uLL), _Q28);
          v65 = vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v50, 0x30uLL), v56);
          v66 = vshlq_n_s32(vsubq_s32(v23, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x10uLL), (int32x4_t)vmvnq_s8(v40)), 0x10uLL)), 0x10uLL);
          v67 = vshlq_n_s32(vsubq_s32(v23, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x10uLL), (int32x4_t)vmvnq_s8(v39)), 0x10uLL)), 0x10uLL);
          v50.i64[0] = v67.u32[2];
          v50.i64[1] = v67.u32[3];
          v68 = v50;
          v50.i64[0] = v67.u32[0];
          v50.i64[1] = v67.u32[1];
          v69 = v50;
          v50.i64[0] = v66.u32[2];
          v50.i64[1] = v66.u32[3];
          v70 = v50;
          v50.i64[0] = v66.u32[0];
          v50.i64[1] = v66.u32[1];
          v71 = v50;
          v72 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x10uLL), (int32x4_t)vmvnq_s8(v38)), 0x10uLL)), v31);
          v73 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x10uLL), (int32x4_t)vmvnq_s8(v37)), 0x10uLL)), v31);
          v50.i64[0] = v73.u32[0];
          v50.i64[1] = v73.u32[1];
          v74 = v50;
          v50.i64[0] = v73.u32[2];
          v50.i64[1] = v73.u32[3];
          v75 = v50;
          v50.i64[0] = v72.u32[0];
          v50.i64[1] = v72.u32[1];
          v76 = v50;
          v50.i64[0] = v72.u32[2];
          v50.i64[1] = v72.u32[3];
          v77 = vorrq_s8(v65, vorrq_s8(v71, v74));
          *(_QWORD *)v47 = v77.i64[0];
          v78 = vorrq_s8(v64, vorrq_s8(v70, v75));
          *(_QWORD *)(v47 + 32) = v78.i64[0];
          v79 = vorrq_s8(v63, vorrq_s8(v69, v76));
          *(_QWORD *)(v47 + 64) = v79.i64[0];
          v80 = vorrq_s8(v62, vorrq_s8(v68, v50));
          *(_QWORD *)(v47 + 96) = v80.i64[0];
          v81 = vsubq_s16(v32, vsubhn_high_s32(vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x10uLL), (int32x4_t)vmvnq_s8(v45)), (int32x4_t)vshrq_n_u32((uint32x4_t)v46, 0x10uLL), (int32x4_t)vmvnq_s8(v46)));
          *(_WORD *)(v47 + 8) = v81.i16[0];
          *(_QWORD *)(v20 + v19 + 16) = v77.i64[1];
          *(_QWORD *)(v20 + v19 + 48) = v78.i64[1];
          *(_QWORD *)(v20 + v19 + 80) = v79.i64[1];
          *(_QWORD *)(v20 + v19 + 112) = v80.i64[1];
          *(_WORD *)(v20 + v19 + 24) = v81.i16[1];
          *(_WORD *)(v20 + v19 + 40) = v81.i16[2];
          *(_WORD *)(v20 + v19 + 56) = v81.i16[3];
          *(_WORD *)(v20 + v19 + 72) = v81.i16[4];
          *(_WORD *)(v20 + v19 + 88) = v81.i16[5];
          *(_WORD *)(v20 + v19 + 104) = v81.i16[6];
          *(_WORD *)(v20 + v19 + 120) = v81.i16[7];
          v30 = vaddq_s32(v30, v33);
          v19 += 128;
          v29 = vaddq_s32(v29, v33);
        }
        while (v19 != 4096);
        pthread_mutex_unlock(&CMYK64_cacheColorLock);
        goto LABEL_25;
      }
    }
    if (v14)
    {
      *v14 = *(_QWORD *)v12;
      *(_QWORD *)v12 = CMYK64_cacheColor;
      CMYK64_cacheColor = v12;
    }
  }
  pthread_mutex_unlock(&CMYK64_cacheColorLock);
  v13 = v12 + 8;
LABEL_25:
  v82 = *(_QWORD *)v13;
  v83 = *(_QWORD *)(*(_QWORD *)v13 + 4080);
  v84 = *(unsigned __int16 *)(*(_QWORD *)v13 + 4088);
  v86 = *(int *)(a1 + 12);
  v85 = *(int *)(a1 + 16);
  if (v3)
  {
    v87 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v88 = (unsigned __int16 *)(v3 + 2 * (v86 + v87 * v85));
    v89 = 1;
    if (!v605)
      return;
  }
  else
  {
    v88 = 0;
    v87 = 0;
    v89 = 0;
    if (!v605)
      return;
  }
  v90 = v87 - v607;
  if (v3)
    v91 = v87 - v607;
  else
    v91 = v87;
  v92 = (int8x8_t *)(v603 + 8 * (v86 + (v601 >> 3) * v85));
  v93 = *(int *)(a1 + 124);
  v94 = v605 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v93;
  v604 = v93 - v607;
  v606 = (v601 >> 3) - v607;
  switch(a2)
  {
    case 0:
      if (v3)
      {
        v95 = 2 * v89;
        do
        {
          v96 = v607;
          do
          {
            v97 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v97 == 255)
              {
                *v92 = 0;
                *v88 = 0;
              }
              else
              {
                CMYK64_DAM(v92, v88, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), bswap32(*v88) >> 16, v97 ^ 0xFF | ((v97 ^ 0xFF) << 8));
              }
            }
            ++v94;
            ++v92;
            v88 = (unsigned __int16 *)((char *)v88 + v95);
            --v96;
          }
          while (v96);
          v94 += v604;
          v92 += v606;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        v418.i64[0] = 0x100000001;
        v418.i64[1] = 0x100000001;
        do
        {
          v419 = v607;
          do
          {
            v420 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v420 == 255)
              {
                *v92 = 0;
              }
              else
              {
                v421 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v422.i32[0] = (unsigned __int16)v421;
                v422.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v421), 0x10uLL).i32[1];
                v422.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
                v423 = (uint32x4_t)vmulq_s32(v422, vdupq_n_s32((v420 ^ 0xFF | ((v420 ^ 0xFF) << 8)) ^ 0xFFFFu));
                v422.i32[0] = v421;
                *v92 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v422, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v423, v423, 0x10uLL), v418), 0x10uLL))));
              }
            }
            ++v94;
            ++v92;
            --v419;
          }
          while (v419);
          v94 += v604;
          v92 += v606;
          --v10;
        }
        while (v10);
      }
      return;
    case 1:
      v98 = v94 & 3;
      if (!v3)
      {
        v424 = v98 + v607;
        v425 = -1 << (8 * v98);
        if ((v94 & 3) != 0)
          v426 = v94 & 0xFC;
        else
          v426 = v94;
        if ((v94 & 3) != 0)
        {
          v427 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v425 = -1;
          v427 = (unsigned int *)v94;
        }
        if ((v94 & 3) != 0)
          v428 = &v92[-(v94 & 3)];
        else
          v428 = v92;
        if ((v94 & 3) == 0)
          v424 = v607;
        if ((((_BYTE)v424 + v426) & 3) != 0)
        {
          v429 = 4 - (((_BYTE)v424 + v426) & 3);
          v98 += v429;
          v430 = 0xFFFFFFFF >> (8 * v429);
          if (v424 >= 4)
            v431 = v430;
          else
            v431 = 0;
          if (v424 >= 4)
            v430 = -1;
          v425 &= v430;
        }
        else
        {
          v431 = 0;
        }
        v523 = v424 >> 2;
        v524 = bswap32(v83);
        v525 = v604 - v98;
        v526 = bswap32(HIDWORD(v83)) >> 16;
        v527 = __rev16(HIWORD(v83));
        v528.i64[0] = 0x100000001;
        v528.i64[1] = 0x100000001;
        v529 = v606 - v98;
        while (1)
        {
          v530 = *v427 & v425;
          v531 = v523;
          v532 = v431;
          if (!v530)
            goto LABEL_552;
LABEL_534:
          if (v530 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v530)
            {
              if (v530 == 255)
              {
                v428->i16[0] = HIWORD(v524);
                v428->i16[1] = v524;
                v428->i16[2] = v526;
                v428->i16[3] = v527;
              }
              else
              {
                v533 = *(_QWORD *)(v82 + 16 * v530);
                v534 = bswap32(v428->u16[1] | (v428->u16[0] << 16));
                v535.i32[0] = (unsigned __int16)v534;
                v535.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v534), 0x10uLL).i32[1];
                v535.i64[1] = __PAIR64__(bswap32(v428->u16[3]) >> 16, bswap32(v428->u16[2]) >> 16);
                v536 = (uint32x4_t)vmulq_s32(v535, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(v530 | (v530 << 8)))));
                v537.i32[0] = v533;
                v537.i32[1] = WORD1(v533);
                *v428 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v537, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v533), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v536, v536, 0x10uLL), v528), 0x10uLL)));
              }
            }
            if (BYTE1(v530))
            {
              if (BYTE1(v530) == 255)
              {
                v428[1].i16[0] = HIWORD(v524);
                v428[1].i16[1] = v524;
                v428[1].i16[2] = v526;
                v428[1].i16[3] = v527;
              }
              else
              {
                v538 = *(_QWORD *)(v82 + 16 * BYTE1(v530));
                v539 = bswap32(v428[1].u16[1] | (v428[1].u16[0] << 16));
                v540.i32[0] = (unsigned __int16)v539;
                v540.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v539), 0x10uLL).i32[1];
                v540.i64[1] = __PAIR64__(bswap32(v428[1].u16[3]) >> 16, bswap32(v428[1].u16[2]) >> 16);
                v541 = (uint32x4_t)vmulq_s32(v540, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(BYTE1(v530) | (BYTE1(v530) << 8)))));
                v542.i32[0] = v538;
                v542.i32[1] = WORD1(v538);
                v428[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v542, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v538), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v541, v541, 0x10uLL), v528), 0x10uLL)));
              }
            }
            if (BYTE2(v530))
            {
              if (BYTE2(v530) == 255)
              {
                v428[2].i16[0] = HIWORD(v524);
                v428[2].i16[1] = v524;
                v428[2].i16[2] = v526;
                v428[2].i16[3] = v527;
              }
              else
              {
                v543 = *(_QWORD *)(v82 + 16 * BYTE2(v530));
                v544 = bswap32(v428[2].u16[1] | (v428[2].u16[0] << 16));
                v545.i32[0] = (unsigned __int16)v544;
                v545.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v544), 0x10uLL).i32[1];
                v545.i64[1] = __PAIR64__(bswap32(v428[2].u16[3]) >> 16, bswap32(v428[2].u16[2]) >> 16);
                v546 = (uint32x4_t)vmulq_s32(v545, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(BYTE2(v530) | (BYTE2(v530) << 8)))));
                v547.i32[0] = v543;
                v547.i32[1] = WORD1(v543);
                v428[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v547, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v543), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v546, v546, 0x10uLL), v528), 0x10uLL)));
              }
            }
            v548 = HIBYTE(v530);
            if (v548 == 255)
              goto LABEL_549;
            if (v548)
            {
              v549 = v548 | (v548 << 8);
              v550 = *(_QWORD *)(v82 + 16 * v548);
              v551 = bswap32(v428[3].u16[1] | (v428[3].u16[0] << 16));
              v552.i32[0] = (unsigned __int16)v551;
              v552.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v551), 0x10uLL).i32[1];
              v552.i64[1] = __PAIR64__(bswap32(v428[3].u16[3]) >> 16, bswap32(v428[3].u16[2]) >> 16);
              v553 = (uint32x4_t)vmulq_s32(v552, vdupq_n_s32(v549 ^ 0xFFFFu));
              v554.i32[0] = v550;
              v554.i32[1] = WORD1(v550);
              v428[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v554, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v550), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v553, v553, 0x10uLL), v528), 0x10uLL)));
            }
LABEL_552:
            while (1)
            {
              v555 = v531;
              v428 += 4;
              --v531;
              ++v427;
              if (v555 < 2)
                break;
              v530 = *v427;
              if (*v427)
                goto LABEL_534;
            }
            if (!v532)
              break;
            v532 = 0;
            v530 = *v427 & v431;
          }
          v427 = (unsigned int *)((char *)v427 + v525);
          v428 += v529;
          if (!--v10)
            return;
        }
        v428->i16[0] = HIWORD(v524);
        v428->i16[1] = v524;
        v428->i16[2] = v526;
        v428->i16[3] = v527;
        v428[1].i16[0] = HIWORD(v524);
        v428[1].i16[1] = v524;
        v428[1].i16[2] = v526;
        v428[1].i16[3] = v527;
        v428[2].i16[0] = HIWORD(v524);
        v428[2].i16[1] = v524;
        v428[2].i16[2] = v526;
        v428[2].i16[3] = v527;
LABEL_549:
        v428[3].i16[0] = HIWORD(v524);
        v428[3].i16[1] = v524;
        v428[3].i16[2] = v526;
        v428[3].i16[3] = v527;
        goto LABEL_552;
      }
      v99 = -1;
      v100 = v607;
      if ((v94 & 3) != 0)
      {
        v100 = v98 + v607;
        v99 = -1 << (8 * v98);
        v101 = v94 & 3;
        v94 &= 0xFFFFFFFFFFFFFFFCLL;
        v92 -= v101;
        v88 -= v101;
      }
      v102 = ((_BYTE)v100 + (_BYTE)v94) & 3;
      if ((((_BYTE)v100 + (_BYTE)v94) & 3) != 0)
      {
        v103 = 4 - v102;
        v98 += v103;
        v104 = 0xFFFFFFFF >> (8 * v103);
        if (v100 >= 4)
          v102 = 0xFFFFFFFF >> (8 * v103);
        else
          v102 = 0;
        if (v100 >= 4)
          v104 = -1;
        v99 &= v104;
      }
      v105 = bswap32(v83);
      v106 = v604 - v98;
      v107 = v606 - v98;
      v108 = __rev16(HIWORD(v83));
      v109 = __rev16(v84);
      v110 = v90 - v98;
      v111.i64[0] = 0x100000001;
      v111.i64[1] = 0x100000001;
      v112 = bswap32(HIDWORD(v83)) >> 16;
      do
      {
        v113 = *(_DWORD *)v94 & v99;
        v114 = v100 >> 2;
        v115 = v102;
        if (!v113)
          goto LABEL_76;
LABEL_55:
        if (v113 == -1)
        {
          v92->i16[0] = HIWORD(v105);
          v92->i16[1] = v105;
          v92->i16[2] = v112;
          v92->i16[3] = v108;
          *v88 = v109;
          v92[1].i16[0] = HIWORD(v105);
          v92[1].i16[1] = v105;
          v92[1].i16[2] = v112;
          v92[1].i16[3] = v108;
          v88[1] = v109;
          v92[2].i16[0] = HIWORD(v105);
          v92[2].i16[1] = v105;
          v92[2].i16[2] = v112;
          v92[2].i16[3] = v108;
          v88[2] = v109;
LABEL_73:
          v92[3].i16[0] = HIWORD(v105);
          v92[3].i16[1] = v105;
          v92[3].i16[2] = v112;
          v92[3].i16[3] = v108;
          v88[3] = v109;
          goto LABEL_76;
        }
        while (1)
        {
          if ((_BYTE)v113)
          {
            if (v113 == 255)
            {
              v92->i16[0] = HIWORD(v105);
              v92->i16[1] = v105;
              v92->i16[2] = v112;
              LOWORD(v116) = v109;
              v92->i16[3] = v108;
            }
            else
            {
              v117 = v113 | (v113 << 8);
              v118 = v82 + 16 * v113;
              v119 = *(_QWORD *)v118;
              LODWORD(v118) = *(unsigned __int16 *)(v118 + 8);
              v120 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
              v121.i32[0] = (unsigned __int16)v120;
              v121.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v120), 0x10uLL).i32[1];
              v122 = ~v117;
              v123 = (unsigned __int16)~(_WORD)v117 * (bswap32(*v88) >> 16);
              v121.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
              v124 = (uint32x4_t)vmulq_s32(v121, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v122)));
              v125.i32[0] = v119;
              v125.i32[1] = WORD1(v119);
              *v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v125, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v119), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v124, v124, 0x10uLL), v111), 0x10uLL)));
              v116 = bswap32(v118 + ((v123 + HIWORD(v123) + 1) >> 16)) >> 16;
            }
            *v88 = v116;
          }
          if (BYTE1(v113))
          {
            if (BYTE1(v113) == 255)
            {
              v92[1].i16[0] = HIWORD(v105);
              v92[1].i16[1] = v105;
              v92[1].i16[2] = v112;
              LOWORD(v126) = v109;
              v92[1].i16[3] = v108;
            }
            else
            {
              v127 = BYTE1(v113) | (BYTE1(v113) << 8);
              v128 = v82 + 16 * BYTE1(v113);
              v129 = *(_QWORD *)v128;
              LODWORD(v128) = *(unsigned __int16 *)(v128 + 8);
              v130 = bswap32(v92[1].u16[1] | (v92[1].u16[0] << 16));
              v131.i32[0] = (unsigned __int16)v130;
              v131.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v130), 0x10uLL).i32[1];
              v132 = ~v127;
              v133 = (unsigned __int16)~(_WORD)v127 * (bswap32(v88[1]) >> 16);
              v131.i64[1] = __PAIR64__(bswap32(v92[1].u16[3]) >> 16, bswap32(v92[1].u16[2]) >> 16);
              v134 = (uint32x4_t)vmulq_s32(v131, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v132)));
              v135.i32[0] = v129;
              v135.i32[1] = WORD1(v129);
              v92[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v135, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v129), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v134, v134, 0x10uLL), v111), 0x10uLL)));
              v126 = bswap32(v128 + ((v133 + HIWORD(v133) + 1) >> 16)) >> 16;
            }
            v88[1] = v126;
          }
          if (BYTE2(v113))
          {
            if (BYTE2(v113) == 255)
            {
              v92[2].i16[0] = HIWORD(v105);
              v92[2].i16[1] = v105;
              v92[2].i16[2] = v112;
              LOWORD(v136) = v109;
              v92[2].i16[3] = v108;
            }
            else
            {
              v137 = BYTE2(v113) | (BYTE2(v113) << 8);
              v138 = v82 + 16 * BYTE2(v113);
              v139 = *(_QWORD *)v138;
              LODWORD(v138) = *(unsigned __int16 *)(v138 + 8);
              v140 = bswap32(v92[2].u16[1] | (v92[2].u16[0] << 16));
              v141.i32[0] = (unsigned __int16)v140;
              v141.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v140), 0x10uLL).i32[1];
              v142 = ~v137;
              v143 = (unsigned __int16)~(_WORD)v137 * (bswap32(v88[2]) >> 16);
              v141.i64[1] = __PAIR64__(bswap32(v92[2].u16[3]) >> 16, bswap32(v92[2].u16[2]) >> 16);
              v144 = (uint32x4_t)vmulq_s32(v141, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v142)));
              v145.i32[0] = v139;
              v145.i32[1] = WORD1(v139);
              v92[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v145, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v139), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v144, v144, 0x10uLL), v111), 0x10uLL)));
              v136 = bswap32(v138 + ((v143 + HIWORD(v143) + 1) >> 16)) >> 16;
            }
            v88[2] = v136;
          }
          v146 = HIBYTE(v113);
          if (v146 == 255)
            goto LABEL_73;
          if (v146)
          {
            v147 = v146 | (v146 << 8);
            v148 = v82 + 16 * v146;
            v149 = *(_QWORD *)v148;
            LODWORD(v148) = *(unsigned __int16 *)(v148 + 8);
            v150 = bswap32(v92[3].u16[1] | (v92[3].u16[0] << 16));
            v147 ^= 0xFFFFu;
            v151.i32[0] = (unsigned __int16)v150;
            v151.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v150), 0x10uLL).i32[1];
            v152 = v147 * (bswap32(v88[3]) >> 16);
            v151.i64[1] = __PAIR64__(bswap32(v92[3].u16[3]) >> 16, bswap32(v92[3].u16[2]) >> 16);
            v153 = (uint32x4_t)vmulq_s32(v151, vdupq_n_s32(v147));
            v154.i32[0] = v149;
            v154.i32[1] = WORD1(v149);
            v92[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v154, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v149), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v153, v153, 0x10uLL), v111), 0x10uLL)));
            v88[3] = bswap32(v148 + ((v152 + HIWORD(v152) + 1) >> 16)) >> 16;
          }
LABEL_76:
          while (1)
          {
            v155 = v114;
            v92 += 4;
            v88 += 4;
            --v114;
            v94 += 4;
            if (v155 < 2)
              break;
            v113 = *(_DWORD *)v94;
            if (*(_DWORD *)v94)
              goto LABEL_55;
          }
          if (!v115)
            break;
          v115 = 0;
          v113 = *(_DWORD *)v94 & v102;
        }
        v94 += v106;
        v92 += v107;
        v88 += v110;
        --v10;
      }
      while (v10);
      return;
    case 2:
      v156 = v94 & 3;
      if (v3)
      {
        v157 = -1 << (8 * v156);
        v158 = &v92[-(v94 & 3)];
        if ((v94 & 3) != 0)
          v159 = v94 & 0xFC;
        else
          v159 = v94;
        if ((v94 & 3) != 0)
        {
          v160 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v157 = -1;
          v160 = (unsigned int *)v94;
        }
        if ((v94 & 3) != 0)
          v161 = &v88[-(v94 & 3)];
        else
          v161 = v88;
        if ((v94 & 3) != 0)
        {
          v162 = v156 + v607;
        }
        else
        {
          v158 = v92;
          v162 = v607;
        }
        if ((((_BYTE)v162 + v159) & 3) != 0)
        {
          v163 = 4 - (((_BYTE)v162 + v159) & 3);
          v156 += v163;
          v164 = 0xFFFFFFFF >> (8 * v163);
          if (v162 >= 4)
            v165 = -1;
          else
            v165 = 0xFFFFFFFF >> (8 * v163);
          v157 &= v165;
          if (v162 < 4)
            v164 = 0;
        }
        else
        {
          v164 = 0;
        }
        v465 = v604 - v156;
        v466 = v606 - v156;
        v467 = v90 - v156;
        v468 = v162 >> 2;
        v469 = (unsigned __int16)~(_WORD)v84;
        v470 = vdupq_n_s32(v469);
        v471.i32[0] = *(_QWORD *)(*(_QWORD *)v13 + 4080);
        v471.i32[1] = WORD1(v83);
        v472 = (uint32x4_t)vmovn_hight_s64(v471, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v83), (uint64x2_t)xmmword_185004DA0));
        v473.i64[0] = 0x100000001;
        v473.i64[1] = 0x100000001;
        while (1)
        {
          v474 = *v160 & v157;
          v475 = v164;
          v476 = v468;
          if (!v474)
            goto LABEL_524;
LABEL_513:
          if (v474 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v474)
            {
              v493 = v82 + 16 * v474;
              v494 = *(_QWORD *)v493;
              LODWORD(v493) = *(unsigned __int16 *)(v493 + 8);
              v495 = bswap32(v158->u16[1] | (v158->u16[0] << 16));
              v496.i32[0] = (unsigned __int16)v495;
              v496.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v495), 0x10uLL).i32[1];
              v497 = (unsigned __int16)~(_WORD)v493 * (bswap32(*v161) >> 16);
              v496.i64[1] = __PAIR64__(bswap32(v158->u16[3]) >> 16, bswap32(v158->u16[2]) >> 16);
              v498 = (uint32x4_t)vmulq_s32(v496, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(_DWORD)v493)));
              v499.i32[0] = v494;
              v499.i32[1] = WORD1(v494);
              *v158 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v499, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v494), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v498, v498, 0x10uLL), v473), 0x10uLL)));
              *v161 = bswap32(v493 + ((v497 + HIWORD(v497) + 1) >> 16)) >> 16;
            }
            if ((v474 & 0xFF00) != 0)
            {
              v500 = v82 + 16 * BYTE1(v474);
              v501 = *(_QWORD *)v500;
              LODWORD(v500) = *(unsigned __int16 *)(v500 + 8);
              v502 = bswap32(v158[1].u16[1] | (v158[1].u16[0] << 16));
              v503.i32[0] = (unsigned __int16)v502;
              v503.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v502), 0x10uLL).i32[1];
              v504 = (unsigned __int16)~(_WORD)v500 * (bswap32(v161[1]) >> 16);
              v503.i64[1] = __PAIR64__(bswap32(v158[1].u16[3]) >> 16, bswap32(v158[1].u16[2]) >> 16);
              v505 = (uint32x4_t)vmulq_s32(v503, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(_DWORD)v500)));
              v506.i32[0] = v501;
              v506.i32[1] = WORD1(v501);
              v158[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v506, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v501), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v505, v505, 0x10uLL), v473), 0x10uLL)));
              v161[1] = bswap32(v500 + ((v504 + HIWORD(v504) + 1) >> 16)) >> 16;
            }
            if ((v474 & 0xFF0000) != 0)
            {
              v507 = v82 + 16 * BYTE2(v474);
              v508 = *(_QWORD *)v507;
              LODWORD(v507) = *(unsigned __int16 *)(v507 + 8);
              v509 = bswap32(v158[2].u16[1] | (v158[2].u16[0] << 16));
              v510.i32[0] = (unsigned __int16)v509;
              v510.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v509), 0x10uLL).i32[1];
              v511 = (unsigned __int16)~(_WORD)v507 * (bswap32(v161[2]) >> 16);
              v510.i64[1] = __PAIR64__(bswap32(v158[2].u16[3]) >> 16, bswap32(v158[2].u16[2]) >> 16);
              v512 = (uint32x4_t)vmulq_s32(v510, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(_DWORD)v507)));
              v513.i32[0] = v508;
              v513.i32[1] = WORD1(v508);
              v158[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v513, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v508), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v512, v512, 0x10uLL), v473), 0x10uLL)));
              v161[2] = bswap32(v507 + ((v511 + HIWORD(v511) + 1) >> 16)) >> 16;
            }
            v514 = HIBYTE(v474);
            if (v514)
            {
              v515 = v82 + 16 * v514;
              v516 = *(_QWORD *)v515;
              v492 = *(unsigned __int16 *)(v515 + 8);
              v517 = bswap32(v158[3].u16[1] | (v158[3].u16[0] << 16));
              v518.i32[0] = (unsigned __int16)v517;
              v518.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v517), 0x10uLL).i32[1];
              v519 = (unsigned __int16)~(_WORD)v492 * (bswap32(v161[3]) >> 16);
              v518.i64[1] = __PAIR64__(bswap32(v158[3].u16[3]) >> 16, bswap32(v158[3].u16[2]) >> 16);
              v489 = v519 + HIWORD(v519) + 1;
              v520 = (uint32x4_t)vmulq_s32(v518, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v492)));
              v521 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v520, v520, 0x10uLL), v473);
              v520.i32[0] = v516;
              v520.i32[1] = WORD1(v516);
              v491 = (int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v520.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v516), (uint64x2_t)xmmword_185004DA0)), v521, 0x10uLL);
              goto LABEL_523;
            }
LABEL_524:
            while (1)
            {
              v522 = v476;
              v158 += 4;
              v161 += 4;
              --v476;
              ++v160;
              if (v522 < 2)
                break;
              v474 = *v160;
              if (*v160)
                goto LABEL_513;
            }
            if (!v475)
              break;
            v475 = 0;
            v474 = *v160 & v164;
          }
          v160 = (unsigned int *)((char *)v160 + v465);
          v158 += v466;
          v161 += v467;
          if (!--v10)
            return;
        }
        v477 = bswap32(v158->u16[1] | (v158->u16[0] << 16));
        v478 = bswap32(*v161);
        v479.i32[0] = (unsigned __int16)v477;
        v479.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v477), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v479.i32[2] = bswap32(v158->u16[2]) >> 16;
        v479.i32[3] = bswap32(v158->u16[3]) >> 16;
        v480 = (uint32x4_t)vmulq_s32(v479, v470);
        *v158 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v472, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v480, v480, 0x10uLL), v473), 0x10uLL)));
        *v161 = bswap32(v84 + ((v469 * HIWORD(v478) + ((v469 * HIWORD(v478)) >> 16) + 1) >> 16)) >> 16;
        v481 = bswap32(v158[1].u16[1] | (v158[1].u16[0] << 16));
        v482 = bswap32(v161[1]);
        v479.i32[0] = (unsigned __int16)v481;
        v479.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v481), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v479.i32[2] = bswap32(v158[1].u16[2]) >> 16;
        v479.i32[3] = bswap32(v158[1].u16[3]) >> 16;
        v483 = (uint32x4_t)vmulq_s32(v479, v470);
        v158[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v472, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v483, v483, 0x10uLL), v473), 0x10uLL)));
        v161[1] = bswap32(v84 + ((v469 * HIWORD(v482) + ((v469 * HIWORD(v482)) >> 16) + 1) >> 16)) >> 16;
        v484 = bswap32(v158[2].u16[1] | (v158[2].u16[0] << 16));
        v485 = bswap32(v161[2]);
        v479.i32[0] = (unsigned __int16)v484;
        v479.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v484), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v479.i32[2] = bswap32(v158[2].u16[2]) >> 16;
        v479.i32[3] = bswap32(v158[2].u16[3]) >> 16;
        v486 = (uint32x4_t)vmulq_s32(v479, v470);
        v158[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v472, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v486, v486, 0x10uLL), v473), 0x10uLL)));
        v161[2] = bswap32(v84 + ((v469 * HIWORD(v485) + ((v469 * HIWORD(v485)) >> 16) + 1) >> 16)) >> 16;
        v487 = bswap32(v158[3].u16[1] | (v158[3].u16[0] << 16));
        v488 = bswap32(v161[3]);
        v479.i32[0] = (unsigned __int16)v487;
        v479.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v487), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v489 = v469 * HIWORD(v488) + ((v469 * HIWORD(v488)) >> 16) + 1;
        v479.i64[1] = __PAIR64__(bswap32(v158[3].u16[3]) >> 16, bswap32(v158[3].u16[2]) >> 16);
        v490 = (uint32x4_t)vmulq_s32(v479, v470);
        v491 = (int32x4_t)vsraq_n_u32(v472, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v490, v490, 0x10uLL), v473), 0x10uLL);
        v492 = v84;
LABEL_523:
        v158[3] = vrev16_s8((int8x8_t)vmovn_s32(v491));
        v161[3] = bswap32(v492 + HIWORD(v489)) >> 16;
        goto LABEL_524;
      }
      v432 = -1 << (8 * v156);
      if ((v94 & 3) != 0)
        v433 = v94 & 0xFC;
      else
        v433 = v94;
      if ((v94 & 3) != 0)
      {
        v434 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        v432 = -1;
        v434 = (unsigned int *)v94;
      }
      if ((v94 & 3) != 0)
        v435 = &v92[-(v94 & 3)];
      else
        v435 = v92;
      if ((v94 & 3) != 0)
        v436 = v156 + v607;
      else
        v436 = v607;
      if ((((_BYTE)v436 + v433) & 3) != 0)
      {
        v437 = 4 - (((_BYTE)v436 + v433) & 3);
        v156 += v437;
        v438 = 0xFFFFFFFF >> (8 * v437);
        if (v436 >= 4)
          v439 = -1;
        else
          v439 = 0xFFFFFFFF >> (8 * v437);
        v432 &= v439;
        if (v436 < 4)
          v438 = 0;
      }
      else
      {
        v438 = 0;
      }
      v556 = v604 - v156;
      v557 = v606 - v156;
      v558 = v436 >> 2;
      v559 = vdupq_n_s32((unsigned __int16)~(_WORD)v84);
      v560.i32[0] = *(_QWORD *)(*(_QWORD *)v13 + 4080);
      v560.i32[1] = WORD1(v83);
      v561 = (uint32x4_t)vmovn_hight_s64(v560, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v83), (uint64x2_t)xmmword_185004DA0));
      v562.i64[0] = 0x100000001;
      v562.i64[1] = 0x100000001;
      while (1)
      {
        v563 = *v434 & v432;
        v564 = v438;
        v565 = v558;
        if (!v563)
          goto LABEL_573;
LABEL_562:
        if (v563 == -1)
          break;
        while (1)
        {
          if ((_BYTE)v563)
          {
            v580 = v82 + 16 * v563;
            v581 = bswap32(v435->u16[1] | (v435->u16[0] << 16));
            v582.i32[0] = (unsigned __int16)v581;
            v582.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v581), 0x10uLL).i32[1];
            v582.i64[1] = __PAIR64__(bswap32(v435->u16[3]) >> 16, bswap32(v435->u16[2]) >> 16);
            v583 = (uint32x4_t)vmulq_s32(v582, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v580 + 8))));
            v584.i32[0] = *(_QWORD *)v580;
            v584.i32[1] = v584.u16[1];
            *v435 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v584, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v580), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v583, v583, 0x10uLL), v562), 0x10uLL)));
          }
          if ((v563 & 0xFF00) != 0)
          {
            v585 = v82 + 16 * BYTE1(v563);
            v586 = bswap32(v435[1].u16[1] | (v435[1].u16[0] << 16));
            v587.i32[0] = (unsigned __int16)v586;
            v587.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v586), 0x10uLL).i32[1];
            v587.i64[1] = __PAIR64__(bswap32(v435[1].u16[3]) >> 16, bswap32(v435[1].u16[2]) >> 16);
            v588 = (uint32x4_t)vmulq_s32(v587, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v585 + 8))));
            v589.i32[0] = *(_QWORD *)v585;
            v589.i32[1] = v589.u16[1];
            v435[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v589, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v585), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v588, v588, 0x10uLL), v562), 0x10uLL)));
          }
          if ((v563 & 0xFF0000) != 0)
          {
            v590 = v82 + 16 * BYTE2(v563);
            v591 = bswap32(v435[2].u16[1] | (v435[2].u16[0] << 16));
            v592.i32[0] = (unsigned __int16)v591;
            v592.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v591), 0x10uLL).i32[1];
            v592.i64[1] = __PAIR64__(bswap32(v435[2].u16[3]) >> 16, bswap32(v435[2].u16[2]) >> 16);
            v593 = (uint32x4_t)vmulq_s32(v592, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v590 + 8))));
            v594.i32[0] = *(_QWORD *)v590;
            v594.i32[1] = v594.u16[1];
            v435[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v594, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v590), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v593, v593, 0x10uLL), v562), 0x10uLL)));
          }
          v595 = HIBYTE(v563);
          if (v595)
          {
            v596 = v82 + 16 * v595;
            v597 = bswap32(v435[3].u16[1] | (v435[3].u16[0] << 16));
            v598.i32[0] = (unsigned __int16)v597;
            v598.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v597), 0x10uLL).i32[1];
            v598.i64[1] = __PAIR64__(bswap32(v435[3].u16[3]) >> 16, bswap32(v435[3].u16[2]) >> 16);
            v599 = (uint32x4_t)vmulq_s32(v598, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v596 + 8))));
            v578 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v599, v599, 0x10uLL), v562);
            v599.i32[0] = *(_QWORD *)v596;
            v599.i32[1] = v599.u16[1];
            v579 = (uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v599.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(_QWORD *)v596), (uint64x2_t)xmmword_185004DA0));
            goto LABEL_572;
          }
LABEL_573:
          while (1)
          {
            v600 = v565;
            v435 += 4;
            --v565;
            ++v434;
            if (v600 < 2)
              break;
            v563 = *v434;
            if (*v434)
              goto LABEL_562;
          }
          if (!v564)
            break;
          v564 = 0;
          v563 = *v434 & v438;
        }
        v434 = (unsigned int *)((char *)v434 + v556);
        v435 += v557;
        if (!--v10)
          return;
      }
      v566 = bswap32(v435->u16[1] | (v435->u16[0] << 16));
      v567.i32[0] = (unsigned __int16)v566;
      v567.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v566), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v567.i32[2] = bswap32(v435->u16[2]) >> 16;
      v567.i32[3] = bswap32(v435->u16[3]) >> 16;
      v568 = (uint32x4_t)vmulq_s32(v567, v559);
      v569 = (int32x4_t)vsraq_n_u32(v561, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v568, v568, 0x10uLL), v562), 0x10uLL);
      v570 = bswap32(v435[1].u16[1] | (v435[1].u16[0] << 16));
      v571.i32[0] = (unsigned __int16)v570;
      v571.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v570), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v571.i32[2] = bswap32(v435[1].u16[2]) >> 16;
      v571.i32[3] = bswap32(v435[1].u16[3]) >> 16;
      v572 = (uint32x4_t)vmulq_s32(v571, v559);
      v573 = bswap32(v435[2].u16[1] | (v435[2].u16[0] << 16));
      v574.i32[0] = (unsigned __int16)v573;
      v574.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v573), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v574.i32[2] = bswap32(v435[2].u16[2]) >> 16;
      v574.i32[3] = bswap32(v435[2].u16[3]) >> 16;
      *v435 = vrev16_s8((int8x8_t)vmovn_s32(v569));
      v435[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v561, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v572, v572, 0x10uLL), v562), 0x10uLL)));
      v575 = (uint32x4_t)vmulq_s32(v574, v559);
      v576 = bswap32(v435[3].u16[1] | (v435[3].u16[0] << 16));
      v571.i32[0] = (unsigned __int16)v576;
      v571.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v576), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v571.i64[1] = __PAIR64__(bswap32(v435[3].u16[3]) >> 16, bswap32(v435[3].u16[2]) >> 16);
      v435[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v561, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v575, v575, 0x10uLL), v562), 0x10uLL)));
      v577 = (uint32x4_t)vmulq_s32(v571, v559);
      v578 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v577, v577, 0x10uLL), v562);
      v579 = v561;
LABEL_572:
      v435[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v579, v578, 0x10uLL)));
      goto LABEL_573;
    case 3:
      v166 = 2 * v89;
      v167.i64[0] = 0x100000001;
      v167.i64[1] = 0x100000001;
      do
      {
        v168 = v607;
        do
        {
          v169 = *(unsigned __int8 *)v94;
          if (*(_BYTE *)v94)
          {
            if (v169 == 255)
            {
              v170 = (unint64_t *)(v82 + 16 * *(unsigned __int8 *)v88);
              v171 = *v170;
              v172 = *((unsigned __int16 *)v170 + 4);
              v173 = HIDWORD(v171);
              v174 = HIWORD(v171);
              LODWORD(v171) = bswap32(v171);
              v92->i16[0] = WORD1(v171);
              v92->i16[1] = v171;
              v92->i16[2] = bswap32(v173) >> 16;
              v92->i16[3] = __rev16(v174);
            }
            else
            {
              v175 = v169 | (v169 << 8);
              v176 = bswap32(*v88) >> 16;
              v177 = v82 + 16 * ((v176 * v175 + ((v176 * v175) >> 16) + 1) >> 24);
              v178 = *(_QWORD *)v177;
              LODWORD(v177) = *(unsigned __int16 *)(v177 + 8);
              v179 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
              v180.i32[0] = (unsigned __int16)v179;
              v180.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v179), 0x10uLL).i32[1];
              v180.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
              v181 = (uint32x4_t)vmulq_s32(v180, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v175)));
              v182.i32[0] = v178;
              v182.i32[1] = WORD1(v178);
              *v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v182, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v178), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v181, v181, 0x10uLL), v167), 0x10uLL)));
              v172 = v177
                   + (((unsigned __int16)~(_WORD)v175 * v176 + (((unsigned __int16)~(_WORD)v175 * v176) >> 16) + 1) >> 16);
            }
            *v88 = bswap32(v172) >> 16;
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v166);
          --v168;
        }
        while (v168);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 4:
      v183 = 2 * v89;
      v184.i64[0] = 0x100000001;
      v184.i64[1] = 0x100000001;
      do
      {
        v185 = v607;
        do
        {
          v186 = *(unsigned __int8 *)v94;
          if (*(_BYTE *)v94)
          {
            if (v186 == 255)
            {
              v187 = (unint64_t *)(v82 + 16 * ~*(_BYTE *)v88);
              v188 = *v187;
              v189 = *((unsigned __int16 *)v187 + 4);
              v190 = HIDWORD(v188);
              v191 = HIWORD(v188);
              LODWORD(v188) = bswap32(v188);
              v92->i16[0] = WORD1(v188);
              v92->i16[1] = v188;
              v92->i16[2] = bswap32(v190) >> 16;
              v92->i16[3] = __rev16(v191);
            }
            else
            {
              v192 = v186 | (v186 << 8);
              v193 = bswap32(*v88) >> 16;
              v194 = v82 + 16 * (((v193 ^ 0xFFFF) * v192 + (((v193 ^ 0xFFFF) * v192) >> 16) + 1) >> 24);
              v195 = *(_QWORD *)v194;
              LODWORD(v194) = *(unsigned __int16 *)(v194 + 8);
              v196 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
              v197.i32[0] = (unsigned __int16)v196;
              v197.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v196), 0x10uLL).i32[1];
              v197.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
              v198 = (uint32x4_t)vmulq_s32(v197, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v192)));
              v199.i32[0] = v195;
              v199.i32[1] = WORD1(v195);
              *v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v199, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v195), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v198, v198, 0x10uLL), v184), 0x10uLL)));
              v189 = v194
                   + (((unsigned __int16)~(_WORD)v192 * v193 + (((unsigned __int16)~(_WORD)v192 * v193) >> 16) + 1) >> 16);
            }
            *v88 = bswap32(v189) >> 16;
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v183);
          --v185;
        }
        while (v185);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 5:
      v200 = 2 * v89;
      do
      {
        v201 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v202 = v82 + 16 * *(unsigned __int8 *)v94;
            v203 = bswap32(*v88) >> 16;
            CMYK64_DAMplusDAM(v92, v88, *(_QWORD *)v202, *(unsigned __int16 *)(v202 + 8), v203, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v203, *(unsigned __int16 *)(v202 + 8) ^ 0xFFFF);
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v200);
          --v201;
        }
        while (v201);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 6:
      v204 = 2 * v89;
      v205.i64[0] = 0x100000001;
      v205.i64[1] = 0x100000001;
      do
      {
        v206 = v607;
        do
        {
          v207 = *(unsigned __int8 *)v94;
          if (*(_BYTE *)v94)
          {
            v208 = bswap32(*v88);
            if (HIWORD(v208) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v208) == 0xFFFF)
              {
                v209 = (unint64_t *)(v82 + 16 * v207);
                v210 = *v209;
                v211 = *((unsigned __int16 *)v209 + 4);
                v212 = HIDWORD(v210);
                v213 = HIWORD(v210);
                LODWORD(v210) = bswap32(v210);
                v92->i16[0] = WORD1(v210);
                v92->i16[1] = v210;
                v92->i16[2] = bswap32(v212) >> 16;
                v92->i16[3] = __rev16(v213);
              }
              else
              {
                v214 = HIWORD(v208);
                v215 = ~HIWORD(v208);
                v216 = (int32x2_t *)(v82 + 16 * v207);
                v217 = (unsigned __int16)WORD2(*(unint64_t *)v216);
                v218 = HIWORD(*(unint64_t *)v216);
                *(int32x2_t *)v219.i8 = *v216;
                v220 = ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16);
                v219.i16[1] = 0;
                v219.i32[1] = vshr_n_u32((uint32x2_t)vdup_lane_s32(*v216, 0), 0x10uLL).i32[1];
                LODWORD(v216) = (unsigned __int16)v215 * v216[1].u16[0];
                v219.i64[1] = __PAIR64__(v218, v217);
                v221 = (uint32x4_t)vmulq_s32(v219, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v215)));
                v222.i32[0] = v220;
                v222.i32[1] = WORD1(v220);
                *v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v222, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v220), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v221, v221, 0x10uLL), v205), 0x10uLL)));
                v211 = v214 + ((v216 + (v216 >> 16) + 1) >> 16);
              }
              *v88 = bswap32(v211) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v204);
          --v206;
        }
        while (v206);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 7:
      if (v3)
      {
        v223 = 2 * v89;
        do
        {
          v224 = v607;
          do
          {
            v225 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              v226 = ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16);
              v227 = bswap32(*v88) >> 16;
              if (v225 == 255)
              {
                v228 = v92;
                v229 = v88;
                v230 = v84;
              }
              else
              {
                v230 = (unsigned __int16)(~(v225 | ((_WORD)v225 << 8))
                                        + (((v225 | (v225 << 8)) * v84 + (((v225 | (v225 << 8)) * v84) >> 16) + 1) >> 16));
                v228 = v92;
                v229 = v88;
              }
              CMYK64_DAM(v228, v229, v226, v227, v230);
            }
            ++v94;
            ++v92;
            v88 = (unsigned __int16 *)((char *)v88 + v223);
            --v224;
          }
          while (v224);
          v94 += v604;
          v92 += v606;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        v440 = vdupq_n_s32(v84 ^ 0xFFFF);
        v441.i64[0] = 0x100000001;
        v441.i64[1] = 0x100000001;
        do
        {
          v442 = v607;
          do
          {
            v443 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v443 == 255)
              {
                v444 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v445.i32[0] = (unsigned __int16)v444;
                v445.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v444), 0x10uLL).i32[1];
                v445.i32[2] = bswap32(v92->u16[2]) >> 16;
                v445.i32[3] = bswap32(v92->u16[3]) >> 16;
                v446 = (uint32x4_t)vmulq_s32(v445, v440);
                v445.i32[0] = v444;
                v447 = vsubq_s32(v445, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v446, v446, 0x10uLL), v441), 0x10uLL));
              }
              else
              {
                v448 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v449.i32[0] = (unsigned __int16)v448;
                v449.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v448), 0x10uLL).i32[1];
                v449.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
                v450 = (uint32x4_t)vmulq_s32(v449, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((v443 | (v443 << 8))- (((v443 | (v443 << 8)) * v84+ (((v443 | (v443 << 8)) * v84) >> 16)+ 1) >> 16))));
                v449.i32[0] = v448;
                v447 = vsubq_s32(v449, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v450, v450, 0x10uLL), v441), 0x10uLL));
              }
              *v92 = vrev16_s8((int8x8_t)vmovn_s32(v447));
            }
            ++v94;
            ++v92;
            --v442;
          }
          while (v442);
          v94 += v604;
          v92 += v606;
          --v10;
        }
        while (v10);
      }
      return;
    case 8:
      v231 = 257 * v84;
      if (v3)
      {
        v232 = 2 * v89;
        v233 = (unsigned __int16)~(_WORD)v84;
        do
        {
          v234 = v607;
          do
          {
            v235 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              v236 = ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16);
              v237 = bswap32(*v88) >> 16;
              if (v235 == 255)
              {
                v238 = v92;
                v239 = v88;
                v240 = v233;
              }
              else
              {
                v240 = ~(v231 * v235 + ((v231 * v235) >> 16) + 1) >> 16;
                v238 = v92;
                v239 = v88;
              }
              CMYK64_DAM(v238, v239, v236, v237, v240);
            }
            ++v94;
            ++v92;
            v88 = (unsigned __int16 *)((char *)v88 + v232);
            --v234;
          }
          while (v234);
          v94 += v604;
          v92 += v606;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        v451 = vdupq_n_s32(v84);
        v452.i64[0] = 0x100000001;
        v452.i64[1] = 0x100000001;
        do
        {
          v453 = v607;
          do
          {
            v454 = *(unsigned __int8 *)v94;
            if (*(_BYTE *)v94)
            {
              if (v454 == 255)
              {
                v455 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v456 = v455;
                v457 = 0;
                v460.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v455), 0x10uLL).i32[1];
                v460.i32[2] = bswap32(v92->u16[2]) >> 16;
                v460.i32[3] = bswap32(v92->u16[3]) >> 16;
                v458 = (uint32x4_t)vmulq_s32(v460, v451);
                v459 = (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v458, v458, 0x10uLL), v452), 0x10uLL);
                v460.i32[0] = v455;
              }
              else
              {
                v461 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v462 = v461;
                v463 = 0;
                v460.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v461), 0x10uLL).i32[1];
                v460.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
                v464 = (uint32x4_t)vmulq_s32(v460, vdupq_n_s32((v231 * v454 + ((v231 * v454) >> 16) + 1) >> 16));
                v459 = (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v464, v464, 0x10uLL), v452), 0x10uLL);
                v460.i32[0] = v461;
              }
              *v92 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v460, v459)));
            }
            ++v94;
            ++v92;
            --v453;
          }
          while (v453);
          v94 += v604;
          v92 += v606;
          --v10;
        }
        while (v10);
      }
      return;
    case 9:
      v241 = 2 * v89;
      do
      {
        v242 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v243 = bswap32(*v88) >> 16;
            v244 = v82 + 16 * *(unsigned __int8 *)v94;
            CMYK64_DAMplusDAM(v92, v88, *(_QWORD *)v244, *(unsigned __int16 *)(v244 + 8), v243 ^ 0xFFFF, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v243, (unsigned __int16)(*(_WORD *)(v244 + 8) + ~(*(unsigned __int8 *)v94 | (*(unsigned __int8 *)v94 << 8))));
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v241);
          --v242;
        }
        while (v242);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 10:
      v245 = 2 * v89;
      do
      {
        v246 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v247 = bswap32(*v88) >> 16;
            v248 = v82 + 16 * *(unsigned __int8 *)v94;
            CMYK64_DAMplusDAM(v92, v88, *(_QWORD *)v248, *(unsigned __int16 *)(v248 + 8), v247 ^ 0xFFFF, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v247, *(unsigned __int16 *)(v248 + 8) ^ 0xFFFF);
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v245);
          --v246;
        }
        while (v246);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 11:
      if (v3)
      {
        v249 = 2 * v89;
        do
        {
          v250 = v607;
          do
          {
            if (*(_BYTE *)v94)
              CMYK64_DAplusdDA((int *)v92, v88, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), bswap32(*v88) >> 16, *(_QWORD *)(v82 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v82 + 16 * *(unsigned __int8 *)v94 + 8));
            ++v94;
            ++v92;
            v88 = (unsigned __int16 *)((char *)v88 + v249);
            --v250;
          }
          while (v250);
          v94 += v604;
          v92 += v606;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v251 = v607;
          do
          {
            if (*(_BYTE *)v94)
              CMYK64_DplusdDA(v92, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), *(_QWORD *)(v82 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v82 + 16 * *(unsigned __int8 *)v94 + 8));
            ++v94;
            ++v92;
            --v251;
          }
          while (v251);
          v94 += v604;
          v92 += v606;
          --v10;
        }
        while (v10);
      }
      return;
    case 12:
      if (v3)
      {
        v252 = 2 * v89;
        do
        {
          v253 = v607;
          do
          {
            if (*(_BYTE *)v94)
              CMYK64_DApluslDA((unsigned int *)v92, v88, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), bswap32(*v88) >> 16, *(_QWORD *)(v82 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v82 + 16 * *(unsigned __int8 *)v94 + 8));
            ++v94;
            ++v92;
            v88 = (unsigned __int16 *)((char *)v88 + v252);
            --v253;
          }
          while (v253);
          v94 += v604;
          v92 += v606;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v254 = v607;
          do
          {
            if (*(_BYTE *)v94)
              CMYK64_DpluslD(v92, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), *(_QWORD *)(v82 + 16 * *(unsigned __int8 *)v94));
            ++v94;
            ++v92;
            --v254;
          }
          while (v254);
          v94 += v604;
          v92 += v606;
          --v10;
        }
        while (v10);
      }
      return;
    case 13:
      v255 = 2 * v89;
      while (1)
      {
        v256 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v257 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v258) = *(unsigned __int16 *)(v257 + 8);
            if (*(_WORD *)(v257 + 8))
            {
              v259 = *(_QWORD *)v257;
              if (v3)
              {
                if (*v88)
                {
                  v260 = __rev16(*v88);
                  goto LABEL_213;
                }
LABEL_215:
                v264 = bswap32(v259);
                v92->i16[0] = HIWORD(v264);
                v92->i16[1] = v264;
                v92->i16[2] = bswap32(HIDWORD(v259)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v259));
                v261 = v88;
              }
              else
              {
                v260 = 0xFFFF;
LABEL_213:
                v261 = (unsigned __int16 *)v92 + 3;
                v262 = PDAmultiplyPDA_10646(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v260, v259, v258);
                v259 = v262;
                if (v3)
                {
                  LODWORD(v258) = v263;
                  goto LABEL_215;
                }
                v258 = HIWORD(v262);
                v265 = bswap32(v262);
                v92->i16[0] = HIWORD(v265);
                v92->i16[1] = v265;
                v92->i16[2] = bswap32(HIDWORD(v262)) >> 16;
              }
              *v261 = bswap32(v258) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v255);
          --v256;
        }
        while (v256);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 14:
      v266 = 2 * v89;
      while (1)
      {
        v267 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v268 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v269) = *(unsigned __int16 *)(v268 + 8);
            if (*(_WORD *)(v268 + 8))
            {
              v270 = *(_QWORD *)v268;
              if (v3)
              {
                if (*v88)
                {
                  v271 = __rev16(*v88);
                  goto LABEL_229;
                }
LABEL_231:
                v275 = bswap32(v270);
                v92->i16[0] = HIWORD(v275);
                v92->i16[1] = v275;
                v92->i16[2] = bswap32(HIDWORD(v270)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v270));
                v272 = v88;
              }
              else
              {
                v271 = 0xFFFF;
LABEL_229:
                v272 = (unsigned __int16 *)v92 + 3;
                v273 = PDAscreenPDA_10647(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v271, v270, v269);
                v270 = v273;
                if (v3)
                {
                  LODWORD(v269) = v274;
                  goto LABEL_231;
                }
                v269 = HIWORD(v273);
                v276 = bswap32(v273);
                v92->i16[0] = HIWORD(v276);
                v92->i16[1] = v276;
                v92->i16[2] = bswap32(HIDWORD(v273)) >> 16;
              }
              *v272 = bswap32(v269) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v266);
          --v267;
        }
        while (v267);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 15:
      v277 = 2 * v89;
      while (1)
      {
        v278 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v279 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v280) = *(unsigned __int16 *)(v279 + 8);
            if (*(_WORD *)(v279 + 8))
            {
              v281 = *(_QWORD *)v279;
              if (v3)
              {
                if (*v88)
                {
                  v282 = __rev16(*v88);
                  goto LABEL_245;
                }
LABEL_247:
                v286 = bswap32(v281);
                v92->i16[0] = HIWORD(v286);
                v92->i16[1] = v286;
                v92->i16[2] = bswap32(HIDWORD(v281)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v281));
                v283 = v88;
              }
              else
              {
                v282 = 0xFFFF;
LABEL_245:
                v283 = (unsigned __int16 *)v92 + 3;
                v284 = PDAoverlayPDA_10648(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v282, v281, v280);
                v281 = v284;
                if (v3)
                {
                  LODWORD(v280) = v285;
                  goto LABEL_247;
                }
                v280 = HIWORD(v284);
                v287 = bswap32(v284);
                v92->i16[0] = HIWORD(v287);
                v92->i16[1] = v287;
                v92->i16[2] = bswap32(HIDWORD(v284)) >> 16;
              }
              *v283 = bswap32(v280) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v277);
          --v278;
        }
        while (v278);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 16:
      v288 = 2 * v89;
      while (1)
      {
        v289 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v290 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v291) = *(unsigned __int16 *)(v290 + 8);
            if (*(_WORD *)(v290 + 8))
            {
              v292 = *(_QWORD *)v290;
              if (v3)
              {
                if (*v88)
                {
                  v293 = __rev16(*v88);
                  goto LABEL_261;
                }
LABEL_263:
                v297 = bswap32(v292);
                v92->i16[0] = HIWORD(v297);
                v92->i16[1] = v297;
                v92->i16[2] = bswap32(HIDWORD(v292)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v292));
                v294 = v88;
              }
              else
              {
                v293 = 0xFFFF;
LABEL_261:
                v294 = (unsigned __int16 *)v92 + 3;
                v295 = PDAdarkenPDA_10650(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v293, v292, v291);
                v292 = v295;
                if (v3)
                {
                  LODWORD(v291) = v296;
                  goto LABEL_263;
                }
                v291 = HIWORD(v295);
                v298 = bswap32(v295);
                v92->i16[0] = HIWORD(v298);
                v92->i16[1] = v298;
                v92->i16[2] = bswap32(HIDWORD(v295)) >> 16;
              }
              *v294 = bswap32(v291) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v288);
          --v289;
        }
        while (v289);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 17:
      v299 = 2 * v89;
      while (1)
      {
        v300 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v301 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v302) = *(unsigned __int16 *)(v301 + 8);
            if (*(_WORD *)(v301 + 8))
            {
              v303 = *(_QWORD *)v301;
              if (v3)
              {
                if (*v88)
                {
                  v304 = __rev16(*v88);
                  goto LABEL_277;
                }
LABEL_279:
                v308 = bswap32(v303);
                v92->i16[0] = HIWORD(v308);
                v92->i16[1] = v308;
                v92->i16[2] = bswap32(HIDWORD(v303)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v303));
                v305 = v88;
              }
              else
              {
                v304 = 0xFFFF;
LABEL_277:
                v305 = (unsigned __int16 *)v92 + 3;
                v306 = PDAlightenPDA_10649(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v304, v303, v302);
                v303 = v306;
                if (v3)
                {
                  LODWORD(v302) = v307;
                  goto LABEL_279;
                }
                v302 = HIWORD(v306);
                v309 = bswap32(v306);
                v92->i16[0] = HIWORD(v309);
                v92->i16[1] = v309;
                v92->i16[2] = bswap32(HIDWORD(v306)) >> 16;
              }
              *v305 = bswap32(v302) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v299);
          --v300;
        }
        while (v300);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 18:
      v310 = 2 * v89;
      while (1)
      {
        v311 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v312 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v313) = *(unsigned __int16 *)(v312 + 8);
            if (*(_WORD *)(v312 + 8))
            {
              v314 = *(_QWORD *)v312;
              if (v3)
              {
                if (*v88)
                {
                  v315 = __rev16(*v88);
                  goto LABEL_293;
                }
LABEL_295:
                v319 = bswap32(v314);
                v92->i16[0] = HIWORD(v319);
                v92->i16[1] = v319;
                v92->i16[2] = bswap32(HIDWORD(v314)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v314));
                v316 = v88;
              }
              else
              {
                v315 = 0xFFFF;
LABEL_293:
                v316 = (unsigned __int16 *)v92 + 3;
                v317 = PDAcolordodgePDA_10651(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v315, v314, v313);
                v314 = v317;
                if (v3)
                {
                  LODWORD(v313) = v318;
                  goto LABEL_295;
                }
                v313 = HIWORD(v317);
                v320 = bswap32(v317);
                v92->i16[0] = HIWORD(v320);
                v92->i16[1] = v320;
                v92->i16[2] = bswap32(HIDWORD(v317)) >> 16;
              }
              *v316 = bswap32(v313) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v310);
          --v311;
        }
        while (v311);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 19:
      v321 = 2 * v89;
      while (1)
      {
        v322 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v323 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v324) = *(unsigned __int16 *)(v323 + 8);
            if (*(_WORD *)(v323 + 8))
            {
              v325 = *(_QWORD *)v323;
              if (v3)
              {
                if (*v88)
                {
                  v326 = __rev16(*v88);
                  goto LABEL_309;
                }
LABEL_311:
                v330 = bswap32(v325);
                v92->i16[0] = HIWORD(v330);
                v92->i16[1] = v330;
                v92->i16[2] = bswap32(HIDWORD(v325)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v325));
                v327 = v88;
              }
              else
              {
                v326 = 0xFFFF;
LABEL_309:
                v327 = (unsigned __int16 *)v92 + 3;
                v328 = PDAcolorburnPDA_10652(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v326, v325, v324);
                v325 = v328;
                if (v3)
                {
                  LODWORD(v324) = v329;
                  goto LABEL_311;
                }
                v324 = HIWORD(v328);
                v331 = bswap32(v328);
                v92->i16[0] = HIWORD(v331);
                v92->i16[1] = v331;
                v92->i16[2] = bswap32(HIDWORD(v328)) >> 16;
              }
              *v327 = bswap32(v324) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v321);
          --v322;
        }
        while (v322);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 20:
      v332 = 2 * v89;
      while (1)
      {
        v333 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v334 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v335) = *(unsigned __int16 *)(v334 + 8);
            if (*(_WORD *)(v334 + 8))
            {
              v336 = *(_QWORD *)v334;
              if (v3)
              {
                if (*v88)
                {
                  v337 = __rev16(*v88);
                  goto LABEL_325;
                }
LABEL_327:
                v341 = bswap32(v336);
                v92->i16[0] = HIWORD(v341);
                v92->i16[1] = v341;
                v92->i16[2] = bswap32(HIDWORD(v336)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v336));
                v338 = v88;
              }
              else
              {
                v337 = 0xFFFF;
LABEL_325:
                v338 = (unsigned __int16 *)v92 + 3;
                v339 = PDAsoftlightPDA_10654(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v337, v336, v335);
                v336 = v339;
                if (v3)
                {
                  LODWORD(v335) = v340;
                  goto LABEL_327;
                }
                v335 = HIWORD(v339);
                v342 = bswap32(v339);
                v92->i16[0] = HIWORD(v342);
                v92->i16[1] = v342;
                v92->i16[2] = bswap32(HIDWORD(v339)) >> 16;
              }
              *v338 = bswap32(v335) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v332);
          --v333;
        }
        while (v333);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 21:
      v343 = 2 * v89;
      while (1)
      {
        v344 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v345 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v346) = *(unsigned __int16 *)(v345 + 8);
            if (*(_WORD *)(v345 + 8))
            {
              v347 = *(_QWORD *)v345;
              if (v3)
              {
                if (*v88)
                {
                  v348 = __rev16(*v88);
                  goto LABEL_341;
                }
LABEL_343:
                v352 = bswap32(v347);
                v92->i16[0] = HIWORD(v352);
                v92->i16[1] = v352;
                v92->i16[2] = bswap32(HIDWORD(v347)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v347));
                v349 = v88;
              }
              else
              {
                v348 = 0xFFFF;
LABEL_341:
                v349 = (unsigned __int16 *)v92 + 3;
                v350 = PDAhardlightPDA_10653(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v348, v347, v346);
                v347 = v350;
                if (v3)
                {
                  LODWORD(v346) = v351;
                  goto LABEL_343;
                }
                v346 = HIWORD(v350);
                v353 = bswap32(v350);
                v92->i16[0] = HIWORD(v353);
                v92->i16[1] = v353;
                v92->i16[2] = bswap32(HIDWORD(v350)) >> 16;
              }
              *v349 = bswap32(v346) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v343);
          --v344;
        }
        while (v344);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 22:
      v354 = 2 * v89;
      while (1)
      {
        v355 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v356 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v357) = *(unsigned __int16 *)(v356 + 8);
            if (*(_WORD *)(v356 + 8))
            {
              v358 = *(_QWORD *)v356;
              if (v3)
              {
                if (*v88)
                {
                  v359 = __rev16(*v88);
                  goto LABEL_357;
                }
LABEL_359:
                v363 = bswap32(v358);
                v92->i16[0] = HIWORD(v363);
                v92->i16[1] = v363;
                v92->i16[2] = bswap32(HIDWORD(v358)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v358));
                v360 = v88;
              }
              else
              {
                v359 = 0xFFFF;
LABEL_357:
                v360 = (unsigned __int16 *)v92 + 3;
                v361 = PDAdifferencePDA_10655(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v359, v358, v357);
                v358 = v361;
                if (v3)
                {
                  LODWORD(v357) = v362;
                  goto LABEL_359;
                }
                v357 = HIWORD(v361);
                v364 = bswap32(v361);
                v92->i16[0] = HIWORD(v364);
                v92->i16[1] = v364;
                v92->i16[2] = bswap32(HIDWORD(v361)) >> 16;
              }
              *v360 = bswap32(v357) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v354);
          --v355;
        }
        while (v355);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 23:
      v365 = 2 * v89;
      while (1)
      {
        v366 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v367 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v368) = *(unsigned __int16 *)(v367 + 8);
            if (*(_WORD *)(v367 + 8))
            {
              v369 = *(_QWORD *)v367;
              if (v3)
              {
                if (*v88)
                {
                  v370 = __rev16(*v88);
                  goto LABEL_373;
                }
LABEL_375:
                v374 = bswap32(v369);
                v92->i16[0] = HIWORD(v374);
                v92->i16[1] = v374;
                v92->i16[2] = bswap32(HIDWORD(v369)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v369));
                v371 = v88;
              }
              else
              {
                v370 = 0xFFFF;
LABEL_373:
                v371 = (unsigned __int16 *)v92 + 3;
                v372 = PDAexclusionPDA_10656(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v370, v369, v368);
                v369 = v372;
                if (v3)
                {
                  LODWORD(v368) = v373;
                  goto LABEL_375;
                }
                v368 = HIWORD(v372);
                v375 = bswap32(v372);
                v92->i16[0] = HIWORD(v375);
                v92->i16[1] = v375;
                v92->i16[2] = bswap32(HIDWORD(v372)) >> 16;
              }
              *v371 = bswap32(v368) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v365);
          --v366;
        }
        while (v366);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 24:
      v376 = 2 * v89;
      while (1)
      {
        v377 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v378 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v379) = *(unsigned __int16 *)(v378 + 8);
            if (*(_WORD *)(v378 + 8))
            {
              v380 = *(_QWORD *)v378;
              if (v3)
              {
                if (*v88)
                {
                  v381 = __rev16(*v88);
                  goto LABEL_389;
                }
LABEL_391:
                v385 = bswap32(v380);
                v92->i16[0] = HIWORD(v385);
                v92->i16[1] = v385;
                v92->i16[2] = bswap32(HIDWORD(v380)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v380));
                v382 = v88;
              }
              else
              {
                v381 = 0xFFFF;
LABEL_389:
                v382 = (unsigned __int16 *)v92 + 3;
                v383 = PDAhuePDA_10657(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v381, v380, v379);
                v380 = v383;
                if (v3)
                {
                  LODWORD(v379) = v384;
                  goto LABEL_391;
                }
                v379 = HIWORD(v383);
                v386 = bswap32(v383);
                v92->i16[0] = HIWORD(v386);
                v92->i16[1] = v386;
                v92->i16[2] = bswap32(HIDWORD(v383)) >> 16;
              }
              *v382 = bswap32(v379) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v376);
          --v377;
        }
        while (v377);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 25:
      v387 = 2 * v89;
      while (1)
      {
        v388 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v389 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v390) = *(unsigned __int16 *)(v389 + 8);
            if (*(_WORD *)(v389 + 8))
            {
              v391 = *(_QWORD *)v389;
              if (v3)
              {
                if (*v88)
                {
                  v392 = __rev16(*v88);
                  goto LABEL_405;
                }
LABEL_407:
                v396 = bswap32(v391);
                v92->i16[0] = HIWORD(v396);
                v92->i16[1] = v396;
                v92->i16[2] = bswap32(HIDWORD(v391)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v391));
                v393 = v88;
              }
              else
              {
                v392 = 0xFFFF;
LABEL_405:
                v393 = (unsigned __int16 *)v92 + 3;
                v394 = PDAsaturationPDA_10658(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v392, v391, v390);
                v391 = v394;
                if (v3)
                {
                  LODWORD(v390) = v395;
                  goto LABEL_407;
                }
                v390 = HIWORD(v394);
                v397 = bswap32(v394);
                v92->i16[0] = HIWORD(v397);
                v92->i16[1] = v397;
                v92->i16[2] = bswap32(HIDWORD(v394)) >> 16;
              }
              *v393 = bswap32(v390) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v387);
          --v388;
        }
        while (v388);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 26:
      v398 = 2 * v89;
      while (1)
      {
        v399 = v607;
        do
        {
          if (*(_BYTE *)v94)
          {
            v400 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v401) = *(unsigned __int16 *)(v400 + 8);
            if (*(_WORD *)(v400 + 8))
            {
              v402 = *(_QWORD *)v400;
              if (v3)
              {
                if (*v88)
                {
                  v403 = __rev16(*v88);
                  goto LABEL_421;
                }
                goto LABEL_422;
              }
              v403 = 0xFFFF;
LABEL_421:
              v404 = (unsigned __int16 *)v92 + 3;
              v402 = PDAluminosityPDA_10659(v402, v401, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v403);
              if (v3)
              {
LABEL_422:
                v405 = bswap32(v402);
                v92->i16[0] = HIWORD(v405);
                v92->i16[1] = v405;
                v92->i16[2] = bswap32(HIDWORD(v402)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v402));
                v404 = v88;
              }
              else
              {
                v401 = HIWORD(v402);
                v406 = bswap32(v402);
                v92->i16[0] = HIWORD(v406);
                v92->i16[1] = v406;
                v92->i16[2] = bswap32(HIDWORD(v402)) >> 16;
              }
              *v404 = bswap32(v401) >> 16;
            }
          }
          ++v94;
          ++v92;
          v88 = (unsigned __int16 *)((char *)v88 + v398);
          --v399;
        }
        while (v399);
        v94 += v604;
        v92 += v606;
        v88 += v91;
        if (!--v10)
          return;
      }
    case 27:
      v407 = 2 * v89;
      break;
    default:
      return;
  }
  do
  {
    v408 = v607;
    do
    {
      if (*(_BYTE *)v94)
      {
        v409 = v82 + 16 * *(unsigned __int8 *)v94;
        LODWORD(v410) = *(unsigned __int16 *)(v409 + 8);
        if (*(_WORD *)(v409 + 8))
        {
          v411 = *(_QWORD *)v409;
          if (v3)
          {
            if (*v88)
            {
              v412 = __rev16(*v88);
              goto LABEL_436;
            }
LABEL_438:
            v416 = bswap32(v411);
            v92->i16[0] = HIWORD(v416);
            v92->i16[1] = v416;
            v92->i16[2] = bswap32(HIDWORD(v411)) >> 16;
            v92->i16[3] = __rev16(HIWORD(v411));
            v413 = v88;
          }
          else
          {
            v412 = 0xFFFF;
LABEL_436:
            v413 = (unsigned __int16 *)v92 + 3;
            v414 = PDAluminosityPDA_10659(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v412, v411, v410);
            v411 = v414;
            if (v3)
            {
              LODWORD(v410) = v415;
              goto LABEL_438;
            }
            v410 = HIWORD(v414);
            v417 = bswap32(v414);
            v92->i16[0] = HIWORD(v417);
            v92->i16[1] = v417;
            v92->i16[2] = bswap32(HIDWORD(v414)) >> 16;
          }
          *v413 = bswap32(v410) >> 16;
        }
      }
      ++v94;
      ++v92;
      v88 = (unsigned __int16 *)((char *)v88 + v407);
      --v408;
    }
    while (v408);
    v94 += v604;
    v92 += v606;
    v88 += v91;
    --v10;
  }
  while (v10);
}

void CMYK64_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  _WORD *v11;
  unint64_t v12;
  unint64_t v13;
  int8x8_t *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  unsigned __int16 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _WORD *v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int16 *v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int32x4_t v59;
  unsigned __int16 *v60;
  int v61;
  int v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  unint64_t v70;
  unsigned int v71;
  unint64_t v72;
  unsigned int v73;
  unsigned int v74;
  int32x4_t v75;
  uint32x4_t v76;
  int32x2_t v77;
  unsigned __int16 *v78;
  unsigned __int16 *v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned __int16 *v87;
  uint64_t v88;
  int v89;
  unint64_t v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  int v94;
  unsigned int v95;
  unsigned __int16 *v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unsigned __int16 *v103;
  uint64_t v104;
  int v105;
  unint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  int v110;
  unsigned int v111;
  unsigned __int16 *v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unsigned __int16 *v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  unint64_t v127;
  unsigned int v128;
  unsigned int v129;
  unsigned __int16 *v130;
  uint64_t v131;
  char *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unsigned __int16 *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  int v141;
  int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unint64_t v146;
  unsigned int v147;
  unsigned int v148;
  int32x4_t v149;
  uint32x4_t v150;
  int32x4_t v151;
  uint32x4_t v152;
  unsigned __int16 *v153;
  uint64_t v154;
  char *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  unsigned __int16 *v159;
  uint64_t v160;
  int v161;
  unint64_t v162;
  int v163;
  unsigned int v164;
  unint64_t v165;
  unsigned int v166;
  unsigned __int16 *v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unsigned __int16 *v173;
  uint64_t v174;
  int v175;
  unint64_t v176;
  int v177;
  unint64_t v178;
  unsigned int v179;
  unsigned int v180;
  unsigned int v181;
  unsigned __int16 *v182;
  uint64_t v183;
  char *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unsigned __int16 *v190;
  int v191;
  unsigned int v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  unsigned int v196;
  unsigned __int16 v197;
  int v198;
  unint64_t v199;
  unsigned int v200;
  unsigned __int16 *v201;
  uint64_t v202;
  char *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unsigned __int16 *v209;
  int v210;
  unsigned int v211;
  unsigned int v212;
  unsigned int v213;
  unsigned int v214;
  unsigned int v215;
  int v216;
  unint64_t v217;
  unsigned int v218;
  unsigned __int16 *v219;
  uint64_t v220;
  char *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  unsigned __int16 *v225;
  uint64_t v226;
  int v227;
  unint64_t v228;
  unsigned int v229;
  unsigned int v230;
  unsigned int v231;
  unsigned int v232;
  int v233;
  unsigned __int16 *v234;
  uint64_t v235;
  char *v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  unsigned __int16 *v240;
  uint64_t v241;
  int v242;
  unint64_t v243;
  unsigned int v244;
  unsigned int v245;
  unsigned int v246;
  unsigned int v247;
  int v248;
  unsigned __int16 *v249;
  uint64_t v250;
  char *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  unsigned __int16 *v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  int v260;
  unsigned int v261;
  int v262;
  unsigned int v263;
  unint64_t v264;
  unsigned int v265;
  unsigned int v266;
  unsigned int v267;
  unsigned int v268;
  unint64_t v269;
  unsigned int v270;
  _WORD *v271;
  unint64_t v272;
  unsigned int v273;
  unsigned int v274;
  unsigned __int16 *v275;
  uint64_t v276;
  char *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unsigned __int16 *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  int v286;
  unsigned int v287;
  int v288;
  unsigned int v289;
  unint64_t v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  unsigned int v294;
  unint64_t v295;
  unsigned int v296;
  _WORD *v297;
  unint64_t v298;
  unsigned int v299;
  unsigned int v300;
  unsigned __int16 *v301;
  uint64_t v302;
  char *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  unsigned __int16 *v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  int v312;
  unsigned int v313;
  int v314;
  unsigned int v315;
  unint64_t v316;
  unsigned int v317;
  unsigned int v318;
  unsigned int v319;
  unsigned int v320;
  unint64_t v321;
  unsigned int v322;
  _WORD *v323;
  unint64_t v324;
  unsigned int v325;
  unsigned int v326;
  unsigned __int16 *v327;
  uint64_t v328;
  char *v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  unsigned __int16 *v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  int v338;
  unsigned int v339;
  int v340;
  unsigned int v341;
  unint64_t v342;
  unsigned int v343;
  unsigned int v344;
  unsigned int v345;
  unsigned int v346;
  unint64_t v347;
  unsigned int v348;
  _WORD *v349;
  unint64_t v350;
  unsigned int v351;
  unsigned int v352;
  unsigned __int16 *v353;
  uint64_t v354;
  char *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  unsigned __int16 *v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  int v364;
  unsigned int v365;
  int v366;
  unsigned int v367;
  unint64_t v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  unsigned int v372;
  unint64_t v373;
  unsigned int v374;
  _WORD *v375;
  unint64_t v376;
  unsigned int v377;
  unsigned int v378;
  unsigned __int16 *v379;
  uint64_t v380;
  char *v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  unsigned __int16 *v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  int v390;
  unsigned int v391;
  int v392;
  unsigned int v393;
  unint64_t v394;
  unsigned int v395;
  unsigned int v396;
  unsigned int v397;
  unsigned int v398;
  unint64_t v399;
  unsigned int v400;
  _WORD *v401;
  unint64_t v402;
  unsigned int v403;
  unsigned int v404;
  unsigned __int16 *v405;
  uint64_t v406;
  char *v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  unsigned __int16 *v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  int v416;
  unsigned int v417;
  int v418;
  unsigned int v419;
  unint64_t v420;
  unsigned int v421;
  unsigned int v422;
  unsigned int v423;
  unsigned int v424;
  unint64_t v425;
  unsigned int v426;
  _WORD *v427;
  unint64_t v428;
  unsigned int v429;
  unsigned int v430;
  unsigned __int16 *v431;
  uint64_t v432;
  char *v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  unsigned __int16 *v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  int v442;
  unsigned int v443;
  int v444;
  unsigned int v445;
  unint64_t v446;
  unsigned int v447;
  unsigned int v448;
  unsigned int v449;
  unsigned int v450;
  unint64_t v451;
  unsigned int v452;
  _WORD *v453;
  unint64_t v454;
  unsigned int v455;
  unsigned int v456;
  unsigned __int16 *v457;
  uint64_t v458;
  char *v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  unsigned __int16 *v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  int v468;
  unsigned int v469;
  int v470;
  unsigned int v471;
  unint64_t v472;
  unsigned int v473;
  unsigned int v474;
  unsigned int v475;
  unsigned int v476;
  unint64_t v477;
  unsigned int v478;
  _WORD *v479;
  unint64_t v480;
  unsigned int v481;
  unsigned int v482;
  unsigned __int16 *v483;
  uint64_t v484;
  char *v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  unsigned __int16 *v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  int v494;
  unsigned int v495;
  int v496;
  unsigned int v497;
  unint64_t v498;
  unsigned int v499;
  unsigned int v500;
  unsigned int v501;
  unsigned int v502;
  unint64_t v503;
  unsigned int v504;
  _WORD *v505;
  unint64_t v506;
  unsigned int v507;
  unsigned int v508;
  unsigned __int16 *v509;
  uint64_t v510;
  char *v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  unsigned __int16 *v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  int v520;
  unsigned int v521;
  int v522;
  unsigned int v523;
  unint64_t v524;
  unsigned int v525;
  unsigned int v526;
  unsigned int v527;
  unsigned int v528;
  unint64_t v529;
  unsigned int v530;
  _WORD *v531;
  unint64_t v532;
  unsigned int v533;
  unsigned int v534;
  unsigned __int16 *v535;
  uint64_t v536;
  char *v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  unsigned __int16 *v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  int v546;
  unsigned int v547;
  int v548;
  unsigned int v549;
  unint64_t v550;
  unsigned int v551;
  unsigned int v552;
  unsigned int v553;
  unsigned int v554;
  unint64_t v555;
  unsigned int v556;
  _WORD *v557;
  unint64_t v558;
  unsigned int v559;
  unsigned int v560;
  unsigned __int16 *v561;
  uint64_t v562;
  char *v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  unsigned __int16 *v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  int v572;
  unsigned int v573;
  int v574;
  unsigned int v575;
  unint64_t v576;
  unsigned int v577;
  unsigned int v578;
  unsigned int v579;
  unsigned int v580;
  unint64_t v581;
  unsigned int v582;
  _WORD *v583;
  unint64_t v584;
  unsigned int v585;
  unsigned int v586;
  unsigned __int16 *v587;
  uint64_t v588;
  char *v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  unsigned __int16 *v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  int v598;
  unsigned int v599;
  int v600;
  unsigned int v601;
  unint64_t v602;
  unsigned int v603;
  unsigned int v604;
  unsigned int v605;
  unsigned int v606;
  unint64_t v607;
  unsigned int v608;
  _WORD *v609;
  unsigned int v610;
  unsigned int v611;
  unsigned __int16 *v612;
  uint64_t v613;
  char *v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  unsigned __int16 *v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  int v623;
  unsigned int v624;
  int v625;
  unsigned int v626;
  unint64_t v627;
  unsigned int v628;
  unsigned int v629;
  unsigned int v630;
  unsigned int v631;
  unint64_t v632;
  unsigned int v633;
  _WORD *v634;
  unint64_t v635;
  unsigned int v636;
  unsigned int v637;
  unsigned __int16 *v638;
  uint64_t v639;
  char *v640;
  uint64_t v641;
  uint64_t v642;
  int32x4_t v643;
  int v644;
  int v645;
  int v646;
  unsigned int v647;
  int32x4_t v648;
  uint32x4_t v649;
  uint64_t v650;
  uint64_t v651;
  int v652;
  int v653;
  int v654;
  unsigned int v655;
  unsigned int v656;
  int8x8_t v657;
  int32x4_t v658;
  int32x4_t v659;
  int32x4_t v660;
  int32x4_t v661;
  int8x16_t v662;
  unsigned __int16 *v663;
  uint64_t v664;
  unsigned __int16 *v665;
  char *v666;
  uint64_t v667;
  char *v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  int32x4_t v672;
  unsigned __int16 *v673;
  uint64_t v674;
  int v675;
  int v676;
  _WORD *v677;
  int v678;
  unsigned int v679;
  unsigned int v680;
  int v681;
  unsigned int v682;
  unsigned int v683;
  unsigned int v684;
  unint64_t v685;
  unsigned int v686;
  unint64_t v687;
  int32x4_t v688;
  int64x2_t v689;
  uint32x4_t v690;
  int32x4_t v691;
  int32x2_t v692;
  unint64_t v693;
  unsigned int v694;
  int32x4_t v695;
  uint32x4_t v696;
  unsigned __int16 *v697;
  unsigned __int16 *v698;
  uint64_t v699;
  char *v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  unsigned __int16 *v705;
  uint64_t v706;
  uint64_t v707;
  int32x4_t v708;
  int v709;
  int v710;
  int v711;
  unsigned int v712;
  int32x4_t v713;
  uint32x4_t v714;
  int32x4_t v715;
  int v716;
  unsigned int v717;
  unsigned int v718;
  int32x4_t v719;
  int8x8_t v720;
  int32x4_t v721;
  int32x4_t v722;
  int8x16_t v723;
  unsigned __int16 *v724;
  unsigned __int16 *v725;
  uint64_t v726;
  char *v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  unsigned __int16 *v733;
  uint64_t v734;
  uint64_t v735;
  int32x4_t v736;
  int v737;
  int v738;
  int v739;
  unsigned int v740;
  int32x4_t v741;
  uint32x4_t v742;
  int32x4_t v743;
  unsigned int v744;
  unsigned int v745;
  int32x4_t v746;
  uint32x4_t v747;
  unsigned __int16 *v748;
  unsigned __int16 *v749;
  uint64_t v750;
  char *v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  unsigned __int16 *v757;
  int v758;
  unint64_t v759;
  unsigned int v760;
  unsigned int v761;
  unsigned int v762;
  unsigned int v763;
  int v764;
  unsigned __int16 *v765;
  uint64_t v766;
  char *v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  int v771;
  int v772;
  unsigned int v773;
  unsigned int v774;
  unsigned int v775;
  int v776;
  unsigned __int16 *v777;
  uint64_t v778;
  unsigned __int16 *v779;
  char *v780;
  uint64_t v781;
  char *v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  int v786;
  int v787;
  int v788;
  unsigned __int16 *v789;
  uint64_t v790;
  unsigned __int16 *v791;
  char *v792;
  uint64_t v793;
  char *v794;
  uint64_t v795;
  BOOL v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  uint64_t v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  uint64_t v871;
  uint64_t v872;
  unint64_t v873;
  unint64_t v874;
  unint64_t v875;
  uint64_t v876;
  unint64_t v877;
  int v878;
  uint64_t v879;
  _WORD *v880;
  unsigned __int16 *v881;
  int v882;
  int v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  uint64_t v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t v894;
  uint64_t v895;
  uint64_t v896;
  uint64_t v897;
  uint64_t v898;
  uint64_t v899;
  unint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  uint64_t v905;
  uint64_t v906;
  unint64_t v907;
  unint64_t v908;
  unint64_t v909;
  unint64_t v910;
  unint64_t v911;
  unint64_t v912;
  unint64_t v913;
  unint64_t v914;
  unint64_t v915;
  unint64_t v916;
  unint64_t v917;
  unint64_t v918;
  unint64_t v919;
  unint64_t v920;
  unint64_t v921;
  uint64_t v922;
  int v923;
  _WORD *v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  uint64_t v928;
  uint64_t v929;
  uint64_t v930;
  uint64_t v931;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 136);
  v5 = *(int *)(a1 + 12);
  v4 = *(int *)(a1 + 16);
  if (v2)
  {
    v6 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v7 = (unsigned __int16 *)(v2 + 2 * (v5 + v6 * v4));
    v8 = -1;
    if (!v3)
      return;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return;
  }
  v9 = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 88);
  v11 = *(_WORD **)(a1 + 96);
  v13 = (unint64_t)*(int *)(a1 + 28) >> 3;
  v14 = (int8x8_t *)(*(_QWORD *)(a1 + 40) + 8 * (v5 + v13 * v4));
  v15 = *(int *)(a1 + 124);
  v16 = (_BYTE *)(v3 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(a1 + 56);
  v18 = *(int *)(a1 + 60);
  v19 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) != 0x100)
  {
    v21 = *(_DWORD *)(a1 + 64);
    v22 = *(_DWORD *)(a1 + 68);
    v879 = v19 >> 3;
    if (v11)
    {
      v877 = (unint64_t)*(int *)(a1 + 80) >> 1;
      v20 = 1;
    }
    else
    {
      v877 = 0;
      v20 = 0;
    }
    v26 = v12 + 8 * v879 * v22;
    v8 &= 1u;
    v25 = 1;
    v881 = (unsigned __int16 *)v12;
    v23 = (char *)v12;
    goto LABEL_19;
  }
  v879 = v19 >> 3;
  if (v11)
  {
    v877 = (unint64_t)*(int *)(a1 + 80) >> 1;
    v11 += v17 + v877 * v18;
    v20 = -1;
  }
  else
  {
    v877 = 0;
    v20 = 0;
  }
  v23 = (char *)(v12 + 8 * (v17 + v879 * v18));
  if (v879 == v13 && (char *)v14 - v23 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - v23) >> 3))
    {
      v14 += v9 - 1;
      v23 += 8 * v9 - 8;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      v25 = -1;
      v879 = (unint64_t)*(int *)(a1 + 28) >> 3;
      v11 += v20 & (v9 - 1);
      goto LABEL_16;
    }
    v24 = v10 - 1;
    if (v14 <= (int8x8_t *)&v23[8 * v13 * v24 - 8 + 8 * v9])
    {
      v14 += v13 * v24;
      v16 += v15 * v24;
      v15 = -v15;
      v7 += v6 * v24;
      v6 = -(uint64_t)v6;
      v8 &= 1u;
      v11 += v877 * v24;
      v877 = -(uint64_t)v877;
      v20 &= 1u;
      v25 = 1;
      v23 += 8 * v13 * v24;
      v879 = -(uint64_t)v13;
      v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  v25 = 1;
LABEL_16:
  v26 = 0;
  v881 = 0;
  v12 = -1;
  v22 = v877;
  v21 = v879;
LABEL_19:
  v27 = v25 * v9;
  v878 = v9;
  v874 = v26;
  v882 = v10;
  if (v26)
  {
    v28 = (int)v18 % v22;
    v29 = (unsigned __int16 *)&v23[8 * v879 * v28];
    v30 = (int)v17 % v21;
    v23 = (char *)&v29[4 * v30];
    v12 = (unint64_t)&v29[4 * v21];
    if ((v20 & 1) != 0)
      v11 += v877 * v28 + v30;
    v880 = v11;
    v881 = &v29[4 * v30];
  }
  else
  {
    v879 -= v27;
    v880 = v11;
    v877 -= v20 * v9;
  }
  v876 = v15 - v27;
  v875 = v13 - v27;
  v873 = v6 - v8 * v9;
  v923 = v20;
  v883 = v8;
  switch(a2)
  {
    case 0:
      v31 = v25;
      if (v8)
      {
        v32 = 2 * v8;
        do
        {
          v33 = v878;
          v34 = v882;
          do
          {
            v35 = *v16;
            if (*v16)
            {
              if (v35 == 255)
              {
                *v14 = 0;
                *v7 = 0;
              }
              else
              {
                CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, (v35 | (v35 << 8)) ^ 0xFFFF);
              }
            }
            v16 += v31;
            v7 = (unsigned __int16 *)((char *)v7 + v32);
            v14 += v31;
            --v33;
          }
          while (v33);
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v34 != 1);
      }
      else
      {
        v643.i64[0] = 0x100000001;
        v643.i64[1] = 0x100000001;
        do
        {
          v644 = v9;
          v645 = v882;
          do
          {
            v646 = *v16;
            if (*v16)
            {
              if (v646 == 255)
              {
                *v14 = 0;
              }
              else
              {
                v647 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v648.i32[0] = (unsigned __int16)v647;
                v648.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v647), 0x10uLL).i32[1];
                v648.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v649 = (uint32x4_t)vmulq_s32(v648, vdupq_n_s32(v646 | (v646 << 8)));
                v648.i32[0] = v647;
                *v14 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v648, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v649, v649, 0x10uLL), v643), 0x10uLL))));
              }
            }
            v16 += v31;
            v14 += v31;
            --v644;
          }
          while (v644);
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v645 != 1);
      }
      return;
    case 1:
      if (v8)
      {
        v36 = v25;
        if (v20)
        {
          v37 = v20;
          v38 = -(uint64_t)v21;
          v884 = -(v879 * v22);
          v848 = -(uint64_t)(v877 * v22);
          v39 = 2 * v8;
          v40 = 8 * v36;
          v41 = v880;
          v896 = v36;
          do
          {
            v42 = v878;
            do
            {
              v43 = *v16;
              if (*v16)
              {
                if (v43 == 255)
                {
                  *v14 = *(int8x8_t *)v23;
                  *v7 = *v41;
                }
                else
                {
                  v44 = v43 | (v43 << 8);
                  v45 = v39;
                  v46 = v40;
                  v924 = v41;
                  CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), bswap32((unsigned __int16)*v41) >> 16, v44, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, v44 ^ 0xFFFF);
                  v40 = v46;
                  v39 = v45;
                  v36 = v896;
                  v41 = v924;
                }
              }
              v16 += v36;
              v47 = (unsigned __int16 *)&v23[8 * v36];
              if ((unint64_t)v47 >= v12)
                v48 = v38;
              else
                v48 = 0;
              v41 += v37 + v48;
              v23 = (char *)&v47[4 * v48];
              v7 = (unsigned __int16 *)((char *)v7 + v39);
              v14 = (int8x8_t *)((char *)v14 + v40);
              --v42;
            }
            while (v42);
            if (v874)
            {
              v49 = (char *)&v881[4 * v879];
              v50 = v848;
              if ((unint64_t)v49 < v874)
                v50 = 0;
              v51 = (uint64_t)&v880[v877 + v50];
              v52 = v884;
              if ((unint64_t)v49 < v874)
                v52 = 0;
              v23 = &v49[8 * v52];
              v12 += 8 * v52 + 8 * v879;
              v880 += v877 + v50;
              v881 = (unsigned __int16 *)v23;
              v41 = (_WORD *)v51;
            }
            else
            {
              v23 += 8 * v879;
              v41 += v877;
            }
            v16 += v876;
            v14 += v875;
            v7 += v873;
            --v882;
          }
          while (v882);
        }
        else
        {
          v784 = -(uint64_t)v21;
          v931 = -(v879 * v22);
          v785 = 2 * v8;
          do
          {
            v786 = v878;
            do
            {
              v787 = *v16;
              if (*v16)
              {
                if (v787 == 255)
                {
                  *v14 = *(int8x8_t *)v23;
                  *v7 = -1;
                }
                else
                {
                  v788 = v787 | (v787 << 8);
                  CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), 0xFFFF, v788, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, v788 ^ 0xFFFF);
                }
              }
              v16 += v36;
              v789 = (unsigned __int16 *)&v23[8 * v36];
              if ((unint64_t)v789 >= v12)
                v790 = v784;
              else
                v790 = 0;
              v23 = (char *)&v789[4 * v790];
              v7 = (unsigned __int16 *)((char *)v7 + v785);
              v14 += v36;
              --v786;
            }
            while (v786);
            v16 += v876;
            v14 += v875;
            v7 += v873;
            v791 = v881;
            v792 = (char *)&v881[4 * v879];
            v793 = v931;
            if ((unint64_t)v792 < v874)
              v793 = 0;
            v794 = &v792[8 * v793];
            v795 = v12 + 8 * v793 + 8 * v879;
            if (v874)
            {
              v12 = v795;
              v791 = (unsigned __int16 *)v794;
              v23 = v794;
            }
            else
            {
              v23 += 8 * v879;
            }
            v796 = v882 == 1;
            v881 = v791;
            --v882;
          }
          while (!v796);
        }
      }
      else
      {
        v650 = -(uint64_t)v21;
        v651 = -(v879 * v22);
        do
        {
          v652 = v9;
          v653 = v882;
          do
          {
            v654 = *v16;
            if (*v16)
            {
              if (v654 == 255)
              {
                *v14 = *(int8x8_t *)v23;
              }
              else
              {
                v655 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
                v656 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v657.i32[0] = v654 | (v654 << 8);
                v657.i32[1] = ~v657.i32[0];
                *(int8x8_t *)v658.i8 = vand_s8(v657, (int8x8_t)0xFFFF0000FFFFLL);
                v659.i64[0] = v658.i64[0];
                v659.i64[1] = v658.i64[0];
                v660.i32[0] = (unsigned __int16)v656;
                v660.i32[1] = HIWORD(v655);
                v660.i64[1] = __PAIR64__(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16, bswap32(v14->u16[2]) >> 16);
                v658.i64[1] = v658.i64[0];
                v661 = vmulq_s32(v660, vrev64q_s32(v658));
                v660.i32[0] = (unsigned __int16)v655;
                v660.i32[1] = HIWORD(v656);
                v660.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(*((unsigned __int16 *)v23 + 2)) >> 16);
                v662 = (int8x16_t)vmlaq_s32(v661, v660, v659);
                *v14 = vrev16_s8((int8x8_t)vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v662, 0x10uLL), (int32x4_t)vmvnq_s8(v662)));
              }
            }
            v16 += v25;
            v663 = (unsigned __int16 *)&v23[8 * v25];
            if ((unint64_t)v663 >= v12)
              v664 = v650;
            else
              v664 = 0;
            v23 = (char *)&v663[4 * v664];
            v14 += v25;
            --v652;
          }
          while (v652);
          v16 += v876;
          v14 += v875;
          v665 = v881;
          v666 = (char *)&v881[4 * v879];
          if ((unint64_t)v666 >= v874)
            v667 = v651;
          else
            v667 = 0;
          v668 = &v666[8 * v667];
          v669 = v12 + 8 * v667 + 8 * v879;
          if (v874)
          {
            v12 = v669;
            v665 = (unsigned __int16 *)v668;
            v23 = v668;
          }
          else
          {
            v23 += 8 * v879;
          }
          v881 = v665;
          --v882;
        }
        while (v653 != 1);
      }
      return;
    case 2:
      v53 = v25;
      v54 = v22;
      if (v8)
      {
        v55 = -(v879 * v22);
        v56 = -(uint64_t)(v877 * v54);
        v57 = 2 * v8;
        v58 = -(uint64_t)v21;
        v59.i64[0] = 0x100000001;
        v59.i64[1] = 0x100000001;
        v60 = v880;
        while (1)
        {
          v61 = v878;
          v62 = v882;
          do
          {
            v63 = *v16;
            if (!*v16)
              goto LABEL_71;
            if (v63 != 255)
            {
              v66 = bswap32(*v60) >> 16;
              v67 = (v63 | (v63 << 8)) ^ 0xFFFF;
              v65 = v66 - ((v67 * v66 + ((v67 * v66) >> 16) + 1) >> 16);
              if (v66 == (v67 * v66 + ((v67 * v66) >> 16) + 1) >> 16)
                goto LABEL_71;
              v68 = bswap32(*((unsigned __int16 *)v23 + 2));
              v69 = bswap32(*((unsigned __int16 *)v23 + 3));
              v70 = ((unint64_t)(HIWORD(v69)
                                      - ((v67 * HIWORD(v69) + ((v67 * HIWORD(v69)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIWORD(v68) - ((v67 * HIWORD(v68) + ((v67 * HIWORD(v68)) >> 16) + 1) >> 16)) << 32);
              v71 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v72 = v70 | ((HIWORD(v71) - ((HIWORD(v71) * v67 + ((HIWORD(v71) * v67) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v71 - (((unsigned __int16)v71 * v67 + (((unsigned __int16)v71 * v67) >> 16) + 1) >> 16));
              goto LABEL_69;
            }
            v64 = *v60;
            v65 = __rev16(v64);
            if (!v65)
              goto LABEL_71;
            if (v65 != 0xFFFF)
            {
              v72 = ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16);
LABEL_69:
              v73 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
              v74 = bswap32(*v7);
              v75.i32[0] = (unsigned __int16)v73;
              v75.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v73), 0x10uLL).i32[1];
              v75.i32[2] = bswap32(v14->u16[2]) >> 16;
              v75.i32[3] = bswap32(v14->u16[3]) >> 16;
              v76 = (uint32x4_t)vmulq_s32(v75, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v65)));
              v77.i32[0] = v72;
              v77.i32[1] = WORD1(v72);
              *v14 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v77, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v72), (uint64x2_t)xmmword_185004DA0)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v76, v76, 0x10uLL), v59), 0x10uLL)));
              v64 = bswap32(v65+ (((unsigned __int16)~(_WORD)v65 * HIWORD(v74)+ (((unsigned __int16)~(_WORD)v65 * HIWORD(v74)) >> 16)+ 1) >> 16)) >> 16;
              goto LABEL_70;
            }
            *v14 = *(int8x8_t *)v23;
LABEL_70:
            *v7 = v64;
LABEL_71:
            v16 += v25;
            v78 = (unsigned __int16 *)&v23[8 * v25];
            v79 = &v60[v20];
            if ((unint64_t)v78 >= v12)
              v80 = v58;
            else
              v80 = 0;
            v60 = &v79[v80];
            v23 = (char *)&v78[4 * v80];
            v7 = (unsigned __int16 *)((char *)v7 + v57);
            v14 += v25;
            --v61;
          }
          while (v61);
          if (v874)
          {
            v81 = (char *)&v881[4 * v879];
            if ((unint64_t)v81 >= v874)
              v82 = v56;
            else
              v82 = 0;
            v83 = (uint64_t)&v880[v877 + v82];
            if ((unint64_t)v81 >= v874)
              v84 = v55;
            else
              v84 = 0;
            v23 = &v81[8 * v84];
            v12 += 8 * v84 + 8 * v879;
            v880 += v877 + v82;
            v881 = (unsigned __int16 *)v23;
            v60 = (unsigned __int16 *)v83;
          }
          else
          {
            v23 += 8 * v879;
            v60 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
          if (v62 == 1)
            return;
        }
      }
      v670 = -(v879 * v22);
      v671 = -(uint64_t)(v877 * v54);
      v672.i64[0] = 0x100000001;
      v672.i64[1] = 0x100000001;
      v673 = v880;
      v674 = -(uint64_t)v21;
LABEL_759:
      v675 = v878;
      v676 = v882;
      v677 = v880;
      while (1)
      {
        v678 = *v16;
        if (*v16)
        {
          if (v678 == 255)
          {
            v679 = bswap32(*v673) >> 16;
            if (v679)
            {
              if (v679 != 0xFFFF)
              {
                v693 = ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16);
                v694 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v695.i32[0] = (unsigned __int16)v694;
                v695.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v694), 0x10uLL).i32[1];
                v689 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v693), (uint64x2_t)xmmword_185004DA0);
                v695.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v696 = (uint32x4_t)vmulq_s32(v695, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v679)));
                v691 = (int32x4_t)vsraq_n_u32(v696, v696, 0x10uLL);
                v692.i32[0] = v693;
                v692.i32[1] = WORD1(v693);
                goto LABEL_768;
              }
              *v14 = *(int8x8_t *)v23;
            }
          }
          else
          {
            v680 = bswap32(*v673) >> 16;
            v681 = (v678 | (v678 << 8)) ^ 0xFFFF;
            v682 = v681 * v680 + ((v681 * v680) >> 16) + 1;
            if (v680 != HIWORD(v682))
            {
              v683 = bswap32(*((unsigned __int16 *)v23 + 2));
              v684 = bswap32(*((unsigned __int16 *)v23 + 3));
              v685 = ((unint64_t)(HIWORD(v684)
                                       - ((v681 * HIWORD(v684) + ((v681 * HIWORD(v684)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIWORD(v683) - ((v681 * HIWORD(v683) + ((v681 * HIWORD(v683)) >> 16) + 1) >> 16)) << 32);
              v686 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v687 = v685 | ((HIWORD(v686)
                            - ((HIWORD(v686) * v681 + ((HIWORD(v686) * v681) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v686 - (((unsigned __int16)v686 * v681 + (((unsigned __int16)v686 * v681) >> 16) + 1) >> 16));
              LODWORD(v685) = bswap32(v14->u16[1] | (v14->u16[0] << 16));
              v688.i32[0] = (unsigned __int16)v685;
              v688.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v685), 0x10uLL).i32[1];
              v689 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v687), (uint64x2_t)xmmword_185004DA0);
              v688.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
              v690 = (uint32x4_t)vmulq_s32(v688, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v680 + HIWORD(v682))));
              v691 = (int32x4_t)vsraq_n_u32(v690, v690, 0x10uLL);
              v692.i32[0] = v687;
              v692.i32[1] = WORD1(v687);
LABEL_768:
              *v14 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v692, v689), (uint32x4_t)vaddq_s32(v691, v672), 0x10uLL)));
            }
          }
        }
        v16 += v53;
        v697 = (unsigned __int16 *)&v23[8 * v53];
        v698 = &v673[v20];
        if ((unint64_t)v697 >= v12)
          v699 = v674;
        else
          v699 = 0;
        v673 = &v698[v699];
        v23 = (char *)&v697[4 * v699];
        v14 += v53;
        if (!--v675)
        {
          if (v874)
          {
            v700 = (char *)&v881[4 * v879];
            if ((unint64_t)v700 >= v874)
              v701 = v671;
            else
              v701 = 0;
            if ((unint64_t)v700 >= v874)
              v702 = v670;
            else
              v702 = 0;
            v23 = &v700[8 * v702];
            v12 += 8 * v702 + 8 * v879;
            v880 += v877 + v701;
            v881 = (unsigned __int16 *)v23;
            v673 = &v677[v877 + v701];
          }
          else
          {
            v23 += 8 * v879;
            v673 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
          if (v676 == 1)
            return;
          goto LABEL_759;
        }
      }
    case 3:
      v85 = v25;
      v897 = v20;
      v849 = -(v879 * v22);
      v828 = -(uint64_t)(v877 * v22);
      v885 = 2 * v8;
      v86 = 8 * v25;
      v87 = v880;
      v88 = -(uint64_t)v21;
      do
      {
        v89 = v878;
        v90 = v12;
        do
        {
          v91 = *v16;
          if (*v16)
          {
            if (v91 == 255)
            {
              if (v20)
                v92 = bswap32(*v87) >> 16;
              else
                v92 = 0xFFFF;
              CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v92, bswap32(*v7) >> 16);
            }
            else
            {
              if (v20)
                v93 = bswap32(*v87) >> 16;
              else
                v93 = 0xFFFF;
              v94 = v91 | (v91 << 8);
              v95 = bswap32(*v7) >> 16;
              CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v93, (v95 * v94 + ((v95 * v94) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v95, v94 ^ 0xFFFF);
            }
            v12 = v90;
            v20 = v923;
          }
          v16 += v85;
          v96 = (unsigned __int16 *)&v23[8 * v85];
          if ((unint64_t)v96 >= v12)
            v97 = v88;
          else
            v97 = 0;
          v87 += v897 + v97;
          v23 = (char *)&v96[4 * v97];
          v7 = (unsigned __int16 *)((char *)v7 + v885);
          v14 = (int8x8_t *)((char *)v14 + v86);
          --v89;
        }
        while (v89);
        if (v874)
        {
          v98 = (char *)&v881[4 * v879];
          v99 = v828;
          if ((unint64_t)v98 < v874)
            v99 = 0;
          v87 = &v880[v877 + v99];
          v100 = v849;
          if ((unint64_t)v98 < v874)
            v100 = 0;
          v23 = &v98[8 * v100];
          v12 += 8 * v100 + 8 * v879;
          v880 += v877 + v99;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v87 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 4:
      v101 = v25;
      v898 = v20;
      v850 = -(v879 * v22);
      v829 = -(uint64_t)(v877 * v22);
      v886 = 2 * v8;
      v102 = 8 * v25;
      v103 = v880;
      v104 = -(uint64_t)v21;
      do
      {
        v105 = v878;
        v106 = v12;
        do
        {
          v107 = *v16;
          if (*v16)
          {
            if (v107 == 255)
            {
              if (v20)
                v108 = bswap32(*v103) >> 16;
              else
                v108 = 0xFFFF;
              CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v108, bswap32(~*v7) >> 16);
            }
            else
            {
              if (v20)
                v109 = bswap32(*v103) >> 16;
              else
                v109 = 0xFFFF;
              v110 = v107 | (v107 << 8);
              v111 = bswap32(*v7) >> 16;
              CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v109, ((v111 ^ 0xFFFF) * v110 + (((v111 ^ 0xFFFF) * v110) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v111, v110 ^ 0xFFFF);
            }
            v12 = v106;
            v20 = v923;
          }
          v16 += v101;
          v112 = (unsigned __int16 *)&v23[8 * v101];
          if ((unint64_t)v112 >= v12)
            v113 = v104;
          else
            v113 = 0;
          v103 += v898 + v113;
          v23 = (char *)&v112[4 * v113];
          v7 = (unsigned __int16 *)((char *)v7 + v886);
          v14 = (int8x8_t *)((char *)v14 + v102);
          --v105;
        }
        while (v105);
        if (v874)
        {
          v114 = (char *)&v881[4 * v879];
          v115 = v829;
          if ((unint64_t)v114 < v874)
            v115 = 0;
          v103 = &v880[v877 + v115];
          v116 = v850;
          if ((unint64_t)v114 < v874)
            v116 = 0;
          v23 = &v114[8 * v116];
          v12 += 8 * v116 + 8 * v879;
          v880 += v877 + v115;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v103 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 5:
      v117 = v25;
      v899 = -(uint64_t)v21;
      v925 = v20;
      v887 = -(v879 * v22);
      v851 = -(uint64_t)(v877 * v22);
      v118 = 2 * v8;
      v119 = 8 * v25;
      v120 = v880;
      do
      {
        v121 = v878;
        do
        {
          if (*v16)
          {
            v122 = bswap32(*v120);
            v123 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
            v124 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
            v125 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
            v126 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v127 = ((unint64_t)(v123 - ((v126 * v123 + ((v126 * v123) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v124 - ((v126 * v124 + ((v126 * v124) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v125) - ((HIWORD(v125) * v126 + ((HIWORD(v125) * v126) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v125 - (((unsigned __int16)v125 * v126 + (((unsigned __int16)v125 * v126) >> 16) + 1) >> 16));
            v128 = HIWORD(v122) - ((v126 * HIWORD(v122) + ((v126 * HIWORD(v122)) >> 16) + 1) >> 16);
            v129 = bswap32(*v7) >> 16;
            CMYK64_DAMplusDAM(v14, v7, v127, (unsigned __int16)v128, v129, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v129, (unsigned __int16)~(_WORD)v128);
          }
          v16 += v117;
          v130 = (unsigned __int16 *)&v23[8 * v117];
          v131 = v899;
          if ((unint64_t)v130 < v12)
            v131 = 0;
          v120 += v925 + v131;
          v23 = (char *)&v130[4 * v131];
          v7 = (unsigned __int16 *)((char *)v7 + v118);
          v14 = (int8x8_t *)((char *)v14 + v119);
          --v121;
        }
        while (v121);
        if (v874)
        {
          v132 = (char *)&v881[4 * v879];
          v133 = v851;
          if ((unint64_t)v132 < v874)
            v133 = 0;
          v120 = &v880[v877 + v133];
          v134 = v887;
          if ((unint64_t)v132 < v874)
            v134 = 0;
          v23 = &v132[8 * v134];
          v12 += 8 * v134 + 8 * v879;
          v880 += v877 + v133;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v120 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 6:
      v135 = v25;
      v136 = v20;
      v137 = v880;
      v830 = -(v879 * v22);
      v812 = -(uint64_t)(v877 * v22);
      v138 = 2 * v8;
      v139 = 8 * v25;
      v140 = -(uint64_t)v21;
      v888 = v20;
      do
      {
        v141 = v878;
        v900 = v12;
        do
        {
          v142 = *v16;
          if (*v16)
          {
            v143 = bswap32(*v7);
            if (HIWORD(v143) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v143) == 0xFFFF)
              {
                if (v20)
                  v144 = bswap32(*v137) >> 16;
                else
                  v144 = 0xFFFF;
                CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v144, v142 | (v142 << 8));
                v12 = v900;
                v20 = v923;
                v136 = v888;
              }
              else
              {
                if (v20)
                  v145 = bswap32(*v137) >> 16;
                else
                  v145 = 0xFFFF;
                v146 = ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16);
                v147 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
                v148 = (257 * v142 * (unsigned __int16)~HIWORD(v143)
                      + ((257 * v142 * (unsigned __int16)~HIWORD(v143)) >> 16)
                      + 1) >> 16;
                v149.i32[0] = (unsigned __int16)v147;
                v149.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v147), 0x10uLL).i32[1];
                v149.i64[1] = __PAIR64__(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16, bswap32(*((unsigned __int16 *)v23 + 2)) >> 16);
                v150 = (uint32x4_t)vmulq_s32(v149, vdupq_n_s32(v148));
                v151.i64[0] = 0x100000001;
                v151.i64[1] = 0x100000001;
                v152 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v150, v150, 0x10uLL), v151);
                v151.i32[0] = v146;
                v151.i32[1] = WORD1(v146);
                *v14 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v151.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v146), (uint64x2_t)xmmword_185004DA0)), v152, 0x10uLL)));
                *v7 = bswap32(HIWORD(v143) + ((v148 * v145 + ((v148 * v145) >> 16) + 1) >> 16)) >> 16;
              }
            }
          }
          v16 += v135;
          v153 = (unsigned __int16 *)&v23[8 * v135];
          if ((unint64_t)v153 >= v12)
            v154 = v140;
          else
            v154 = 0;
          v137 += v136 + v154;
          v23 = (char *)&v153[4 * v154];
          v7 = (unsigned __int16 *)((char *)v7 + v138);
          v14 = (int8x8_t *)((char *)v14 + v139);
          --v141;
        }
        while (v141);
        if (v874)
        {
          v155 = (char *)&v881[4 * v879];
          v156 = v812;
          if ((unint64_t)v155 < v874)
            v156 = 0;
          v137 = &v880[v877 + v156];
          v157 = v830;
          if ((unint64_t)v155 < v874)
            v157 = 0;
          v23 = &v155[8 * v157];
          v12 += 8 * v157 + 8 * v879;
          v880 += v877 + v156;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v137 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 7:
      v158 = v25;
      if (v8)
      {
        v926 = v20;
        v889 = -(v879 * v22);
        v852 = -(uint64_t)(v877 * v22);
        v901 = 2 * v8;
        v159 = v880;
        v160 = -(uint64_t)v21;
        do
        {
          v161 = v878;
          v162 = v12;
          do
          {
            v163 = *v16;
            if (*v16)
            {
              if (v163 == 255)
              {
                CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, bswap32(*v159) >> 16);
              }
              else
              {
                v164 = bswap32(*v159);
                v165 = ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16);
                v166 = bswap32(*v7) >> 16;
                CMYK64_DAMplusDAM(v14, v7, v165, v166, (HIWORD(v164) * (v163 | (v163 << 8)) + ((HIWORD(v164) * (v163 | (v163 << 8))) >> 16) + 1) >> 16, v165, v166, (v163 | (v163 << 8)) ^ 0xFFFF);
              }
              v12 = v162;
            }
            v16 += v158;
            v167 = (unsigned __int16 *)&v23[8 * v158];
            if ((unint64_t)v167 >= v12)
              v168 = v160;
            else
              v168 = 0;
            v159 += v926 + v168;
            v23 = (char *)&v167[4 * v168];
            v7 = (unsigned __int16 *)((char *)v7 + v901);
            v14 += v158;
            --v161;
          }
          while (v161);
          if (v874)
          {
            v169 = (char *)&v881[4 * v879];
            v170 = v852;
            if ((unint64_t)v169 < v874)
              v170 = 0;
            v159 = &v880[v877 + v170];
            v171 = v889;
            if ((unint64_t)v169 < v874)
              v171 = 0;
            v23 = &v169[8 * v171];
            v12 += 8 * v171 + 8 * v879;
            v880 += v877 + v170;
            v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v159 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        v703 = -(uint64_t)v21;
        v704 = v22;
        v705 = v880;
        v706 = -(v879 * v22);
        v707 = -(uint64_t)(v877 * v704);
        v708.i64[0] = 0x100000001;
        v708.i64[1] = 0x100000001;
        do
        {
          v709 = v878;
          v710 = v882;
          do
          {
            v711 = *v16;
            if (*v16)
            {
              if (v711 == 255)
              {
                v712 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v713.i32[0] = (unsigned __int16)v712;
                v713.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v712), 0x10uLL).i32[1];
                v713.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v714 = (uint32x4_t)vmulq_s32(v713, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(bswap32(~*v705) >> 16)));
                v713.i32[0] = v712;
                v715 = vsubq_s32(v713, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v714, v714, 0x10uLL), v708), 0x10uLL));
              }
              else
              {
                v716 = v711 | (v711 << 8);
                v717 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v718 = bswap32(*v705);
                v719.i32[0] = (unsigned __int16)v717;
                v719.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v717), 0x10uLL).i32[1];
                v720.i32[0] = (HIWORD(v718) * v716 + ((HIWORD(v718) * v716) >> 16) + 1) >> 16;
                v720.i32[1] = ~v716;
                *(int8x8_t *)v721.i8 = vand_s8(v720, (int8x8_t)0xFFFF0000FFFFLL);
                v722.i64[0] = v721.i64[0];
                v722.i64[1] = v721.i64[0];
                v719.i32[2] = bswap32(v14->u16[2]) >> 16;
                v719.i32[3] = bswap32(v14->u16[3]) >> 16;
                v721.i64[1] = v721.i64[0];
                v723 = (int8x16_t)vmulq_s32(v719, vaddq_s32(v722, vrev64q_s32(v721)));
                v715 = (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v723, 0x10uLL), (int32x4_t)vmvnq_s8(v723)), 0x10uLL);
              }
              *v14 = vrev16_s8((int8x8_t)vmovn_s32(v715));
            }
            v16 += v158;
            v724 = (unsigned __int16 *)&v23[8 * v158];
            v725 = &v705[v20];
            if ((unint64_t)v724 >= v12)
              v726 = v703;
            else
              v726 = 0;
            v705 = &v725[v726];
            v23 = (char *)&v724[4 * v726];
            v14 += v158;
            --v709;
          }
          while (v709);
          if (v874)
          {
            v727 = (char *)&v881[4 * v879];
            if ((unint64_t)v727 >= v874)
              v728 = v707;
            else
              v728 = 0;
            v729 = (uint64_t)&v880[v877 + v728];
            if ((unint64_t)v727 >= v874)
              v730 = v706;
            else
              v730 = 0;
            v23 = &v727[8 * v730];
            v12 += 8 * v730 + 8 * v879;
            v880 += v877 + v728;
            v881 = (unsigned __int16 *)v23;
            v705 = (unsigned __int16 *)v729;
          }
          else
          {
            v23 += 8 * v879;
            v705 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v710 != 1);
      }
      return;
    case 8:
      v172 = v25;
      if (v8)
      {
        v927 = v20;
        v890 = -(v879 * v22);
        v853 = -(uint64_t)(v877 * v22);
        v902 = 2 * v8;
        v173 = v880;
        v174 = -(uint64_t)v21;
        do
        {
          v175 = v878;
          v176 = v12;
          do
          {
            v177 = *v16;
            if (*v16)
            {
              v178 = ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16);
              v179 = bswap32(*v7) >> 16;
              if (v177 == 255)
              {
                v180 = bswap32(~*v173);
              }
              else
              {
                v181 = bswap32(*v173) >> 16;
                v180 = ~(257 * v177 * v181 + ((257 * v177 * v181) >> 16) + 1);
              }
              CMYK64_DAM(v14, v7, v178, v179, HIWORD(v180));
              v12 = v176;
            }
            v16 += v172;
            v182 = (unsigned __int16 *)&v23[8 * v172];
            if ((unint64_t)v182 >= v12)
              v183 = v174;
            else
              v183 = 0;
            v173 += v927 + v183;
            v23 = (char *)&v182[4 * v183];
            v7 = (unsigned __int16 *)((char *)v7 + v902);
            v14 += v172;
            --v175;
          }
          while (v175);
          if (v874)
          {
            v184 = (char *)&v881[4 * v879];
            v185 = v853;
            if ((unint64_t)v184 < v874)
              v185 = 0;
            v173 = &v880[v877 + v185];
            v186 = v890;
            if ((unint64_t)v184 < v874)
              v186 = 0;
            v23 = &v184[8 * v186];
            v12 += 8 * v186 + 8 * v879;
            v880 += v877 + v185;
            v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v173 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        v731 = -(uint64_t)v21;
        v732 = v22;
        v733 = v880;
        v734 = -(v879 * v22);
        v735 = -(uint64_t)(v877 * v732);
        v736.i64[0] = 0x100000001;
        v736.i64[1] = 0x100000001;
        do
        {
          v737 = v878;
          v738 = v882;
          do
          {
            v739 = *v16;
            if (*v16)
            {
              if (v739 == 255)
              {
                v740 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v741.i32[0] = (unsigned __int16)v740;
                v741.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v740), 0x10uLL).i32[1];
                v741.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v742 = (uint32x4_t)vmulq_s32(v741, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(bswap32(*v733) >> 16)));
                v741.i32[0] = v740;
                v743 = vsubq_s32(v741, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v742, v742, 0x10uLL), v736), 0x10uLL));
              }
              else
              {
                v744 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v745 = bswap32(*v733) >> 16;
                v746.i32[0] = (unsigned __int16)v744;
                v746.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v744), 0x10uLL).i32[1];
                v746.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                v747 = (uint32x4_t)vmulq_s32(v746, vdupq_n_s32((257 * v739 * v745 + ((257 * v739 * v745) >> 16) + 1) >> 16));
                v746.i32[0] = v744;
                v743 = vsubq_s32(v746, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v747, v747, 0x10uLL), v736), 0x10uLL));
              }
              *v14 = vrev16_s8((int8x8_t)vmovn_s32(v743));
            }
            v16 += v172;
            v748 = (unsigned __int16 *)&v23[8 * v172];
            v749 = &v733[v20];
            if ((unint64_t)v748 >= v12)
              v750 = v731;
            else
              v750 = 0;
            v733 = &v749[v750];
            v23 = (char *)&v748[4 * v750];
            v14 += v172;
            --v737;
          }
          while (v737);
          if (v874)
          {
            v751 = (char *)&v881[4 * v879];
            if ((unint64_t)v751 >= v874)
              v752 = v735;
            else
              v752 = 0;
            v753 = (uint64_t)&v880[v877 + v752];
            if ((unint64_t)v751 >= v874)
              v754 = v734;
            else
              v754 = 0;
            v23 = &v751[8 * v754];
            v12 += 8 * v754 + 8 * v879;
            v880 += v877 + v752;
            v881 = (unsigned __int16 *)v23;
            v733 = (unsigned __int16 *)v753;
          }
          else
          {
            v23 += 8 * v879;
            v733 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v738 != 1);
      }
      return;
    case 9:
      v187 = v25;
      v903 = -(uint64_t)v21;
      v928 = v20;
      v891 = -(v879 * v22);
      v854 = -(uint64_t)(v877 * v22);
      v188 = 2 * v8;
      v189 = 8 * v25;
      v190 = v880;
      do
      {
        v191 = v878;
        do
        {
          if (*v16)
          {
            v192 = bswap32(*v7) >> 16;
            v193 = bswap32(*v190);
            v194 = bswap32(*((unsigned __int16 *)v23 + 3));
            v195 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
            v196 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
            v197 = ~(*v16 | (*v16 << 8));
            v198 = v197;
            v199 = ((unint64_t)(HIWORD(v194)
                                     - ((HIWORD(v194) * v198 + ((HIWORD(v194) * v198) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v195 - ((v195 * v198 + ((v195 * v198) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v196) - ((HIWORD(v196) * v198 + ((HIWORD(v196) * v198) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v196 - (((unsigned __int16)v196 * v198 + (((unsigned __int16)v196 * v198) >> 16) + 1) >> 16));
            v200 = HIWORD(v193) - ((HIWORD(v193) * v198 + ((HIWORD(v193) * v198) >> 16) + 1) >> 16);
            CMYK64_DAMplusDAM(v14, v7, v199, (unsigned __int16)v200, v192 ^ 0xFFFF, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v192, (unsigned __int16)(v200 + v197));
          }
          v16 += v187;
          v201 = (unsigned __int16 *)&v23[8 * v187];
          v202 = v903;
          if ((unint64_t)v201 < v12)
            v202 = 0;
          v190 += v928 + v202;
          v23 = (char *)&v201[4 * v202];
          v7 = (unsigned __int16 *)((char *)v7 + v188);
          v14 = (int8x8_t *)((char *)v14 + v189);
          --v191;
        }
        while (v191);
        if (v874)
        {
          v203 = (char *)&v881[4 * v879];
          v204 = v854;
          if ((unint64_t)v203 < v874)
            v204 = 0;
          v190 = &v880[v877 + v204];
          v205 = v891;
          if ((unint64_t)v203 < v874)
            v205 = 0;
          v23 = &v203[8 * v205];
          v12 += 8 * v205 + 8 * v879;
          v880 += v877 + v204;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v190 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 10:
      v206 = v25;
      v904 = -(uint64_t)v21;
      v929 = v20;
      v892 = -(v879 * v22);
      v855 = -(uint64_t)(v877 * v22);
      v207 = 2 * v8;
      v208 = 8 * v25;
      v209 = v880;
      do
      {
        v210 = v878;
        do
        {
          if (*v16)
          {
            v211 = bswap32(*v7) >> 16;
            v212 = bswap32(*v209);
            v213 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
            v214 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
            v215 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
            v216 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v217 = ((unint64_t)(v213 - ((v216 * v213 + ((v216 * v213) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v214 - ((v216 * v214 + ((v216 * v214) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v215) - ((HIWORD(v215) * v216 + ((HIWORD(v215) * v216) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v215 - (((unsigned __int16)v215 * v216 + (((unsigned __int16)v215 * v216) >> 16) + 1) >> 16));
            v218 = HIWORD(v212) - ((v216 * HIWORD(v212) + ((v216 * HIWORD(v212)) >> 16) + 1) >> 16);
            CMYK64_DAMplusDAM(v14, v7, v217, (unsigned __int16)v218, v211 ^ 0xFFFF, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v211, (unsigned __int16)~(_WORD)v218);
          }
          v16 += v206;
          v219 = (unsigned __int16 *)&v23[8 * v206];
          v220 = v904;
          if ((unint64_t)v219 < v12)
            v220 = 0;
          v209 += v929 + v220;
          v23 = (char *)&v219[4 * v220];
          v7 = (unsigned __int16 *)((char *)v7 + v207);
          v14 = (int8x8_t *)((char *)v14 + v208);
          --v210;
        }
        while (v210);
        if (v874)
        {
          v221 = (char *)&v881[4 * v879];
          v222 = v855;
          if ((unint64_t)v221 < v874)
            v222 = 0;
          v209 = &v880[v877 + v222];
          v223 = v892;
          if ((unint64_t)v221 < v874)
            v223 = 0;
          v23 = &v221[8 * v223];
          v12 += 8 * v223 + 8 * v879;
          v880 += v877 + v222;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v209 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 11:
      v224 = v25;
      if (v8)
      {
        v905 = v20;
        v856 = -(v879 * v22);
        v831 = -(uint64_t)(v877 * v22);
        v893 = 2 * v8;
        v225 = v880;
        v226 = -(uint64_t)v21;
        do
        {
          v227 = v878;
          v228 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
                v229 = bswap32(*v225) >> 16;
              else
                v229 = 0xFFFF;
              v230 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v231 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v232 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v233 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DAplusdDA((int *)v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, ((unint64_t)(v230 - ((v233 * v230 + ((v233 * v230) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v231 - ((v233 * v231 + ((v233 * v231) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v232) - ((HIWORD(v232) * v233 + ((HIWORD(v232) * v233) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v232 - (((unsigned __int16)v232 * v233 + (((unsigned __int16)v232 * v233) >> 16) + 1) >> 16)), (unsigned __int16)(v229 - ((v229 * v233 + ((v229 * v233) >> 16) + 1) >> 16)));
              v12 = v228;
              v20 = v923;
            }
            v16 += v224;
            v234 = (unsigned __int16 *)&v23[8 * v224];
            if ((unint64_t)v234 >= v12)
              v235 = v226;
            else
              v235 = 0;
            v225 += v905 + v235;
            v23 = (char *)&v234[4 * v235];
            v7 = (unsigned __int16 *)((char *)v7 + v893);
            v14 += v224;
            --v227;
          }
          while (v227);
          if (v874)
          {
            v236 = (char *)&v881[4 * v879];
            v237 = v831;
            if ((unint64_t)v236 < v874)
              v237 = 0;
            v225 = &v880[v877 + v237];
            v238 = v856;
            if ((unint64_t)v236 < v874)
              v238 = 0;
            v23 = &v236[8 * v238];
            v12 += 8 * v238 + 8 * v879;
            v880 += v877 + v237;
            v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v225 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        v755 = v20;
        v756 = -(uint64_t)v21;
        v922 = -(v879 * v22);
        v895 = -(uint64_t)(v877 * v22);
        v757 = v880;
        do
        {
          v758 = v878;
          v759 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
                v760 = bswap32(*v757) >> 16;
              else
                v760 = 0xFFFF;
              v761 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v762 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v763 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v764 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DplusdDA(v14, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), ((unint64_t)(v761 - ((v764 * v761 + ((v764 * v761) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v762 - ((v764 * v762 + ((v764 * v762) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v763) - ((HIWORD(v763) * v764 + ((HIWORD(v763) * v764) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v763 - (((unsigned __int16)v763 * v764 + (((unsigned __int16)v763 * v764) >> 16) + 1) >> 16)), (unsigned __int16)(v760 - ((v760 * v764 + ((v760 * v764) >> 16) + 1) >> 16)));
              v12 = v759;
              v20 = v923;
            }
            v16 += v224;
            v765 = (unsigned __int16 *)&v23[8 * v224];
            if ((unint64_t)v765 >= v12)
              v766 = v756;
            else
              v766 = 0;
            v757 += v755 + v766;
            v23 = (char *)&v765[4 * v766];
            v14 += v224;
            --v758;
          }
          while (v758);
          if (v874)
          {
            v767 = (char *)&v881[4 * v879];
            v768 = v895;
            if ((unint64_t)v767 < v874)
              v768 = 0;
            v757 = &v880[v877 + v768];
            v769 = v922;
            if ((unint64_t)v767 < v874)
              v769 = 0;
            v23 = &v767[8 * v769];
            v12 += 8 * v769 + 8 * v879;
            v880 += v877 + v768;
            v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v757 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v882);
      }
      return;
    case 12:
      v239 = v25;
      if (v8)
      {
        v906 = v20;
        v857 = -(v879 * v22);
        v832 = -(uint64_t)(v877 * v22);
        v894 = 2 * v8;
        v240 = v880;
        v241 = -(uint64_t)v21;
        do
        {
          v242 = v878;
          v243 = v12;
          do
          {
            if (*v16)
            {
              if (v20)
                v244 = bswap32(*v240) >> 16;
              else
                v244 = 0xFFFF;
              v245 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v246 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v247 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v248 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DApluslDA((unsigned int *)v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, ((unint64_t)(v245 - ((v248 * v245 + ((v248 * v245) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v246 - ((v248 * v246 + ((v248 * v246) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v247) - ((HIWORD(v247) * v248 + ((HIWORD(v247) * v248) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v247 - (((unsigned __int16)v247 * v248 + (((unsigned __int16)v247 * v248) >> 16) + 1) >> 16)), (unsigned __int16)(v244 - ((v244 * v248 + ((v244 * v248) >> 16) + 1) >> 16)));
              v12 = v243;
              v20 = v923;
            }
            v16 += v239;
            v249 = (unsigned __int16 *)&v23[8 * v239];
            if ((unint64_t)v249 >= v12)
              v250 = v241;
            else
              v250 = 0;
            v240 += v906 + v250;
            v23 = (char *)&v249[4 * v250];
            v7 = (unsigned __int16 *)((char *)v7 + v894);
            v14 += v239;
            --v242;
          }
          while (v242);
          if (v874)
          {
            v251 = (char *)&v881[4 * v879];
            v252 = v832;
            if ((unint64_t)v251 < v874)
              v252 = 0;
            v240 = &v880[v877 + v252];
            v253 = v857;
            if ((unint64_t)v251 < v874)
              v253 = 0;
            v23 = &v251[8 * v253];
            v12 += 8 * v253 + 8 * v879;
            v880 += v877 + v252;
            v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v240 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        v770 = -(uint64_t)v21;
        v930 = -(v879 * v22);
        do
        {
          v771 = v878;
          v772 = v882;
          do
          {
            if (*v16)
            {
              v773 = bswap32(*((unsigned __int16 *)v23 + 3));
              v774 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v775 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v776 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DpluslD(v14, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), ((unint64_t)(HIWORD(v773)- ((v776 * HIWORD(v773) + ((v776 * HIWORD(v773)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v774 - ((v776 * v774 + ((v776 * v774) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v775) - ((HIWORD(v775) * v776 + ((HIWORD(v775) * v776) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v775 - (((unsigned __int16)v775 * v776 + (((unsigned __int16)v775 * v776) >> 16) + 1) >> 16)));
            }
            v16 += v239;
            v777 = (unsigned __int16 *)&v23[8 * v239];
            if ((unint64_t)v777 >= v12)
              v778 = v770;
            else
              v778 = 0;
            v23 = (char *)&v777[4 * v778];
            v14 += v239;
            --v771;
          }
          while (v771);
          v16 += v876;
          v14 += v875;
          v779 = v881;
          v780 = (char *)&v881[4 * v879];
          v781 = v930;
          if ((unint64_t)v780 < v874)
            v781 = 0;
          v782 = &v780[8 * v781];
          v783 = v12 + 8 * v781 + 8 * v879;
          if (v874)
          {
            v12 = v783;
            v779 = (unsigned __int16 *)v782;
            v23 = v782;
          }
          else
          {
            v23 += 8 * v879;
          }
          v881 = v779;
          --v882;
        }
        while (v772 != 1);
      }
      return;
    case 13:
      v254 = v25;
      v255 = v20;
      v256 = v880;
      v813 = -(v879 * v22);
      v797 = -(uint64_t)(v877 * v22);
      v257 = 2 * v8;
      v258 = 8 * v25;
      v259 = -(uint64_t)v21;
      v833 = v257;
      v858 = v20;
      while (1)
      {
        v260 = v878;
        v907 = v12;
        do
        {
          if (*v16)
          {
            v261 = v20 ? bswap32(*v256) >> 16 : 0xFFFF;
            v262 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v263 = v261 - ((v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16);
            LODWORD(v264) = (unsigned __int16)(v261 - ((v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16));
            if ((_WORD)v261 != (v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16)
            {
              v265 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v266 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v267 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v268 = HIWORD(v267);
              v269 = ((unint64_t)(v265 - ((v262 * v265 + ((v262 * v265) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v266 - ((v262 * v266 + ((v262 * v266) >> 16) + 1) >> 16)) << 32) | ((v268 - ((v268 * v262 + ((v268 * v262) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v267 - (((unsigned __int16)v267 * v262 + (((unsigned __int16)v267 * v262) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v270 = __rev16(*v7);
                  goto LABEL_307;
                }
LABEL_309:
                v273 = bswap32(v269);
                v14->i16[0] = HIWORD(v273);
                v14->i16[1] = v273;
                v14->i16[2] = bswap32(HIDWORD(v269)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v269));
                v271 = v7;
              }
              else
              {
                v270 = 0xFFFF;
LABEL_307:
                v271 = (_WORD *)v14 + 3;
                v272 = PDAmultiplyPDA_10646(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v270, v269, (unsigned __int16)v263);
                v269 = v272;
                v8 = v883;
                if (v883)
                {
                  v12 = v907;
                  v20 = v923;
                  v257 = v833;
                  v255 = v858;
                  goto LABEL_309;
                }
                v264 = HIWORD(v272);
                v274 = bswap32(v272);
                v14->i16[0] = HIWORD(v274);
                v14->i16[1] = v274;
                v14->i16[2] = bswap32(HIDWORD(v272)) >> 16;
                v12 = v907;
                v20 = v923;
                v257 = v833;
                v255 = v858;
              }
              *v271 = bswap32(v264) >> 16;
            }
          }
          v16 += v254;
          v14 = (int8x8_t *)((char *)v14 + v258);
          v275 = (unsigned __int16 *)&v23[8 * v254];
          if ((unint64_t)v275 >= v12)
            v276 = v259;
          else
            v276 = 0;
          v256 += v255 + v276;
          v23 = (char *)&v275[4 * v276];
          v7 = (unsigned __int16 *)((char *)v7 + v257);
          --v260;
        }
        while (v260);
        if (v874)
        {
          v277 = (char *)&v881[4 * v879];
          v278 = v797;
          if ((unint64_t)v277 < v874)
            v278 = 0;
          v256 = &v880[v877 + v278];
          v279 = v813;
          if ((unint64_t)v277 < v874)
            v279 = 0;
          v23 = &v277[8 * v279];
          v12 += 8 * v279 + 8 * v879;
          v880 += v877 + v278;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v256 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 14:
      v280 = v25;
      v281 = v20;
      v282 = v880;
      v814 = -(v879 * v22);
      v798 = -(uint64_t)(v877 * v22);
      v283 = 2 * v8;
      v284 = 8 * v25;
      v285 = -(uint64_t)v21;
      v834 = v283;
      v859 = v20;
      while (1)
      {
        v286 = v878;
        v908 = v12;
        do
        {
          if (*v16)
          {
            v287 = v20 ? bswap32(*v282) >> 16 : 0xFFFF;
            v288 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v289 = v287 - ((v287 * v288 + ((v287 * v288) >> 16) + 1) >> 16);
            LODWORD(v290) = (unsigned __int16)(v287 - ((v287 * v288 + ((v287 * v288) >> 16) + 1) >> 16));
            if ((_WORD)v287 != (v287 * v288 + ((v287 * v288) >> 16) + 1) >> 16)
            {
              v291 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v292 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v293 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v294 = HIWORD(v293);
              v295 = ((unint64_t)(v291 - ((v288 * v291 + ((v288 * v291) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v292 - ((v288 * v292 + ((v288 * v292) >> 16) + 1) >> 16)) << 32) | ((v294 - ((v294 * v288 + ((v294 * v288) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v293 - (((unsigned __int16)v293 * v288 + (((unsigned __int16)v293 * v288) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v296 = __rev16(*v7);
                  goto LABEL_336;
                }
LABEL_338:
                v299 = bswap32(v295);
                v14->i16[0] = HIWORD(v299);
                v14->i16[1] = v299;
                v14->i16[2] = bswap32(HIDWORD(v295)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v295));
                v297 = v7;
              }
              else
              {
                v296 = 0xFFFF;
LABEL_336:
                v297 = (_WORD *)v14 + 3;
                v298 = PDAscreenPDA_10647(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v296, v295, (unsigned __int16)v289);
                v295 = v298;
                v8 = v883;
                if (v883)
                {
                  v12 = v908;
                  v20 = v923;
                  v283 = v834;
                  v281 = v859;
                  goto LABEL_338;
                }
                v290 = HIWORD(v298);
                v300 = bswap32(v298);
                v14->i16[0] = HIWORD(v300);
                v14->i16[1] = v300;
                v14->i16[2] = bswap32(HIDWORD(v298)) >> 16;
                v12 = v908;
                v20 = v923;
                v283 = v834;
                v281 = v859;
              }
              *v297 = bswap32(v290) >> 16;
            }
          }
          v16 += v280;
          v14 = (int8x8_t *)((char *)v14 + v284);
          v301 = (unsigned __int16 *)&v23[8 * v280];
          if ((unint64_t)v301 >= v12)
            v302 = v285;
          else
            v302 = 0;
          v282 += v281 + v302;
          v23 = (char *)&v301[4 * v302];
          v7 = (unsigned __int16 *)((char *)v7 + v283);
          --v286;
        }
        while (v286);
        if (v874)
        {
          v303 = (char *)&v881[4 * v879];
          v304 = v798;
          if ((unint64_t)v303 < v874)
            v304 = 0;
          v282 = &v880[v877 + v304];
          v305 = v814;
          if ((unint64_t)v303 < v874)
            v305 = 0;
          v23 = &v303[8 * v305];
          v12 += 8 * v305 + 8 * v879;
          v880 += v877 + v304;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v282 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 15:
      v306 = v25;
      v307 = v20;
      v308 = v880;
      v815 = -(v879 * v22);
      v799 = -(uint64_t)(v877 * v22);
      v309 = 2 * v8;
      v310 = 8 * v25;
      v311 = -(uint64_t)v21;
      v835 = v309;
      v860 = v20;
      while (1)
      {
        v312 = v878;
        v909 = v12;
        do
        {
          if (*v16)
          {
            v313 = v20 ? bswap32(*v308) >> 16 : 0xFFFF;
            v314 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v315 = v313 - ((v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16);
            LODWORD(v316) = (unsigned __int16)(v313 - ((v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16));
            if ((_WORD)v313 != (v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16)
            {
              v317 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v318 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v319 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v320 = HIWORD(v319);
              v321 = ((unint64_t)(v317 - ((v314 * v317 + ((v314 * v317) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v318 - ((v314 * v318 + ((v314 * v318) >> 16) + 1) >> 16)) << 32) | ((v320 - ((v320 * v314 + ((v320 * v314) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v319 - (((unsigned __int16)v319 * v314 + (((unsigned __int16)v319 * v314) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v322 = __rev16(*v7);
                  goto LABEL_365;
                }
LABEL_367:
                v325 = bswap32(v321);
                v14->i16[0] = HIWORD(v325);
                v14->i16[1] = v325;
                v14->i16[2] = bswap32(HIDWORD(v321)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v321));
                v323 = v7;
              }
              else
              {
                v322 = 0xFFFF;
LABEL_365:
                v323 = (_WORD *)v14 + 3;
                v324 = PDAoverlayPDA_10648(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v322, v321, (unsigned __int16)v315);
                v321 = v324;
                v8 = v883;
                if (v883)
                {
                  v12 = v909;
                  v20 = v923;
                  v309 = v835;
                  v307 = v860;
                  goto LABEL_367;
                }
                v316 = HIWORD(v324);
                v326 = bswap32(v324);
                v14->i16[0] = HIWORD(v326);
                v14->i16[1] = v326;
                v14->i16[2] = bswap32(HIDWORD(v324)) >> 16;
                v12 = v909;
                v20 = v923;
                v309 = v835;
                v307 = v860;
              }
              *v323 = bswap32(v316) >> 16;
            }
          }
          v16 += v306;
          v14 = (int8x8_t *)((char *)v14 + v310);
          v327 = (unsigned __int16 *)&v23[8 * v306];
          if ((unint64_t)v327 >= v12)
            v328 = v311;
          else
            v328 = 0;
          v308 += v307 + v328;
          v23 = (char *)&v327[4 * v328];
          v7 = (unsigned __int16 *)((char *)v7 + v309);
          --v312;
        }
        while (v312);
        if (v874)
        {
          v329 = (char *)&v881[4 * v879];
          v330 = v799;
          if ((unint64_t)v329 < v874)
            v330 = 0;
          v308 = &v880[v877 + v330];
          v331 = v815;
          if ((unint64_t)v329 < v874)
            v331 = 0;
          v23 = &v329[8 * v331];
          v12 += 8 * v331 + 8 * v879;
          v880 += v877 + v330;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v308 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 16:
      v332 = v25;
      v333 = v20;
      v334 = v880;
      v816 = -(v879 * v22);
      v800 = -(uint64_t)(v877 * v22);
      v335 = 2 * v8;
      v336 = 8 * v25;
      v337 = -(uint64_t)v21;
      v836 = v335;
      v861 = v20;
      while (1)
      {
        v338 = v878;
        v910 = v12;
        do
        {
          if (*v16)
          {
            v339 = v20 ? bswap32(*v334) >> 16 : 0xFFFF;
            v340 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v341 = v339 - ((v339 * v340 + ((v339 * v340) >> 16) + 1) >> 16);
            LODWORD(v342) = (unsigned __int16)(v339 - ((v339 * v340 + ((v339 * v340) >> 16) + 1) >> 16));
            if ((_WORD)v339 != (v339 * v340 + ((v339 * v340) >> 16) + 1) >> 16)
            {
              v343 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v344 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v345 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v346 = HIWORD(v345);
              v347 = ((unint64_t)(v343 - ((v340 * v343 + ((v340 * v343) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v344 - ((v340 * v344 + ((v340 * v344) >> 16) + 1) >> 16)) << 32) | ((v346 - ((v346 * v340 + ((v346 * v340) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v345 - (((unsigned __int16)v345 * v340 + (((unsigned __int16)v345 * v340) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v348 = __rev16(*v7);
                  goto LABEL_394;
                }
LABEL_396:
                v351 = bswap32(v347);
                v14->i16[0] = HIWORD(v351);
                v14->i16[1] = v351;
                v14->i16[2] = bswap32(HIDWORD(v347)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v347));
                v349 = v7;
              }
              else
              {
                v348 = 0xFFFF;
LABEL_394:
                v349 = (_WORD *)v14 + 3;
                v350 = PDAdarkenPDA_10650(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v348, v347, (unsigned __int16)v341);
                v347 = v350;
                v8 = v883;
                if (v883)
                {
                  v12 = v910;
                  v20 = v923;
                  v335 = v836;
                  v333 = v861;
                  goto LABEL_396;
                }
                v342 = HIWORD(v350);
                v352 = bswap32(v350);
                v14->i16[0] = HIWORD(v352);
                v14->i16[1] = v352;
                v14->i16[2] = bswap32(HIDWORD(v350)) >> 16;
                v12 = v910;
                v20 = v923;
                v335 = v836;
                v333 = v861;
              }
              *v349 = bswap32(v342) >> 16;
            }
          }
          v16 += v332;
          v14 = (int8x8_t *)((char *)v14 + v336);
          v353 = (unsigned __int16 *)&v23[8 * v332];
          if ((unint64_t)v353 >= v12)
            v354 = v337;
          else
            v354 = 0;
          v334 += v333 + v354;
          v23 = (char *)&v353[4 * v354];
          v7 = (unsigned __int16 *)((char *)v7 + v335);
          --v338;
        }
        while (v338);
        if (v874)
        {
          v355 = (char *)&v881[4 * v879];
          v356 = v800;
          if ((unint64_t)v355 < v874)
            v356 = 0;
          v334 = &v880[v877 + v356];
          v357 = v816;
          if ((unint64_t)v355 < v874)
            v357 = 0;
          v23 = &v355[8 * v357];
          v12 += 8 * v357 + 8 * v879;
          v880 += v877 + v356;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v334 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 17:
      v358 = v25;
      v359 = v20;
      v360 = v880;
      v817 = -(v879 * v22);
      v801 = -(uint64_t)(v877 * v22);
      v361 = 2 * v8;
      v362 = 8 * v25;
      v363 = -(uint64_t)v21;
      v837 = v361;
      v862 = v20;
      while (1)
      {
        v364 = v878;
        v911 = v12;
        do
        {
          if (*v16)
          {
            v365 = v20 ? bswap32(*v360) >> 16 : 0xFFFF;
            v366 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v367 = v365 - ((v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16);
            LODWORD(v368) = (unsigned __int16)(v365 - ((v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16));
            if ((_WORD)v365 != (v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16)
            {
              v369 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v370 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v371 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v372 = HIWORD(v371);
              v373 = ((unint64_t)(v369 - ((v366 * v369 + ((v366 * v369) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v370 - ((v366 * v370 + ((v366 * v370) >> 16) + 1) >> 16)) << 32) | ((v372 - ((v372 * v366 + ((v372 * v366) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v371 - (((unsigned __int16)v371 * v366 + (((unsigned __int16)v371 * v366) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v374 = __rev16(*v7);
                  goto LABEL_423;
                }
LABEL_425:
                v377 = bswap32(v373);
                v14->i16[0] = HIWORD(v377);
                v14->i16[1] = v377;
                v14->i16[2] = bswap32(HIDWORD(v373)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v373));
                v375 = v7;
              }
              else
              {
                v374 = 0xFFFF;
LABEL_423:
                v375 = (_WORD *)v14 + 3;
                v376 = PDAlightenPDA_10649(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v374, v373, (unsigned __int16)v367);
                v373 = v376;
                v8 = v883;
                if (v883)
                {
                  v12 = v911;
                  v20 = v923;
                  v361 = v837;
                  v359 = v862;
                  goto LABEL_425;
                }
                v368 = HIWORD(v376);
                v378 = bswap32(v376);
                v14->i16[0] = HIWORD(v378);
                v14->i16[1] = v378;
                v14->i16[2] = bswap32(HIDWORD(v376)) >> 16;
                v12 = v911;
                v20 = v923;
                v361 = v837;
                v359 = v862;
              }
              *v375 = bswap32(v368) >> 16;
            }
          }
          v16 += v358;
          v14 = (int8x8_t *)((char *)v14 + v362);
          v379 = (unsigned __int16 *)&v23[8 * v358];
          if ((unint64_t)v379 >= v12)
            v380 = v363;
          else
            v380 = 0;
          v360 += v359 + v380;
          v23 = (char *)&v379[4 * v380];
          v7 = (unsigned __int16 *)((char *)v7 + v361);
          --v364;
        }
        while (v364);
        if (v874)
        {
          v381 = (char *)&v881[4 * v879];
          v382 = v801;
          if ((unint64_t)v381 < v874)
            v382 = 0;
          v360 = &v880[v877 + v382];
          v383 = v817;
          if ((unint64_t)v381 < v874)
            v383 = 0;
          v23 = &v381[8 * v383];
          v12 += 8 * v383 + 8 * v879;
          v880 += v877 + v382;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v360 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 18:
      v384 = v25;
      v385 = v20;
      v386 = v880;
      v818 = -(v879 * v22);
      v802 = -(uint64_t)(v877 * v22);
      v387 = 2 * v8;
      v388 = 8 * v25;
      v389 = -(uint64_t)v21;
      v838 = v387;
      v863 = v20;
      while (1)
      {
        v390 = v878;
        v912 = v12;
        do
        {
          if (*v16)
          {
            v391 = v20 ? bswap32(*v386) >> 16 : 0xFFFF;
            v392 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v393 = v391 - ((v391 * v392 + ((v391 * v392) >> 16) + 1) >> 16);
            LODWORD(v394) = (unsigned __int16)(v391 - ((v391 * v392 + ((v391 * v392) >> 16) + 1) >> 16));
            if ((_WORD)v391 != (v391 * v392 + ((v391 * v392) >> 16) + 1) >> 16)
            {
              v395 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v396 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v397 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v398 = HIWORD(v397);
              v399 = ((unint64_t)(v395 - ((v392 * v395 + ((v392 * v395) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v396 - ((v392 * v396 + ((v392 * v396) >> 16) + 1) >> 16)) << 32) | ((v398 - ((v398 * v392 + ((v398 * v392) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v397 - (((unsigned __int16)v397 * v392 + (((unsigned __int16)v397 * v392) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v400 = __rev16(*v7);
                  goto LABEL_452;
                }
LABEL_454:
                v403 = bswap32(v399);
                v14->i16[0] = HIWORD(v403);
                v14->i16[1] = v403;
                v14->i16[2] = bswap32(HIDWORD(v399)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v399));
                v401 = v7;
              }
              else
              {
                v400 = 0xFFFF;
LABEL_452:
                v401 = (_WORD *)v14 + 3;
                v402 = PDAcolordodgePDA_10651(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v400, v399, (unsigned __int16)v393);
                v399 = v402;
                v8 = v883;
                if (v883)
                {
                  v12 = v912;
                  v20 = v923;
                  v387 = v838;
                  v385 = v863;
                  goto LABEL_454;
                }
                v394 = HIWORD(v402);
                v404 = bswap32(v402);
                v14->i16[0] = HIWORD(v404);
                v14->i16[1] = v404;
                v14->i16[2] = bswap32(HIDWORD(v402)) >> 16;
                v12 = v912;
                v20 = v923;
                v387 = v838;
                v385 = v863;
              }
              *v401 = bswap32(v394) >> 16;
            }
          }
          v16 += v384;
          v14 = (int8x8_t *)((char *)v14 + v388);
          v405 = (unsigned __int16 *)&v23[8 * v384];
          if ((unint64_t)v405 >= v12)
            v406 = v389;
          else
            v406 = 0;
          v386 += v385 + v406;
          v23 = (char *)&v405[4 * v406];
          v7 = (unsigned __int16 *)((char *)v7 + v387);
          --v390;
        }
        while (v390);
        if (v874)
        {
          v407 = (char *)&v881[4 * v879];
          v408 = v802;
          if ((unint64_t)v407 < v874)
            v408 = 0;
          v386 = &v880[v877 + v408];
          v409 = v818;
          if ((unint64_t)v407 < v874)
            v409 = 0;
          v23 = &v407[8 * v409];
          v12 += 8 * v409 + 8 * v879;
          v880 += v877 + v408;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v386 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 19:
      v410 = v25;
      v411 = v20;
      v412 = v880;
      v819 = -(v879 * v22);
      v803 = -(uint64_t)(v877 * v22);
      v413 = 2 * v8;
      v414 = 8 * v25;
      v415 = -(uint64_t)v21;
      v839 = v413;
      v864 = v20;
      while (1)
      {
        v416 = v878;
        v913 = v12;
        do
        {
          if (*v16)
          {
            v417 = v20 ? bswap32(*v412) >> 16 : 0xFFFF;
            v418 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v419 = v417 - ((v417 * v418 + ((v417 * v418) >> 16) + 1) >> 16);
            LODWORD(v420) = (unsigned __int16)(v417 - ((v417 * v418 + ((v417 * v418) >> 16) + 1) >> 16));
            if ((_WORD)v417 != (v417 * v418 + ((v417 * v418) >> 16) + 1) >> 16)
            {
              v421 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v422 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v423 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v424 = HIWORD(v423);
              v425 = ((unint64_t)(v421 - ((v418 * v421 + ((v418 * v421) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v422 - ((v418 * v422 + ((v418 * v422) >> 16) + 1) >> 16)) << 32) | ((v424 - ((v424 * v418 + ((v424 * v418) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v423 - (((unsigned __int16)v423 * v418 + (((unsigned __int16)v423 * v418) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v426 = __rev16(*v7);
                  goto LABEL_481;
                }
LABEL_483:
                v429 = bswap32(v425);
                v14->i16[0] = HIWORD(v429);
                v14->i16[1] = v429;
                v14->i16[2] = bswap32(HIDWORD(v425)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v425));
                v427 = v7;
              }
              else
              {
                v426 = 0xFFFF;
LABEL_481:
                v427 = (_WORD *)v14 + 3;
                v428 = PDAcolorburnPDA_10652(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v426, v425, (unsigned __int16)v419);
                v425 = v428;
                v8 = v883;
                if (v883)
                {
                  v12 = v913;
                  v20 = v923;
                  v413 = v839;
                  v411 = v864;
                  goto LABEL_483;
                }
                v420 = HIWORD(v428);
                v430 = bswap32(v428);
                v14->i16[0] = HIWORD(v430);
                v14->i16[1] = v430;
                v14->i16[2] = bswap32(HIDWORD(v428)) >> 16;
                v12 = v913;
                v20 = v923;
                v413 = v839;
                v411 = v864;
              }
              *v427 = bswap32(v420) >> 16;
            }
          }
          v16 += v410;
          v14 = (int8x8_t *)((char *)v14 + v414);
          v431 = (unsigned __int16 *)&v23[8 * v410];
          if ((unint64_t)v431 >= v12)
            v432 = v415;
          else
            v432 = 0;
          v412 += v411 + v432;
          v23 = (char *)&v431[4 * v432];
          v7 = (unsigned __int16 *)((char *)v7 + v413);
          --v416;
        }
        while (v416);
        if (v874)
        {
          v433 = (char *)&v881[4 * v879];
          v434 = v803;
          if ((unint64_t)v433 < v874)
            v434 = 0;
          v412 = &v880[v877 + v434];
          v435 = v819;
          if ((unint64_t)v433 < v874)
            v435 = 0;
          v23 = &v433[8 * v435];
          v12 += 8 * v435 + 8 * v879;
          v880 += v877 + v434;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v412 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 20:
      v436 = v25;
      v437 = v20;
      v438 = v880;
      v820 = -(v879 * v22);
      v804 = -(uint64_t)(v877 * v22);
      v439 = 2 * v8;
      v440 = 8 * v25;
      v441 = -(uint64_t)v21;
      v840 = v439;
      v865 = v20;
      while (1)
      {
        v442 = v878;
        v914 = v12;
        do
        {
          if (*v16)
          {
            v443 = v20 ? bswap32(*v438) >> 16 : 0xFFFF;
            v444 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v445 = v443 - ((v443 * v444 + ((v443 * v444) >> 16) + 1) >> 16);
            LODWORD(v446) = (unsigned __int16)(v443 - ((v443 * v444 + ((v443 * v444) >> 16) + 1) >> 16));
            if ((_WORD)v443 != (v443 * v444 + ((v443 * v444) >> 16) + 1) >> 16)
            {
              v447 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v448 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v449 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v450 = HIWORD(v449);
              v451 = ((unint64_t)(v447 - ((v444 * v447 + ((v444 * v447) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v448 - ((v444 * v448 + ((v444 * v448) >> 16) + 1) >> 16)) << 32) | ((v450 - ((v450 * v444 + ((v450 * v444) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v449 - (((unsigned __int16)v449 * v444 + (((unsigned __int16)v449 * v444) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v452 = __rev16(*v7);
                  goto LABEL_510;
                }
LABEL_512:
                v455 = bswap32(v451);
                v14->i16[0] = HIWORD(v455);
                v14->i16[1] = v455;
                v14->i16[2] = bswap32(HIDWORD(v451)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v451));
                v453 = v7;
              }
              else
              {
                v452 = 0xFFFF;
LABEL_510:
                v453 = (_WORD *)v14 + 3;
                v454 = PDAsoftlightPDA_10654(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v452, v451, (unsigned __int16)v445);
                v451 = v454;
                v8 = v883;
                if (v883)
                {
                  v12 = v914;
                  v20 = v923;
                  v439 = v840;
                  v437 = v865;
                  goto LABEL_512;
                }
                v446 = HIWORD(v454);
                v456 = bswap32(v454);
                v14->i16[0] = HIWORD(v456);
                v14->i16[1] = v456;
                v14->i16[2] = bswap32(HIDWORD(v454)) >> 16;
                v12 = v914;
                v20 = v923;
                v439 = v840;
                v437 = v865;
              }
              *v453 = bswap32(v446) >> 16;
            }
          }
          v16 += v436;
          v14 = (int8x8_t *)((char *)v14 + v440);
          v457 = (unsigned __int16 *)&v23[8 * v436];
          if ((unint64_t)v457 >= v12)
            v458 = v441;
          else
            v458 = 0;
          v438 += v437 + v458;
          v23 = (char *)&v457[4 * v458];
          v7 = (unsigned __int16 *)((char *)v7 + v439);
          --v442;
        }
        while (v442);
        if (v874)
        {
          v459 = (char *)&v881[4 * v879];
          v460 = v804;
          if ((unint64_t)v459 < v874)
            v460 = 0;
          v438 = &v880[v877 + v460];
          v461 = v820;
          if ((unint64_t)v459 < v874)
            v461 = 0;
          v23 = &v459[8 * v461];
          v12 += 8 * v461 + 8 * v879;
          v880 += v877 + v460;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v438 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 21:
      v462 = v25;
      v463 = v20;
      v464 = v880;
      v821 = -(v879 * v22);
      v805 = -(uint64_t)(v877 * v22);
      v465 = 2 * v8;
      v466 = 8 * v25;
      v467 = -(uint64_t)v21;
      v841 = v465;
      v866 = v20;
      while (1)
      {
        v468 = v878;
        v915 = v12;
        do
        {
          if (*v16)
          {
            v469 = v20 ? bswap32(*v464) >> 16 : 0xFFFF;
            v470 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v471 = v469 - ((v469 * v470 + ((v469 * v470) >> 16) + 1) >> 16);
            LODWORD(v472) = (unsigned __int16)(v469 - ((v469 * v470 + ((v469 * v470) >> 16) + 1) >> 16));
            if ((_WORD)v469 != (v469 * v470 + ((v469 * v470) >> 16) + 1) >> 16)
            {
              v473 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v474 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v475 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v476 = HIWORD(v475);
              v477 = ((unint64_t)(v473 - ((v470 * v473 + ((v470 * v473) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v474 - ((v470 * v474 + ((v470 * v474) >> 16) + 1) >> 16)) << 32) | ((v476 - ((v476 * v470 + ((v476 * v470) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v475 - (((unsigned __int16)v475 * v470 + (((unsigned __int16)v475 * v470) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v478 = __rev16(*v7);
                  goto LABEL_539;
                }
LABEL_541:
                v481 = bswap32(v477);
                v14->i16[0] = HIWORD(v481);
                v14->i16[1] = v481;
                v14->i16[2] = bswap32(HIDWORD(v477)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v477));
                v479 = v7;
              }
              else
              {
                v478 = 0xFFFF;
LABEL_539:
                v479 = (_WORD *)v14 + 3;
                v480 = PDAhardlightPDA_10653(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v478, v477, (unsigned __int16)v471);
                v477 = v480;
                v8 = v883;
                if (v883)
                {
                  v12 = v915;
                  v20 = v923;
                  v465 = v841;
                  v463 = v866;
                  goto LABEL_541;
                }
                v472 = HIWORD(v480);
                v482 = bswap32(v480);
                v14->i16[0] = HIWORD(v482);
                v14->i16[1] = v482;
                v14->i16[2] = bswap32(HIDWORD(v480)) >> 16;
                v12 = v915;
                v20 = v923;
                v465 = v841;
                v463 = v866;
              }
              *v479 = bswap32(v472) >> 16;
            }
          }
          v16 += v462;
          v14 = (int8x8_t *)((char *)v14 + v466);
          v483 = (unsigned __int16 *)&v23[8 * v462];
          if ((unint64_t)v483 >= v12)
            v484 = v467;
          else
            v484 = 0;
          v464 += v463 + v484;
          v23 = (char *)&v483[4 * v484];
          v7 = (unsigned __int16 *)((char *)v7 + v465);
          --v468;
        }
        while (v468);
        if (v874)
        {
          v485 = (char *)&v881[4 * v879];
          v486 = v805;
          if ((unint64_t)v485 < v874)
            v486 = 0;
          v464 = &v880[v877 + v486];
          v487 = v821;
          if ((unint64_t)v485 < v874)
            v487 = 0;
          v23 = &v485[8 * v487];
          v12 += 8 * v487 + 8 * v879;
          v880 += v877 + v486;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v464 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 22:
      v488 = v25;
      v489 = v20;
      v490 = v880;
      v822 = -(v879 * v22);
      v806 = -(uint64_t)(v877 * v22);
      v491 = 2 * v8;
      v492 = 8 * v25;
      v493 = -(uint64_t)v21;
      v842 = v491;
      v867 = v20;
      while (1)
      {
        v494 = v878;
        v916 = v12;
        do
        {
          if (*v16)
          {
            v495 = v20 ? bswap32(*v490) >> 16 : 0xFFFF;
            v496 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v497 = v495 - ((v495 * v496 + ((v495 * v496) >> 16) + 1) >> 16);
            LODWORD(v498) = (unsigned __int16)(v495 - ((v495 * v496 + ((v495 * v496) >> 16) + 1) >> 16));
            if ((_WORD)v495 != (v495 * v496 + ((v495 * v496) >> 16) + 1) >> 16)
            {
              v499 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v500 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v501 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v502 = HIWORD(v501);
              v503 = ((unint64_t)(v499 - ((v496 * v499 + ((v496 * v499) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v500 - ((v496 * v500 + ((v496 * v500) >> 16) + 1) >> 16)) << 32) | ((v502 - ((v502 * v496 + ((v502 * v496) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v501 - (((unsigned __int16)v501 * v496 + (((unsigned __int16)v501 * v496) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v504 = __rev16(*v7);
                  goto LABEL_568;
                }
LABEL_570:
                v507 = bswap32(v503);
                v14->i16[0] = HIWORD(v507);
                v14->i16[1] = v507;
                v14->i16[2] = bswap32(HIDWORD(v503)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v503));
                v505 = v7;
              }
              else
              {
                v504 = 0xFFFF;
LABEL_568:
                v505 = (_WORD *)v14 + 3;
                v506 = PDAdifferencePDA_10655(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v504, v503, (unsigned __int16)v497);
                v503 = v506;
                v8 = v883;
                if (v883)
                {
                  v12 = v916;
                  v20 = v923;
                  v491 = v842;
                  v489 = v867;
                  goto LABEL_570;
                }
                v498 = HIWORD(v506);
                v508 = bswap32(v506);
                v14->i16[0] = HIWORD(v508);
                v14->i16[1] = v508;
                v14->i16[2] = bswap32(HIDWORD(v506)) >> 16;
                v12 = v916;
                v20 = v923;
                v491 = v842;
                v489 = v867;
              }
              *v505 = bswap32(v498) >> 16;
            }
          }
          v16 += v488;
          v14 = (int8x8_t *)((char *)v14 + v492);
          v509 = (unsigned __int16 *)&v23[8 * v488];
          if ((unint64_t)v509 >= v12)
            v510 = v493;
          else
            v510 = 0;
          v490 += v489 + v510;
          v23 = (char *)&v509[4 * v510];
          v7 = (unsigned __int16 *)((char *)v7 + v491);
          --v494;
        }
        while (v494);
        if (v874)
        {
          v511 = (char *)&v881[4 * v879];
          v512 = v806;
          if ((unint64_t)v511 < v874)
            v512 = 0;
          v490 = &v880[v877 + v512];
          v513 = v822;
          if ((unint64_t)v511 < v874)
            v513 = 0;
          v23 = &v511[8 * v513];
          v12 += 8 * v513 + 8 * v879;
          v880 += v877 + v512;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v490 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 23:
      v514 = v25;
      v515 = v20;
      v516 = v880;
      v823 = -(v879 * v22);
      v807 = -(uint64_t)(v877 * v22);
      v517 = 2 * v8;
      v518 = 8 * v25;
      v519 = -(uint64_t)v21;
      v843 = v517;
      v868 = v20;
      while (1)
      {
        v520 = v878;
        v917 = v12;
        do
        {
          if (*v16)
          {
            v521 = v20 ? bswap32(*v516) >> 16 : 0xFFFF;
            v522 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v523 = v521 - ((v521 * v522 + ((v521 * v522) >> 16) + 1) >> 16);
            LODWORD(v524) = (unsigned __int16)(v521 - ((v521 * v522 + ((v521 * v522) >> 16) + 1) >> 16));
            if ((_WORD)v521 != (v521 * v522 + ((v521 * v522) >> 16) + 1) >> 16)
            {
              v525 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v526 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v527 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v528 = HIWORD(v527);
              v529 = ((unint64_t)(v525 - ((v522 * v525 + ((v522 * v525) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v526 - ((v522 * v526 + ((v522 * v526) >> 16) + 1) >> 16)) << 32) | ((v528 - ((v528 * v522 + ((v528 * v522) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v527 - (((unsigned __int16)v527 * v522 + (((unsigned __int16)v527 * v522) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v530 = __rev16(*v7);
                  goto LABEL_597;
                }
LABEL_599:
                v533 = bswap32(v529);
                v14->i16[0] = HIWORD(v533);
                v14->i16[1] = v533;
                v14->i16[2] = bswap32(HIDWORD(v529)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v529));
                v531 = v7;
              }
              else
              {
                v530 = 0xFFFF;
LABEL_597:
                v531 = (_WORD *)v14 + 3;
                v532 = PDAexclusionPDA_10656(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v530, v529, (unsigned __int16)v523);
                v529 = v532;
                v8 = v883;
                if (v883)
                {
                  v12 = v917;
                  v20 = v923;
                  v517 = v843;
                  v515 = v868;
                  goto LABEL_599;
                }
                v524 = HIWORD(v532);
                v534 = bswap32(v532);
                v14->i16[0] = HIWORD(v534);
                v14->i16[1] = v534;
                v14->i16[2] = bswap32(HIDWORD(v532)) >> 16;
                v12 = v917;
                v20 = v923;
                v517 = v843;
                v515 = v868;
              }
              *v531 = bswap32(v524) >> 16;
            }
          }
          v16 += v514;
          v14 = (int8x8_t *)((char *)v14 + v518);
          v535 = (unsigned __int16 *)&v23[8 * v514];
          if ((unint64_t)v535 >= v12)
            v536 = v519;
          else
            v536 = 0;
          v516 += v515 + v536;
          v23 = (char *)&v535[4 * v536];
          v7 = (unsigned __int16 *)((char *)v7 + v517);
          --v520;
        }
        while (v520);
        if (v874)
        {
          v537 = (char *)&v881[4 * v879];
          v538 = v807;
          if ((unint64_t)v537 < v874)
            v538 = 0;
          v516 = &v880[v877 + v538];
          v539 = v823;
          if ((unint64_t)v537 < v874)
            v539 = 0;
          v23 = &v537[8 * v539];
          v12 += 8 * v539 + 8 * v879;
          v880 += v877 + v538;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v516 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 24:
      v540 = v25;
      v541 = v20;
      v542 = v880;
      v824 = -(v879 * v22);
      v808 = -(uint64_t)(v877 * v22);
      v543 = 2 * v8;
      v544 = 8 * v25;
      v545 = -(uint64_t)v21;
      v844 = v543;
      v869 = v20;
      while (1)
      {
        v546 = v878;
        v918 = v12;
        do
        {
          if (*v16)
          {
            v547 = v20 ? bswap32(*v542) >> 16 : 0xFFFF;
            v548 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v549 = v547 - ((v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16);
            LODWORD(v550) = (unsigned __int16)(v547 - ((v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16));
            if ((_WORD)v547 != (v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16)
            {
              v551 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v552 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v553 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v554 = HIWORD(v553);
              v555 = ((unint64_t)(v551 - ((v548 * v551 + ((v548 * v551) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v552 - ((v548 * v552 + ((v548 * v552) >> 16) + 1) >> 16)) << 32) | ((v554 - ((v554 * v548 + ((v554 * v548) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v553 - (((unsigned __int16)v553 * v548 + (((unsigned __int16)v553 * v548) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v556 = __rev16(*v7);
                  goto LABEL_626;
                }
LABEL_628:
                v559 = bswap32(v555);
                v14->i16[0] = HIWORD(v559);
                v14->i16[1] = v559;
                v14->i16[2] = bswap32(HIDWORD(v555)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v555));
                v557 = v7;
              }
              else
              {
                v556 = 0xFFFF;
LABEL_626:
                v557 = (_WORD *)v14 + 3;
                v558 = PDAhuePDA_10657(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v556, v555, (unsigned __int16)v549);
                v555 = v558;
                v8 = v883;
                if (v883)
                {
                  v12 = v918;
                  v20 = v923;
                  v543 = v844;
                  v541 = v869;
                  goto LABEL_628;
                }
                v550 = HIWORD(v558);
                v560 = bswap32(v558);
                v14->i16[0] = HIWORD(v560);
                v14->i16[1] = v560;
                v14->i16[2] = bswap32(HIDWORD(v558)) >> 16;
                v12 = v918;
                v20 = v923;
                v543 = v844;
                v541 = v869;
              }
              *v557 = bswap32(v550) >> 16;
            }
          }
          v16 += v540;
          v14 = (int8x8_t *)((char *)v14 + v544);
          v561 = (unsigned __int16 *)&v23[8 * v540];
          if ((unint64_t)v561 >= v12)
            v562 = v545;
          else
            v562 = 0;
          v542 += v541 + v562;
          v23 = (char *)&v561[4 * v562];
          v7 = (unsigned __int16 *)((char *)v7 + v543);
          --v546;
        }
        while (v546);
        if (v874)
        {
          v563 = (char *)&v881[4 * v879];
          v564 = v808;
          if ((unint64_t)v563 < v874)
            v564 = 0;
          v542 = &v880[v877 + v564];
          v565 = v824;
          if ((unint64_t)v563 < v874)
            v565 = 0;
          v23 = &v563[8 * v565];
          v12 += 8 * v565 + 8 * v879;
          v880 += v877 + v564;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v542 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 25:
      v566 = v25;
      v567 = v20;
      v568 = v880;
      v825 = -(v879 * v22);
      v809 = -(uint64_t)(v877 * v22);
      v569 = 2 * v8;
      v570 = 8 * v25;
      v571 = -(uint64_t)v21;
      v845 = v569;
      v870 = v20;
      while (1)
      {
        v572 = v878;
        v919 = v12;
        do
        {
          if (*v16)
          {
            v573 = v20 ? bswap32(*v568) >> 16 : 0xFFFF;
            v574 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v575 = v573 - ((v573 * v574 + ((v573 * v574) >> 16) + 1) >> 16);
            LODWORD(v576) = (unsigned __int16)(v573 - ((v573 * v574 + ((v573 * v574) >> 16) + 1) >> 16));
            if ((_WORD)v573 != (v573 * v574 + ((v573 * v574) >> 16) + 1) >> 16)
            {
              v577 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v578 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v579 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v580 = HIWORD(v579);
              v581 = ((unint64_t)(v577 - ((v574 * v577 + ((v574 * v577) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v578 - ((v574 * v578 + ((v574 * v578) >> 16) + 1) >> 16)) << 32) | ((v580 - ((v580 * v574 + ((v580 * v574) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v579 - (((unsigned __int16)v579 * v574 + (((unsigned __int16)v579 * v574) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v582 = __rev16(*v7);
                  goto LABEL_655;
                }
LABEL_657:
                v585 = bswap32(v581);
                v14->i16[0] = HIWORD(v585);
                v14->i16[1] = v585;
                v14->i16[2] = bswap32(HIDWORD(v581)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v581));
                v583 = v7;
              }
              else
              {
                v582 = 0xFFFF;
LABEL_655:
                v583 = (_WORD *)v14 + 3;
                v584 = PDAsaturationPDA_10658(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v582, v581, (unsigned __int16)v575);
                v581 = v584;
                v8 = v883;
                if (v883)
                {
                  v12 = v919;
                  v20 = v923;
                  v569 = v845;
                  v567 = v870;
                  goto LABEL_657;
                }
                v576 = HIWORD(v584);
                v586 = bswap32(v584);
                v14->i16[0] = HIWORD(v586);
                v14->i16[1] = v586;
                v14->i16[2] = bswap32(HIDWORD(v584)) >> 16;
                v12 = v919;
                v20 = v923;
                v569 = v845;
                v567 = v870;
              }
              *v583 = bswap32(v576) >> 16;
            }
          }
          v16 += v566;
          v14 = (int8x8_t *)((char *)v14 + v570);
          v587 = (unsigned __int16 *)&v23[8 * v566];
          if ((unint64_t)v587 >= v12)
            v588 = v571;
          else
            v588 = 0;
          v568 += v567 + v588;
          v23 = (char *)&v587[4 * v588];
          v7 = (unsigned __int16 *)((char *)v7 + v569);
          --v572;
        }
        while (v572);
        if (v874)
        {
          v589 = (char *)&v881[4 * v879];
          v590 = v809;
          if ((unint64_t)v589 < v874)
            v590 = 0;
          v568 = &v880[v877 + v590];
          v591 = v825;
          if ((unint64_t)v589 < v874)
            v591 = 0;
          v23 = &v589[8 * v591];
          v12 += 8 * v591 + 8 * v879;
          v880 += v877 + v590;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v568 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 26:
      v592 = v25;
      v593 = v20;
      v594 = v880;
      v826 = -(v879 * v22);
      v810 = -(uint64_t)(v877 * v22);
      v595 = 2 * v8;
      v596 = 8 * v25;
      v597 = -(uint64_t)v21;
      v846 = v595;
      v871 = v20;
      while (1)
      {
        v598 = v878;
        v920 = v12;
        do
        {
          if (*v16)
          {
            v599 = v20 ? bswap32(*v594) >> 16 : 0xFFFF;
            v600 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            v601 = v599 - ((v599 * v600 + ((v599 * v600) >> 16) + 1) >> 16);
            LODWORD(v602) = (unsigned __int16)(v599 - ((v599 * v600 + ((v599 * v600) >> 16) + 1) >> 16));
            if ((_WORD)v599 != (v599 * v600 + ((v599 * v600) >> 16) + 1) >> 16)
            {
              v603 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              v604 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              v605 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              v606 = HIWORD(v605);
              v607 = ((unint64_t)(v603 - ((v600 * v603 + ((v600 * v603) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v604 - ((v600 * v604 + ((v600 * v604) >> 16) + 1) >> 16)) << 32) | ((v606 - ((v606 * v600 + ((v606 * v600) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v605 - (((unsigned __int16)v605 * v600 + (((unsigned __int16)v605 * v600) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  v608 = __rev16(*v7);
                  goto LABEL_684;
                }
LABEL_686:
                v610 = bswap32(v607);
                v14->i16[0] = HIWORD(v610);
                v14->i16[1] = v610;
                v14->i16[2] = bswap32(HIDWORD(v607)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v607));
                v609 = v7;
              }
              else
              {
                v608 = 0xFFFF;
LABEL_684:
                v609 = (_WORD *)v14 + 3;
                v607 = PDAluminosityPDA_10659(v607, (unsigned __int16)v601, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v608);
                v8 = v883;
                if (v883)
                {
                  v12 = v920;
                  v20 = v923;
                  v595 = v846;
                  v593 = v871;
                  goto LABEL_686;
                }
                v602 = HIWORD(v607);
                v611 = bswap32(v607);
                v14->i16[0] = HIWORD(v611);
                v14->i16[1] = v611;
                v14->i16[2] = bswap32(HIDWORD(v607)) >> 16;
                v12 = v920;
                v20 = v923;
                v595 = v846;
                v593 = v871;
              }
              *v609 = bswap32(v602) >> 16;
            }
          }
          v16 += v592;
          v14 = (int8x8_t *)((char *)v14 + v596);
          v612 = (unsigned __int16 *)&v23[8 * v592];
          if ((unint64_t)v612 >= v12)
            v613 = v597;
          else
            v613 = 0;
          v594 += v593 + v613;
          v23 = (char *)&v612[4 * v613];
          v7 = (unsigned __int16 *)((char *)v7 + v595);
          --v598;
        }
        while (v598);
        if (v874)
        {
          v614 = (char *)&v881[4 * v879];
          v615 = v810;
          if ((unint64_t)v614 < v874)
            v615 = 0;
          v594 = &v880[v877 + v615];
          v616 = v826;
          if ((unint64_t)v614 < v874)
            v616 = 0;
          v23 = &v614[8 * v616];
          v12 += 8 * v616 + 8 * v879;
          v880 += v877 + v615;
          v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v594 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882)
          return;
      }
    case 27:
      v617 = v25;
      v618 = v20;
      v619 = v880;
      v827 = -(v879 * v22);
      v811 = -(uint64_t)(v877 * v22);
      v620 = 2 * v8;
      v621 = 8 * v25;
      v622 = -(uint64_t)v21;
      v847 = v620;
      v872 = v20;
      break;
    default:
      return;
  }
  do
  {
    v623 = v878;
    v921 = v12;
    do
    {
      if (*v16)
      {
        v624 = v20 ? bswap32(*v619) >> 16 : 0xFFFF;
        v625 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        v626 = v624 - ((v624 * v625 + ((v624 * v625) >> 16) + 1) >> 16);
        LODWORD(v627) = (unsigned __int16)(v624 - ((v624 * v625 + ((v624 * v625) >> 16) + 1) >> 16));
        if ((_WORD)v624 != (v624 * v625 + ((v624 * v625) >> 16) + 1) >> 16)
        {
          v628 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
          v629 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
          v630 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
          v631 = HIWORD(v630);
          v632 = ((unint64_t)(v628 - ((v625 * v628 + ((v625 * v628) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v629 - ((v625 * v629 + ((v625 * v629) >> 16) + 1) >> 16)) << 32) | ((v631 - ((v631 * v625 + ((v631 * v625) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v630 - (((unsigned __int16)v630 * v625 + (((unsigned __int16)v630 * v625) >> 16) + 1) >> 16));
          if (v8)
          {
            if (!*v7)
              goto LABEL_715;
            v633 = __rev16(*v7);
          }
          else
          {
            v633 = 0xFFFF;
          }
          v634 = (_WORD *)v14 + 3;
          v635 = PDAluminosityPDA_10659(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v633, v632, (unsigned __int16)v626);
          v632 = v635;
          v8 = v883;
          if (!v883)
          {
            v627 = HIWORD(v635);
            v637 = bswap32(v635);
            v14->i16[0] = HIWORD(v637);
            v14->i16[1] = v637;
            v14->i16[2] = bswap32(HIDWORD(v635)) >> 16;
            v12 = v921;
            v20 = v923;
            v620 = v847;
            v618 = v872;
            goto LABEL_717;
          }
          v12 = v921;
          v20 = v923;
          v620 = v847;
          v618 = v872;
LABEL_715:
          v636 = bswap32(v632);
          v14->i16[0] = HIWORD(v636);
          v14->i16[1] = v636;
          v14->i16[2] = bswap32(HIDWORD(v632)) >> 16;
          v14->i16[3] = __rev16(HIWORD(v632));
          v634 = v7;
LABEL_717:
          *v634 = bswap32(v627) >> 16;
        }
      }
      v16 += v617;
      v14 = (int8x8_t *)((char *)v14 + v621);
      v638 = (unsigned __int16 *)&v23[8 * v617];
      if ((unint64_t)v638 >= v12)
        v639 = v622;
      else
        v639 = 0;
      v619 += v618 + v639;
      v23 = (char *)&v638[4 * v639];
      v7 = (unsigned __int16 *)((char *)v7 + v620);
      --v623;
    }
    while (v623);
    if (v874)
    {
      v640 = (char *)&v881[4 * v879];
      v641 = v811;
      if ((unint64_t)v640 < v874)
        v641 = 0;
      v619 = &v880[v877 + v641];
      v642 = v827;
      if ((unint64_t)v640 < v874)
        v642 = 0;
      v23 = &v640[8 * v642];
      v12 += 8 * v642 + 8 * v879;
      v880 += v877 + v641;
      v881 = (unsigned __int16 *)v23;
    }
    else
    {
      v23 += 8 * v879;
      v619 += v877;
    }
    v16 += v876;
    v14 += v875;
    v7 += v873;
    --v882;
  }
  while (v882);
}

void CGPDFArchiveFinalize(uint64_t a1)
{

  *(_QWORD *)(a1 + 16) = 0;
}

CFStringRef CGPDFArchiveCopyDebugDesc(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CGPDFArchive (%p)>"), a1);
}

uint64_t CGPDFArchiveCreate()
{
  uint64_t Instance;

  if (!CGPDFArchiveGetTypeID_id)
    CGPDFArchiveGetTypeID_id = _CFRuntimeRegisterClass();
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 16) = objc_alloc_init(CPArchive);
  return Instance;
}

CFTypeRef CGPDFArchiveRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void CGPDFArchiveRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGPDFArchiveAddSelection(uint64_t result, uint64_t a2)
{
  if (result)
    return objc_msgSend(*(id *)(result + 16), "addSelection:", a2);
  return result;
}

uint64_t CGPDFArchiveGetPlainText(uint64_t result)
{
  if (result)
    return objc_msgSend(*(id *)(result + 16), "plainText");
  return result;
}

uint64_t CGPDFArchiveGetHTML(uint64_t result)
{
  if (result)
    return objc_msgSend(*(id *)(result + 16), "html");
  return result;
}

uint64_t CGPDFArchiveGetWebArchiveData(uint64_t result)
{
  if (result)
    return objc_msgSend(*(id *)(result + 16), "webArchiveData");
  return result;
}

uint64_t CGPDFArchiveGetStructuredString(uint64_t result)
{
  if (result)
    return objc_msgSend(*(id *)(result + 16), "structuredString");
  return result;
}

uint64_t CGPDFArchiveGetRTFDData(uint64_t result)
{
  if (result)
    return objc_msgSend(*(id *)(result + 16), "RTFDData");
  return result;
}

char *lzw_decoder_create(const void *a1, char a2)
{
  char *v4;
  char *v5;
  _WORD *v6;

  v4 = (char *)malloc_type_calloc(1uLL, 0x4450uLL, 0x1030040EB8D5A71uLL);
  v5 = v4;
  if (v4)
  {
    v6 = v4 + 17444;
    if (a1)
      CFRetain(a1);
    *(_QWORD *)v5 = a1;
    v5[10] = a2;
    *((_DWORD *)v5 + 264) = 9;
    *v6 = 258;
    *((_WORD *)v5 + 8724) = 0;
  }
  return v5;
}

void lzw_decoder_release(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    free(a1[2185]);
    free(a1);
  }
}

uint64_t lzw_read_code(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  int v9;
  int v10;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;

  v8 = (unsigned int *)(a1 + 17452);
  v9 = *(_DWORD *)(a1 + 17456);
  v10 = *(_DWORD *)(a1 + 1056);
  if (v9 >= v10)
  {
    v13 = *v8;
LABEL_6:
    v14 = v9 - v10;
    v8[1] = v14;
    return (unsigned __int16)((v13 >> v14) & ~(-1 << v10));
  }
  else
  {
    while (1)
    {
      v12 = CGPDFSourceGetc(*(_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8);
      if (v12 == -1)
        break;
      v13 = v12 | (*v8 << 8);
      v9 = v8[1] + 8;
      *v8 = v13;
      v8[1] = v9;
      v10 = *(_DWORD *)(a1 + 1056);
      if (v9 >= v10)
        goto LABEL_6;
    }
    pdf_error("LZW decode: encountered unexpected EOF.");
    *(_BYTE *)(a1 + 9) = 1;
    LOWORD(v15) = 257;
  }
  return (unsigned __int16)v15;
}

void *lzw_push(void *result, char a2)
{
  _QWORD *v3;
  uint64_t v4;
  size_t v5;
  char *v6;
  uint64_t v7;

  v3 = result;
  v4 = *((_QWORD *)result + 2183);
  v5 = *((_QWORD *)result + 2184);
  if (v4 == v5)
  {
    v5 = 2 * v4 + 10;
    v6 = (char *)malloc_type_realloc(*((void **)result + 2185), v5, 0x82892DD4uLL);
    v3[2185] = v6;
    result = memmove(&v6[v5 - v3[2184]], v6, v3[2184]);
    v3[2184] = v5;
    v4 = v3[2183];
  }
  v7 = v4 + 1;
  v3[2183] = v7;
  *(_BYTE *)(v3[2185] + v5 - v7) = a2;
  return result;
}

uint64_t CGPDFFormCreate(CGPDFDictionary *a1)
{
  uint64_t cftype;
  uint64_t v3;
  __int128 v4;
  CGPDFInteger value;
  _OWORD v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (CGPDFFormGetTypeID_onceToken != -1)
    dispatch_once(&CGPDFFormGetTypeID_onceToken, &__block_literal_global_10763);
  cftype = pdf_create_cftype();
  v3 = cftype;
  if (cftype)
  {
    value = 0;
    *(_QWORD *)(cftype + 16) = a1;
    if (a1)
      a1 = (CGPDFDictionary *)*((_QWORD *)a1 + 6);
    if (CGPDFDictionaryGetInteger(a1, "FormType", &value) && value != 1)
    {
LABEL_13:
      CFRelease((CFTypeRef)v3);
      return 0;
    }
    if (!CGPDFDictionaryGetRect(a1, "BBox", (double *)(v3 + 24)))
    {
      goto LABEL_13;
    }
    if (CGPDFDictionaryGetNumbers(a1, "Matrix", (uint64_t)v7, (CGPDFArray *)6))
    {
      v4 = v7[1];
      *(_OWORD *)(v3 + 56) = v7[0];
      *(_OWORD *)(v3 + 72) = v4;
      *(_OWORD *)(v3 + 88) = v7[2];
    }
    else
    {
      *(CGAffineTransform *)(v3 + 56) = CGAffineTransformIdentity;
    }
    if (!CGPDFDictionaryGetDictionary(a1, "Resources", (CGPDFDictionaryRef *)(v3 + 104)))
      *(_QWORD *)(v3 + 104) = 0;
  }
  return v3;
}

void CGPDFFormRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

CFTypeRef CGPDFFormRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

uint64_t CGPDFFormGetStream(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

CGFloat CGPDFFormGetBBox(uint64_t a1)
{
  const CGRect *v1;

  v1 = &CGRectNull;
  if (a1)
    v1 = (const CGRect *)(a1 + 24);
  return v1->origin.x;
}

__n128 CGPDFFormGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  const CGAffineTransform *v2;
  __int128 v3;
  __n128 result;

  v2 = (const CGAffineTransform *)(a1 + 56);
  if (!a1)
    v2 = &CGAffineTransformIdentity;
  v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGPDFFormGetResources(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 104);
  return result;
}

void shape_enum_alloc(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;

  v6 = a2;
  shape_enum_allocate(a2, 0, a4);
  if (v6 != (_DWORD *)&the_empty_shape && v6[v6[1]] != 0x7FFFFFFF)
  {
    *(_DWORD *)(v7 + 4) = a3;
    if (a4 < 0)
    {
      v8 = (_DWORD *)(v7 + 56);
      while (*v6 != 0x7FFFFFFF)
      {
        v9 = (int)v6[1];
        *v8++ = -(int)v9;
        v6 += v9;
      }
      *(_QWORD *)(v7 + 32) = v6 - 2;
      *(_QWORD *)(v7 + 40) = v6;
      *(_QWORD *)(v7 + 48) = v8 - 1;
    }
    else
    {
      *(_QWORD *)(v7 + 32) = v6;
      *(_QWORD *)(v7 + 40) = v6 + 2;
    }
  }
}

uint64_t shape_enum_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5;
  int v6;
  uint64_t v7;
  int *v8;
  _DWORD *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;

  v5 = *(_DWORD **)(a1 + 32);
  if (v5)
  {
    v6 = *(_DWORD *)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 48);
    if (v7)
    {
      if (!v6)
      {
        v8 = (int *)(v7 - 4);
        while (1)
        {
          v9 = v5;
          v10 = v8;
          v11 = *v8;
          v5 += v11;
          if (*v5 == 0x80000000)
            break;
          --v8;
          if ((_DWORD)v11 != -2)
          {
            v6 = -2 - v11;
            *(_QWORD *)(a1 + 32) = v5;
            *(_QWORD *)(a1 + 40) = v9;
            *(_QWORD *)(a1 + 48) = v10;
            goto LABEL_13;
          }
        }
        v5 = 0;
        *(_QWORD *)(a1 + 48) = v8;
LABEL_20:
        *(_QWORD *)(a1 + 32) = 0;
        *(_QWORD *)(a1 + 40) = v9;
        return (uint64_t)v5;
      }
    }
    else if (!v6)
    {
      v9 = *(_DWORD **)(a1 + 40);
      while (1)
      {
        v5 = v9;
        v12 = (int)v9[1];
        v9 += v12;
        if (*v9 == 0x7FFFFFFF)
          break;
        v6 = v12 - 2;
        if (v6)
        {
          *(_QWORD *)(a1 + 32) = v5;
          *(_QWORD *)(a1 + 40) = v9;
          goto LABEL_13;
        }
      }
      v5 = 0;
      goto LABEL_20;
    }
LABEL_13:
    *(_DWORD *)(a1 + 8) = v6 - 2;
    if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
    {
      v14 = &v5[v6];
      v13 = *(_DWORD **)(a1 + 40);
    }
    else
    {
      v13 = *(_DWORD **)(a1 + 40);
      v14 = &v13[-v6];
    }
    *a2 = *v14;
    *a4 = v14[1];
    *a3 = *v5;
    *a5 = *v13;
    return 1;
  }
  return (uint64_t)v5;
}

void shape_enum_free(int a1, void *a2)
{
  free(a2);
}

uint64_t shape_forward_enum@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  void *v2;
  _BOOL4 v3;

  a2[2] = 0;
  if ((_UNKNOWN *)result == &the_empty_shape)
  {
    v2 = &unk_185000608;
    v3 = 1;
    goto LABEL_5;
  }
  v2 = (void *)(result + 8);
  v3 = *(_DWORD *)(result + 4 * *(int *)(result + 4)) == 0x7FFFFFFF;
  if (*(_DWORD *)(result + 4 * *(int *)(result + 4)) == 0x7FFFFFFF)
LABEL_5:
    result = 0;
  if (v3)
    v2 = 0;
  *a2 = result;
  a2[1] = v2;
  return result;
}

uint64_t shape_forward_enum_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  _DWORD *v9;

  v5 = *(_DWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v6 = *(_DWORD *)(a1 + 16);
    v7 = *(_DWORD **)(a1 + 8);
    if (v6)
    {
LABEL_6:
      *(_DWORD *)(a1 + 16) = v6 - 2;
      v9 = &v7[-v6];
      *a2 = *v9;
      *a4 = v9[1];
      *a3 = *v5;
      *a5 = *v7;
      return 1;
    }
    else
    {
      while (1)
      {
        v5 = v7;
        v8 = (int)v7[1];
        v7 += v8;
        if (*v7 == 0x7FFFFFFF)
          break;
        v6 = v8 - 2;
        if (v6)
        {
          *(_QWORD *)a1 = v5;
          *(_QWORD *)(a1 + 8) = v7;
          goto LABEL_6;
        }
      }
      v5 = 0;
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = v7;
    }
  }
  return (uint64_t)v5;
}

_QWORD *shape_enum_binary_init(_QWORD *result, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  _DWORD *v4;
  int v5;
  int v6;

  v2 = (_DWORD *)(a2 + 4 * *(int *)(a2 + 4));
  if (*v2 == 0x7FFFFFFF || (v3 = (int)v2[1], v4 = &v2[v3], *v4 == 0x7FFFFFFF))
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    do
    {
      v5 = v5 + (int)v3 / 2 - 1;
      v3 = (int)v4[1];
      v4 += v3;
    }
    while (*v4 != 0x7FFFFFFF);
  }
  do
  {
    v6 = v5;
    v5 &= v5 - 1;
  }
  while (v5);
  result[1] = 0;
  result[2] = a2;
  *result = 0;
  result[3] = (4 * v6);
  return result;
}

uint64_t shape_enum_binary_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v5;
  _DWORD *v7;
  _DWORD *v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;

  v5 = *(_DWORD *)(a1 + 24);
  if ((int)v5 < 2)
    return 0;
  v7 = *(_DWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v8 = *(_DWORD **)(a1 + 8);
    v9 = *(_DWORD *)(a1 + 28);
    v10 = 2 * v5;
    v11 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    v11 = v5 >> 1;
    v7 = *(_DWORD **)(a1 + 16);
    v12 = (int)v7[1];
    *(_DWORD *)(a1 + 24) = v5 >> 1;
    if (v5 < 4)
      return 0;
    v8 = &v7[v12];
    v9 = v12 - 2;
    v10 = v11 - 2;
  }
  if (v9 <= v10)
  {
    do
    {
      v14 = (int)v8[1];
      v13 = &v8[v14];
      if (*v13 == 0x7FFFFFFF)
      {
        v8 = *(_DWORD **)(a1 + 16);
        v15 = (int)v8[1];
        *(_DWORD *)(a1 + 24) = v11 >> 1;
        if (v11 < 4)
          return 0;
        v10 = (v11 >> 1) - 2;
        v11 >>= 1;
        LODWORD(v14) = v15;
        v13 = &v8[v15];
      }
      else
      {
        v10 -= v9;
      }
      v7 = v8;
      v9 = v14 - 2;
      v8 = v13;
    }
    while ((int)v14 - 2 <= v10);
  }
  else
  {
    v13 = v8;
  }
  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = v13;
  *(_DWORD *)(a1 + 28) = v9 - v10;
  v16 = &v13[-(v9 - v10)];
  *a3 = *v7;
  *a5 = *v13;
  *a2 = *v16;
  *a4 = v16[1];
  return 1;
}

uint64_t shape_enum_clip_scan(uint64_t a1, _DWORD *a2)
{
  int *v2;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v27;
  int v28;
  int v29;
  int v30;
  char *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v36;
  int *v37;
  char *v38;
  int v39;

  v2 = *(int **)(a1 + 32);
  if (*(int *)a1 < 2 || v2 == 0)
    return 0;
  v5 = a1;
  v38 = (char *)(a2 + 4);
  v7 = *(int **)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 48);
  v36 = a2;
  v34 = v6;
  while (v6)
  {
    v8 = *(_QWORD *)(v5 + 48);
    v9 = *(int *)(v8 - 4);
    *(_QWORD *)(v5 + 40) = v2;
    *(_QWORD *)(v5 + 48) = v8 - 4;
    v10 = &v2[v9];
    *(_QWORD *)(v5 + 32) = v10;
    v7 = v2;
    if (*v10 == 0x80000000)
      goto LABEL_54;
LABEL_11:
    v11 = v10 + 2;
    v2 = v10;
    if (v10 + 2 != v7)
    {
      v12 = *(_DWORD *)(v5 + 16);
      v13 = *(_DWORD *)(v5 + 24);
      v14 = *v10;
      v15 = *v7 > v12 && v14 < v13;
      v2 = v10;
      if (v15)
      {
        if (*v7 >= v13)
          v16 = *(_DWORD *)(v5 + 24);
        else
          v16 = *v7;
        if (v14 <= v12)
          v17 = *(_DWORD *)(v5 + 16);
        else
          v17 = *v10;
        v18 = v16 - v17;
        v19 = v16 - v13;
        v20 = v17 - v12;
        if (v6)
          v20 = v19;
        *a2 = v20;
        a2[1] = v18;
        v2 = v10;
        if (v11 < v7)
        {
          v21 = *(_DWORD *)(v5 + 12);
          v22 = *(_DWORD *)(v5 + 20);
          v37 = v10;
          v23 = -1;
          v39 = -1;
          do
          {
            v24 = *v11;
            v25 = v11[1];
            if (v25 > v21 && v24 < v22)
            {
              v27 = v25 >= v22 ? v22 : v11[1];
              v28 = v24 <= v21 ? v21 : *v11;
              v29 = v27 - v28;
              if (v27 != v28)
              {
                v30 = v39;
                if (v39 < 0)
                {
                  bzero(v38, v22 - v21);
                  v30 = v28;
                }
                v39 = v30;
                v31 = &v38[v28 - v21];
                do
                {
                  if ((v31 & 3) == 0)
                  {
                    if (v29 >= 4)
                    {
                      if (v29 >= 7)
                        v32 = 7;
                      else
                        v32 = v29;
                      v33 = (v29 - v32 + 3) & 0xFFFFFFFC;
                      memset(v31, 255, v33 + 4);
                      v29 = v29 - v33 - 4;
                      v31 += v33 + 4;
                    }
                    if (!v29)
                      break;
                  }
                  *v31++ = -1;
                  --v29;
                }
                while (v29);
                v23 = v27;
              }
            }
            v11 += 2;
          }
          while (v11 < v7);
          a2 = v36;
          v2 = v37;
          v6 = v34;
          v5 = a1;
          if ((v39 & 0x80000000) == 0)
          {
            v36[2] = v39 - v21;
            v36[3] = v23 - v39;
            return 1;
          }
        }
      }
    }
  }
  *(_QWORD *)(v5 + 32) = v7;
  v10 = v7;
  v7 += v7[1];
  *(_QWORD *)(v5 + 40) = v7;
  if (*v7 != 0x7FFFFFFF)
    goto LABEL_11;
LABEL_54:
  result = 0;
  *(_QWORD *)(v5 + 32) = 0;
  return result;
}

uint64_t img_decode_read_alpha(uint64_t a1, unsigned int a2, uint64_t a3, uint16x4_t **a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  double v22;
  uint8x8_t v23;
  int *v24;
  int *v25;

  v12 = img_decode_read(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  if ((int)v12 < 1)
    return 0;
  v13 = v12;
  v14 = *(_DWORD *)(a1 + 40);
  if (v14 == 16)
    v15 = 2;
  else
    v15 = 1;
  if (v14 == 32)
    v16 = 4;
  else
    v16 = v15;
  if (*(_DWORD *)(a1 + 208) == 5)
    v17 = 5;
  else
    v17 = v16;
  v18 = *(unsigned int *)(a1 + 44);
  if ((_DWORD)v18 == 9)
    v19 = 8;
  else
    v19 = *(_DWORD *)(a1 + 44);
  if ((_DWORD)v18 == 4)
    v20 = 2;
  else
    v20 = v19;
  if ((_DWORD)v18 == 3)
    v21 = 1;
  else
    v21 = v20;
  img_alpha(*(_DWORD *)(a1 + 48), v12, *(unsigned int *)(a1 + 36), v21, (unsigned __int8 **)a4, a5, v18, (unsigned __int8 **)a4, a5, v17);
  v24 = *(int **)(a1 + 168);
  if (v24)
    decode_data(v24, *(unsigned int *)(a1 + 48), v13, (char *)*a4, *a5, *a4, *a5, a4[1], v22, v23, a5[1]);
  v25 = *(int **)(a1 + 176);
  if (v25)
    decode_data(v25, *(unsigned int *)(a1 + 48), v13, (char *)a4[1], a5[1], a4[1], a5[1], 0, v22, v23, 0);
  return v13;
}

void img_blocks_error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;

  if (a4)
    v8 = "%s: %s\n"
         "CGImageProviderCopyImageBlockSet(<CGImageProvider %p> (component-type = %s, pixel-size = %ld, size = [%g x %g])"
         ");\n"
         "\t<CGImageBlockSet %p> (size = [%g x %g], rect = (%g, %g) x [%g, %g], count %ld) [%ld];\n"
         "\t\t<CGImageBlock %p> (rect = (%g, %g) x [%g, %g], data = %p, bytes-per-row = %ld)";
  else
    v8 = "%s: %s\n"
         "CGImageProviderCopyImageBlockSet(<CGImageProvider %p> (component-type = %s, pixel-size = %ld, size = [%g x %g])"
         ");\n"
         "\t<CGImageBlockSet %p> (size = [%g x %g], rect = (%g, %g) x [%g, %g], count = %ld) [%ld]";
  CGPostError((uint64_t)v8, a2, a3, a4, a5, a6, a7, a8, (char)"img_blocks_create");
}

uint64_t img_blocks_read(_QWORD *a1, int a2, unsigned int a3, _QWORD *a4, int *a5)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t result;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;

  v5 = a1[23];
  v26 = 0;
  v27 = a2;
  v28 = a1[15];
  v29 = a3;
  if ((int)*(_QWORD *)(v5 + 40) >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = *(_DWORD *)(v5 + 32);
    v10 = 16 * *(_QWORD *)(v5 + 40);
    do
    {
      v24 = 0;
      v25 = 0;
      v23 = 0uLL;
      v23 = *(_OWORD *)(*(_QWORD *)(v5 + 72) + v8);
      if (CGSBoundsIntersection(&v26, (int *)&v23, &v24))
      {
        v11 = *(_QWORD *)(*(_QWORD *)(v5 + 80) + v7);
        v12 = *(_QWORD *)(*(_QWORD *)(v5 + 88) + v7);
        v13 = (char *)(*a4 + (HIDWORD(v24) - v27) * *a5 + ((int)v24 - (uint64_t)v26) * v9);
        if (!v11)
          CGBlt_fillBytes(v25 * v9, HIDWORD(v25), 0, v13, *a5);
        v14 = a1[14];
        if (v14)
        {
          CGBlt_swapBytes(v25 * v9, HIDWORD(v25), (void *)(v11 + v12 * (SHIDWORD(v24) - (uint64_t)SDWORD1(v23)) + ((int)v24 - (uint64_t)(int)v23) * v9), v13, v12, *a5, v14);
        }
        else
        {
          if (*(_QWORD *)(v5 + 48) != *(_QWORD *)(v5 + 40))
          {
            v16 = v24;
            v17 = HIDWORD(v24);
            LODWORD(v15) = *a5;
LABEL_13:
            CGBlt_copyBytes(v25 * v9, SHIDWORD(v25), (char *)(v11 + v12 * (v17 - (uint64_t)SDWORD1(v23)) + (v16 - (uint64_t)(int)v23) * v9), v13, v12, v15);
            goto LABEL_14;
          }
          v15 = *a5;
          v16 = v24;
          v17 = HIDWORD(v24);
          if ((v15 & 0x80000000) != 0 || v12 != v15)
            goto LABEL_13;
          memcpy(v13, (const void *)(v11 + v12 * (SHIDWORD(v24) - (uint64_t)SDWORD1(v23)) + ((int)v24 - (int)v23) * v9), v12 * SHIDWORD(v25));
        }
      }
LABEL_14:
      v8 += 16;
      v7 += 8;
    }
    while (v10 != v8);
  }
  result = a3;
  a1[11] = (int)(a3 + a2);
  return result;
}

void AddPdfOperators(CGPDFOperatorTable *a1)
{
  CGPDFOperatorTableSetCallback(a1, "b", (CGPDFOperatorCallback)op_b_10946);
  CGPDFOperatorTableSetCallback(a1, "B", (CGPDFOperatorCallback)op_B_10948);
  CGPDFOperatorTableSetCallback(a1, "BMC", (CGPDFOperatorCallback)op_BMC_10950);
  CGPDFOperatorTableSetCallback(a1, "BDC", (CGPDFOperatorCallback)op_BDC_10952);
  CGPDFOperatorTableSetCallback(a1, "EMC", (CGPDFOperatorCallback)op_EMC_10954);
  CGPDFOperatorTableSetCallback(a1, "BT", (CGPDFOperatorCallback)op_BT_10956);
  CGPDFOperatorTableSetCallback(a1, "b*", (CGPDFOperatorCallback)op_bstar_10958);
  CGPDFOperatorTableSetCallback(a1, "B*", (CGPDFOperatorCallback)op_Bstar_10960);
  CGPDFOperatorTableSetCallback(a1, "c", (CGPDFOperatorCallback)op_c_10962);
  CGPDFOperatorTableSetCallback(a1, "cm", (CGPDFOperatorCallback)op_cm_10964);
  CGPDFOperatorTableSetCallback(a1, "cs", (CGPDFOperatorCallback)op_cs_10966);
  CGPDFOperatorTableSetCallback(a1, "CS", (CGPDFOperatorCallback)op_CS_10968);
  CGPDFOperatorTableSetCallback(a1, "Do", (CGPDFOperatorCallback)op_Do_10970);
  CGPDFOperatorTableSetCallback(a1, "d", (CGPDFOperatorCallback)op_d_10972);
  CGPDFOperatorTableSetCallback(a1, "DP", (CGPDFOperatorCallback)op_DP_10974);
  CGPDFOperatorTableSetCallback(a1, "d0", (CGPDFOperatorCallback)op_d0_10976);
  CGPDFOperatorTableSetCallback(a1, "d1", (CGPDFOperatorCallback)op_d1_10978);
  CGPDFOperatorTableSetCallback(a1, "EI", (CGPDFOperatorCallback)op_EI_10980);
  CGPDFOperatorTableSetCallback(a1, "ET", (CGPDFOperatorCallback)op_ET_10982);
  CGPDFOperatorTableSetCallback(a1, "f", (CGPDFOperatorCallback)op_f_10984);
  CGPDFOperatorTableSetCallback(a1, "F", (CGPDFOperatorCallback)op_f_10984);
  CGPDFOperatorTableSetCallback(a1, "f*", (CGPDFOperatorCallback)op_fstar_10987);
  CGPDFOperatorTableSetCallback(a1, "g", (CGPDFOperatorCallback)op_g_10989);
  CGPDFOperatorTableSetCallback(a1, "G", (CGPDFOperatorCallback)op_G_10991);
  CGPDFOperatorTableSetCallback(a1, "gs", (CGPDFOperatorCallback)op_gs_10993);
  CGPDFOperatorTableSetCallback(a1, "h", (CGPDFOperatorCallback)op_h_10995);
  CGPDFOperatorTableSetCallback(a1, "i", (CGPDFOperatorCallback)op_i_10997);
  CGPDFOperatorTableSetCallback(a1, "j", (CGPDFOperatorCallback)op_j_10999);
  CGPDFOperatorTableSetCallback(a1, "J", (CGPDFOperatorCallback)op_J_11001);
  CGPDFOperatorTableSetCallback(a1, "k", (CGPDFOperatorCallback)op_k_11003);
  CGPDFOperatorTableSetCallback(a1, "K", (CGPDFOperatorCallback)op_K_11005);
  CGPDFOperatorTableSetCallback(a1, "l", (CGPDFOperatorCallback)op_l_11007);
  CGPDFOperatorTableSetCallback(a1, "m", (CGPDFOperatorCallback)op_m_11009);
  CGPDFOperatorTableSetCallback(a1, "M", (CGPDFOperatorCallback)op_M_11011);
  CGPDFOperatorTableSetCallback(a1, "MP", (CGPDFOperatorCallback)op_MP_11013);
  CGPDFOperatorTableSetCallback(a1, "n", (CGPDFOperatorCallback)op_n_11015);
  CGPDFOperatorTableSetCallback(a1, "q", (CGPDFOperatorCallback)op_q_11017);
  CGPDFOperatorTableSetCallback(a1, "Q", (CGPDFOperatorCallback)op_Q_11019);
  CGPDFOperatorTableSetCallback(a1, "re", (CGPDFOperatorCallback)op_re_11021);
  CGPDFOperatorTableSetCallback(a1, "RG", (CGPDFOperatorCallback)op_RG_11023);
  CGPDFOperatorTableSetCallback(a1, "rg", (CGPDFOperatorCallback)op_rg_11025);
  CGPDFOperatorTableSetCallback(a1, "ri", (CGPDFOperatorCallback)op_ri_11027);
  CGPDFOperatorTableSetCallback(a1, "s", (CGPDFOperatorCallback)op_s_11029);
  CGPDFOperatorTableSetCallback(a1, "S", (CGPDFOperatorCallback)op_S_11031);
  CGPDFOperatorTableSetCallback(a1, "sc", (CGPDFOperatorCallback)op_sc_11033);
  CGPDFOperatorTableSetCallback(a1, "SC", (CGPDFOperatorCallback)op_SC_11035);
  CGPDFOperatorTableSetCallback(a1, "SCN", (CGPDFOperatorCallback)op_SCN_11037);
  CGPDFOperatorTableSetCallback(a1, "scn", (CGPDFOperatorCallback)op_scn_11039);
  CGPDFOperatorTableSetCallback(a1, "sh", (CGPDFOperatorCallback)op_sh_11041);
  CGPDFOperatorTableSetCallback(a1, "Tc", (CGPDFOperatorCallback)op_Tc_11043);
  CGPDFOperatorTableSetCallback(a1, "Td", (CGPDFOperatorCallback)op_Td_11045);
  CGPDFOperatorTableSetCallback(a1, "TD", (CGPDFOperatorCallback)op_TD_11047);
  CGPDFOperatorTableSetCallback(a1, "Tf", (CGPDFOperatorCallback)op_Tf_11049);
  CGPDFOperatorTableSetCallback(a1, "Tj", (CGPDFOperatorCallback)op_Tj_11051);
  CGPDFOperatorTableSetCallback(a1, "TJ", (CGPDFOperatorCallback)op_TJ_11053);
  CGPDFOperatorTableSetCallback(a1, "TL", (CGPDFOperatorCallback)op_TL_11055);
  CGPDFOperatorTableSetCallback(a1, "Tm", (CGPDFOperatorCallback)op_Tm_11057);
  CGPDFOperatorTableSetCallback(a1, "Tr", (CGPDFOperatorCallback)op_Tr_11059);
  CGPDFOperatorTableSetCallback(a1, "T*", (CGPDFOperatorCallback)op_Tstar_11061);
  CGPDFOperatorTableSetCallback(a1, "Ts", (CGPDFOperatorCallback)op_Ts_11063);
  CGPDFOperatorTableSetCallback(a1, "Tw", (CGPDFOperatorCallback)op_Tw_11065);
  CGPDFOperatorTableSetCallback(a1, "Tz", (CGPDFOperatorCallback)op_Tz_11067);
  CGPDFOperatorTableSetCallback(a1, "v", (CGPDFOperatorCallback)op_v_11069);
  CGPDFOperatorTableSetCallback(a1, "W", (CGPDFOperatorCallback)op_W_11071);
  CGPDFOperatorTableSetCallback(a1, "w", (CGPDFOperatorCallback)op_w_11073);
  CGPDFOperatorTableSetCallback(a1, "W*", (CGPDFOperatorCallback)op_Wstar_11075);
  CGPDFOperatorTableSetCallback(a1, "y", (CGPDFOperatorCallback)op_y_11077);
  CGPDFOperatorTableSetCallback(a1, "'", (CGPDFOperatorCallback)op_quo_11079);
  CGPDFOperatorTableSetCallback(a1, "\"", (CGPDFOperatorCallback)op_quoquo_11081);
}

uint64_t op_b_10946(uint64_t a1, uint64_t a2)
{
  op_h_10995(a1, a2);
  return CPPDFContextAddStrokeAndFill(a2, 1);
}

uint64_t op_B_10948(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddStrokeAndFill(a2, 1);
}

void op_BMC_10950(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL4 v3;
  CGPDFDictionary *v4;
  uint64_t v5;
  TaggedParser *v6;
  char *value;

  value = 0;
  v3 = CGPDFScannerPopName(a1, (const char **)&value);
  if (a2)
  {
    if (v3)
    {
      v5 = *(_QWORD *)(a2 + 2344);
      if (v5)
      {
        v6 = *(TaggedParser **)(v5 + 16);
        if (v6)
          TaggedParser::BeginMarkedContentSequence(v6, *(CGPDFPage **)(a2 + 2288), 0, v4);
      }
    }
  }
}

void op_BDC_10952(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  int v6;
  CGPDFDictionary *v7;
  const char *v8;
  _BOOL4 v9;
  char *v10;
  uint64_t v11;
  CGPDFPage *v12;
  TaggedParser *v13;
  char *value;

  v2 = *(_DWORD *)(a1 + 72);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.");
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 80);
    v4 = v2 - 1;
    *(_DWORD *)(a1 + 72) = v4;
    if (!v3)
      return;
    v6 = *(_DWORD *)(v3 + 40 * v4 + 8);
    if (v6 == 8)
    {
      v8 = 0;
      v7 = *(CGPDFDictionary **)(v3 + 40 * v4 + 32);
    }
    else
    {
      if (v6 != 5)
        return;
      v7 = 0;
      v8 = *(const char **)(v3 + 40 * v4 + 32);
    }
    value = 0;
    v9 = CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value);
    if (a2)
    {
      if (v9)
      {
        v11 = *(_QWORD *)(a2 + 2344);
        if (v11)
        {
          v12 = *(CGPDFPage **)(a2 + 2288);
          v13 = *(TaggedParser **)(v11 + 16);
          if (v8)
          {
            if (v13)
              TaggedParser::BeginMarkedContentSequence(v13, v12, v8, v10);
          }
          else if (v13)
          {
            TaggedParser::BeginMarkedContentSequence(v13, v12, v7, (CGPDFDictionary *)v10);
          }
        }
      }
    }
  }
}

uint64_t op_EMC_10954(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t result;

  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 2344);
    if (v2)
    {
      v3 = *(uint64_t **)(v2 + 16);
      if (v3)
        return TaggedParser::EndMarkedContentSequence(*v3, *(CGPDFPage **)(a2 + 2288));
    }
  }
  return result;
}

CGFloat op_BT_10956(uint64_t a1, uint64_t a2)
{
  CGFloat result;

  result = CGAffineTransformIdentity.a;
  *(CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 88) = CGAffineTransformIdentity;
  *(CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 136) = CGAffineTransformIdentity;
  return result;
}

uint64_t op_bstar_10958(uint64_t a1, uint64_t a2)
{
  op_h_10995(a1, a2);
  return CPPDFContextAddStrokeAndFill(a2, 0);
}

uint64_t op_Bstar_10960(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddStrokeAndFill(a2, 0);
}

void op_c_10962(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat y;
  CGFloat v4;
  CGFloat v5;
  CGFloat v6;
  CGFloat v7;
  CGFloat v8;

  v8 = 0.0;
  v6 = 0.0;
  v7 = 0.0;
  v4 = 0.0;
  v5 = 0.0;
  y = 0.0;
  if (common_ReadCGPathCurve(a1, &v8, &v7, &v6, &v5, &v4, &y)
    && !CGPathIsEmpty(*(CGPathRef *)(*(_QWORD *)(a2 + 40) + 64)))
  {
    CGPathAddCurveToPoint(*(CGMutablePathRef *)(*(_QWORD *)(a2 + 40) + 64), (const CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 16), v8, v7, v6, v5, v4, y);
  }
}

double op_cm_10964(CGPDFScanner *a1, uint64_t a2)
{
  double result;
  CGAffineTransform v4;
  CGAffineTransform v5;

  v5 = CGAffineTransformIdentity;
  if (common_ReadCGAffineTransform(a1, &v5.a))
  {
    v4 = v5;
    return CPPDFContextConcatCTM(*(double **)(a2 + 40), &v4.a);
  }
  return result;
}

void op_cs_10966(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpaceRef v3;
  CGColorSpaceRef v4;
  uint64_t v5;
  CGColorSpace *v6;

  v3 = CPPDFCreateColorSpace(a1, a2);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(CGColorSpace **)(v5 + 264);
    if (v6)
    {
      CGColorSpaceRelease(v6);
      v5 = *(_QWORD *)(a2 + 40);
    }
    *(_QWORD *)(v5 + 264) = v4;
    *(_BYTE *)(v5 + 9) = 1;
  }
}

void op_CS_10968(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpaceRef v3;
  CGColorSpaceRef v4;
  uint64_t v5;
  CGColorSpace *v6;

  v3 = CPPDFCreateColorSpace(a1, a2);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(CGColorSpace **)(v5 + 280);
    if (v6)
    {
      CGColorSpaceRelease(v6);
      v5 = *(_QWORD *)(a2 + 40);
    }
    *(_QWORD *)(v5 + 280) = v4;
    *(_BYTE *)(v5 + 9) = 1;
  }
}

void op_Do_10970(CGPDFScanner *a1, uint64_t a2)
{
  const char *v3;
  CGPDFDictionary *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  CGPDFReal v10;
  CGPDFReal v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  CGPDFBoolean v23;
  CGPDFReal v24;
  CGPDFReal value;
  uint64_t v26;
  CGPDFDictionaryRef v27;
  const char *v28;

  v27 = 0;
  v28 = 0;
  v26 = 0;
  if (common_op_Do(a1, &v28, &v27, (uint64_t)&v26))
  {
    v3 = v28;
    if (!strcmp(v28, "Image"))
    {
      v24 = 0.0;
      value = 0.0;
      v4 = v27;
      if (!CGPDFDictionaryGetNumber(v27, "Width", &value))
        value = 0.0;
      if (!CGPDFDictionaryGetNumber(v4, "Height", &v24))
        v24 = 0.0;
      v23 = 0;
      if (CGPDFDictionaryGetBoolean(v4, "ImageMask", &v23))
      {
        v5 = v23 == 0;
      }
      else
      {
        v23 = 0;
        v5 = 1;
      }
      v6 = 0;
      v15 = 0u;
      v7 = *(_QWORD *)(a2 + 40);
      DWORD2(v15) = *(_DWORD *)(v7 + 308);
      *(_QWORD *)&v15 = v26;
      v8 = *(_QWORD *)(v7 + 368);
      v19 = 0;
      v20 = v8;
      v22 = 0;
      v21 = 0u;
      v18 = 0u;
      v17 = 0u;
      v16 = 0u;
      v14 = 0u;
      v13 = 0u;
      v12 = 0u;
      v9 = 0uLL;
      v10 = value;
      v11 = v24;
      if (!v5)
        v6 = *(_QWORD *)(v7 + 256);
      *((_QWORD *)&v21 + 1) = v6;
      CPPDFContextAddImage(a2, &v9);
    }
    else if (!strcmp(v3, "Form"))
    {
      DoPdfForm(a2, v26, 0);
    }
  }
}

CGPDFReal op_d_10972(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal result;
  uint64_t v5;
  CGPDFArrayRef v6;
  CGPDFReal value;

  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    v6 = 0;
    if (CGPDFScannerPopArray(a1, &v6))
    {
      v5 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(v5 + 360) = v6;
      result = value;
      *(CGPDFReal *)(v5 + 352) = value;
      *(_BYTE *)(v5 + 9) = 1;
    }
  }
  return result;
}

void op_DP_10974(CGPDFScanner *a1)
{
  int v1;
  char *value;

  v1 = *((_DWORD *)a1 + 18);
  if (v1 <= 0)
  {
    pdf_error("stack underflow.");
  }
  else
  {
    value = 0;
    *((_DWORD *)a1 + 18) = v1 - 1;
    CGPDFScannerPopName(a1, (const char **)&value);
  }
}

void op_EI_10980(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFDictionary *v3;
  _BOOL4 v4;
  uint64_t v5;
  CGFloat *decode;
  CGColorSpace *v7;
  uint64_t v8;
  size_t i;
  BOOL v10;
  CGColorSpace *DeviceCMYK;
  const __CFData *v12;
  const __CFData *v13;
  CGDataProvider *v14;
  CGDataProvider *v15;
  CGColorRenderingIntent intent;
  CGImageRef v17;
  CGImageRef v18;
  CFDictionaryRef v19;
  const void *v20;
  CGColorSpace *v21;
  CGPDFInteger v22;
  uint64_t v23;
  CGPDFInteger v24;
  CGPDFInteger Length;
  uint64_t v26;
  uint64_t v27;
  CGPDFReal v28[4];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  CGPDFDataFormat format;
  CGColorSpace *v40;
  CGPDFArrayRef v41;
  CGPDFBoolean v42;
  CGPDFBoolean v43;
  CGPDFObjectRef v44;
  CGPDFInteger v45;
  CGPDFInteger v46;
  CGPDFInteger v47;
  CGPDFStreamRef value;

  value = 0;
  if (!CGPDFScannerPopStream(a1, &value))
    return;
  if (!value)
    return;
  v3 = (CGPDFDictionary *)*((_QWORD *)value + 6);
  if (!v3)
    return;
  v47 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "W", &v47) && !CGPDFDictionaryGetInteger(v3, "Width", &v47))
    return;
  v46 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "H", &v46) && !CGPDFDictionaryGetInteger(v3, "Height", &v46))
    return;
  v45 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "BPC", &v45) && !CGPDFDictionaryGetInteger(v3, "BitsPerComponent", &v45))
    v45 = 0;
  v44 = 0;
  if (!CGPDFDictionaryGetObject(v3, "CS", &v44) && !CGPDFDictionaryGetObject(v3, "ColorSpace", &v44))
    v44 = 0;
  v43 = 0;
  if (!CGPDFDictionaryGetBoolean(v3, "IM", &v43) && !CGPDFDictionaryGetBoolean(v3, "ImageMask", &v43))
    v43 = 0;
  v42 = 0;
  if (!CGPDFDictionaryGetBoolean(v3, "I", &v42) && !CGPDFDictionaryGetBoolean(v3, "Interpolate", &v42))
    v42 = 0;
  v41 = 0;
  v4 = CGPDFDictionaryGetArray(v3, "D", &v41) || CGPDFDictionaryGetArray(v3, "Decode", &v41);
  v40 = 0;
  if (v44 && !v43)
    CreateColorSpaceFromInlineObject((uint64_t)v44, &v40);
  if (!v4)
  {
    decode = 0;
    goto LABEL_50;
  }
  if (v41)
    v5 = *((_QWORD *)v41 + 2);
  else
    v5 = 0;
  v7 = v40;
  if (v40)
    v8 = *(_QWORD *)(*((_QWORD *)v40 + 3) + 40);
  else
    v8 = 0;
  decode = 0;
  if (v5 && v5 == 2 * v8)
  {
    decode = (CGFloat *)malloc_type_malloc(8 * v5, 0x100004000313F17uLL);
    for (i = 0; i != v5; ++i)
    {
      v28[0] = 0.0;
      CGPDFArrayGetNumber(v41, i, v28);
      decode[i] = v28[0];
    }
  }
  if (v43)
    v10 = 0;
  else
    v10 = v7 == 0;
  if (v10)
  {
    switch(v5)
    {
      case 8:
        DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
        break;
      case 6:
        DeviceCMYK = CGColorSpaceCreateDeviceRGB();
        break;
      case 2:
        DeviceCMYK = CGColorSpaceCreateDeviceGray();
        break;
      default:
        goto LABEL_50;
    }
    v40 = DeviceCMYK;
  }
LABEL_50:
  format = CGPDFDataFormatRaw;
  v12 = CGPDFStreamCopyData(value, &format);
  if (v12)
  {
    v13 = v12;
    v14 = CGDataProviderCreateWithCFData(v12);
    if (!v14)
    {
      v18 = 0;
LABEL_72:
      CFRelease(v13);
      goto LABEL_73;
    }
    v15 = v14;
    intent = *(_DWORD *)(*(_QWORD *)(a2 + 40) + 308);
    if (format)
    {
      if (format == CGPDFDataFormatJPEG2000)
      {
        v19 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&kCGImageSourceTypeIdentifierHint, (const void **)&kUTTypeJPEG2000, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (op_EI_predicate != -1)
          dispatch_once(&op_EI_predicate, &__block_literal_global_11097);
        v20 = (const void *)op_EI_f(v13, v19);
        CFRelease(v19);
        if (v20)
        {
          if (op_EI_predicate_86 != -1)
            dispatch_once(&op_EI_predicate_86, &__block_literal_global_87_11098);
          v18 = (CGImageRef)op_EI_f_85(v20, 0, 0);
          CFRelease(v20);
          goto LABEL_71;
        }
      }
      else if (format == CGPDFDataFormatJPEGEncoded)
      {
        v17 = CGImageCreateWithJPEGDataProvider2((uint64_t)v14, 0, 0, v42 != 0, *(_DWORD *)(*(_QWORD *)(a2 + 40) + 308));
LABEL_60:
        v18 = v17;
LABEL_71:
        CGDataProviderRelease(v15);
        goto LABEL_72;
      }
    }
    else
    {
      if (v43)
      {
        v45 = 1;
        v17 = mask_create(v47, v46, 1uLL, 1uLL, vcvtps_u32_f32((float)v47 * 0.125), v14, 0, v42 != 0, 4);
        goto LABEL_60;
      }
      v18 = 0;
      v21 = v40;
      if (!v40)
        goto LABEL_71;
      v22 = v45;
      if (v45 < 1)
        goto LABEL_71;
      v23 = *(_QWORD *)(*((_QWORD *)v40 + 3) + 40);
      v24 = v47;
      Length = CFDataGetLength(v13);
      if (Length >= v47 * v23 * v46 * v45 / 8)
      {
        v17 = CGImageCreate(v47, v46, v45, v22 * v23, vcvtps_u32_f32((float)(unint64_t)(v22 * v23 * v24) * 0.125), v21, 0, v15, decode, v42 != 0, intent);
        goto LABEL_60;
      }
    }
    v18 = 0;
    goto LABEL_71;
  }
  v18 = 0;
LABEL_73:
  if (v40)
    CGColorSpaceRelease(v40);
  if (decode)
    free(decode);
  v38 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  v28[0] = 0.0;
  v28[1] = 0.0;
  v28[2] = (double)v47;
  v28[3] = (double)v46;
  v26 = *(_QWORD *)(a2 + 40);
  DWORD2(v32) = *(_DWORD *)(v26 + 308);
  *(_QWORD *)&v33 = v18;
  *((_QWORD *)&v36 + 1) = *(_QWORD *)(v26 + 368);
  if (v43)
    v27 = *(_QWORD *)(v26 + 256);
  else
    v27 = 0;
  *((_QWORD *)&v37 + 1) = v27;
  CPPDFContextAddImage(a2, (__int128 *)v28);
  if (v18)
    CFRelease(v18);
}

uint64_t op_f_10984(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddFill(a2, 1);
}

uint64_t op_fstar_10987(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddFill(a2, 0);
}

void op_g_10989(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpace *DeviceGray;
  CGColorRef v5;
  uint64_t v6;
  CGColorSpace *v7;
  const void *v8;
  CGPDFReal value[3];

  value[2] = *(CGPDFReal *)MEMORY[0x1E0C80C00];
  DeviceGray = CGColorSpaceCreateDeviceGray();
  if (!CGPDFScannerPopNumber(a1, value))
    value[0] = 0.0;
  value[1] = 1.0;
  v5 = CGColorCreate(DeviceGray, value);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(CGColorSpace **)(v6 + 264);
  if (v7)
  {
    CGColorSpaceRelease(v7);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 264) = DeviceGray;
  v8 = *(const void **)(v6 + 256);
  if (v8)
  {
    CFRelease(v8);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 256) = v5;
  *(_BYTE *)(v6 + 9) = 1;
}

void op_G_10991(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpace *DeviceGray;
  CGColorRef v5;
  uint64_t v6;
  CGColorSpace *v7;
  const void *v8;
  CGPDFReal value[3];

  value[2] = *(CGPDFReal *)MEMORY[0x1E0C80C00];
  DeviceGray = CGColorSpaceCreateDeviceGray();
  if (!CGPDFScannerPopNumber(a1, value))
    value[0] = 0.0;
  value[1] = 1.0;
  v5 = CGColorCreate(DeviceGray, value);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(CGColorSpace **)(v6 + 280);
  if (v7)
  {
    CGColorSpaceRelease(v7);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 280) = DeviceGray;
  v8 = *(const void **)(v6 + 272);
  if (v8)
  {
    CFRelease(v8);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 272) = v5;
  *(_BYTE *)(v6 + 9) = 1;
}

CGPDFDictionary *op_gs_10993(CGPDFObjectRef *a1, uint64_t a2)
{
  CGPDFDictionary *result;
  CGPDFDictionary *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CGPDFArrayRef v9;
  CGPDFArrayRef array;
  char *value;

  value = 0;
  result = (CGPDFDictionary *)CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value);
  if ((_DWORD)result)
  {
    result = common_GetResourceDictionary(a1[7], "ExtGState", value);
    if (result)
    {
      v5 = result;
      result = (CGPDFDictionary *)common_op_gs(a2, result);
      if ((_DWORD)result)
      {
        array = 0;
        if (CGPDFDictionaryGetArray(v5, "D", &array))
        {
          v8 = 0;
          v9 = 0;
          if (CGPDFArrayGetArray(array, 0, &v9) && CGPDFArrayGetNumber(array, 1uLL, (CGPDFReal *)&v8))
          {
            v6 = *(_QWORD *)(a2 + 40);
            *(_QWORD *)(v6 + 360) = v9;
            *(_QWORD *)(v6 + 352) = v8;
          }
        }
        v9 = 0;
        result = (CGPDFDictionary *)CGPDFDictionaryGetDictionary(v5, "SMask", &v9);
        v7 = *(_QWORD *)(a2 + 40);
        if ((result & 1) != 0)
          *(_QWORD *)(v7 + 368) = v9;
        *(_BYTE *)(v7 + 9) = 1;
      }
    }
  }
  return result;
}

void op_h_10995(uint64_t a1, uint64_t a2)
{
  if (!CGPathIsEmpty(*(CGPathRef *)(*(_QWORD *)(a2 + 40) + 64)))
    CGPathCloseSubpath(*(CGMutablePathRef *)(*(_QWORD *)(a2 + 40) + 64));
}

CGPDFReal op_i_10997(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal result;
  uint64_t v4;
  CGPDFReal value;

  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    result = value;
    v4 = *(_QWORD *)(a2 + 40);
    *(CGPDFReal *)(v4 + 312) = value;
    *(_BYTE *)(v4 + 9) = 1;
  }
  return result;
}

BOOL op_j_10999(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFInteger value;

  value = 0;
  result = CGPDFScannerPopInteger(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 40);
    *(_BYTE *)(v4 + 305) = value;
    *(_BYTE *)(v4 + 9) = 1;
  }
  return result;
}

BOOL op_J_11001(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v4;
  CGPDFInteger value;

  value = 0;
  result = CGPDFScannerPopInteger(a1, &value);
  if (result)
  {
    v4 = *(_QWORD *)(a2 + 40);
    *(_BYTE *)(v4 + 304) = value;
    *(_BYTE *)(v4 + 9) = 1;
  }
  return result;
}

void op_k_11003(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpace *DeviceCMYK;
  CGColorRef v5;
  uint64_t v6;
  const void *v7;
  CGColorSpace *v8;

  DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  v5 = common_PopCMYKAlphaCGColorCreate(a1, DeviceCMYK);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(const void **)(v6 + 256);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 256) = v5;
  v8 = *(CGColorSpace **)(v6 + 264);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 264) = DeviceCMYK;
  *(_BYTE *)(v6 + 9) = 1;
}

void op_K_11005(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpace *DeviceCMYK;
  CGColorRef v5;
  uint64_t v6;
  const void *v7;
  CGColorSpace *v8;

  DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  v5 = common_PopCMYKAlphaCGColorCreate(a1, DeviceCMYK);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(const void **)(v6 + 272);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 272) = v5;
  v8 = *(CGColorSpace **)(v6 + 280);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 280) = DeviceCMYK;
  *(_BYTE *)(v6 + 9) = 1;
}

void op_l_11007(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGPDFReal value;

  v4 = 0.0;
  value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &value)
    && !CGPathIsEmpty(*(CGPathRef *)(*(_QWORD *)(a2 + 40) + 64)))
  {
    CGPathAddLineToPoint(*(CGMutablePathRef *)(*(_QWORD *)(a2 + 40) + 64), (const CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 16), value, v4);
  }
}

void op_m_11009(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGFloat y;
  CGPDFReal value;

  y = 0.0;
  value = 0.0;
  if (!CGPDFScannerPopNumber(a1, &y))
    y = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    v4 = value;
  }
  else
  {
    value = 0.0;
    v4 = 0.0;
  }
  CGPathMoveToPoint(*(CGMutablePathRef *)(*(_QWORD *)(a2 + 40) + 64), (const CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 16), v4, y);
}

BOOL op_M_11011(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;

  result = CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 288));
  if (result)
    *(_BYTE *)(*(_QWORD *)(a2 + 40) + 9) = 1;
  return result;
}

BOOL op_MP_11013(CGPDFScanner *a1)
{
  char *value;

  value = 0;
  return CGPDFScannerPopName(a1, (const char **)&value);
}

CGMutablePathRef op_n_11015(uint64_t a1, uint64_t a2)
{
  const void *v3;
  CGMutablePathRef result;

  CPPDFContextAddPathToClip(a2, 0);
  v3 = *(const void **)(*(_QWORD *)(a2 + 40) + 64);
  if (v3)
    CFRelease(v3);
  result = CGPathCreateMutable();
  *(_QWORD *)(*(_QWORD *)(a2 + 40) + 64) = result;
  return result;
}

void op_q_11017(uint64_t a1, uint64_t a2)
{
  CPPDFContextSaveGState(a2);
}

void op_Q_11019(uint64_t a1, uint64_t a2)
{
  CPPDFContextRestoreGState(a2);
}

void op_re_11021(CGPDFScanner *a1, uint64_t a2)
{
  CGRect v3;

  memset(&v3, 0, sizeof(v3));
  if (common_ReadCGRect(a1, &v3.origin.x))
    CGPathAddRect(*(CGMutablePathRef *)(*(_QWORD *)(a2 + 40) + 64), (const CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 16), v3);
}

void op_RG_11023(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpace *DeviceRGB;
  CGColorRef v5;
  uint64_t v6;
  const void *v7;
  CGColorSpace *v8;

  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v5 = common_PopRGBAlphaCGColorCreate(a1, DeviceRGB);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(const void **)(v6 + 272);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 272) = v5;
  v8 = *(CGColorSpace **)(v6 + 280);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 280) = DeviceRGB;
  *(_BYTE *)(v6 + 9) = 1;
}

void op_rg_11025(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpace *DeviceRGB;
  CGColorRef v5;
  uint64_t v6;
  const void *v7;
  CGColorSpace *v8;

  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v5 = common_PopRGBAlphaCGColorCreate(a1, DeviceRGB);
  v6 = *(_QWORD *)(a2 + 40);
  v7 = *(const void **)(v6 + 256);
  if (v7)
  {
    CFRelease(v7);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 256) = v5;
  v8 = *(CGColorSpace **)(v6 + 264);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    v6 = *(_QWORD *)(a2 + 40);
  }
  *(_QWORD *)(v6 + 264) = DeviceRGB;
  *(_BYTE *)(v6 + 9) = 1;
}

uint64_t op_s_11029(uint64_t a1, uint64_t a2)
{
  op_h_10995(a1, a2);
  return CPPDFContextAddStroke(a2);
}

uint64_t op_S_11031(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddStroke(a2);
}

void op_sc_11033(CGPDFScanner *a1, uint64_t a2)
{
  SetColor(a1, a2, 0);
}

void op_SC_11035(CGPDFScanner *a1, uint64_t a2)
{
  SetColor(a1, a2, 1);
}

void op_SCN_11037(CGPDFScanner *a1, uint64_t a2)
{
  SetColor(a1, a2, 1);
}

void op_scn_11039(CGPDFScanner *a1, uint64_t a2)
{
  SetColor(a1, a2, 0);
}

void op_sh_11041(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  char v5;
  CGPath *v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  if (common_op_sh(a1, (double *)a2, &v7, &v6))
  {
    CPPDFContextSaveGState(a2);
    v3 = *(_QWORD *)(a2 + 40);
    *(_QWORD *)(v3 + 376) = v7;
    v4 = *(const void **)(v3 + 64);
    if (v4)
    {
      CFRelease(v4);
      v3 = *(_QWORD *)(a2 + 40);
    }
    *(_QWORD *)(v3 + 64) = v6;
    v5 = *(_BYTE *)(v3 + 8);
    *(_BYTE *)(v3 + 8) = 1;
    CPPDFContextAddShape(a2, 1, 1);
    *(_BYTE *)(*(_QWORD *)(a2 + 40) + 8) = v5;
    CPPDFContextRestoreGState(a2);
  }
}

BOOL op_Tc_11043(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 184));
}

__n128 op_Td_11045(CGPDFScanner *a1, uint64_t a2)
{
  __n128 result;
  double *v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  __int128 v12;

  v12 = *(_OWORD *)&CGAffineTransformIdentity.tx;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v12 + 1) && CGPDFScannerPopNumber(a1, (CGPDFReal *)&v12))
  {
    v5 = *(double **)(a2 + 40);
    v6 = v5[17];
    v7 = v5[18];
    v8 = v5[19];
    v9 = v5[20];
    v10 = v5[21] + v8 * *((double *)&v12 + 1) + *(double *)&v12 * v6;
    v11 = v9 * *((double *)&v12 + 1) + *(double *)&v12 * v7 + v5[22];
    v5[11] = 0.0 * v8 + 1.0 * v6;
    v5[12] = 0.0 * v9 + 1.0 * v7;
    v5[13] = 1.0 * v8 + 0.0 * v6;
    v5[14] = 1.0 * v9 + 0.0 * v7;
    v5[15] = v10;
    v5[16] = v11;
    *(_OWORD *)(v5 + 17) = *(_OWORD *)(v5 + 11);
    *(_OWORD *)(v5 + 19) = *(_OWORD *)(v5 + 13);
    result = *(__n128 *)(v5 + 15);
    *(__n128 *)(v5 + 21) = result;
  }
  return result;
}

__n128 op_TD_11047(CGPDFScanner *a1, uint64_t a2)
{
  __n128 result;
  double v5;
  double v6;
  double *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  __int128 v14;

  v14 = *(_OWORD *)&CGAffineTransformIdentity.tx;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v14 + 1) && CGPDFScannerPopNumber(a1, (CGPDFReal *)&v14))
  {
    v5 = *((double *)&v14 + 1);
    v6 = *(double *)&v14;
    v7 = *(double **)(a2 + 40);
    v7[26] = -*((double *)&v14 + 1);
    v8 = v7[17];
    v9 = v7[18];
    v10 = v7[19];
    v11 = v7[20];
    v12 = v7[22];
    v13 = v7[21] + v10 * v5 + v6 * v8;
    v7[11] = 0.0 * v10 + 1.0 * v8;
    v7[12] = 0.0 * v11 + 1.0 * v9;
    v7[13] = 1.0 * v10 + 0.0 * v8;
    v7[14] = 1.0 * v11 + 0.0 * v9;
    v7[15] = v13;
    v7[16] = v11 * v5 + v6 * v9 + v12;
    *(_OWORD *)(v7 + 19) = *(_OWORD *)(v7 + 13);
    *(_OWORD *)(v7 + 17) = *(_OWORD *)(v7 + 11);
    result = *(__n128 *)(v7 + 15);
    *(__n128 *)(v7 + 21) = result;
  }
  return result;
}

void op_Tf_11049(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFContentStream *v4;
  CGPDFObjectRef Resource;
  const void *v6;
  CPFont *v7;
  uint64_t v8;
  uint64_t v9;
  CPFont *v10;
  uint64_t v11;
  char *value;

  v11 = 0;
  value = 0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v11) && CGPDFScannerPopName(a1, (const char **)&value))
  {
    v4 = (CGPDFContentStream *)*((_QWORD *)a1 + 7);
    if (v4)
    {
      Resource = CGPDFContentStreamGetResource(v4, "Font", value);
      if (Resource)
      {
        if (*((_DWORD *)Resource + 2) == 8)
        {
          v6 = (const void *)*((_QWORD *)Resource + 4);
          if (v6)
          {
            v7 = (CPFont *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 2240), v6);
            if (!v7)
            {
              v7 = -[CPFont initWith:]([CPFont alloc], "initWith:", v6);
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 2240), v6, v7);
            }
            v8 = *(_QWORD *)(a2 + 40);
            v9 = v11;
            v10 = *(CPFont **)(v8 + 248);
            if (v10 != v7)
            {

              *(_QWORD *)(v8 + 248) = v7;
            }
            *(_QWORD *)(v8 + 216) = v9;
            *(_BYTE *)(v8 + 9) = 1;
          }
        }
        *(_BYTE *)(*(_QWORD *)(a2 + 40) + 9) = 1;
      }
    }
  }
}

void op_Tj_11051(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value;

  value = 0;
  if (CGPDFScannerPopString(a1, &value))
    ShowText(a2, (uint64_t)value);
}

void op_TJ_11053(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v3;
  size_t i;
  double v5;
  uint64_t *v6;
  CGPDFArrayRef value;

  value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (value)
    {
      v3 = *((_QWORD *)value + 2);
      if (v3)
      {
        for (i = 0; i != v3; ++i)
        {
          v6 = 0;
          if (CGPDFArrayGetObject(value, i, (CGPDFObjectRef *)&v6) && v6)
          {
            switch(*((_DWORD *)v6 + 2))
            {
              case 3:
              case 0xC:
                v5 = (double)v6[4];
                goto LABEL_10;
              case 4:
                v5 = *((double *)v6 + 4);
LABEL_10:
                AdjustPosition(a2, v5);
                break;
              case 6:
                ShowText(a2, v6[4]);
                break;
              default:
                continue;
            }
          }
        }
      }
    }
  }
}

BOOL op_TL_11055(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 208));
}

__n128 op_Tm_11057(CGPDFScanner *a1, uint64_t a2)
{
  __n128 result;
  uint64_t v5;

  *(CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 88) = CGAffineTransformIdentity;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 128))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 120))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 112))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 104))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 96))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 88)))
  {
    v5 = *(_QWORD *)(a2 + 40);
    *(_OWORD *)(v5 + 136) = *(_OWORD *)(v5 + 88);
    *(_OWORD *)(v5 + 152) = *(_OWORD *)(v5 + 104);
    result = *(__n128 *)(v5 + 120);
    *(__n128 *)(v5 + 168) = result;
    *(_BYTE *)(*(_QWORD *)(a2 + 40) + 9) = 1;
  }
  return result;
}

BOOL op_Tr_11059(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopInteger(a1, (CGPDFInteger *)(*(_QWORD *)(a2 + 40) + 224));
}

__n128 op_Tstar_11061(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float64x2_t v3;
  float64x2_t v4;
  double v5;
  float64x2_t v6;
  __n128 result;

  v2 = *(_QWORD *)(a2 + 40);
  v3 = *(float64x2_t *)(v2 + 136);
  v4 = *(float64x2_t *)(v2 + 152);
  v5 = *(double *)(v2 + 144) + vmuld_lane_f64(0.0, v4, 1);
  v6 = vaddq_f64(*(float64x2_t *)(v2 + 168), vmlaq_f64(vmulq_n_f64(v4, -*(double *)(v2 + 208)), (float64x2_t)0, v3));
  *(double *)(v2 + 88) = v3.f64[0] + 0.0 * v4.f64[0];
  *(double *)(v2 + 96) = v5;
  *(float64x2_t *)(v2 + 104) = vmlaq_f64(v4, (float64x2_t)0, v3);
  *(float64x2_t *)(v2 + 120) = v6;
  *(_OWORD *)(v2 + 152) = *(_OWORD *)(v2 + 104);
  *(_OWORD *)(v2 + 136) = *(_OWORD *)(v2 + 88);
  result = *(__n128 *)(v2 + 120);
  *(__n128 *)(v2 + 168) = result;
  return result;
}

BOOL op_Ts_11063(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 232));
}

BOOL op_Tw_11065(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 192));
}

BOOL op_Tz_11067(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 200));
}

void op_v_11069(CGPDFScanner *a1, uint64_t a2)
{
  CGPoint CurrentPoint;
  uint64_t v5;
  double v6;
  CGPDFReal v7;
  CGPDFReal value;
  CGPDFReal v9;

  value = 0.0;
  v9 = 0.0;
  v6 = 0.0;
  v7 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7)
    && !CGPathIsEmpty(*(CGPathRef *)(*(_QWORD *)(a2 + 40) + 64)))
  {
    CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*(_QWORD *)(*(_QWORD *)(a2 + 40) + 64));
    v5 = *(_QWORD *)(a2 + 40);
    CGPathAddCurveToPoint(*(CGMutablePathRef *)(v5 + 64), 0, CurrentPoint.x, CurrentPoint.y, *(double *)(v5 + 48) + v6 * *(double *)(v5 + 32) + *(double *)(v5 + 16) * v7, *(double *)(v5 + 56) + v6 * *(double *)(v5 + 40) + *(double *)(v5 + 24) * v7, *(double *)(v5 + 48) + *(double *)(v5 + 32) * value + *(double *)(v5 + 16) * v9, *(double *)(v5 + 56) + *(double *)(v5 + 40) * value + *(double *)(v5 + 24) * v9);
  }
}

uint64_t op_W_11071(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddClip(a2, 1);
}

BOOL op_w_11073(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL8 result;

  result = CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 296));
  if (result)
    *(_BYTE *)(*(_QWORD *)(a2 + 40) + 9) = 1;
  return result;
}

uint64_t op_Wstar_11075(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddClip(a2, 0);
}

void op_y_11077(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4;
  CGPDFReal v5;
  CGPDFReal value;
  CGPDFReal v7;

  value = 0.0;
  v7 = 0.0;
  v4 = 0.0;
  v5 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &v5)
    && !CGPathIsEmpty(*(CGPathRef *)(*(_QWORD *)(a2 + 40) + 64)))
  {
    CGPathAddCurveToPoint(*(CGMutablePathRef *)(*(_QWORD *)(a2 + 40) + 64), (const CGAffineTransform *)(*(_QWORD *)(a2 + 40) + 16), v5, v4, v7, value, v7, value);
  }
}

void op_quo_11079(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value;

  op_Tstar_11061((uint64_t)a1, a2);
  value = 0;
  if (CGPDFScannerPopString(a1, &value))
    ShowText(a2, (uint64_t)value);
}

void op_quoquo_11081(CGPDFScanner *a1, uint64_t a2)
{
  _BOOL4 v4;
  _BOOL8 v5;
  CGPDFStringRef value;

  value = 0;
  v4 = CGPDFScannerPopString(a1, &value);
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 184)))
  {
    v5 = CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(_QWORD *)(a2 + 40) + 192));
    if (v5 && v4)
    {
      op_Tstar_11061(v5, a2);
      ShowText(a2, (uint64_t)value);
    }
  }
}

CGColorSpaceRef CPPDFCreateColorSpace(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpaceRef v4;
  CGPDFContentStream *v5;
  CGPDFObjectRef Resource;
  CGColorSpace *v7;
  void *v8;
  CGColorSpaceRef v10;
  char *value;
  void *v12;

  value = 0;
  v4 = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    if (value)
    {
      v10 = 0;
      CreateColorSpaceFromName(value, &v10);
      v4 = v10;
      if (!v10)
      {
        v5 = (CGPDFContentStream *)*((_QWORD *)a1 + 7);
        if (v5 && (Resource = CGPDFContentStreamGetResource(v5, "ColorSpace", value)) != 0)
        {
          v7 = Resource;
          v8 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 2248), Resource);
          v12 = v8;
          if (v8)
          {
            v4 = (CGColorSpaceRef)v8;
            CFRetain(v8);
          }
          else
          {
            CreateColorSpaceFromObject(v7, (CGColorSpaceRef *)&v12);
            v4 = (CGColorSpaceRef)v12;
            if (v12)
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 2248), v7, v12);
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v4;
}

uint64_t path_add(unsigned __int8 **a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  uint64_t v15;
  unsigned __int8 *v16;

  if (!a1 || (v10 = *a1) == 0)
    _CGHandleAssert("path_add", 94, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path-internal.c", "pathp != NULL && *pathp != NULL", "Element type (%d) added to NULL path %p", a6, a7, a8, a2);
  if (a2 > 0xFFFFFFFD)
    return 0;
  if (a2 + 3 >= 8)
    abort();
  v12 = dword_184F7E9F0[a2 + 3];
  v13 = *((_QWORD *)v10 + 5);
  if ((a2 | 4) == 4)
  {
    v14 = (unsigned __int8 *)*((_QWORD *)v10 + 2);
    if (v14 < &v10[v13 + 48] && *v14 == a2)
      return *((_QWORD *)v10 + 4);
  }
  else
  {
    v14 = (unsigned __int8 *)*((_QWORD *)v10 + 2);
  }
  if (*((_QWORD *)v10 + 3) + 16 * v12 > (unint64_t)(v14 - 1))
  {
    if ((unint64_t)(2 * v13) >= 0x7D1)
      v15 = *((_QWORD *)v10 + 5);
    else
      v15 = 2 * v13;
    v16 = (unsigned __int8 *)malloc_type_malloc(v15 + 48, 0x65B64981uLL);
    *(_QWORD *)v16 = v10;
    *((_QWORD *)v16 + 1) = 0;
    *((_QWORD *)v16 + 2) = &v16[v15 + 48];
    *((_QWORD *)v16 + 3) = (unint64_t)(v16 + 55) & 0xFFFFFFFFFFFFFFF8;
    *((_QWORD *)v10 + 1) = v16;
    *((_QWORD *)v16 + 4) = *((_QWORD *)v10 + 4);
    *((_QWORD *)v16 + 5) = v15;
    *a1 = v16;
    v14 = (unsigned __int8 *)*((_QWORD *)v16 + 2);
    v10 = v16;
  }
  *((_QWORD *)v10 + 2) = v14 - 1;
  *(v14 - 1) = a2;
  result = *((_QWORD *)v10 + 3);
  *((_QWORD *)v10 + 3) = result + 16 * v12;
  if (!a2 || a2 == -3)
    *((_QWORD *)v10 + 4) = result;
  return result;
}

_QWORD *path_reset(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  char *v4;

  if (result)
  {
    v1 = result;
    result = (_QWORD *)*result;
    if (result)
    {
      v2 = (_QWORD *)*result;
      if (*result)
      {
        do
        {
          v3 = v2;
          free(result);
          v3[1] = 0;
          v2 = (_QWORD *)*v3;
          result = v3;
        }
        while (*v3);
      }
      else
      {
        v3 = result;
      }
      *v1 = v3;
      v4 = (char *)v3 + v3[5];
      v3[3] = ((unint64_t)v3 + 55) & 0xFFFFFFFFFFFFFFF8;
      v3[4] = 0;
      v3[2] = v4 + 48;
    }
  }
  return result;
}

void path_free(void *a1)
{
  void *v1;

  v1 = a1;
  if (a1)
  {
    path_reset(&v1);
    if (v1)
      free(v1);
  }
}

uint64_t path_element(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned __int8 *v5;
  _QWORD *v6;
  unsigned __int8 *v7;

  if (result)
  {
    v1 = *(_QWORD **)result;
    if (!*(_QWORD *)result)
    {
      *(_QWORD *)(result + 16) = 0;
      *(_QWORD *)(result + 24) = 0;
      *(_DWORD *)(result + 8) = 4;
      return 0;
    }
    v2 = *(_QWORD *)(result + 24);
    if (v2 && (v3 = *(_QWORD *)(result + 16)) != 0)
    {
      v4 = *(_DWORD *)(result + 8) + 3;
      if (v4 >= 8)
        abort();
      v5 = (unsigned __int8 *)(v2 - 1);
      *(_QWORD *)(result + 16) = v3 + 16 * dword_184F7E9F0[v4];
      *(_QWORD *)(result + 24) = v5;
      if ((unint64_t)v5 >= v1[2])
      {
        *(_DWORD *)(result + 8) = *v5;
        return result;
      }
      v6 = (_QWORD *)v1[1];
      *(_QWORD *)result = v6;
      if (!v6)
      {
        *(_DWORD *)(result + 8) = 4;
        *(_QWORD *)(result + 16) = 0;
        *(_QWORD *)(result + 24) = 0;
        return 0;
      }
    }
    else
    {
      do
      {
        v6 = v1;
        v1 = (_QWORD *)*v1;
      }
      while (v1);
    }
    v7 = (unsigned __int8 *)v6 + v6[5] + 47;
    *(_QWORD *)(result + 24) = v7;
    if ((unint64_t)v7 < v6[2])
    {
      *(_QWORD *)result = 0;
      *(_DWORD *)(result + 8) = 4;
      *(_QWORD *)(result + 16) = 0;
      *(_QWORD *)(result + 24) = 0;
      return 0;
    }
    *(_QWORD *)result = v6;
    *(_DWORD *)(result + 8) = *v7;
    *(_QWORD *)(result + 16) = ((unint64_t)v6 + 55) & 0xFFFFFFFFFFFFFFF8;
  }
  return result;
}

_QWORD *path_iterator_iterate(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  void (*v3)(_QWORD, _QWORD, _QWORD);
  uint64_t (*v4)(_QWORD, _QWORD);
  _QWORD v5[4];

  if (result && a2)
  {
    v2 = result;
    v5[0] = a2;
    v5[1] = 4;
    v5[2] = 0;
    v5[3] = 0;
    v3 = (void (*)(_QWORD, _QWORD, _QWORD))result[2];
    if (v3)
      v3(result[1], 0, result[6]);
    while (1)
    {
      result = (_QWORD *)path_element((uint64_t)v5);
      if (!result)
        break;
      ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD))v2[3])(v2[1], *((unsigned int *)result + 2), result[2], v2[6]);
    }
    v4 = (uint64_t (*)(_QWORD, _QWORD))v2[4];
    if (v4)
      return (_QWORD *)v4(v2[1], v2[6]);
  }
  return result;
}

_QWORD *path_iterator_unrollpath(_QWORD *result, unsigned __int8 **a2)
{
  unsigned __int8 *v3;
  _QWORD *v4;
  unsigned __int8 *v5;
  uint64_t v6;

  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      v4 = result;
      do
      {
        while (1)
        {
          v5 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
          if (v5 >= &v3[*((_QWORD *)v3 + 5) + 48])
            break;
          *((_QWORD *)v3 + 2) = v5 + 1;
          v6 = *v5;
          if (v6 >= 5)
            abort();
          *((_QWORD *)v3 + 3) -= 16 * dword_184F7E9F0[v6 + 3];
          ((void (*)(_QWORD))v4[3])(v4[1]);
        }
        v3 = *(unsigned __int8 **)v3;
      }
      while (v3);
      return path_reset(a2);
    }
  }
  return result;
}

uint64_t ___ZL24CGPDFPageLayoutGetTypeIDv_block_invoke()
{
  uint64_t result;

  result = pdf_register_cftype((uint64_t)&CGPDFPageLayoutGetTypeID(void)::CGPDFPageLayoutType);
  CGPDFPageLayoutGetTypeID(void)::typeID = result;
  return result;
}

void CGPDFPageLayoutFinalize(char *a1)
{
  PageLayout::~PageLayout((PageLayout *)(a1 + 16));
}

void PageLayout::~PageLayout(PageLayout *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void **v16;

  v2 = (void *)*((_QWORD *)this + 57);
  if (v2)
  {
    *((_QWORD *)this + 58) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 54);
  if (v3)
  {
    *((_QWORD *)this + 55) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 51);
  if (v4)
  {
    *((_QWORD *)this + 52) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 48);
  if (v5)
  {
    *((_QWORD *)this + 49) = v5;
    operator delete(v5);
  }
  std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table((uint64_t)this + 336);

  v6 = (void *)*((_QWORD *)this + 37);
  if (v6)
  {
    *((_QWORD *)this + 38) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 34);
  if (v7)
  {
    *((_QWORD *)this + 35) = v7;
    operator delete(v7);
  }
  v16 = (void **)((char *)this + 248);
  std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:se180100](&v16);
  v8 = (void *)*((_QWORD *)this + 28);
  if (v8)
  {
    *((_QWORD *)this + 29) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 25);
  if (v9)
  {
    *((_QWORD *)this + 26) = v9;
    operator delete(v9);
  }
  v16 = (void **)((char *)this + 176);
  std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:se180100](&v16);
  v10 = (void *)*((_QWORD *)this + 19);
  if (v10)
  {
    *((_QWORD *)this + 20) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 16);
  if (v11)
  {
    *((_QWORD *)this + 17) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 13);
  if (v12)
  {
    *((_QWORD *)this + 14) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 10);
  if (v13)
  {
    *((_QWORD *)this + 11) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 7);
  if (v14)
  {
    *((_QWORD *)this + 8) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 4);
  if (v15)
  {
    *((_QWORD *)this + 5) = v15;
    operator delete(v15);
  }

}

CFTypeRef CGPDFPageLayoutRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void CGPDFPageLayoutRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGPDFPageLayoutEqualToPageLayout(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  const void *v9;
  size_t v10;
  const void *v11;
  const void *v12;
  size_t v13;
  const void *v14;
  CGRect *v15;
  CGRect *v16;
  CGRect *v17;
  CGRect *v18;
  CGRect *v19;
  CGRect *v20;
  const void *v21;
  size_t v22;
  const void *v23;
  const void *v24;
  size_t v25;
  const void *v26;
  double *v27;
  double *v28;
  double *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 **v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  uint64_t v38;
  uint64_t v39;
  _BOOL4 v40;
  BOOL v41;
  const void *v43;
  size_t v44;
  const void *v45;
  const void *v46;
  size_t v47;
  const void *v48;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    if (*(unsigned __int8 *)(a1 + 24) != *(unsigned __int8 *)(a2 + 24))
      return 0;
    result = objc_msgSend(*(id *)(a1 + 40), "isEqualToString:", *(_QWORD *)(a2 + 40));
    if (!(_DWORD)result)
      return result;
    v6 = *(_QWORD *)(a1 + 48);
    v5 = *(_QWORD *)(a1 + 56);
    v7 = *(_QWORD *)(a2 + 48);
    if (v5 - v6 != *(_QWORD *)(a2 + 56) - v7)
      return 0;
    for (; v6 != v5; v7 += 72)
    {
      v8 = *(_QWORD *)v6 == *(_QWORD *)v7 && *(_QWORD *)(v6 + 8) == *(_QWORD *)(v7 + 8);
      if (!v8 || *(_QWORD *)(v6 + 16) != *(_QWORD *)(v7 + 16))
        return 0;
      result = CGRectEqualToRect(*(CGRect *)(v6 + 24), *(CGRect *)(v7 + 24));
      if (!(_DWORD)result)
        return result;
      if (vabdd_f64(*(double *)(v6 + 56), *(double *)(v7 + 56)) > 0.00000011920929)
        return 0;
      v6 += 72;
    }
    v9 = *(const void **)(a1 + 72);
    v10 = *(_QWORD *)(a1 + 80) - (_QWORD)v9;
    v11 = *(const void **)(a2 + 72);
    if (v10 != *(_QWORD *)(a2 + 80) - (_QWORD)v11)
      return 0;
    if (memcmp(v9, v11, v10))
      return 0;
    v12 = *(const void **)(a1 + 96);
    v13 = *(_QWORD *)(a1 + 104) - (_QWORD)v12;
    v14 = *(const void **)(a2 + 96);
    if (v13 != *(_QWORD *)(a2 + 104) - (_QWORD)v14)
      return 0;
    if (memcmp(v12, v14, v13))
      return 0;
    v15 = *(CGRect **)(a1 + 120);
    v16 = *(CGRect **)(a1 + 128);
    v17 = *(CGRect **)(a2 + 120);
    if ((char *)v16 - (char *)v15 != *(_QWORD *)(a2 + 128) - (_QWORD)v17)
      return 0;
    while (v15 != v16)
    {
      result = std::__equal_to::operator()[abi:se180100]<CGRect,CGRect>(v15, v17);
      if (!(_DWORD)result)
        return result;
      ++v15;
      ++v17;
    }
    v18 = *(CGRect **)(a1 + 144);
    v19 = *(CGRect **)(a1 + 152);
    v20 = *(CGRect **)(a2 + 144);
    if ((char *)v19 - (char *)v18 != *(_QWORD *)(a2 + 152) - (_QWORD)v20)
      return 0;
    if (v18 == v19)
      goto LABEL_31;
    do
    {
      result = std::__equal_to::operator()[abi:se180100]<CGRect,CGRect>(v18, v20);
      if (!(_DWORD)result)
        break;
      ++v18;
      ++v20;
    }
    while (v18 != v19);
    if ((_DWORD)result)
    {
LABEL_31:
      v21 = *(const void **)(a1 + 168);
      v22 = *(_QWORD *)(a1 + 176) - (_QWORD)v21;
      v23 = *(const void **)(a2 + 168);
      if (v22 == *(_QWORD *)(a2 + 176) - (_QWORD)v23 && !memcmp(v21, v23, v22))
      {
        v24 = *(const void **)(a1 + 216);
        v25 = *(_QWORD *)(a1 + 224) - (_QWORD)v24;
        v26 = *(const void **)(a2 + 216);
        if (v25 == *(_QWORD *)(a2 + 224) - (_QWORD)v26 && !memcmp(v24, v26, v25))
        {
          v28 = *(double **)(a1 + 240);
          v27 = *(double **)(a1 + 248);
          v29 = *(double **)(a2 + 240);
          if ((char *)v27 - (char *)v28 == *(_QWORD *)(a2 + 248) - (_QWORD)v29)
          {
            while (v28 != v27)
            {
              if (*v28 != *v29)
                return 0;
              ++v28;
              ++v29;
            }
            v31 = *(_QWORD *)(a1 + 264);
            v30 = *(_QWORD *)(a1 + 272);
            v32 = *(unsigned __int8 ***)(a2 + 264);
            if (v30 - v31 == *(_QWORD *)(a2 + 272) - (_QWORD)v32)
            {
              if (v31 == v30)
              {
LABEL_69:
                v43 = *(const void **)(a1 + 288);
                v44 = *(_QWORD *)(a1 + 296) - (_QWORD)v43;
                v45 = *(const void **)(a2 + 288);
                if (v44 == *(_QWORD *)(a2 + 296) - (_QWORD)v45 && !memcmp(v43, v45, v44))
                {
                  v46 = *(const void **)(a1 + 312);
                  v47 = *(_QWORD *)(a1 + 320) - (_QWORD)v46;
                  v48 = *(const void **)(a2 + 312);
                  if (v47 == *(_QWORD *)(a2 + 320) - (_QWORD)v48)
                    return memcmp(v46, v48, v47) == 0;
                }
              }
              else
              {
                while (1)
                {
                  v33 = *(unsigned __int8 *)(v31 + 23);
                  if ((v33 & 0x80u) == 0)
                    v34 = (unsigned __int8 *)*(unsigned __int8 *)(v31 + 23);
                  else
                    v34 = *(unsigned __int8 **)(v31 + 8);
                  v35 = (unsigned __int8 *)*((unsigned __int8 *)v32 + 23);
                  v36 = (char)v35;
                  if ((char)v35 < 0)
                    v35 = v32[1];
                  if (v34 != v35)
                    break;
                  if (v36 >= 0)
                    v37 = (unsigned __int8 *)v32;
                  else
                    v37 = *v32;
                  if ((v33 & 0x80) != 0)
                  {
                    v40 = memcmp(*(const void **)v31, v37, *(_QWORD *)(v31 + 8)) == 0;
                  }
                  else if (*(_BYTE *)(v31 + 23))
                  {
                    v38 = 0;
                    v39 = v33 - 1;
                    do
                    {
                      v40 = *(unsigned __int8 *)(v31 + v38) == v37[v38];
                      v41 = *(unsigned __int8 *)(v31 + v38) != v37[v38] || v39 == v38;
                      ++v38;
                    }
                    while (!v41);
                  }
                  else
                  {
                    v40 = 1;
                  }
                  if (*(_DWORD *)(v31 + 24) != *((_DWORD *)v32 + 6))
                    v40 = 0;
                  v31 += 32;
                  v32 += 4;
                  if (!v40 || v31 == v30)
                  {
                    if (!v40)
                      return 0;
                    goto LABEL_69;
                  }
                }
              }
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

void CGPDFPageLayoutCreateEncodedData(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  double *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void ***v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void ***v32;
  char v33;
  char v34;
  void **v35;
  void **v36;
  void **v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  int64x2_t v51;
  void **v52;
  unint64_t v53;
  unsigned __int16 *v54;
  unsigned __int16 *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t i;
  uint64_t v60;
  uint64_t v61;
  uint64_t j;
  uint64_t v63;
  _QWORD *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  float v72;
  _QWORD *v73;
  CGColorSpaceRef *v74;
  __CFDictionary *v75;
  const __CFData *Data;
  void ***v77;
  void ***v78;
  const unsigned __int8 *BytePtr;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  char v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  void ***v89;
  PB::Data *v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  char *v98;
  uint64_t *v99;
  uint64_t v100;
  void ***v101;
  _QWORD *v102;
  _QWORD *v103;
  uint64_t v104;
  char *v105;
  char *v106;
  uint64_t v107;
  char *v108;
  char *v109;
  char *v110;
  char *v111;
  int v112;
  double *v113;
  double *v114;
  float *v115;
  float v116;
  uint64_t v117;
  unint64_t v118;
  unint64_t v119;
  char *v120;
  uint64_t v121;
  float *v122;
  char *v123;
  char *v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  std::string *v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  std::string *v136;
  std::string *v137;
  __int128 v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  unint64_t v145;
  char *v146;
  uint64_t *v147;
  uint64_t v148;
  uint64_t v149;
  const __CFAllocator *allocator;
  CGColorSpace *cf;
  uint64_t v152;
  void (**v153)(PBPageLayoutPkg::PBPageLayout *__hidden);
  __int128 v154;
  _OWORD v155[2];
  _OWORD v156[3];
  std::vector<unsigned int> v157[2];
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  _QWORD v163[6];
  int64x2_t v164;
  unint64_t v165;
  char v166;
  int v167;
  void **v168;
  _BYTE v169[32];
  char *v170;
  int v171;
  void (**v172)(PBPageLayoutPkg::PBTextLine *__hidden);
  void ***v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  int v177;

  if (a1)
  {
    v1 = a1;
    v153 = &off_1E1628DD0;
    v167 = 1;
    v164 = 0u;
    v154 = 0u;
    memset(v155, 0, sizeof(v155));
    memset(v156, 0, sizeof(v156));
    memset(v157, 0, sizeof(v157));
    v158 = 0u;
    v159 = 0u;
    v160 = 0u;
    v161 = 0u;
    v162 = 0u;
    memset(v163, 0, sizeof(v163));
    v165 = 0;
    v166 = *(_BYTE *)(a1 + 24);
    v2 = (char *)objc_msgSend(*(id *)(a1 + 40), "UTF8String");
    v3 = strlen(v2);
    std::string::basic_string[abi:se180100](v169, v2, v3);
    v4 = operator new();
    *(_QWORD *)v4 = 0;
    *(_QWORD *)(v4 + 8) = 0;
    *(_QWORD *)(v4 + 16) = 0;
    v5 = *((_QWORD *)&v162 + 1);
    *((_QWORD *)&v162 + 1) = v4;
    if (v5)
    {
      std::default_delete<std::string>::operator()[abi:se180100](v5);
      v4 = *((_QWORD *)&v162 + 1);
    }
    if (*(char *)(v4 + 23) < 0)
      operator delete(*(void **)v4);
    v6 = *(_OWORD *)v169;
    *(_QWORD *)(v4 + 16) = *(_QWORD *)&v169[16];
    *(_OWORD *)v4 = v6;
    v7 = *(double **)(v1 + 48);
    v8 = *(uint64_t **)(v1 + 56);
    v152 = v1;
    if (v7 != (double *)v8)
    {
      while (1)
      {
        v172 = &off_1E1628D98;
        v177 = 0;
        v173 = 0;
        v174 = 0;
        v9 = operator new();
        *(_QWORD *)v9 = &off_1E1628EE8;
        *(_DWORD *)(v9 + 24) = 0;
        v10 = v174;
        v174 = v9;
        if (v10)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
          v9 = v174;
        }
        v11 = *v7;
        v12 = *(_BYTE *)(v9 + 24);
        *(_BYTE *)(v9 + 24) = v12 | 2;
        *(double *)(v9 + 16) = v11;
        v13 = *((_QWORD *)v7 + 1);
        *(_BYTE *)(v9 + 24) = v12 | 3;
        *(_QWORD *)(v9 + 8) = v13;
        v14 = *((_QWORD *)v7 + 2);
        LOBYTE(v177) = v177 | 1;
        v175 = v14;
        v15 = (uint64_t)v173;
        if (!v173)
        {
          v15 = operator new();
          *(_QWORD *)v15 = &off_1E1628E78;
          *(_DWORD *)(v15 + 40) = 0;
          v16 = v173;
          v173 = (void ***)v15;
          if (v16)
          {
            ((void (*)(void ***))(*v16)[1])(v16);
            v15 = (uint64_t)v173;
          }
        }
        v17 = *((_QWORD *)v7 + 3);
        v18 = *(_BYTE *)(v15 + 40);
        *(_BYTE *)(v15 + 40) = v18 | 2;
        *(_QWORD *)(v15 + 16) = v17;
        v19 = *((_QWORD *)v7 + 4);
        *(_BYTE *)(v15 + 40) = v18 | 6;
        *(_QWORD *)(v15 + 24) = v19;
        v20 = *((_QWORD *)v7 + 5);
        *(_BYTE *)(v15 + 40) = v18 | 0xE;
        *(_QWORD *)(v15 + 32) = v20;
        v21 = *((_QWORD *)v7 + 6);
        *(_BYTE *)(v15 + 40) = v18 | 0xF;
        *(_QWORD *)(v15 + 8) = v21;
        *(float *)&v21 = v7[7];
        LOBYTE(v177) = v177 | 2;
        v176 = v21;
        v22 = operator new();
        *(_QWORD *)v22 = &off_1E1628D98;
        *(_QWORD *)(v22 + 8) = 0;
        v23 = (uint64_t *)(v22 + 8);
        *(_DWORD *)(v22 + 36) = 0;
        *(_QWORD *)(v22 + 16) = 0;
        if (v174)
          break;
LABEL_20:
        if ((v177 & 1) != 0)
        {
          v30 = v175;
          *(_BYTE *)(v22 + 36) |= 1u;
          *(_QWORD *)(v22 + 24) = v30;
        }
        if (v173)
        {
          v31 = operator new();
          v32 = v173;
          *(_QWORD *)v31 = &off_1E1628E78;
          *(_DWORD *)(v31 + 40) = 0;
          v33 = *((_BYTE *)v32 + 40);
          if ((v33 & 2) != 0)
          {
            v35 = v32[2];
            v34 = 2;
            *(_BYTE *)(v31 + 40) = 2;
            *(_QWORD *)(v31 + 16) = v35;
            v33 = *((_BYTE *)v32 + 40);
            if ((v33 & 4) == 0)
              goto LABEL_28;
          }
          else
          {
            v34 = 0;
            if (((_BYTE)v32[5] & 4) == 0)
            {
LABEL_28:
              if ((v33 & 8) != 0)
              {
                v52 = v32[4];
                v34 |= 8u;
                *(_BYTE *)(v31 + 40) = v34;
                *(_QWORD *)(v31 + 32) = v52;
                if (((_BYTE)v32[5] & 1) != 0)
                {
LABEL_30:
                  v37 = v32[1];
                  *(_BYTE *)(v31 + 40) = v34 | 1;
                  *(_QWORD *)(v31 + 8) = v37;
                }
              }
              else if ((v33 & 1) != 0)
              {
                goto LABEL_30;
              }
              v38 = *v23;
              *v23 = v31;
              if (v38)
                (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
              goto LABEL_33;
            }
          }
          v36 = v32[3];
          v34 |= 4u;
          *(_BYTE *)(v31 + 40) = v34;
          *(_QWORD *)(v31 + 24) = v36;
          v33 = *((_BYTE *)v32 + 40);
          goto LABEL_28;
        }
LABEL_33:
        if ((v177 & 2) != 0)
        {
          v39 = v176;
          *(_BYTE *)(v22 + 36) |= 2u;
          *(_DWORD *)(v22 + 32) = v39;
        }
        v40 = v164.i64[1];
        if (v164.i64[1] >= v165)
        {
          v42 = (v164.i64[1] - v164.i64[0]) >> 3;
          if ((unint64_t)(v42 + 1) >> 61)
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
          v43 = (uint64_t)(v165 - v164.i64[0]) >> 2;
          if (v43 <= v42 + 1)
            v43 = v42 + 1;
          if (v165 - v164.i64[0] >= 0x7FFFFFFFFFFFFFF8)
            v44 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v44 = v43;
          v170 = (char *)&v165;
          if (!v44
            || (v45 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v44),
                v46 = (uint64_t *)&v45[8 * v42],
                *(_QWORD *)v169 = v45,
                *(_QWORD *)&v169[8] = v46,
                *(_QWORD *)&v169[24] = &v45[8 * v47],
                !v45))
          {
LABEL_179:
            __break(1u);
            return;
          }
          *v46 = v22;
          v41 = v46 + 1;
          *(_QWORD *)&v169[16] = v46 + 1;
          v48 = (_QWORD *)v164.i64[1];
          v49 = (_QWORD *)v164.i64[0];
          if (v164.i64[1] == v164.i64[0])
          {
            v51 = vdupq_n_s64(v164.u64[1]);
          }
          else
          {
            do
            {
              v50 = *--v48;
              *v48 = 0;
              *--v46 = v50;
            }
            while (v48 != v49);
            v51 = v164;
            v41 = *(_QWORD **)&v169[16];
          }
          v164.i64[0] = (uint64_t)v46;
          v164.i64[1] = (uint64_t)v41;
          *(int64x2_t *)&v169[8] = v51;
          v53 = v165;
          v165 = *(_QWORD *)&v169[24];
          *(_QWORD *)&v169[24] = v53;
          *(_QWORD *)v169 = v51.i64[0];
          std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v169);
        }
        else
        {
          if (!v164.i64[1])
            goto LABEL_179;
          *(_QWORD *)v164.i64[1] = v22;
          v41 = (_QWORD *)(v40 + 8);
        }
        v164.i64[1] = (uint64_t)v41;
        PBPageLayoutPkg::PBTextLine::~PBTextLine((PBPageLayoutPkg::PBTextLine *)&v172);
        v7 += 9;
        v1 = v152;
        if (v7 == (double *)v8)
          goto LABEL_54;
      }
      v24 = operator new();
      v25 = v174;
      *(_QWORD *)v24 = &off_1E1628EE8;
      *(_DWORD *)(v24 + 24) = 0;
      if ((*(_BYTE *)(v25 + 24) & 2) != 0)
      {
        v27 = *(_QWORD *)(v25 + 16);
        *(_BYTE *)(v24 + 24) = 2;
        *(_QWORD *)(v24 + 16) = v27;
        v26 = 3;
        if ((*(_BYTE *)(v25 + 24) & 1) == 0)
          goto LABEL_18;
      }
      else
      {
        v26 = 1;
        if ((*(_BYTE *)(v25 + 24) & 1) == 0)
        {
LABEL_18:
          v29 = *(_QWORD *)(v22 + 16);
          *(_QWORD *)(v22 + 16) = v24;
          if (v29)
            (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
          goto LABEL_20;
        }
      }
      v28 = *(_QWORD *)(v25 + 8);
      *(_BYTE *)(v24 + 24) = v26;
      *(_QWORD *)(v24 + 8) = v28;
      goto LABEL_18;
    }
LABEL_54:
    std::vector<unsigned int>::reserve((std::vector<unsigned int> *)&v158, (uint64_t)(*(_QWORD *)(v1 + 80) - *(_QWORD *)(v1 + 72)) >> 1);
    v54 = *(unsigned __int16 **)(v1 + 72);
    v55 = *(unsigned __int16 **)(v1 + 80);
    *(_QWORD *)v169 = &v158;
    while (v54 != v55)
    {
      LODWORD(v172) = *v54;
      std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:se180100]((void ***)v169, &v172);
      ++v54;
    }
    std::vector<unsigned int>::reserve(&v157[1], (uint64_t)(*(_QWORD *)(v1 + 104) - *(_QWORD *)(v1 + 96)) >> 3);
    v56 = *(_QWORD **)(v1 + 96);
    v57 = *(_QWORD **)(v1 + 104);
    *(_QWORD *)v169 = &v157[1];
    while (v56 != v57)
    {
      LODWORD(v172) = *v56;
      std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:se180100]((void ***)v169, &v172);
      ++v56;
    }
    std::vector<std::unique_ptr<PBPageLayoutPkg::PBRect>>::reserve(&v163[3], (uint64_t)(*(_QWORD *)(v1 + 128) - *(_QWORD *)(v1 + 120)) >> 5);
    v58 = *(_QWORD *)(v1 + 120);
    for (i = *(_QWORD *)(v1 + 128); v58 != i; v58 += 32)
    {
      *(_QWORD *)v169 = &off_1E1628E78;
      v171 = 0;
      *(_OWORD *)&v169[16] = *(_OWORD *)v58;
      v170 = *(char **)(v58 + 16);
      v60 = *(_QWORD *)(v58 + 24);
      LOBYTE(v171) = 15;
      *(_QWORD *)&v169[8] = v60;
      PB::PtrVector<PBPageLayoutPkg::PBRect>::emplace_back<PBPageLayoutPkg::PBRect>(&v163[3], (uint64_t)v169);
      PB::Base::~Base((PB::Base *)v169);
    }
    std::vector<std::unique_ptr<PBPageLayoutPkg::PBRect>>::reserve(v163, (uint64_t)(*(_QWORD *)(v1 + 152) - *(_QWORD *)(v1 + 144)) >> 5);
    v61 = *(_QWORD *)(v1 + 144);
    for (j = *(_QWORD *)(v1 + 152); v61 != j; v61 += 32)
    {
      *(_QWORD *)v169 = &off_1E1628E78;
      v171 = 0;
      *(_OWORD *)&v169[16] = *(_OWORD *)v61;
      v170 = *(char **)(v61 + 16);
      v63 = *(_QWORD *)(v61 + 24);
      LOBYTE(v171) = 15;
      *(_QWORD *)&v169[8] = v63;
      PB::PtrVector<PBPageLayoutPkg::PBRect>::emplace_back<PBPageLayoutPkg::PBRect>(v163, (uint64_t)v169);
      PB::Base::~Base((PB::Base *)v169);
    }
    std::vector<unsigned int>::reserve(v157, (uint64_t)(*(_QWORD *)(v1 + 176) - *(_QWORD *)(v1 + 168)) >> 3);
    v64 = *(_QWORD **)(v1 + 168);
    v65 = *(_QWORD **)(v1 + 176);
    *(_QWORD *)v169 = v157;
    while (v64 != v65)
    {
      LODWORD(v172) = *v64;
      std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:se180100]((void ***)v169, &v172);
      ++v64;
    }
    v67 = *(_QWORD *)(v1 + 192);
    v66 = *(_QWORD *)(v1 + 200);
    v68 = 0xAAAAAAAAAAAAAAABLL * ((v66 - v67) >> 3);
    v69 = v161;
    if (v68 > (uint64_t)(v162 - v161) >> 3)
    {
      if (v68 >> 61)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v70 = *((_QWORD *)&v161 + 1);
      v170 = (char *)&v162;
      *(_QWORD *)v169 = std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v68);
      *(_QWORD *)&v169[8] = *(_QWORD *)v169 + v70 - v69;
      *(_QWORD *)&v169[16] = *(_QWORD *)&v169[8];
      *(_QWORD *)&v169[24] = *(_QWORD *)v169 + 8 * v71;
      std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(&v161, v169);
      std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v169);
      v67 = *(_QWORD *)(v1 + 192);
      v66 = *(_QWORD *)(v1 + 200);
    }
    if (v67 != v66)
    {
      v149 = v66;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      while (1)
      {
        v172 = &off_1E1628E08;
        v173 = 0;
        v176 = 0;
        v174 = *(_QWORD *)v67;
        v72 = *(double *)(v67 + 8);
        LOBYTE(v176) = 5;
        *((float *)&v175 + 1) = v72;
        cf = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceSRGB"));
        v73 = (_QWORD *)color_transform_create(cf, 0);
        v74 = (CGColorSpaceRef *)CGColorTransformConvertColor(v73, *(_QWORD *)(v67 + 16), 3);
        v75 = CGColorCopyPropertyList(v74);
        Data = CFPropertyListCreateData(allocator, v75, kCFPropertyListBinaryFormat_v1_0, 0, 0);
        if (!v173)
        {
          v77 = (void ***)operator new();
          *v77 = (void **)&off_1E1628EB0;
          v77[1] = 0;
          v78 = v173;
          v173 = v77;
          if (v78)
            ((void (*)(void ***))(*v78)[1])(v78);
        }
        BytePtr = CFDataGetBytePtr(Data);
        CFDataGetLength(Data);
        PB::Data::Data((PB::Data *)v169, BytePtr);
        v80 = operator new();
        v81 = *(_QWORD *)&v169[8];
        *(_QWORD *)v80 = *(_QWORD *)v169;
        *(_QWORD *)(v80 + 8) = v81;
        *(_OWORD *)v169 = 0uLL;
        v168 = 0;
        std::unique_ptr<PB::Data>::reset[abi:se180100](v173 + 1, (void **)v80);
        std::unique_ptr<PB::Data>::reset[abi:se180100](&v168, 0);
        free(*(void **)v169);
        v82 = operator new();
        v83 = v82;
        *(_QWORD *)v82 = &off_1E1628E08;
        *(_QWORD *)(v82 + 8) = 0;
        *(_DWORD *)(v82 + 32) = 0;
        v84 = v176;
        if ((v176 & 1) != 0)
          break;
        v85 = 4;
        if ((v176 & 4) != 0)
          goto LABEL_79;
LABEL_80:
        if (v173)
        {
          v88 = operator new();
          v89 = v173;
          *(_QWORD *)v88 = &off_1E1628EB0;
          *(_QWORD *)(v88 + 8) = 0;
          if (v89[1])
          {
            v90 = (PB::Data *)operator new();
            PB::Data::Data(v90, (const PB::Data *)v89[1]);
            *(_QWORD *)v169 = 0;
            std::unique_ptr<PB::Data>::reset[abi:se180100]((void ***)(v88 + 8), (void **)v90);
            std::unique_ptr<PB::Data>::reset[abi:se180100]((void ***)v169, 0);
          }
          v91 = *(_QWORD *)(v83 + 8);
          *(_QWORD *)(v83 + 8) = v88;
          if (v91)
            (*(void (**)(uint64_t))(*(_QWORD *)v91 + 8))(v91);
        }
        if ((v176 & 2) != 0)
        {
          v92 = v175;
          *(_BYTE *)(v83 + 32) |= 2u;
          *(_DWORD *)(v83 + 24) = v92;
        }
        v93 = *((_QWORD *)&v161 + 1);
        if (*((_QWORD *)&v161 + 1) >= (unint64_t)v162)
        {
          v95 = (uint64_t)(*((_QWORD *)&v161 + 1) - v161) >> 3;
          if ((unint64_t)(v95 + 1) >> 61)
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
          v96 = (uint64_t)(v162 - v161) >> 2;
          if (v96 <= v95 + 1)
            v96 = v95 + 1;
          if ((_QWORD)v162 - (_QWORD)v161 >= 0x7FFFFFFFFFFFFFF8uLL)
            v97 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v97 = v96;
          v170 = (char *)&v162;
          if (!v97)
            goto LABEL_179;
          v98 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v97);
          v99 = (uint64_t *)&v98[8 * v95];
          *(_QWORD *)v169 = v98;
          *(_QWORD *)&v169[8] = v99;
          *(_QWORD *)&v169[24] = &v98[8 * v100];
          if (!v98)
            goto LABEL_179;
          *v99 = v83;
          *(_QWORD *)&v169[16] = v99 + 1;
          std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(&v161, v169);
          v94 = *((_QWORD *)&v161 + 1);
          std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v169);
        }
        else
        {
          if (!*((_QWORD *)&v161 + 1))
            goto LABEL_179;
          **((_QWORD **)&v161 + 1) = v83;
          v94 = v93 + 8;
        }
        *((_QWORD *)&v161 + 1) = v94;
        v1 = v152;
        if (Data)
          CFRelease(Data);
        if (v75)
          CFRelease(v75);
        if (v74)
          CFRelease(v74);
        if (v73)
          CFRelease(v73);
        if (cf)
          CFRelease(cf);
        v101 = v173;
        v172 = &off_1E1628E08;
        v173 = 0;
        if (v101)
          ((void (*)(void ***))(*v101)[1])(v101);
        PB::Base::~Base((PB::Base *)&v172);
        v67 += 24;
        if (v67 == v149)
          goto LABEL_112;
      }
      v86 = v174;
      *(_BYTE *)(v82 + 32) = 1;
      *(_QWORD *)(v82 + 16) = v86;
      v85 = 5;
      if ((v84 & 4) == 0)
        goto LABEL_80;
LABEL_79:
      v87 = HIDWORD(v175);
      *(_BYTE *)(v82 + 32) = v85;
      *(_DWORD *)(v82 + 28) = v87;
      goto LABEL_80;
    }
LABEL_112:
    std::vector<unsigned int>::reserve((std::vector<unsigned int> *)((char *)v155 + 8), (uint64_t)(*(_QWORD *)(v1 + 224) - *(_QWORD *)(v1 + 216)) >> 3);
    v102 = *(_QWORD **)(v1 + 216);
    v103 = *(_QWORD **)(v1 + 224);
    *(_QWORD *)v169 = (char *)v155 + 8;
    while (v102 != v103)
    {
      LODWORD(v172) = *v102;
      std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:se180100]((void ***)v169, &v172);
      ++v102;
    }
    v104 = *(_QWORD *)(v1 + 248) - *(_QWORD *)(v1 + 240);
    if (v104 >> 3 > (unint64_t)((uint64_t)(*(_QWORD *)&v155[0] - v154) >> 2))
    {
      if (v104 < 0)
LABEL_173:
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v105 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<float>>(v104 >> 3);
      v106 = &v105[(*((_QWORD *)&v154 + 1) - v154) & 0xFFFFFFFFFFFFFFFCLL];
      v108 = &v105[4 * v107];
      v110 = (char *)*((_QWORD *)&v154 + 1);
      v109 = (char *)v154;
      v111 = v106;
      if (*((_QWORD *)&v154 + 1) != (_QWORD)v154)
      {
        v111 = v106;
        do
        {
          v112 = *((_DWORD *)v110 - 1);
          v110 -= 4;
          *((_DWORD *)v111 - 1) = v112;
          v111 -= 4;
        }
        while (v110 != v109);
      }
      *(_QWORD *)&v154 = v111;
      *((_QWORD *)&v154 + 1) = v106;
      *(_QWORD *)&v155[0] = v108;
      if (v109)
        operator delete(v109);
    }
    v113 = *(double **)(v1 + 240);
    v114 = *(double **)(v1 + 248);
    if (v113 != v114)
    {
      v115 = (float *)*((_QWORD *)&v154 + 1);
      do
      {
        v116 = *v113;
        if ((unint64_t)v115 >= *(_QWORD *)&v155[0])
        {
          v117 = (uint64_t)((uint64_t)v115 - v154) >> 2;
          if ((unint64_t)(v117 + 1) >> 62)
            goto LABEL_173;
          v118 = (uint64_t)(*(_QWORD *)&v155[0] - v154) >> 1;
          if (v118 <= v117 + 1)
            v118 = v117 + 1;
          if (*(_QWORD *)&v155[0] - (_QWORD)v154 >= 0x7FFFFFFFFFFFFFFCuLL)
            v119 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v119 = v118;
          if (!v119)
            goto LABEL_179;
          v120 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<float>>(v119);
          if (!v120)
            goto LABEL_179;
          v122 = (float *)&v120[4 * v117];
          *v122 = v116;
          v115 = v122 + 1;
          v124 = (char *)*((_QWORD *)&v154 + 1);
          v123 = (char *)v154;
          while (v124 != v123)
          {
            v125 = *((_DWORD *)v124 - 1);
            v124 -= 4;
            *((_DWORD *)v122-- - 1) = v125;
          }
          *(_QWORD *)&v154 = v122;
          *((_QWORD *)&v154 + 1) = v115;
          *(_QWORD *)&v155[0] = &v120[4 * v121];
          if (v123)
            operator delete(v123);
        }
        else
        {
          if (!v115)
            goto LABEL_179;
          *v115++ = v116;
        }
        *((_QWORD *)&v154 + 1) = v115;
        ++v113;
      }
      while (v113 != v114);
    }
    v126 = *(_QWORD *)(v1 + 264);
    v127 = *(_QWORD *)(v1 + 272);
    v128 = (v127 - v126) >> 5;
    v129 = *((_QWORD *)&v159 + 1);
    if (v128 > (uint64_t)(*((_QWORD *)&v160 + 1) - *((_QWORD *)&v159 + 1)) >> 3)
    {
      if (v127 - v126 < 0)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v130 = v160;
      v170 = (char *)&v160 + 8;
      *(_QWORD *)v169 = std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v128);
      *(_QWORD *)&v169[8] = *(_QWORD *)v169 + v130 - v129;
      *(_QWORD *)&v169[16] = *(_QWORD *)&v169[8];
      *(_QWORD *)&v169[24] = *(_QWORD *)v169 + 8 * v131;
      std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer((_QWORD *)&v159 + 1, v169);
      std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v169);
      v126 = *(_QWORD *)(v1 + 264);
      v127 = *(_QWORD *)(v1 + 272);
    }
    for (; v126 != v127; v126 += 32)
    {
      v172 = &off_1E1628E40;
      v173 = 0;
      HIDWORD(v174) = 0;
      v132 = (std::string *)operator new();
      v132->__r_.__value_.__r.__words[0] = 0;
      v132->__r_.__value_.__l.__size_ = 0;
      v132->__r_.__value_.__r.__words[2] = 0;
      v133 = (uint64_t)v173;
      v173 = (void ***)v132;
      if (v133)
      {
        std::default_delete<std::string>::operator()[abi:se180100](v133);
        v132 = (std::string *)v173;
      }
      std::string::operator=(v132, (const std::string *)v126);
      v134 = *(_DWORD *)(v126 + 24);
      BYTE4(v174) |= 1u;
      LODWORD(v174) = v134;
      v135 = operator new();
      *(_QWORD *)v135 = &off_1E1628E40;
      *(_QWORD *)(v135 + 8) = 0;
      *(_DWORD *)(v135 + 20) = 0;
      if (v173)
      {
        v136 = (std::string *)operator new();
        v137 = v136;
        if (*((char *)v173 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v136, (const std::string::value_type *)*v173, (std::string::size_type)v173[1]);
        }
        else
        {
          v138 = *(_OWORD *)v173;
          v136->__r_.__value_.__r.__words[2] = (std::string::size_type)v173[2];
          *(_OWORD *)&v136->__r_.__value_.__l.__data_ = v138;
        }
        v139 = *(_QWORD *)(v135 + 8);
        *(_QWORD *)(v135 + 8) = v137;
        if (v139)
          std::default_delete<std::string>::operator()[abi:se180100](v139);
      }
      if ((v174 & 0x100000000) != 0)
      {
        v140 = v174;
        *(_BYTE *)(v135 + 20) |= 1u;
        *(_DWORD *)(v135 + 16) = v140;
      }
      v141 = v160;
      if ((unint64_t)v160 >= *((_QWORD *)&v160 + 1))
      {
        v143 = (uint64_t)(v160 - *((_QWORD *)&v159 + 1)) >> 3;
        if ((unint64_t)(v143 + 1) >> 61)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v144 = (uint64_t)(*((_QWORD *)&v160 + 1) - *((_QWORD *)&v159 + 1)) >> 2;
        if (v144 <= v143 + 1)
          v144 = v143 + 1;
        if (*((_QWORD *)&v160 + 1) - *((_QWORD *)&v159 + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
          v145 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v145 = v144;
        v170 = (char *)&v160 + 8;
        if (!v145)
          goto LABEL_179;
        v146 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v145);
        v147 = (uint64_t *)&v146[8 * v143];
        *(_QWORD *)v169 = v146;
        *(_QWORD *)&v169[8] = v147;
        *(_QWORD *)&v169[24] = &v146[8 * v148];
        if (!v146)
          goto LABEL_179;
        *v147 = v135;
        *(_QWORD *)&v169[16] = v147 + 1;
        std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer((_QWORD *)&v159 + 1, v169);
        v142 = v160;
        std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v169);
      }
      else
      {
        if (!(_QWORD)v160)
          goto LABEL_179;
        *(_QWORD *)v160 = v135;
        v142 = v141 + 8;
      }
      *(_QWORD *)&v160 = v142;
      PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair::~PBFontNameAndDescriptorFlagsPair((PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair *)&v172);
    }
    std::vector<unsigned long>::reserve((void **)&v156[1] + 1, (uint64_t)(*(_QWORD *)(v1 + 176) - *(_QWORD *)(v1 + 168)) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:se180100]<unsigned long const*,unsigned long const*,std::back_insert_iterator<std::vector<unsigned long long>>>(*(uint64_t **)(v1 + 288), *(uint64_t **)(v1 + 296), (void **)&v156[1] + 1);
    std::vector<unsigned long>::reserve((void **)v156, (uint64_t)(*(_QWORD *)(v1 + 320) - *(_QWORD *)(v1 + 312)) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:se180100]<unsigned long const*,unsigned long const*,std::back_insert_iterator<std::vector<unsigned long long>>>(*(uint64_t **)(v1 + 312), *(uint64_t **)(v1 + 320), (void **)v156);
    PB::Writer::Writer((PB::Writer *)v169);
    PBPageLayoutPkg::PBPageLayout::writeTo((uint64_t)&v153, (PB::Writer *)v169);
    if (*(_QWORD *)&v169[8])
      CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)&v169[8], *(_QWORD *)v169 - *(_QWORD *)&v169[8]);
    else
      pdf_error("Failed to serialize PageLayout %p", (const void *)(v1 + 16));
    PB::Writer::~Writer((PB::Writer *)v169);
    PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&v153);
  }
}

void sub_184CC547C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, CFTypeRef cf, uint64_t a16, char a17)
{
  uint64_t v17;

  if (*(char *)(v17 - 169) < 0)
    operator delete(*(void **)(v17 - 192));
  PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&a17);
  _Unwind_Resume(a1);
}

void CGPDFLayoutCreateFromEncodedData(const __CFData *a1)
{
  uint64_t cftype;
  uint64_t v3;
  _OWORD *v4;
  _OWORD *v5;
  const unsigned __int8 *BytePtr;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  int *v51;
  int *v52;
  char *v53;
  int v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *i;
  __int16 v66;
  unsigned int *v67;
  unsigned int *v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  uint64_t v82;
  char *v83;
  char *v84;
  char *v85;
  char *v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  uint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  char *v105;
  __int128 v106;
  unsigned int *v107;
  unsigned int *v108;
  uint64_t *v109;
  uint64_t *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  char *v118;
  int64x2_t v119;
  void **v120;
  const __CFAllocator *v121;
  const __CFAllocator *v122;
  uint64_t v123;
  uint64_t v124;
  const __CFData *v125;
  const __CFDictionary *v126;
  _OWORD *v127;
  unint64_t v128;
  char *v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  char *v135;
  char *v136;
  void **v137;
  _OWORD *v138;
  unint64_t v139;
  uint64_t v140;
  int64x2_t v141;
  void **v142;
  unsigned int *v143;
  unsigned int *v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  char *v149;
  uint64_t v150;
  char *v151;
  char *v152;
  char *v153;
  char *v154;
  uint64_t v155;
  float *v156;
  float *v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  void **v173;
  uint64_t v174;
  double *v175;
  double *v176;
  double *v177;
  double *v178;
  uint64_t v179;
  uint64_t v180;
  void **v181;
  void **v182;
  void **v183;
  void **v184;
  void **v185;
  void **v186;
  void **v187;
  void **v188;
  int64x2_t *v189;
  uint64_t *v190;
  void (**v191)(PBPageLayoutPkg::PBPageLayout *__hidden);
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  uint64_t v210;
  char v211;
  int v212;
  _BYTE v213[32];
  double v214[2];
  const __CFDictionary *v215;
  void **j;
  int64x2_t v217;
  void **v218;
  uint64_t v219;

  if (a1)
  {
    if (CGPDFPageLayoutGetTypeID(void)::onceToken != -1)
      dispatch_once(&CGPDFPageLayoutGetTypeID(void)::onceToken, &__block_literal_global_11122);
    cftype = pdf_create_cftype();
    v3 = cftype;
    if (cftype)
    {
      *(_OWORD *)(cftype + 240) = 0u;
      *(_QWORD *)(cftype + 16) = 0;
      *(_BYTE *)(cftype + 24) = 0;
      *(_OWORD *)(cftype + 32) = 0u;
      v4 = (_OWORD *)(cftype + 32);
      *(_OWORD *)(cftype + 96) = 0u;
      v188 = (void **)(cftype + 96);
      *(_OWORD *)(cftype + 144) = 0u;
      v186 = (void **)(cftype + 144);
      v187 = (void **)(cftype + 120);
      *(_OWORD *)(cftype + 192) = 0u;
      v189 = (int64x2_t *)(cftype + 192);
      v184 = (void **)(cftype + 216);
      v185 = (void **)(cftype + 168);
      v190 = (uint64_t *)(cftype + 264);
      v181 = (void **)(cftype + 72);
      v182 = (void **)(cftype + 288);
      *(_OWORD *)(cftype + 48) = 0u;
      *(_OWORD *)(cftype + 64) = 0u;
      v180 = cftype + 352;
      *(_OWORD *)(cftype + 80) = 0u;
      *(_OWORD *)(cftype + 112) = 0u;
      *(_OWORD *)(cftype + 128) = 0u;
      *(_OWORD *)(cftype + 160) = 0u;
      *(_OWORD *)(cftype + 176) = 0u;
      *(_OWORD *)(cftype + 208) = 0u;
      *(_OWORD *)(cftype + 224) = 0u;
      *(_OWORD *)(cftype + 256) = 0u;
      *(_OWORD *)(cftype + 272) = 0u;
      *(_OWORD *)(cftype + 288) = 0u;
      *(_OWORD *)(cftype + 304) = 0u;
      *(_OWORD *)(cftype + 320) = 0u;
      *(_OWORD *)(cftype + 336) = 0u;
      *(_OWORD *)(cftype + 352) = 0u;
      *(_OWORD *)(cftype + 368) = 0u;
      *(_DWORD *)(cftype + 384) = 1065353216;
      *(_DWORD *)(cftype + 392) = 0;
      v5 = (_OWORD *)(cftype + 400);
      *(_OWORD *)(cftype + 400) = 0u;
      *(_OWORD *)(cftype + 416) = 0u;
      *(_OWORD *)(cftype + 432) = 0u;
      *(_OWORD *)(cftype + 448) = 0u;
      *(_OWORD *)(cftype + 464) = 0u;
      *(_OWORD *)(cftype + 480) = 0u;
      v183 = (void **)(cftype + 240);
      v179 = cftype + 400;
      BytePtr = CFDataGetBytePtr(a1);
      CFDataGetLength(a1);
      PB::Reader::Reader((PB::Reader *)v213, BytePtr);
      v191 = &off_1E1628DD0;
      v212 = 0;
      v208 = 0u;
      v209 = 0u;
      v192 = 0u;
      v193 = 0u;
      v194 = 0u;
      v195 = 0u;
      v196 = 0u;
      v197 = 0u;
      v198 = 0u;
      v199 = 0u;
      v200 = 0u;
      v201 = 0u;
      v202 = 0u;
      v203 = 0u;
      v204 = 0u;
      v205 = 0u;
      v206 = 0u;
      v207 = 0u;
      v210 = 0;
      PBPageLayoutPkg::PBPageLayout::readFrom((PBPageLayoutPkg::PBPageLayout *)&v191, (PB::Reader *)v213);
      *(_QWORD *)(v3 + 16) = 0;
      *v4 = 0u;
      *(_OWORD *)(v3 + 48) = 0u;
      *(_OWORD *)(v3 + 64) = 0u;
      *(_OWORD *)(v3 + 80) = 0u;
      *(_OWORD *)(v3 + 96) = 0u;
      *(_OWORD *)(v3 + 112) = 0u;
      *(_OWORD *)(v3 + 128) = 0u;
      *(_OWORD *)(v3 + 144) = 0u;
      *(_OWORD *)(v3 + 160) = 0u;
      *(_OWORD *)(v3 + 176) = 0u;
      *(_OWORD *)(v3 + 192) = 0u;
      *(_OWORD *)(v3 + 208) = 0u;
      *(_OWORD *)(v3 + 224) = 0u;
      *(_OWORD *)(v3 + 240) = 0u;
      *(_OWORD *)(v3 + 256) = 0u;
      *(_OWORD *)(v3 + 272) = 0u;
      *(_OWORD *)(v3 + 288) = 0u;
      *(_OWORD *)(v3 + 304) = 0u;
      *(_OWORD *)(v3 + 320) = 0u;
      *(_OWORD *)(v3 + 336) = 0u;
      *(_OWORD *)(v3 + 352) = 0u;
      *(_OWORD *)(v3 + 368) = 0u;
      *(_DWORD *)(v3 + 384) = 1065353216;
      *(_DWORD *)(v3 + 392) = 0;
      *(_OWORD *)(v3 + 464) = 0u;
      *(_OWORD *)(v3 + 480) = 0u;
      *(_OWORD *)(v3 + 432) = 0u;
      *(_OWORD *)(v3 + 448) = 0u;
      *v5 = 0u;
      *(_OWORD *)(v3 + 416) = 0u;
      *(_BYTE *)(v3 + 24) = v211;
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v179, v180);
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = *(void **)(v3 + 40);
      *(_QWORD *)(v3 + 40) = v7;

      v9 = *((_QWORD *)&v209 + 1) - v209;
      v10 = *(_QWORD *)(v3 + 48);
      if (0x8E38E38E38E38E39 * ((*(_QWORD *)(v3 + 64) - v10) >> 3) < (uint64_t)(*((_QWORD *)&v209 + 1) - v209) >> 3)
      {
        if ((unint64_t)v9 >= 0x1C71C71C71C71C71)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v11 = *(_QWORD *)(v3 + 56);
        v12 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v9 >> 3);
        v13 = &v12[72 * ((v11 - v10) / 72)];
        v15 = &v12[72 * v14];
        v17 = *(char **)(v3 + 48);
        v16 = *(char **)(v3 + 56);
        v18 = v13;
        if (v16 != v17)
        {
          do
          {
            *(_OWORD *)(v18 - 72) = *(_OWORD *)(v16 - 72);
            v19 = *(_OWORD *)(v16 - 56);
            v20 = *(_OWORD *)(v16 - 40);
            v21 = *(_OWORD *)(v16 - 24);
            *((_QWORD *)v18 - 1) = *((_QWORD *)v16 - 1);
            *(_OWORD *)(v18 - 24) = v21;
            *(_OWORD *)(v18 - 40) = v20;
            *(_OWORD *)(v18 - 56) = v19;
            v18 -= 72;
            v16 -= 72;
          }
          while (v16 != v17);
          v16 = *(char **)(v3 + 48);
        }
        *(_QWORD *)(v3 + 48) = v18;
        *(_QWORD *)(v3 + 56) = v13;
        *(_QWORD *)(v3 + 64) = v15;
        if (v16)
          operator delete(v16);
      }
      v23 = *((_QWORD *)&v209 + 1);
      v22 = v209;
      if ((_QWORD)v209 != *((_QWORD *)&v209 + 1))
      {
        v24 = *(char **)(v3 + 56);
        do
        {
          v26 = *(_QWORD **)(*(_QWORD *)v22 + 8);
          v25 = *(_QWORD *)(*(_QWORD *)v22 + 16);
          v28 = *(_QWORD *)(v25 + 8);
          v27 = *(_QWORD *)(v25 + 16);
          v29 = *(_QWORD *)(*(_QWORD *)v22 + 24);
          v31 = v26[3];
          v30 = v26[4];
          v32 = v26[1];
          v33 = v26[2];
          v34 = *(float *)(*(_QWORD *)v22 + 32);
          v35 = *(_QWORD *)(v3 + 32);
          *(_QWORD *)(v3 + 32) = v35 + 1;
          v36 = *(_QWORD *)(v3 + 64);
          if ((unint64_t)v24 >= v36)
          {
            v37 = *(_QWORD *)(v3 + 48);
            v38 = 0x8E38E38E38E38E39 * ((uint64_t)&v24[-v37] >> 3);
            v39 = v38 + 1;
            if (v38 + 1 > 0x38E38E38E38E38ELL)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v40 = 0x8E38E38E38E38E39 * ((uint64_t)(v36 - v37) >> 3);
            if (2 * v40 > v39)
              v39 = 2 * v40;
            if (v40 >= 0x1C71C71C71C71C7)
              v41 = 0x38E38E38E38E38ELL;
            else
              v41 = v39;
            if (!v41
              || (v42 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v41)) == 0)
            {
LABEL_178:
              __break(1u);
              return;
            }
            v44 = &v42[72 * v38];
            *(_QWORD *)v44 = v27;
            *((_QWORD *)v44 + 1) = v28;
            *((_QWORD *)v44 + 2) = v29;
            *((_QWORD *)v44 + 3) = v33;
            *((_QWORD *)v44 + 4) = v31;
            *((_QWORD *)v44 + 5) = v30;
            *((_QWORD *)v44 + 6) = v32;
            *((double *)v44 + 7) = v34;
            *((_QWORD *)v44 + 8) = v35;
            v46 = *(char **)(v3 + 48);
            v45 = *(char **)(v3 + 56);
            v47 = v44;
            if (v45 != v46)
            {
              do
              {
                *(_OWORD *)(v47 - 72) = *(_OWORD *)(v45 - 72);
                v48 = *(_OWORD *)(v45 - 56);
                v49 = *(_OWORD *)(v45 - 40);
                v50 = *(_OWORD *)(v45 - 24);
                *((_QWORD *)v47 - 1) = *((_QWORD *)v45 - 1);
                *(_OWORD *)(v47 - 24) = v50;
                *(_OWORD *)(v47 - 40) = v49;
                *(_OWORD *)(v47 - 56) = v48;
                v47 -= 72;
                v45 -= 72;
              }
              while (v45 != v46);
              v45 = *(char **)(v3 + 48);
            }
            v24 = v44 + 72;
            *(_QWORD *)(v3 + 48) = v47;
            *(_QWORD *)(v3 + 56) = v44 + 72;
            *(_QWORD *)(v3 + 64) = &v42[72 * v43];
            if (v45)
              operator delete(v45);
          }
          else
          {
            if (!v24)
              goto LABEL_178;
            *(_QWORD *)v24 = v27;
            *((_QWORD *)v24 + 1) = v28;
            *((_QWORD *)v24 + 2) = v29;
            *((_QWORD *)v24 + 3) = v33;
            *((_QWORD *)v24 + 4) = v31;
            *((_QWORD *)v24 + 5) = v30;
            *((_QWORD *)v24 + 6) = v32;
            *((double *)v24 + 7) = v34;
            *((_QWORD *)v24 + 8) = v35;
            v24 += 72;
          }
          *(_QWORD *)(v3 + 56) = v24;
          v22 += 8;
        }
        while (v22 != v23);
      }
      std::vector<unsigned short>::reserve(v181, (uint64_t)(*((_QWORD *)&v201 + 1) - v201) >> 2);
      v52 = (int *)*((_QWORD *)&v201 + 1);
      v51 = (int *)v201;
      if ((_QWORD)v201 != *((_QWORD *)&v201 + 1))
      {
        v53 = *(char **)(v3 + 80);
        do
        {
          v54 = *v51;
          v55 = *(_QWORD *)(v3 + 88);
          if ((unint64_t)v53 >= v55)
          {
            v56 = v53 - (_BYTE *)*v181;
            if (v56 <= -3)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v57 = v56 >> 1;
            v58 = v55 - (_QWORD)*v181;
            if (v58 <= (v56 >> 1) + 1)
              v59 = v57 + 1;
            else
              v59 = v58;
            if (v58 >= 0x7FFFFFFFFFFFFFFELL)
              v60 = 0x7FFFFFFFFFFFFFFFLL;
            else
              v60 = v59;
            if (!v60)
              goto LABEL_178;
            v61 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<unsigned short>>(v60);
            if (!v61)
              goto LABEL_178;
            v63 = &v61[2 * v57];
            *(_WORD *)v63 = v54;
            v53 = v63 + 2;
            v64 = *(char **)(v3 + 72);
            for (i = *(char **)(v3 + 80); i != v64; i -= 2)
            {
              v66 = *((_WORD *)i - 1);
              *((_WORD *)v63 - 1) = v66;
              v63 -= 2;
            }
            *(_QWORD *)(v3 + 72) = v63;
            *(_QWORD *)(v3 + 80) = v53;
            *(_QWORD *)(v3 + 88) = &v61[2 * v62];
            if (v64)
              operator delete(v64);
          }
          else
          {
            if (!v53)
              goto LABEL_178;
            *(_WORD *)v53 = v54;
            v53 += 2;
          }
          *(_QWORD *)(v3 + 80) = v53;
          ++v51;
        }
        while (v51 != v52);
      }
      std::vector<unsigned long>::reserve(v188, (uint64_t)(v200 - *((_QWORD *)&v199 + 1)) >> 2);
      v67 = (unsigned int *)*((_QWORD *)&v199 + 1);
      v68 = (unsigned int *)v200;
      for (j = v188; v67 != v68; ++v67)
      {
        *(_QWORD *)&v214[0] = *v67;
        std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&j, v214);
      }
      std::vector<CGRect>::reserve(v187, (uint64_t)(v208 - *((_QWORD *)&v207 + 1)) >> 3);
      v69 = *((_QWORD *)&v207 + 1);
      v70 = v208;
      if (*((_QWORD *)&v207 + 1) != (_QWORD)v208)
      {
        v71 = *(char **)(v3 + 128);
        do
        {
          v73 = *(_QWORD *)(*(_QWORD *)v69 + 24);
          v72 = *(_QWORD *)(*(_QWORD *)v69 + 32);
          v74 = *(_QWORD *)(*(_QWORD *)v69 + 8);
          v75 = *(_QWORD *)(*(_QWORD *)v69 + 16);
          v76 = *(_QWORD *)(v3 + 136);
          if ((unint64_t)v71 >= v76)
          {
            v77 = (v71 - (_BYTE *)*v187) >> 5;
            if ((unint64_t)(v77 + 1) >> 59)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v78 = v76 - (_QWORD)*v187;
            v79 = v78 >> 4;
            if (v78 >> 4 <= (unint64_t)(v77 + 1))
              v79 = v77 + 1;
            if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFE0)
              v80 = 0x7FFFFFFFFFFFFFFLL;
            else
              v80 = v79;
            if (!v80)
              goto LABEL_178;
            v81 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v80);
            if (!v81)
              goto LABEL_178;
            v83 = &v81[32 * v77];
            *(_QWORD *)v83 = v75;
            *((_QWORD *)v83 + 1) = v73;
            *((_QWORD *)v83 + 2) = v72;
            *((_QWORD *)v83 + 3) = v74;
            v85 = *(char **)(v3 + 120);
            v84 = *(char **)(v3 + 128);
            v86 = v83;
            if (v84 != v85)
            {
              do
              {
                v87 = *((_OWORD *)v84 - 1);
                *((_OWORD *)v86 - 2) = *((_OWORD *)v84 - 2);
                *((_OWORD *)v86 - 1) = v87;
                v86 -= 32;
                v84 -= 32;
              }
              while (v84 != v85);
              v84 = (char *)*v187;
            }
            v71 = v83 + 32;
            *(_QWORD *)(v3 + 120) = v86;
            *(_QWORD *)(v3 + 128) = v83 + 32;
            *(_QWORD *)(v3 + 136) = &v81[32 * v82];
            if (v84)
              operator delete(v84);
          }
          else
          {
            if (!v71)
              goto LABEL_178;
            *(_QWORD *)v71 = v75;
            *((_QWORD *)v71 + 1) = v73;
            *((_QWORD *)v71 + 2) = v72;
            *((_QWORD *)v71 + 3) = v74;
            v71 += 32;
          }
          *(_QWORD *)(v3 + 128) = v71;
          v69 += 8;
        }
        while (v69 != v70);
      }
      std::vector<CGRect>::reserve(v186, (uint64_t)(*((_QWORD *)&v206 + 1) - v206) >> 3);
      v89 = *((_QWORD *)&v206 + 1);
      v88 = v206;
      if ((_QWORD)v206 != *((_QWORD *)&v206 + 1))
      {
        v90 = *(char **)(v3 + 152);
        do
        {
          v92 = *(_QWORD *)(*(_QWORD *)v88 + 24);
          v91 = *(_QWORD *)(*(_QWORD *)v88 + 32);
          v93 = *(_QWORD *)(*(_QWORD *)v88 + 8);
          v94 = *(_QWORD *)(*(_QWORD *)v88 + 16);
          v95 = *(_QWORD *)(v3 + 160);
          if ((unint64_t)v90 >= v95)
          {
            v96 = (v90 - (_BYTE *)*v186) >> 5;
            if ((unint64_t)(v96 + 1) >> 59)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v97 = v95 - (_QWORD)*v186;
            v98 = v97 >> 4;
            if (v97 >> 4 <= (unint64_t)(v96 + 1))
              v98 = v96 + 1;
            if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFE0)
              v99 = 0x7FFFFFFFFFFFFFFLL;
            else
              v99 = v98;
            if (!v99)
              goto LABEL_178;
            v100 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v99);
            if (!v100)
              goto LABEL_178;
            v102 = &v100[32 * v96];
            *(_QWORD *)v102 = v94;
            *((_QWORD *)v102 + 1) = v92;
            *((_QWORD *)v102 + 2) = v91;
            *((_QWORD *)v102 + 3) = v93;
            v104 = *(char **)(v3 + 144);
            v103 = *(char **)(v3 + 152);
            v105 = v102;
            if (v103 != v104)
            {
              do
              {
                v106 = *((_OWORD *)v103 - 1);
                *((_OWORD *)v105 - 2) = *((_OWORD *)v103 - 2);
                *((_OWORD *)v105 - 1) = v106;
                v105 -= 32;
                v103 -= 32;
              }
              while (v103 != v104);
              v103 = (char *)*v186;
            }
            v90 = v102 + 32;
            *(_QWORD *)(v3 + 144) = v105;
            *(_QWORD *)(v3 + 152) = v102 + 32;
            *(_QWORD *)(v3 + 160) = &v100[32 * v101];
            if (v103)
              operator delete(v103);
          }
          else
          {
            if (!v90)
              goto LABEL_178;
            *(_QWORD *)v90 = v94;
            *((_QWORD *)v90 + 1) = v92;
            *((_QWORD *)v90 + 2) = v91;
            *((_QWORD *)v90 + 3) = v93;
            v90 += 32;
          }
          *(_QWORD *)(v3 + 152) = v90;
          v88 += 8;
        }
        while (v88 != v89);
      }
      std::vector<unsigned long>::reserve(v185, (uint64_t)(*((_QWORD *)&v198 + 1) - v198) >> 2);
      v108 = (unsigned int *)*((_QWORD *)&v198 + 1);
      v107 = (unsigned int *)v198;
      j = v185;
      while (v107 != v108)
      {
        *(_QWORD *)&v214[0] = *v107;
        std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&j, v214);
        ++v107;
      }
      v109 = (uint64_t *)*((_QWORD *)&v204 + 1);
      v110 = (uint64_t *)v204;
      v111 = *((_QWORD *)&v204 + 1) - v204;
      v112 = *(_QWORD *)(v3 + 192);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v3 + 208) - v112) >> 3) < (uint64_t)(*((_QWORD *)&v204 + 1) - v204) >> 3)
      {
        if ((unint64_t)v111 >= 0x5555555555555551)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v113 = *(_QWORD *)(v3 + 200);
        v219 = v3 + 208;
        v114 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v111 >> 3);
        v117 = *(_QWORD *)(v3 + 192);
        v116 = *(_QWORD *)(v3 + 200);
        if (v116 == v117)
        {
          v119 = vdupq_n_s64(v116);
          v118 = &v114[v113 - v112];
        }
        else
        {
          v118 = &v114[v113 - v112];
          do
          {
            *(_OWORD *)(v118 - 24) = *(_OWORD *)(v116 - 24);
            *((_QWORD *)v118 - 1) = *(_QWORD *)(v116 - 8);
            v118 -= 24;
            *(_QWORD *)(v116 - 8) = 0;
            v116 -= 24;
          }
          while (v116 != v117);
          v119 = *v189;
        }
        *(_QWORD *)(v3 + 192) = v118;
        *(_QWORD *)(v3 + 200) = &v114[v113 - v112];
        v217 = v119;
        v120 = *(void ***)(v3 + 208);
        *(_QWORD *)(v3 + 208) = &v114[24 * v115];
        v218 = v120;
        j = (void **)v119.i64[0];
        std::__split_buffer<PageLayout::CharacterStyle>::~__split_buffer((uint64_t)&j);
        v109 = (uint64_t *)*((_QWORD *)&v204 + 1);
        v110 = (uint64_t *)v204;
      }
      if (v110 != v109)
      {
        v121 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v122 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
        do
        {
          v123 = *v110;
          v215 = 0;
          v124 = *(_QWORD *)(v123 + 8);
          v214[0] = *(double *)(v123 + 16);
          v214[1] = *(float *)(v123 + 28);
          v125 = CFDataCreateWithBytesNoCopy(v121, **(const UInt8 ***)(v124 + 8), *(_QWORD *)(*(_QWORD *)(v124 + 8) + 8), v122);
          v126 = (const __CFDictionary *)CFPropertyListCreateWithData(v121, v125, 0, 0, 0);
          v215 = CGColorCreateWithPropertyList(v126);
          v127 = *(_OWORD **)(v3 + 200);
          v128 = *(_QWORD *)(v3 + 208);
          if ((unint64_t)v127 >= v128)
          {
            v130 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v127 - v189->i64[0]) >> 3);
            v131 = v130 + 1;
            if (v130 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v132 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v128 - v189->i64[0]) >> 3);
            if (2 * v132 > v131)
              v131 = 2 * v132;
            if (v132 >= 0x555555555555555)
              v133 = 0xAAAAAAAAAAAAAAALL;
            else
              v133 = v131;
            v219 = v3 + 208;
            if (v133)
            {
              v135 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v133);
            }
            else
            {
              v135 = 0;
              v134 = 0;
            }
            v136 = &v135[24 * v130];
            v137 = (void **)&v135[24 * v134];
            v218 = v137;
            v138 = std::construct_at[abi:se180100]<PageLayout::CharacterStyle,PageLayout::CharacterStyle const&,PageLayout::CharacterStyle*>(v136, (uint64_t)v214);
            v129 = (char *)v138 + 24;
            v217.i64[1] = (uint64_t)v138 + 24;
            v140 = *(_QWORD *)(v3 + 192);
            v139 = *(_QWORD *)(v3 + 200);
            if (v139 == v140)
            {
              v141 = vdupq_n_s64(v139);
            }
            else
            {
              do
              {
                *(_OWORD *)((char *)v138 - 24) = *(_OWORD *)(v139 - 24);
                *((_QWORD *)v138 - 1) = *(_QWORD *)(v139 - 8);
                v138 = (_OWORD *)((char *)v138 - 24);
                *(_QWORD *)(v139 - 8) = 0;
                v139 -= 24;
              }
              while (v139 != v140);
              v141 = *v189;
              v129 = (char *)v217.i64[1];
              v137 = v218;
            }
            *(_QWORD *)(v3 + 192) = v138;
            *(_QWORD *)(v3 + 200) = v129;
            v217 = v141;
            v142 = *(void ***)(v3 + 208);
            *(_QWORD *)(v3 + 208) = v137;
            v218 = v142;
            j = (void **)v141.i64[0];
            std::__split_buffer<PageLayout::CharacterStyle>::~__split_buffer((uint64_t)&j);
          }
          else
          {
            v129 = (char *)std::construct_at[abi:se180100]<PageLayout::CharacterStyle,PageLayout::CharacterStyle const&,PageLayout::CharacterStyle*>(v127, (uint64_t)v214)+ 24;
          }
          *(_QWORD *)(v3 + 200) = v129;
          if (v126)
            CFRelease(v126);
          if (v125)
            CFRelease(v125);
          if (v215)
            CFRelease(v215);
          ++v110;
        }
        while (v110 != v109);
      }
      std::vector<unsigned long>::reserve(v184, (uint64_t)(v194 - *((_QWORD *)&v193 + 1)) >> 2);
      v143 = (unsigned int *)*((_QWORD *)&v193 + 1);
      v144 = (unsigned int *)v194;
      j = v184;
      while (v143 != v144)
      {
        *(_QWORD *)&v214[0] = *v143;
        std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&j, v214);
        ++v143;
      }
      v145 = (uint64_t)(*((_QWORD *)&v192 + 1) - v192) >> 2;
      v146 = *(_QWORD *)(v3 + 240);
      if (v145 > (*(_QWORD *)(v3 + 256) - v146) >> 3)
      {
        if (*((_QWORD *)&v192 + 1) - (_QWORD)v192 >= 0x7FFFFFFFFFFFFFFDuLL)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v147 = *(_QWORD *)(v3 + 248);
        v148 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v145);
        v149 = &v148[(v147 - v146) & 0xFFFFFFFFFFFFFFF8];
        v151 = &v148[8 * v150];
        v152 = *(char **)(v3 + 240);
        v153 = *(char **)(v3 + 248);
        v154 = v149;
        if (v153 != v152)
        {
          v154 = v149;
          do
          {
            v155 = *((_QWORD *)v153 - 1);
            v153 -= 8;
            *((_QWORD *)v154 - 1) = v155;
            v154 -= 8;
          }
          while (v153 != v152);
        }
        *(_QWORD *)(v3 + 240) = v154;
        *(_QWORD *)(v3 + 248) = v149;
        *(_QWORD *)(v3 + 256) = v151;
        if (v152)
          operator delete(v152);
      }
      v157 = (float *)*((_QWORD *)&v192 + 1);
      v156 = (float *)v192;
      j = v183;
      while (v156 != v157)
      {
        v214[0] = *v156;
        std::back_insert_iterator<std::vector<double>>::operator=[abi:se180100](&j, v214);
        ++v156;
      }
      v158 = *((_QWORD *)&v202 + 1);
      v159 = v203;
      v160 = (uint64_t)(v203 - *((_QWORD *)&v202 + 1)) >> 3;
      v161 = *(_QWORD *)(v3 + 264);
      if (v160 > (*(_QWORD *)(v3 + 280) - v161) >> 5)
      {
        if ((_QWORD)v203 - *((_QWORD *)&v202 + 1) >= 0x3FFFFFFFFFFFFFF9uLL)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v162 = *(_QWORD *)(v3 + 272);
        v219 = v3 + 280;
        j = (void **)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v160);
        v217.i64[0] = (uint64_t)j + v162 - v161;
        v217.i64[1] = v217.i64[0];
        v218 = &j[4 * v163];
        std::vector<std::pair<std::string,unsigned int>>::__swap_out_circular_buffer(v190, &j);
        std::__split_buffer<std::pair<std::string,unsigned int>>::~__split_buffer((uint64_t)&j);
        v158 = *((_QWORD *)&v202 + 1);
        v159 = v203;
      }
      for (; v158 != v159; v158 += 8)
      {
        v164 = *(char **)(*(_QWORD *)v158 + 8);
        if (v164[23] < 0)
          v164 = *(char **)v164;
        v165 = *(_DWORD *)(*(_QWORD *)v158 + 16);
        v167 = *(_QWORD *)(v3 + 272);
        v166 = *(_QWORD *)(v3 + 280);
        if (v167 >= v166)
        {
          v169 = (uint64_t)(v167 - *v190) >> 5;
          if ((unint64_t)(v169 + 1) >> 59)
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
          v170 = v166 - *v190;
          v171 = v170 >> 4;
          if (v170 >> 4 <= (unint64_t)(v169 + 1))
            v171 = v169 + 1;
          if ((unint64_t)v170 >= 0x7FFFFFFFFFFFFFE0)
            v172 = 0x7FFFFFFFFFFFFFFLL;
          else
            v172 = v171;
          v219 = v3 + 280;
          if (!v172)
            goto LABEL_178;
          v173 = (void **)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v172);
          j = v173;
          v217.i64[0] = (uint64_t)&v173[4 * v169];
          v217.i64[1] = v217.i64[0];
          v218 = &v173[4 * v174];
          if (!v173)
            goto LABEL_178;
          std::string::basic_string[abi:se180100]<0>((char **)&v173[4 * v169], v164);
          LODWORD(v173[4 * v169 + 3]) = v165;
          v217.i64[1] += 32;
          std::vector<std::pair<std::string,unsigned int>>::__swap_out_circular_buffer(v190, &j);
          v168 = *(_QWORD *)(v3 + 272);
          std::__split_buffer<std::pair<std::string,unsigned int>>::~__split_buffer((uint64_t)&j);
        }
        else
        {
          if (!v167)
            goto LABEL_178;
          std::string::basic_string[abi:se180100]<0>(*(char ***)(v3 + 272), v164);
          *(_DWORD *)(v167 + 24) = v165;
          v168 = v167 + 32;
          *(_QWORD *)(v3 + 272) = v167 + 32;
        }
        *(_QWORD *)(v3 + 272) = v168;
      }
      std::vector<unsigned long>::reserve(v182, (uint64_t)(v197 - *((_QWORD *)&v196 + 1)) >> 3);
      v175 = (double *)*((_QWORD *)&v196 + 1);
      v176 = (double *)v197;
      j = v182;
      while (v175 != v176)
      {
        v214[0] = *v175;
        std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&j, v214);
        ++v175;
      }
      std::vector<unsigned long>::reserve(v183 + 9, (uint64_t)(*((_QWORD *)&v195 + 1) - v195) >> 3);
      v178 = (double *)*((_QWORD *)&v195 + 1);
      v177 = (double *)v195;
      j = v183 + 9;
      while (v177 != v178)
      {
        v214[0] = *v177;
        std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&j, v214);
        ++v177;
      }
      PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&v191);
    }
  }
}

void sub_184CC643C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, void **a11, void **a12, void **a13, void **a14, void **a15, void **a16, void **a17, void **a18, uint64_t a19, void **a20,void **a21,void **a22)
{
  uint64_t v22;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;

  PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&a22);
  v24 = *(void **)(v22 + 472);
  if (v24)
  {
    *(_QWORD *)(v22 + 480) = v24;
    operator delete(v24);
  }
  v25 = *(void **)(v22 + 448);
  if (v25)
  {
    *(_QWORD *)(v22 + 456) = v25;
    operator delete(v25);
  }
  v26 = *(void **)(v22 + 424);
  if (v26)
  {
    *(_QWORD *)(v22 + 432) = v26;
    operator delete(v26);
  }
  v27 = *a9;
  if (*a9)
  {
    *(_QWORD *)(v22 + 408) = v27;
    operator delete(v27);
  }
  std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table(a10);

  v28 = *(void **)(v22 + 312);
  if (v28)
  {
    *(_QWORD *)(v22 + 320) = v28;
    operator delete(v28);
  }
  v29 = *a12;
  if (*a12)
  {
    *(_QWORD *)(v22 + 296) = v29;
    operator delete(v29);
  }
  a22 = a21;
  std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:se180100](&a22);
  v30 = *a13;
  if (*a13)
  {
    *(_QWORD *)(v22 + 248) = v30;
    operator delete(v30);
  }
  v31 = *a14;
  if (*a14)
  {
    *(_QWORD *)(v22 + 224) = v31;
    operator delete(v31);
  }
  a22 = a20;
  std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:se180100](&a22);
  v32 = *a15;
  if (*a15)
  {
    *(_QWORD *)(v22 + 176) = v32;
    operator delete(v32);
  }
  v33 = *a16;
  if (*a16)
  {
    *(_QWORD *)(v22 + 152) = v33;
    operator delete(v33);
  }
  v34 = *a17;
  if (*a17)
  {
    *(_QWORD *)(v22 + 128) = v34;
    operator delete(v34);
  }
  v35 = *a18;
  if (*a18)
  {
    *(_QWORD *)(v22 + 104) = v35;
    operator delete(v35);
  }
  v36 = *a11;
  if (*a11)
  {
    *(_QWORD *)(v22 + 80) = v36;
    operator delete(v36);
  }
  v37 = *(void **)(v22 + 48);
  if (v37)
  {
    *(_QWORD *)(v22 + 56) = v37;
    operator delete(v37);
  }

  _Unwind_Resume(a1);
}

unint64_t CGPDFPageLayoutGetCharacterSelectionBoundingBox(unint64_t result, unint64_t a2, _OWORD *a3, uint64_t a4)
{
  uint64_t v5;
  _OWORD *v6;
  __int128 v7;
  PageLayout *v8;
  PageLayout *v9;
  __double2 v10;

  if (result)
  {
    if (a2 < (uint64_t)(*(_QWORD *)(result + 128) - *(_QWORD *)(result + 120)) >> 5)
    {
      if (a3)
      {
        v5 = *(_QWORD *)(result + 144);
        if (a2 >= (*(_QWORD *)(result + 152) - v5) >> 5)
        {
LABEL_12:
          __break(1u);
          return result;
        }
        v6 = (_OWORD *)(v5 + 32 * a2);
        v7 = v6[1];
        *a3 = *v6;
        a3[1] = v7;
      }
      if (!a4)
        return 1;
      v8 = *(PageLayout **)(result + 48);
      v9 = *(PageLayout **)(result + 56);
      result = PageLayout::getLineIndex(v8, v9, a2);
      if (0x8E38E38E38E38E39 * ((v9 - v8) >> 3) > result)
      {
        v10 = __sincos_stret(*((double *)v8 + 9 * result + 7));
        *(double *)a4 = v10.__cosval;
        *(double *)(a4 + 8) = v10.__sinval;
        *(double *)(a4 + 16) = -v10.__sinval;
        *(double *)(a4 + 24) = v10.__cosval;
        *(_QWORD *)(a4 + 32) = 0;
        *(_QWORD *)(a4 + 40) = 0;
        return 1;
      }
      goto LABEL_12;
    }
    return 0;
  }
  return result;
}

BOOL CGPDFPageLayoutGetColumnBoundsAtPointWithCompletion(uint64_t a1, void *a2, void *a3, CGFloat a4, CGFloat a5)
{
  id v9;
  id v10;
  NSObject *v11;
  void (**v12)(_QWORD, double, double, double, double);
  os_unfair_lock_s *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const CGRect *v17;
  _BOOL8 v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  void *v21;
  _QWORD v23[4];
  void (**v24)(_QWORD);
  _QWORD aBlock[4];
  void (**v26)(_QWORD, double, double, double, double);
  uint64_t v27;
  uint64_t v28;
  CGFloat v29;
  CGFloat v30;
  CGPoint v31;

  v9 = a2;
  v10 = a3;
  if (a1)
  {
    v11 = v9;
    v12 = (void (**)(_QWORD, double, double, double, double))v10;
    v13 = (os_unfair_lock_s *)(a1 + 392);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 392));
    if (*(_BYTE *)(a1 + 396))
    {
      v15 = *(_QWORD *)(a1 + 400);
      v14 = *(_QWORD *)(a1 + 408);
      if (v15 == v14)
      {
        v17 = &CGRectNull;
      }
      else
      {
        v16 = 0;
        do
        {
          v31.x = a4;
          v31.y = a5;
          if (CGRectContainsPoint(*(CGRect *)v15, v31) && (!v16 || *(_QWORD *)(v15 + 32) >= *(_QWORD *)(v16 + 32)))
            v16 = v15;
          v15 += 40;
        }
        while (v15 != v14);
        v17 = &CGRectNull;
        if (v16)
          v17 = (const CGRect *)v16;
      }
      v12[2](v12, v17->origin.x, v17->origin.y, v17->size.width, v17->size.height);
      os_unfair_lock_unlock(v13);
      v18 = 1;
    }
    else
    {
      os_unfair_lock_unlock(v13);
      v19 = MEMORY[0x1E0C809B0];
      aBlock[0] = MEMORY[0x1E0C809B0];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke;
      aBlock[3] = &unk_1E165AA58;
      v27 = a1 + 16;
      v26 = v12;
      v28 = a1 + 16;
      v29 = a4;
      v30 = a5;
      v20 = (void (**)(_QWORD))_Block_copy(aBlock);
      v21 = v20;
      v18 = v11 == 0;
      if (v11)
      {
        v23[0] = v19;
        v23[1] = 3221225472;
        v23[2] = ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke_2;
        v23[3] = &unk_1E165AA80;
        v24 = v20;
        dispatch_async(v11, v23);

      }
      else
      {
        v20[2](v20);
      }

    }
  }
  else
  {
    v18 = 0;
  }

  return v18;
}

void sub_184CC6A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

uint64_t CGPDFPageLayoutGetTextRangeIndexAtPoint(uint64_t a1, double a2, double a3)
{
  uint64_t v3;

  if (!a1)
    return -1;
  PageLayout::getTextRangeIndex((PageLayout *)(a1 + 16), 0, 2u, a2, a3);
  return v3;
}

uint64_t CGPDFPageLayoutGetStringRangeIndexNearestPoint(uint64_t a1, double a2, double a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void **v7;
  _QWORD v8[2];
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  _QWORD v12[2];

  if (!a1)
    return -1;
  v3 = a1 + 16;
  PageLayout::getTextRangeIndex((PageLayout *)(a1 + 16), 0, 3u, a2, a3);
  if (v4 == -1)
    return -1;
  v12[0] = v4;
  v12[1] = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v8[0] = v12;
  v8[1] = 1;
  v7 = (void **)&v9;
  PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(v3, (uint64_t)v8, &v7);
  if (v9 != v10)
  {
    v5 = *v9;
LABEL_7:
    v10 = v9;
    operator delete(v9);
    return v5;
  }
  v5 = -1;
  if (v9)
    goto LABEL_7;
  return v5;
}

void sub_184CC6B58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFPageLayoutGetAreaOfInterestAtPoint(uint64_t result, double a2, double a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CGRect *v8;
  CGRect *v9;
  CGPoint v10;

  if (result)
  {
    v5 = result;
    PageLayout::getTextRangeIndex((PageLayout *)(result + 16), 0, 2u, a2, a3);
    v7 = v6;
    v9 = *(CGRect **)(v5 + 424);
    v8 = *(CGRect **)(v5 + 432);
    while (1)
    {
      if (v9 == v8)
        return v7 != -1;
      v10.x = a2;
      v10.y = a3;
      if (CGRectContainsPoint(*v9, v10))
        break;
      ++v9;
    }
    return (v7 != -1) | 2u;
  }
  return result;
}

uint64_t CGPDFPageLayoutGetNumberOfCharacterBoundingBoxes(uint64_t result)
{
  if (result)
    return (uint64_t)(*(_QWORD *)(result + 152) - *(_QWORD *)(result + 144)) >> 5;
  return result;
}

void CGPDFPageLayoutGetCharacterPreciseBoundingBoxes(_QWORD *a1, void *__dst, uint64_t a3)
{
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __double2 v11;
  uint64_t v12;
  unint64_t v13;

  if (a1)
  {
    v5 = (_BYTE *)a1[18];
    v6 = (_BYTE *)a1[19];
    if (v6 != v5)
      memmove(__dst, v5, v6 - v5);
    v8 = a1[6];
    v7 = a1[7];
    if (v8 != v7)
    {
      v9 = 0;
      do
      {
        v10 = *(_QWORD *)(v8 + 8);
        v11 = __sincos_stret(*(double *)(v8 + 56));
        if (v10 >= 1)
        {
          v12 = a3 + 48 * v9;
          v13 = v10 + 1;
          do
          {
            *(double *)v12 = v11.__cosval;
            *(double *)(v12 + 8) = v11.__sinval;
            *(double *)(v12 + 16) = -v11.__sinval;
            *(double *)(v12 + 24) = v11.__cosval;
            --v13;
            *(_QWORD *)(v12 + 32) = 0;
            *(_QWORD *)(v12 + 40) = 0;
            v12 += 48;
          }
          while (v13 > 1);
        }
        v9 += v10;
        v8 += 72;
      }
      while (v8 != v7);
    }
  }
}

void CGPDFPageLayoutGetCharacterSelectionBoundingBoxes(_QWORD *a1, void *__dst, uint64_t a3)
{
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __double2 v11;
  uint64_t v12;
  unint64_t v13;

  if (a1)
  {
    v5 = (_BYTE *)a1[15];
    v6 = (_BYTE *)a1[16];
    if (v6 != v5)
      memmove(__dst, v5, v6 - v5);
    v8 = a1[6];
    v7 = a1[7];
    if (v8 != v7)
    {
      v9 = 0;
      do
      {
        v10 = *(_QWORD *)(v8 + 8);
        v11 = __sincos_stret(*(double *)(v8 + 56));
        if (v10 >= 1)
        {
          v12 = a3 + 48 * v9;
          v13 = v10 + 1;
          do
          {
            *(double *)v12 = v11.__cosval;
            *(double *)(v12 + 8) = v11.__sinval;
            *(double *)(v12 + 16) = -v11.__sinval;
            *(double *)(v12 + 24) = v11.__cosval;
            --v13;
            *(_QWORD *)(v12 + 32) = 0;
            *(_QWORD *)(v12 + 40) = 0;
            v12 += 48;
          }
          while (v13 > 1);
        }
        v9 += v10;
        v8 += 72;
      }
      while (v8 != v7);
    }
  }
}

void CGPDFPageLayoutEnumerateLineRects(uint64_t a1, void *a2)
{
  id v3;
  void (**v4)(id, _QWORD *, double, double, double, double);
  double *i;
  double *v6;
  __double2 v7;
  double v8;
  double v9;
  double v10;
  double v11;
  id v12;
  _QWORD v13[6];

  v3 = a2;
  if (a1)
  {
    v12 = v3;
    v4 = (void (**)(id, _QWORD *, double, double, double, double))v3;
    v6 = *(double **)(a1 + 48);
    for (i = *(double **)(a1 + 56); v6 != i; v6 += 9)
    {
      v7 = __sincos_stret(v6[7]);
      v8 = v6[3];
      v9 = v6[4];
      v10 = v6[5];
      v11 = v6[6];
      v13[0] = *(_QWORD *)&v7.__cosval;
      v13[1] = *(_QWORD *)&v7.__sinval;
      *(double *)&v13[2] = -v7.__sinval;
      v13[3] = *(_QWORD *)&v7.__cosval;
      v13[4] = 0;
      v13[5] = 0;
      v4[2](v4, v13, v8, v9, v10, v11);
    }

    v3 = v12;
  }

}

void sub_184CC6E10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CGPDFPageLayoutInsertTableDescriptions(uint64_t a1, void *a2)
{
  void *v2;
  PageLayout *v3;
  id v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  id v8;
  uint64_t j;
  void *v10;
  char *v11;
  char *v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  void *v17;
  PDFTextLineElement *v18;
  PDFAtomicElement *v19;
  uint64_t v20;
  void *k;
  id v22;
  void *v23;
  id v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t m;
  id v28;
  void *v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  const CGPoint *v38;
  const CGPoint *v39;
  double v40;
  double v41;
  double v42;
  double v43;
  const CGPoint *v44;
  const CGPoint *v45;
  double v46;
  double v47;
  __n128 v48;
  double v49;
  double v50;
  double v51;
  __n128 v52;
  uint64_t *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  PDFTextLineElement *v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  PDFAtomicElement *v62;
  __int128 v63;
  __int128 v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  id v68;
  void *v69;
  uint64_t *v70;
  uint64_t *v71;
  BOOL v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  void *v76;
  void *v77;
  double v78;
  CGFloat v79;
  double v80;
  double v81;
  double v82;
  double v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  double v87;
  double v88;
  double v89;
  double y;
  double v91;
  double v92;
  double v93;
  id v94;
  void *v95;
  void *v96;
  uint64_t v97;
  uint64_t ii;
  id v99;
  void *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t jj;
  void *v105;
  void *v106;
  int v107;
  PDFCRGroupRegionCell *v108;
  PDFCTLDDelegateForTables *v109;
  void *v110;
  double v111;
  double v112;
  double v113;
  double v114;
  id v115;
  id v116;
  uint64_t v117;
  id v118;
  uint64_t v119;
  id v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  id v124;
  id v125;
  void *v126;
  id obj;
  id obja;
  uint64_t v129;
  uint64_t n;
  uint64_t v131;
  id v133;
  void *v134;
  id i;
  id v136;
  id v137;
  id v138;
  id v139;
  id v140;
  id v141;
  id v142;
  id v143;
  id v144;
  double height;
  double width;
  void *v147;
  CGAffineTransform v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  unsigned int v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  _BYTE __dst[72];
  CGAffineTransform v167;
  TextLine v168;
  _OWORD v169[4];
  uint64_t v170;
  CGAffineTransform v171;
  uint64_t *v172;
  _QWORD *v173[2];
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  TextLine v182;
  $5CFEE62CA76FAE445C6F9DBCEE669C70 v183;
  unint64_t v184;
  CGFloat v185;
  CGFloat v186;
  CGFloat v187;
  CGFloat v188;
  __int128 v189;
  CGAffineTransform v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  CGAffineTransform v199;
  CGAffineTransform v200;
  _BYTE v201[128];
  _BYTE v202[128];
  _BYTE v203[128];
  unsigned int v204[32];
  $5CFEE62CA76FAE445C6F9DBCEE669C70 v205;
  unint64_t v206;
  void *__p;
  char *v208;
  _BYTE v209[128];
  __int128 v210;
  uint64_t v211;
  uint64_t v212;
  CGPoint v213;
  CGRect BoxRect;
  CGRect v215;
  CGRect v216;
  CGRect v217;
  CGRect v218;
  CGRect v219;
  CGRect v220;
  CGRect v221;
  CGRect v222;
  CGRect v223;
  CGRect v224;
  CGRect v225;
  CGRect v226;
  CGRect v227;

  v212 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!TextRecognitionLibraryCore(char **)::frameworkLibrary)
    {
      v2 = a2;
      v210 = xmmword_1E165AAF0;
      v211 = 0;
      TextRecognitionLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
      a2 = v2;
    }
    if (TextRecognitionLibraryCore(char **)::frameworkLibrary)
    {
      v124 = a2;
      v3 = (PageLayout *)(a1 + 16);
      BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(_QWORD *)(a1 + 16), kCGPDFCropBox);
      height = BoxRect.size.height;
      width = BoxRect.size.width;
      memset(&v200, 0, sizeof(v200));
      *(float64x2_t *)&v199.a = vmulq_n_f64((float64x2_t)xmmword_185004990, BoxRect.size.width);
      *(float64x2_t *)&v199.c = vmulq_n_f64((float64x2_t)xmmword_185004A20, -BoxRect.size.height);
      v199.tx = BoxRect.origin.x;
      v199.ty = BoxRect.origin.y + BoxRect.size.height;
      CGAffineTransformInvert(&v200, &v199);
      v126 = (void *)objc_msgSend(objc_alloc((Class)getCRCTLDClass()), "init");
      v147 = (void *)objc_opt_new();
      if (objc_msgSend(*(id *)(a1 + 344), "count"))
      {
        v198 = 0u;
        v197 = 0u;
        v196 = 0u;
        v195 = 0u;
        v4 = *(id *)(a1 + 344);
        v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v195, &v210, 16);
        if (v5)
        {
          obj = v4;
          v129 = v5;
          v131 = *(_QWORD *)v196;
          do
          {
            for (i = 0; i != (id)v129; i = (char *)i + 1)
            {
              if (*(_QWORD *)v196 != v131)
                objc_enumerationMutation(obj);
              v6 = *(id *)(*((_QWORD *)&v195 + 1) + 8 * (_QWORD)i);
              v191 = 0u;
              v192 = 0u;
              v193 = 0u;
              v194 = 0u;
              v133 = v6;
              objc_msgSend(v6, "subregions");
              v142 = (id)objc_claimAutoreleasedReturnValue();
              v7 = objc_msgSend(v142, "countByEnumeratingWithState:objects:count:", &v191, v209, 16);
              if (v7)
              {
                v8 = *(id *)v192;
                v138 = *(id *)v192;
                do
                {
                  for (j = 0; j != v7; ++j)
                  {
                    if (*(id *)v192 != v8)
                      objc_enumerationMutation(v142);
                    v10 = *(void **)(*((_QWORD *)&v191 + 1) + 8 * j);
                    if (objc_msgSend(v10, "type") == 4)
                    {
                      if (v10)
                      {
                        objc_msgSend(v10, "textLines");
                        v11 = (char *)__p;
                        v12 = v208;
                        if (__p != v208)
                        {
                          do
                          {
                            v205 = *($5CFEE62CA76FAE445C6F9DBCEE669C70 *)v11;
                            v206 = *((_QWORD *)v11 + 2);
                            v13 = *((double *)v11 + 3);
                            v14 = *((double *)v11 + 4);
                            v15 = *((double *)v11 + 5);
                            v16 = *((double *)v11 + 6);
                            *(_OWORD *)v204 = *(_OWORD *)(v11 + 56);
                            v190 = v200;
                            v215.origin.x = v13;
                            v215.origin.y = v14;
                            v215.size.width = v15;
                            v215.size.height = v16;
                            v216 = CGRectApplyAffineTransform(v215, &v190);
                            v17 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v216.origin.x, v216.origin.y, v216.size.width, v216.size.height, width, height);
                            v18 = [PDFTextLineElement alloc];
                            v183 = v205;
                            v184 = v206;
                            v185 = v13;
                            v186 = v14;
                            v187 = v15;
                            v188 = v16;
                            v189 = *(_OWORD *)v204;
                            v19 = -[PDFTextLineElement initWithTextLine:boundingBox:](v18, "initWithTextLine:boundingBox:", &v183, v17);
                            v182.textRange = v205;
                            v182.uniCharStart = v206;
                            v182.bbox.origin.x = v13;
                            v182.bbox.origin.y = v14;
                            v182.bbox.size.width = v15;
                            v182.bbox.size.height = v16;
                            *(_OWORD *)&v182.rotation = *(_OWORD *)v204;
                            PageLayout::addCTLDMapping(v3, &v182, v19);
                            objc_msgSend(v147, "addObject:", v19);

                            v11 += 72;
                          }
                          while (v11 != v12);
                          v11 = (char *)__p;
                        }
                        v8 = v138;
                        if (v11)
                        {
                          v208 = v11;
                          operator delete(v11);
                        }
                      }
                    }
                    else
                    {
                      objc_msgSend(v147, "addObject:", v10);
                    }
                  }
                  v7 = objc_msgSend(v142, "countByEnumeratingWithState:objects:count:", &v191, v209, 16);
                }
                while (v7);
              }

            }
            v129 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v195, &v210, 16);
          }
          while (v129);
          v4 = obj;
        }
      }
      else
      {
        PageLayout::createAtomicElements(v3, 0);
        v4 = v147;
        v147 = (void *)objc_claimAutoreleasedReturnValue();
      }

      v180 = 0u;
      v181 = 0u;
      v178 = 0u;
      v179 = 0u;
      v136 = v124;
      v20 = objc_msgSend(v136, "countByEnumeratingWithState:objects:count:", &v178, &__p, 16);
      if (v20)
      {
        v139 = *(id *)v179;
        do
        {
          v143 = (id)v20;
          for (k = 0; k != v143; k = (char *)k + 1)
          {
            if (*(id *)v179 != v139)
              objc_enumerationMutation(v136);
            v22 = *(id *)(*((_QWORD *)&v178 + 1) + 8 * (_QWORD)k);
            objc_msgSend(v22, "valueForKey:", CFSTR("Cells"));
            v23 = (void *)objc_claimAutoreleasedReturnValue();
            v176 = 0u;
            v177 = 0u;
            v174 = 0u;
            v175 = 0u;
            v24 = v23;
            v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v174, &v205, 16);
            if (v25)
            {
              v26 = *(_QWORD *)v175;
              do
              {
                for (m = 0; m != v25; ++m)
                {
                  if (*(_QWORD *)v175 != v26)
                    objc_enumerationMutation(v24);
                  v28 = *(id *)(*((_QWORD *)&v174 + 1) + 8 * m);
                  objc_msgSend(v28, "valueForKey:", CFSTR("Rect"));
                  v29 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v29, "rectValue");
                  v31 = v30;
                  v33 = v32;
                  v35 = v34;
                  v37 = v36;

                  if (v35 < 0.0 || v37 < 0.0)
                  {
                    v217.origin.x = v31;
                    v217.origin.y = v33;
                    v217.size.width = v35;
                    v217.size.height = v37;
                    v218 = CGRectStandardize(v217);
                    v40 = v218.origin.x + v218.size.width;
                    v218.origin.x = v31;
                    v218.origin.y = v33;
                    v218.size.width = v35;
                    v218.size.height = v37;
                    *(CGRect *)(&v41 - 1) = CGRectStandardize(v218);
                    v37 = v42;
                  }
                  else
                  {
                    v40 = v31 + v35;
                    v41 = v33;
                  }
                  v43 = v41 + v37;
                  PageLayout::addVertEdge(v3, v38, v39, v31, v33, v41 + v37);
                  PageLayout::addVertEdge(v3, v44, v45, v40, v33, v43);

                }
                v25 = objc_msgSend(v24, "countByEnumeratingWithState:objects:count:", &v174, &v205, 16);
              }
              while (v25);
            }

          }
          v20 = objc_msgSend(v136, "countByEnumeratingWithState:objects:count:", &v178, &__p, 16);
        }
        while (v20);
      }

      v173[1] = 0;
      v173[0] = 0;
      v172 = (uint64_t *)v173;
      PageLayout::splitLines(v3, 1, &v172, v46, v47, v48, v49, v50, v51, v52);
      v53 = v172;
      if (v172 != (uint64_t *)v173)
      {
        do
        {
          v54 = v53[4];
          v55 = *(_QWORD *)(a1 + 48);
          if (0x8E38E38E38E38E39 * ((*(_QWORD *)(a1 + 56) - v55) >> 3) <= v54)
            goto LABEL_96;
          v56 = v55 + 72 * v54;
          v219 = *(CGRect *)(v56 + 24);
          v171 = v200;
          v220 = CGRectApplyAffineTransform(v219, &v171);
          v57 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v220.origin.x, v220.origin.y, v220.size.width, v220.size.height, width, height);
          v58 = [PDFTextLineElement alloc];
          v169[0] = *(_OWORD *)v56;
          v59 = *(_OWORD *)(v56 + 16);
          v60 = *(_OWORD *)(v56 + 32);
          v61 = *(_OWORD *)(v56 + 48);
          v170 = *(_QWORD *)(v56 + 64);
          v169[2] = v60;
          v169[3] = v61;
          v169[1] = v59;
          v62 = -[PDFTextLineElement initWithTextLine:boundingBox:](v58, "initWithTextLine:boundingBox:", v169, v57);
          objc_msgSend(v147, "addObject:", v62);
          v63 = *(_OWORD *)(v56 + 48);
          *(_OWORD *)&v168.bbox.origin.y = *(_OWORD *)(v56 + 32);
          *(_OWORD *)&v168.bbox.size.height = v63;
          v168.identifier = *(_QWORD *)(v56 + 64);
          v64 = *(_OWORD *)(v56 + 16);
          v168.textRange = *($5CFEE62CA76FAE445C6F9DBCEE669C70 *)v56;
          *(_OWORD *)&v168.uniCharStart = v64;
          PageLayout::addCTLDMapping(v3, &v168, v62);
          v65 = v54 - 1;
          v66 = *(_QWORD *)(a1 + 48);
          if (0x8E38E38E38E38E39 * ((*(_QWORD *)(a1 + 56) - v66) >> 3) <= v65)
LABEL_96:
            __break(1u);
          v67 = v66 + 72 * v65;
          v204[0] = *(_DWORD *)(v67 + 64);
          v68 = (id)std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(a1 + 352, v204[0], v204)[3];
          v221 = *(CGRect *)(v67 + 24);
          v167 = v200;
          v222 = CGRectApplyAffineTransform(v221, &v167);
          v69 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v222.origin.x, v222.origin.y, v222.size.width, v222.size.height, width, height);

          memmove(__dst, (const void *)v67, 0x48uLL);
          objc_msgSend(v68, "setTextLine:", __dst);
          objc_msgSend(v68, "setBoundingQuad:", v69);

          v70 = (uint64_t *)v53[1];
          if (v70)
          {
            do
            {
              v71 = v70;
              v70 = (uint64_t *)*v70;
            }
            while (v70);
          }
          else
          {
            do
            {
              v71 = (uint64_t *)v53[2];
              v72 = *v71 == (_QWORD)v53;
              v53 = v71;
            }
            while (!v72);
          }
          v53 = v71;
        }
        while (v71 != (uint64_t *)v173);
      }
      v164 = 0u;
      v165 = 0u;
      v162 = 0u;
      v163 = 0u;
      v120 = v136;
      v73 = objc_msgSend(v120, "countByEnumeratingWithState:objects:count:", &v162, v204, 16);
      if (v73)
      {
        v123 = 0;
        v119 = *(_QWORD *)v163;
        do
        {
          v121 = 0;
          v117 = v73;
          do
          {
            if (*(_QWORD *)v163 != v119)
              objc_enumerationMutation(v120);
            v118 = *(id *)(*((_QWORD *)&v162 + 1) + 8 * v121);
            objc_msgSend(v118, "valueForKey:", CFSTR("Cells"));
            v74 = (void *)objc_claimAutoreleasedReturnValue();
            v160 = 0u;
            v161 = 0u;
            v158 = 0u;
            v159 = 0u;
            v125 = v74;
            v75 = objc_msgSend(v125, "countByEnumeratingWithState:objects:count:", &v158, v203, 16);
            if (v75)
            {
              v122 = *(_QWORD *)v159;
              do
              {
                for (n = 0; n != v75; ++n)
                {
                  if (*(_QWORD *)v159 != v122)
                    objc_enumerationMutation(v125);
                  obja = *(id *)(*((_QWORD *)&v158 + 1) + 8 * n);
                  objc_msgSend(obja, "valueForKey:", CFSTR("Rect"));
                  v76 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v76, "rectValue");
                  v137 = v77;
                  v79 = v78;
                  v81 = v80;
                  v83 = v82;

                  v84 = objc_opt_new();
                  v134 = (void *)v84;
                  v85 = *(_QWORD *)(a1 + 48);
                  v86 = *(_QWORD *)(a1 + 56);
                  while (v85 != v86)
                  {
                    v87 = *(double *)(v85 + 40);
                    v88 = *(double *)(v85 + 48);
                    v89 = *(double *)(v85 + 24);
                    y = *(double *)(v85 + 32);
                    if (v87 < 0.0 || v88 < 0.0)
                    {
                      v223 = CGRectStandardize(*(CGRect *)(v85 + 24));
                      v93 = v223.origin.x + v223.size.width * 0.5;
                      v223.origin.x = v89;
                      v223.origin.y = y;
                      v223.size.width = v87;
                      v92 = 0.5;
                      v223.size.height = v88;
                      v224 = CGRectStandardize(v223);
                      y = v224.origin.y;
                      v88 = v224.size.height;
                    }
                    else
                    {
                      v91 = v87 * 0.5;
                      v92 = 0.5;
                      v93 = v89 + v91;
                    }
                    v213.y = y + v88 * v92;
                    *(_QWORD *)&v225.origin.x = v137;
                    v225.origin.y = v79;
                    v225.size.width = v81;
                    v225.size.height = v83;
                    v213.x = v93;
                    v84 = CGRectContainsPoint(v225, v213);
                    if ((_DWORD)v84)
                    {
                      v157 = *(_DWORD *)(v85 + 64);
                      v94 = (id)std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(a1 + 352, v157, &v157)[3];
                      objc_msgSend(v134, "addObject:", v94);
                      objc_msgSend(v147, "removeObject:", v94);

                    }
                    v85 += 72;
                  }
                  PageLayout::createFineCTLDConfig((PageLayout *)v84);
                  v95 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v126, "groupAndOrderRegions:config:delegate:", v134, v95, 0);
                  v140 = (id)objc_claimAutoreleasedReturnValue();

                  v96 = (void *)objc_opt_new();
                  v155 = 0u;
                  v156 = 0u;
                  v153 = 0u;
                  v154 = 0u;
                  v141 = v140;
                  v97 = objc_msgSend(v141, "countByEnumeratingWithState:objects:count:", &v153, v202, 16);
                  if (v97)
                  {
                    v144 = *(id *)v154;
                    do
                    {
                      for (ii = 0; ii != v97; ++ii)
                      {
                        if (*(id *)v154 != v144)
                          objc_enumerationMutation(v141);
                        v99 = *(id *)(*((_QWORD *)&v153 + 1) + 8 * ii);
                        v149 = 0u;
                        v150 = 0u;
                        v151 = 0u;
                        v152 = 0u;
                        objc_msgSend(v99, "subregions");
                        v100 = (void *)objc_claimAutoreleasedReturnValue();
                        v101 = v75;
                        v102 = objc_msgSend(v100, "countByEnumeratingWithState:objects:count:", &v149, v201, 16);
                        if (v102)
                        {
                          v103 = *(_QWORD *)v150;
                          do
                          {
                            for (jj = 0; jj != v102; ++jj)
                            {
                              if (*(_QWORD *)v150 != v103)
                                objc_enumerationMutation(v100);
                              objc_msgSend(v96, "addObject:", *(_QWORD *)(*((_QWORD *)&v149 + 1) + 8 * jj));
                            }
                            v102 = objc_msgSend(v100, "countByEnumeratingWithState:objects:count:", &v149, v201, 16);
                          }
                          while (v102);
                        }

                        v75 = v101;
                      }
                      v97 = objc_msgSend(v141, "countByEnumeratingWithState:objects:count:", &v153, v202, 16);
                    }
                    while (v97);
                  }

                  v226.size.width = v81 + -0.001;
                  v226.size.height = v83 + -0.001;
                  v148 = v200;
                  *(_QWORD *)&v226.origin.x = v137;
                  v226.origin.y = v79;
                  v227 = CGRectApplyAffineTransform(v226, &v148);
                  v105 = (void *)objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v227.origin.x, v227.origin.y, v227.size.width, v227.size.height, width, height);
                  objc_msgSend(obja, "valueForKey:", CFSTR("Row Index"));
                  v106 = (void *)objc_claimAutoreleasedReturnValue();
                  v107 = objc_msgSend(v106, "intValue");

                  v108 = -[PDFCRGroupRegionCell initWithBoundingQuad:layoutDirection:subregions:parent:groupID:rowIndex:]([PDFCRGroupRegionCell alloc], "initWithBoundingQuad:layoutDirection:subregions:parent:groupID:rowIndex:", v105, 1, v96, 0, v123, v107);
                  objc_msgSend(v147, "addObject:", v108);

                }
                v75 = objc_msgSend(v125, "countByEnumeratingWithState:objects:count:", &v158, v203, 16);
              }
              while (v75);
            }

            ++v123;
            ++v121;
          }
          while (v121 != v117);
          v73 = objc_msgSend(v120, "countByEnumeratingWithState:objects:count:", &v162, v204, 16);
        }
        while (v73);
      }

      v109 = objc_alloc_init(PDFCTLDDelegateForTables);
      objc_msgSend(*(id *)(a1 + 336), "boundingQuad");
      v110 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v110, "boundingBox");
      PageLayout::getOrderedLayout((uint64_t)v3, v147, v109, v111, v112, v113, v114);
      v116 = v115;

      std::__tree<unsigned long>::destroy(v173[0]);
    }
  }
}

void sub_184CC7C64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{

  std::__tree<unsigned long>::destroy((_QWORD *)STACK[0x360]);
  _Unwind_Resume(a1);
}

const void **CGOrderedSetCreate()
{
  const void **v0;
  const __CFAllocator *v1;
  CFMutableArrayRef Mutable;
  BOOL v3;

  v0 = (const void **)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  if (v0)
  {
    v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *v0 = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    Mutable = CFArrayCreateMutable(v1, 0, 0);
    v0[1] = Mutable;
    if (*v0)
      v3 = Mutable == 0;
    else
      v3 = 1;
    if (v3)
    {
      CGOrderedSetRelease(v0);
      return 0;
    }
  }
  return v0;
}

void CGOrderedSetRelease(const void **a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    v3 = a1[1];
    if (v3)
      CFRelease(v3);
    free(a1);
  }
}

void CGOrderedSetAddValue(CFSetRef *a1, const void *a2)
{
  CFIndex Count;

  Count = CFSetGetCount(*a1);
  CFSetAddValue(*a1, a2);
  if (CFSetGetCount(*a1) > Count)
    CFArrayAppendValue(a1[1], a2);
}

unsigned int *CGRenderingStateRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

void CGRenderingStateRelease(void *a1)
{
  unsigned int v1;
  unsigned int v2;

  if (a1)
  {
    do
    {
      v1 = __ldxr((unsigned int *)a1);
      v2 = v1 - 1;
    }
    while (__stxr(v2, (unsigned int *)a1));
    if (!v2)
      free(a1);
  }
}

__n128 CGRenderingStateSetBaseCTM(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = v3;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

double CGRenderingStateGetRenderingResolution(uint64_t a1)
{
  return *(double *)(a1 + 8);
}

uint64_t CGRenderingStateSetRenderingResolution(uint64_t result, double a2, double a3)
{
  double v3;
  double v4;
  double v5;

  v3 = 432.0;
  if (a2 <= 432.0)
    v3 = a2;
  if (a2 >= 72.0)
    v4 = v3;
  else
    v4 = 72.0;
  v5 = 72.0;
  if (a3 >= 72.0)
  {
    v5 = a3;
    if (a3 > 432.0)
      v5 = 432.0;
  }
  *(double *)(result + 8) = v4;
  *(double *)(result + 16) = v5;
  return result;
}

uint64_t CGRenderingStateSetMinInterpolationQuality(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t CGRenderingStateSetMaxInterpolationQuality(uint64_t result, int a2)
{
  *(_DWORD *)(result + 76) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsAcceleration(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t CGRenderingStateSetAllowsAcceleration(uint64_t result, char a2)
{
  *(_BYTE *)(result + 80) = a2;
  return result;
}

uint64_t CGRenderingStateSetAllowsAntialiasing(uint64_t result, char a2)
{
  *(_BYTE *)(result + 81) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsDithering(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 82);
}

uint64_t CGRenderingStateSetAllowsDithering(uint64_t result, char a2)
{
  *(_BYTE *)(result + 82) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontAntialiasing(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 83);
}

uint64_t CGRenderingStateSetAllowsFontAntialiasing(uint64_t result, char a2)
{
  *(_BYTE *)(result + 83) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontSmoothing(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 84);
}

uint64_t CGRenderingStateSetAllowsFontSmoothing(uint64_t result, char a2)
{
  *(_BYTE *)(result + 84) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontSubpixelPositioning(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 85);
}

uint64_t CGRenderingStateSetAllowsFontSubpixelPositioning(uint64_t result, char a2)
{
  *(_BYTE *)(result + 85) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontSubpixelQuantization(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 86);
}

uint64_t CGRenderingStateSetAllowsFontSubpixelQuantization(uint64_t result, char a2)
{
  *(_BYTE *)(result + 86) = a2;
  return result;
}

uint64_t CGRenderingStateGetVectorCapabilities(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 4);
  else
    return 3;
}

uint64_t CGRenderingStateSetVectorCapabilities(uint64_t result, unsigned int a2)
{
  int v2;

  if (result)
  {
    v2 = a2 | ~(-1 << -(char)__clz(a2));
    if (a2 < 2)
      LOBYTE(v2) = a2;
    *(_DWORD *)(result + 4) = v2 & 3;
  }
  return result;
}

void md5_creator_11219(int a1, const __CFString *cf, CC_MD5_CTX *a3)
{
  CFTypeID v5;
  uint64_t v6;
  CC_MD5_CTX *v7;
  CC_LONG v8;
  CFTypeID v9;
  const char *CStringPtr;
  char *v11;
  size_t v12;
  CFTypeID v13;
  CFIndex Length;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD data[130];
  CFRange v23;

  data[129] = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v5 = CFGetTypeID(cf);
    if (md5_creator_cglibrarypredicate != -1)
      dispatch_once(&md5_creator_cglibrarypredicate, &__block_literal_global_14_11237);
    if (v5 == md5_creator_f())
    {
      if (md5_creator_cglibrarypredicate_17 != -1)
        dispatch_once(&md5_creator_cglibrarypredicate_17, &__block_literal_global_19_11238);
      data[0] = md5_creator_f_16(cf);
      data[1] = v6;
      if (a3)
      {
        v7 = a3;
        v8 = 16;
LABEL_9:
        CC_MD5_Update(v7, data, v8);
      }
    }
    else
    {
      v9 = CFGetTypeID(cf);
      if (v9 == CFStringGetTypeID())
      {
        CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
        if (CStringPtr)
        {
          if (a3)
          {
            v11 = (char *)CStringPtr;
            v12 = strlen(CStringPtr);
            md5_update(a3, v11, v12);
          }
        }
        else
        {
          bzero(data, 0x401uLL);
          Length = CFStringGetLength(cf);
          if (!CFStringGetCString(cf, (char *)data, 1024, 0x600u))
          {
            v23.location = 0;
            v23.length = Length;
            CFStringGetBytes(cf, v23, 0x600u, 0x3Fu, 0, (UInt8 *)data, 1024, 0);
          }
          v15 = strlen((const char *)data);
          if (v15)
          {
            if (a3)
              md5_update(a3, (char *)data, v15);
          }
          else
          {
            CGLog(3, (uint64_t)"md5_creator failed for CFString %p", v16, v17, v18, v19, v20, v21, (char)cf);
          }
        }
      }
      else
      {
        v13 = CFGetTypeID(cf);
        if (v13 == CFBooleanGetTypeID())
        {
          LODWORD(data[0]) = *MEMORY[0x1E0C9AE50] == (_QWORD)cf;
          if (a3)
          {
            v7 = a3;
            v8 = 4;
            goto LABEL_9;
          }
        }
      }
    }
  }
}

uint64_t colorsync_smart_null_11226()
{
  return 0;
}

uint64_t __get_cache_block_invoke_11227()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;
  cache_attributes_t attrs;
  pthread_mutexattr_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  get_cache_transform_cache = (uint64_t)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040C6685353uLL);
  if (!get_cache_transform_cache)
    _CGHandleAssert("get_cache_block_invoke", 120, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorSyncTransformCache.c", "transform_cache != NULL", "cache missing", v0, v1, v2, v8);
  v10.__sig = 0;
  *(_QWORD *)v10.__opaque = 0;
  pthread_mutexattr_init(&v10);
  pthread_mutexattr_settype(&v10, 2);
  pthread_mutex_init((pthread_mutex_t *)get_cache_transform_cache, &v10);
  pthread_mutexattr_destroy(&v10);
  attrs = *(cache_attributes_t *)byte_1E165AE90;
  v3 = cache_create("com.apple.CoreGraphics.colorsync_transform_cache", &attrs, (cache_t **)(get_cache_transform_cache + 64));
  if (v3)
    _CGHandleAssert("get_cache_block_invoke", 142, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorSyncTransformCache.c", "cacheError == 0", "err %d", v4, v5, v6, v3);
  return cache_set_count_hint();
}

void colorsync_transform_data_key_release(void *a1)
{
  if (a1)
    free(a1);
}

void colorsync_transform_data_value_release(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

__n128 process_subpath_split(_QWORD **a1, uint64_t a2)
{
  _QWORD *v4;
  unsigned int v5;
  _DWORD *v6;
  __n128 result;
  char *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = *a1;
  v5 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 - 1) < 3)
  {
    v6 = path_list_create(v5, *(_QWORD *)(a2 + 8));
    *(_QWORD *)v6 = v4[2];
LABEL_6:
    v4[2] = v6;
    return result;
  }
  if (v5 != 4)
  {
    if (v5)
      return result;
    v4 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
    *v4 = 0;
    v4[1] = 0xFFFFFFFEFFFFFFFFLL;
    v4[2] = 0;
    v4[3] = 0;
    *v4 = *a1;
    *a1 = v4;
    v6 = path_list_create(*(_DWORD *)a2, *(_QWORD *)(a2 + 8));
    goto LABEL_6;
  }
  v8 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x64A29F66uLL);
  v9 = 0;
  *((_DWORD *)v8 + 4) = 4;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = 1;
  *(_QWORD *)v8 = v4[2];
  v4[2] = v8;
  v10 = v8;
  do
  {
    v11 = v10;
    v10 = (_QWORD *)*v10;
    *v11 = v9;
    v9 = v11;
  }
  while (v10);
  v4[2] = v11;
  result = *(__n128 *)(v11 + 3);
  *(__n128 *)(v8 + 24) = result;
  return result;
}

void subpath_release(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[2];
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      free(v2);
      v2 = v3;
    }
    while (v3);
  }
  free(a1);
}

_DWORD *path_list_create(unsigned int a1, uint64_t a2)
{
  uint64_t v4;
  _DWORD *result;
  uint64_t v6;

  if (a1 > 4)
    return 0;
  v4 = qword_184F7EBC8[a1];
  result = malloc_type_calloc(1uLL, 16 * v4 + 24, 0x64A29F66uLL);
  result[4] = a1;
  *(_QWORD *)result = 0;
  *((_QWORD *)result + 1) = v4;
  if (a2)
  {
    v6 = 0;
    do
    {
      *(_OWORD *)&result[v6 + 6] = *(_OWORD *)(a2 + v6 * 4);
      v6 += 4;
      --v4;
    }
    while (v4);
  }
  return result;
}

id CGPDFPageCopyString(uint64_t a1)
{
  id *v1;
  id *v2;
  id v3;

  if (!a1)
    return 0;
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = v1[5];
  CFRelease(v2);
  return v3;
}

void CGContextSetImageReplacer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      *(_QWORD *)(a1 + 64) = a3;
      *(_QWORD *)(a1 + 72) = a2;
      return;
    }
    v8 = a1;
  }
  else
  {
    v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetImageReplacer", v8, a3, a4, a5, a6, a7, a8);
}

void CGContextSetInterpolationQualityRange(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      v8 = *(_QWORD *)(a1 + 112);
      *(_DWORD *)(v8 + 72) = a2;
      *(_DWORD *)(v8 + 76) = a3;
      return;
    }
    v9 = a1;
  }
  else
  {
    v9 = 0;
  }
  handle_invalid_context((char)"CGContextSetInterpolationQualityRange", v9, a3, a4, a5, a6, a7, a8);
}

void CGContextGetInterpolationQualityRange(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (!a1)
  {
    v8 = 0;
LABEL_9:
    handle_invalid_context((char)"CGContextGetInterpolationQualityRange", v8, (uint64_t)a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v8 = a1;
    goto LABEL_9;
  }
  if (a2)
    *a2 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 72);
  if (a3)
    *a3 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 76);
}

BOOL is_2x_scale(CGContext *a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  double height;
  _BOOL4 v11;
  double v12;
  double v13;
  CGRect v15;
  CGRect v16;
  CGRect v17;

  v15 = CGContextConvertRectToDeviceSpace(a1, *(CGRect *)&a3);
  x = v15.origin.x;
  y = v15.origin.y;
  width = v15.size.width;
  height = v15.size.height;
  v11 = v15.size.height < 0.0 || v15.size.width < 0.0;
  if (v11)
    v15 = CGRectStandardize(v15);
  if (a2)
    v12 = (double)*(unint64_t *)(a2 + 40);
  else
    v12 = 0.0;
  if (fabs(v15.size.width / v12 + -2.0) >= 1.0)
    return 0;
  if (v11)
  {
    v16.origin.x = x;
    v16.origin.y = y;
    v16.size.width = width;
    v16.size.height = height;
    v17 = CGRectStandardize(v16);
    height = v17.size.height;
  }
  v13 = a2 ? (double)*(unint64_t *)(a2 + 48) : 0.0;
  return fabs(height / v13 + -2.0) < 1.0;
}

float CGGetFloatValue(const void *a1)
{
  float v1;
  CFTypeID v3;
  float valuePtr;

  v1 = 0.0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      valuePtr = 0.0;
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloatType, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

void CGContextDrawImages(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int (*v17)(void);
  CGContextRef v18;
  _BOOL4 v19;
  CGFloat height;
  uint64_t v21;
  CGFloat width;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CGImage *v26;
  CGFloat *v27;
  double v28;
  double v29;
  double x;
  double y;
  double v32;
  double v33;
  uint64_t v34;
  double v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  double v40;
  double v41;
  double v42;
  CGContext *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  double v49;
  double v50;
  unint64_t v51;
  double v52;
  double v53;
  unint64_t v54;
  CGColorRef image_pattern;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CGColor *v63;
  CGColor *FillColorAsColor;
  CGColor *v65;
  CGContext *v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  _BOOL4 v73;
  double v74;
  double v75;
  uint64_t v76;
  double v77;
  uint64_t v78;
  double v79;
  CGRect v80;
  CGRect v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;
  CGRect v86;
  CGRect v87;
  CGRect v88;
  CGRect v89;
  CGRect v90;
  CGRect v91;
  CGRect v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;
  CGRect v96;
  CGRect v97;
  CGRect v98;
  CGRect v99;
  CGRect v100;
  CGRect v101;
  CGRect v102;
  CGRect v103;

  if (!c)
  {
    v18 = 0;
LABEL_17:
    handle_invalid_context((char)"CGContextDrawImages", (uint64_t)v18, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v18 = c;
    goto LABEL_17;
  }
  if (a2 && a3 && a5)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = *(_QWORD **)(a3 + 8 * v13);
      if (v15)
      {
        ++v14;
        if (CGImageGetClipPath(v15))
        {
          if (!v14)
            return;
          goto LABEL_19;
        }
      }
      ++v13;
    }
    while (a5 != v13);
    if (!v14)
      return;
    v16 = *((_QWORD *)c + 5);
    if (!v16)
      return;
    v17 = *(unsigned int (**)(void))(v16 + 136);
    if (v17)
    {
      if (v17() != 1006)
        return;
    }
LABEL_19:
    if (a4)
    {
      v19 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)c + 12) + 120) + 16) != 0;
      height = 0.0;
      *(double *)&v21 = INFINITY;
      width = 0.0;
      *(double *)&v23 = INFINITY;
    }
    else
    {
      *(CGRect *)&v23 = CGContextGetClipBoundingBox(c);
      if (v80.size.width == 0.0)
        return;
      height = v80.size.height;
      if (v80.size.height == 0.0)
        return;
      width = v80.size.width;
      v19 = 0;
    }
    v24 = 0;
    if (a5 <= 1)
      v25 = 1;
    else
      v25 = a5;
    v78 = v21;
    v79 = height;
    v76 = v23;
    v77 = width;
    do
    {
      v26 = *(CGImage **)(a3 + 8 * v24);
      if (!v26)
        goto LABEL_31;
      v27 = (CGFloat *)(a2 + 32 * v24);
      v28 = v27[2];
      if (v28 == 0.0)
        goto LABEL_31;
      v29 = v27[3];
      if (v29 == 0.0)
        goto LABEL_31;
      x = *(double *)&v23;
      y = *(double *)&v21;
      v32 = width;
      v33 = height;
      if (a4)
      {
        v34 = a4 + 32 * v24;
        v35 = *(double *)(v34 + 16);
        if (v35 == 0.0)
          goto LABEL_31;
        v36 = *(double *)(v34 + 24);
        if (v36 == 0.0)
          goto LABEL_31;
        v37 = *(_QWORD *)v34;
        v38 = *(_QWORD *)(v34 + 8);
        v81 = CGRectStandardize(*(CGRect *)(&v35 - 2));
        x = v81.origin.x;
        y = v81.origin.y;
        v32 = v81.size.width;
        v33 = v81.size.height;
      }
      v82.origin.x = *v27;
      v82.origin.y = v27[1];
      v82.size.width = v28;
      v82.size.height = v29;
      v83 = CGRectStandardize(v82);
      v39 = v83.origin.x;
      v40 = v83.origin.y;
      v41 = v83.size.width;
      v42 = v83.size.height;
      v101.origin.x = x;
      v101.origin.y = y;
      v101.size.width = v32;
      v101.size.height = v33;
      if (CGRectEqualToRect(v83, v101))
      {
        v84.origin.x = v39;
        v84.origin.y = v40;
        v84.size.width = v41;
        v84.size.height = v42;
        CGContextDrawImage(c, v84, v26);
      }
      else
      {
        v85.origin.x = v39;
        v85.origin.y = v40;
        v85.size.width = v41;
        v85.size.height = v42;
        v102.origin.x = x;
        v102.origin.y = y;
        v102.size.width = v32;
        v102.size.height = v33;
        if (CGRectContainsRect(v85, v102))
        {
          if (!v19)
            goto LABEL_61;
          goto LABEL_41;
        }
        v21 = v78;
        height = v79;
        v23 = v76;
        width = v77;
        if (v41 == 0.0 || v42 == 0.0)
          goto LABEL_31;
        if (v41 < 0.0 || v42 < 0.0)
        {
          v86.origin.x = v39;
          v86.origin.y = v40;
          v86.size.width = v41;
          v86.size.height = v42;
          v48 = (unint64_t)CGRectStandardize(v86);
          v87.origin.x = v39;
          v39 = *(double *)&v48;
          v87.origin.y = v40;
          v87.size.width = v41;
          v87.size.height = v42;
          v88 = CGRectStandardize(v87);
          v40 = v88.origin.y;
        }
        v49 = fabs(v42);
        v50 = fabs(v41);
        if (v32 < 0.0 || v33 < 0.0)
        {
          v89.origin.x = x;
          v74 = v50;
          v75 = v49;
          v89.origin.y = y;
          v89.size.width = v32;
          v89.size.height = v33;
          v39 = v39 + v74 * floor((COERCE_DOUBLE(CGRectStandardize(v89)) - v39) / v74);
          v90.origin.x = x;
          v90.origin.y = y;
          v90.size.width = v32;
          v90.size.height = v33;
          v91 = CGRectStandardize(v90);
          v40 = v40 + v75 * floor((v91.origin.y - v40) / v75);
          v91.origin.x = x;
          v91.origin.y = y;
          v91.size.width = v32;
          v91.size.height = v33;
          v92 = CGRectStandardize(v91);
          v51 = vcvtmd_u64_f64((v92.origin.x + v92.size.width - v39) / v74);
          v92.origin.x = x;
          v92.origin.y = y;
          v92.size.width = v32;
          v92.size.height = v33;
          *(CGRect *)(&v52 - 1) = CGRectStandardize(v92);
          v49 = v75;
        }
        else
        {
          v39 = v39 + v50 * floor((x - v39) / v50);
          v40 = v40 + v49 * floor((y - v40) / v49);
          v51 = vcvtmd_u64_f64((x + v32 - v39) / v50);
          v52 = y;
          v53 = v33;
        }
        v54 = vcvtmd_u64_f64((v52 + v53 - v40) / v49);
        if (!(v51 | v54))
        {
          v94.origin.x = v39;
          v94.origin.y = v40;
          v94.size.width = v41;
          v94.size.height = v42;
          v103.origin.x = x;
          v103.origin.y = y;
          v103.size.width = v32;
          v103.size.height = v33;
          if (CGRectEqualToRect(v94, v103))
          {
            v95.origin.x = v39;
            v95.origin.y = v40;
            v95.size.width = v41;
            v95.size.height = v42;
            CGContextDrawImage(c, v95, v26);
LABEL_81:
            v21 = v78;
            height = v79;
            v23 = v76;
            width = v77;
            goto LABEL_31;
          }
          if (!v19)
          {
LABEL_61:
            CGContextSaveGState(c);
LABEL_62:
            v96.origin.x = x;
            v96.origin.y = y;
            v96.size.width = v32;
            v96.size.height = v33;
            CGContextClipToRect(c, v96);
            v97.origin.x = v39;
            v97.origin.y = v40;
            v97.size.width = v41;
            v97.size.height = v42;
            CGContextDrawImage(c, v97, *(CGImageRef *)(a3 + 8 * v24));
            if (v19)
              CGContextEndTransparencyLayer(c);
            else
              CGContextRestoreGState(c);
            goto LABEL_70;
          }
LABEL_41:
          if (a4)
          {
            v43 = c;
            v44 = *(_QWORD *)&x;
            v45 = *(_QWORD *)&y;
            v46 = *(_QWORD *)&v32;
            v47 = *(_QWORD *)&v33;
          }
          else
          {
            v44 = 0xFFDFFFFFFFFFFFFFLL;
            v46 = 0x7FEFFFFFFFFFFFFFLL;
            v43 = c;
            v45 = 0xFFDFFFFFFFFFFFFFLL;
            v47 = 0x7FEFFFFFFFFFFFFFLL;
          }
          CGContextBeginTransparencyLayerWithRect(v43, *(CGRect *)&v44, 0);
          goto LABEL_62;
        }
        image_pattern = create_image_pattern(c, (uint64_t)v26, v39, v40, v41, v42);
        if (!image_pattern)
        {
          v73 = v19;
          if (v19)
          {
            if (a4)
            {
              v66 = c;
              v67 = *(_QWORD *)&x;
              v68 = *(_QWORD *)&y;
              v69 = *(_QWORD *)&v32;
              v70 = *(_QWORD *)&v33;
            }
            else
            {
              v67 = 0xFFDFFFFFFFFFFFFFLL;
              v69 = 0x7FEFFFFFFFFFFFFFLL;
              v66 = c;
              v68 = 0xFFDFFFFFFFFFFFFFLL;
              v70 = 0x7FEFFFFFFFFFFFFFLL;
            }
            CGContextBeginTransparencyLayerWithRect(v66, *(CGRect *)&v67, 0);
          }
          else
          {
            CGContextSaveGState(c);
          }
          v99.origin.x = x;
          v99.origin.y = y;
          v99.size.width = v32;
          v99.size.height = v33;
          CGContextClipToRect(c, v99);
          v71 = 0;
          do
          {
            v72 = 0;
            do
            {
              v100.origin.x = v39 + v41 * (double)v72;
              v100.origin.y = v40 + v42 * (double)v71;
              v100.size.width = v41;
              v100.size.height = v42;
              CGContextDrawImage(c, v100, *(CGImageRef *)(a3 + 8 * v24));
              ++v72;
            }
            while (v72 <= v51);
            ++v71;
          }
          while (v71 <= v54);
          v19 = v73;
          if (v73)
            CGContextEndTransparencyLayer(c);
          else
            CGContextRestoreGState(c);
          goto LABEL_81;
        }
        v63 = image_pattern;
        FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor((uint64_t)c, v56, v57, v58, v59, v60, v61, v62);
        v65 = FillColorAsColor;
        if (FillColorAsColor)
        {
          CFRetain(FillColorAsColor);
          CGContextSetFillColorWithColor(c, v63);
          v93.origin.x = x;
          v93.origin.y = y;
          v93.size.width = v32;
          v93.size.height = v33;
          CGContextFillRect(c, v93);
          CGContextSetFillColorWithColor(c, v65);
          CFRelease(v65);
        }
        else
        {
          CGContextSetFillColorWithColor(c, v63);
          v98.origin.x = x;
          v98.origin.y = y;
          v98.size.width = v32;
          v98.size.height = v33;
          CGContextFillRect(c, v98);
          CGContextSetFillColorWithColor(c, 0);
        }
        CFRelease(v63);
      }
LABEL_70:
      v21 = v78;
      height = v79;
      v23 = v76;
      width = v77;
LABEL_31:
      ++v24;
    }
    while (v24 != v25);
  }
}

CGColorRef create_image_pattern(CGContext *a1, uint64_t a2, CGFloat a3, CGFloat y, CGFloat a5, CGFloat a6)
{
  _BOOL4 v12;
  double width;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  double v40;
  CGFloat v41;
  double PatternPhase;
  double v43;
  CGPatternRef v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  CGPattern *v52;
  CGColorSpace *ColorSpace;
  const CGFloat *Components;
  CGColorSpace *Pattern;
  CGColorSpace *v56;
  CGColorRef v57;
  uint64_t FillColorAsColor;
  unint64_t v59;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  CGAffineTransform v68;
  CGAffineTransform v69;
  CGAffineTransform v70;
  float64x2_t v71;
  float64x2_t v72;
  __int128 v73;
  uint64_t v74;
  CGRect v75;
  CGRect v76;
  CGRect v77;
  CGRect v78;
  CGRect v79;

  v12 = a6 < 0.0 || a5 < 0.0;
  width = a5;
  if (v12)
  {
    v75 = CGRectStandardize(*(CGRect *)&a3);
    width = v75.size.width;
  }
  if (a2)
    v14 = (double)*(unint64_t *)(a2 + 40);
  else
    v14 = 0.0;
  v15 = a6;
  if (v12)
  {
    v76.origin.x = a3;
    v76.origin.y = y;
    v76.size.width = a5;
    v76.size.height = a6;
    *(CGRect *)(&v15 - 3) = CGRectStandardize(v76);
  }
  if (a2)
    v16 = (double)*(unint64_t *)(a2 + 48);
  else
    v16 = 0.0;
  v17 = width / v14;
  v18 = v15 / v16;
  if (v12)
  {
    v77.origin.x = a3;
    v77.origin.y = y;
    v77.size.width = a5;
    v77.size.height = a6;
    *(_QWORD *)&v19 = (unint64_t)CGRectStandardize(v77);
    v78.origin.x = a3;
    v78.origin.y = y;
    v78.size.width = a5;
    v78.size.height = a6;
    v79 = CGRectStandardize(v78);
    y = v79.origin.y;
  }
  else
  {
    v19 = a3;
  }
  v74 = 0;
  CGContextGetCTM(&v70, a1);
  v20 = v70.c * 0.0 + v17 * v70.a;
  v21 = v70.d * 0.0 + v17 * v70.b;
  v22 = v18 * v70.c + v70.a * 0.0;
  v23 = v18 * v70.d + v70.b * 0.0;
  v24 = v70.tx + v70.c * y + v19 * v70.a;
  v25 = v70.d * y + v19 * v70.b + v70.ty;
  CGContextGetBaseCTM((uint64_t)a1, v26, v27, v28, v29, v30, v31, (uint64_t)&v71);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v71, (float64x2_t)xmmword_185004990), (int32x4_t)vceqq_f64(v72, (float64x2_t)xmmword_185004A20))))) & 1) != 0|| *(double *)&v73 != 0.0|| *((double *)&v73 + 1) != 0.0)
  {
    *(float64x2_t *)&v68.a = v71;
    *(float64x2_t *)&v68.c = v72;
    *(_OWORD *)&v68.tx = v73;
    CGAffineTransformInvert(&v69, &v68);
    v39 = v21 * v69.c;
    v21 = v21 * v69.d + v20 * v69.b;
    v20 = v39 + v20 * v69.a;
    v40 = v23 * v69.c;
    v23 = v23 * v69.d + v22 * v69.b;
    v22 = v40 + v22 * v69.a;
    v41 = v69.d * v25 + v24 * v69.b;
    v24 = v69.tx + v69.c * v25 + v24 * v69.a;
    v25 = v41 + v69.ty;
  }
  PatternPhase = CGContextGetPatternPhase((uint64_t)a1, v32, v33, v34, v35, v36, v37, v38);
  v68.a = v20;
  v68.b = v21;
  v68.c = v22;
  v68.d = v23;
  v68.tx = v24 - PatternPhase;
  v68.ty = v25 - v43;
  v44 = CGPatternCreateWithImage2((unint64_t *)a2, &v68, kCGPatternTilingNoDistortion);
  if (v44)
  {
    v52 = v44;
    if (a2 && (*(_BYTE *)(a2 + 39) & 2) != 0)
    {
      FillColorAsColor = CGContextGetFillColorAsColor((uint64_t)a1, v45, v46, v47, v48, v49, v50, v51);
      if (!FillColorAsColor)
        goto LABEL_31;
      v59 = FillColorAsColor;
      if (FillColorAsColor >= 1)
      {
        if (*(_QWORD *)(FillColorAsColor + 32))
          goto LABEL_31;
      }
      Components = CGColorGetComponents((CGColorRef)FillColorAsColor);
      if ((v59 & 0x8000000000000000) != 0)
        ColorSpace = CGTaggedColorGetColorSpace(v59, v61, v62, v63, v64, v65, v66, v67);
      else
        ColorSpace = *(CGColorSpace **)(v59 + 24);
    }
    else
    {
      ColorSpace = 0;
      v74 = 0x3FF0000000000000;
      Components = (const CGFloat *)&v74;
    }
    Pattern = CGColorSpaceCreatePattern(ColorSpace);
    if (Pattern)
    {
      v56 = Pattern;
      v57 = CGColorCreateWithPattern(Pattern, v52, Components);
      CGColorSpaceRelease(v56);
LABEL_32:
      CFRelease(v52);
      return v57;
    }
LABEL_31:
    v57 = 0;
    goto LABEL_32;
  }
  return 0;
}

void CGContextDrawImageFromRect(CGContext *a1, CGImageRef image, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9, __n128 a10)
{
  uint64_t v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  unsigned int (*v21)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128);
  CGImage *v22;
  CGImage *v23;
  CGRect v24;
  CGRect v25;

  v11 = *((_QWORD *)a1 + 5);
  if (v11)
  {
    v12 = a10.n128_f64[0];
    v13 = a9.n128_f64[0];
    v14 = a8.n128_f64[0];
    v15 = a7.n128_f64[0];
    v17 = a6.n128_f64[0];
    v18 = a5.n128_f64[0];
    v19 = a4.n128_f64[0];
    v20 = a3.n128_f64[0];
    v21 = *(unsigned int (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))(v11 + 144);
    if (!v21 || v21(a3, a4, a5, a6, a7, a8, a9, a10) == 1006)
    {
      v24.origin.x = v15;
      v24.origin.y = v14;
      v24.size.width = v13;
      v24.size.height = v12;
      v22 = CGImageCreateWithImageInRect(image, v24);
      if (v22)
      {
        v23 = v22;
        v25.origin.x = v20;
        v25.origin.y = v19;
        v25.size.width = v18;
        v25.size.height = v17;
        CGContextDrawImage(a1, v25, v22);
        CFRelease(v23);
      }
    }
  }
}

uint64_t CGContextDrawImageApplyingToneMapping(CGContext *c, CGImageRef image, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  CGImageRef v13;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CGImage *CopyWithProtectedDataProvider;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CGImage *v33;
  uint64_t v34;
  unsigned int (*v35)(double, double, double, double);
  BOOL v36;
  CGContextRef v37;

  if (!c)
  {
    v37 = 0;
LABEL_14:
    handle_invalid_context((char)"CGContextDrawImageApplyingToneMapping", (uint64_t)v37, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v37 = c;
    goto LABEL_14;
  }
  v13 = image;
  if ((_DWORD)a3)
  {
    if (CGImageGetHeadroomInfo(image, 0) < 1.0)
    {
      CGPostError((uint64_t)"%s: image doesn't have a valid headroom value", v18, v19, v20, v21, v22, v23, v24, (char)"CGContextDrawImageApplyingToneMapping");
    }
    else
    {
      if (v13)
        CFRetain(v13);
      CopyWithProtectedDataProvider = CGImageCreateCopyWithProtectedDataProvider(v13);
      if (CopyWithProtectedDataProvider)
      {
        v33 = CopyWithProtectedDataProvider;
        CFRelease(v13);
        v13 = v33;
      }
      v34 = *((_QWORD *)c + 5);
      v36 = v34
         && (v35 = *(unsigned int (**)(double, double, double, double))(v34 + 272)) != 0
         && v35(a9, a10, a11, a12) == 0;
      if (v13)
        CFRelease(v13);
      if (v36)
        return 1;
    }
    CGPostError((uint64_t)"%s failed", v26, v27, v28, v29, v30, v31, v32, (char)"CGContextDrawImageApplyingToneMapping");
    return 0;
  }
  CGContextDrawImage(c, *(CGRect *)&a9, image);
  return 1;
}

uint64_t CGDataProviderCreateWithSoftMaskAndMatte(_QWORD *a1, _QWORD *a2, vImagePixelCount a3, CGDataProvider *a4, CGImage *a5, unsigned int a6)
{
  CGImage *CopyWithColorSpace;
  _BYTE *v11;
  _BYTE *v12;
  CGImage *Mask;
  unsigned int UpscaledComponentType;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double *Matte;
  double *v20;
  CGColorSpaceRef ColorSpace;
  uint64_t v22;
  uint64_t v23;
  int Type;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  uint64_t i;
  _WORD *v34;
  double *v35;
  double v36;
  double *v37;
  double v38;
  double *v39;
  double v40;
  float v41;
  double *v42;
  double v43;
  char *DataProviderInternal;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  CFIndex *v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  _QWORD *v61;
  uint64_t *v62;
  unint64_t v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t *v68;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  __CFData *v76;
  CGDataProvider *v77;
  uint64_t v78;
  _BOOL4 v80;
  _QWORD *v81;
  unsigned int v82;
  CGDataProvider *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  __CFData *v88;
  CGDataProvider *v89;
  uint64_t v90;
  CGDataProvider *v91;
  CGColorSpaceRef v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  CGColorSpaceRef v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  CGColorSpaceRef *v102;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *Cache;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char v113;
  CGColorSpaceRef v114;
  uint64_t v115;
  int v116;
  uint64_t BitsPerComponent;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  CGColorSpaceRef v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  _QWORD *v143;
  vImagePixelCount v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  unint64_t v194;
  char *v195;
  char *v196;
  char *v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  vImagePixelCount v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t SequentialWithInternalCallbacks;
  CGDataProvider *v213;
  uint64_t v214;
  CGDataProvider *v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  unint64_t v224;
  unint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t BitsPerPixel;
  unint64_t v229;
  uint64_t v230;
  unint64_t v231;
  _QWORD *v232;
  size_t v233;
  __int128 v234;
  unint64_t v236;
  unint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  size_t v246;
  unint64_t v247;
  unint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  size_t v257;
  void *v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  const __CFString *v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  const __CFData *v275;
  uint64_t v276;
  size_t v277;
  const __CFData *v278;
  const unsigned __int8 *BytePtr;
  CGColorSpace *DeviceN;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  _QWORD *TintTransform;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t Colorants;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  char v303;
  uint64_t v304;
  uint64_t v305;
  _BOOL4 v306;
  uint64_t v307;
  uint64_t *v308;
  uint64_t *v309;
  unint64_t v310;
  CGImage *cf;
  _QWORD *v312;
  unint64_t v313;
  unsigned int v314;
  uint64_t v315;
  uint64_t Names;
  CGDataProvider *v317;
  vImagePixelCount v318;
  __int128 v320;
  size_t size[2];
  _OWORD v322[4];
  __int128 v323;
  __int128 v324;
  _OWORD v325[20];
  _BYTE __dst[349];
  _OWORD __src[17];
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  __int128 v332;
  __int128 v333;
  __int128 v334;
  __int128 v335;
  __int128 v336;
  __int128 v337;
  __int128 v338;
  __int128 v339;
  __int128 v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  uint64_t v344;

  CopyWithColorSpace = a5;
  v344 = *MEMORY[0x1E0C80C00];
  if (!CGImageGetMask(a5))
  {
    CGImageGetMask(CopyWithColorSpace);
    _CGHandleAssert("CGDataProviderCreateWithSoftMaskAndMatte", 1214, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image != NULL && CGImageGetMask(image) != NULL", "image %p  mask %p", v300, v301, v302, (char)CopyWithColorSpace);
  }
  v11 = malloc_type_calloc(1uLL, 0x518uLL, 0xA3729uLL);
  if (!v11)
    return 0;
  v12 = v11;
  v312 = a1;
  Mask = (CGImage *)CGImageGetMask(CopyWithColorSpace);
  UpscaledComponentType = CGImageGetUpscaledComponentType(CopyWithColorSpace);
  v15 = CGImageGetUpscaledComponentType(Mask);
  if (UpscaledComponentType > 5 || ((1 << UpscaledComponentType) & 0x36) == 0)
    _CGHandleAssert("choose_component_type", 1120, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_component_type == kCGImageComponent8BitInteger || image_component_type == kCGImageComponent16BitInteger || image_component_type == kCGImageComponent16BitFloat || image_component_type == kCGImageComponent32BitFloat", "component type %d", v16, v17, v18, UpscaledComponentType);
  if (v15 > 5 || ((1 << v15) & 0x36) == 0)
    _CGHandleAssert("choose_component_type", 1125, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_component_type == kCGImageComponent8BitInteger || smask_component_type == kCGImageComponent16BitInteger || smask_component_type == kCGImageComponent16BitFloat || smask_component_type == kCGImageComponent32BitFloat", "mask component type %d", v16, v17, v18, v15);
  v317 = a4;
  switch(UpscaledComponentType)
  {
    case 1u:
      UpscaledComponentType = v15;
      break;
    case 2u:
      if (v15 - 3 >= 0xFFFFFFFE)
        UpscaledComponentType = 2;
      else
        UpscaledComponentType = v15;
      break;
    case 4u:
      break;
    case 5u:
      if (v15 == 4)
        UpscaledComponentType = 4;
      else
        UpscaledComponentType = 5;
      break;
    default:
      _CGHandleAssert("choose_component_type", 1147, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v16, v17, v18, v303);
  }
  Matte = (double *)CGImageGetMatte(CopyWithColorSpace);
  if (Matte)
  {
    v20 = Matte;
    ColorSpace = CGImageGetColorSpace(CopyWithColorSpace);
    v22 = (uint64_t)ColorSpace;
    if (ColorSpace)
      v23 = *(_QWORD *)(*((_QWORD *)ColorSpace + 3) + 40);
    else
      v23 = 0;
    v12[1065] = 1;
    Type = CGColorSpaceGetType(ColorSpace);
    if ((Type - 10) < 2 || Type == 6)
    {
      if (!v22 || !*(_BYTE *)(*(_QWORD *)(v22 + 24) + 13))
      {
        v32 = (_BYTE *)CGColorSpaceICCGetRange(v22, v25, v26, v27, v28, v29, v30, v31);
        if (v32)
          goto LABEL_31;
      }
    }
    else if (Type == 5)
    {
      memset(v325, 0, 64);
      v323 = 0u;
      v324 = 0u;
      CGColorSpaceGetLabData(v22, v29, v30, v31, &v323);
      *(_OWORD *)__dst = xmmword_185004E50;
      *(_OWORD *)&__dst[16] = v325[1];
      *(_OWORD *)&__dst[32] = v325[2];
LABEL_30:
      v32 = __dst;
      goto LABEL_31;
    }
    if (!v23)
      goto LABEL_30;
    for (i = 0; i != v23; ++i)
    {
      v32 = __dst;
      *(_OWORD *)&__dst[16 * i] = xmmword_185004A20;
    }
LABEL_31:
    v34 = v12 + 1072;
    switch(UpscaledComponentType)
    {
      case 1u:
        if (v23)
        {
          v35 = (double *)(v32 + 8);
          do
          {
            v36 = *v20++;
            *(_BYTE *)v34 = (int)fmax(fmin(round((v36 - *(v35 - 1)) / (*v35 - *(v35 - 1)) * 255.0), 255.0), 0.0);
            v34 = (_WORD *)((char *)v34 + 1);
            v35 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      case 2u:
        if (v23)
        {
          v37 = (double *)(v32 + 8);
          do
          {
            v38 = *v20++;
            *v34++ = (int)fmax(fmin(round((v38 - *(v37 - 1)) / (*v37 - *(v37 - 1)) * 65535.0), 65535.0), 0.0);
            v37 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      case 4u:
        if (v23)
        {
          v39 = (double *)(v32 + 8);
          do
          {
            v40 = *v20++;
            v41 = (v40 - *(v39 - 1)) / (*v39 - *(v39 - 1));
            *(float *)v34 = v41;
            v34 += 2;
            v39 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      case 5u:
        if (v23)
        {
          v42 = (double *)(v32 + 8);
          do
          {
            v43 = *v20++;
            _S0 = (v43 - *(v42 - 1)) / (*v42 - *(v42 - 1));
            __asm { FCVT            H0, S0 }
            *v34++ = LOWORD(_S0);
            v42 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      default:
        _CGHandleAssert("copy_matte", 1109, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v29, v30, v31, v303);
    }
  }
  DataProviderInternal = CGImageGetDataProviderInternal((char *)CopyWithColorSpace, 0);
  v49 = CGImageGetDataProviderInternal((char *)Mask, 0);
  if (!DataProviderInternal)
    goto LABEL_223;
  v53 = (CFIndex *)v49;
  v54 = *((_DWORD *)DataProviderInternal + 5) & 0xFFFFFFFD;
  if (!v49)
    goto LABEL_223;
  if (CopyWithColorSpace)
  {
    v55 = *((_QWORD *)CopyWithColorSpace + 9);
    v56 = *((_QWORD *)CopyWithColorSpace + 8) * *((_QWORD *)CopyWithColorSpace + 5);
  }
  else
  {
    v55 = 0;
    v56 = 0;
  }
  v57 = (uint64_t *)Mask;
  if (Mask)
  {
    v58 = *((_QWORD *)Mask + 9);
    v59 = *((_QWORD *)Mask + 8) * *((_QWORD *)Mask + 5);
  }
  else
  {
    v58 = 0;
    v59 = 0;
  }
  v314 = UpscaledComponentType;
  v60 = v56 + 7;
  v61 = a2;
  if (CopyWithColorSpace)
    v62 = (uint64_t *)*((_QWORD *)CopyWithColorSpace + 6);
  else
    v62 = 0;
  v63 = v59 + 7;
  v64 = *((_DWORD *)v49 + 5) & 0xFFFFFFFD;
  v65 = v55 - (v60 >> 3);
  v66 = v57;
  if (v57)
    v66 = (uint64_t *)v57[6];
  v67 = v58 - (v63 >> 3);
  v318 = a3;
  if ((v54 != 0) == (v64 != 0) && v62 == v66 && v65 == v67)
  {
    v306 = (*((_DWORD *)DataProviderInternal + 5) & 0xFFFFFFFD) != 0;
    cf = 0;
    v68 = 0;
    v304 = v55 - (v60 >> 3);
    v305 = v304;
  }
  else
  {
    if (v65)
      _ZF = v65 == v67;
    else
      _ZF = 1;
    v70 = !_ZF;
    if (v54 || v70)
    {
      if (CopyWithColorSpace)
      {
        v72 = *((_QWORD *)CopyWithColorSpace + 5);
        v73 = *((_QWORD *)CopyWithColorSpace + 6);
        v74 = *((_QWORD *)CopyWithColorSpace + 8);
        v75 = *((_QWORD *)CopyWithColorSpace + 9);
      }
      else
      {
        v74 = 0;
        v72 = 0;
        v73 = 0;
        v75 = 0;
      }
      v76 = CGDataProviderCopyPixelData((CFIndex *)DataProviderInternal, v72, v73, v74, v75);
      v77 = CGDataProviderCreateWithCFData(v76);
      if (v76)
        CFRelease(v76);
      if (CopyWithColorSpace)
        v78 = *((_QWORD *)CopyWithColorSpace + 8) * *((_QWORD *)CopyWithColorSpace + 5);
      else
        v78 = 0;
      CopyWithColorSpace = (CGImage *)copy_image_with_new_provider(CopyWithColorSpace, v77, (unint64_t)(v78 + 7) >> 3);
      CGDataProviderRelease(v77);
      v71 = 0;
      cf = CopyWithColorSpace;
    }
    else
    {
      cf = 0;
      v71 = v55 - (v60 >> 3);
    }
    v80 = v65 != v67 && v67 != 0;
    v304 = v71;
    if (v64 || v80)
    {
      v81 = v61;
      if (v57)
      {
        v84 = v57[5];
        v85 = v57[6];
        v86 = v57[8];
        v87 = v57[9];
      }
      else
      {
        v86 = 0;
        v84 = 0;
        v85 = 0;
        v87 = 0;
      }
      v82 = v314;
      v88 = CGDataProviderCopyPixelData(v53, v84, v85, v86, v87);
      v89 = CGDataProviderCreateWithCFData(v88);
      if (v88)
        CFRelease(v88);
      if (v57)
        v90 = v57[8] * v57[5];
      else
        v90 = 0;
      v83 = v317;
      v68 = copy_image_with_new_provider((CGImage *)v57, v89, (unint64_t)(v90 + 7) >> 3);
      CGDataProviderRelease(v89);
      v306 = 0;
      v305 = 0;
      v57 = v68;
      goto LABEL_101;
    }
    v306 = 0;
    v68 = 0;
    v305 = v67;
  }
  v81 = v61;
  v82 = v314;
  v83 = v317;
LABEL_101:
  if (CGImageGetAlphaInfo(CopyWithColorSpace))
    v12[1064] = 1;
  if (!v312)
  {
    v308 = 0;
    goto LABEL_129;
  }
  v91 = v83;
  v92 = CGImageGetColorSpace(CopyWithColorSpace);
  v93 = CGColorSpaceGetType(v92);
  v97 = v93;
  v98 = v92;
  if (v93 == 8)
    goto LABEL_112;
  if (v93 != 7)
    goto LABEL_128;
  if (v92 && (v99 = *((_QWORD *)v92 + 3), (*(_DWORD *)(v99 + 24) - 5) <= 1))
    v98 = **(CGColorSpaceRef **)(v99 + 88);
  else
    v98 = 0;
  if (CGColorSpaceGetType(v98) == 8)
  {
LABEL_112:
    if (v98)
    {
      v100 = *((_QWORD *)v98 + 3);
      v101 = *(_DWORD *)(v100 + 20);
      switch(v101)
      {
        case 6:
          v102 = (CGColorSpaceRef *)(*(_QWORD *)(v100 + 88) + 56);
          goto LABEL_119;
        case 10:
          v102 = (CGColorSpaceRef *)(*(_QWORD *)(v100 + 88) + 48);
          goto LABEL_119;
        case 8:
          v102 = (CGColorSpaceRef *)(*(_QWORD *)(v100 + 88) + 8);
LABEL_119:
          v98 = *v102;
          goto LABEL_120;
      }
    }
LABEL_128:
    v308 = 0;
    v83 = v91;
    goto LABEL_129;
  }
LABEL_120:
  if (!v98)
    goto LABEL_128;
  v103 = *((_QWORD *)v98 + 3);
  if (*(_BYTE *)(v103 + 10))
  {
LABEL_122:
    v104 = (_QWORD *)color_transform_create(v98, 0);
LABEL_123:
    v308 = 0;
    goto LABEL_124;
  }
  v266 = *(_QWORD *)(v103 + 40);
  switch(v266)
  {
    case 1:
      v267 = CFSTR("kCGColorSpaceGenericGrayGamma2_2");
      break;
    case 4:
      v267 = CFSTR("kCGColorSpaceGenericCMYK");
      break;
    case 3:
      v267 = CFSTR("kCGColorSpaceSRGB");
      break;
    default:
      _CGHandleAssert("create_intermediate_color_transform_if_needed", 959, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v94, v95, v96, v303);
  }
  v98 = CGColorSpaceCreateWithName(v267);
  if (v97 == 8)
  {
    if (v92)
      v310 = *(_QWORD *)(*((_QWORD *)v92 + 3) + 40);
    else
      v310 = 0;
    Names = CGColorSpaceGetNames((uint64_t)v92, v268, v269, v270, v271, v272, v273, v274);
    TintTransform = (_QWORD *)CGColorSpaceGetTintTransform((uint64_t)v92, v281, v282, v283, v284, v285, v286, v287);
    Colorants = CGColorSpaceGetColorants((uint64_t)v92, v289, v290, v291, v292, v293, v294, v295);
    DeviceN = (CGColorSpace *)CGColorSpaceCreateDeviceN(v310, Names, v98, TintTransform, Colorants, v297, v298, v299);
  }
  else
  {
    if (v97 != 7)
      goto LABEL_122;
    v275 = CGColorSpaceCopyColorTable((uint64_t)v92);
    if (v92 && (v276 = *((_QWORD *)v92 + 3), *(_DWORD *)(v276 + 24) == 5))
      v277 = *(_QWORD *)(*(_QWORD *)(v276 + 88) + 8);
    else
      v277 = -1;
    v278 = v275;
    BytePtr = CFDataGetBytePtr(v275);
    DeviceN = CGColorSpaceCreateIndexed(v98, v277, BytePtr);
    CFRelease(v278);
  }
  v104 = (_QWORD *)color_transform_create(v98, 0);
  if (!DeviceN)
    goto LABEL_123;
  CopyWithColorSpace = CGImageCreateCopyWithColorSpace(CopyWithColorSpace, DeviceN);
  CGColorSpaceRelease(DeviceN);
  v308 = (uint64_t *)CopyWithColorSpace;
LABEL_124:
  v83 = v91;
  if (v104)
  {
    Cache = CGColorTransformGetCache(v104);
    v113 = 0;
    if (!Cache)
      goto LABEL_127;
    v114 = (CGColorSpaceRef)Cache[2];
    if (!v114)
      goto LABEL_127;
    goto LABEL_130;
  }
LABEL_129:
  v114 = CGImageGetColorSpace(CopyWithColorSpace);
  v104 = 0;
  v113 = 1;
  if (!v114)
  {
LABEL_127:
    v115 = 0;
    goto LABEL_131;
  }
LABEL_130:
  v115 = *(_QWORD *)(*((_QWORD *)v114 + 3) + 40);
LABEL_131:
  v315 = v115;
  v309 = v68;
  if (v82 - 2 > 3)
    v116 = 0;
  else
    v116 = dword_185005230[v82 - 2];
  BitsPerComponent = CGPixelComponentGetBitsPerComponent(v82, v106, v107, v108, v109, v110, v111, v112);
  v328 = 0u;
  v329 = 0u;
  v330 = 0u;
  v331 = 0u;
  v332 = 0u;
  v333 = 0u;
  v334 = 0u;
  v335 = 0u;
  v336 = 0u;
  v337 = 0u;
  v338 = 0u;
  v339 = 0u;
  v340 = 0u;
  v341 = 0u;
  v342 = 0u;
  v343 = 0u;
  if ((unint64_t)(BitsPerComponent - 33) <= 0xFFFFFFFFFFFFFFDFLL)
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v118, v119, v120, BitsPerComponent);
  *(_QWORD *)__dst = v82;
  v307 = BitsPerComponent;
  *(_QWORD *)&__dst[8] = BitsPerComponent;
  *(_QWORD *)&__dst[16] = v315;
  *(_DWORD *)&__dst[24] = 3;
  *(_DWORD *)&__dst[28] = v116;
  memset(&__dst[32], 0, 272);
  v121 = CGDataProviderCreateForDestinationWithImage(v104, __dst, v318, v83, CopyWithColorSpace, a6, 1);
  *((_QWORD *)v12 + 1) = v121;
  if (!v121)
  {
    if (cf)
      CFRelease(cf);
    v142 = v68;
    if (!v68)
      goto LABEL_179;
    goto LABEL_178;
  }
  memcpy(__dst, v81, 0x130uLL);
  *((_QWORD *)v12 + 49) = CGImageGetImageBytesPerRowForPixelInfo((uint64_t)CopyWithColorSpace, v318, (uint64_t)__dst, v122, v123, v124, v125, v126);
  memcpy(__dst, v81, 0x130uLL);
  *((_QWORD *)v12 + 50) = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v127, v128, v129, v130, v131, v132, v133)
                         * v318
                         + 7) >> 3;
  if ((v113 & 1) != 0)
  {
    v134 = CGImageGetColorSpace(CopyWithColorSpace);
    goto LABEL_144;
  }
  v143 = CGColorTransformGetCache(v104);
  if (v143)
  {
    v134 = (CGColorSpaceRef)v143[2];
LABEL_144:
    v144 = v318;
    *((_QWORD *)v12 + 6) = v134;
    if (v134)
      CFRetain(v134);
    if (v104)
      goto LABEL_147;
    goto LABEL_148;
  }
  *((_QWORD *)v12 + 6) = 0;
  v144 = v318;
  if (v104)
LABEL_147:
    CFRelease(v104);
LABEL_148:
  v145 = CGPixelComponentGetBitsPerComponent(v82, v135, v136, v137, v138, v139, v140, v141);
  v149 = v145;
  memset(__src, 0, 268);
  if ((unint64_t)(v145 - 33) <= 0xFFFFFFFFFFFFFFDFLL)
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v146, v147, v148, v145);
  *(_QWORD *)__dst = v82;
  *(_QWORD *)&__dst[8] = v145;
  *(_QWORD *)&__dst[16] = 1;
  *(_DWORD *)&__dst[24] = 0;
  *(_DWORD *)&__dst[28] = v116;
  memset(&__dst[32], 0, 272);
  v150 = CGDataProviderCreateForDestinationWithImage(0, __dst, v144, v83, v57, a6, 1);
  *((_QWORD *)v12 + 2) = v150;
  if (!v150)
  {
    v215 = (CGDataProvider *)*((_QWORD *)v12 + 1);
LABEL_172:
    CGDataProviderRelease(v215);
    if (cf)
      CFRelease(cf);
    if (v309)
      CFRelease(v309);
    if (!v308)
      goto LABEL_179;
    v142 = v308;
LABEL_178:
    CFRelease(v142);
LABEL_179:
    free(v12);
    return 0;
  }
  v156 = v340;
  v157 = v341;
  v158 = v341;
  *(_OWORD *)(v12 + 648) = v340;
  *(_OWORD *)(v12 + 664) = v157;
  v159 = v342;
  v160 = v343;
  v161 = v343;
  *(_OWORD *)(v12 + 680) = v342;
  *(_OWORD *)(v12 + 696) = v160;
  v162 = v336;
  v163 = v337;
  v164 = v337;
  *(_OWORD *)(v12 + 584) = v336;
  *(_OWORD *)(v12 + 600) = v163;
  v165 = v338;
  v166 = v339;
  v167 = v339;
  *(_OWORD *)(v12 + 616) = v338;
  *(_OWORD *)(v12 + 632) = v166;
  v168 = v332;
  v169 = v333;
  v170 = v333;
  *(_OWORD *)(v12 + 520) = v332;
  *(_OWORD *)(v12 + 536) = v169;
  v171 = v334;
  v172 = v335;
  v173 = v335;
  *(_OWORD *)(v12 + 552) = v334;
  *(_OWORD *)(v12 + 568) = v172;
  v174 = v328;
  v175 = v329;
  v176 = v329;
  *(_OWORD *)(v12 + 456) = v328;
  *(_OWORD *)(v12 + 472) = v175;
  v177 = v330;
  v178 = v331;
  v179 = v331;
  *(_OWORD *)(v12 + 488) = v330;
  *(_OWORD *)(v12 + 504) = v178;
  *((_OWORD *)v12 + 48) = 0u;
  *((_OWORD *)v12 + 49) = 0u;
  *((_OWORD *)v12 + 50) = 0u;
  *((_OWORD *)v12 + 51) = 0u;
  *((_OWORD *)v12 + 52) = 0u;
  *((_OWORD *)v12 + 53) = 0u;
  *((_OWORD *)v12 + 54) = 0u;
  *((_OWORD *)v12 + 55) = 0u;
  *((_OWORD *)v12 + 56) = 0u;
  *((_OWORD *)v12 + 57) = 0u;
  *((_OWORD *)v12 + 58) = 0u;
  *((_OWORD *)v12 + 59) = 0u;
  *((_OWORD *)v12 + 60) = 0u;
  *((_OWORD *)v12 + 61) = 0u;
  *((_OWORD *)v12 + 62) = 0u;
  *((_OWORD *)v12 + 63) = 0u;
  *((_OWORD *)v12 + 64) = 0u;
  *(_OWORD *)&__dst[240] = v156;
  *(_OWORD *)&__dst[256] = v158;
  *(_OWORD *)&__dst[272] = v159;
  *(_OWORD *)&__dst[288] = v161;
  *(_OWORD *)&__dst[176] = v162;
  *(_OWORD *)&__dst[192] = v164;
  *(_OWORD *)&__dst[208] = v165;
  *(_OWORD *)&__dst[224] = v167;
  *(_OWORD *)&__dst[112] = v168;
  *(_OWORD *)&__dst[128] = v170;
  *(_OWORD *)&__dst[144] = v171;
  *(_OWORD *)&__dst[160] = v173;
  *(_OWORD *)&__dst[48] = v174;
  *(_OWORD *)&__dst[64] = v176;
  *((_DWORD *)v12 + 102) = v82;
  *((_DWORD *)v12 + 103) = 0;
  *((_QWORD *)v12 + 52) = v307;
  *((_QWORD *)v12 + 53) = v315;
  *((_DWORD *)v12 + 108) = 3;
  *((_DWORD *)v12 + 109) = v116;
  *((_QWORD *)v12 + 55) = 0;
  *((_QWORD *)v12 + 56) = 0;
  *((_DWORD *)v12 + 184) = v82;
  *((_DWORD *)v12 + 185) = 0;
  *((_QWORD *)v12 + 93) = v149;
  *((_QWORD *)v12 + 94) = 1;
  *((_DWORD *)v12 + 190) = 0;
  *((_DWORD *)v12 + 191) = v116;
  *(_QWORD *)__dst = v82;
  *(_QWORD *)&__dst[8] = v307;
  *(_QWORD *)&__dst[16] = v315;
  *(_DWORD *)&__dst[24] = 3;
  *(_DWORD *)&__dst[28] = v116;
  *(_OWORD *)&__dst[32] = 0uLL;
  *(_OWORD *)&__dst[80] = v177;
  *(_OWORD *)&__dst[96] = v179;
  *((_QWORD *)v12 + 89) = CGImageGetImageBytesPerRowForPixelInfo((uint64_t)CopyWithColorSpace, v144, (uint64_t)__dst, v151, v152, v153, v154, v155);
  *(_QWORD *)__dst = v82;
  *(_QWORD *)&__dst[8] = v307;
  *(_QWORD *)&__dst[16] = v315;
  *(_DWORD *)&__dst[24] = 3;
  *(_DWORD *)&__dst[28] = v116;
  *(_OWORD *)&__dst[32] = 0uLL;
  *(_OWORD *)&__dst[240] = v340;
  *(_OWORD *)&__dst[256] = v341;
  *(_OWORD *)&__dst[272] = v342;
  *(_OWORD *)&__dst[288] = v343;
  *(_OWORD *)&__dst[176] = v336;
  *(_OWORD *)&__dst[192] = v337;
  *(_OWORD *)&__dst[208] = v338;
  *(_OWORD *)&__dst[224] = v339;
  *(_OWORD *)&__dst[112] = v332;
  *(_OWORD *)&__dst[128] = v333;
  *(_OWORD *)&__dst[144] = v334;
  *(_OWORD *)&__dst[160] = v335;
  *(_OWORD *)&__dst[48] = v328;
  *(_OWORD *)&__dst[64] = v329;
  *(_OWORD *)&__dst[80] = v330;
  *(_OWORD *)&__dst[96] = v331;
  *((_QWORD *)v12 + 90) = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v180, v181, v182, v183, v184, v185, v186)
                         * v144
                         + 7) >> 3;
  v194 = (CGPixelComponentGetBitsPerComponent(v82, v187, v188, v189, v190, v191, v192, v193) * v144 + 7) >> 3;
  v195 = (char *)CGImageGetMask(CopyWithColorSpace);
  if (v195)
  {
    v196 = v195;
    v197 = CGImageGetDataProviderInternal(v195, 0);
    if (v197)
    {
      if (*((_DWORD *)v197 + 5))
        v194 = *((_QWORD *)v196 + 9)
             + v194
             - ((unint64_t)(*((_QWORD *)v196 + 5) * *((_QWORD *)v196 + 8) + 7) >> 3);
      goto LABEL_154;
    }
LABEL_223:
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", v50, v51, v52, v303);
  }
LABEL_154:
  if (!v194)
    _CGHandleAssert("CGImageGetMaskBytesPerRowForPixelInfo", 3917, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "bytes_per_row != 0", "zero rowBytes", v50, v51, v52, v303);
  *((_QWORD *)v12 + 130) = v194;
  *(_QWORD *)__dst = v82;
  *(_QWORD *)&__dst[8] = v149;
  *(_QWORD *)&__dst[16] = 1;
  *(_DWORD *)&__dst[24] = 0;
  *(_DWORD *)&__dst[28] = v116;
  *(_DWORD *)&__dst[32] = 0;
  memcpy(&__dst[36], __src, 0x10CuLL);
  v205 = v318;
  *((_QWORD *)v12 + 131) = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v198, v199, v200, v201, v202, v203, v204)
                          * v318
                          + 7) >> 3;
  if (v306)
  {
    SequentialWithInternalCallbacks = CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v12, (uint64_t)&sequential_provider_with_softmask_callbacks, v206, v207, v208, v209, v210, v211);
    v213 = v317;
    if (SequentialWithInternalCallbacks)
    {
      v214 = SequentialWithInternalCallbacks;
      CGDataProviderLock(*((_QWORD *)v12 + 1));
      CGDataProviderLock(*((_QWORD *)v12 + 2));
      goto LABEL_160;
    }
    goto LABEL_171;
  }
  *v12 = 1;
  v213 = v317;
  CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v12, *((_QWORD *)v12 + 49) * (_QWORD)v317, (uint64_t)&direct_provider_with_softmask_callbacks, v207, v208, v209, v210, v211);
  v214 = v216;
  if (!v216)
  {
LABEL_171:
    CGDataProviderRelease(*((CGDataProviderRef *)v12 + 1));
    v215 = (CGDataProvider *)*((_QWORD *)v12 + 2);
    goto LABEL_172;
  }
LABEL_160:
  if (v312)
  {
    CFRetain(v312);
    *((_QWORD *)v12 + 3) = v312;
    *((_QWORD *)v12 + 4) = CGColorTransformCreateCGCMSConverter(v312, *((_QWORD **)v12 + 6), a6);
    v224 = *((_QWORD *)v12 + 89);
    v225 = v224;
    v226 = v315;
    v227 = v307;
    if (v224)
      goto LABEL_163;
    *(_QWORD *)__dst = v82;
    *(_QWORD *)&__dst[8] = v307;
    *(_QWORD *)&__dst[16] = v315;
    *(_DWORD *)&__dst[24] = 3;
    *(_DWORD *)&__dst[28] = v116;
    *(_OWORD *)&__dst[32] = 0uLL;
    *(_OWORD *)&__dst[240] = v340;
    *(_OWORD *)&__dst[256] = v341;
    *(_OWORD *)&__dst[272] = v342;
    *(_OWORD *)&__dst[288] = v343;
    *(_OWORD *)&__dst[176] = v336;
    *(_OWORD *)&__dst[192] = v337;
    *(_OWORD *)&__dst[208] = v338;
    *(_OWORD *)&__dst[224] = v339;
    *(_OWORD *)&__dst[112] = v332;
    *(_OWORD *)&__dst[128] = v333;
    *(_OWORD *)&__dst[144] = v334;
    *(_OWORD *)&__dst[160] = v335;
    *(_OWORD *)&__dst[48] = v328;
    *(_OWORD *)&__dst[64] = v329;
    *(_OWORD *)&__dst[80] = v330;
    *(_OWORD *)&__dst[96] = v331;
    BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v217, v218, v219, v220, v221, v222, v223);
    v226 = v315;
    v224 = (BitsPerPixel * v318 + 7) >> 3;
    v225 = *((_QWORD *)v12 + 89);
    v229 = v318;
    if (v225)
    {
LABEL_163:
      v313 = 8 * v225;
      *(_QWORD *)__dst = v82;
      *(_QWORD *)&__dst[8] = v307;
      *(_QWORD *)&__dst[16] = v226;
      *(_DWORD *)&__dst[24] = 3;
      *(_DWORD *)&__dst[28] = v116;
      *(_OWORD *)&__dst[32] = 0uLL;
      *(_OWORD *)&__dst[240] = v340;
      *(_OWORD *)&__dst[256] = v341;
      *(_OWORD *)&__dst[272] = v342;
      *(_OWORD *)&__dst[288] = v343;
      *(_OWORD *)&__dst[176] = v336;
      *(_OWORD *)&__dst[192] = v337;
      *(_OWORD *)&__dst[208] = v338;
      *(_OWORD *)&__dst[224] = v339;
      *(_OWORD *)&__dst[112] = v332;
      *(_OWORD *)&__dst[128] = v333;
      *(_OWORD *)&__dst[144] = v334;
      *(_OWORD *)&__dst[160] = v335;
      *(_OWORD *)&__dst[48] = v328;
      *(_OWORD *)&__dst[64] = v329;
      *(_OWORD *)&__dst[80] = v330;
      *(_OWORD *)&__dst[96] = v331;
      v230 = v226;
      v231 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v217, v218, v219, v220, v221, v222, v223);
      v226 = v230;
      v227 = v307;
      v229 = (v313 / v231 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(_QWORD *)__dst = 0;
    *(_QWORD *)&__dst[8] = v229;
    *(_QWORD *)&__dst[16] = 1;
    *(_QWORD *)&__dst[24] = v224;
    *(_QWORD *)&__dst[32] = a6;
    *(_QWORD *)&__dst[40] = v82;
    *(_QWORD *)&__dst[48] = v227;
    *(_QWORD *)&__dst[56] = v226;
    *(_DWORD *)&__dst[64] = 3;
    *(_DWORD *)&__dst[68] = v116;
    *(_QWORD *)&__dst[80] = 0;
    *(_QWORD *)&__dst[72] = 0;
    *(_OWORD *)&__dst[312] = v342;
    *(_OWORD *)&__dst[328] = v343;
    *(_OWORD *)&__dst[280] = v340;
    *(_OWORD *)&__dst[296] = v341;
    *(_OWORD *)&__dst[264] = v339;
    *(_OWORD *)&__dst[136] = v331;
    *(_OWORD *)&__dst[120] = v330;
    *(_OWORD *)&__dst[104] = v329;
    *(_OWORD *)&__dst[88] = v328;
    *(_OWORD *)&__dst[200] = v335;
    *(_OWORD *)&__dst[184] = v334;
    *(_OWORD *)&__dst[168] = v333;
    *(_OWORD *)&__dst[152] = v332;
    *(_OWORD *)&__dst[248] = v338;
    *(_OWORD *)&__dst[232] = v337;
    *(_OWORD *)&__dst[216] = v336;
    *(_QWORD *)&v323 = 0;
    *((_QWORD *)&v323 + 1) = v229;
    v324 = 1uLL;
    *((_QWORD *)&v324 + 1) = *((_QWORD *)v12 + 49);
    *(_QWORD *)&v325[0] = a6;
    v232 = v81;
    memcpy((char *)v325 + 8, v81, 0x130uLL);
    if (v81[5])
      *(_QWORD *)&v325[3] = (char *)&v325[3] + 8;
    *(_OWORD *)size = 0u;
    memset(v322, 0, 56);
    v320 = 0u;
    CGCMSConverterConvertGetConverterInfo((uint64_t)&v320, *((CFTypeRef *)v12 + 4), (uint64_t)__dst, (uint64_t)&v323);
    v233 = size[0];
    *((_QWORD *)v12 + 5) = v320;
    v205 = v318;
    if (v233 >= 0x401)
    {
      *((_QWORD *)v12 + 155) = v233;
      *((_QWORD *)v12 + 154) = malloc_type_calloc(1uLL, v233, 0xA3729uLL);
    }
    v213 = v317;
    if (size[1])
      *((_QWORD *)v12 + 156) = size[1];
    v234 = *(_OWORD *)((char *)&v322[1] + 8);
    *(_OWORD *)(v12 + 1256) = *(_OWORD *)((char *)v322 + 8);
    *(_OWORD *)(v12 + 1272) = v234;
    *(_OWORD *)(v12 + 1288) = *(_OWORD *)((char *)&v322[2] + 8);
  }
  else
  {
    *((_QWORD *)v12 + 3) = 0;
    v232 = v81;
  }
  *((_DWORD *)v12 + 14) = a6;
  memcpy(v12 + 88, v232, 0x130uLL);
  if (v232[5])
    *((_QWORD *)v12 + 16) = v12 + 136;
  *((_QWORD *)v12 + 8) = v205;
  *((_QWORD *)v12 + 9) = v213;
  if (cf)
    CFRelease(cf);
  if (v309)
    CFRelease(v309);
  if (v308)
    CFRelease(v308);
  v236 = *((_QWORD *)v12 + 49);
  v237 = *((_QWORD *)v12 + 89);
  if (!v237)
  {
    v238 = *((_QWORD *)v12 + 8);
    memcpy(__dst, v12 + 408, 0x130uLL);
    v237 = (unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v239, v240, v241, v242, v243, v244, v245)
                            * v238
                            + 7) >> 3;
  }
  if (v236 > v237)
    v237 = v236;
  v246 = (v304 + v237 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)v12 + 151) = v246;
  *((_QWORD *)v12 + 150) = malloc_type_calloc(1uLL, v246, 0xA3729uLL);
  v247 = *((_QWORD *)v12 + 49);
  v248 = *((_QWORD *)v12 + 130);
  if (!v248)
  {
    v249 = *((_QWORD *)v12 + 8);
    memcpy(__dst, v12 + 736, 0x130uLL);
    v248 = (unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v250, v251, v252, v253, v254, v255, v256)
                            * v249
                            + 7) >> 3;
  }
  if (v247 > v248)
    v248 = v247;
  v257 = (v305 + v248 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((_QWORD *)v12 + 153) = v257;
  v258 = malloc_type_calloc(1uLL, v257, 0xA3729uLL);
  *((_QWORD *)v12 + 152) = v258;
  if (!*((_QWORD *)v12 + 150) || !v258)
  {
    provider_with_softmask_release_info(v12);
    CGPostError((uint64_t)"%s failed", v259, v260, v261, v262, v263, v264, v265, (char)"CGDataProviderCreateWithSoftMaskAndMatte");
    return 0;
  }
  return v214;
}

uint64_t *copy_image_with_new_provider(CGImage *image, CGDataProvider *a2, size_t a3)
{
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  CGColorSpace *ColorSpace;
  CGBitmapInfo BitmapInfo;
  const CGFloat *decode;
  BOOL shouldInterpolate;
  CGColorRenderingIntent intent;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (image)
  {
    v5 = *((_QWORD *)image + 5);
    v6 = *((_QWORD *)image + 6);
    v7 = *((_QWORD *)image + 7);
    v8 = *((_QWORD *)image + 8);
  }
  else
  {
    v7 = 0;
    v5 = 0;
    v6 = 0;
    v8 = 0;
  }
  ColorSpace = CGImageGetColorSpace(image);
  BitmapInfo = CGImageGetBitmapInfo(image);
  decode = CGImageGetDecode(image);
  shouldInterpolate = CGImageGetShouldInterpolate(image);
  intent = CGImageGetRenderingIntent(image);
  v14 = (uint64_t *)CGImageCreate(v5, v6, v7, v8, a3, ColorSpace, BitmapInfo, a2, decode, shouldInterpolate, intent);
  CGImageCopyHeadroomFromOriginal(v14, image, v15, v16, v17, v18, v19, v20);
  return v14;
}

void provider_with_softmask_release_info(void *a1)
{
  const void *v2;
  const void *v3;
  char *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  vImageConverter *v9;
  vImageConverter *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  if (!*(_BYTE *)a1)
  {
    CGDataProviderUnlock(*((_QWORD *)a1 + 1));
    CGDataProviderUnlock(*((_QWORD *)a1 + 2));
  }
  CGDataProviderRelease(*((CGDataProviderRef *)a1 + 1));
  CGDataProviderRelease(*((CGDataProviderRef *)a1 + 2));
  v2 = (const void *)*((_QWORD *)a1 + 3);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)a1 + 4);
  if (v3)
    CFRelease(v3);
  CGColorSpaceRelease(*((CGColorSpaceRef *)a1 + 6));
  v4 = (char *)*((_QWORD *)a1 + 5);
  if (v4)
    CGvImageConverterCacheRelease(v4);
  v5 = (void *)*((_QWORD *)a1 + 150);
  if (v5)
    free(v5);
  v6 = (void *)*((_QWORD *)a1 + 152);
  if (v6)
    free(v6);
  v7 = (void *)*((_QWORD *)a1 + 154);
  if (v7)
    free(v7);
  v8 = (void *)*((_QWORD *)a1 + 156);
  if (v8)
    free(v8);
  v9 = (vImageConverter *)*((_QWORD *)a1 + 157);
  if (v9)
    vImageConverter_Release(v9);
  v10 = (vImageConverter *)*((_QWORD *)a1 + 158);
  if (v10)
    vImageConverter_Release(v10);
  v11 = (void *)*((_QWORD *)a1 + 159);
  if (v11)
    free(v11);
  v12 = (void *)*((_QWORD *)a1 + 160);
  if (v12)
    free(v12);
  v13 = (void *)*((_QWORD *)a1 + 161);
  if (v13)
    free(v13);
  v14 = (void *)*((_QWORD *)a1 + 162);
  if (v14)
    free(v14);
  free(a1);
}

unint64_t provider_with_softmask_get_bytes_at_position(_BYTE *a1, void *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!*a1)
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position", 684, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "info->src_provider_uses_random_access == true", "", a6, a7, a8, vars0);
  return provider_with_softmask_get_bytes_at_position_inner((uint64_t)a1, a2, a3, a4, 0, a6, a7, a8);
}

uint64_t provider_with_softmask_retain_data(uint64_t a1)
{
  CGDataProviderRetainBytePtr(*(_QWORD *)(a1 + 8));
  CGDataProviderRetainBytePtr(*(_QWORD *)(a1 + 16));
  CGDataProviderRetainData(*(_QWORD *)(a1 + 8));
  return CGDataProviderRetainData(*(_QWORD *)(a1 + 16));
}

uint64_t provider_with_softmask_release_data(uint64_t a1)
{
  CGDataProviderReleaseBytePtr(*(_QWORD *)(a1 + 8));
  CGDataProviderReleaseBytePtr(*(_QWORD *)(a1 + 16));
  CGDataProviderReleaseData(*(_QWORD *)(a1 + 8));
  return CGDataProviderReleaseData(*(_QWORD *)(a1 + 16));
}

uint64_t provider_with_softmask_get_bytes_per_row_count(uint64_t a1)
{
  return *(_QWORD *)(a1 + 392);
}

uint64_t provider_with_softmask_get_image_work_buffer_size(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1208);
}

uint64_t provider_with_softmask_get_softmask_work_buffer_size(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1224);
}

unint64_t provider_with_softmask_get_bytes_at_position_inner(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t BitsPerPixel;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  char *v57;
  uint64_t v58;
  size_t v59;
  size_t BytesAtPositionInternal;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  _QWORD *v71;
  char *v72;
  size_t BytesInternal;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  size_t v77;
  unint64_t v78;
  unint64_t result;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  unsigned __int8 *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _BYTE *v90;
  unsigned __int16 v91;
  unsigned __int8 *v92;
  uint64_t v93;
  __int16 v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  float *v100;
  uint64_t v101;
  float v102;
  float *v103;
  float *v104;
  uint64_t v105;
  float v106;
  int v107;
  __int16 *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  __int16 *v114;
  __int16 *v120;
  uint64_t v121;
  float v122;
  __int16 v125;
  __int16 *v134;
  __int16 *v136;
  uint64_t v137;
  float v138;
  __int16 v141;
  int v145;
  size_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  unsigned int v151;
  _WORD *v152;
  unsigned __int16 *v153;
  uint64_t v154;
  int v155;
  unsigned int v156;
  unsigned int v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  _BYTE *v162;
  unsigned __int16 v163;
  unsigned __int8 *v164;
  uint64_t v165;
  __int16 v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  float *v170;
  uint64_t v171;
  float v172;
  float *v173;
  float *v174;
  uint64_t v175;
  float v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unsigned int v180;
  _WORD *v181;
  unsigned __int16 *v182;
  uint64_t v183;
  int v184;
  _QWORD *v185;
  __int128 v186;
  uint64_t v187;
  uint64_t v188;
  unint64_t v189;
  _QWORD *v190;
  uint64_t v191;
  _QWORD *v192;
  unint64_t v193;
  unint64_t v194;
  size_t v195;
  char v196;
  uint64_t v197;
  size_t v198;
  void *v199;
  unint64_t v200;
  unint64_t v201;
  int v202;
  uint64_t __len;
  size_t __lena;
  void *v205;
  size_t v206;
  size_t __n;
  uint64_t v208;
  unint64_t v209;
  _QWORD v210[2];
  __int128 v211;
  int v212;
  int v213;
  _BYTE v214[304];
  _BYTE __dst[344];
  __int128 v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;

  if ((a3 & 0x8000000000000000) != 0)
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 511, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "pos >= 0", "pos = %lld", a6, a7, a8, a3);
  v13 = (void *)(a1 + 88);
  memcpy(__dst, (const void *)(a1 + 88), 0x130uLL);
  BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v14, v15, v16, v17, v18, v19, v20);
  if ((BitsPerPixel & 7) != 0)
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 515, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "((dst_bits_per_pixel >> 3) << 3) == dst_bits_per_pixel", "bpp = %zu", v21, v22, v23, BitsPerPixel);
  memcpy(__dst, (const void *)(a1 + 408), 0x130uLL);
  v32 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v25, v26, v27, v28, v29, v30, v31);
  memcpy(__dst, (const void *)(a1 + 736), 0x130uLL);
  v40 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v33, v34, v35, v36, v37, v38, v39);
  v43 = destination_position_to_source_position(BitsPerPixel, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), v32, *(_QWORD *)(a1 + 712), a3, v41, v42);
  v46 = destination_position_to_source_position(BitsPerPixel, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), v40, *(_QWORD *)(a1 + 1040), a3, v44, v45);
  if ((v43 & 0x8000000000000000) != 0)
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 574, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_src_pos >= 0", "position %lld", v47, v48, v49, v43);
  v50 = v46;
  v55 = byte_count_to_byte_count(BitsPerPixel, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 80), v32, *(_QWORD *)(a1 + 712), a4, v49);
  if (v55 > *(_QWORD *)(a1 + 1208))
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 586, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_bytes_to_read <= info->image_work_buffer_size", "%s: image_bytes_to_read %zd > image_work_buffer_size %zd", v52, v53, v54, (char)"provider_with_softmask_get_bytes_at_position_inner");
  v56 = *(_QWORD **)(a1 + 8);
  v57 = *(char **)(a1 + 1200);
  if (*(_BYTE *)a1)
  {
    v58 = v43;
    v59 = v55;
    BytesAtPositionInternal = CGDataProviderDirectGetBytesAtPositionInternal(v56, v57, v58, v55, v51, v52, v53, v54);
  }
  else
  {
    v59 = v55;
    BytesAtPositionInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v56, (uint64_t)v57, v55);
  }
  if (BytesAtPositionInternal > v59)
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 594, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_bytes_read <= image_bytes_to_read", "%zu %zu", v61, v62, v63, BytesAtPositionInternal);
  v205 = v13;
  v64 = 8 * a4 / BitsPerPixel;
  v65 = v64;
  v206 = v59;
  if (v59 != BytesAtPositionInternal)
    v65 = 8 * BytesAtPositionInternal / v32;
  v209 = v65;
  __n = BytesAtPositionInternal;
  v70 = byte_count_to_byte_count(BitsPerPixel, *(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 80), v40, *(_QWORD *)(a1 + 1040), a4, v63);
  if (v70 > *(_QWORD *)(a1 + 1224))
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 608, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_bytes_to_read <= info->smask_work_buffer_size", "%s: smask_bytes_to_read %zd > smask_work_buffer_size %zd", v67, v68, v69, (char)"provider_with_softmask_get_bytes_at_position_inner");
  v71 = *(_QWORD **)(a1 + 16);
  v72 = *(char **)(a1 + 1216);
  if (*(_BYTE *)a1)
    BytesInternal = CGDataProviderDirectGetBytesAtPositionInternal(v71, v72, v50, v70, v66, v67, v68, v69);
  else
    BytesInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v71, (uint64_t)v72, v70);
  v77 = BytesInternal;
  v78 = v209;
  if (BytesInternal > v70)
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 615, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_bytes_read <= smask_bytes_to_read", "bytes read %zu to read %zu", v74, v75, v76, BytesInternal);
  if (v70 != BytesInternal)
    v64 = 8 * BytesInternal / v40;
  result = 0;
  if (v209 && v64 && v209 == v64)
  {
    v199 = a2;
    v80 = *(_QWORD *)(a1 + 1200);
    v81 = *(_QWORD *)(a1 + 1216);
    v82 = *(_QWORD *)(a1 + 424);
    v208 = v81;
    v202 = a5;
    v200 = BitsPerPixel;
    v201 = a4;
    v198 = v77;
    switch(*(_DWORD *)(a1 + 408))
    {
      case 1:
        v83 = *(unsigned __int8 *)(a1 + 1065);
        v84 = (unsigned __int8 *)(a1 + 1072);
        if (!*(_BYTE *)(a1 + 1065))
          v84 = 0;
        v85 = v82 + 1;
        if (*(_BYTE *)(a1 + 1064))
        {
          v86 = 0;
          v87 = 0;
          v88 = *(_QWORD *)(a1 + 424);
          do
          {
            v89 = *(unsigned __int8 *)(v81 + v87);
            if (v83)
            {
              if (v82)
              {
                v90 = (_BYTE *)(v80 + v86);
                v91 = inverted_8bit_alpha[v89];
                v92 = v84;
                v93 = v82;
                do
                {
                  v94 = *v92++;
                  *v90 = v94 + ((unsigned __int16)((*v90 - v94) * v91) >> 8);
                  ++v90;
                  --v93;
                }
                while (v93);
              }
              v86 += v85;
            }
            if ((_DWORD)v89)
              LODWORD(v89) = (*(unsigned __int8 *)(v80 + v88) * (_DWORD)v89
                            + ((*(unsigned __int8 *)(v80 + v88) * v89) >> 8)
                            + 1) >> 8;
            *(_BYTE *)(v80 + v88) = v89;
            v88 += v85;
            ++v87;
          }
          while (v87 != v209);
        }
        else
        {
          v158 = 0;
          v159 = 0;
          v160 = *(_QWORD *)(a1 + 424);
          do
          {
            v161 = *(unsigned __int8 *)(v81 + v159);
            if (v83)
            {
              if (v82)
              {
                v162 = (_BYTE *)(v80 + v158);
                v163 = inverted_8bit_alpha[v161];
                v164 = v84;
                v165 = v82;
                do
                {
                  v166 = *v164++;
                  *v162 = v166 + ((unsigned __int16)((*v162 - v166) * v163) >> 8);
                  ++v162;
                  --v165;
                }
                while (v165);
              }
              v158 += v85;
            }
            *(_BYTE *)(v80 + v160) = v161;
            v160 += v85;
            ++v159;
          }
          while (v159 != v209);
        }
        break;
      case 2:
        v145 = *(unsigned __int8 *)(a1 + 1065);
        v146 = a1 + 1072;
        if (!*(_BYTE *)(a1 + 1065))
          v146 = 0;
        __lena = v146;
        v147 = v82 + 1;
        v197 = 2 * v82;
        if (*(_BYTE *)(a1 + 1064))
        {
          v148 = 0;
          v149 = 0;
          v150 = *(_QWORD *)(a1 + 424);
          do
          {
            v151 = *(unsigned __int16 *)(v81 + 2 * v149);
            if (v145)
            {
              v152 = (_WORD *)(v80 + 2 * v148);
              if (*(_WORD *)(v81 + 2 * v149))
              {
                if (v82)
                {
                  v153 = (unsigned __int16 *)__lena;
                  v154 = v82;
                  do
                  {
                    v155 = *v153++;
                    *v152 = v155 + ((((unsigned __int16)*v152 - v155) * (0xFFFFFFFF / v151)) >> 16);
                    ++v152;
                    --v154;
                  }
                  while (v154);
                }
              }
              else if (v82)
              {
                memset(v152, 255, v197);
                v81 = v208;
                v78 = v209;
              }
              v148 += v147;
            }
            if (v151)
            {
              v156 = *(unsigned __int16 *)(v80 + 2 * v150) * v151;
              v157 = (v156 + HIWORD(v156) + 1) >> 16;
            }
            else
            {
              LOWORD(v157) = 0;
            }
            *(_WORD *)(v80 + 2 * v150) = v157;
            v150 += v147;
            ++v149;
          }
          while (v149 != v78);
        }
        else
        {
          v177 = 0;
          v178 = 0;
          v179 = *(_QWORD *)(a1 + 424);
          do
          {
            v180 = *(unsigned __int16 *)(v81 + 2 * v178);
            if (v145)
            {
              v181 = (_WORD *)(v80 + 2 * v177);
              if (*(_WORD *)(v81 + 2 * v178))
              {
                if (v82)
                {
                  v182 = (unsigned __int16 *)__lena;
                  v183 = v82;
                  do
                  {
                    v184 = *v182++;
                    *v181 = v184 + ((((unsigned __int16)*v181 - v184) * (0xFFFFFFFF / v180)) >> 16);
                    ++v181;
                    --v183;
                  }
                  while (v183);
                }
              }
              else if (v82)
              {
                memset(v181, 255, v197);
                v81 = v208;
                v78 = v209;
              }
              v177 += v147;
            }
            *(_WORD *)(v80 + 2 * v179) = v180;
            v179 += v147;
            ++v178;
          }
          while (v178 != v78);
        }
        break;
      case 4:
        v95 = v82 + 1;
        v96 = 4 * v82;
        __len = 4 * v82;
        if (*(_BYTE *)(a1 + 1064))
        {
          v97 = 0;
          v98 = 0;
          v99 = v96 + 4;
          v100 = *(float **)(a1 + 1200);
          v101 = *(_QWORD *)(a1 + 424);
          do
          {
            v102 = *(float *)(v81 + 4 * v98);
            if (v102 == 0.0)
            {
              if (v82)
              {
                memset_pattern16((void *)(v80 + 4 * v97), &unk_185005220, __len);
                v81 = v208;
                v78 = v209;
              }
            }
            else if (v82)
            {
              v103 = v100;
              v104 = (float *)(a1 + 1072);
              v105 = v82;
              do
              {
                v106 = *v104++;
                *v103 = v106 + (float)((float)(1.0 / v102) * (float)(*v103 - v106));
                ++v103;
                --v105;
              }
              while (v105);
            }
            v97 += v95;
            *(float *)(v80 + 4 * v101) = v102 * *(float *)(v80 + 4 * v101);
            v101 += v95;
            ++v98;
            v100 = (float *)((char *)v100 + v99);
          }
          while (v98 != v78);
        }
        else
        {
          v167 = 0;
          v168 = 0;
          v169 = v96 + 4;
          v170 = *(float **)(a1 + 1200);
          v171 = *(_QWORD *)(a1 + 424);
          do
          {
            v172 = *(float *)(v81 + 4 * v168);
            if (v172 == 0.0)
            {
              if (v82)
              {
                memset_pattern16((void *)(v80 + 4 * v167), &unk_185005220, __len);
                v81 = v208;
                v78 = v209;
              }
            }
            else if (v82)
            {
              v173 = v170;
              v174 = (float *)(a1 + 1072);
              v175 = v82;
              do
              {
                v176 = *v174++;
                *v173 = v176 + (float)((float)(1.0 / v172) * (float)(*v173 - v176));
                ++v173;
                --v175;
              }
              while (v175);
            }
            v167 += v95;
            *(float *)(v80 + 4 * v171) = v172;
            v171 += v95;
            ++v168;
            v170 = (float *)((char *)v170 + v169);
          }
          while (v168 != v78);
        }
        break;
      case 5:
        v107 = *(unsigned __int8 *)(a1 + 1065);
        if (*(_BYTE *)(a1 + 1065))
          v108 = (__int16 *)(a1 + 1072);
        else
          v108 = 0;
        v109 = v82 + 1;
        v110 = 0;
        v111 = 0;
        v112 = *(_QWORD *)(a1 + 424);
        if (*(_BYTE *)(a1 + 1064))
        {
          do
          {
            _H9 = *(_WORD *)(v81 + 2 * v111);
            if (v107)
            {
              v114 = (__int16 *)(v80 + 2 * v110);
              __asm { FCVT            S0, H9 }
              if (_S0 == 0.0)
              {
                if (v82)
                {
                  memset_pattern16(v114, &unk_185005210, 2 * v82);
                  v81 = v208;
                  v78 = v209;
                }
              }
              else if (v82)
              {
                v120 = v108;
                v121 = v82;
                v122 = 1.0 / _S0;
                do
                {
                  _H1 = *v114;
                  __asm { FCVT            S1, H1 }
                  v125 = *v120++;
                  _H2 = v125;
                  __asm { FCVT            S2, H2 }
                  _S1 = (float)(v122 * (float)(_S1 - _S2)) + _S2;
                  __asm { FCVT            H1, S1 }
                  *v114++ = LOWORD(_S1);
                  --v121;
                }
                while (v121);
              }
              v110 += v109;
            }
            _H0 = *(_WORD *)(v80 + 2 * v112);
            __asm
            {
              FCVT            S0, H0
              FCVT            S1, H9
            }
            _S0 = _S1 * _S0;
            __asm { FCVT            H0, S0 }
            *(_WORD *)(v80 + 2 * v112) = LOWORD(_S0);
            v112 += v109;
            ++v111;
          }
          while (v111 != v78);
        }
        else
        {
          do
          {
            _H9 = *(_WORD *)(v81 + 2 * v111);
            if (v107)
            {
              v134 = (__int16 *)(v80 + 2 * v110);
              __asm { FCVT            S0, H9 }
              if (_S0 == 0.0)
              {
                if (v82)
                {
                  memset_pattern16(v134, &unk_185005210, 2 * v82);
                  v81 = v208;
                  v78 = v209;
                }
              }
              else if (v82)
              {
                v136 = v108;
                v137 = v82;
                v138 = 1.0 / _S0;
                do
                {
                  _H1 = *v134;
                  __asm { FCVT            S1, H1 }
                  v141 = *v136++;
                  _H2 = v141;
                  __asm { FCVT            S2, H2 }
                  _S1 = (float)(v138 * (float)(_S1 - _S2)) + _S2;
                  __asm { FCVT            H1, S1 }
                  *v134++ = LOWORD(_S1);
                  --v137;
                }
                while (v137);
              }
              v110 += v109;
            }
            *(_WORD *)(v80 + 2 * v112) = _H9;
            v112 += v109;
            ++v111;
          }
          while (v111 != v78);
        }
        break;
      default:
        _CGHandleAssert("merge_mask_to_image", 500, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v81, v75, v76, v196);
    }
    v185 = *(_QWORD **)(a1 + 24);
    if (v185)
    {
      v186 = *(_OWORD *)(a1 + 1272);
      v220 = *(_OWORD *)(a1 + 1256);
      v187 = *(unsigned int *)(a1 + 56);
      v188 = *(_QWORD *)(a1 + 1200);
      v190 = *(_QWORD **)(a1 + 32);
      v189 = *(_QWORD *)(a1 + 40);
      v191 = *(_QWORD *)(a1 + 1248);
      v221 = v186;
      v222 = *(_OWORD *)(a1 + 1288);
      v192 = *(_QWORD **)(a1 + 48);
      v216 = v189;
      v217 = 0;
      v218 = v191;
      v219 = 0;
      *(_QWORD *)__dst = v188;
      *(_QWORD *)&__dst[8] = v78;
      *(_OWORD *)&__dst[16] = xmmword_184E39160;
      *(_DWORD *)&__dst[32] = v187;
      *(_DWORD *)&__dst[36] = 0;
      memcpy(&__dst[40], (const void *)(a1 + 408), 0x130uLL);
      v210[0] = v199;
      v210[1] = v209;
      v211 = xmmword_184E39160;
      v212 = v187;
      v213 = 0;
      memcpy(v214, v205, sizeof(v214));
      CGColorTransformConvertUsingCMSConverter(v185, v192, v187, v190, &v216, (uint64_t)__dst, (uint64_t)v210);
      v78 = v209;
      v194 = v200;
      v193 = v201;
    }
    else
    {
      v194 = v200;
      v193 = v201;
      v195 = __n;
      if (!__n)
      {
LABEL_124:
        if (v206 == v195)
          result = v193;
        else
          result = (v78 * v194 + 7) >> 3;
        if (v202)
        {
          *(_QWORD *)(a1 + 728) += v195;
          *(_QWORD *)(a1 + 1056) += v198;
          *(_QWORD *)(a1 + 80) += result;
        }
        return result;
      }
      memcpy(v199, *(const void **)(a1 + 1200), __n);
      v78 = v209;
    }
    v195 = __n;
    goto LABEL_124;
  }
  return result;
}

unint64_t provider_with_softmask_get_bytes(_BYTE *a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (*a1)
    _CGHandleAssert("provider_with_softmask_get_bytes", 692, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "info->src_provider_uses_random_access == false", "", a6, a7, a8, vars0);
  return provider_with_softmask_get_bytes_at_position_inner((uint64_t)a1, a2, 0, a3, 1, a6, a7, a8);
}

unint64_t provider_with_softmask_skip_forward(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t BitsPerPixel;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE __dst[304];

  v5 = a1[1];
  v4 = a1[2];
  memcpy(__dst, a1 + 11, sizeof(__dst));
  BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v6, v7, v8, v9, v10, v11, v12);
  memcpy(__dst, a1 + 51, sizeof(__dst));
  v21 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v14, v15, v16, v17, v18, v19, v20);
  memcpy(__dst, a1 + 92, sizeof(__dst));
  v29 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v22, v23, v24, v25, v26, v27, v28);
  if ((a2 & 0x8000000000000000) != 0)
    _CGHandleAssert("provider_with_softmask_skip_forward", 709, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "count >= 0", "count: %lld", v30, v31, v32, a2);
  v33 = v29;
  v34 = byte_count_to_byte_count(BitsPerPixel, a1[49], a1[50], a1[10], v21, a1[89], a2, v32);
  v38 = CGDataProviderSkipForwardInternal(v5, v34);
  if (v38 < 0)
    _CGHandleAssert("provider_with_softmask_skip_forward", 723, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_skipped >= 0", "skipped %lld", v35, v36, v37, v38);
  v39 = byte_count_to_byte_count(BitsPerPixel, a1[49], a1[50], a1[10], v33, a1[130], a2, v37);
  v43 = CGDataProviderSkipForwardInternal(v4, v39);
  if (v43 < 0)
    _CGHandleAssert("provider_with_softmask_skip_forward", 738, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_skipped >= 0", "smask_skipped %lld", v40, v41, v42, v43);
  if (v38 != v34)
    a2 = byte_count_to_byte_count(v21, a1[89], a1[90], a1[91], BitsPerPixel, a1[49], v38, v42);
  a1[91] += v38;
  a1[132] += v43;
  a1[10] += a2;
  return a2;
}

void provider_with_softmask_rewind(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  char Type;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;

  v9 = a1[1];
  if (!v9 || (v10 = a1[2]) == 0)
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, v23);
  v11 = *(_DWORD *)(v9 + 20);
  if (v11 != *(_DWORD *)(v10 + 20))
  {
    Type = CGDataProviderGetType(v9, a2, a3, a4, a5, a6, a7, a8);
    CGDataProviderGetType(v10, v13, v14, v15, v16, v17, v18, v19);
    _CGHandleAssert("provider_with_softmask_rewind", 783, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "CGDataProviderGetType(image_provider) == CGDataProviderGetType(smask_provider)", "image type %d  mask type %d", v20, v21, v22, Type);
  }
  if ((v11 | 2) != 3)
    _CGHandleAssert("provider_with_softmask_rewind", 793, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", a6, a7, a8, v23);
  CGDataProviderRewind(v9);
  CGDataProviderRewind(v10);
  a1[10] = 0;
  a1[132] = 0;
  a1[91] = 0;
}

uint64_t provider_with_softmask_lock(uint64_t a1)
{
  int v2;

  v2 = CGDataProviderLock(*(_QWORD *)(a1 + 8));
  return CGDataProviderLock(*(_QWORD *)(a1 + 16)) + v2;
}

uint64_t provider_with_softmask_unlock(uint64_t a1)
{
  int v2;

  v2 = CGDataProviderUnlock(*(_QWORD *)(a1 + 8));
  return CGDataProviderUnlock(*(_QWORD *)(a1 + 16)) + v2;
}

_QWORD *PDFFormSetCreate(uint64_t a1)
{
  _QWORD *v2;

  v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2)
    *v2 = a1;
  return v2;
}

_DWORD *formRetain(uint64_t a1, _DWORD *a2)
{
  _DWORD *result;

  result = a2;
  if (a2)
    ++*a2;
  return result;
}

void formRelease(int a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFFormRelease(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
}

BOOL formEqual(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  _BOOL8 result;

  result = 1;
  if (a1 != a2)
  {
    v2 = *(_DWORD *)(a1 + 24);
    if (v2 != *(_DWORD *)(a2 + 24) || v2 > 1 || *(_QWORD *)(a1 + 32) != *(_QWORD *)(a2 + 32))
      return 0;
  }
  return result;
}

uint64_t formHash(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) > 1u)
    return 0;
  else
    return *(unsigned int *)(a1 + 32);
}

_BYTE *emitFormDefinition(_BYTE *result, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const __CFDictionary *v38;
  const CGRect *v39;
  CGFloat *p_y;
  CGSize *p_size;
  CGFloat *p_height;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  CGFloat v69;
  CGFloat x;
  CGFloat v71;
  CGFloat width;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  CGSize v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  float64x2_t v91;
  __int128 v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  CGColorSpace *ColorSpace;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  _DWORD *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  PDFDocumentPrivate *v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  _QWORD *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  double v206;
  double v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  _BYTE **v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  CGColorSpaceRef space;
  CGRect v251;
  CGRect v252;
  float64x2_t v253;
  float64x2_t v254;
  __int128 v255;
  CGRect v256;

  if (!result[56])
  {
    v9 = result;
    v10 = *((_DWORD *)result + 6);
    if (v10 == 1)
    {
      v43 = *((_QWORD *)result + 4);
      if (!v43)
        goto LABEL_2;
      v44 = *((_QWORD *)result + 1);
      v12 = *((_QWORD *)result + 2);
      PDFContentStreamBegin(v12, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v229);
      PDFDocumentPrintf(v44, (uint64_t)"/Type /XObject", v45, v46, v47, v48, v49, v50, v233);
      PDFDocumentPrintf(v44, (uint64_t)"/Subtype /Form", v51, v52, v53, v54, v55, v56, v234);
      PDFDocumentPrintf(v44, (uint64_t)"/FormType 1", v57, v58, v59, v60, v61, v62, v235);
      if (v12)
        v68 = *(_QWORD *)(v12 + 112);
      else
        v68 = 0;
      PDFDocumentPrintReference(v44, (uint64_t)"/Resources %R", *(_QWORD *)(v68 + 16), v63, v64, v65, v66, v67);
      v78 = *(CGSize *)(v43 + 88);
      v252.origin = *(CGPoint *)(v43 + 72);
      v252.size = v78;
      PDFDocumentPrintf(v44, (uint64_t)"/BBox %r", v79, v80, v81, v82, v83, v84, (uint64_t)&v252);
      v91 = *(float64x2_t *)(v43 + 24);
      v92 = *(_OWORD *)(v43 + 56);
      v254 = *(float64x2_t *)(v43 + 40);
      v255 = v92;
      v253 = v91;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v91, (float64x2_t)xmmword_185004990), (int32x4_t)vceqq_f64(v254, (float64x2_t)xmmword_185004A20))))) & 1) != 0|| *(double *)&v255 != 0.0|| *((double *)&v255 + 1) != 0.0)
      {
        PDFDocumentPrintf(v44, (uint64_t)"/Matrix %m", v85, v86, v87, v88, v89, v90, (uint64_t)&v253);
      }
      PDFDocumentPrintf(v44, (uint64_t)"/Group <<", v85, v86, v87, v88, v89, v90, v237);
      PDFDocumentPrintf(v44, (uint64_t)"/S /Transparency ", v93, v94, v95, v96, v97, v98, v238);
      v106 = *(_QWORD *)(v43 + 104);
      if (v106)
      {
        if ((v106 & 0x8000000000000000) != 0)
          ColorSpace = CGTaggedColorGetColorSpace(v106, v99, v100, v101, v102, v103, v104, v105);
        else
          ColorSpace = *(CGColorSpace **)(v106 + 24);
        v123 = PDFDocumentResolveColorSpace(v44, ColorSpace);
        v124 = PDFDocumentAddColorSpace(v44, v123);
        PDFDocumentPrintf(v44, (uint64_t)"/CS", v125, v126, v127, v128, v129, v130, v239);
        PDFColorSpaceEmitReference(v124, v131, v132, v133, v134, v135, v136, v137);
      }
      else
      {
        PDFDocumentPrintf(v44, (uint64_t)"/CS /DeviceGray", v100, v101, v102, v103, v104, v105, v239);
      }
      PDFDocumentPrintf(v44, (uint64_t)"/I true", v117, v118, v119, v120, v121, v122, v240);
      PDFDocumentPrintf(v44, (uint64_t)"/K false", v138, v139, v140, v141, v142, v143, v241);
      PDFDocumentPrintf(v44, (uint64_t)">>", v144, v145, v146, v147, v148, v149, v242);
      PDFContentStreamBeginData((uint64_t *)v12, v150, v151, v152, v153, v154, v155, v156, v243);
      PDFDocumentPushContentStream(v44, (void *)v12);
      CGSoftMaskDelegateDrawSoftMask(*(const void **)(v44 + 16), 0, 0, v43, v157, v158, v159, v160);
      v161 = v44;
      goto LABEL_50;
    }
    if (v10)
      goto LABEL_2;
    v11 = (_QWORD *)*((_QWORD *)result + 4);
    if (!v11)
      goto LABEL_2;
    v13 = *((_QWORD *)result + 1);
    v12 = *((_QWORD *)result + 2);
    PDFContentStreamBegin(v12, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v229);
    PDFDocumentPrintf(v13, (uint64_t)"/Type /XObject", v14, v15, v16, v17, v18, v19, v230);
    PDFDocumentPrintf(v13, (uint64_t)"/Subtype /Form", v20, v21, v22, v23, v24, v25, v231);
    PDFDocumentPrintf(v13, (uint64_t)"/FormType 1", v26, v27, v28, v29, v30, v31, v232);
    if (*((_QWORD *)v9 + 10) != -1)
      PDFDocumentPrintf(v13, (uint64_t)"/StructParent %d", v32, v33, v34, v35, v36, v37, *((_QWORD *)v9 + 10));
    memset(&v252, 0, sizeof(v252));
    space = 0;
    v38 = (const __CFDictionary *)v11[4];
    if (v11[74] == v11[75])
    {
      v39 = &CGRectNull;
      p_height = &CGRectNull.size.height;
      p_y = &CGRectNull.origin.y;
      p_size = &CGRectNull.size;
    }
    else
    {
      v39 = (const CGRect *)(v11 + 11);
      p_y = (CGFloat *)(v11 + 12);
      p_size = (CGSize *)(v11 + 13);
      p_height = (CGFloat *)(v11 + 14);
    }
    v69 = *p_height;
    x = v39->origin.x;
    v71 = *p_y;
    width = p_size->width;
    v251.origin.x = v39->origin.x;
    v251.origin.y = v71;
    v251.size.width = width;
    v251.size.height = v69;
    if (v38 && CGCFDictionaryGetRect(v38, CFSTR("kCGContextBoundingBox"), (UInt8 *)&v252))
    {
      v256.origin.x = x;
      v256.origin.y = v71;
      v256.size.width = width;
      v256.size.height = v69;
      v251 = CGRectIntersection(v256, v252);
    }
    PDFDocumentPrintf(v13, (uint64_t)"/BBox %r", v32, v33, v34, v35, v36, v37, (uint64_t)&v251);
    if (v12)
      v68 = *(_QWORD *)(v12 + 112);
    else
      v68 = 0;
    PDFDocumentPrintReference(v13, (uint64_t)"/Resources %R", *(_QWORD *)(v68 + 16), v73, v74, v75, v76, v77);
    if (!v38
      || !CFDictionaryGetValue(v38, CFSTR("kCGContextGroup"))
      && !CFDictionaryGetValue(v38, CFSTR("kCGContextColorSpace")))
    {
LABEL_47:
      PDFContentStreamBeginData((uint64_t *)v12, v108, v109, v110, v111, v112, v113, v114, v236);
      v206 = *((double *)v9 + 8);
      v207 = *((double *)v9 + 9);
      if (v206 > 0.0 || v207 > 0.0)
      {
        v253 = (float64x2_t)0x3FF0000000000000uLL;
        v254.f64[0] = 0.0;
        v254.f64[1] = 1.0;
        *(double *)&v255 = v206;
        *((double *)&v255 + 1) = v207;
        if (v12)
        {
          PDFWriterPrintf(*(_BYTE ***)(v12 + 64), (uint64_t)"%*m cm q", v200, v201, v202, v203, v204, v205, (uint64_t)&v253);
          PDFDocumentPushContentStream(v13, (void *)v12);
          CGDisplayListDrawInContextDelegate((uint64_t)v11, *(_QWORD *)(v13 + 16), 0, 0, 0);
          PDFDocumentPopContentStream(v13);
          v221 = *(_BYTE ***)(v12 + 64);
        }
        else
        {
          PDFWriterPrintf(0, (uint64_t)"%*m cm q", v200, v201, v202, v203, v204, v205, (uint64_t)&v253);
          PDFDocumentPushContentStream(v13, 0);
          CGDisplayListDrawInContextDelegate((uint64_t)v11, *(_QWORD *)(v13 + 16), 0, 0, 0);
          PDFDocumentPopContentStream(v13);
          v221 = 0;
        }
        PDFWriterPrintf(v221, (uint64_t)"Q", v215, v216, v217, v218, v219, v220, v249);
        goto LABEL_55;
      }
      PDFDocumentPushContentStream(v13, (void *)v12);
      CGDisplayListDrawInContextDelegate((uint64_t)v11, *(_QWORD *)(v13 + 16), 0, 0, 0);
      v161 = v13;
LABEL_50:
      PDFDocumentPopContentStream(v161);
LABEL_55:
      PDFContentStreamEndData(v12, v208, v209, v210, v211, v212, v213, v214);
      PDFContentStreamEnd((CFDataRef *)v12);
      result = PDFResourceSetEmit(v68, v222, v223, v224, v225, v226, v227, v228);
      v9[56] = 1;
      goto LABEL_2;
    }
    v115 = *(_DWORD *)(v13 + 4);
    if (v115 <= 0)
    {
      *(_DWORD *)(v13 + 4) = 1;
      v116 = (_DWORD *)(v13 + 8);
    }
    else
    {
      if (v115 != 1)
        goto LABEL_41;
      v116 = (_DWORD *)(v13 + 8);
      if (*(int *)(v13 + 8) > 3)
        goto LABEL_41;
    }
    *v116 = 4;
LABEL_41:
    PDFDocumentPrintf(v13, (uint64_t)"/Group <<", v109, v110, v111, v112, v113, v114, v236);
    PDFDocumentPrintf(v13, (uint64_t)"/S /Transparency", v162, v163, v164, v165, v166, v167, v244);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1)
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_77);
    if (CGCFDictionaryGetCFTypeRef(v38, CFSTR("kCGContextColorSpace"), CGColorSpaceGetTypeID_type_id, (uint64_t *)&space))
    {
      space = PDFDocumentResolveColorSpace(v13, space);
      v174 = PDFDocumentAddColorSpace(v13, space);
    }
    else
    {
      space = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericRGB"));
      v174 = PDFDocumentAddColorSpace(v13, space);
      CGColorSpaceRelease(space);
    }
    PDFDocumentPrintf(v13, (uint64_t)"/CS", v168, v169, v170, v171, v172, v173, v245);
    PDFColorSpaceEmitReference(v174, v175, v176, v177, v178, v179, v180, v181);
    PDFDocumentPrintf(v13, (uint64_t)"/I true", v182, v183, v184, v185, v186, v187, v246);
    PDFDocumentPrintf(v13, (uint64_t)"/K false", v188, v189, v190, v191, v192, v193, v247);
    PDFDocumentPrintf(v13, (uint64_t)">>", v194, v195, v196, v197, v198, v199, v248);
    goto LABEL_47;
  }
LABEL_2:
  *a2 = 1;
  return result;
}

const void *CGPropertiesCopyProperty(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  const void *Value;
  const void *v6;

  v4 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  v6 = Value;
  if (Value)
    CFRetain(Value);
  os_unfair_lock_unlock(v4);
  return v6;
}

void CGPropertiesRemoveProperty(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), a2);
  os_unfair_lock_unlock(v4);
}

double CGSBoundingShapeCreate()
{
  char *v0;
  double result;

  v0 = (char *)malloc_type_malloc(0x200uLL, 0x705560E0uLL);
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *(_OWORD *)(v0 + 136) = 0u;
  *(_OWORD *)(v0 + 152) = 0u;
  *(_OWORD *)(v0 + 168) = 0u;
  *(_OWORD *)(v0 + 184) = 0u;
  *(_OWORD *)(v0 + 200) = 0u;
  *(_OWORD *)(v0 + 216) = 0u;
  *(_OWORD *)(v0 + 232) = 0u;
  *(_OWORD *)(v0 + 248) = 0u;
  *((_QWORD *)v0 + 33) = 0;
  *(_QWORD *)&result = 8;
  *(_QWORD *)v0 = 8;
  *((_QWORD *)v0 + 2) = v0 + 32;
  *((_QWORD *)v0 + 3) = v0 + 160;
  return result;
}

uint64_t CGSBoundingShapeRelease(void *a1)
{
  if (a1)
    free(a1);
  return 0;
}

uint64_t CGSBoundingShapeReset(int *a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *a1;
    a1[1] = 0;
    a1[2] = 0;
    bzero(a1 + 8, ((2 * v1 * (v1 - 1)) & 0xFFFFFFFFFFFFFFFCLL) + 16 * v1);
  }
  return 0;
}

unsigned int *CGSBoundingShapeAdd(unsigned int *result, unsigned int a2, unsigned int a3, int a4, int a5)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;

  if (result && a4 && a5)
  {
    v5 = a4 + a2;
    if (a4 >= 0)
      v6 = a2;
    else
      v6 = v5;
    if (a4 >= 0)
      v7 = v5;
    else
      v7 = a2;
    v8 = a5 + a3;
    if (a5 >= 0)
      v9 = a3;
    else
      v9 = v8;
    if (a5 >= 0)
      v10 = v8;
    else
      v10 = a3;
    return (unsigned int *)shape_accum_add(result, v6, v9, v7, v10);
  }
  return result;
}

uint64_t CGSBoundingShapeAddRect(unsigned int *a1, double *a2)
{
  double v3;
  double v4;
  double v5;
  double v6;
  uint64_t v8;
  uint64_t v9;

  if (a1)
  {
    if (a2)
    {
      v3 = *a2;
      v4 = a2[1];
      v5 = a2[2];
      v6 = a2[3];
      v8 = 0;
      v9 = 0;
      if ((rect_to_bounds_16910((signed int *)&v9 + 1, (signed int *)&v9, (signed int *)&v8 + 1, (signed int *)&v8, v3, v4, v5, v6) & 0x80000000) == 0)shape_accum_add(a1, HIDWORD(v9), v9, HIDWORD(v8), v8);
    }
  }
  return 0;
}

uint64_t CGSBoundingShapeAddRegion(unsigned int *a1, _QWORD *cf)
{
  unsigned int *v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;

  if (a1)
  {
    if (region_check(cf))
    {
      v4 = (unsigned int *)cf[2];
      if (v4 != (unsigned int *)&the_empty_shape && v4[v4[1]] != 0x7FFFFFFF && v4 && (int)*a1 >= 3)
      {
        v5 = v4[1];
        v6 = *v4 != 0x80000000 || (int)v5 < 1;
        if (!v6 && v4[v5] != 0x7FFFFFFF)
        {
          v8 = 0x80000000;
          while (1)
          {
            v9 = v4;
            v10 = (int)v4[1];
            v4 += v10;
            v11 = *v4;
            if ((int)v10 >= 3)
              break;
LABEL_19:
            v8 = v11;
            if ((_DWORD)v11 == 0x7FFFFFFF)
              return 0;
          }
          v12 = v9 + 2;
          while ((shape_accum_add(a1, *v12, v8, v12[1], v11) & 0x80000000) == 0)
          {
            v12 += 2;
            if (v12 >= v4)
            {
              v11 = *v4;
              goto LABEL_19;
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t CGSBoundingShapeAddRegionWithScale(uint64_t result, _QWORD *cf, double a3)
{
  unsigned int *v5;
  unsigned int *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;

  if (result)
  {
    v5 = (unsigned int *)result;
    result = (uint64_t)region_check(cf);
    if ((_DWORD)result)
    {
      v6 = (unsigned int *)cf[2];
      if (v6 != (unsigned int *)&the_empty_shape)
      {
        if (v6)
        {
          if ((int)*v5 >= 3 && *v6 == 0x80000000)
          {
            v7 = v6[1];
            if ((int)v7 >= 1 && v6[v7] != 0x7FFFFFFF)
            {
              v8 = vcvtd_n_s64_f64(a3, 8uLL);
              v9 = 0x80000000;
              do
              {
                v10 = v6 + 2;
                v6 += (int)v6[1];
                v11 = ((int)(v9 * v8 + 1) >> 8);
                v12 = ((int)(*v6 * v8 + 255) >> 8);
                while (v10 < v6)
                {
                  v13 = *v10;
                  v14 = v10[1];
                  v10 += 2;
                  result = shape_accum_add(v5, ((int)(v13 * v8 + 1) >> 8), v11, ((int)(v14 * v8 + 255) >> 8), v12);
                  if ((result & 0x80000000) != 0)
                    return result;
                }
                v9 = *v6;
              }
              while (*v6 != 0x7FFFFFFF);
            }
          }
        }
      }
    }
  }
  return result;
}

int *CGSRegionCreateWithBoundingShape(int *result)
{
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (result)
  {
    v1 = shape_accum_shape(result);
    return (int *)region_create_with_shape(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  return result;
}

uint64_t CGSBoundingShapeGetRegion(int *a1, int **a2)
{
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a2)
  {
    if (a1)
    {
      v3 = shape_accum_shape(a1);
      a1 = (int *)region_create_with_shape(v3, v4, v5, v6, v7, v8, v9, v10);
    }
    *a2 = a1;
  }
  return 0;
}

uint64_t CGSBoundingShapeGetBounds(int *a1, double *a2)
{
  uint64_t v2;
  char v3;
  int *v4;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;

  if (a2)
  {
    if (a1 && (v2 = *a1, (int)v2 >= 3))
    {
      v3 = 0;
      v4 = (int *)*((_QWORD *)a1 + 2);
      v5 = &v4[4 * v2];
      v6 = 0x7FFFFFFF;
      v7 = -2147483647;
      v8 = -2147483647;
      v9 = 0x7FFFFFFF;
      v10 = 0x7FFFFFFF;
      do
      {
        while (1)
        {
          v11 = v4[1];
          if (*v4 >= v11)
            break;
          v12 = v4[2];
          if (v12 <= -2147483647)
            v12 = -2147483647;
          v13 = v4[3] - (v4[3] >= v10);
          if (v12 >= v13)
            break;
          v10 = 0;
          if (*v4 < v9)
            v9 = *v4;
          if (v11 > v8)
            v8 = v4[1];
          if (v12 < v6)
            v6 = v12;
          if (v13 > v7)
            v7 = v13;
          v4 += 4;
          v3 = 1;
          if (v4 >= v5)
            goto LABEL_22;
        }
        v4 += 4;
      }
      while (v4 < v5);
      if ((v3 & 1) == 0)
        goto LABEL_23;
LABEL_22:
      *a2 = (double)v9;
      a2[1] = (double)v6;
      a2[2] = (double)(v8 - v9);
      a2[3] = (double)(v7 - v6);
    }
    else
    {
LABEL_23:
      *(CGRect *)a2 = CGRectNull;
    }
  }
  return 0;
}

uint64_t CGPDFGetBaseEncodingForName(uint64_t result)
{
  const char *v1;

  if (result)
  {
    v1 = (const char *)result;
    if (!strcmp((const char *)result, "MacRomanEncoding"))
    {
      return 2;
    }
    else if (!strcmp(v1, "WinAnsiEncoding"))
    {
      return 3;
    }
    else if (!strcmp(v1, "MacExpertEncoding"))
    {
      return 4;
    }
    else if (!strcmp(v1, "StandardEncoding"))
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

char *CGPDFGetNameForBaseEncoding(int a1)
{
  if ((a1 + 1) >= 8)
    abort();
  return off_1E165E798[a1 + 1];
}

uint64_t CGPDFGetNameVectorForBaseEncoding(int a1)
{
  if ((a1 - 1) > 6)
    return 0;
  else
    return (uint64_t)*(&off_1E165E7D8 + (a1 - 1));
}

uint64_t CGPDFGetUnicharVectorForBaseEncoding(int a1)
{
  if ((a1 - 1) > 6)
    return 0;
  else
    return (uint64_t)*(&off_1E165E810 + (a1 - 1));
}

uint64_t CGFontAutohinterIteratorCreate(unint64_t *a1, double *a2, unsigned int *a3, double a4)
{
  uint64_t *Autohinter;
  uint64_t result;
  uint64_t v9;
  unsigned int v10;

  Autohinter = (uint64_t *)CGFontGetAutohinter(a1);
  result = (uint64_t)CGFontAutohinterCreateAutohintTransform(Autohinter, a2, 1, a4);
  if (result)
  {
    v9 = result;
    result = operator new();
    *(_QWORD *)(result + 8) = v9;
    *(_OWORD *)(result + 16) = CGFontAutohinterIteratorCreate_callbacks;
    *(_OWORD *)(result + 32) = *(_OWORD *)off_1E1623948;
    if (a3)
    {
      do
        v10 = __ldxr(a3);
      while (__stxr(v10 + 1, a3));
    }
    *(_QWORD *)(result + 48) = a3;
    *(_DWORD *)result = 1;
  }
  return result;
}

uint64_t autohinter_iterator_begin(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t (*v3)(_QWORD, uint64_t, _QWORD);
  uint64_t result;

  if (a3)
  {
    v3 = (uint64_t (*)(_QWORD, uint64_t, _QWORD))a3[2];
    if (v3)
      return v3(a3[1], a2, a3[6]);
  }
  return result;
}

void autohinter_iterate(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  void (*v5)(_QWORD, uint64_t, _QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  switch(a2)
  {
    case -1:
      if (a4)
      {
        v5 = *(void (**)(_QWORD, uint64_t, _QWORD))(a4 + 16);
        if (v5)
          v5(*(_QWORD *)(a4 + 8), a3, *(_QWORD *)(a4 + 48));
      }
      break;
    case 0:
      CGFontAutohintTransformApply();
      v20 = v6;
      v21 = v7;
      if (a4)
        (*(void (**)(_QWORD, _QWORD, uint64_t *, _QWORD))(a4 + 24))(*(_QWORD *)(a4 + 8), 0, &v20, *(_QWORD *)(a4 + 48));
      break;
    case 1:
      CGFontAutohintTransformApply();
      v20 = v8;
      v21 = v9;
      if (a4)
        (*(void (**)(_QWORD, uint64_t, uint64_t *, _QWORD))(a4 + 24))(*(_QWORD *)(a4 + 8), 1, &v20, *(_QWORD *)(a4 + 48));
      break;
    case 3:
      if (a4)
      {
        CGFontAutohintTransformApply();
        v11 = v10;
        v13 = v12;
        CGFontAutohintTransformApply();
        v15 = v14;
        v17 = v16;
        CGFontAutohintTransformApply();
        v20 = v18;
        v21 = v19;
        v22 = v15;
        v23 = v17;
        v24 = v11;
        v25 = v13;
        (*(void (**)(_QWORD, uint64_t, uint64_t *, _QWORD))(a4 + 24))(*(_QWORD *)(a4 + 8), 3, &v20, *(_QWORD *)(a4 + 48));
      }
      break;
    case 4:
      if (a4)
        (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD))(a4 + 24))(*(_QWORD *)(a4 + 8), 4, 0, *(_QWORD *)(a4 + 48));
      break;
    default:
      abort();
  }
}

uint64_t autohinter_iterator_end(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD, _QWORD);
  uint64_t result;

  if (a2)
  {
    v2 = (uint64_t (*)(_QWORD, _QWORD))a2[4];
    if (v2)
      return v2(a2[1], a2[6]);
  }
  return result;
}

void autohinter_iterator_release_data(void *a1)
{
  unsigned int v1;
  unsigned int v2;

  if (a1)
  {
    do
    {
      v1 = __ldxr((unsigned int *)a1);
      v2 = v1 - 1;
    }
    while (__stxr(v2, (unsigned int *)a1));
    if (!v2)
      free(a1);
  }
}

void *PDFColorSpaceCreate(uint64_t a1, const void *a2, int a3)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = malloc_type_calloc(1uLL, 0x38uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *(_DWORD *)v6 = 1;
  *((_QWORD *)v6 + 1) = a1;
  if (a2)
    CFRetain(a2);
  *((_QWORD *)v6 + 3) = a2;
  *((_QWORD *)v6 + 4) = 0;
  *((_QWORD *)v6 + 2) = 0;
  snprintf_l((char *)v6 + 40, 0x10uLL, 0, "Cs%d", a3);
  switch(CGColorSpaceGetType(*((_QWORD **)v6 + 3)))
  {
    case 0u:
      v7 = "DeviceGray";
      goto LABEL_12;
    case 1u:
      v7 = "DeviceRGB";
      goto LABEL_12;
    case 2u:
      v7 = "DeviceCMYK";
      goto LABEL_12;
    case 9u:
      v8 = *((_QWORD *)v6 + 3);
      if (v8)
      {
        v9 = *(_QWORD *)(v8 + 24);
        if ((*(_DWORD *)(v9 + 24) - 5) <= 1)
        {
          if (**(_QWORD **)(v9 + 88))
            goto LABEL_10;
        }
      }
      v7 = "Pattern";
LABEL_12:
      *((_QWORD *)v6 + 4) = v7;
      break;
    default:
LABEL_10:
      *((_QWORD *)v6 + 2) = PDFXRefTableAddObject(*(_QWORD **)(*((_QWORD *)v6 + 1) + 464));
      break;
  }
  return v6;
}

void PDFColorSpaceRelease(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;

  if (a1)
  {
    do
    {
      v2 = __ldxr((unsigned int *)a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, (unsigned int *)a1));
    if (!v3)
    {
      CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 24));
      free((void *)a1);
    }
  }
}

void PDFColorSpaceEmitReference(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;

  if (a1)
  {
    v9 = a1[4];
    v10 = a1[1];
    if (v9)
      PDFDocumentPrintf(v10, (uint64_t)"/%N", a3, a4, a5, a6, a7, a8, v9);
    else
      PDFDocumentPrintReference(v10, (uint64_t)"%R", a1[2], a4, a5, a6, a7, a8);
  }
}

void emit_array(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v9 = a4;
  v10 = (uint64_t *)a3;
  PDFDocumentPrintf(a1, (uint64_t)"%s [", a3, a4, a5, a6, a7, a8, a2);
  for (; v9; --v9)
  {
    v18 = *v10++;
    PDFDocumentPrintf(a1, (uint64_t)"%f", v12, v13, v14, v15, v16, v17, v18);
  }
  PDFDocumentPrintf(a1, (uint64_t)"]", v12, v13, v14, v15, v16, v17, a9);
}

CGPDFObjectType CGPDFObjectGetType(CGPDFObjectRef object)
{
  if (!object)
    return 1;
  if (*((_DWORD *)object + 2) == 12)
    return 3;
  return *((_DWORD *)object + 2);
}

BOOL CGPDFObjectGetValue(CGPDFObjectRef object, CGPDFObjectType type, void *value)
{
  CGPDFObjectRef v3;
  int v4;
  double v5;
  int v6;

  if (!object)
    return (char)object;
  v3 = object;
  if (type == kCGPDFObjectTypeInteger || type == (kCGPDFObjectTypeDictionary|kCGPDFObjectTypeReal))
  {
    v6 = *((_DWORD *)object + 2);
    if (v6 == 12 || v6 == 3)
    {
      if (value)
        *(_QWORD *)value = *((_QWORD *)object + 4);
      goto LABEL_24;
    }
    goto LABEL_21;
  }
  if (type == kCGPDFObjectTypeReal)
  {
    v4 = *((_DWORD *)object + 2);
    switch(v4)
    {
      case 12:
        goto LABEL_8;
      case 4:
        v5 = *((double *)object + 4);
        if (!value)
        {
LABEL_24:
          LOBYTE(object) = 1;
          return (char)object;
        }
LABEL_23:
        *(double *)value = v5;
        goto LABEL_24;
      case 3:
LABEL_8:
        v5 = (double)*((uint64_t *)object + 4);
        if (!value)
          goto LABEL_24;
        goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (*((_DWORD *)object + 2) != type)
  {
LABEL_21:
    LOBYTE(object) = 0;
    return (char)object;
  }
  LOBYTE(object) = 1;
  switch(type)
  {
    case kCGPDFObjectTypeNull:
      return (char)object;
    case kCGPDFObjectTypeBoolean:
      if (value)
        *(_BYTE *)value = *((_BYTE *)v3 + 32);
      break;
    case kCGPDFObjectTypeName:
    case kCGPDFObjectTypeString:
    case kCGPDFObjectTypeArray:
    case kCGPDFObjectTypeDictionary:
    case kCGPDFObjectTypeStream:
      if (value)
        *(_QWORD *)value = *((_QWORD *)v3 + 4);
      break;
    case kCGPDFObjectTypeDictionary|kCGPDFObjectTypeBoolean:
      if (value)
        *(_OWORD *)value = *((_OWORD *)v3 + 1);
      break;
    case kCGPDFObjectTypeStream|kCGPDFObjectTypeBoolean:
      if (value)
        *(_DWORD *)value = *((_DWORD *)v3 + 8);
      break;
    default:
      pdf_error("invalid object type: %d.", type);
      abort();
  }
  return (char)object;
}

uint64_t CGPDFObjectPrint(uint64_t a1, FILE *a2)
{
  return CGPDFObjectPrintWithIndent(a1, a2, 0);
}

uint64_t CGPDFObjectPrintWithIndent(uint64_t result, FILE *a2, uint64_t a3)
{
  uint64_t v3;
  FILE *v4;
  const char *v6;
  size_t v7;
  int v8;
  int v9;
  BOOL v10;

  if (result)
  {
    v3 = result;
    if (a2)
      v4 = a2;
    else
      v4 = (FILE *)*MEMORY[0x1E0C80C10];
    switch(*(_DWORD *)(result + 8))
    {
      case 1:
        result = fwrite("null object", 0xBuLL, 1uLL, v4);
        break;
      case 2:
        result = fprintf(v4, "Boolean: %s");
        break;
      case 3:
        result = fprintf(v4, "Integer: %ld");
        break;
      case 4:
        result = fprintf(v4, "Real: %g");
        break;
      case 5:
        fwrite("Name: ", 6uLL, 1uLL, v4);
        v6 = *(const char **)(v3 + 32);
        v7 = strlen(v6);
        for (result = fputc(47, v4); v7; --v7)
        {
          v9 = *(unsigned __int8 *)v6++;
          v8 = v9;
          if ((v9 - 127) <= 0xFFFFFFA1
            || ((v8 - 35) <= 0x3A
              ? (v10 = ((1 << (v8 - 35)) & 0x50000000A001065) == 0)
              : (v10 = 1),
                !v10 || v8 == 125 || v8 == 123))
          {
            result = fprintf(v4, "#%02x", v8);
          }
          else
          {
            result = fputc(v8, v4);
          }
        }
        break;
      case 6:
        fwrite("String: ", 8uLL, 1uLL, v4);
        result = CGPDFStringPrint(*(_QWORD *)(v3 + 32), v4);
        break;
      case 7:
        fwrite("Array: ", 7uLL, 1uLL, v4);
        result = CGPDFArrayPrintWithIndent(*(_QWORD *)(v3 + 32), v4, a3);
        break;
      case 8:
        fwrite("Dictionary: ", 0xCuLL, 1uLL, v4);
        result = CGPDFDictionaryPrintWithIndent(*(_QWORD *)(v3 + 32), v4, a3);
        break;
      case 9:
        fwrite("Stream: ", 8uLL, 1uLL, v4);
        result = stream_print(*(_QWORD *)(v3 + 32), v4, a3, 0);
        break;
      case 0xA:
        result = fprintf(v4, "Object Reference: R(%lu,%hu)");
        break;
      case 0xB:
        result = fprintf(v4, "Operator: %d");
        break;
      case 0xC:
        result = fprintf(v4, "Offset: %lld");
        break;
      default:
        result = fprintf(v4, "UNKNOWN OBJECT TYPE: %d");
        break;
    }
  }
  return result;
}

void pdf_softmask_release_info(CFTypeRef *a1)
{
  CFTypeRef v2;
  CFTypeRef v3;

  v2 = a1[2];
  if (v2)
    CFRelease(v2);
  if (*a1)
    CFRelease(*a1);
  v3 = a1[1];
  if (v3)
    CFRelease(v3);
  free(a1);
}

void pdf_softmask_draw_softmask(CGPDFStream **a1, uint64_t a2)
{
  CGPDFStream *v3;
  CGPDFStream **v4;
  CGPDFDictionary *v5;
  CGPDFContentStreamRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;

  v3 = *a1;
  if (*a1)
  {
    v4 = (CGPDFStream **)*((_QWORD *)v3 + 4);
    if (v4)
    {
      v3 = *v4;
      v5 = v4[11];
      goto LABEL_6;
    }
    v3 = 0;
  }
  v5 = 0;
LABEL_6:
  v6 = CGPDFContentStreamCreateWithStream(v3, v5, a1[2]);
  v13 = CGPDFDrawingContextCreateWithContentStream(v6, 0);
  if (v6)
    CFRelease(v6);
  CGPDFDrawingContextDraw((uint64_t)v13, a2, v7, v8, v9, v10, v11, v12);
  CGPDFDrawingContextRelease(v13);
}

CFStringRef _ripdata_copy_format_description(uint64_t a1, const __CFDictionary *a2)
{
  return CFStringCreateWithFormat(0, a2, CFSTR("<RIPData %p>"), a1);
}

CFStringRef _ripdata_copy_description(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<RIPData %p>"), a1);
}

void RIPCacheEntryRemove(uint64_t *a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *a1;
  v1 = (_QWORD *)a1[1];
  *(_QWORD *)(v2 + 8) = v1;
  v3 = (_QWORD *)a1[3];
  --*(_QWORD *)(a1[4] + 40);
  *v1 = v2;
  v4 = a1[5];
  a1[5] = 0;
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  --*(_QWORD *)(v4 + 16);
  v5 = a1[2];
  *(_QWORD *)(v5 + 8) = v3;
  *v3 = v5;
  a1[2] = (uint64_t)(a1 + 2);
  a1[3] = (uint64_t)(a1 + 2);
  if (RIPGetCacheState_predicate != -1)
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_9_12336);
  --*(_QWORD *)(RIPGetCacheState_cache_state + 16);
}

void RIPPrint()
{
  FILE *v0;
  uint64_t v1;
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  const char *v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;

  v0 = (FILE *)*MEMORY[0x1E0C80C10];
  fputc(10, (FILE *)*MEMORY[0x1E0C80C10]);
  fwrite("RIP\n", 4uLL, 1uLL, v0);
  fwrite("===\n\n", 5uLL, 1uLL, v0);
  if (RIPGetCacheState_predicate != -1)
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_9_12336);
  v1 = RIPGetCacheState_cache_state;
  RIPLockCacheState();
  pthread_mutex_lock(&contexts_mutex);
  v2 = (uint64_t *)contexts;
  if (contexts)
  {
    v3 = 0;
    v4 = contexts;
    do
    {
      ++v3;
      v4 = *(_QWORD *)(v4 + 8);
    }
    while (v4);
  }
  else
  {
    v3 = 0;
  }
  v13 = malloc_type_calloc(v3 + 1, 0x68uLL, 0x10200409CB08D46uLL);
  fprintf(v0, "%-18s %-10s %.10s %-18s %-18s %-6s %-6s %-8s\n", "Context", "Usage", "Generation", "Reference", "Address", "Width", "Height", "Type");
  fprintf(v0, "%.18s %.10s %.10s %.18s %.18s %.6s %.6s %.8s\n", "====================", "====================", "====================", "====================", "====================", "====================", "====================", "====================");
  if (v2)
  {
    v5 = v13;
    do
    {
      RIPPrintCache(v0, v1, *v2, v5);
      fprintf(v0, "%.18s %.10s %.10s %.18s %.18s %.6s %.6s %.8s\n", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------");
      v2 = (uint64_t *)v2[1];
      v5 += 13;
    }
    while (v2);
  }
  pthread_mutex_unlock(&contexts_mutex);
  v11 = v1;
  RIPPrintCache(v0, v1, 0, &v13[13 * v3]);
  RIPUnlockCacheState();
  fprintf(v0, "%.18s %.10s %.10s %.18s %.18s %.6s %.6s %.8s\n", "====================", "====================", "====================", "====================", "====================", "====================", "====================", "====================");
  fputc(10, v0);
  fprintf(v0, "%-18s %-10s %-10s %-10s\n", "Context", "Count", "Size", "Type");
  fprintf(v0, "%.18s %.10s %.10s %.10s\n", "====================", "====================", "====================", "====================");
  v6 = 0;
  v7 = v13 + 3;
  v12 = v3;
  do
  {
    v8 = 0;
    v9 = v7;
    do
    {
      if (*v9)
      {
        if (v13[13 * v6])
          fprintf(v0, "%18p");
        else
          fprintf(v0, "%18s");
        v10 = "Unknown";
        if (v8 <= 2)
          v10 = off_1E165E9C8[v8];
        fprintf(v0, " %10lu %10lu %s\n", *v9, v9[1], v10);
      }
      ++v8;
      v9 += 2;
    }
    while (v8 != 5);
    if (v6 < v12)
      fprintf(v0, "%.18s %.10s %.10s %.10s\n", "--------------------", "--------------------", "--------------------", "--------------------");
    ++v6;
    v7 += 13;
  }
  while (v6 <= v12);
  fprintf(v0, "%.18s %.10s %.10s %.10s\n", "====================", "====================", "====================", "====================");
  fprintf(v0, "%-18s %10zu Total\n", "", *(_QWORD *)(v11 + 16));
  free(v13);
}

FILE *RIPPrintCache(FILE *result, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  FILE *v12;
  uint64_t v13;

  v4 = (uint64_t *)(a3 + 208);
  v7 = *(_QWORD *)(a2 + 8);
  v5 = (uint64_t *)(a2 + 8);
  v6 = v7;
  if (!a3)
    v4 = v5;
  v8 = *v4;
  *a4 = a3;
  v9 = *(_QWORD *)(v6 + 8);
  if (v9 != v6)
  {
    v12 = result;
    do
    {
      if (*(_QWORD *)(v9 + 24) == v8)
      {
        ++a4[1];
        v13 = *(int *)(v9 + 32);
        ++a4[2 * v13 + 3];
        switch((_DWORD)v13)
        {
          case 2:
            if (a3)
              fprintf(v12, "%18p");
            else
              fprintf(v12, "%18s");
            result = (FILE *)fprintf(v12, " %10u %10u %18p %18p %6u %6u PatternImage\n");
            break;
          case 1:
            if (a3)
              fprintf(v12, "%18p");
            else
              fprintf(v12, "%18s");
            result = (FILE *)fprintf(v12, " %10u %10u %18p %18p %6u %6u Pattern\n");
            break;
          case 0:
            if (a3)
              fprintf(v12, "%18p");
            else
              fprintf(v12, "%18s");
            result = (FILE *)fprintf(v12, " %10u %10u %18p %18p %6zu %6zu Function\n");
            break;
        }
      }
      v9 = *(_QWORD *)(v9 + 8);
    }
    while (v9 != v6);
  }
  return result;
}

_QWORD *CGColorTransformCreateParametricCodeFragment(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *calibrated_parametric_data_f;
  _QWORD *Cache;
  uint64_t v8;
  CGColorSpace *ResolvedColorSpace;
  _QWORD *v10;
  unsigned __int8 *Converter;
  _BOOL4 v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeID v17;
  uint64_t v18;
  const __CFArray *Retained;
  const __CFDictionary *v20;
  __CFArray *colorsync_profile_sequence;
  __CFArray *v22;
  char *v24;
  unsigned int v25;
  CFTypeID v26;
  CFIndex v27;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v29;
  CFTypeID v30;
  int *v31;
  const __CFArray *Value;
  CFIndex v33;
  __int128 *v34;
  CFIndex v35;
  char *v36;
  const __CFArray *v37;
  const __CFNumber *v38;
  const __CFArray *v39;
  const __CFNumber *v40;
  char *v41;
  const __CFString *v42;
  int v43;
  const __CFArray *v44;
  const __CFNumber *v45;
  unsigned int v46;
  unsigned int v47;
  CFIndex v48;
  uint64_t v49;
  __int128 *v50;
  const __CFNumber *v51;
  char *v52;
  __int128 v53;
  __int128 v54;
  unsigned int Count;
  _QWORD *v56;
  __int128 v57;
  __int128 v58;
  _QWORD *v59;
  _DWORD valuePtr[3];
  uint64_t v61;

  calibrated_parametric_data_f = 0;
  v61 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    Cache = CGColorTransformGetCache(a1);
    if (Cache)
    {
      v8 = Cache[2];
      if (v8)
      {
        if (*(_QWORD *)(*(_QWORD *)(v8 + 24) + 40) == 3)
        {
          *(_QWORD *)&v57 = MEMORY[0x1E0C809B0];
          *((_QWORD *)&v57 + 1) = 0x40000000;
          *(_QWORD *)&v58 = __create_resolved_source_space_block_invoke;
          *((_QWORD *)&v58 + 1) = &__block_descriptor_tmp_27_15656;
          v59 = a1;
          ResolvedColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)&v57);
          v10 = CGColorTransformGetCache(a1);
          Converter = (unsigned __int8 *)CGColorTransformCacheCreateConverter((uint64_t)v10, ResolvedColorSpace, a3);
          v12 = CGColorTransformUsesCalibratedColor(a1);
          if (!Converter)
          {
            calibrated_parametric_data_f = 0;
LABEL_75:
            CGColorSpaceRelease(ResolvedColorSpace);
            return calibrated_parametric_data_f;
          }
          v13 = v12;
          v17 = CFGetTypeID(Converter);
          v18 = kCGCMSConverterID;
          if (!kCGCMSConverterID)
          {
            pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
            v18 = kCGCMSConverterID;
          }
          if (v17 == v18)
          {
            if (!v13)
            {
              if (*((_QWORD *)Converter + 6) != 3 || *((_QWORD *)Converter + 5) != 3)
                _CGHandleAssert("create_linear_parametric_data", 5763, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSConverter.c", "converter != NULL && converter->nSrcComp == 3 && converter->nDstComp == 3", "converter: %p  src components: %lu  destComponents %lu", v14, v15, v16, (char)Converter);
              v24 = (char *)malloc_type_malloc(0x16CuLL, 0x10000403884A0CCuLL);
              *(_QWORD *)v24 = 0;
              *((_DWORD *)v24 + 2) = 1065353216;
              *(_QWORD *)(v24 + 12) = 0;
              *(_QWORD *)(v24 + 28) = 0;
              *(_QWORD *)(v24 + 20) = 0;
              *(_QWORD *)(v24 + 52) = 0x100000000;
              *((_DWORD *)v24 + 15) = 1065353216;
              *((_QWORD *)v24 + 9) = 0;
              *((_QWORD *)v24 + 10) = 0;
              *((_QWORD *)v24 + 8) = 0;
              *((_QWORD *)v24 + 13) = 0x200000000;
              *((_DWORD *)v24 + 28) = 1065353216;
              *(_QWORD *)(v24 + 116) = 0;
              *(_QWORD *)(v24 + 132) = 0;
              *(_QWORD *)(v24 + 124) = 0;
              *((_DWORD *)v24 + 40) = 1065353216;
              *(_QWORD *)(v24 + 172) = 0;
              *(_QWORD *)(v24 + 164) = 0;
              *((_DWORD *)v24 + 45) = 1065353216;
              *((_QWORD *)v24 + 23) = 0;
              *((_QWORD *)v24 + 24) = 0;
              *((_QWORD *)v24 + 25) = 1065353216;
              *((_QWORD *)v24 + 26) = 0x100000000;
              *((_DWORD *)v24 + 54) = 1065353216;
              *(_QWORD *)(v24 + 236) = 0;
              *(_QWORD *)(v24 + 220) = 0;
              *(_QWORD *)(v24 + 228) = 0;
              *(_QWORD *)(v24 + 260) = 0x200000000;
              *((_DWORD *)v24 + 67) = 1065353216;
              *((_QWORD *)v24 + 34) = 0;
              *((_QWORD *)v24 + 35) = 0;
              *((_QWORD *)v24 + 36) = 0;
              *((_QWORD *)v24 + 39) = 0x300000000;
              *((_DWORD *)v24 + 80) = 1065353216;
              *(_QWORD *)(v24 + 332) = 0;
              *(_QWORD *)(v24 + 324) = 0;
              v25 = 7;
              *(_QWORD *)(v24 + 340) = 0;
LABEL_72:
              calibrated_parametric_data_f = malloc_type_calloc(1uLL, 0x38uLL, 0x10E20400F34DD07uLL);
              *(_DWORD *)calibrated_parametric_data_f = 1;
              *(_QWORD *)((char *)calibrated_parametric_data_f + 12) = 0;
              *(_QWORD *)((char *)calibrated_parametric_data_f + 4) = 0;
              calibrated_parametric_data_f[3] = v25;
              calibrated_parametric_data_f[4] = v24;
LABEL_74:
              CFRelease(Converter);
              goto LABEL_75;
            }
            Retained = (const __CFArray *)*((_QWORD *)Converter + 11);
            if (!Retained)
            {
              v20 = (const __CFDictionary *)*((_QWORD *)Converter + 9);
              colorsync_profile_sequence = create_colorsync_profile_sequence(*((CGColorSpace **)Converter + 3), *((CGColorSpace **)Converter + 4), *((_DWORD *)Converter + 21), Converter[80]);
              if (colorsync_profile_sequence)
              {
                v22 = colorsync_profile_sequence;
                Retained = CGColorSyncTransformCacheGetRetained(colorsync_profile_sequence, v20);
                CFRelease(v22);
              }
              else
              {
                Retained = 0;
              }
            }
            if (create_calibrated_parametric_data_cglibrarypredicate != -1)
              dispatch_once(&create_calibrated_parametric_data_cglibrarypredicate, &__block_literal_global_126_2029);
            calibrated_parametric_data_f = (_QWORD *)create_calibrated_parametric_data_f(Retained, CFSTR("com.apple.cmm.ParametricConversion"), 0);
            if (!*((_QWORD *)Converter + 11))
              CGColorSyncTransformCacheRelease(Retained);
            if (!calibrated_parametric_data_f)
              goto LABEL_74;
            v26 = CFGetTypeID(calibrated_parametric_data_f);
            if (v26 == CFArrayGetTypeID())
            {
              Count = CFArrayGetCount((CFArrayRef)calibrated_parametric_data_f);
              v24 = (char *)malloc_type_malloc(52 * Count, 0x10000403884A0CCuLL);
              if (Count)
              {
                v27 = 0;
                v56 = calibrated_parametric_data_f;
                do
                {
                  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)calibrated_parametric_data_f, v27);
                  if (!ValueAtIndex)
                    goto LABEL_67;
                  v29 = ValueAtIndex;
                  v30 = CFGetTypeID(ValueAtIndex);
                  if (v30 != CFDictionaryGetTypeID())
                    goto LABEL_67;
                  v31 = (int *)&v24[52 * v27];
                  if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.Matrix")))
                  {
                    *v31 = 1836348024;
                    Value = (const __CFArray *)CFDictionaryGetValue(v29, CFSTR("com.apple.cmm.Matrix"));
                    v33 = 0;
                    v34 = &v57;
                    do
                    {
                      v35 = 0;
                      v36 = (char *)v34;
                      do
                      {
                        v37 = (const __CFArray *)CFArrayGetValueAtIndex(Value, v33);
                        v38 = (const __CFNumber *)CFArrayGetValueAtIndex(v37, v35);
                        CFNumberGetValue(v38, kCFNumberFloat32Type, v36);
                        ++v35;
                        v36 += 4;
                      }
                      while (v35 != 3);
                      v39 = (const __CFArray *)CFArrayGetValueAtIndex(Value, v33);
                      v40 = (const __CFNumber *)CFArrayGetValueAtIndex(v39, 3);
                      CFNumberGetValue(v40, kCFNumberFloat32Type, &valuePtr[v33++]);
                      v34 = (__int128 *)((char *)v34 + 12);
                    }
                    while (v33 != 3);
                    v41 = &v24[52 * v27];
                    *(_QWORD *)(v41 + 4) = v57;
                    *((_DWORD *)v41 + 3) = DWORD2(v57);
                    *((_DWORD *)v41 + 4) = valuePtr[0];
                    *((_DWORD *)v41 + 5) = HIDWORD(v57);
                    *((_QWORD *)v41 + 3) = v58;
                    *((_DWORD *)v41 + 8) = valuePtr[1];
                    *(_QWORD *)(v41 + 36) = *((_QWORD *)&v58 + 1);
                    *((_DWORD *)v41 + 11) = (_DWORD)v59;
                    *((_DWORD *)v41 + 12) = valuePtr[2];
                  }
                  else
                  {
                    v42 = CFSTR("com.apple.cmm.ParamCurve0");
                    if (!CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve0"))
                      && !CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve1"))
                      && !CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve2"))
                      && !CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve3"))
                      && !CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve4")))
                    {
                      *v31 = -1;
                      goto LABEL_67;
                    }
                    if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve0")))
                    {
                      v43 = 0;
                    }
                    else if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve1")))
                    {
                      v43 = 1;
                    }
                    else if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve2")))
                    {
                      v43 = 2;
                    }
                    else if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve3")))
                    {
                      v43 = 3;
                    }
                    else if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve4")))
                    {
                      v43 = 4;
                    }
                    else
                    {
                      v43 = -1;
                    }
                    *v31 = v43;
                    if (CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve0"))
                      || (v42 = CFSTR("com.apple.cmm.ParamCurve1"),
                          CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve1")))
                      || (v42 = CFSTR("com.apple.cmm.ParamCurve2"),
                          CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve2")))
                      || (v42 = CFSTR("com.apple.cmm.ParamCurve3"),
                          CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve3")))
                      || (v42 = CFSTR("com.apple.cmm.ParamCurve4"),
                          CFDictionaryContainsKey(v29, CFSTR("com.apple.cmm.ParamCurve4"))))
                    {
                      v44 = (const __CFArray *)CFDictionaryGetValue(v29, v42);
                    }
                    else
                    {
                      v44 = 0;
                    }
                    v45 = (const __CFNumber *)CFDictionaryGetValue(v29, CFSTR("com.apple.cmm.ChannelID"));
                    v46 = CFArrayGetCount(v44);
                    if (!v44)
                      goto LABEL_67;
                    if (!v45)
                      goto LABEL_67;
                    v47 = v46;
                    if (v46 - 7 > 1)
                      goto LABEL_67;
                    valuePtr[0] = 0;
                    CFNumberGetValue(v45, kCFNumberSInt32Type, valuePtr);
                    v48 = 0;
                    v57 = 0u;
                    v58 = 0u;
                    v49 = v47;
                    v50 = &v57;
                    do
                    {
                      v51 = (const __CFNumber *)CFArrayGetValueAtIndex(v44, v48);
                      CFNumberGetValue(v51, kCFNumberFloat32Type, v50);
                      ++v48;
                      v50 = (__int128 *)((char *)v50 + 4);
                    }
                    while (v49 != v48);
                    v52 = &v24[52 * v27];
                    v53 = v57;
                    v54 = v58;
                    *((_DWORD *)v52 + 1) = valuePtr[0];
                    *(_OWORD *)(v52 + 8) = v53;
                    *(_OWORD *)(v52 + 24) = v54;
                  }
                  calibrated_parametric_data_f = v56;
LABEL_67:
                  ++v27;
                }
                while (v27 != Count);
              }
              CFRelease(calibrated_parametric_data_f);
              v25 = Count;
              if (v24)
                goto LABEL_72;
            }
          }
          calibrated_parametric_data_f = 0;
          goto LABEL_74;
        }
      }
    }
    return 0;
  }
  return calibrated_parametric_data_f;
}

_QWORD *CGColorTransformCreateLookupTextureCodeFragment(_QWORD *a1, _QWORD *a2, uint64_t a3, int a4, unint64_t a5)
{
  _QWORD *v5;
  _QWORD *Cache;
  uint64_t v12;
  uint64_t ResolvedColorSpace;
  CGColorSpace *v14;
  uint64_t v15;
  _QWORD *v17;
  unsigned __int8 *Converter;
  _BOOL4 v19;
  _BOOL4 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFTypeID v28;
  uint64_t v29;
  const __CFArray *Retained;
  __CFDictionary *Mutable;
  const __CFArray *calibrated_lookup_texture_f;
  const __CFDictionary *ValueAtIndex;
  const __CFData *Value;
  char *RGB_to_RGBX8_texture;
  char *v36;
  char *v37;
  uint64_t v38;
  float v39;
  char *v40;
  uint64_t v41;
  unsigned int v42;
  _BYTE *v43;
  unint64_t v44;
  unsigned int v45;
  _BYTE *v46;
  unint64_t v47;
  unsigned int v48;
  const __CFDictionary *v49;
  __CFArray *colorsync_profile_sequence;
  __CFArray *v51;
  char *v52;
  uint64_t v53;
  float v54;
  char *v55;
  uint64_t v56;
  _WORD *v57;
  unint64_t v58;
  _WORD *v59;
  unint64_t v60;
  char *v61;
  unint64_t v62;
  float v63;
  float *v64;
  unint64_t v65;
  float v66;
  float *v67;
  unint64_t v68;
  float v69;
  float *v70;
  float v71;
  char *v72;
  unint64_t v73;
  _BYTE *v74;
  unint64_t v75;
  unsigned int v76;
  char v77;
  _QWORD v78[5];

  v5 = 0;
  if (a1 && a2)
  {
    Cache = CGColorTransformGetCache(a1);
    if (Cache)
    {
      v12 = Cache[2];
      if (v12)
      {
        if (*(_QWORD *)(*(_QWORD *)(v12 + 24) + 40) == 3)
        {
          v78[0] = MEMORY[0x1E0C809B0];
          v78[1] = 0x40000000;
          v78[2] = __create_resolved_source_space_block_invoke;
          v78[3] = &__block_descriptor_tmp_27_15656;
          v78[4] = a1;
          ResolvedColorSpace = CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)v78);
          v14 = (CGColorSpace *)ResolvedColorSpace;
          if (ResolvedColorSpace)
          {
            v15 = *(_QWORD *)(*(_QWORD *)(ResolvedColorSpace + 24) + 40);
            if (a4 == 3)
            {
              if (v15 != 1)
                goto LABEL_32;
            }
            else if (v15 != 3)
            {
              goto LABEL_32;
            }
            v17 = CGColorTransformGetCache(a1);
            Converter = (unsigned __int8 *)CGColorTransformCacheCreateConverter((uint64_t)v17, v14, a3);
            v19 = CGColorTransformUsesCalibratedColor(a1);
            if (Converter)
            {
              v20 = v19;
              v28 = CFGetTypeID(Converter);
              v29 = kCGCMSConverterID;
              if (!kCGCMSConverterID)
              {
                pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
                v29 = kCGCMSConverterID;
              }
              if (v28 != v29)
                goto LABEL_64;
              if (!v20)
              {
                if ((a4 != 3 || a5 <= 0x100) && (a4 == 3 || a5 <= 0x80))
                {
                  switch(a4)
                  {
                    case 0:
                      v36 = (char *)malloc_type_calloc(4 * a5 * a5 * a5, 1uLL, 0x6D658DB9uLL);
                      v37 = v36;
                      if (!a5 || !v36)
                        goto LABEL_61;
                      v38 = 0;
                      v39 = (float)(a5 - 1);
                      v40 = v36 + 3;
                      do
                      {
                        v41 = 0;
                        v42 = ((int)((float)((float)(unint64_t)(255 * v38) / v39) + 0.5) + 128) >> 8;
                        if (v42 >= 0xFF)
                          LOBYTE(v42) = -1;
                        v43 = v40;
                        do
                        {
                          v44 = 0;
                          v45 = ((int)((float)((float)(unint64_t)(255 * v41) / v39) + 0.5) + 128) >> 8;
                          if (v45 >= 0xFF)
                            LOBYTE(v45) = -1;
                          v46 = v43;
                          v47 = a5;
                          do
                          {
                            v48 = ((int)((float)((float)v44 / v39) + 0.5) + 128) >> 8;
                            *(v46 - 3) = v42;
                            *(v46 - 2) = v45;
                            if (v48 >= 0xFF)
                              LOBYTE(v48) = -1;
                            *(v46 - 1) = v48;
                            *v46 = -1;
                            v46 += 4;
                            v44 += 255;
                            --v47;
                          }
                          while (v47);
                          ++v41;
                          v43 += 4 * a5;
                        }
                        while (v41 != a5);
                        ++v38;
                        v40 += 4 * a5 * a5;
                      }
                      while (v38 != a5);
                      break;
                    case 1:
                      v52 = (char *)malloc_type_calloc(8 * a5 * a5 * a5, 1uLL, 0x90A802BCuLL);
                      v37 = v52;
                      if (!a5 || !v52)
                        goto LABEL_61;
                      v53 = 0;
                      v54 = (float)(a5 - 1);
                      v55 = v52 + 4;
                      do
                      {
                        v56 = 0;
                        v57 = v55;
                        do
                        {
                          v58 = 0;
                          v59 = v57;
                          v60 = a5;
                          do
                          {
                            *(v59 - 2) = (int)((float)((float)(unint64_t)(0xFFFF * v53) / v54)
                                                              + 0.5);
                            *(v59 - 1) = (int)((float)((float)(unint64_t)(0xFFFF * v56) / v54)
                                                              + 0.5);
                            *v59 = (int)((float)((float)v58 / v54) + 0.5);
                            v59[1] = -1;
                            v58 += 0xFFFFLL;
                            v59 += 4;
                            --v60;
                          }
                          while (v60);
                          ++v56;
                          v57 += 4 * a5;
                        }
                        while (v56 != a5);
                        ++v53;
                        v55 += 8 * a5 * a5;
                      }
                      while (v53 != a5);
                      break;
                    case 2:
                      v61 = (char *)malloc_type_calloc(16 * a5 * a5 * a5, 1uLL, 0xCCC4138CuLL);
                      v37 = v61;
                      if (!a5 || !v61)
                        goto LABEL_61;
                      v62 = 0;
                      v63 = (float)(a5 - 1);
                      v64 = (float *)(v61 + 8);
                      do
                      {
                        v65 = 0;
                        v66 = (float)v62 / v63;
                        if (v66 > 1.0)
                          v66 = 1.0;
                        v67 = v64;
                        do
                        {
                          v68 = 0;
                          v69 = (float)v65 / v63;
                          if (v69 > 1.0)
                            v69 = 1.0;
                          v70 = v67;
                          do
                          {
                            v71 = (float)v68 / v63;
                            if (v71 > 1.0)
                              v71 = 1.0;
                            *(v70 - 2) = v66;
                            *(v70 - 1) = v69;
                            *v70 = v71;
                            v70[1] = 1.0;
                            ++v68;
                            v70 += 4;
                          }
                          while (a5 != v68);
                          ++v65;
                          v67 += 4 * a5;
                        }
                        while (v65 != a5);
                        ++v62;
                        v64 += 4 * a5 * a5;
                      }
                      while (v62 != a5);
                      break;
                    case 3:
                      v72 = (char *)malloc_type_calloc(4 * a5, 1uLL, 0x37B7D386uLL);
                      v37 = v72;
                      if (!a5 || !v72)
                        goto LABEL_61;
                      v73 = 0;
                      v74 = v72 + 3;
                      v75 = a5;
                      do
                      {
                        v76 = ((int)((float)((float)v73 / (float)(a5 - 1)) + 0.5) + 128) >> 8;
                        if (v76 >= 0xFF)
                          LOBYTE(v76) = -1;
                        *(v74 - 3) = v76;
                        *(v74 - 2) = v76;
                        *(v74 - 1) = v76;
                        *v74 = -1;
                        v74 += 4;
                        v73 += 255;
                        --v75;
                      }
                      while (v75);
                      break;
                    default:
                      goto LABEL_63;
                  }
                  goto LABEL_62;
                }
                goto LABEL_63;
              }
              Retained = (const __CFArray *)*((_QWORD *)Converter + 11);
              if (!Retained)
              {
                v49 = (const __CFDictionary *)*((_QWORD *)Converter + 9);
                colorsync_profile_sequence = create_colorsync_profile_sequence(*((CGColorSpace **)Converter + 3), *((CGColorSpace **)Converter + 4), *((_DWORD *)Converter + 21), Converter[80]);
                if (!colorsync_profile_sequence)
                {
                  Retained = 0;
                  goto LABEL_58;
                }
                v51 = colorsync_profile_sequence;
                Retained = CGColorSyncTransformCacheGetRetained(colorsync_profile_sequence, v49);
                CFRelease(v51);
                if (!Retained)
                  goto LABEL_58;
              }
              if ((a4 != 3 || a5 <= 0x100) && (a4 == 3 || a5 <= 0x80))
              {
                Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                CGCFDictionarySetInteger(Mutable, CFSTR("com.apple.cmm.GridPointCount"), a5);
                if (create_calibrated_lookup_texture_cglibrarypredicate != -1)
                  dispatch_once(&create_calibrated_lookup_texture_cglibrarypredicate, &__block_literal_global_118_2023);
                calibrated_lookup_texture_f = (const __CFArray *)create_calibrated_lookup_texture_f(Retained, CFSTR("com.apple.cmm.SimplifiedConversion"), Mutable);
                if (Mutable)
                  CFRelease(Mutable);
                if (calibrated_lookup_texture_f)
                {
                  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(calibrated_lookup_texture_f, 0);
                  if (ValueAtIndex
                    && (Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("com.apple.cmm.3D-LUT"))) != 0)
                  {
                    switch(a4)
                    {
                      case 0:
                        RGB_to_RGBX8_texture = create_RGB_to_RGBX8_texture(Value, a5);
                        break;
                      case 1:
                        RGB_to_RGBX8_texture = create_RGB_to_RGBX16_texture(Value, a5);
                        break;
                      case 2:
                        RGB_to_RGBX8_texture = create_RGB_to_RGBXF_texture(Value, a5);
                        break;
                      case 3:
                        RGB_to_RGBX8_texture = create_gray_to_RGBX8_texture(Value, a5);
                        break;
                      default:
                        goto LABEL_66;
                    }
                    v37 = RGB_to_RGBX8_texture;
                  }
                  else
                  {
LABEL_66:
                    v37 = 0;
                  }
                  CFRelease(calibrated_lookup_texture_f);
                  goto LABEL_59;
                }
              }
LABEL_58:
              v37 = 0;
LABEL_59:
              if (!*((_QWORD *)Converter + 11))
                CGColorSyncTransformCacheRelease(Retained);
LABEL_61:
              if (v37)
              {
LABEL_62:
                v5 = malloc_type_calloc(1uLL, 0x38uLL, 0x10E20400F34DD07uLL);
                *v5 = 0;
                v5[1] = 0;
                *((_DWORD *)v5 + 4) = 0;
                *((_DWORD *)v5 + 8) = a4;
                v5[5] = a5;
                v5[6] = v37;
LABEL_65:
                CFRelease(Converter);
                goto LABEL_33;
              }
LABEL_63:
              CGPostError((uint64_t)"Failed to create a 3D texture", v21, v22, v23, v24, v25, v26, v27, v77);
LABEL_64:
              v5 = 0;
              goto LABEL_65;
            }
          }
LABEL_32:
          v5 = 0;
LABEL_33:
          CGColorSpaceRelease(v14);
          return v5;
        }
      }
    }
    return 0;
  }
  return v5;
}

_QWORD *CGColorTransformCreateCodeFragment(_QWORD *a1, _QWORD *a2, uint64_t a3, int a4, int a5, unint64_t a6)
{
  if (!a4)
    return CGColorTransformCreateLookupTextureCodeFragment(a1, a2, a3, a5, a6);
  if (a4 != 1)
    abort();
  return CGColorTransformCreateParametricCodeFragment(a1, a2, a3);
}

uint64_t CGColorCodeFragmentGetTextureFormat(_DWORD *a1)
{
  if (a1 && !*a1)
    return a1[8];
  else
    return 0xFFFFFFFFLL;
}

uint64_t CGColorCodeFragmentGetTextureGridPoints(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result)
      return 0;
    else
      return *(_QWORD *)(result + 40);
  }
  return result;
}

uint64_t CGColorCodeFragmentGetTextureData(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result)
      return 0;
    else
      return *(_QWORD *)(result + 48);
  }
  return result;
}

uint64_t CGColorCodeFragmentGetParametricCount(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1)
      return *(_QWORD *)(result + 24);
    else
      return 0;
  }
  return result;
}

uint64_t CGColorCodeFragmentGetParametricConversion(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1)
      return *(_QWORD *)(result + 32);
    else
      return 0;
  }
  return result;
}

void CGColorCodeFragmentRelease(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    if (*(_DWORD *)a1)
    {
      v2 = (void *)a1[4];
    }
    else
    {
      v2 = (void *)a1[6];
      if (!v2)
      {
LABEL_7:
        free(a1);
        return;
      }
    }
    free(v2);
    goto LABEL_7;
  }
}

const void *CGDefaultsGetBoolean(const char *a1, BOOL *a2)
{
  return get_BOOLean_property(a1, (const void *(*)(const char *))copy_local_domain_value, a2);
}

CFTypeRef copy_application_property_value(const char *a1)
{
  CFBundleRef MainBundle;
  __CFBundle *v3;
  const __CFString *v4;
  const __CFString *v5;
  CFTypeRef ValueForInfoDictionaryKey;

  MainBundle = CFBundleGetMainBundle();
  if (MainBundle
    && a1
    && (v3 = MainBundle, (v4 = CFStringCreateWithCString(0, a1, 0x600u)) != 0)
    && (v5 = v4,
        ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v3, v4),
        CFRelease(v5),
        ValueForInfoDictionaryKey))
  {
    return CFRetain(ValueForInfoDictionaryKey);
  }
  else
  {
    return 0;
  }
}

uint64_t CGDefaultsGetInteger(const char *a1, int *a2)
{
  return get_integer_property(a1, (const void *(*)(const char *))copy_local_domain_value, a2);
}

uint64_t CGDefaultsCopyString(const char *a1, const __CFString **a2)
{
  return copy_string_property(a1, (const void *(*)(const char *))copy_local_domain_value, a2);
}

const void *CGPreferencesGetBoolean(const char *a1, BOOL *a2)
{
  return get_BOOLean_property(a1, copy_preference_value, a2);
}

uint64_t CGPreferencesGetInteger(const char *a1, int *a2)
{
  return get_integer_property(a1, copy_preference_value, a2);
}

uint64_t CGPreferencesGetCGFloat(const char *a1, double *a2)
{
  const __CFNumber *v3;
  const __CFNumber *v4;
  CFTypeID v5;
  double DoubleValue;
  uint64_t v7;
  double valuePtr;

  v3 = (const __CFNumber *)copy_preference_value(a1);
  if (v3)
  {
    v4 = v3;
    v5 = CFGetTypeID(v3);
    if (v5 == CFNumberGetTypeID())
    {
      valuePtr = 0.0;
      if (CFNumberGetValue(v4, kCFNumberCGFloatType, &valuePtr))
      {
        if (a2)
        {
          DoubleValue = valuePtr;
LABEL_10:
          *a2 = DoubleValue;
          goto LABEL_11;
        }
        goto LABEL_11;
      }
    }
    else if (v5 == CFStringGetTypeID())
    {
      if (a2)
      {
        DoubleValue = CFStringGetDoubleValue((CFStringRef)v4);
        goto LABEL_10;
      }
LABEL_11:
      v7 = 1;
LABEL_13:
      CFRelease(v4);
      return v7;
    }
    v7 = 0;
    goto LABEL_13;
  }
  return 0;
}

uint64_t CGPreferencesCopyString(const char *a1, const __CFString **a2)
{
  return copy_string_property(a1, copy_preference_value, a2);
}

const void *CGApplicationPropertyGetBoolean(const char *a1, BOOL *a2)
{
  return get_BOOLean_property(a1, copy_application_property_value, a2);
}

uint64_t CGDefaultsCheck<CGResamplingAllowTemplateMethod>()
{
  if (CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1)
    dispatch_once(&CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_12428);
  return CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::result;
}

uint64_t CGPreferencesCheck<CGResamplingAllowTemplateMethod>()
{
  if (CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_2_12434);
  return CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::result;
}

uint64_t CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>()
{
  if (CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1)
    dispatch_once(&CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_4_12436);
  return CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
}

uint64_t CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>()
{
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_6_12441);
  return CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
}

uint64_t CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>()
{
  if (CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken != -1)
    dispatch_once(&CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken, &__block_literal_global_8_12443);
  return CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result;
}

uint64_t CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>()
{
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken, &__block_literal_global_10_12448);
  return CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result;
}

uint64_t CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>()
{
  if (CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken != -1)
    dispatch_once(&CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken, &__block_literal_global_12_12452);
  return CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result;
}

uint64_t CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>()
{
  if (CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken, &__block_literal_global_14_12455);
  return CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result;
}

uint64_t ___Z18CGPreferencesCheckI35CGPDFDocumentPageResourcesCacheSizeENT_10ResultTypeEv_block_invoke()
{
  uint64_t result;

  result = get_integer_property("CGPDFDocumentPageResourcesCacheSize", copy_preference_value, &CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result);
  if ((result & 1) == 0)
    CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result = 16;
  return result;
}

uint64_t CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>()
{
  if (CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken != -1)
    dispatch_once(&CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken, &__block_literal_global_16_12459);
  return CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::result;
}

uint64_t CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>()
{
  if (CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken, &__block_literal_global_18_12462);
  return CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::result;
}

uint64_t CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>()
{
  if (CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken != -1)
    dispatch_once(&CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken, &__block_literal_global_20_12464);
  return CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::result;
}

uint64_t CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>()
{
  if (CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken != -1)
    dispatch_once(&CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken, &__block_literal_global_22);
  return CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::result;
}

char *CGPDFShadingCreateShadingFunction(uint64_t a1, size_t a2)
{
  CGPDFArray *v2;
  size_t v3;
  unint64_t *v5;
  size_t v6;
  char *Function;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  char *result;
  CGPDFObjectRef value;
  CGFloat domain[2];
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  value = (CGPDFObjectRef)a1;
  if (!a1 || *(_DWORD *)(a1 + 8) != 7)
    return CGPDFFunctionCreateFunction((char *)a1);
  v2 = *(CGPDFArray **)(a1 + 32);
  if (!v2)
    return 0;
  v3 = *((_QWORD *)v2 + 2);
  if (!v3)
    return 0;
  v5 = (unint64_t *)malloc_type_calloc(1uLL, 8 * v3 + 8, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (!v5)
    return 0;
  v6 = 0;
  *v5 = v3;
  do
  {
    if (!CGPDFArrayGetObject(v2, v6, &value))
      goto LABEL_34;
    Function = CGPDFFunctionCreateFunction((char *)value);
    v5[v6 + 1] = (unint64_t)Function;
    if (!Function)
      goto LABEL_34;
    if (*((_QWORD *)Function + 4) != a2)
    {
      pdf_error("invalid shading function domain dimension.");
LABEL_34:
      shading_function_array_release(v5);
      return 0;
    }
    if (*((_QWORD *)Function + 6) != 1)
    {
      pdf_error("invalid shading function range dimension.");
      goto LABEL_34;
    }
    ++v6;
  }
  while (v3 != v6);
  *(_OWORD *)domain = xmmword_185004E70;
  if (a2 == 2)
    v22 = xmmword_185004E70;
  v8 = 0;
  if (v3 <= 1)
    v9 = 1;
  else
    v9 = v3;
  v10 = 1.79769313e308;
  v11 = -1.79769313e308;
  v12 = -1.79769313e308;
  v13 = 1.79769313e308;
  do
  {
    v14 = *(double **)(v5[v8 + 1] + 40);
    v15 = *v14;
    if (*v14 < v13)
    {
      domain[0] = *v14;
      v13 = v15;
    }
    v16 = v14[1];
    if (v16 > v12)
    {
      domain[1] = v14[1];
      v12 = v16;
    }
    if (a2 != 2)
      goto LABEL_27;
    v17 = v14[2];
    if (v17 < v10)
    {
      *(double *)&v22 = v14[2];
      v10 = v17;
    }
    v18 = v14[3];
    if (v18 > v11)
      *((double *)&v22 + 1) = v14[3];
    else
LABEL_27:
      v18 = v11;
    ++v8;
    v11 = v18;
  }
  while (v9 != v8);
  result = (char *)CGFunctionCreate(v5, a2, domain, v3, 0, &CGPDFShadingCreateShadingFunction_callbacks);
  if (!result)
    goto LABEL_34;
  return result;
}

void shading_function_array_release(unint64_t *a1)
{
  unint64_t v2;
  unint64_t v3;
  const void *v4;

  v2 = *a1;
  if (*a1)
  {
    v3 = 0;
    do
    {
      v4 = (const void *)a1[v3 + 1];
      if (v4)
      {
        CFRelease(v4);
        v2 = *a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }
  free(a1);
}

unint64_t *shading_function_array_evaluate(unint64_t *result, char *a2, double *a3)
{
  unint64_t *v5;
  unint64_t v6;

  if (*result)
  {
    v5 = result;
    v6 = 0;
    do
      result = (unint64_t *)CGFunctionEvaluate(v5[++v6], a2, a3++);
    while (v6 < *v5);
  }
  return result;
}

_QWORD *CPMultiUnicodesCreate()
{
  _QWORD *v0;

  v0 = malloc_type_malloc(0x20uLL, 0x1020040A5B76CDFuLL);
  v0[1] = 0;
  v0[2] = 0;
  *v0 = 1;
  v0[3] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  return v0;
}

void CPMultiUnicodesRelease(void *a1)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  void **ValueAtIndex;
  void **v8;

  if (a1)
  {
    if ((*(_QWORD *)a1)-- == 1)
    {
      v3 = (const __CFArray *)*((_QWORD *)a1 + 3);
      if (v3)
      {
        Count = CFArrayGetCount(v3);
        if (Count >= 1)
        {
          v5 = Count;
          for (i = 0; i != v5; ++i)
          {
            ValueAtIndex = (void **)CFArrayGetValueAtIndex(*((CFArrayRef *)a1 + 3), i);
            if (ValueAtIndex)
            {
              v8 = ValueAtIndex;
              free(ValueAtIndex[3]);
              free(v8);
            }
          }
        }
        CFRelease(*((CFTypeRef *)a1 + 3));
      }
      free(a1);
    }
  }
}

void CPMultiUnicodesAppend(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v10;
  uint64_t v11;
  unint64_t v12;
  void **ValueAtIndex;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  uint64_t v19;

  if (a1)
  {
    v5 = *(const __CFArray **)(a1 + 24);
    if (v5)
    {
      Count = CFArrayGetCount(v5);
      v10 = Count - 1;
      if (Count >= 1)
      {
        v11 = *(_QWORD *)(a1 + 8);
        if (v11 > a2)
        {
          if (a2 + 1 != v11)
            return;
          v12 = Count;
          ValueAtIndex = (void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v10);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), v10);
          if (ValueAtIndex)
          {
            free(ValueAtIndex[3]);
            free(ValueAtIndex);
          }
          if (v12 < 2)
          {
            *(_QWORD *)(a1 + 8) = 0;
            *(_QWORD *)(a1 + 16) = 0;
          }
          else
          {
            v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v12 - 2);
            if (v14)
            {
              v15 = v14[2] + v14[1];
              *(_QWORD *)(a1 + 8) = *v14 + 1;
              *(_QWORD *)(a1 + 16) = v15;
            }
          }
        }
      }
      v16 = malloc_type_malloc(0x20uLL, 0x1010040313BCFEBuLL);
      if (v16)
      {
        v17 = v16;
        *v16 = a2;
        v18 = malloc_type_malloc(2 * a3, 0x1000040BDFB0063uLL);
        v17[3] = v18;
        if (v18)
        {
          v17[2] = a3;
          memcpy(v18, a4, 2 * a3);
        }
        else
        {
          v17[2] = 0;
        }
        v17[1] = *(_QWORD *)(a1 + 16) + a2 - *(_QWORD *)(a1 + 8);
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 24), v17);
        v19 = v17[2] + v17[1];
        *(_QWORD *)(a1 + 8) = a2 + 1;
        *(_QWORD *)(a1 + 16) = v19;
      }
    }
  }
}

uint64_t CPMultiUnicodesGetCharacterIndexAtUnicodeIndex(uint64_t a1, unint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *ValueAtIndex;
  uint64_t v12;

  if (a1)
  {
    v4 = *(const __CFArray **)(a1 + 24);
    if (v4)
    {
      Count = CFArrayGetCount(v4);
      if (Count >= 1)
      {
        v6 = Count;
        v7 = 0;
        v8 = -1;
        do
        {
          v9 = v6 + v8;
          if (v6 + v8 < 0 != __OFADD__(v6, v8))
            ++v9;
          v10 = v9 >> 1;
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v9 >> 1);
          if (!ValueAtIndex)
            break;
          v12 = ValueAtIndex[1];
          if (v12 <= (uint64_t)a2)
          {
            if (ValueAtIndex[2] + v12 > a2)
              return *ValueAtIndex;
            v8 = v10;
            v10 = v6;
            v7 = ValueAtIndex;
          }
          else
          {
            v6 = v10;
          }
        }
        while (v8 + 1 < v10);
        if (v7)
          return a2 + *v7 - (v7[1] + v7[2]) + 1;
      }
    }
  }
  return a2;
}

uint64_t CPMultiUnicodesGetUnicodeRangeAtCharacterIndex(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *ValueAtIndex;

  if (a1)
  {
    v4 = *(const __CFArray **)(a1 + 24);
    if (v4)
    {
      Count = CFArrayGetCount(v4);
      if (Count >= 1)
      {
        v6 = Count;
        v7 = 0;
        v8 = -1;
        do
        {
          v9 = v6 + v8;
          if (v6 + v8 < 0 != __OFADD__(v6, v8))
            ++v9;
          v10 = v9 >> 1;
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v9 >> 1);
          if (!ValueAtIndex)
            break;
          if (*ValueAtIndex == a2)
            return ValueAtIndex[1];
          if (*ValueAtIndex >= a2)
            v6 = v10;
          else
            v8 = v10;
          if (*ValueAtIndex < a2)
            v7 = ValueAtIndex;
        }
        while (v8 + 1 < v6);
        if (v7)
          a2 += ~*v7 + v7[1] + v7[2];
      }
    }
  }
  return a2;
}

uint64_t CPMultiUnicodesGetRangeInCharacterRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFArray *v5;
  BOOL v6;
  CFIndex Count;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *ValueAtIndex;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;

  if (!a1)
    return 0x7FFFFFFFFFFFFFFFLL;
  v5 = *(const __CFArray **)(a1 + 24);
  if (v5)
    v6 = a3 < 1;
  else
    v6 = 1;
  if (v6)
    return 0x7FFFFFFFFFFFFFFFLL;
  Count = CFArrayGetCount(v5);
  v10 = Count;
  v11 = Count - 1;
  if (Count >= 1)
  {
    v12 = a3 + a2 - 1;
    v13 = -1;
    v14 = Count;
    do
    {
      v15 = v14 + v13;
      if (v14 + v13 < 0 != __OFADD__(v14, v13))
        ++v15;
      v16 = v15 >> 1;
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v15 >> 1);
      if (!ValueAtIndex)
        break;
      if (*ValueAtIndex == a2)
      {
        v14 = v16;
        break;
      }
      if (*ValueAtIndex >= a2)
        v14 = v16;
      else
        v13 = v16;
    }
    while (v13 + 1 < v14);
    v11 = v14 - 1;
    if (v14 < v10)
    {
      do
      {
        v18 = v10 + v11;
        if (v10 + v11 < 0 != __OFADD__(v10, v11))
          ++v18;
        v19 = v18 >> 1;
        v20 = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v18 >> 1);
        if (!v20)
          break;
        if (*v20 == v12)
        {
          v10 = v14;
          v11 = v19;
          goto LABEL_31;
        }
        if (*v20 >= v12)
          v10 = v19;
        else
          v11 = v19;
      }
      while (v11 + 1 < v10);
    }
    v10 = v14;
  }
LABEL_31:
  if ((unint64_t)(v11 - v10) <= 0x7FFFFFFFFFFFFFFELL)
    return v10;
  else
    return 0x7FFFFFFFFFFFFFFFLL;
}

void CG::Path::convert_to_huge_(CG::Path *this)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  CGAffineTransform cf;
  CGSize v10;

  CG::Path::Path((CG::Path *)&v8, this);
  if (*(_DWORD *)this == 7)
  {
    v2 = (const void *)*((_QWORD *)this + 1);
    if (v2)
      CFRelease(v2);
  }
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *(int64x2_t *)((char *)this + 40) = vdupq_n_s64(0x7FF0000000000000uLL);
  *(int64x2_t *)((char *)this + 56) = vdupq_n_s64(0xFFF0000000000000);
  *(_DWORD *)this = 9;
  CG::Path::reserve_space(this, 24, 12);
  switch((int)v8)
  {
    case 1:
      CG::Path::append_rect(this, &unit_rect, (float64x2_t *)&cf);
      break;
    case 2:
      CG::Path::append_rounded_rect(this, &unit_rect, v10, &cf);
      break;
    case 3:
      CG::Path::append_uneven_rounded_rect(this, &unit_rect, &v10, (float64x2_t *)&cf);
      break;
    case 4:
      CG::Path::append_ellipse(this, &unit_rect, BYTE1(v10.width), LOBYTE(v10.width), &cf);
      break;
    case 5:
      CG::Path::append_line_segment(this, (__n128 *)&cf, (float64x2_t *)&cf.c, 0);
      break;
    case 6:
      CG::Path::add_arc_relative(this, (float64x2_t *)&CGPointZero, 1.0, 0.0, v10.width, (float64x2_t *)&cf, 1);
      break;
    case 7:
      CG::Path::append_region(this, *(uint64_t **)&cf.a, 0, v3, v4, v5, v6, v7);
      break;
    case 8:
      CG::Path::append_tiny(this, (const CGPoint *)&cf.b, LOWORD(cf.a), HIDWORD(cf.a), WORD1(cf.a));
      break;
    default:
      break;
  }
  CG::Path::recalculate_subpath_start(this);
  CG::Path::~Path(&v8);
}

void sub_184CD0B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  CG::Path::~Path(&a9);
  _Unwind_Resume(a1);
}

double CG::Path::append_line_segment(CG::Path *this, __n128 *a2, float64x2_t *a3, const CGAffineTransform *a4)
{
  double v5;
  double b;
  double c;
  double d;
  double tx;
  double ty;
  __n128 v11;
  double v12;
  double result;
  float64x2_t v14;
  uint64_t v15;
  __int16 v16;
  const CGAffineTransform *v17;
  const CGAffineTransform *v18;
  __n128 v19;
  float64x2_t v20;

  if (a4)
  {
    v5 = a2->n128_f64[1];
    b = a4->b;
    c = a4->c;
    d = a4->d;
    tx = a4->tx;
    ty = a4->ty;
    v11.n128_f64[0] = tx + v5 * c + a4->a * a2->n128_f64[0];
    v11.n128_f64[1] = ty + v5 * d + b * a2->n128_f64[0];
    v12 = a3->f64[1];
    v14.f64[0] = tx + v12 * c + a4->a * a3->f64[0];
    result = ty + v12 * d + b * a3->f64[0];
    v14.f64[1] = result;
  }
  else
  {
    v11 = *a2;
    v14 = *a3;
  }
  if (*(_DWORD *)this == 8)
  {
    v15 = *((unsigned __int16 *)this + 4);
    if (v15 <= 5)
    {
      *((__n128 *)this + v15 + 1) = v11;
      *((_WORD *)this + 4) = v15 + 2;
      *((float64x2_t *)this + v15 + 2) = v14;
      v16 = *((_WORD *)this + 5);
      *((_DWORD *)this + 3) |= 8 << (3 * v16);
      *((_WORD *)this + 5) = v16 + 2;
      return result;
    }
  }
  else if (!*(_DWORD *)this)
  {
    *(_DWORD *)this = 5;
    *(__n128 *)((char *)this + 8) = v11;
    *(float64x2_t *)((char *)this + 24) = v14;
    return result;
  }
  v19 = v11;
  v20 = v14;
  CG::Path::reserve_space(this, 2, 2);
  CG::Path::move_to_point(this, 0, v17, v19);
  *(_QWORD *)&result = *(_OWORD *)&CG::Path::add_line_to_point(this, 0, v18, v20);
  return result;
}

void *CG::Path::append_region(CG::Path *this, uint64_t *cf, float64x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v11;
  double v12;
  const void *v14;
  char v15;
  int v16;
  const CGAffineTransform *v17;
  void *result;
  float64x2_t v19;
  float64x2_t v20;
  _OWORD v21[3];

  if (*(_DWORD *)this != 9)
  {
    if (!*(_DWORD *)this)
    {
      if (a3)
      {
        if (fabs(a3->f64[0]) != 1.0 || fabs(a3[1].f64[1]) != 1.0 || a3->f64[1] != 0.0 || a3[1].f64[0] != 0.0)
          goto LABEL_12;
        v11 = a3[2].f64[1];
        v12 = floor(v11);
        if (floor(a3[2].f64[0]) != a3[2].f64[0] || v12 != v11)
          goto LABEL_12;
        *(_DWORD *)this = 7;
        v19 = a3[1];
        v21[0] = *a3;
        v21[1] = v19;
        v21[2] = a3[2];
        result = CGRegionCreateByTransformingRegion(cf, (uint64_t)v21, 1, a4, a5, a6, a7, a8);
      }
      else
      {
        *(_DWORD *)this = 7;
        if (cf)
          result = (void *)CFRetain(cf);
        else
          result = 0;
      }
      *((_QWORD *)this + 1) = result;
      return result;
    }
LABEL_12:
    CG::Path::convert_to_huge_(this);
  }
  v14 = (const void *)CGSRegionPathEnumerator(cf);
  v15 = 0;
  while (1)
  {
    v16 = CGSNextPoint((uint64_t)v14, v20.f64);
    if (!v16)
      break;
    if (a3)
      v20 = vaddq_f64(a3[2], vmlaq_n_f64(vmulq_n_f64(a3[1], v20.f64[1]), *a3, v20.f64[0]));
    if (v16 < 0)
    {
      if ((v15 & 1) != 0)
        CG::Path::close_subpath(this);
      CG::Path::move_to_point(this, 0, v17, (__n128)v20);
      v15 = 1;
    }
    else
    {
      CG::Path::add_line_to_point(this, 0, v17, v20);
    }
  }
  if ((v15 & 1) != 0)
    CG::Path::close_subpath(this);
  return (void *)CGSReleaseRegionEnumerator(v14);
}

_QWORD *CG::Path::recalculate_subpath_start(_QWORD *this)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = this[2];
  v1 = this[3];
  if (v1 >= v2)
  {
    v3 = this[1];
    v4 = this[4] + v1;
    v5 = -(uint64_t)v2;
    while (1)
    {
      v3 -= point_counts[*(unsigned __int8 *)(v4 + v5)];
      if (!*(_BYTE *)(v4 + v5))
        break;
      if (!++v5)
        return this;
    }
    this[9] = v3;
  }
  return this;
}

void CG::Path::append_continuous_rounded_rect(CG::Path *this, const CGRect *a2, CGSize a3, float64x2_t *a4)
{
  double height;
  double width;
  const CGAffineTransform *v9;
  uint64_t v10;
  double x;
  double y;
  double v13;
  double v14;
  double v15;
  double v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  double v21;
  double v22;
  __n128 v23;
  float64x2_t v24;
  const CGAffineTransform *v25;
  float64x2_t v26;
  const CGAffineTransform *v27;
  double v28;
  float64x2_t v29;
  double v30;
  const CGAffineTransform *v31;
  float64x2_t v32;
  const CGAffineTransform *v33;
  float64x2_t v34;
  const CGAffineTransform *v35;
  float64x2_t v36;
  double v37;
  const CGAffineTransform *v38;
  float64x2_t v39;
  const CGAffineTransform *v40;
  float64x2_t v41;
  const CGAffineTransform *v42;
  float64x2_t v43;
  const CGAffineTransform *v44;
  float64x2_t v45;
  const CGAffineTransform *v46;
  float64x2_t v47;
  const CGAffineTransform *v48;
  float64x2_t v49;
  const CGAffineTransform *v50;
  float64x2_t v51;
  const CGAffineTransform *v52;
  float64x2_t v53;
  const CGAffineTransform *v54;
  float64x2_t v55;
  const CGAffineTransform *v56;
  CGFloat v57;
  CGFloat v58;
  CGFloat v59;
  double v60;
  double v61;
  CGFloat v62;
  CGFloat v63;
  CGFloat v64;
  double v65;
  double v66;
  CGFloat v67;
  CGFloat v68;
  CGFloat v69;
  double v70;
  CGFloat v71;
  CGFloat v72;
  CGFloat v73;
  double v74;
  CGFloat v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  CGFloat v81;
  double v82;
  CGFloat v83;
  double v84;
  CGFloat v85;
  double v86;
  double v87;
  double v88;
  double v89;
  CGPoint v90;
  CGPoint v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  double v102;
  double v103;
  double v104;
  double v105;
  double v106;
  double v107;
  double v108;
  double v109;
  double v110;
  double v111;
  uint64_t v112;

  height = a3.height;
  width = a3.width;
  v112 = *MEMORY[0x1E0C80C00];
  CG::Path::reserve_space(this, 41, 17);
  v10 = 0;
  x = a2->origin.x;
  y = a2->origin.y;
  v13 = a2->size.width;
  v14 = a2->size.height;
  v15 = (v14 * 0.5 / height + -1.52866) / -0.52866;
  if (v15 > 1.0)
    v15 = 1.0;
  if (v15 < 0.0)
    v15 = 0.0;
  v16 = (v13 * 0.5 / width + -1.52866) / -0.52866;
  if (v16 > 1.0)
    v16 = 1.0;
  if (v16 < 0.0)
    v16 = 0.0;
  v17 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - v16), 0);
  v18 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - v15), 0);
  do
  {
    v19 = (float64x2_t)CG::Path::append_continuous_rounded_rect(CGRect const&,CGSize,CGAffineTransform const*)::continuous[v10];
    v20 = (float64x2_t)CG::Path::append_continuous_rounded_rect(CGRect const&,CGSize,CGAffineTransform const*)::circular[v10];
    *(float64x2_t *)((char *)&v102 + v10 * 16) = vmlaq_f64(vmulq_n_f64(v20, v16), v17, v19);
    *(float64x2_t *)((char *)&v92 + v10 * 16) = vmlaq_f64(vmulq_n_f64(v20, v15), v18, v19);
    ++v10;
  }
  while (v10 != 5);
  v21 = y + v14;
  v22 = x + v13;
  v82 = v101;
  v89 = v92;
  v23.n128_f64[0] = x + width * v101;
  v81 = y + height * v92;
  v23.n128_f64[1] = v81;
  CG::Path::move_to_point(this, a4, v9, v23);
  v74 = v100;
  v70 = v99;
  v24.f64[0] = x + width * v100;
  v86 = v93;
  v88 = v94;
  v73 = y + height * v93;
  v24.f64[1] = v73;
  v72 = y + height * v94;
  v91.x = x + width * v99;
  v91.y = v72;
  v65 = v98;
  v87 = v95;
  v64 = y + height * v95;
  v90.x = x + width * v98;
  v90.y = v64;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v25, v24);
  v84 = v96;
  v26.f64[0] = x + width * v97;
  v78 = v97;
  v63 = y + height * v96;
  v26.f64[1] = v63;
  v60 = v105;
  v61 = v106;
  v91.x = x + width * v106;
  v91.y = y + height * v97;
  v80 = v108;
  v59 = y + height * v108;
  v90.x = x + width * v105;
  v90.y = v59;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v27, v26);
  v28 = v103;
  v66 = v104;
  v79 = v109;
  v29.f64[0] = x + width * v104;
  v58 = y + height * v109;
  v29.f64[1] = v58;
  v30 = v102;
  v76 = v110;
  v77 = v111;
  v57 = y + height * v110;
  v91.x = x + width * v103;
  v91.y = v57;
  v85 = x + width * v102;
  v68 = y + height * v111;
  v90.x = v85;
  v90.y = v68;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v31, v29);
  v32.f64[0] = v22 - width * v30;
  v32.f64[1] = v68;
  CG::Path::add_line_to_point(this, a4, v33, v32);
  v34.f64[0] = v22 - width * v28;
  v69 = v34.f64[0];
  v34.f64[1] = v57;
  v67 = v22 - width * v66;
  v91.x = v67;
  v91.y = v58;
  v90.x = v22 - width * v60;
  v90.y = v59;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v35, v34);
  v62 = v22 - width * v61;
  v36.f64[0] = v62;
  v37 = v107;
  v36.f64[1] = y + height * v107;
  v91.x = v22 - width * v107;
  v91.y = v63;
  v90.x = v22 - width * v65;
  v90.y = v64;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v38, v36);
  v71 = v22 - width * v70;
  v39.f64[0] = v71;
  v39.f64[1] = v72;
  v75 = v22 - width * v74;
  v91.x = v75;
  v91.y = v73;
  v83 = v22 - width * v82;
  v90.x = v83;
  v90.y = v81;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v40, v39);
  v41.f64[0] = v83;
  v41.f64[1] = v21 - height * v89;
  CG::Path::add_line_to_point(this, a4, v42, v41);
  v43.f64[0] = v75;
  v43.f64[1] = v21 - height * v86;
  v91.x = v71;
  v91.y = v21 - height * v88;
  v90.x = v22 - width * v65;
  v90.y = v21 - height * v87;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v44, v43);
  v45.f64[0] = v22 - width * v78;
  v45.f64[1] = v21 - height * v84;
  v91.x = v62;
  v91.y = v21 - height * v78;
  v90.x = v22 - width * v60;
  v90.y = v21 - height * v80;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v46, v45);
  v47.f64[0] = v67;
  v47.f64[1] = v21 - height * v79;
  v91.x = v69;
  v91.y = v21 - height * v76;
  v90.x = v22 - width * v30;
  v90.y = v21 - height * v77;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v48, v47);
  v49.f64[0] = v85;
  v49.f64[1] = v21 - height * v77;
  CG::Path::add_line_to_point(this, a4, v50, v49);
  v51.f64[0] = x + width * v103;
  v51.f64[1] = v21 - height * v110;
  v91.x = x + width * v104;
  v91.y = v21 - height * v109;
  v90.x = x + width * v105;
  v90.y = v21 - height * v108;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v52, v51);
  v53.f64[0] = x + width * v106;
  v53.f64[1] = v21 - height * v37;
  v91.x = x + width * v37;
  v91.y = v21 - height * v96;
  v90.x = x + width * v98;
  v90.y = v21 - height * v95;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v54, v53);
  v55.f64[0] = x + width * v99;
  v55.f64[1] = v21 - height * v94;
  v91.x = x + width * v100;
  v91.y = v21 - height * v93;
  v90.x = x + width * v101;
  v90.y = v21 - height * v92;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v91, (float64x2_t *)&v90, a4, v56, v55);
  CG::Path::close_subpath(this);
}

void create_initialized_encoding_buffer(uint64_t a1, CFIndex a2, int a3)
{
  __CFData *Mutable;
  int v5;
  UInt8 v6[4];
  UInt8 bytes[4];

  *(_DWORD *)v6 = a3;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  *(_QWORD *)a1 = Mutable;
  if (*(_BYTE *)(a1 + 8))
    v5 = 65537;
  else
    v5 = 1;
  *(_DWORD *)bytes = v5;
  CFDataAppendBytes(Mutable, bytes, 4);
  CFDataAppendBytes(*(CFMutableDataRef *)a1, v6, 1);
}

void encode_CGAffineTransform(uint64_t a1, double *a2)
{
  encode_CGFloat(a1, *a2);
  encode_CGFloat(a1, a2[1]);
  encode_CGFloat(a1, a2[2]);
  encode_CGFloat(a1, a2[3]);
  encode_CGFloat(a1, a2[4]);
  encode_CGFloat(a1, a2[5]);
}

void encode_CGFloat(uint64_t a1, double a2)
{
  __CFData *v2;
  UInt8 *v3;
  CFIndex v4;
  float v5;
  float v6;
  UInt8 bytes[8];

  *(double *)bytes = a2;
  if (*(_BYTE *)(a1 + 8))
  {
    v5 = a2;
    v6 = v5;
    v2 = *(__CFData **)a1;
    v3 = (UInt8 *)&v6;
    v4 = 4;
  }
  else
  {
    v2 = *(__CFData **)a1;
    v3 = bytes;
    v4 = 8;
  }
  CFDataAppendBytes(v2, v3, v4);
}

uint64_t decode_CGAffineTransform(uint64_t a1, double *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  v4 = decode_CGFloat(a1, a2);
  v5 = v4 & decode_CGFloat(a1, a2 + 1);
  v6 = decode_CGFloat(a1, a2 + 2);
  v7 = v5 & v6 & decode_CGFloat(a1, a2 + 3);
  v8 = decode_CGFloat(a1, a2 + 4);
  return v7 & v8 & decode_CGFloat(a1, a2 + 5);
}

uint64_t decode_CGFloat(uint64_t a1, double *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t result;
  double v5;
  uint64_t v6;
  float v7;

  v2 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(a1 + 8))
  {
    v5 = 0.0;
    if ((v2 & 0x8000000000000000) != 0 || (v6 = *(_QWORD *)(a1 + 16), v6 + 4 > v2))
    {
      result = 0;
    }
    else
    {
      v7 = *(float *)(*(_QWORD *)a1 + v6);
      *(_QWORD *)(a1 + 16) = v6 + 4;
      v5 = v7;
      result = 1;
    }
    *a2 = v5;
  }
  else
  {
    if ((v2 & 0x8000000000000000) != 0)
      return 0;
    v3 = *(_QWORD *)(a1 + 16);
    if (v3 + 8 > v2)
    {
      return 0;
    }
    else
    {
      *a2 = *(double *)(*(_QWORD *)a1 + v3);
      *(_QWORD *)(a1 + 16) += 8;
      return 1;
    }
  }
  return result;
}

_QWORD *text_layout_reset(_QWORD *result)
{
  _QWORD **v1;
  _QWORD *v2;
  _QWORD *v3;

  v1 = (_QWORD **)result;
  v2 = (_QWORD *)*result;
  if (*result)
  {
    do
    {
      text_chunk_release((void **)v2[1]);
      v2 = (_QWORD *)*v2;
    }
    while (v2);
    result = *v1;
    if (*v1)
    {
      do
      {
        v3 = (_QWORD *)*result;
        free(result);
        result = v3;
      }
      while (v3);
    }
  }
  *v1 = 0;
  return result;
}

void text_chunk_release(void **a1)
{
  if (a1)
  {
    free(a1[14]);
    free(a1[15]);
    free(a1[16]);
    free(a1[17]);
    free(a1);
  }
}

void CGPDFTextLayoutAppendString(uint64_t *a1, uint64_t a2, uint64_t a3, double *a4)
{
  double *v7;
  double *v8;
  double v9;
  double v10;
  double v11;

  if (a1)
  {
    v7 = (double *)text_chunk_create(a1, a2);
    if (v7)
    {
      v8 = v7;
      if (*((_BYTE *)v7 + 17))
      {
        text_chunk_append_cids(v7, a2, a3);
        if (!a4)
          return;
      }
      else
      {
        text_chunk_append_simple((uint64_t)v7, a2, a3);
        if (!a4)
          return;
      }
      v9 = v8[6];
      if (*((_BYTE *)v8 + 16))
      {
        v10 = v9 * v8[7] * v8[3];
        v11 = 0.0;
      }
      else
      {
        v11 = v9 * v8[4];
        v10 = 0.0;
      }
      *a4 = v10;
      a4[1] = v11;
    }
  }
}

void *text_chunk_create(uint64_t *a1, uint64_t a2)
{
  void *v4;
  unint64_t v5;
  double v6;
  unint64_t CMap;
  unint64_t v8;
  unsigned int (*v9)(_QWORD);
  BOOL v10;
  double v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = malloc_type_calloc(1uLL, 0x90uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *(_QWORD *)v4 = 0;
  *((_QWORD *)v4 + 1) = 0;
  v5 = *(_QWORD *)(a2 + 48);
  *((_QWORD *)v4 + 5) = v5;
  v6 = *(double *)(a2 + 56);
  *((double *)v4 + 6) = v6;
  if (!v5 || v6 == 0.0)
  {
    text_chunk_release((void **)v4);
    return 0;
  }
  else
  {
    *((double *)v4 + 7) = *(double *)(a2 + 16) / 100.0;
    CMap = CGPDFFontGetCMap(v5);
    v8 = CMap;
    v10 = !CMap
       || !cmap_vtable
       || (v9 = *(unsigned int (**)(_QWORD))(cmap_vtable + 40)) == 0
       || v9(*(_QWORD *)(CMap + 16)) == 0;
    *((_BYTE *)v4 + 16) = v10;
    *((_BYTE *)v4 + 17) = v8 != 0;
    v11 = *((double *)v4 + 6);
    v12 = *(float64x2_t *)(a2 + 120);
    v13 = *(float64x2_t *)(a2 + 136);
    v14 = vaddq_f64(*(float64x2_t *)(a2 + 152), vmlaq_f64(vmulq_n_f64(v13, *(double *)(a2 + 32)), (float64x2_t)0, v12));
    *((float64x2_t *)v4 + 4) = vmlaq_n_f64(vmulq_f64(v13, (float64x2_t)0), v12, v11 * *((double *)v4 + 7));
    *((float64x2_t *)v4 + 5) = vmlaq_f64(vmulq_n_f64(v13, v11), (float64x2_t)0, v12);
    *((float64x2_t *)v4 + 6) = v14;
    *((_OWORD *)v4 + 7) = 0u;
    *((_OWORD *)v4 + 8) = 0u;
    v15 = *a1;
    v16 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
    *v16 = v15;
    v16[1] = v4;
    *a1 = (uint64_t)v16;
  }
  return v4;
}

void text_chunk_append_cids(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  size_t v6;
  uint64_t v7;
  __n128 v8;
  uint64_t v9;
  char *v10;
  unsigned __int16 *v11;
  unint64_t CMap;
  __n128 v13;
  _BYTE *v14;
  uint64_t CIDsForText;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double *v19;
  __int128 v20;
  unint64_t v21;
  unsigned int (*v22)(_QWORD);
  void ***v23;
  const CGAffineTransform *v24;
  double a;
  double v26;
  double v27;
  double v28;
  void ***Advances;
  uint64_t v30;
  float64x2_t *v31;
  double v32;
  _BYTE *v33;
  double v34;
  __int128 v35;
  unint64_t v36;
  unsigned int v37;
  double VerticalAdvance;
  float64x2_t v39;
  double v40;
  void ***v41;
  const CGAffineTransform *v42;
  double v43;
  double v44;
  double v45;
  double v46;
  void ***v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  _QWORD *v51;
  _BYTE *v52;
  double v53;
  uint64_t v54;
  __int128 v55;
  double v56;
  double v57;
  _QWORD *v58;
  uint64_t v59;
  char *v60;
  uint64_t *v61;
  _QWORD *v62;
  float64x2_t v63;
  __int128 v64;
  __int128 v65;
  float64x2_t v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (*(_QWORD *)(a3 + 24))
      decrypt_string(a3);
    v6 = *(_QWORD *)(a3 + 72);
  }
  else
  {
    v6 = 0;
  }
  v7 = text_chunk_require_size((uint64_t)a1, a1[1] + v6);
  if ((_DWORD)v7)
  {
    v61 = &v59;
    MEMORY[0x1E0C80A78](v7, v8);
    v60 = (char *)&v59 - v9;
    if (v6 == -1)
      v10 = 0;
    else
      v10 = (char *)&v59 - v9;
    if (v6 + 1 >= 0x66)
      v10 = (char *)malloc_type_malloc(v6, 0x1780CF22uLL);
    v11 = (unsigned __int16 *)(a1[15] + 2 * a1[1]);
    CMap = CGPDFFontGetCMap(a1[5]);
    if (a3)
    {
      if (*(_QWORD *)(a3 + 24))
        decrypt_string(a3);
      v14 = (_BYTE *)(a3 + 80);
    }
    else
    {
      v14 = 0;
    }
    CIDsForText = CGPDFCMapGetCIDsForText(CMap, v14, v6, (uint64_t)v11, (uint64_t)v10, v13);
    v16 = a1[1];
    v17 = a1[16];
    v18 = a1[17];
    v19 = (double *)(v18 + 8 * v16);
    *(_QWORD *)&v20 = a1[3];
    v65 = v20;
    *(_QWORD *)&v20 = a1[4];
    v64 = v20;
    v21 = CGPDFFontGetCMap(*(_QWORD *)(a2 + 48));
    v62 = a1;
    v59 = CIDsForText;
    if (v21
      && cmap_vtable
      && (v22 = *(unsigned int (**)(_QWORD))(cmap_vtable + 40)) != 0
      && v22(*(_QWORD *)(v21 + 16)))
    {
      v23 = *(void ****)(a2 + 48);
      v66 = 0uLL;
      v24 = (const CGAffineTransform *)(v23 + 7);
      if (!v23)
        v24 = &CGAffineTransformIdentity;
      a = v24->a;
      v26 = *(double *)(a2 + 56);
      v27 = *(double *)a2;
      v28 = *(double *)(a2 + 8);
      Advances = CGPDFFontGetAdvances(v23);
      if (CIDsForText)
      {
        v30 = (uint64_t)Advances;
        v31 = (float64x2_t *)(v17 + 16 * v16);
        v32 = v27 / v26;
        v63 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(-a), 0);
        v33 = v10;
        v34 = v28 / v26;
        v35 = v64;
        do
        {
          v64 = v35;
          v37 = *v11++;
          v36 = v37;
          if (v18)
            *v19 = a * CGPDFAdvancesGetHorizontalAdvance(v30, v36);
          VerticalAdvance = CGPDFAdvancesGetVerticalAdvance(v30, v36, (uint64_t)&v66);
          v35 = v64;
          if (v17)
          {
            *(_QWORD *)&v39.f64[0] = v65;
            *(_QWORD *)&v39.f64[1] = v64;
            *v31 = vmlaq_f64(v39, v66, v63);
          }
          *(double *)&v35 = *(double *)&v35 + v32 + a * VerticalAdvance;
          if (v10)
          {
            v40 = -0.0;
            if (*v33)
              v40 = v34;
            *(double *)&v35 = *(double *)&v35 + v40;
          }
          ++v33;
          ++v31;
          ++v19;
          --CIDsForText;
        }
        while (CIDsForText);
      }
      else
      {
        *(_QWORD *)&v35 = v64;
      }
      v58 = v62;
      v62[3] = v65;
      v58[4] = v35;
    }
    else
    {
      v41 = *(void ****)(a2 + 48);
      v42 = (const CGAffineTransform *)(v41 + 7);
      if (!v41)
        v42 = &CGAffineTransformIdentity;
      v43 = v42->a;
      v44 = *(double *)(a2 + 56);
      v45 = *(double *)a2;
      v46 = *(double *)(a2 + 8);
      v47 = CGPDFFontGetAdvances(v41);
      if (CIDsForText)
      {
        v48 = (uint64_t)v47;
        v49 = CIDsForText;
        v50 = v45 / v44;
        v51 = (_QWORD *)(v17 + 16 * v16 + 8);
        v52 = v10;
        v53 = v46 / v44;
        v54 = v64;
        v55 = v65;
        do
        {
          if (v17)
          {
            *(v51 - 1) = v55;
            *v51 = v54;
          }
          v65 = v55;
          v56 = v43 * CGPDFAdvancesGetHorizontalAdvance(v48, *v11);
          if (v18)
            *v19 = v56;
          *((_QWORD *)&v55 + 1) = *((_QWORD *)&v65 + 1);
          *(double *)&v55 = *(double *)&v65 + v50 + v56;
          if (v10)
          {
            v57 = -0.0;
            if (*v52)
              v57 = v53;
            *(double *)&v55 = *(double *)&v55 + v57;
          }
          v54 = v64;
          ++v52;
          ++v19;
          ++v11;
          v51 += 2;
          --v49;
        }
        while (v49);
      }
      else
      {
        v54 = v64;
        *(_QWORD *)&v55 = v65;
      }
      v58 = v62;
      v62[3] = v55;
      v58[4] = v54;
    }
    v58[1] += v59;
    if (v10 != v60)
      free(v10);
  }
}

void text_chunk_append_simple(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  void ***v13;
  const CGAffineTransform *v14;
  double a;
  double v16;
  double v17;
  double v18;
  void ***Advances;
  uint64_t v20;
  double *v21;
  double v22;
  double *v23;
  size_t v24;
  double v25;
  int v26;
  double v27;
  double v28;
  double v29;
  size_t v30;

  if (!a3)
  {
    if ((text_chunk_require_size(a1, *(_QWORD *)(a1 + 8)) & 1) != 0)
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_10;
    }
LABEL_22:
    abort();
  }
  if (*(_QWORD *)(a3 + 24))
    decrypt_string(a3);
  v6 = *(_QWORD *)(a3 + 72);
  if ((text_chunk_require_size(a1, *(_QWORD *)(a1 + 8) + v6) & 1) == 0)
    goto LABEL_22;
  if (*(_QWORD *)(a3 + 24))
    decrypt_string(a3);
  v7 = (unsigned __int8 *)(a3 + 80);
LABEL_10:
  memmove((void *)(*(_QWORD *)(a1 + 112) + *(_QWORD *)(a1 + 8)), v7, v6);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 128);
  v10 = *(_QWORD *)(a1 + 136);
  v12 = *(double *)(a1 + 24);
  v11 = *(_QWORD *)(a1 + 32);
  v13 = *(void ****)(a2 + 48);
  v14 = (const CGAffineTransform *)(v13 + 7);
  if (!v13)
    v14 = &CGAffineTransformIdentity;
  a = v14->a;
  v16 = *(double *)(a2 + 56);
  v17 = *(double *)a2;
  v18 = *(double *)(a2 + 8);
  Advances = CGPDFFontGetAdvances(v13);
  v30 = v6;
  if (v6)
  {
    v20 = (uint64_t)Advances;
    v21 = (double *)(v10 + 8 * v8);
    v22 = v17 / v16;
    v23 = (double *)(v9 + 16 * v8 + 8);
    v24 = v6;
    v25 = v18 / v16;
    do
    {
      if (v9)
      {
        *(v23 - 1) = v12;
        *(_QWORD *)v23 = v11;
      }
      v26 = *v7;
      v27 = a * CGPDFAdvancesGetHorizontalAdvance(v20, *v7);
      if (v10)
      {
        *v21 = v27;
        v26 = *v7;
      }
      v28 = v12 + v22 + v27;
      v29 = -0.0;
      if (v26 == 32)
        v29 = v25;
      v12 = v28 + v29;
      ++v21;
      ++v7;
      v23 += 2;
      --v24;
    }
    while (v24);
  }
  *(double *)(a1 + 24) = v12;
  *(_QWORD *)(a1 + 32) = v11;
  *(_QWORD *)(a1 + 8) += v30;
}

uint64_t text_chunk_require_size(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t result;

  if (*(_QWORD *)a1 >= a2)
    return 1;
  v3 = a2 + 20;
  result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 112), a2 + 20, 0x100004077774924uLL);
  if (result)
  {
    *(_QWORD *)(a1 + 112) = result;
    result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 120), 2 * v3, 0x1000040BDFB0063uLL);
    if (result)
    {
      *(_QWORD *)(a1 + 120) = result;
      result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 128), 16 * v3, 0x1000040451B5BE8uLL);
      if (result)
      {
        *(_QWORD *)(a1 + 128) = result;
        result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 136), 8 * v3, 0x100004000313F17uLL);
        if (result)
        {
          *(_QWORD *)(a1 + 136) = result;
          *(_QWORD *)a1 = v3;
          return 1;
        }
      }
    }
  }
  return result;
}

void CGPDFTextLayoutAppendStrings(uint64_t *a1, uint64_t a2, CGPDFArray *a3, double *a4)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t v15;
  CGPDFReal value;

  if (a1)
  {
    v7 = text_chunk_create(a1, a2);
    if (v7)
    {
      v8 = (uint64_t)v7;
      if (a3)
      {
        v9 = *((_QWORD *)a3 + 2);
        if (v9)
        {
          v10 = 0;
          v15 = 0;
          value = 0.0;
          do
          {
            if (CGPDFArrayGetString(a3, v10, (CGPDFStringRef *)&v15))
            {
              if (*(_BYTE *)(v8 + 17))
                text_chunk_append_cids((_QWORD *)v8, a2, v15);
              else
                text_chunk_append_simple(v8, a2, v15);
            }
            else if (CGPDFArrayGetNumber(a3, v10, &value))
            {
              v11 = value / 1000.0;
              if (*(_BYTE *)(v8 + 16))
                *(double *)(v8 + 24) = *(double *)(v8 + 24) - v11;
              else
                *(double *)(v8 + 32) = *(double *)(v8 + 32) - v11;
            }
            ++v10;
          }
          while (v9 != v10);
        }
      }
      if (a4)
      {
        v12 = *(double *)(v8 + 48);
        if (*(_BYTE *)(v8 + 16))
        {
          v13 = v12 * *(double *)(v8 + 56) * *(double *)(v8 + 24);
          v14 = 0.0;
        }
        else
        {
          v14 = v12 * *(double *)(v8 + 32);
          v13 = 0.0;
        }
        *a4 = v13;
        a4[1] = v14;
      }
    }
  }
}

_QWORD *CGPDFTextLayoutDrawGlyphs(_QWORD *result, void (*a2)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, char *, char *, _QWORD, uint64_t), uint64_t a3, __n128 a4)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;

  if (result && a2)
  {
    v5 = result;
    v6 = (_QWORD *)*result;
    if (*result)
    {
      v8 = 0;
      do
      {
        v9 = v6;
        v6 = (_QWORD *)*v6;
        *v9 = v8;
        v8 = v9;
      }
      while (v6);
      *result = v9;
      do
      {
        v10 = v9[1];
        if (*(_BYTE *)(v10 + 17))
          cid_draw(v10, a2, a3, a4);
        else
          simple_draw(v10, (void (*)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, char *, _QWORD, uint64_t, uint64_t))a2, a3, a4);
        v9 = (_QWORD *)*v9;
      }
      while (v9);
    }
    else
    {
      *result = 0;
    }
    return text_layout_reset(v5);
  }
  return result;
}

void cid_draw(uint64_t a1, void (*a2)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, char *, char *, _QWORD, uint64_t), uint64_t a3, __n128 a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  __int16 *CIDToGlyphMap;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  _QWORD *Font;
  int GlyphsForCIDs;
  __int128 *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1, a4);
  v10 = (char *)&v25 - v9;
  if (v8 <= 0x7FFFFFFFFFFFFFFELL)
    v11 = (char *)&v25 - v9;
  else
    v11 = 0;
  if (v8 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000066)
    v11 = (char *)malloc_type_malloc(2 * v7, 0x9D9DABE0uLL);
  CIDToGlyphMap = (__int16 *)CGPDFFontGetCIDToGlyphMap(*(_QWORD *)(a1 + 40));
  if (CIDToGlyphMap)
  {
    CGFontIndexMapGetValues(CIDToGlyphMap, *(unsigned __int16 **)(a1 + 120), *(_QWORD *)(a1 + 8), v11);
    v13 = *(_QWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 128);
    v15 = *(_QWORD *)(a1 + 136);
    v16 = *(char **)(a1 + 120);
    v17 = *(_QWORD *)(a1 + 8);
    v18 = *(_OWORD *)(a1 + 80);
    v25 = *(_OWORD *)(a1 + 64);
    v26 = v18;
    v19 = *(_OWORD *)(a1 + 96);
LABEL_10:
    v27 = v19;
    a2(a3, v13, &v25, v14, v15, v11, v16, 0, v17);
    goto LABEL_11;
  }
  Font = (_QWORD *)CGPDFFontGetFont(*(_QWORD *)(a1 + 40));
  GlyphsForCIDs = CGFontGetGlyphsForCIDs(Font, *(unsigned __int16 **)(a1 + 120), *(_QWORD *)(a1 + 8), v11);
  v13 = *(_QWORD *)(a1 + 40);
  v22 = (__int128 *)(a1 + 64);
  v14 = *(_QWORD *)(a1 + 128);
  v15 = *(_QWORD *)(a1 + 136);
  v16 = *(char **)(a1 + 120);
  v17 = *(_QWORD *)(a1 + 8);
  if (GlyphsForCIDs)
  {
    v23 = *(_OWORD *)(a1 + 80);
    v25 = *v22;
    v26 = v23;
    v19 = *(_OWORD *)(a1 + 96);
    goto LABEL_10;
  }
  v24 = *(_OWORD *)(a1 + 80);
  v25 = *v22;
  v26 = v24;
  v27 = *(_OWORD *)(a1 + 96);
  a2(a3, v13, &v25, v14, v15, v16, v16, 0, v17);
LABEL_11:
  if (v11 != v10)
    free(v11);
}

void simple_draw(uint64_t a1, void (*a2)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, char *, _QWORD, uint64_t, uint64_t), uint64_t a3, __n128 a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  unint64_t *Encoding;
  _OWORD *GlyphVector;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  _OWORD v22[3];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1, a4);
  v10 = (char *)v22 - v9;
  if (v8 <= 0x7FFFFFFFFFFFFFFELL)
    v11 = (char *)v22 - v9;
  else
    v11 = 0;
  if (v8 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000066)
    v11 = (char *)malloc_type_malloc(2 * v7, 0x307BE51uLL);
  Encoding = CGPDFFontGetEncoding(*(unint64_t **)(a1 + 40));
  GlyphVector = CGPDFEncodingGetGlyphVector((size_t)Encoding);
  v14 = *(_QWORD *)(a1 + 8);
  if (GlyphVector)
  {
    if (v14)
    {
      v15 = 0;
      v16 = *(_QWORD *)(a1 + 112);
      do
      {
        *(_WORD *)&v11[2 * v15] = *((_WORD *)GlyphVector + *(unsigned __int8 *)(v16 + v15));
        ++v15;
      }
      while (v14 != v15);
    }
  }
  else if (v14)
  {
    bzero(v11, 2 * v14);
  }
  v17 = *(_QWORD *)(a1 + 40);
  v18 = *(_QWORD *)(a1 + 128);
  v19 = *(_QWORD *)(a1 + 136);
  v20 = *(_QWORD *)(a1 + 112);
  v21 = *(_OWORD *)(a1 + 80);
  v22[0] = *(_OWORD *)(a1 + 64);
  v22[1] = v21;
  v22[2] = *(_OWORD *)(a1 + 96);
  a2(a3, v17, v22, v18, v19, v11, 0, v20, v14);
  if (v11 != v10)
    free(v11);
}

uint64_t blt_bitmap_copy_XXXX32(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  int v17;

  do
  {
    v11 = a7 + 4 * a10 * a8;
    v12 = result;
    v13 = a9;
    if (result > 1)
    {
      do
      {
        v14 = v12;
        v15 = *(_DWORD *)(v11 + 4 * v13);
        if (v13 + 1 < a5)
          v16 = v13 + 1;
        else
          v16 = 0;
        v17 = *(_DWORD *)(v11 + 4 * v16);
        *a3 = v15;
        a3[1] = v17;
        a3 += 2;
        if (v16 + 1 < a5)
          v13 = v16 + 1;
        else
          v13 = 0;
        v12 = v14 - 2;
      }
      while (v14 > 3);
    }
    if (v12 >= 1)
      *a3++ = *(_DWORD *)(v11 + 4 * v13);
    a3 += a4 - result;
    if (a10 + 1 < a6)
      ++a10;
    else
      a10 = 0;
  }
  while (a2-- > 1);
  return result;
}

uint64_t blt_bitmap_blend_XXXA32(uint64_t result, uint64_t a2, uint32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int32 v15;
  uint64_t v16;
  __int32 v17;
  int32x2_t v18;
  int8x8_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  BOOL v23;
  __int32 v24;
  int v25;

  v11 = a4 - result;
  do
  {
    v12 = a7 + 4 * a10 * a8;
    v13 = a9;
    v14 = result;
    if (result > 1)
    {
      do
      {
        v15 = *(_DWORD *)(v12 + 4 * v13);
        if (v13 + 1 < a5)
          v16 = v13 + 1;
        else
          v16 = 0;
        v17 = *(_DWORD *)(v12 + 4 * v16);
        if ((v17 & v15) == 0xFF)
        {
          a3->i32[0] = v15;
          a3->i32[1] = v17;
        }
        else if (v17 | v15)
        {
          v18.i16[0] = a3->u8[0];
          v18.i16[1] = BYTE2(a3->u32[0]);
          v18.i16[2] = BYTE4(*(unint64_t *)a3);
          v18.i16[3] = BYTE6(*(unint64_t *)a3);
          v19.i32[0] = v15;
          v19.i32[1] = *(_DWORD *)(v12 + 4 * v16);
          v20 = (int32x2_t)veor_s8(v19, (int8x8_t)0xFF000000FFLL);
          v21 = vmul_s32((int32x2_t)(*(_QWORD *)&vshr_n_u32(*a3, 8uLL) & 0xFFFF00FFFFFF00FFLL), v20);
          v22 = vmul_s32(v18, v20);
          *a3 = (uint32x2_t)vadd_s32((int32x2_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vadd_s32(vadd_s32(v22, (int32x2_t)0x1000100010001), (int32x2_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)v22, 8uLL) & 0xFFFF00FFFFFF00FFLL)), 8uLL) & 0xFFFF00FFFFFF00FFLL), vadd_s32((int32x2_t)__PAIR64__(v17, v15), (int32x2_t)(*(_QWORD *)&vadd_s32(vadd_s32(v21, (int32x2_t)0x1000100010001), (int32x2_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)v21, 8uLL) & 0xFFFF00FFFFFF00FFLL)) & 0xFF00FF00FF00FF00)));
        }
        ++a3;
        if (v16 + 1 < a5)
          v13 = v16 + 1;
        else
          v13 = 0;
        v23 = (unint64_t)v14 > 3;
        v14 -= 2;
      }
      while (v23);
    }
    if (v14 >= 1)
    {
      v24 = *(_DWORD *)(v12 + 4 * v13);
      if ((_BYTE)v24)
      {
        if (v24 != 255)
        {
          v25 = ~(_BYTE)v24;
          v24 += ((((a3->i32[0] & 0xFF00FF) * v25 + 65537 + ((((a3->i32[0] & 0xFF00FFu) * v25) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
               + (((((unsigned __int32)a3->i32[0] >> 8) & 0xFF00FF) * v25
                 + 65537
                 + ((((((unsigned __int32)a3->i32[0] >> 8) & 0xFF00FF) * v25) >> 8) & 0xFF00FF)) & 0xFF00FF00);
        }
        a3->i32[0] = v24;
      }
      a3 = (uint32x2_t *)((char *)a3 + 4);
    }
    a3 = (uint32x2_t *)((char *)a3 + 4 * v11);
    if (a10 + 1 < a6)
      ++a10;
    else
      a10 = 0;
    v23 = a2-- <= 1;
  }
  while (!v23);
  return result;
}

uint64_t CGGetHardwareVectorCapabilities()
{
  return 3;
}

uint64_t CGContextGetVectorCapabilities(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 112);
  if (v1)
    return *(unsigned int *)(v1 + 4);
  else
    return 3;
}

uint64_t CGContextSetVectorCapabilities(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v2 = (a2 | ~(-1 << -(char)__clz(a2))) & 3;
  if (a2 < 2)
    v2 = a2;
  if (*(_DWORD *)(result + 24) == 4)
  {
    v3 = *(_QWORD *)(result + 32);
    if (v3)
      *(_DWORD *)(v3 + 96) = v2;
  }
  v4 = *(_QWORD *)(result + 112);
  if (v4)
  {
    v5 = v2 | ~(-1 << -(char)__clz(v2));
    if (v2 >= 2)
      LOBYTE(v2) = v5;
    *(_DWORD *)(v4 + 4) = v2 & 3;
  }
  return result;
}

uint64_t CG::Cubic::is_near(CG::Cubic *this, const Point *a2, double a3, double a4, double a5, double a6)
{
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  uint64_t result;
  unsigned __int8 v23;
  double *v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  BOOL v42;
  int v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;

  v6 = a6 * a6;
  v7 = *((double *)this + 8);
  v8 = *((double *)this + 9);
  v9 = *((double *)this + 10);
  v10 = *((double *)this + 11);
  v11 = *((double *)this + 12);
  v12 = *((double *)this + 13);
  v13 = *(double *)this - a3;
  v14 = *((double *)this + 1) - a4;
  v15 = v13 + (v7 + (v9 + v11 * 0.0) * 0.0) * 0.0;
  v16 = (v14 + (v8 + (v10 + v12 * 0.0) * 0.0) * 0.0) * (v14 + (v8 + (v10 + v12 * 0.0) * 0.0) * 0.0) + v15 * v15;
  if (v16 < v6)
    return 1;
  v17 = (v14 + v8 + v10 + v12) * (v14 + v8 + v10 + v12) + (v13 + v7 + v9 + v11) * (v13 + v7 + v9 + v11);
  if (v17 < v6)
    return 1;
  v18 = v13 + (v7 + (v9 + v11 * a5) * a5) * a5;
  v19 = v14 + (v8 + (v10 + v12 * a5) * a5) * a5;
  v20 = v19 * v19 + v18 * v18;
  if (v20 < v6)
    return 1;
  if (v20 >= v16 || v20 >= v17)
    return 0;
  v24 = (double *)&unk_1ECDA6000;
  if ((v23 & 1) == 0)
  {
    v47 = a5;
    v48 = *((double *)this + 8);
    v44 = v6;
    v45 = *((double *)this + 9);
    v49 = *((double *)this + 10);
    v46 = *((double *)this + 11);
    v50 = *((double *)this + 12);
    v51 = *((double *)this + 13);
    v52 = v13;
    v53 = v14;
    v54 = v20;
    v24 = (double *)&unk_1ECDA6000;
    v14 = v53;
    v20 = v54;
    v12 = v51;
    v13 = v52;
    v11 = v50;
    v8 = v45;
    v10 = v46;
    v7 = v48;
    v9 = v49;
    v6 = v44;
    a5 = v47;
    if (v43)
    {
      CG::Cubic::is_near(CG::Point const&,double,double)const::G = 0x3FE3C6EF372FE950;
      v24 = (double *)&unk_1ECDA6000;
      v14 = v53;
      v20 = v54;
      v12 = v51;
      v13 = v52;
      v11 = v50;
      v8 = v45;
      v10 = v46;
      v7 = v48;
      v9 = v49;
      v6 = v44;
      a5 = v47;
    }
  }
  v25 = v24[232];
  v26 = 1.0 - v25;
  if (a5 <= 0.5)
  {
    v27 = a5;
    a5 = a5 + v26 * (1.0 - a5);
    v31 = v13 + a5 * (v7 + a5 * (v9 + v11 * a5));
    v32 = v14 + a5 * (v8 + a5 * (v10 + v12 * a5));
    v33 = v32 * v32;
    v30 = v20;
    v20 = v33 + v31 * v31;
    if (v20 >= v6)
      goto LABEL_16;
    return 1;
  }
  v27 = a5 - v26 * a5;
  v28 = v13 + v27 * (v7 + v27 * (v9 + v11 * v27));
  v29 = v14 + v27 * (v8 + v27 * (v10 + v12 * v27));
  v30 = v29 * v29 + v28 * v28;
  if (v30 < v6)
    return 1;
LABEL_16:
  v34 = 1.0;
  if ((v27 + a5) * 0.00000003 >= 1.0)
    return 0;
  v35 = 0.0;
  result = 0;
  do
  {
    if (v20 >= v30)
    {
      v34 = a5;
      a5 = v35 * v26 + v25 * v27;
      v38 = v13 + a5 * (v7 + a5 * (v9 + v11 * a5));
      v39 = v14 + a5 * (v8 + a5 * (v10 + v12 * a5));
      v20 = v39 * v39 + v38 * v38;
      if (v20 <= v6)
        return 1;
    }
    else
    {
      v35 = v27;
      v27 = v34 * v26 + v25 * a5;
      v36 = v13 + v27 * (v7 + v27 * (v9 + v11 * v27));
      v37 = v14 + v27 * (v8 + v27 * (v10 + v12 * v27));
      v30 = v37 * v37 + v36 * v36;
      if (v30 <= v6)
        return 1;
    }
    v40 = v20;
    v41 = a5;
    v42 = v34 - v35 <= (a5 + v27) * 0.00000003;
    v20 = v30;
    v30 = v40;
    a5 = v27;
    v27 = v41;
  }
  while (!v42);
  return result;
}

uint64_t is_smaller_stop(double *a1, double *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

BOOL gradient_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t gradient_hash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

_QWORD *gradient_evaluate_premul(_QWORD *result, double *a2, double *a3)
{
  unint64_t v3;
  unint64_t v4;
  double v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  double v10;
  double v11;
  uint64_t v12;
  double *v13;
  uint64_t v14;
  double v15;
  double v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;
  double *v22;
  double *v23;
  double v24;
  double v25;
  double v26;

  v3 = result[2];
  v4 = v3 - 2;
  if (v3 >= 2)
  {
    v5 = *a2;
    v6 = result[1];
    v7 = result[3];
    v8 = v6 + 1;
    v9 = (double *)(v7 + 8 * (v6 + 1));
    v10 = *v9;
    v11 = 0.0;
    v12 = 0;
    if (*a2 <= *v9)
    {
      v15 = 0.0;
LABEL_9:
      v16 = (v5 - v15) / (v10 - v15);
      v17 = v7 + 8 * v12 * v8;
      v18 = *(double *)(v17 + 8 * v6);
      v19 = v9[v6];
      v20 = v16 * v19 + (1.0 - v16) * v18;
      if (v20 != 0.0)
        v11 = 1.0 / v20;
      v21 = v6 - 1;
      if (v21)
      {
        v22 = (double *)(v17 + 8);
        v23 = v9 + 1;
        do
        {
          v24 = *v22++;
          v25 = (1.0 - v16) * v24;
          v26 = *v23++;
          *a3++ = v11 * (v19 * (v16 * v26) + v25 * v18);
          --v21;
        }
        while (v21);
      }
      *a3 = v20;
    }
    else
    {
      v13 = (double *)(v7 + 16 * v6 + 16);
      v14 = v6 + 1;
      while (v4 != v12)
      {
        v15 = v10;
        v10 = *v13;
        ++v12;
        v14 += v8;
        v13 += v6 + 1;
        if (v5 <= v10)
        {
          v9 = (double *)(v7 + 8 * v14);
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

double *CGGradientPrint(uint64_t a1, FILE *a2)
{
  uint64_t v4;
  uint64_t v5;
  double *result;
  double *v7;
  unint64_t v8;
  double v9;
  uint64_t v10;
  double v11;

  fprintf(a2, "gradient %u\n", *(_DWORD *)(a1 + 16));
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
    v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 40);
  else
    v5 = 0;
  result = (double *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  if (*(_QWORD *)(a1 + 48))
  {
    v7 = result;
    v8 = 0;
    do
    {
      v9 = *v7++;
      fprintf(a2, "%zu: %g -> (", v8, v9);
      if (v5 != -1)
      {
        v10 = v5 + 1;
        do
        {
          v11 = *v7++;
          fprintf(a2, " %g", v11);
          --v10;
        }
        while (v10);
      }
      result = (double *)fwrite(")\n", 2uLL, 1uLL, a2);
      ++v8;
    }
    while (v8 < *(_QWORD *)(a1 + 48));
  }
  return result;
}

uint64_t CGGradientGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t error(int a1, const char *a2, ...)
{
  FILE **v3;
  FILE *v4;
  va_list va;

  va_start(va, a2);
  v3 = (FILE **)MEMORY[0x1E0C80C10];
  v4 = (FILE *)*MEMORY[0x1E0C80C10];
  if (a1 < 0)
    fwrite("Error: ", 7uLL, 1uLL, v4);
  else
    fprintf(v4, "Error (%d): ", a1);
  vfprintf(*v3, a2, va);
  fputc(10, *v3);
  return fflush(*v3);
}

uint64_t assembleClusterGaps(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v6;
  double v7;
  double v8;
  BOOL v9;
  double v10;
  double v11;
  double v12;
  double v13;
  uint64_t v14;
  double v15;
  unsigned int v16;
  double v17;
  double v18;
  void *v21;
  uint64_t v22;
  void *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  BOOL v37;
  double *v38;
  _OWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  double *v45;
  uint64_t v46;
  double v47;
  uint64_t v48;
  int v49;

  v6 = *(double *)(a3 + 96) - *(double *)(a2 + 96);
  v7 = *(double *)(a2 + 144);
  v8 = *(double *)(a3 + 144);
  v9 = v8 < 0.0;
  v10 = v6 + v8;
  if (v8 > 0.0)
    v11 = v6 + v8;
  else
    v11 = *(double *)(a3 + 96) - *(double *)(a2 + 96);
  if (v8 <= 0.0)
    v8 = -v8;
  if (v9)
    v6 = v10;
  if (v7 >= 0.0)
    v12 = v6;
  else
    v12 = v11;
  if (v7 >= 0.0)
    v13 = *(double *)(a2 + 144);
  else
    v13 = v8;
  v14 = *(_QWORD *)(a2 + 160);
  v15 = *(double *)(v14 + 72);
  if (v15 == 0.0)
  {
    v16 = -1;
    v17 = 0.0;
    v18 = 0.0;
  }
  else
  {
    v21 = *(void **)(v14 + 64);
    v22 = *(_QWORD *)(a3 + 160);
    v23 = *(void **)(v22 + 64);
    v24 = *(double *)(v22 + 72);
    v25 = 0.0;
    if (v15 == v24 && objc_msgSend(v21, "isSameFontAs:", *(_QWORD *)(v22 + 64), v6))
    {
      objc_msgSend(v21, "kernBetweenUnicode:andUnicode:", *(unsigned __int16 *)(a2 + 72), *(unsigned __int16 *)(a3 + 72));
      v25 = v26;
    }
    objc_msgSend(v21, "kernBetweenUnicode:andUnicode:", *(unsigned __int16 *)(a2 + 72), 32);
    v28 = v27;
    objc_msgSend(v23, "kernBetweenUnicode:andUnicode:", 32, *(unsigned __int16 *)(a3 + 72));
    v30 = v24 / v15 * v29;
    objc_msgSend(v21, "spaceWidth");
    v32 = v31;
    objc_msgSend(v23, "spaceWidth");
    v34 = (v32 + v33) * 0.5;
    v35 = 0.277832031 / v34;
    if (v34 <= 0.0)
      v35 = 1.0;
    v17 = (v28 + v30) * v35 + 0.277832031;
    v16 = *(_DWORD *)(a3 + 176);
    if (v12 > v13 * 0.5
      || !*(_WORD *)(a2 + 72)
      || *(unsigned __int16 *)(a2 + 72) != *(unsigned __int16 *)(a3 + 72)
      || ((v36 = v13 + v25 * v15, v18 = 0.0, v36 > 0.0) ? (v37 = v12 > v36 * 0.5) : (v37 = 1), v37))
    {
      v18 = (v12 / v15 - (v13 / v15 + (v25 + v28 + v30) * 0.5)) * v35;
    }
  }
  v38 = (double *)(a4 + 16);
  *(double *)(*(_QWORD *)a4 + 8 * a1) = v18;
  if (!a1)
  {
    *(double *)(a4 + 16) = v17;
    *(double *)(a4 + 24) = v17;
    v39 = *(_OWORD **)(a4 + 8);
    *v39 = 0u;
    v39[1] = 0u;
    v40 = *(_QWORD *)(a4 + 8);
    *(_OWORD *)(v40 + 32) = 0u;
    *(_OWORD *)(v40 + 48) = 0u;
    if ((v16 & 0x80000000) != 0)
      return 1;
    goto LABEL_38;
  }
  if (*v38 > v17 || (v38 = (double *)(a4 + 24), *(double *)(a4 + 24) < v17))
    *v38 = v17;
  if ((v16 & 0x80000000) == 0)
  {
LABEL_38:
    if (v16 <= 2)
    {
      v41 = *(_QWORD *)(a4 + 8);
      v42 = v16;
      v43 = v41 + 32 * v16;
      v45 = (double *)(v43 + 8);
      v44 = *(_DWORD *)v43;
      if (*(_DWORD *)v43)
      {
        if (*v45 > v18 || (v46 = v41 + 32 * v42, v47 = *(double *)(v46 + 16), v45 = (double *)(v46 + 16), v47 < v18))
          *v45 = v18;
        v48 = v41 + 32 * v42;
        v49 = v44 + 1;
        *(double *)(v48 + 24) = (v18 + *(double *)(v48 + 24) * (double)v44) / (double)(v44 + 1);
      }
      else
      {
        *(int64x2_t *)v45 = vdupq_lane_s64(*(uint64_t *)&v18, 0);
        *(double *)(v43 + 24) = v18;
        v49 = 1;
      }
      *(_DWORD *)v43 = v49;
    }
  }
  return 1;
}

BOOL isCharacterOverlay(uint64_t a1, uint64_t a2)
{
  double v4;
  double v5;
  double v6;
  _BOOL8 result;
  uint64_t v8;
  double v9;
  uint64_t v10;
  double v11;
  void *v12;
  double v13;
  double v14;

  v4 = *(double *)(a2 + 96) - *(double *)(a1 + 96);
  v5 = *(double *)(a1 + 144);
  v6 = *(double *)(a2 + 144);
  if (v5 >= 0.0)
  {
    if (v6 < 0.0)
      v4 = v4 + v6;
  }
  else if (v6 <= 0.0)
  {
    v5 = -v6;
  }
  else
  {
    v4 = v4 + v6;
    v5 = *(double *)(a2 + 144);
  }
  result = 0;
  if (v4 <= v5 * 0.5 && *(_WORD *)(a1 + 72) && *(unsigned __int16 *)(a1 + 72) == *(unsigned __int16 *)(a2 + 72))
  {
    v8 = *(_QWORD *)(a1 + 160);
    v9 = *(double *)(v8 + 72);
    v10 = *(_QWORD *)(a2 + 160);
    v11 = 0.0;
    if (v9 == *(double *)(v10 + 72))
    {
      v12 = *(void **)(v8 + 64);
      if (objc_msgSend(v12, "isSameFontAs:", *(_QWORD *)(v10 + 64)))
      {
        objc_msgSend(v12, "kernBetweenUnicode:andUnicode:", *(unsigned __int16 *)(a1 + 72), *(unsigned __int16 *)(a2 + 72));
        v11 = v13;
      }
    }
    v14 = v5 + v11 * v9;
    return v4 <= v14 * 0.5 && v14 > 0.0;
  }
  return result;
}

void PBPageLayoutPkg::PBColor::~PBColor(void ***this)
{
  *this = (void **)&off_1E1628EB0;
  std::unique_ptr<PB::Data>::reset[abi:se180100](this + 1, 0);
  PB::Base::~Base((PB::Base *)this);
}

{
  *this = (void **)&off_1E1628EB0;
  std::unique_ptr<PB::Data>::reset[abi:se180100](this + 1, 0);
  PB::Base::~Base((PB::Base *)this);
  JUMPOUT(0x186DC23C4);
}

uint64_t PBPageLayoutPkg::PBColor::readFrom(PBPageLayoutPkg::PBColor *this, PB::Reader *a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  void ***v7;
  uint64_t v8;
  char v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t result;
  void **v21;

  v2 = *((_QWORD *)a2 + 1);
  v3 = *((_QWORD *)a2 + 2);
  v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    v7 = (void ***)((char *)this + 8);
    while (1)
    {
      v8 = *(_QWORD *)a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        break;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v12 = v2 + 1;
        *((_QWORD *)a2 + 1) = v2 + 1;
        v13 = *(_BYTE *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0)
          break;
        v9 += 7;
        v2 = v12;
        v14 = v10++ > 8;
        if (v14)
          goto LABEL_24;
      }
LABEL_21:
      if ((v11 & 7) == 4)
      {
        v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 1)
      {
        v19 = operator new();
        *(_QWORD *)v19 = 0;
        *(_QWORD *)(v19 + 8) = 0;
        v21 = 0;
        std::unique_ptr<PB::Data>::reset[abi:se180100](v7, (void **)v19);
        std::unique_ptr<PB::Data>::reset[abi:se180100](&v21, 0);
        PB::Reader::read(a2, (PB::Data *)*v7);
      }
      else
      {
LABEL_24:
        result = PB::Reader::skip(a2);
        if (!(_DWORD)result)
          return result;
      }
      v2 = *((_QWORD *)a2 + 1);
      v3 = *((_QWORD *)a2 + 2);
      v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((_BYTE *)a2 + 24))
        return v4 == 0;
    }
    v15 = 0;
    v16 = 0;
    v11 = 0;
    if (v2 > v3)
      v3 = v2;
    while (v3 != v2)
    {
      v17 = v2 + 1;
      v18 = *(_BYTE *)(v8 + v2);
      *((_QWORD *)a2 + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0)
        goto LABEL_21;
      v15 += 7;
      v2 = v17;
      v14 = v16++ > 8;
      if (v14)
        goto LABEL_24;
    }
    v4 = 1;
    *((_BYTE *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t PBPageLayoutPkg::PBColor::writeTo(uint64_t this, PB::Writer *a2)
{
  const PB::Data *v2;

  v2 = *(const PB::Data **)(this + 8);
  if (v2)
    return PB::Writer::write(a2, v2);
  return this;
}

uint64_t PBPageLayoutPkg::PBColor::formatText(PBPageLayoutPkg::PBColor *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  if (*((_QWORD *)this + 1))
    PB::TextFormatter::format();
  return PB::TextFormatter::endObject(a2);
}

uint64_t create_rgb_bitmap(double *a1, int a2, int a3)
{
  __n128 v6;
  uint64_t v7;
  int v8;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  char *v13;
  _WORD *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  char *v28;
  _WORD *v29;
  uint64_t i;
  int v31;
  int v32;
  int v33;
  int v34;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  size_t v45;
  unint64_t v46;
  _DWORD *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  _WORD *v52;
  _BYTE v53[12];
  int v54;
  char *v55;
  _BYTE *v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  _QWORD v65[2];

  v65[1] = *MEMORY[0x1E0C80C00];
  v62 = 0;
  v63 = 0;
  CGSScanconverterGetBoundingBox(a1, (_DWORD *)&v63 + 1, &v63, (_DWORD *)&v62 + 1, &v62);
  v8 = v62;
  v7 = HIDWORD(v62);
  if ((HIDWORD(v62) - 1) > 0x3FFFFFFB || (int)v62 < 1)
    return 0;
  v10 = (2 * HIDWORD(v62) + 3) & 0x3FFFFFFFCLL;
  if (0x7FFFFFFF / v10 <= v62)
    return 0;
  v56 = v53;
  v11 = MEMORY[0x1E0C80A78](v10 * v62, v6);
  v13 = &v53[-v12];
  v55 = &v53[-v12];
  if (v11 >= 0x259)
    v13 = (char *)malloc_type_malloc(v11, 0x76A840EFuLL);
  v54 = a3;
  v60 = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v64 = 0;
  v65[0] = 0;
  v14 = delta_create((uint64_t)a1, (_DWORD *)v65 + 1, v65, &v64);
  v57 = v13;
  if (v14)
  {
    v15 = v64;
    v17 = v65[0];
    v16 = HIDWORD(v65[0]);
    if (CGSScanConvolveAndIntegrateRGB_onceToken != -1)
    {
      v52 = v14;
      dispatch_once(&CGSScanConvolveAndIntegrateRGB_onceToken, &__block_literal_global_2679);
      v14 = v52;
    }
    if ((int)v16 >= 1)
    {
      v18 = 0;
      v19 = &v57[(v17 - 1) * (int)v10];
      v20 = CGSScanConvolveAndIntegrateRGB_redKernel;
      v21 = CGSScanConvolveAndIntegrateRGB_greenKernel;
      v22 = CGSScanConvolveAndIntegrateRGB_blueKernel;
      v23 = v15;
      do
      {
        if (v17 >= 1)
        {
          v24 = 0;
          v25 = 0;
          v26 = 0;
          v27 = 0;
          v28 = &v19[2 * v18];
          v29 = &v14[(4 * v18)];
          do
          {
            for (i = 0; i != 19; ++i)
            {
              v31 = (__int16)v29[i];
              v27 += v31 * *(__int16 *)(v20 + i * 2);
              v26 += *(__int16 *)(v21 + i * 2) * v31;
              v25 += *(__int16 *)(v22 + i * 2) * v31;
            }
            v32 = (v27 + 7168) >> 14;
            v33 = (v26 + 7168) >> 14;
            v34 = (v25 + 7168) >> 14;
            if (v27 < -1154048 || v26 < -1154048 || v25 < -1154048)
            {
              v32 = -v32;
              v33 = -v33;
              v34 = -v34;
            }
            if (v32 >= 255)
              v32 = 255;
            v38 = v32 & ~(v32 >> 31);
            if (v33 >= 255)
              v33 = 255;
            v39 = v33 & ~(v33 >> 31);
            if (v34 >= 255)
              v34 = 255;
            *(_WORD *)v28 = (4 * v39) & 0x3E0 | ((v34 & ~(v34 >> 31)) >> 3) | ((_WORD)v38 << 7) & 0x7C00;
            v29 = (_WORD *)((char *)v29 + v23);
            v28 -= (int)v10;
            ++v24;
          }
          while (v24 != v17);
        }
        ++v18;
      }
      while (v18 != v16);
    }
    free(v14);
    v13 = v57;
  }
  CGGlyphGetTrimRegion((uint64_t)v13, (int)v7, v8, (2 * v7 + 3) & 0x3FFFFFFFCLL, &v61, &v60, &v59, &v58);
  v40 = v59;
  v41 = (int)v7 - (v59 + v58);
  v42 = v61;
  v43 = v61 + v60;
  v44 = v8 - (v61 + v60);
  v45 = 2 * v41;
  v46 = (2 * v41 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v47 = CGGlyphBitmapCreate(a2, v54, HIDWORD(v63) + (int)v59, v8 - (int)v61 + (int)v63, v41, v44, v46, 0);
  v48 = (uint64_t)v47;
  if (v47)
  {
    if (v8 != v43)
    {
      v49 = &v57[2 * v40 + v42 * v10];
      v50 = (char *)(v47 + 10);
      do
      {
        memcpy(v50, v49, v45);
        v49 += v10;
        v50 += v46;
        --v44;
      }
      while (v44);
    }
    if (default_glyph_bitmap_debugging)
      CGGlyphBitmapWriteToFile(v48);
  }
  if (v57 != v55)
    free(v57);
  return v48;
}

uint64_t create_gray_bitmap(double *a1, int a2, int a3)
{
  __n128 v6;
  uint64_t v7;
  int v8;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  char *v13;
  _WORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  char *v21;
  _WORD *v22;
  uint64_t i;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  size_t v30;
  unint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v39;
  uint64_t v40;
  int v41;
  char *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  _QWORD v51[2];

  v51[1] = *MEMORY[0x1E0C80C00];
  v48 = 0;
  v49 = 0;
  CGSScanconverterGetBoundingBox(a1, (_DWORD *)&v49 + 1, &v49, (_DWORD *)&v48 + 1, &v48);
  v8 = v48;
  v7 = HIDWORD(v48);
  if ((HIDWORD(v48) - 1) > 0x3FFFFFFB || (int)v48 < 1)
    return 0;
  v10 = (2 * HIDWORD(v48) + 3) & 0x3FFFFFFFCLL;
  if (0x7FFFFFFF / v10 <= v48)
    return 0;
  v43 = &v39;
  v11 = MEMORY[0x1E0C80A78](v10 * v48, v6);
  v13 = (char *)&v39 - v12;
  v42 = (char *)&v39 - v12;
  if (v11 >= 0x259)
    v13 = (char *)malloc_type_malloc(v11, 0x4008D2F1uLL);
  v41 = a3;
  v46 = 0;
  v47 = 0;
  v44 = 0;
  v45 = 0;
  v50 = 0;
  v51[0] = 0;
  v14 = delta_create((uint64_t)a1, (_DWORD *)v51 + 1, v51, &v50);
  if (v14)
  {
    v15 = HIDWORD(v51[0]);
    if (SHIDWORD(v51[0]) >= 1)
    {
      v16 = 0;
      v17 = v51[0];
      v18 = (int)v50;
      do
      {
        if (v17 >= 1)
        {
          v19 = 0;
          v20 = 0;
          v21 = &v13[2 * v16 + (v17 - 1) * (int)v10];
          v22 = &v14[(4 * v16)];
          do
          {
            for (i = 0; i != 19; ++i)
              v20 += (__int16)v22[i] * mKernel[i];
            v24 = (v20 + 7168) >> 14;
            if (v20 < -1154048)
              v24 = -v24;
            if (v24 >= 255)
              v24 = 255;
            *(_WORD *)v21 = (4 * (v24 & ~(unsigned __int16)(v24 >> 31) & 0xF8)) & 0x83E0 | ((((v24 & ~(v24 >> 31) & 0xF8u) >> 3) & 0x1F) << 10) | ((v24 & ~(v24 >> 31)) >> 3);
            v22 = (_WORD *)((char *)v22 + v18);
            v21 -= (int)v10;
            ++v19;
          }
          while (v19 != v17);
        }
        ++v16;
      }
      while (v16 != v15);
    }
    free(v14);
  }
  CGGlyphGetTrimRegion((uint64_t)v13, (int)v7, v8, (2 * v7 + 3) & 0x3FFFFFFFCLL, &v47, &v46, &v45, &v44);
  v25 = v45;
  v26 = (int)v7 - (v45 + v44);
  v27 = v47;
  v28 = v47 + v46;
  v29 = v8 - (v47 + v46);
  v30 = 2 * v26;
  v40 = v8;
  v31 = (2 * v26 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v32 = CGGlyphBitmapCreate(a2, v41, HIDWORD(v49) + (int)v45, v8 - (int)v47 + (int)v49, v26, v29, v31, 0);
  v33 = (uint64_t)v32;
  if (!v32)
  {
    v37 = v13;
    if (v13 == v42)
      return v33;
    goto LABEL_29;
  }
  v34 = v13;
  if (v40 != v28)
  {
    v35 = &v13[2 * v25 + v27 * v10];
    v36 = (char *)(v32 + 10);
    do
    {
      memcpy(v36, v35, v30);
      v35 += v10;
      v36 += v31;
      --v29;
    }
    while (v29);
  }
  if (default_glyph_bitmap_debugging)
    CGGlyphBitmapWriteToFile(v33);
  v37 = v34;
  if (v34 != v42)
LABEL_29:
    free(v37);
  return v33;
}

int64x2_t scan_converter_begin(uint64_t a1)
{
  int64x2_t result;

  *(_QWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(int64x2_t *)(a1 + 40) = vdupq_n_s64(0x47EFFFFFE0000000uLL);
  result = vdupq_n_s64(0xC7EFFFFFE0000000);
  *(int64x2_t *)(a1 + 56) = result;
  return result;
}

char *scan_converter_iterate(char *result, int a2, uint64_t a3, double a4, double a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9)
{
  char *v9;
  float64x2_t v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  __n128 v54;
  __n128 v55;
  double v56;
  __n128 v57;
  double v58;
  __n128 v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;

  v9 = result;
  switch(a2)
  {
    case 0:
      v10 = *(float64x2_t *)a3;
      *(_OWORD *)(result + 24) = *(_OWORD *)a3;
      *(_OWORD *)(result + 8) = *(_OWORD *)(result + 24);
      *(float64x2_t *)(result + 40) = vminnmq_f64(*(float64x2_t *)(result + 40), v10);
      *(float64x2_t *)(result + 56) = vmaxnmq_f64(*(float64x2_t *)(result + 56), v10);
      return result;
    case 1:
      v17 = *(double *)a3;
      v18 = *(double *)(a3 + 8);
      return CGSScanconverterAddLineToPoint(result, v17, v18);
    case 3:
      a6.n128_u64[0] = *(_QWORD *)a3;
      a7.n128_u64[0] = *(_QWORD *)(a3 + 8);
      a8.n128_u64[0] = *(_QWORD *)(a3 + 16);
      a9.n128_u64[0] = *(_QWORD *)(a3 + 24);
      v12 = *(double *)(a3 + 32);
      v11 = *(double *)(a3 + 40);
      v13 = *((double *)result + 1);
      if (vabdd_f64(*(double *)a3, a8.n128_f64[0]) + vabdd_f64(a7.n128_f64[0], a9.n128_f64[0]) >= 0.0001)
      {
        v14 = *((double *)result + 2);
LABEL_12:
        v19 = a6.n128_f64[0] * (a6.n128_f64[0] - a8.n128_f64[0])
            + a8.n128_f64[0] * (a8.n128_f64[0] - v13)
            + v12 * (v13 - a6.n128_f64[0]);
        if (v19 >= 0.0)
        {
          v20 = v12 - v13 + (a6.n128_f64[0] - a8.n128_f64[0]) * 3.0;
          v21 = a8.n128_f64[0] + v13 + a6.n128_f64[0] * -2.0;
          if (v20 == 0.0)
          {
            if (v21 == 0.0)
            {
              v23 = 0.0;
              v22 = 0.0;
            }
            else
            {
              v22 = (v14 - a7.n128_f64[0]) * 0.5 / v21;
              v23 = 2.0;
            }
          }
          else if (v21 != 0.0 || (v23 = 0.0, v22 = 0.0, v19 != 0.0))
          {
            v24 = 1.0;
            if (v21 < 0.0)
              v24 = -1.0;
            v25 = -(v21 + v24 * sqrt(v19));
            v26 = v25 / v20;
            v27 = (a7.n128_f64[0] - v14) / v25;
            if (v26 >= v27)
              v22 = v27;
            else
              v22 = v26;
            if (v26 <= v27)
              v23 = v27;
            else
              v23 = v26;
          }
          v28 = 2.0;
          if (v22 < 1.0e-10)
            v22 = v23;
          else
            v28 = v23;
          if (v22 >= 1.0e-10 && v22 <= 1.0)
          {
            if (1.0 - v28 >= 1.0e-10)
            {
              v42 = 1.0 - v22;
              v43 = (v28 - v22) / (1.0 - v22);
              v44 = a8.n128_f64[0] + v13 + a6.n128_f64[0] * -2.0;
              v45 = v13 + (v44 * v22 + (a6.n128_f64[0] - v13) * 2.0) * v22;
              v46 = a9.n128_f64[0] + v14 + a7.n128_f64[0] * -2.0;
              v47 = v14 + (v46 * v22 + (a7.n128_f64[0] - v14) * 2.0) * v22;
              v48 = v13
                  + (v22 * ((v12 + (a8.n128_f64[0] - a6.n128_f64[0]) * -3.0 - v13) * v22 + v44 * 3.0)
                   + (a6.n128_f64[0] - v13) * 3.0)
                  * v22;
              v49 = v14
                  + (v22 * ((v11 + (a9.n128_f64[0] - a7.n128_f64[0]) * -3.0 - v14) * v22 + v46 * 3.0)
                   + (a7.n128_f64[0] - v14) * 3.0)
                  * v22;
              v71 = v12 + ((a6.n128_f64[0] + v12 + a8.n128_f64[0] * -2.0) * v42 + (v12 - a8.n128_f64[0]) * -2.0) * v42;
              v50 = v11 + ((a7.n128_f64[0] + v11 + a9.n128_f64[0] * -2.0) * v42 + (v11 - a9.n128_f64[0]) * -2.0) * v42;
              v51 = v12 - (v12 - a8.n128_f64[0]) * (1.0 - v22);
              v52 = v11 - (v11 - a9.n128_f64[0]) * (1.0 - v22);
              a6.n128_f64[0] = v13 + (a6.n128_f64[0] - v13) * v22;
              a7.n128_f64[0] = v14 + (a7.n128_f64[0] - v14) * v22;
              a8.n128_f64[0] = v45;
              a9.n128_f64[0] = v47;
              approximateMonotonicCube(result, 0, v13, v14, a6, a7, a8, a9, v48, v49);
              v53 = v12 - v51;
              v54.n128_f64[0] = v48 + (v71 - v48) * v43;
              v55.n128_f64[0] = v49 + (v50 - v49) * v43;
              v56 = v51 + v48 + v71 * -2.0;
              v57.n128_f64[0] = v48 + (v43 * v56 + (v71 - v48) * 2.0) * v43;
              v58 = v52 + v49 + v50 * -2.0;
              v59.n128_f64[0] = v49 + (v43 * v58 + (v50 - v49) * 2.0) * v43;
              v60 = v48 + (v43 * (v43 * (v12 + (v51 - v71) * -3.0 - v48) + v56 * 3.0) + (v71 - v48) * 3.0) * v43;
              v61 = v49 + (v43 * (v43 * (v11 + (v52 - v50) * -3.0 - v49) + v58 * 3.0) + (v50 - v49) * 3.0) * v43;
              v62 = 1.0 - v43;
              v63 = v12 + ((1.0 - v43) * (v12 + v51 * -2.0 + v71) + (v12 - v51) * -2.0) * (1.0 - v43);
              v64 = v11 + ((1.0 - v43) * (v11 + v52 * -2.0 + v50) + (v11 - v52) * -2.0) * (1.0 - v43);
              v65 = v12 - v53 * v62;
              v66 = v11 - (v11 - v52) * v62;
              v67 = v48;
              v68 = v49;
              v69 = v60;
              v70 = v61;
              approximateMonotonicCube(v9, 0, v67, v68, v54, v55, v57, v59, v60, v61);
              result = v9;
              v13 = v69;
              v14 = v70;
              a6.n128_f64[0] = v63;
              a7.n128_f64[0] = v64;
              a8.n128_f64[0] = v65;
              a9.n128_f64[0] = v66;
            }
            else
            {
              v29 = v13 + (a6.n128_f64[0] - v13) * v22;
              v30 = v14 + (a7.n128_f64[0] - v14) * v22;
              v31 = a8.n128_f64[0] + v13 + a6.n128_f64[0] * -2.0;
              v32 = v13 + (v31 * v22 + (a6.n128_f64[0] - v13) * 2.0) * v22;
              v33 = a9.n128_f64[0] + v14 + a7.n128_f64[0] * -2.0;
              v34 = v14 + (v33 * v22 + (a7.n128_f64[0] - v14) * 2.0) * v22;
              v35 = v13
                  + (v22 * ((v12 + (a8.n128_f64[0] - a6.n128_f64[0]) * -3.0 - v13) * v22 + v31 * 3.0)
                   + (a6.n128_f64[0] - v13) * 3.0)
                  * v22;
              v36 = v14
                  + (v22 * ((v11 + (a9.n128_f64[0] - a7.n128_f64[0]) * -3.0 - v14) * v22 + v33 * 3.0)
                   + (a7.n128_f64[0] - v14) * 3.0)
                  * v22;
              v37 = 1.0 - v22;
              v38 = v12 + ((a6.n128_f64[0] + v12 + a8.n128_f64[0] * -2.0) * v37 + (v12 - a8.n128_f64[0]) * -2.0) * v37;
              v39 = v11 + ((a7.n128_f64[0] + v11 + a9.n128_f64[0] * -2.0) * v37 + (v11 - a9.n128_f64[0]) * -2.0) * v37;
              v40 = v12 - (v12 - a8.n128_f64[0]) * v37;
              v41 = v11 - (v11 - a9.n128_f64[0]) * v37;
              a6.n128_f64[0] = v29;
              a7.n128_f64[0] = v30;
              a8.n128_f64[0] = v32;
              a9.n128_f64[0] = v34;
              approximateMonotonicCube(result, 0, v13, v14, a6, a7, a8, a9, v35, v36);
              result = v9;
              v13 = v35;
              v14 = v36;
              a6.n128_f64[0] = v38;
              a7.n128_f64[0] = v39;
              a8.n128_f64[0] = v40;
              a9.n128_f64[0] = v41;
            }
          }
        }
        result = approximateMonotonicCube(result, 0, v13, v14, a6, a7, a8, a9, v12, v11);
        *((double *)v9 + 1) = v12;
        *((double *)v9 + 2) = v11;
        return result;
      }
      v14 = *((double *)result + 2);
      v15 = vabdd_f64(v13, a6.n128_f64[0]) + vabdd_f64(v14, a7.n128_f64[0]);
      v16 = vabdd_f64(a8.n128_f64[0], v12) + vabdd_f64(a9.n128_f64[0], v11);
      if (v16 + v15 < 0.0002)
        return result;
      if (v16 >= 0.0001 && v15 >= 0.0001)
        goto LABEL_12;
      v17 = *(double *)(a3 + 32);
      v18 = *(double *)(a3 + 40);
      return CGSScanconverterAddLineToPoint(result, v17, v18);
    case 4:
      v17 = *((double *)result + 3);
      v18 = *((double *)result + 4);
      return CGSScanconverterAddLineToPoint(result, v17, v18);
    default:
      abort();
  }
}

uint64_t ripc_GetColorTransform(uint64_t a1)
{
  uint64_t v1;

  if (a1)
    v1 = *(_QWORD *)(a1 + 288);
  else
    v1 = 0;
  ripc_InitializeColorTransform(v1);
  return *(_QWORD *)(v1 + 120);
}

CGFloat ripc_GetTransform@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  CGFloat result;
  double v6;
  uint64_t v7;
  uint64_t v8;

  if (a1)
    v3 = *(_QWORD *)(a1 + 288);
  else
    v3 = 0;
  v4 = *(_QWORD *)(v3 + 48);
  if (v4
    && (v7 = 0, v8 = 0, ((*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 72))(v4, &v7) & 1) != 0))
  {
    (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 48) + 88))(*(_QWORD *)(v3 + 48), v3 + 40);
    result = *(double *)(v3 + 40);
    v6 = (double)SHIDWORD(v8);
    *(CGFloat *)a2 = result;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(CGFloat *)(a2 + 24) = -result;
    *(_QWORD *)(a2 + 32) = 0;
    *(double *)(a2 + 40) = v6;
  }
  else
  {
    *(CGAffineTransform *)a2 = CGAffineTransformIdentity;
    return CGAffineTransformIdentity.tx;
  }
  return result;
}

const void *ripc_GetLayer(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGFloat a9, CGFloat a10, CGFloat a11, CGFloat a12)
{
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned int *v22;
  _QWORD **v23;
  uint64_t v24;
  _QWORD *v25;
  dispatch_once_t v26;
  unsigned int *v27;
  CGColorSpace *Cache;
  const void *result;
  const void *v30;
  double v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  double v36;
  int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  double v41;
  double v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  char *v47;
  char *v48;
  int v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  CGColorSpace *v55;
  CGRect v56;
  CGRect v57;

  if (a1)
    v18 = *(_QWORD *)(a1 + 288);
  else
    v18 = 0;
  v55 = 0;
  v52 = 0;
  v53 = 0;
  v54 = *(_OWORD *)(v18 + 24);
  if (theDict)
  {
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1)
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_77);
    CGCFDictionaryGetCFTypeRef(theDict, CFSTR("kCGContextColorSpace"), CGColorSpaceGetTypeID_type_id, (uint64_t *)&v55);
    if (v55 && !*(_BYTE *)(*((_QWORD *)v55 + 3) + 10))
      v55 = 0;
    CGCFDictionaryGetSize(theDict, CFSTR("kCGContextResolution"), (UInt8 *)&v54);
  }
  v19 = *(_QWORD **)(v18 + 88);
  if (v19)
  {
    do
    {
      v20 = v19;
      v19 = (_QWORD *)*v19;
    }
    while (v19);
    v21 = v20[4];
    if (v21)
      v22 = *(unsigned int **)(v21 + 32);
    else
      v22 = 0;
    v23 = (_QWORD **)(v20 + 1);
  }
  else
  {
    v23 = (_QWORD **)(v18 + 16);
    v24 = *(_QWORD *)(v18 + 48);
    if (v24)
      v22 = *(unsigned int **)(v24 + 32);
    else
      v22 = 0;
  }
  v25 = *v23;
  if (v55
    && (v26 = RIPLayerDepthForModel(*(_DWORD *)(*((_QWORD *)v55 + 3) + 24), *v22, a3, (uint64_t)theDict, a5, a6, a7, a8)) != 0)
  {
    v27 = (unsigned int *)v26;
    Cache = v55;
    v22 = v27;
  }
  else
  {
    Cache = (CGColorSpace *)CGColorTransformGetCache(v25);
    if (Cache)
    {
      Cache = (CGColorSpace *)*((_QWORD *)Cache + 2);
      v55 = Cache;
    }
    else
    {
      v55 = 0;
    }
  }
  result = (const void *)color_transform_create(Cache, theDict);
  if (result)
  {
    v30 = result;
    v31 = *(double *)(v18 + 40);
    v56.origin.x = a9;
    v56.origin.y = a10;
    v56.size.width = a11;
    v56.size.height = a12;
    v57 = CGRectStandardize(v56);
    if (v31 != 1.0)
    {
      v57.origin.x = v31 * v57.origin.x;
      v57.origin.y = v31 * v57.origin.y;
      v57.size.width = v31 * v57.size.width;
      v57.size.height = v31 * v57.size.height;
    }
    v35 = v57.size.width + v57.origin.x;
    v36 = v57.origin.x + 0.0;
    if (v57.origin.x + 0.0 <= 1073741820.0)
    {
      v38 = vcvtmd_s64_f64(v36);
      if (v36 >= -1073741820.0)
        v37 = v38;
      else
        v37 = -1073741823;
    }
    else
    {
      v37 = 0x3FFFFFFF;
    }
    LODWORD(v52) = v37;
    if (v35 <= 1073741820.0)
    {
      v40 = vcvtpd_s64_f64(v35);
      if (v35 >= -1073741820.0)
        v39 = v40;
      else
        v39 = -1073741823;
    }
    else
    {
      v39 = 0x3FFFFFFF;
    }
    LODWORD(v53) = v39 - v37;
    v41 = v57.size.height + v57.origin.y;
    v42 = v57.origin.y + 0.0;
    if (v42 <= 1073741820.0)
    {
      v44 = vcvtmd_s64_f64(v42);
      if (v42 >= -1073741820.0)
        v43 = v44;
      else
        v43 = -1073741823;
    }
    else
    {
      v43 = 0x3FFFFFFF;
    }
    HIDWORD(v52) = v43;
    if (v41 <= 1073741820.0)
    {
      v45 = vcvtpd_s64_f64(v41);
      if (v41 < -1073741820.0)
        v45 = -1073741823;
    }
    else
    {
      v45 = 0x3FFFFFFF;
    }
    HIDWORD(v53) = v45 - v43;
    if (a2)
      v46 = *(unsigned int *)(a2 + 4);
    else
      v46 = 3;
    v47 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v52, 17, (uint64_t)v22, v46, v32, v33, v34);
    if (v47)
    {
      v48 = v47;
      v49 = *(_DWORD *)(v18 + 216);
      v50 = ripc_Initialize();
      *((_QWORD *)v50 + 6) = v48;
      *((_QWORD *)v50 + 2) = v30;
      *(_OWORD *)(v50 + 24) = v54;
      *((double *)v50 + 5) = v31;
      *((_DWORD *)v50 + 54) = v49;
      if (a2)
      {
        v51 = *((_QWORD *)v50 + 1);
        if (v51)
          *(_DWORD *)(v51 + 96) = *(_DWORD *)(a2 + 4);
      }
      return *(const void **)v50;
    }
    else
    {
      CFRelease(v30);
      return 0;
    }
  }
  return result;
}

uint64_t ripc_DrawLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6, double a7, double a8)
{
  uint64_t v15;
  char v16;
  uint64_t v17;
  _QWORD *Cache;
  CGColorSpace *v19;
  CGDataProvider *Image;
  CGDataProvider *v21;
  void (*v22)(uint64_t, uint64_t, uint64_t, CGDataProvider *, double, double, double, double);

  if (a1)
  {
    v15 = *(_QWORD *)(a1 + 288);
    if (a4)
    {
LABEL_3:
      v16 = *(_QWORD *)(a4 + 80) != (_QWORD)ripc_DrawImage;
      goto LABEL_6;
    }
  }
  else
  {
    v15 = 0;
    if (a4)
      goto LABEL_3;
  }
  v16 = 1;
LABEL_6:
  v17 = *(_QWORD *)(v15 + 48);
  Cache = CGColorTransformGetCache(*(_QWORD **)(v15 + 16));
  if (Cache)
    v19 = (CGColorSpace *)Cache[2];
  else
    v19 = 0;
  Image = RIPLayerCreateImage(v17, v19, v16);
  if (!Image)
    return 1000;
  v21 = Image;
  if (a4)
  {
    v22 = *(void (**)(uint64_t, uint64_t, uint64_t, CGDataProvider *, double, double, double, double))(a4 + 80);
    if (v22)
      v22(a4, a2, a3, Image, a5, a6, a7, a8);
  }
  CFRelease(v21);
  return 0;
}

const char *ripc_GetName()
{
  return "RIPContextDelegate";
}

uint64_t ripc_GetColorSpace(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *Cache;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 288) + 8);
  if (!v1 || (v2 = *(_QWORD *)(v1 + 32)) == 0)
  {
    v3 = *(_QWORD *)(a1 + 288);
    ripc_InitializeColorTransform(v3);
    Cache = CGColorTransformGetCache(*(_QWORD **)(v3 + 120));
    if (Cache)
      return Cache[2];
    else
      return 0;
  }
  return v2;
}

uint64_t ripc_DrawImageApplyingToneMapping(uint64_t a1, uint64_t a2, uint64_t a3, CGImage *a4, unsigned int a5, const void *a6, CGFloat a7, CGFloat a8, double a9, double a10)
{
  uint64_t ColorSpace;
  _QWORD *v21;
  float v22;
  float HeadroomInfo;
  float v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  float v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  CGColorSpaceRef v39;
  const __CFNumber *v40;
  float v41;
  CFTypeID v42;
  const __CFDictionary *OptionsForToneMapping;
  _QWORD *CopyWithResolvedOptions;
  const void *v45;
  uint64_t v46;
  char v48;
  float valuePtr;

  ColorSpace = ripc_GetColorSpace(a1);
  if (!ColorSpace)
    return 1000;
  v21 = (_QWORD *)ColorSpace;
  v22 = 0.0;
  HeadroomInfo = 0.0;
  if (a5 - 3 >= 3)
  {
    v24 = *(float *)(*(_QWORD *)(a3 + 120) + 48);
    v25 = (_QWORD *)ripc_GetColorSpace(a1);
    if (CGColorSpaceSanitizeHeadroom(v25, v24) == 0.0)
      CGPostError((uint64_t)"CGContextDrawImageApplyingToneMapping: EDR Target headroom unspecified", v26, v27, v28, v29, v30, v31, v32, v48);
    v33 = *(float *)(*(_QWORD *)(a3 + 120) + 48);
    v34 = (_QWORD *)ripc_GetColorSpace(a1);
    v22 = CGColorSpaceSanitizeHeadroom(v34, v33);
    HeadroomInfo = CGImageGetHeadroomInfo(a4, 0);
  }
  v39 = CGImageGetColorSpace(a4);
  if (CGImageDefaultReferenceWhite_once != -1)
    dispatch_once(&CGImageDefaultReferenceWhite_once, &__block_literal_global_205);
  v40 = (const __CFNumber *)CGImageDefaultReferenceWhite_media_white;
  v41 = 0.0;
  if (CGImageDefaultReferenceWhite_media_white)
  {
    v42 = CFGetTypeID((CFTypeRef)CGImageDefaultReferenceWhite_media_white);
    if (v42 == CFNumberGetTypeID())
    {
      valuePtr = 0.0;
      CFNumberGetValue(v40, kCFNumberFloatType, &valuePtr);
      v41 = valuePtr;
    }
  }
  OptionsForToneMapping = CGColorConversionInfoCreateOptionsForToneMapping(a5, v21, v39, a6, v22, HeadroomInfo, v41, v35, v36, v37, v38);
  CopyWithResolvedOptions = (_QWORD *)CGImageCreateCopyWithResolvedOptions((uint64_t)a4, OptionsForToneMapping);
  v45 = CopyWithResolvedOptions;
  if (OptionsForToneMapping && CopyWithResolvedOptions)
  {
    v46 = ripc_DrawImage(a1, a2, a3, CopyWithResolvedOptions, a7, a8, a9, a10);
  }
  else
  {
    if (!OptionsForToneMapping)
    {
      v46 = ripc_DrawImage(a1, a2, a3, a4, a7, a8, a9, a10);
      if (!v45)
        return v46;
      goto LABEL_18;
    }
    v46 = 1000;
  }
  CFRelease(OptionsForToneMapping);
  if (v45)
LABEL_18:
    CFRelease(v45);
  return v46;
}

double ripc_InitializeImageTile(uint64_t a1, __int128 *a2, uint64_t a3, int a4, unint64_t a5, unint64_t a6, double *a7, double *a8, double result, double a10, double a11, double a12)
{
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  double v16;
  double v17;
  double v18;
  double v19;
  __int16 v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;

  *(_QWORD *)(a1 + 16) = a3;
  *(_WORD *)(a1 + 42) = -1;
  v12 = *a2;
  *(_OWORD *)a1 = *a2;
  if (!a7)
  {
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 40) = 0;
    goto LABEL_18;
  }
  v13 = *(unsigned int *)(a3 + 40);
  if (v13 != a5)
  {
    v21 = *a7;
    v22 = a7[1];
    v23 = a7[2];
    v24 = a7[3];
    if (a4 == 1)
    {
LABEL_12:
      *(_WORD *)(a1 + 40) = 0;
      goto LABEL_15;
    }
    *(_WORD *)(a1 + 40) = -1;
    v25 = (double)a5 / (double)v13;
    v21 = v25 * v21;
    v22 = v25 * v22;
    v14 = *(unsigned int *)(a3 + 44);
LABEL_14:
    if (v14 != a6)
    {
      v28 = (double)a6 / (double)v14;
      v27 = v23 * v28;
      v26 = v24 * v28;
      goto LABEL_17;
    }
LABEL_15:
    v26 = v24;
    v27 = v23;
LABEL_17:
    v29 = (double)a6 * a10;
    v30 = (double)(*((_DWORD *)a2 + 3) + *((_DWORD *)a2 + 1)) - (a7[5] + v24 * v29);
    a7[4] = a7[4] + v23 * v29 - (double)*(int *)a2;
    a7[5] = v30;
    a12 = -v22;
    *a7 = v21;
    a7[1] = a12;
    *(double *)&v12 = -v27;
    a7[2] = -v27;
    a7[3] = v26;
    *(_QWORD *)(a1 + 24) = a7;
    *(_QWORD *)(a1 + 48) = 0;
    goto LABEL_18;
  }
  v14 = *(unsigned int *)(a3 + 44);
  if (v14 != a6)
  {
    v21 = *a7;
    v22 = a7[1];
    v23 = a7[2];
    v24 = a7[3];
    if (a4 == 1)
      goto LABEL_12;
    *(_WORD *)(a1 + 40) = -1;
    goto LABEL_14;
  }
  v15 = *((_DWORD *)a2 + 3) + *((_DWORD *)a2 + 1);
  v16 = (double)a6 * a10;
  v17 = a7[5] + a7[3] * v16;
  v19 = a7[1];
  v18 = a7[2];
  a7[4] = a7[4] + v18 * v16 - (double)*(int *)a2;
  a7[5] = (double)v15 - v17;
  *(double *)&v12 = -v18;
  a12 = -v19;
  a7[1] = -v19;
  a7[2] = -v18;
  *(_QWORD *)(a1 + 24) = a7;
  *(_QWORD *)(a1 + 48) = 0;
  if (a4 == 1)
    v20 = 0;
  else
    v20 = -1;
  *(_WORD *)(a1 + 40) = v20;
LABEL_18:
  *(_QWORD *)(a1 + 32) = a8;
  if (a8)
  {
    LODWORD(a12) = *(_DWORD *)(a3 + 40);
    LODWORD(v12) = *(_DWORD *)(a3 + 44);
    v31 = (double)(unint64_t)v12 * a10;
    v32 = a8[1];
    v33 = v31 - (v32 + a8[3]) * v31;
    v34 = v31 - v32 * v31;
    v35 = (double)*(unint64_t *)&a12 * result;
    v36 = *a8 + a8[2];
    v37 = *a8 * v35;
    *a8 = v37;
    a8[1] = v33;
    result = v36 * v35 - v37;
    a8[2] = result;
    a8[3] = v34 - v33;
  }
  return result;
}

CFDictionaryRef __get_flattening_options_block_invoke()
{
  CFDictionaryRef result;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("kCGColorTransformFlattenImage");
  values = (void *)*MEMORY[0x1E0C9AE50];
  result = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  get_flattening_options_options = (uint64_t)result;
  return result;
}

CFDataRef CGCMSUtilsGetICCProfileData(CGColorSpaceRef space, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((CGCMSUtilsGetICCProfileData_warned & 1) == 0)
  {
    CGCMSUtilsGetICCProfileData_warned = 1;
  }
  return CGColorSpaceCopyICCData(space);
}

double *CG::Quadratic::length(double *this, int a2)
{
  double v3;
  double v4;
  double v5;
  double v6;
  int v7;
  _BYTE v8[80];
  uint64_t v9;

  v3 = this[2];
  if (*this != v3 || this[1] != this[3])
  {
    v4 = this[4];
    if (v3 == v4)
    {
      v6 = this[3];
      v5 = this[5];
      if (v6 == v5)
        return this;
    }
    else
    {
      v5 = this[5];
      v6 = this[3];
    }
    if (a2 <= 32
      && (v5 - v6 + this[1] - v6) * (v5 - v6 + this[1] - v6) + (*this - v3 + v4 - v3) * (*this - v3 + v4 - v3) >= 4.0)
    {
      CG::Quadratic::split((CG::Quadratic *)v8, 0.5, this);
      v7 = a2 + 1;
      CG::Quadratic::length((CG::Quadratic *)v8, v7);
      return (double *)CG::Quadratic::length((CG::Quadratic *)&v9, v7);
    }
  }
  return this;
}

double CG::Quadratic::split(CG::Quadratic *this, double a2, double *a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double result;

  v3 = a3[2];
  v4 = a3[3];
  v5 = a3[1];
  v6 = *a3 + (v3 - *a3) * a2;
  v7 = v5 + (v4 - v5) * a2;
  v8 = a3[4];
  v9 = a3[5];
  v10 = v3 + (v8 - v3) * a2;
  v11 = v4 + (v9 - v4) * a2;
  v12 = v6 + (v10 - v6) * a2;
  v13 = v7 + (v11 - v7) * a2;
  v14 = v6 - *a3;
  v15 = v11 - v13 + v11 - v13;
  *(double *)this = *a3;
  *((double *)this + 1) = v5;
  *((double *)this + 2) = v6;
  *((double *)this + 3) = v7;
  *((double *)this + 4) = v12;
  *((double *)this + 5) = v13;
  *((double *)this + 6) = v14 + v14;
  *((double *)this + 7) = v7 - v5 + v7 - v5;
  *((double *)this + 8) = v12 - v6 - v14;
  *((double *)this + 9) = v13 - v7 - (v7 - v5);
  *((double *)this + 10) = v12;
  *((double *)this + 11) = v13;
  *((double *)this + 12) = v10;
  *((double *)this + 13) = v11;
  *((double *)this + 14) = v8;
  *((double *)this + 15) = v9;
  result = v9 - v11 - (v11 - v13);
  *((double *)this + 16) = v10 - v12 + v10 - v12;
  *((double *)this + 17) = v15;
  *((double *)this + 18) = v8 - v10 - (v10 - v12);
  *((double *)this + 19) = result;
  return result;
}

double *CG::Quadratic::index(double *this, double a2)
{
  double *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8[20];

  if (a2 > 0.0)
  {
    v3 = this;
    this = CG::Quadratic::length(this, 0);
    if (v4 > a2)
    {
      v5 = 1.0;
      v6 = 0.0;
      do
      {
        CG::Quadratic::split((CG::Quadratic *)v8, (v5 + v6) * 0.5, v3);
        this = CG::Quadratic::length(v8, 0);
        if (v7 <= a2)
          v6 = (v5 + v6) * 0.5;
        else
          v5 = (v5 + v6) * 0.5;
      }
      while (v5 - v6 > 0.0001);
    }
  }
  return this;
}

void cmap_cid_set_release(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    free(a1);
  }
}

char *add_range(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  char *result;
  char *v9;

  v6 = *(_QWORD *)(a1 + 16);
  if (v6 == *(_QWORD *)(a1 + 8))
  {
    v7 = 2 * v6 + 8;
    result = (char *)malloc_type_realloc(*(void **)(a1 + 24), 12 * v7, 0x1000040CBA68D63uLL);
    if (!result)
      return result;
    *(_QWORD *)(a1 + 24) = result;
    *(_QWORD *)(a1 + 8) = v7;
    v6 = *(_QWORD *)(a1 + 16);
  }
  else
  {
    result = *(char **)(a1 + 24);
  }
  *(_QWORD *)(a1 + 16) = v6 + 1;
  v9 = &result[12 * v6];
  *(_QWORD *)v9 = a2;
  *((_DWORD *)v9 + 2) = a3;
  return result;
}

BOOL cmap_cid_set_normalize(_BOOL8 result)
{
  unsigned __int8 *v1;
  unsigned int v2;
  char *v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_BYTE *)(result + 32))
  {
    v1 = (unsigned __int8 *)result;
    qsort(*(void **)(result + 24), *(_QWORD *)(result + 16), 0xCuLL, (int (__cdecl *)(const void *, const void *))compare_ranges);
    result = contains_overlaps((uint64_t)v1);
    if (result)
    {
      v2 = *v1;
      if (v2 > 4 || ((1 << v2) & 0x16) == 0)
      {
        v5 = 0;
      }
      else
      {
        v4 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x10200401AE633E8uLL);
        v5 = v4;
        if (v4)
        {
          *v4 = v2;
          v4[32] = 0;
        }
      }
      v6 = *((_QWORD *)v1 + 2);
      if (v6)
      {
        v7 = 0;
        v8 = -1;
        do
        {
          add_nonoverlapping_range(v5, (unsigned int *)(*((_QWORD *)v1 + 3) + 12 * (v6 + v8)), 0);
          ++v7;
          v6 = *((_QWORD *)v1 + 2);
          --v8;
        }
        while (v7 < v6);
      }
      free(*((void **)v1 + 3));
      v9 = *(_OWORD *)v5;
      v10 = *((_OWORD *)v5 + 1);
      *((_QWORD *)v1 + 4) = *((_QWORD *)v5 + 4);
      *(_OWORD *)v1 = v9;
      *((_OWORD *)v1 + 1) = v10;
      *((_QWORD *)v5 + 3) = 0;
      cmap_cid_set_release((void **)v5);
      result = contains_overlaps((uint64_t)v1);
      if (result)
        _CGHandleAssert("remove_overlaps", 203, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/CMaps/cmap-cid-set.c", "!contains_overlaps(set)", "set %p contains overlaps", v11, v12, v13, (char)v1);
    }
    v1[32] = 0;
  }
  return result;
}

uint64_t compare_ranges(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

BOOL contains_overlaps(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _DWORD *v5;
  BOOL v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  unint64_t v10;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(a1 + 24);
    v4 = v1 - 1;
    v5 = (_DWORD *)(v3 + 16);
    v6 = 1;
    while (1)
    {
      v7 = v2 + 1;
      if (v2 + 1 < v1)
        break;
LABEL_8:
      --v4;
      v5 += 3;
      v6 = ++v2 < v1;
      if (v7 == v1)
        return 0;
    }
    v8 = (_DWORD *)(v3 + 12 * v2);
    v9 = v5;
    v10 = v4;
    while (v8[1] < *(v9 - 1) || *v8 > *v9)
    {
      v9 += 3;
      if (!--v10)
        goto LABEL_8;
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

char *add_nonoverlapping_range(char *result, unsigned int *a2, unint64_t a3)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned int *i;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  unint64_t v14;
  int v15;

  v4 = result;
  v5 = *((_QWORD *)result + 2);
  if (v5 <= a3)
    return add_range((uint64_t)result, *(_QWORD *)a2, a2[2]);
  v6 = a3;
  v7 = a2[1];
  for (i = (unsigned int *)(*((_QWORD *)result + 3) + 12 * a3 + 4); ; i += 3)
  {
    v9 = *(i - 1);
    if (v7 >= v9)
    {
      v10 = *a2;
      v11 = *i;
      if (v10 <= *i)
        break;
    }
    if (v5 == ++v6)
      return add_range((uint64_t)result, *(_QWORD *)a2, a2[2]);
  }
  v15 = 0;
  v14 = 0;
  if (v10 < v9)
  {
    v12 = *((unsigned __int16 *)a2 + 4);
    v14 = v10 | ((unint64_t)(v9 - 1) << 32);
    v15 = v12;
    result = (char *)add_nonoverlapping_range(result, &v14, v6 + 1);
    v7 = a2[1];
    v11 = *(_DWORD *)(*((_QWORD *)v4 + 3) + 12 * v6 + 4);
  }
  if (v7 > v11)
  {
    v13 = (unsigned __int16)(v11 + 1 + *((_WORD *)a2 + 4) - *a2);
    v14 = (v11 + 1) | (unint64_t)(v7 << 32);
    v15 = v13;
    return (char *)add_nonoverlapping_range(v4, &v14, v6 + 1);
  }
  return result;
}

uint64_t cmap_cid_set_find_matching_range(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  int __key;

  __key = a2;
  if (result)
  {
    v4 = result;
    cmap_cid_set_normalize(result);
    result = (uint64_t)bsearch(&__key, *(const void **)(v4 + 24), *(_QWORD *)(v4 + 16), 0xCuLL, (int (__cdecl *)(const void *, const void *))compare_code_with_range);
    if (result)
    {
      v5 = *(_QWORD *)result;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(result + 8);
      *(_QWORD *)a3 = v5;
      return 1;
    }
  }
  return result;
}

uint64_t compare_code_with_range(_DWORD *a1, _DWORD *a2)
{
  if (*a1 >= *a2)
    return *a1 > a2[1];
  else
    return 0xFFFFFFFFLL;
}

uint64_t cmap_cid_set_create_with_stream(__CFReadStream *a1)
{
  uint64_t v2;
  int v3;
  _BYTE *v5;
  CFIndex v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  unsigned int v10;
  CFIndex v11;
  unsigned int v12;
  CFIndex v13;
  unsigned int v14;
  CFIndex v15;
  unsigned int v16;
  uint64_t v17;
  CFIndex v18;
  unsigned int v19;
  int v20;
  UInt8 buffer[4];

  buffer[0] = 0;
  v2 = 0;
  if (!CFReadStreamRead(a1, buffer, 1))
    return v2;
  v3 = buffer[0];
  if (!buffer[0])
    return v2;
  if (buffer[0] > 4u || ((1 << buffer[0]) & 0x16) == 0)
    return 0;
  v5 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200401AE633E8uLL);
  v2 = (uint64_t)v5;
  if (!v5)
    return v2;
  *v5 = v3;
  v5[32] = 0;
  *(_DWORD *)buffer = 0;
  v6 = CFReadStreamRead(a1, buffer, 4);
  v7 = bswap32(*(unsigned int *)buffer);
  if (v6)
    v8 = v7;
  else
    v8 = 0;
  *(_QWORD *)(v2 + 8) = v8;
  v9 = malloc_type_malloc(12 * v8, 0x1000040CBA68D63uLL);
  *(_QWORD *)(v2 + 24) = v9;
  if (!v9)
  {
    free((void *)v2);
    return 0;
  }
  if (v8)
  {
    if ((v3 - 1) >= 2 && v3 != 4)
      abort();
    do
    {
      if (v3 == 2)
      {
        *(_WORD *)buffer = 0;
        v13 = CFReadStreamRead(a1, buffer, 2);
        v14 = bswap32(*(unsigned __int16 *)buffer) >> 16;
        if (v13)
          v10 = v14;
        else
          v10 = 0;
        *(_WORD *)buffer = 0;
        v11 = CFReadStreamRead(a1, buffer, 2);
        v12 = bswap32(*(unsigned __int16 *)buffer) >> 16;
      }
      else if (v3 == 1)
      {
        buffer[0] = 0;
        if (CFReadStreamRead(a1, buffer, 1))
          v10 = buffer[0];
        else
          v10 = 0;
        buffer[0] = 0;
        v11 = CFReadStreamRead(a1, buffer, 1);
        v12 = buffer[0];
      }
      else
      {
        *(_DWORD *)buffer = 0;
        v15 = CFReadStreamRead(a1, buffer, 4);
        v16 = bswap32(*(unsigned int *)buffer);
        if (v15)
          v10 = v16;
        else
          v10 = 0;
        *(_DWORD *)buffer = 0;
        v11 = CFReadStreamRead(a1, buffer, 4);
        v12 = bswap32(*(unsigned int *)buffer);
      }
      if (v11)
        v17 = v12;
      else
        v17 = 0;
      *(_WORD *)buffer = 0;
      v18 = CFReadStreamRead(a1, buffer, 2);
      v19 = bswap32(*(unsigned __int16 *)buffer) >> 16;
      if (v18)
        v20 = v19;
      else
        v20 = 0;
      add_range(v2, v10 | (unint64_t)(v17 << 32), v20);
      *(_BYTE *)(v2 + 32) = 1;
      --v8;
    }
    while (v8);
  }
  *(_BYTE *)(v2 + 32) = 0;
  return v2;
}

BOOL CGPDFTaggedNodeEqualToPDFTaggedNode(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  const __CFArray *v6;
  unint64_t v7;
  const __CFArray *v8;
  CFIndex v9;
  const char *Name;
  const char *v11;
  uint64_t TextRange;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t i;
  const void *ChildAtIndex;
  const void *v19;

  if (!(a1 | a2))
    return 1;
  v2 = 0;
  if (a1 && a2)
  {
    v6 = *(const __CFArray **)(a1 + 96);
    v7 = v6 ? CFArrayGetCount(v6) : 0;
    v8 = *(const __CFArray **)(a2 + 96);
    v9 = v8 ? CFArrayGetCount(v8) : 0;
    Name = CGPDFTaggedNodeTypeGetName(*(_DWORD *)(a1 + 16));
    v11 = CGPDFTaggedNodeTypeGetName(*(_DWORD *)(a2 + 16));
    TextRange = CGPDFTaggedNodeGetTextRange(a1);
    v14 = v13;
    v15 = CGPDFTaggedNodeGetTextRange(a2);
    v2 = 0;
    if (v7 == v9 && Name == v11)
    {
      v2 = 0;
      if (TextRange == v15 && v14 == v16)
      {
        if (!v7)
          return 1;
        v2 = 0;
        for (i = 0; i != v7; v2 = i >= v7)
        {
          ChildAtIndex = CGPDFTaggedNodeGetChildAtIndex(a1, i);
          v19 = CGPDFTaggedNodeGetChildAtIndex(a2, i);
          if ((CGPDFTaggedNodeEqualToPDFTaggedNode(ChildAtIndex, v19) & 1) == 0)
            break;
          ++i;
        }
      }
    }
  }
  return v2;
}

uint64_t CGPDFTaggedNodeGetTextRange(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v3[5];

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 104))
    {
      if (!*(_BYTE *)(result + 168))
      {
        result = GetTextRangeForTaggedNode(result);
        *(_QWORD *)(v1 + 176) = result;
        *(_QWORD *)(v1 + 184) = v2;
        *(_BYTE *)(v1 + 168) = 1;
        return result;
      }
    }
    else if (!*(_BYTE *)(result + 168))
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 3221225472;
      v3[2] = __CGPDFTaggedNodeGetTextRange_block_invoke;
      v3[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
      v3[4] = result;
      CGPDFTaggedNodeEnumerateChildren(result, v3);
      *(_BYTE *)(v1 + 168) = 1;
      *(_BYTE *)(v1 + 192) = 0;
    }
    return *(_QWORD *)(v1 + 176);
  }
  return result;
}

const void *CGPDFTaggedNodeGetChildAtIndex(uint64_t a1, unint64_t a2)
{
  const __CFArray *v3;

  if (a1 && (v3 = *(const __CFArray **)(a1 + 96)) != 0 && CFArrayGetCount(v3) > a2)
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), a2);
  else
    return 0;
}

uint64_t GetTextRangeForTaggedNode(uint64_t a1)
{
  uint64_t v1;
  int v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t TextRange;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  _QWORD v14[5];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  __n128 (*v18)(__n128 *, __n128 *);
  uint64_t (*v19)();
  const char *v20;
  uint64_t v21;
  uint64_t v22;

  v1 = a1;
  v15 = 0;
  v16 = &v15;
  v17 = 0x4012000000;
  v18 = __Block_byref_object_copy__37;
  v19 = __Block_byref_object_dispose__38;
  v21 = 0;
  v22 = 0;
  v20 = "";
  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 16);
    v3 = v2 == 700 || v2 == 1;
    if (v3 && (CGPDFNodeGetTextRange(*(_QWORD *)(a1 + 104)), v4 >= 1))
    {
      v5 = v16[6];
      v6 = v16[7];
      TextRange = CGPDFNodeGetTextRange(*(_QWORD *)(v1 + 104));
      v1 = TextRange;
      v9 = v8;
      if (v6 >= 1)
      {
        if (v8 < 1)
        {
          v9 = v6;
          v1 = v5;
        }
        else
        {
          v10 = v6 + v5 - TextRange;
          if (v8 > v10)
            v10 = v8;
          v11 = v8 - v5 + TextRange;
          if (v6 > v11)
            v11 = v6;
          if (v5 < TextRange)
            v9 = v11;
          else
            v9 = v10;
          if (v5 < TextRange)
            v1 = v5;
        }
      }
      v12 = v16;
      v16[6] = v1;
      v12[7] = v9;
    }
    else
    {
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = ___ZL25GetTextRangeForTaggedNodeP15CGPDFTaggedNode_block_invoke;
      v14[3] = &unk_1E165EE70;
      v14[4] = &v15;
      CGPDFTaggedNodeEnumerateChildren(v1, v14);
      v1 = v16[6];
    }
  }
  _Block_object_dispose(&v15, 8);
  return v1;
}

void sub_184CD6070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeEnumerateChildren(uint64_t a1, void *a2)
{
  const __CFArray *v3;
  CFIndex Count;
  unint64_t v5;
  CFIndex v6;
  const void *ChildAtIndex;
  char v8;
  char v10;
  uint64_t (**v11)(id, const void *, unint64_t);

  v11 = a2;
  if (a1)
  {
    if (v11)
    {
      v3 = *(const __CFArray **)(a1 + 96);
      if (v3)
      {
        Count = CFArrayGetCount(v3);
        if (Count)
        {
          v5 = 0;
          v6 = Count - 1;
          do
          {
            ChildAtIndex = CGPDFTaggedNodeGetChildAtIndex(a1, v5);
            v8 = v11[2](v11, ChildAtIndex, v5);
            if (v6 == v5++)
              v10 = 0;
            else
              v10 = v8;
          }
          while ((v10 & 1) != 0);
        }
      }
    }
  }

}

void sub_184CD619C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__37(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t ___ZL25GetTextRangeForTaggedNodeP15CGPDFTaggedNode_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t TextRangeForTaggedNode;
  uint64_t v7;
  uint64_t v8;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(_QWORD *)(v3 + 48);
  v5 = *(_QWORD *)(v3 + 56);
  TextRangeForTaggedNode = GetTextRangeForTaggedNode(a2);
  if (v5 >= 1)
  {
    if (v7 < 1)
    {
      v7 = v5;
LABEL_8:
      TextRangeForTaggedNode = v4;
      goto LABEL_11;
    }
    if (v4 < TextRangeForTaggedNode)
    {
      if (v5 <= v7 - v4 + TextRangeForTaggedNode)
        v7 = v7 - v4 + TextRangeForTaggedNode;
      else
        v7 = v5;
      goto LABEL_8;
    }
    if (v7 <= v5 + v4 - TextRangeForTaggedNode)
      v7 = v5 + v4 - TextRangeForTaggedNode;
  }
LABEL_11:
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  *(_QWORD *)(v8 + 48) = TextRangeForTaggedNode;
  *(_QWORD *)(v8 + 56) = v7;
  return 1;
}

CFIndex CGPDFTaggedNodeGetChildCount(uint64_t a1)
{
  const __CFArray *v1;

  if (a1 && (v1 = *(const __CFArray **)(a1 + 96)) != 0)
    return CFArrayGetCount(v1);
  else
    return 0;
}

uint64_t CGPDFTaggedNodeGetType(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 16);
  return result;
}

uint64_t CGPDFTaggedNodeConvertStringRangeToTextRange(uint64_t a1, int64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;
  _QWORD *v7;
  int64_t v8;
  int64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  void **v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  __int128 v17;

  v14 = 0;
  v15 = 0;
  v16 = 0;
  v13 = (void **)&v14;
  if (*(_BYTE *)(a1 + 8))
    return -1;
  result = *(_QWORD *)(a1 + 152);
  v7 = *(_QWORD **)(a1 + 160);
  if ((_QWORD *)result != v7)
  {
    v8 = *(v7 - 1);
    v9 = a3 + a2;
    v10 = -1;
    if ((a2 & 0x8000000000000000) == 0 && a2 < v8)
      v10 = (uint64_t)PageLayout::convertStringRangeIndexToTextRangeIndex((_QWORD *)result, v7, a2);
    v11 = (char *)v10;
    if ((v9 & 0x8000000000000000) == 0)
    {
      v11 = (char *)v10;
      if (v9 < v8)
      {
        v12 = (char *)PageLayout::convertStringRangeIndexToTextRangeIndex(*(_QWORD **)(a1 + 152), *(_QWORD **)(a1 + 160), v9);
        if (objc_msgSend(*(id *)(a1 + 24), "characterAtIndex:", v9, v13) == 10)
          v11 = v12 + 1;
        else
          v11 = v12;
      }
    }
    *(_QWORD *)&v17 = v10;
    *((_QWORD *)&v17 + 1) = &v11[-v10];
    std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:se180100](&v13, &v17);
    if (v14 == v15)
    {
      v3 = -1;
      if (!v15)
        return v3;
    }
    else
    {
      v3 = *v14;
    }
    v15 = v14;
    operator delete(v14);
    return v3;
  }
  __break(1u);
  return result;
}

void sub_184CD6384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFTaggedNodePrint(uint64_t result)
{
  if (result)
    return CGPDFTaggedNodePrintTabbed(result, 0);
  return result;
}

uint64_t CGPDFTaggedNodePrintTabbed(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  const __CFArray *v4;
  CFIndex Count;
  uint64_t v6;
  const char *Name;
  int TextRange;
  int v9;
  int v10;
  double Bounds;
  double v12;
  double v13;
  double v14;
  unint64_t i;
  _DWORD *ChildAtIndex;
  _DWORD *v17;
  int v18;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  const char *v23;

  if (!result)
    return result;
  v3 = result;
  v4 = *(const __CFArray **)(result + 96);
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (!a2)
      goto LABEL_8;
  }
  else
  {
    Count = 0;
    if (!a2)
      goto LABEL_8;
  }
  v6 = a2;
  do
  {
    printf("    ");
    --v6;
  }
  while (v6);
LABEL_8:
  Name = CGPDFTaggedNodeTypeGetName(*(_DWORD *)(v3 + 16));
  TextRange = CGPDFTaggedNodeGetTextRange(v3);
  v10 = v9;
  Bounds = CGPDFTaggedNodeGetBounds(v3);
  result = printf("CGPDFTaggedNodeRef: %p, type: <%s>, page %d, child count: %zu, text range: [%d, %d], bounds: (%.2f, %.2f), [%.2f, %.2f]\n", (const void *)v3, Name, *(_QWORD *)(v3 + 160), Count, TextRange, v10, Bounds, v12, v13, v14);
  if (Count)
  {
    for (i = 0; i != Count; ++i)
    {
      ChildAtIndex = CGPDFTaggedNodeGetChildAtIndex(v3, i);
      v17 = ChildAtIndex;
      if (ChildAtIndex)
      {
        v18 = ChildAtIndex[4];
        if (v18 == 700 || v18 == 1)
        {
          if (a2 != -1)
          {
            v20 = a2 + 1;
            do
            {
              printf("    ");
              --v20;
            }
            while (v20);
          }
          v21 = CGPDFTaggedNodeTypeGetName(v18);
          result = printf("Leaf-node type: %s.\n", v21);
          continue;
        }
      }
      else
      {
        v18 = 0;
      }
      if (a2)
      {
        v22 = a2;
        do
        {
          printf("    ");
          --v22;
        }
        while (v22);
      }
      v23 = CGPDFTaggedNodeTypeGetName(v18);
      printf("Tagged node type: %s.\n", v23);
      result = CGPDFTaggedNodePrintTabbed(v17, a2 + 1);
    }
  }
  return result;
}

double CGPDFTaggedNodeGetBounds(uint64_t a1)
{
  double v2;
  double *v3;
  __int128 v4;
  _QWORD v6[5];
  uint64_t v7;
  double *v8;
  uint64_t v9;
  __n128 (*v10)(uint64_t, uint64_t);
  uint64_t (*v11)();
  const char *v12;
  CGRect v13;

  if (!a1)
    return 0.0;
  if (*(_BYTE *)(a1 + 48))
    return *(double *)(a1 + 56);
  v7 = 0;
  v8 = (double *)&v7;
  v9 = 0x5012000000;
  v10 = __Block_byref_object_copy__12766;
  v11 = __Block_byref_object_dispose__12767;
  v12 = "";
  v13 = CGRectNull;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __CGPDFTaggedNodeGetBounds_block_invoke;
  v6[3] = &unk_1E165EE70;
  v6[4] = &v7;
  CGPDFTaggedNodeEnumerateChildren(a1, v6);
  *(_BYTE *)(a1 + 48) = 1;
  v3 = v8;
  v4 = *((_OWORD *)v8 + 4);
  *(_OWORD *)(a1 + 56) = *((_OWORD *)v8 + 3);
  *(_OWORD *)(a1 + 72) = v4;
  v2 = v3[6];
  _Block_object_dispose(&v7, 8);
  return v2;
}

void sub_184CD665C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__12766(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

CFTypeRef CGPDFTaggedNodeRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void CGPDFTaggedNodeRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGPDFTaggedNodeGetTypeName(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

BOOL CGPDFTaggedNodeIsImage(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 113) != 0;
  return result;
}

double CGPDFTaggedNodeGetBoundsForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  uint64_t TextRange;
  uint64_t v11;
  CFIndex v12;
  uint64_t v13;
  const void *v14;
  double v15;
  CFRange v17;

  if (!a1)
    return INFINITY;
  v6 = *(_QWORD *)(a1 + 104);
  if (v6)
  {
    v7 = CGPDFNodeGetTextRange(*(_QWORD *)(a1 + 104)) + a2;
    while (*(_DWORD *)v6 != 517)
    {
      v6 = *(_QWORD *)(v6 + 8);
      if (!v6)
      {
        v8 = 0;
        return CGPDFLayoutGetBoundsForTextRange(v8, v7, a3);
      }
    }
    v8 = *(_QWORD *)(v6 + 104);
    return CGPDFLayoutGetBoundsForTextRange(v8, v7, a3);
  }
  else
  {
    TextRange = CGPDFTaggedNodeGetTextRange(a1);
    if (a2 + a3 > v11)
      v12 = -1;
    else
      v12 = TextRange + a2;
    if (a2 + a3 > v11)
      a3 = 0;
    v9 = INFINITY;
    if (v12 != -1)
    {
      if (a3)
      {
        CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
        v14 = (const void *)v13;
        v17.location = v12;
        v17.length = a3;
        PageLayout::GetBoundsForTextRange((PageLayout *)(v13 + 16), v17);
        v9 = v15;
        if (v14)
          CFRelease(v14);
      }
    }
  }
  return v9;
}

double CGPDFTaggedNodeGetBoundsForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v4;
  int64_t PageStringRangeFromStringRange;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  PageLayout *v11;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  double v15;
  _BYTE v16[480];
  uint64_t v17;
  CFRange v18;

  if (a1 && !*(_QWORD *)(a1 + 104))
  {
    PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
    v8 = v7;
    CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
    v10 = (const void *)v9;
    v17 = v9;
    v11 = (PageLayout *)(v9 + 16);
    PageLayout::PageLayout((PageLayout *)v16, (const PageLayout *)(v9 + 16));
    v12 = CGPDFTaggedNodeConvertStringRangeToTextRange((uint64_t)v16, PageStringRangeFromStringRange, v8);
    v14 = v13;
    PageLayout::~PageLayout((PageLayout *)v16);
    if (v12 == -1)
    {
      v4 = INFINITY;
      if (!v10)
        return v4;
    }
    else
    {
      v18.location = v12;
      v18.length = v14;
      PageLayout::GetBoundsForTextRange(v11, v18);
      v4 = v15;
      if (!v10)
        return v4;
    }
    CFRelease(v10);
    return v4;
  }
  return INFINITY;
}

void sub_184CD6984(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  PageLayout::~PageLayout((PageLayout *)va);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v2 - 88));
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeGetPageStringRangeFromStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t TextRange;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE v16[480];
  uint64_t v17;

  if (*(_QWORD *)(a1 + 104))
    return 0;
  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v8 = v7;
  v17 = v7;
  TextRange = CGPDFTaggedNodeGetTextRange(a1);
  v11 = v10;
  PageLayout::PageLayout((PageLayout *)v16, (const PageLayout *)(v8 + 16));
  v12 = CGPDFTaggedNodeConvertTextRangeToStringRange((uint64_t)v16, TextRange, v11);
  v14 = v13;
  PageLayout::~PageLayout((PageLayout *)v16);
  if (a2 + a3 > v14)
    v3 = -1;
  else
    v3 = v12 + a2;
  if (v8)
    CFRelease((CFTypeRef)v8);
  return v3;
}

void sub_184CD6A74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  PageLayout::~PageLayout((PageLayout *)va);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v2 - 56));
  _Unwind_Resume(a1);
}

void PageLayout::PageLayout(PageLayout *this, const PageLayout *a2)
{
  unint64_t v2;
  __int128 v5;
  id v6;
  _BYTE *v7;
  _BYTE *v8;
  int64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  uint64_t v19;
  std::string *v20;
  uint64_t v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  uint64_t *v25;
  uint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t v29;
  uint8x8_t v30;
  uint64_t **v31;
  uint64_t *i;
  unint64_t v33;
  _QWORD *v34;
  float v35;
  float v36;
  _BOOL8 v37;
  unint64_t v38;
  unint64_t v39;
  size_t v40;
  uint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  int v44;
  _BYTE *v45;
  _BYTE *v46;
  int64_t v47;
  char *v48;
  uint64_t v49;
  _BYTE *v50;
  _BYTE *v51;
  int64_t v52;
  char *v53;
  uint64_t v54;
  _BYTE *v55;
  _BYTE *v56;
  int64_t v57;
  char *v58;
  uint64_t v59;
  char *v60;
  char **v61;
  char **v62;
  char v63;
  std::string *v64;
  std::string *v65;

  v5 = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *(_OWORD *)this = v5;
  v6 = *((id *)a2 + 3);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = v6;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  std::vector<PageLayout::TextLine>::__init_with_size[abi:se180100]<PageLayout::TextLine*,PageLayout::TextLine*>((_QWORD *)this + 4, *((const void **)a2 + 4), *((_QWORD *)a2 + 5), 0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)a2 + 5) - *((_QWORD *)a2 + 4)) >> 3));
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v8 = (_BYTE *)*((_QWORD *)a2 + 7);
  v7 = (_BYTE *)*((_QWORD *)a2 + 8);
  v9 = v7 - v8;
  if (v7 != v8)
  {
    std::vector<unsigned short>::__vallocate[abi:se180100]((_QWORD *)this + 7, v9 >> 1);
    v10 = (char *)*((_QWORD *)this + 8);
    memmove(v10, v8, v9);
    *((_QWORD *)this + 8) = &v10[2 * (v9 >> 1)];
  }
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  std::vector<unsigned long>::__init_with_size[abi:se180100]<unsigned long *,unsigned long *>((_QWORD *)this + 10, *((const void **)a2 + 10), *((_QWORD *)a2 + 11), (uint64_t)(*((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10)) >> 3);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  std::vector<CGRect>::__init_with_size[abi:se180100]<CGRect*,CGRect*>((_QWORD *)this + 13, *((const void **)a2 + 13), *((_QWORD *)a2 + 14), (uint64_t)(*((_QWORD *)a2 + 14) - *((_QWORD *)a2 + 13)) >> 5);
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  std::vector<CGRect>::__init_with_size[abi:se180100]<CGRect*,CGRect*>((_QWORD *)this + 16, *((const void **)a2 + 16), *((_QWORD *)a2 + 17), (uint64_t)(*((_QWORD *)a2 + 17) - *((_QWORD *)a2 + 16)) >> 5);
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  std::vector<unsigned long>::__init_with_size[abi:se180100]<unsigned long *,unsigned long *>((_QWORD *)this + 19, *((const void **)a2 + 19), *((_QWORD *)a2 + 20), (uint64_t)(*((_QWORD *)a2 + 20) - *((_QWORD *)a2 + 19)) >> 3);
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  v11 = *((_QWORD *)a2 + 22);
  v12 = *((_QWORD *)a2 + 23);
  v60 = (char *)this + 176;
  LOBYTE(v61) = 0;
  if (v12 == v11)
  {
LABEL_11:
    *((_QWORD *)this + 25) = 0;
    *((_QWORD *)this + 26) = 0;
    *((_QWORD *)this + 27) = 0;
    std::vector<unsigned long>::__init_with_size[abi:se180100]<unsigned long *,unsigned long *>((_QWORD *)this + 25, *((const void **)a2 + 25), *((_QWORD *)a2 + 26), (uint64_t)(*((_QWORD *)a2 + 26) - *((_QWORD *)a2 + 25)) >> 3);
    *((_QWORD *)this + 28) = 0;
    *((_QWORD *)this + 29) = 0;
    *((_QWORD *)this + 30) = 0;
    std::vector<double>::__init_with_size[abi:se180100]<double *,double *>((_QWORD *)this + 28, *((const void **)a2 + 28), *((_QWORD *)a2 + 29), (uint64_t)(*((_QWORD *)a2 + 29) - *((_QWORD *)a2 + 28)) >> 3);
    *((_QWORD *)this + 31) = 0;
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
    v17 = (__int128 *)*((_QWORD *)a2 + 31);
    v18 = (__int128 *)*((_QWORD *)a2 + 32);
    v19 = (char *)v18 - (char *)v17;
    if (v18 != v17)
    {
      if (v19 < 0)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v20 = (std::string *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v19 >> 5);
      *((_QWORD *)this + 31) = v20;
      *((_QWORD *)this + 32) = v20;
      *((_QWORD *)this + 33) = (char *)v20 + 32 * v21;
      v64 = v20;
      v65 = v20;
      v60 = (char *)this + 264;
      v61 = (char **)&v64;
      v62 = (char **)&v65;
      v22 = v20;
      v63 = 0;
      do
      {
        if (!v22)
          goto LABEL_76;
        if (*((char *)v17 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)v17, *((_QWORD *)v17 + 1));
          v24 = v65;
        }
        else
        {
          v23 = *v17;
          v22->__r_.__value_.__r.__words[2] = *((_QWORD *)v17 + 2);
          *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v23;
          v24 = v22;
        }
        LODWORD(v22[1].__r_.__value_.__l.__data_) = *((_DWORD *)v17 + 6);
        v17 += 2;
        v22 = (std::string *)((char *)v24 + 32);
        v65 = (std::string *)((char *)v24 + 32);
      }
      while (v17 != v18);
      v63 = 1;
      std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,unsigned int>>,std::pair<std::string,unsigned int>*>>::~__exception_guard_exceptions[abi:se180100]((uint64_t)&v60);
      *((_QWORD *)this + 32) = v22;
    }
    *((_QWORD *)this + 34) = 0;
    *((_QWORD *)this + 35) = 0;
    *((_QWORD *)this + 36) = 0;
    std::vector<unsigned long>::__init_with_size[abi:se180100]<unsigned long *,unsigned long *>((_QWORD *)this + 34, *((const void **)a2 + 34), *((_QWORD *)a2 + 35), (uint64_t)(*((_QWORD *)a2 + 35) - *((_QWORD *)a2 + 34)) >> 3);
    *((_QWORD *)this + 37) = 0;
    *((_QWORD *)this + 38) = 0;
    *((_QWORD *)this + 39) = 0;
    std::vector<unsigned long>::__init_with_size[abi:se180100]<unsigned long *,unsigned long *>((_QWORD *)this + 37, *((const void **)a2 + 37), *((_QWORD *)a2 + 38), (uint64_t)(*((_QWORD *)a2 + 38) - *((_QWORD *)a2 + 37)) >> 3);
    *((_QWORD *)this + 40) = *((id *)a2 + 40);
    *((_QWORD *)this + 41) = *((id *)a2 + 41);
    v25 = (uint64_t *)((char *)this + 336);
    *((_OWORD *)this + 21) = 0u;
    *((_OWORD *)this + 22) = 0u;
    *((_DWORD *)this + 92) = *((_DWORD *)a2 + 92);
    std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>((uint64_t)this + 336, *((_QWORD *)a2 + 43));
    v26 = (uint64_t *)*((_QWORD *)a2 + 44);
    if (!v26)
    {
LABEL_61:
      v44 = *((_DWORD *)a2 + 94);
      *((_BYTE *)this + 380) = *((_BYTE *)a2 + 380);
      *((_DWORD *)this + 94) = v44;
      *((_QWORD *)this + 49) = 0;
      *((_QWORD *)this + 50) = 0;
      *((_QWORD *)this + 48) = 0;
      v46 = (_BYTE *)*((_QWORD *)a2 + 48);
      v45 = (_BYTE *)*((_QWORD *)a2 + 49);
      v47 = v45 - v46;
      if (v45 != v46)
      {
        if (0xCCCCCCCCCCCCCCCDLL * (v47 >> 3) >= 0x666666666666667)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v48 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::Column>>(0xCCCCCCCCCCCCCCCDLL * (v47 >> 3));
        *((_QWORD *)this + 48) = v48;
        *((_QWORD *)this + 49) = v48;
        *((_QWORD *)this + 50) = &v48[40 * v49];
        memmove(v48, v46, v47);
        *((_QWORD *)this + 49) = &v48[8 * (v47 >> 3)];
      }
      *((_QWORD *)this + 51) = 0;
      *((_QWORD *)this + 52) = 0;
      *((_QWORD *)this + 53) = 0;
      std::vector<CGRect>::__init_with_size[abi:se180100]<CGRect*,CGRect*>((_QWORD *)this + 51, *((const void **)a2 + 51), *((_QWORD *)a2 + 52), (uint64_t)(*((_QWORD *)a2 + 52) - *((_QWORD *)a2 + 51)) >> 5);
      *((_QWORD *)this + 54) = 0;
      *((_QWORD *)this + 55) = 0;
      *((_QWORD *)this + 56) = 0;
      v51 = (_BYTE *)*((_QWORD *)a2 + 54);
      v50 = (_BYTE *)*((_QWORD *)a2 + 55);
      v52 = v50 - v51;
      if (v50 != v51)
      {
        if (0xAAAAAAAAAAAAAAABLL * (v52 >> 3) > 0xAAAAAAAAAAAAAAALL)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v53 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(0xAAAAAAAAAAAAAAABLL * (v52 >> 3));
        *((_QWORD *)this + 54) = v53;
        *((_QWORD *)this + 55) = v53;
        *((_QWORD *)this + 56) = &v53[24 * v54];
        memmove(v53, v51, v52);
        *((_QWORD *)this + 55) = &v53[8 * (v52 >> 3)];
      }
      *((_QWORD *)this + 57) = 0;
      *((_QWORD *)this + 58) = 0;
      *((_QWORD *)this + 59) = 0;
      v56 = (_BYTE *)*((_QWORD *)a2 + 57);
      v55 = (_BYTE *)*((_QWORD *)a2 + 58);
      v57 = v55 - v56;
      if (v55 != v56)
      {
        if (0xAAAAAAAAAAAAAAABLL * (v57 >> 3) > 0xAAAAAAAAAAAAAAALL)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v58 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(0xAAAAAAAAAAAAAAABLL * (v57 >> 3));
        *((_QWORD *)this + 57) = v58;
        *((_QWORD *)this + 58) = v58;
        *((_QWORD *)this + 59) = &v58[24 * v59];
        memmove(v58, v56, v57);
        *((_QWORD *)this + 58) = &v58[8 * (v57 >> 3)];
      }
      return;
    }
    v27 = (_QWORD *)((char *)this + 352);
    while (1)
    {
      v28 = *((unsigned int *)v26 + 4);
      v29 = *((_QWORD *)this + 43);
      if (v29)
      {
        v30 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
        v30.i16[0] = vaddlv_u8(v30);
        if (v30.u32[0] > 1uLL)
        {
          v2 = *((unsigned int *)v26 + 4);
          if (v29 <= v28)
            v2 = v28 % v29;
        }
        else
        {
          v2 = ((_DWORD)v29 - 1) & v28;
        }
        v31 = *(uint64_t ***)(*v25 + 8 * v2);
        if (v31)
        {
          for (i = *v31; i; i = (uint64_t *)*i)
          {
            v33 = i[1];
            if (v33 == v28)
            {
              if (*((_DWORD *)i + 4) == (_DWORD)v28)
                goto LABEL_60;
            }
            else
            {
              if (v30.u32[0] > 1uLL)
              {
                if (v33 >= v29)
                  v33 %= v29;
              }
              else
              {
                v33 &= v29 - 1;
              }
              if (v33 != v2)
                break;
            }
          }
        }
      }
      v34 = operator new(0x20uLL);
      *v34 = 0;
      v34[1] = v28;
      *((_DWORD *)v34 + 4) = *((_DWORD *)v26 + 4);
      v34[3] = (id)v26[3];
      v35 = (float)(unint64_t)(*((_QWORD *)this + 45) + 1);
      v36 = *((float *)this + 92);
      if (!v29 || (float)(v36 * (float)v29) < v35)
      {
        v37 = (v29 & (v29 - 1)) != 0;
        if (v29 < 3)
          v37 = 1;
        v38 = v37 | (2 * v29);
        v39 = vcvtps_u32_f32(v35 / v36);
        if (v38 <= v39)
          v40 = v39;
        else
          v40 = v38;
        std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>((uint64_t)this + 336, v40);
        v29 = *((_QWORD *)this + 43);
        if ((v29 & (v29 - 1)) != 0)
        {
          if (v29 <= v28)
            v2 = v28 % v29;
          else
            v2 = v28;
        }
        else
        {
          v2 = ((_DWORD)v29 - 1) & v28;
        }
      }
      v41 = *v25;
      v42 = *(_QWORD **)(*v25 + 8 * v2);
      if (v42)
      {
        *v34 = *v42;
      }
      else
      {
        *v34 = *v27;
        *v27 = v34;
        *(_QWORD *)(v41 + 8 * v2) = v27;
        if (!*v34)
          goto LABEL_59;
        v43 = *(_QWORD *)(*v34 + 8);
        if ((v29 & (v29 - 1)) != 0)
        {
          if (v43 >= v29)
            v43 %= v29;
        }
        else
        {
          v43 &= v29 - 1;
        }
        v42 = (_QWORD *)(*v25 + 8 * v43);
      }
      *v42 = v34;
LABEL_59:
      ++*((_QWORD *)this + 45);
LABEL_60:
      v26 = (uint64_t *)*v26;
      if (!v26)
        goto LABEL_61;
    }
  }
  v13 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v11) >> 3);
  if (v13 > 0xAAAAAAAAAAAAAAALL)
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  v14 = std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v13);
  *((_QWORD *)this + 22) = v14;
  *((_QWORD *)this + 23) = v14;
  *((_QWORD *)this + 24) = &v14[3 * v15];
  while (v14)
  {
    *(_OWORD *)v14 = *(_OWORD *)v11;
    v16 = *(_QWORD *)(v11 + 16);
    if (v16)
      CFRetain(*(CFTypeRef *)(v11 + 16));
    v14[2] = v16;
    v14 += 3;
    v11 += 24;
    if (v11 == v12)
    {
      *((_QWORD *)this + 23) = v14;
      goto LABEL_11;
    }
  }
LABEL_76:
  __break(1u);
}

void sub_184CD718C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21)
{
  uint64_t v21;
  void **v22;
  void *v24;
  void *v25;

  v24 = *v22;
  if (*v22)
  {
    *(_QWORD *)(v21 + 64) = v24;
    operator delete(v24);
  }
  v25 = *a21;
  if (*a21)
  {
    *(_QWORD *)(v21 + 40) = v25;
    operator delete(v25);
  }

  _Unwind_Resume(a1);
}

_QWORD *std::vector<unsigned long>::__init_with_size[abi:se180100]<unsigned long *,unsigned long *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long>::__vallocate[abi:se180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184CD7404(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CGRect>::__init_with_size[abi:se180100]<CGRect*,CGRect*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CGRect>::__vallocate[abi:se180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184CD747C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<double>::__init_with_size[abi:se180100]<double *,double *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long>::__vallocate[abi:se180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184CD74F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,unsigned int>>,std::pair<std::string,unsigned int>*>>::~__exception_guard_exceptions[abi:se180100](uint64_t a1)
{
  uint64_t v3;
  uint64_t v4;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(_QWORD **)(a1 + 16);
    v4 = **(_QWORD **)(a1 + 8);
    while (v3 != v4)
    {
      if (*(char *)(v3 - 9) < 0)
        operator delete(*(void **)(v3 - 32));
      v3 -= 32;
    }
  }
  return a1;
}

uint64_t CGPDFTaggedNodeConvertTextRangeToStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  void **v5;
  _QWORD v6[2];
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD v10[2];

  v10[0] = a2;
  v10[1] = a3;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v6[0] = v10;
  v6[1] = 1;
  v5 = (void **)&v7;
  PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(a1, (uint64_t)v6, &v5);
  if (v7 != v8)
  {
    v3 = *v7;
LABEL_4:
    v8 = v7;
    operator delete(v7);
    return v3;
  }
  v3 = -1;
  if (v7)
    goto LABEL_4;
  return v3;
}

void sub_184CD75EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL CGPDFTaggedNodeIsFromTaggedStructure(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 112) != 0;
  return result;
}

uint64_t CGPDFTaggedNodeGetAltText(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 120);
  return result;
}

uint64_t CGPDFTaggedNodeGetActualText(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 128);
  return result;
}

uint64_t CGPDFTaggedNodeGetTitleText(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 136);
  return result;
}

uint64_t CGPDFTaggedNodeGetLanguageText(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 144);
  return result;
}

__CFString *CGPDFTaggedNodeCreateString(_QWORD *a1)
{
  __CFString *Mutable;
  CFIndex Length;
  CFIndex v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  _QWORD v9[3];
  CFRange v10;

  if (!a1)
    return 0;
  if (a1[13])
  {
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    AppendNodeString((uint64_t)a1, Mutable);
    Length = CFStringGetLength(Mutable);
    v4 = Length - 1;
    if (Length >= 1 && CFStringHasSuffix(Mutable, CFSTR(" ")))
    {
      v10.location = v4;
      v10.length = 1;
      CFStringDelete(Mutable, v10);
    }
  }
  else
  {
    CGPDFPageCopyPageLayoutWithCTLD(a1[28], 1);
    v6 = v5;
    v9[2] = v5;
    CGPDFTaggedNodeCacheStringRanges((uint64_t)a1);
    v7 = (uint64_t)(a1[26] - a1[25]) >> 4;
    v9[0] = a1[25];
    v9[1] = v7;
    Mutable = (__CFString *)PageLayout::CreateStringForStringRanges((uint64_t)v6 + 16, (uint64_t)v9);
    if (v6)
      CFRelease(v6);
  }
  return Mutable;
}

void sub_184CD7738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void AppendNodeString(uint64_t a1, __CFString *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *StringForRanges;
  __CFString *v8;
  _QWORD v9[5];
  _QWORD v10[2];

  if (!a1)
  {
    v3 = 0;
LABEL_9:
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZL16AppendNodeStringP15CGPDFTaggedNodeP10__CFString_block_invoke;
    v9[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
    v9[4] = a2;
    CGPDFTaggedNodeEnumerateChildren(a1, v9);
    if (v3 == 200)
      CFStringAppend(a2, CFSTR("\n"));
    return;
  }
  v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 1)
    goto LABEL_9;
  v4 = *(_QWORD *)(a1 + 104);
  if (v4)
  {
    v10[0] = CGPDFNodeGetTextRange(*(_QWORD *)(a1 + 104));
    v10[1] = v5;
    while (*(_DWORD *)v4 != 517)
    {
      v4 = *(_QWORD *)(v4 + 8);
      if (!v4)
      {
        v6 = 0;
        goto LABEL_12;
      }
    }
    v6 = *(_QWORD *)(v4 + 104);
LABEL_12:
    StringForRanges = CGPDFLayoutCreateStringForRanges(v6, (uint64_t)v10, 1);
    if (StringForRanges)
    {
      v8 = StringForRanges;
      CFStringAppend(a2, StringForRanges);
      CFStringAppend(a2, CFSTR(" "));
      CFRelease(v8);
    }
  }
}

void CGPDFTaggedNodeCacheStringRanges(uint64_t a1)
{
  void **v2;
  uint64_t TextRange;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  id v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void **v23[2];
  _QWORD v24[7];
  __int128 v25;
  uint64_t v26;
  __n128 (*v27)(__n128 *, __n128 *);
  uint64_t (*v28)();
  const char *v29;
  __int128 v30;

  if (*(_BYTE *)(a1 + 192))
    return;
  v2 = (void **)(a1 + 200);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a1 + 200);
  *(_BYTE *)(a1 + 192) = 1;
  TextRange = CGPDFTaggedNodeGetTextRange(a1);
  if (TextRange == -1)
    return;
  v5 = v4;
  if (!v4)
    return;
  v6 = TextRange;
  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v8 = (_QWORD *)v7;
  v23[0] = v2;
  v23[1] = (void **)v7;
  if (!*(_BYTE *)(v7 + 24))
  {
    v19 = *(_QWORD *)(v7 + 168);
    v20 = (*(_QWORD *)(v7 + 176) - v19) >> 3;
    if (v20 <= v6)
      std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
    if (v20 <= v5 + v6)
      std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
    v21 = *(_QWORD *)(v19 + 8 * v6);
    v22 = *(_QWORD *)(v19 + 8 * (v5 + v6)) - v21;
    *(_QWORD *)&v25 = v21;
    *((_QWORD *)&v25 + 1) = v22;
    std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:se180100](v23, &v25);
LABEL_28:
    CFRelease(v8);
    return;
  }
  v9 = objc_alloc_init(MEMORY[0x1E0CB3788]);
  if (v5 >= 1)
  {
    v10 = v5 + v6;
    v12 = v8[12];
    v11 = v8[13];
    while (1)
    {
      if (v6 >= (v11 - v12) >> 3)
        goto LABEL_29;
      if (*(_QWORD *)(v12 + 8 * v6))
        break;
LABEL_20:
      if ((uint64_t)++v6 >= v10)
        goto LABEL_21;
    }
    v13 = 0;
    while (1)
    {
      v14 = v8[21];
      if (v6 >= (v8[22] - v14) >> 3)
        std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
      v15 = (_QWORD *)v8[39];
      v16 = (_QWORD *)v8[40];
      if (v15 == v16)
      {
        v18 = (_QWORD *)v8[39];
      }
      else
      {
        v17 = *(_QWORD *)(v14 + 8 * v6) + v13;
        v18 = (_QWORD *)v8[39];
        while (*v18 != v17)
        {
          if (++v18 == v16)
          {
            v18 = (_QWORD *)v8[40];
            break;
          }
        }
      }
      objc_msgSend(v9, "addIndex:", v18 - v15);
      v12 = v8[12];
      v11 = v8[13];
      if (v6 >= (v11 - v12) >> 3)
        break;
      if ((unint64_t)++v13 >= *(_QWORD *)(v12 + 8 * v6))
        goto LABEL_20;
    }
LABEL_29:
    std::vector<unsigned long>::__throw_out_of_range[abi:se180100]();
  }
LABEL_21:
  *(_QWORD *)&v25 = 0;
  *((_QWORD *)&v25 + 1) = &v25;
  v26 = 0x4012000000;
  v27 = __Block_byref_object_copy__37;
  v28 = __Block_byref_object_dispose__38;
  v29 = "";
  v30 = xmmword_185004A10;
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3221225472;
  v24[2] = ___ZNK10PageLayout31ConvertTextRangesToStringRangesIRNSt3__14spanI7CFRangeLm18446744073709551615EEENS1_20back_insert_iteratorINS1_6vectorIS3_NS1_9allocatorIS3_EEEEEEEEvOT_OT0__block_invoke;
  v24[3] = &unk_1E165F018;
  v24[4] = &v25;
  v24[5] = v8 + 2;
  v24[6] = v23;
  objc_msgSend(v9, "enumerateRangesUsingBlock:", v24);
  if (*(_QWORD *)(*((_QWORD *)&v25 + 1) + 48) != -1)
    std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:se180100](v23, (_OWORD *)(*((_QWORD *)&v25 + 1) + 48));
  _Block_object_dispose(&v25, 8);

  if (v8)
    goto LABEL_28;
}

#error "184CD7AE8: call analysis failed (funcsize=19)"

#error "184CD7B60: call analysis failed (funcsize=15)"

void sub_184CD7B6C()
{
  JUMPOUT(0x184CD7B10);
}

uint64_t ___ZL16AppendNodeStringP15CGPDFTaggedNodeP10__CFString_block_invoke(uint64_t a1, uint64_t a2)
{
  AppendNodeString(a2, *(_QWORD *)(a1 + 32));
  return 1;
}

__CFString *CGPDFTaggedNodeCreateStringForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t TextRange;
  uint64_t v8;
  uint64_t v9;
  uint64_t StringForStringRanges;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  BOOL v21;
  void **p_p;
  _QWORD *v24;
  uint64_t v25;
  void *__p;
  _BYTE *v27;
  uint64_t v28;
  const void *v29;
  _QWORD v30[2];

  if (!a1)
    return 0;
  v6 = *(_QWORD *)(a1 + 104);
  if (v6)
  {
    while (*(_DWORD *)v6 != 517)
    {
      v6 = *(_QWORD *)(v6 + 8);
      if (!v6)
      {
        TextRange = CGPDFTaggedNodeGetTextRange(a1);
        v8 = 0;
LABEL_6:
        v9 = 0;
        goto LABEL_19;
      }
    }
    v8 = *(_QWORD *)(v6 + 104);
    TextRange = CGPDFTaggedNodeGetTextRange(a1);
    if (!v8)
      goto LABEL_6;
    v9 = *(_QWORD *)(v8 + 48);
LABEL_19:
    v17 = TextRange + a2;
    v18 = a3 + TextRange + a2;
    if (v18 >= v9)
      v19 = (_BYTE *)v9;
    else
      v19 = (_BYTE *)(a3 + TextRange + a2);
    if (v17 < 0 || v17 >= v9)
    {
      v21 = v18 > 0 && v17 < 1;
      v17 = 0;
      if (v21)
        v20 = v19;
      else
        v20 = 0;
    }
    else
    {
      v20 = &v19[-v17];
    }
    __p = (void *)v17;
    v27 = v20;
    return CGPDFLayoutCreateStringForRanges(v8, (uint64_t)&__p, 1);
  }
  else
  {
    StringForStringRanges = 0;
    v11 = CGPDFTaggedNodeGetTextRange(a1) + a2;
    if (a2 + a3 <= v12)
    {
      v13 = a3;
    }
    else
    {
      v11 = -1;
      v13 = 0;
    }
    v30[0] = v11;
    v30[1] = v13;
    if (v11 != -1 && v13)
    {
      CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
      v15 = v14;
      v28 = 0;
      v29 = v14;
      v16 = (uint64_t)v14 + 16;
      __p = 0;
      v27 = 0;
      v24 = v30;
      v25 = 1;
      p_p = &__p;
      PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>((uint64_t)v14 + 16, (uint64_t)&v24, &p_p);
      v24 = __p;
      v25 = (v27 - (_BYTE *)__p) >> 4;
      StringForStringRanges = PageLayout::CreateStringForStringRanges(v16, (uint64_t)&v24);
      if (__p)
      {
        v27 = __p;
        operator delete(__p);
      }
      if (v15)
        CFRelease(v15);
    }
  }
  return (__CFString *)StringForStringRanges;
}

void sub_184CD7DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p)
    operator delete(__p);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a16);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeCreateStringForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t StringForStringRanges;
  uint64_t PageStringRangeFromStringRange;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  _QWORD *v12;
  _QWORD v13[3];

  if (!a1 || *(_QWORD *)(a1 + 104))
    return 0;
  PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
  StringForStringRanges = 0;
  if (PageStringRangeFromStringRange != -1)
  {
    v8 = v7;
    if (v7)
    {
      v9 = PageStringRangeFromStringRange;
      CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
      v11 = v10;
      v13[2] = v10;
      v12 = operator new(0x10uLL);
      *v12 = v9;
      v12[1] = v8;
      v13[0] = v12;
      v13[1] = 1;
      StringForStringRanges = PageLayout::CreateStringForStringRanges((uint64_t)v11 + 16, (uint64_t)v13);
      operator delete(v12);
      if (v11)
        CFRelease(v11);
    }
  }
  return StringForStringRanges;
}

void sub_184CD7EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  void *v12;

  operator delete(v12);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a12);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeCreateAttributedString(uint64_t a1)
{
  uint64_t AttributedStringForStringRanges;
  const __CFAttributedString *Mutable;
  CFIndex Length;
  CFIndex v4;
  const __CFString *String;
  const void *v6;
  const void *v7;
  uint64_t v8;
  _QWORD v10[3];
  CFRange v11;

  AttributedStringForStringRanges = a1;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 104))
    {
      Mutable = CFAttributedStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      AppendNodeAttributedString(AttributedStringForStringRanges, Mutable);
      Length = CFAttributedStringGetLength(Mutable);
      v4 = Length - 1;
      if (Length >= 1)
      {
        String = CFAttributedStringGetString(Mutable);
        if (CFStringHasSuffix(String, CFSTR(" ")))
        {
          v11.location = v4;
          v11.length = 1;
          CFAttributedStringReplaceString(Mutable, v11, &stru_1E1664C98);
        }
      }
      _updateAttributedStringAttributes((NSAttributedString *)Mutable);
      AttributedStringForStringRanges = objc_claimAutoreleasedReturnValue();

    }
    else
    {
      CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
      v7 = v6;
      v10[2] = v6;
      CGPDFTaggedNodeCacheStringRanges(AttributedStringForStringRanges);
      v8 = (uint64_t)(*(_QWORD *)(AttributedStringForStringRanges + 208)
                   - *(_QWORD *)(AttributedStringForStringRanges + 200)) >> 4;
      v10[0] = *(_QWORD *)(AttributedStringForStringRanges + 200);
      v10[1] = v8;
      AttributedStringForStringRanges = (uint64_t)PageLayout::CreateAttributedStringForStringRanges((uint64_t)v7 + 16, (uint64_t)v10);
      if (v7)
        CFRelease(v7);
    }
  }
  return AttributedStringForStringRanges;
}

void sub_184CD7FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void AppendNodeAttributedString(uint64_t a1, const __CFAttributedString *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFAttributedString *AttributedStringForRanges;
  const __CFAttributedString *v8;
  _QWORD v9[5];
  _QWORD v10[2];
  CFRange v11;
  CFRange v12;
  CFRange v13;

  if (!a1)
  {
    v3 = 0;
LABEL_9:
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZL26AppendNodeAttributedStringP15CGPDFTaggedNodeP20__CFAttributedString_block_invoke;
    v9[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
    v9[4] = a2;
    CGPDFTaggedNodeEnumerateChildren(a1, v9);
    if (v3 == 200)
    {
      v11.location = CFAttributedStringGetLength(a2);
      v11.length = 0;
      CFAttributedStringReplaceString(a2, v11, CFSTR("\n"));
    }
    return;
  }
  v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 1)
    goto LABEL_9;
  v4 = *(_QWORD *)(a1 + 104);
  if (v4)
  {
    v10[0] = CGPDFNodeGetTextRange(*(_QWORD *)(a1 + 104));
    v10[1] = v5;
    while (*(_DWORD *)v4 != 517)
    {
      v4 = *(_QWORD *)(v4 + 8);
      if (!v4)
      {
        v6 = 0;
        goto LABEL_12;
      }
    }
    v6 = *(_QWORD *)(v4 + 104);
LABEL_12:
    AttributedStringForRanges = CGPDFLayoutCreateAttributedStringForRanges(v6, (uint64_t)v10, 1);
    if (AttributedStringForRanges)
    {
      v8 = AttributedStringForRanges;
      v12.location = CFAttributedStringGetLength(a2);
      v12.length = 0;
      CFAttributedStringReplaceAttributedString(a2, v12, v8);
      v13.location = CFAttributedStringGetLength(a2);
      v13.length = 0;
      CFAttributedStringReplaceString(a2, v13, CFSTR(" "));
      CFRelease(v8);
    }
  }
}

id _updateAttributedStringAttributes(NSAttributedString *a1)
{
  NSAttributedString *v1;
  void *v2;
  uint64_t v3;
  id v4;
  _QWORD v6[4];
  id v7;

  v1 = a1;
  v2 = (void *)-[NSAttributedString mutableCopy](v1, "mutableCopy");
  v3 = objc_msgSend(v2, "length");
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL33_updateAttributedStringAttributesP18NSAttributedString_block_invoke;
  v6[3] = &unk_1E165EF30;
  v4 = v2;
  v7 = v4;
  objc_msgSend(v4, "enumerateAttributesInRange:options:usingBlock:", 0, v3, 0, v6);

  return v4;
}

void sub_184CD81B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void ___ZL33_updateAttributedStringAttributesP18NSAttributedString_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  BOOL v13;
  pthread_mutex_t *v14;
  uint64_t Font;
  PageLayout *v16;
  unint64_t FontDescriptor;
  NSString *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  void *CTFont;
  _QWORD *v26;
  void *v27;
  void *v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;

  v7 = a2;
  v8 = (void *)objc_msgSend(v7, "mutableCopy");
  objc_msgSend(v7, "objectForKey:", kCGPDFTextStyleFont);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "objectForKey:", kCGPDFTextStyleFontSize);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v9)
    goto LABEL_14;
  objc_opt_self();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_opt_isKindOfClass() & 1) == 0 || objc_msgSend(v9, "length") != 8 || !v28)
  {
LABEL_13:

    goto LABEL_14;
  }
  objc_opt_self();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_13;
  }
  v12 = objc_msgSend(v28, "length");

  v13 = v12 == 8;
  v14 = &w16_cacheColorLock;
  if (v13)
  {
    v30 = 0;
    objc_msgSend(v9, "getBytes:length:", &v30, 8);
    Font = CGPDFFontGetFont(v30);
    if (Font)
    {
      v16 = (PageLayout *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)(Font + 16) + 152))(*(_QWORD *)(Font + 112));
      if (v16)
      {
        FontDescriptor = CGPDFFontGetFontDescriptor(v30);
        if (FontDescriptor)
          v18 = (NSString *)*(unsigned int *)(FontDescriptor + 40);
        else
          v18 = 0;
        v29 = 0.0;
        objc_msgSend(v28, "getBytes:length:", &v29, 8);
        CTFont = (void *)PageLayout::CreateCTFont(v16, v18, v29);
        if (CTFont)
        {
          v31 = 0;
          v32 = &v31;
          v33 = 0x2020000000;
          v26 = (_QWORD *)getkCTFontAttributeNameSymbolLoc(void)::ptr;
          v34 = getkCTFontAttributeNameSymbolLoc(void)::ptr;
          if (!getkCTFontAttributeNameSymbolLoc(void)::ptr)
          {
            v27 = (void *)CoreTextLibrary();
            v26 = dlsym(v27, "kCTFontAttributeName");
            v32[3] = (uint64_t)v26;
            getkCTFontAttributeNameSymbolLoc(void)::ptr = (uint64_t)v26;
          }
          _Block_object_dispose(&v31, 8);
          if (!v26)
            goto LABEL_31;
          objc_msgSend(v8, "setObject:forKey:", CTFont, *v26);

          v14 = &w16_cacheColorLock;
        }
        objc_msgSend(v8, "removeObjectForKey:", *(_QWORD *)&v14[19].__opaque[8]);
        objc_msgSend(v8, "removeObjectForKey:", kCGPDFTextStyleFontSize);
      }

    }
  }
LABEL_14:
  objc_msgSend(v7, "objectForKey:", kCGPDFTextStyleBaseLineOffset);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v19)
    goto LABEL_22;
  objc_opt_self();
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_22;
  }
  v21 = objc_msgSend(v19, "length");

  if (v21 != 8)
  {
LABEL_22:
    objc_msgSend(*(id *)(a1 + 32), "setAttributes:range:", v8, a3, a4);

    return;
  }
  v30 = 0;
  objc_msgSend(v19, "getBytes:length:", &v30, 8);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *(double *)&v30);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = 0;
  v32 = &v31;
  v33 = 0x2020000000;
  v23 = (_QWORD *)getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  v34 = getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  if (!getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr)
  {
    v24 = (void *)CoreTextLibrary();
    v23 = dlsym(v24, "kCTBaselineOffsetAttributeName");
    v32[3] = (uint64_t)v23;
    getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr = (uint64_t)v23;
  }
  _Block_object_dispose(&v31, 8);
  if (v23)
  {
    objc_msgSend(v8, "setObject:forKey:", v22, *v23);

    objc_msgSend(v8, "removeObjectForKey:", kCGPDFTextStyleBaseLineOffset);
    goto LABEL_22;
  }
LABEL_31:
  dlerror();
  abort_report_np();
  __break(1u);
}

void sub_184CD857C(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t CoreTextLibrary()
{
  uint64_t v0;
  void *v2;

  if (CoreTextLibraryCore(char **)::frameworkLibrary)
    return CoreTextLibraryCore(char **)::frameworkLibrary;
  CoreTextLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  v0 = CoreTextLibraryCore(char **)::frameworkLibrary;
  if (!CoreTextLibraryCore(char **)::frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

{
  uint64_t v0;
  void *v2;

  if (CoreTextLibraryCore_frameworkLibrary)
    return CoreTextLibraryCore_frameworkLibrary;
  CoreTextLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = CoreTextLibraryCore_frameworkLibrary;
  if (!CoreTextLibraryCore_frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

uint64_t ___ZL26AppendNodeAttributedStringP15CGPDFTaggedNodeP20__CFAttributedString_block_invoke(uint64_t a1, uint64_t a2)
{
  AppendNodeAttributedString(a2, *(_QWORD *)(a1 + 32));
  return 1;
}

uint64_t CGPDFTaggedNodeCreateAttributedStringForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t TextRange;
  uint64_t v8;
  uint64_t v9;
  uint64_t AttributedStringForStringRanges;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  BOOL v22;
  NSAttributedString *AttributedStringForRanges;
  void **p_p;
  _QWORD *v26;
  uint64_t v27;
  void *__p;
  _BYTE *v29;
  uint64_t v30;
  const void *v31;
  _QWORD v32[2];

  if (!a1)
    return 0;
  v6 = *(_QWORD *)(a1 + 104);
  if (v6)
  {
    while (*(_DWORD *)v6 != 517)
    {
      v6 = *(_QWORD *)(v6 + 8);
      if (!v6)
      {
        TextRange = CGPDFTaggedNodeGetTextRange(a1);
        v8 = 0;
LABEL_6:
        v9 = 0;
        goto LABEL_21;
      }
    }
    v8 = *(_QWORD *)(v6 + 104);
    TextRange = CGPDFTaggedNodeGetTextRange(a1);
    if (!v8)
      goto LABEL_6;
    v9 = *(_QWORD *)(v8 + 48);
LABEL_21:
    v18 = TextRange + a2;
    v19 = a3 + TextRange + a2;
    if (v19 >= v9)
      v20 = (_BYTE *)v9;
    else
      v20 = (_BYTE *)(a3 + TextRange + a2);
    if (v18 < 0 || v18 >= v9)
    {
      v22 = v19 > 0 && v18 < 1;
      v18 = 0;
      if (v22)
        v21 = v20;
      else
        v21 = 0;
    }
    else
    {
      v21 = &v20[-v18];
    }
    __p = (void *)v18;
    v29 = v21;
    AttributedStringForRanges = (NSAttributedString *)CGPDFLayoutCreateAttributedStringForRanges(v8, (uint64_t)&__p, 1);
    _updateAttributedStringAttributes(AttributedStringForRanges);
    AttributedStringForStringRanges = objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v11 = CGPDFTaggedNodeGetTextRange(a1);
    AttributedStringForStringRanges = 0;
    if (a2 + a3 > v12)
      v13 = -1;
    else
      v13 = v11 + a2;
    if (a2 + a3 <= v12)
      v14 = a3;
    else
      v14 = 0;
    v32[0] = v13;
    v32[1] = v14;
    if ((unint64_t)(v13 + 1) >= 2)
    {
      CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
      v16 = v15;
      v30 = 0;
      v31 = v15;
      v17 = (uint64_t)v15 + 16;
      __p = 0;
      v29 = 0;
      v26 = v32;
      v27 = 1;
      p_p = &__p;
      PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>((uint64_t)v15 + 16, (uint64_t)&v26, &p_p);
      v26 = __p;
      v27 = (v29 - (_BYTE *)__p) >> 4;
      AttributedStringForStringRanges = (uint64_t)PageLayout::CreateAttributedStringForStringRanges(v17, (uint64_t)&v26);
      if (__p)
      {
        v29 = __p;
        operator delete(__p);
      }
      if (v16)
        CFRelease(v16);
    }
  }
  return AttributedStringForStringRanges;
}

void sub_184CD8884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p)
    operator delete(__p);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a16);
  _Unwind_Resume(a1);
}

id CGPDFTaggedNodeCreateAttributedStringForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id AttributedStringForStringRanges;
  uint64_t PageStringRangeFromStringRange;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  _QWORD *v12;
  _QWORD v13[3];

  if (!a1)
    return 0;
  if (*(_QWORD *)(a1 + 104))
    return 0;
  PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
  if (PageStringRangeFromStringRange == -1)
    return 0;
  v8 = PageStringRangeFromStringRange;
  v9 = v7;
  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v11 = v10;
  v13[2] = v10;
  v12 = operator new(0x10uLL);
  *v12 = v8;
  v12[1] = v9;
  v13[0] = v12;
  v13[1] = 1;
  AttributedStringForStringRanges = PageLayout::CreateAttributedStringForStringRanges((uint64_t)v11 + 16, (uint64_t)v13);
  operator delete(v12);
  if (v11)
    CFRelease(v11);
  return AttributedStringForStringRanges;
}

void sub_184CD8968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  void *v12;

  operator delete(v12);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a12);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineRanges(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t TextRange;
  uint64_t v6;
  uint64_t v7;
  id v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 104);
    if (v2)
    {
      while (*(_DWORD *)v2 != 517)
      {
        v2 = *(_QWORD *)(v2 + 8);
        if (!v2)
        {
          v3 = 0;
          goto LABEL_8;
        }
      }
      v3 = *(_QWORD *)(v2 + 104);
LABEL_8:
      TextRange = CGPDFTaggedNodeGetTextRange(a1);
      v7 = v6;
      v8 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
      v14 = 0;
      CGPDFLayoutGetLineRangesForTextRange(v3, TextRange, v7, 0, &v14);
      if (v14 >= 1)
      {
        std::vector<CFRange>::vector(&v12, v14);
        CGPDFLayoutGetLineRangesForTextRange(v3, TextRange, v7, (uint64_t)v12, &v14);
        v9 = v12;
        v10 = v13;
        if (v12 != v13)
        {
          do
          {
            objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithRange:", *v9, v9[1]);
            v11 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "addObject:", v11);

            v9 += 2;
          }
          while (v9 != v10);
          v9 = v12;
        }
        if (v9)
        {
          v13 = v9;
          operator delete(v9);
        }
      }
    }
    else
    {
      CGPDFTaggedNodeGetTextRange(a1);
      CGPDFTaggedNodeCreateLineRangesForTextRange(a1, 0, v4);
    }
  }
}

void sub_184CD8AD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  void *v10;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

char *std::vector<CFRange>::vector(_QWORD *a1, unint64_t a2)
{
  char *result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = std::vector<CFRange>::__vallocate[abi:se180100](a1, a2);
  v5 = (_QWORD *)a1[1];
  v6 = &v5[2 * a2];
  v7 = 16 * a2;
  while (v5)
  {
    *v5 = 0;
    v5[1] = 0;
    v5 += 2;
    v7 -= 16;
    if (!v7)
    {
      a1[1] = v6;
      return (char *)a1;
    }
  }
  __break(1u);
  return result;
}

void sub_184CD8B68(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CGPDFTaggedNodeCreateLineRangesForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t TextRange;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  id v19;
  PageLayout *v20;
  PageLayout *v21;
  unint64_t LineIndex;
  unint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  BOOL v36;
  id v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  _QWORD *v43;
  _QWORD *v44;
  uint64_t v45;

  if (!a1)
    return;
  v6 = *(_QWORD *)(a1 + 104);
  if (v6)
  {
    while (*(_DWORD *)v6 != 517)
    {
      v6 = *(_QWORD *)(v6 + 8);
      if (!v6)
      {
        TextRange = CGPDFTaggedNodeGetTextRange(a1);
        v9 = v8;
        v10 = 0;
LABEL_6:
        v11 = 0;
        goto LABEL_28;
      }
    }
    v10 = *(_QWORD *)(v6 + 104);
    TextRange = CGPDFTaggedNodeGetTextRange(a1);
    v9 = v32;
    if (!v10)
      goto LABEL_6;
    v11 = *(_QWORD *)(v10 + 48);
LABEL_28:
    v33 = TextRange + a2;
    if (v33 + a3 >= v11)
      v34 = v11;
    else
      v34 = v33 + a3;
    if (v33 < 0 || v33 >= v11)
    {
      v36 = v33 + a3 > 0 && v33 < 1;
      v33 = 0;
      if (v36)
        v35 = v34;
      else
        v35 = 0;
    }
    else
    {
      v35 = v34 - v33;
    }
    v37 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v45 = 0;
    CGPDFLayoutGetLineRangesForTextRange(v10, v33, v35, 0, &v45);
    if (v45 >= 1)
    {
      std::vector<CFRange>::vector(&v43, v45);
      CGPDFLayoutGetLineRangesForTextRange(v10, TextRange, v9, (uint64_t)v43, &v45);
      v38 = v43;
      v39 = v44;
      if (v43 != v44)
      {
        do
        {
          objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithRange:", *v38, v38[1]);
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v37, "addObject:", v40);

          v38 += 2;
        }
        while (v38 != v39);
        v38 = v43;
      }
      if (v38)
      {
        v44 = v38;
        operator delete(v38);
      }
    }
    return;
  }
  v12 = CGPDFTaggedNodeGetTextRange(a1);
  if (a2 + a3 > v13)
    v14 = -1;
  else
    v14 = v12 + a2;
  if (a2 + a3 <= v13)
    v15 = a3;
  else
    v15 = 0;
  if (v14 == -1)
    return;
  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v17 = (_QWORD *)v16;
  v43 = (_QWORD *)v16;
  v18 = CGPDFTaggedNodeGetTextRange(a1);
  v19 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v21 = (PageLayout *)v17[6];
  v20 = (PageLayout *)v17[7];
  LineIndex = PageLayout::getLineIndex(v21, v20, v14);
  if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) <= LineIndex)
  {
LABEL_56:
    __break(1u);
    return;
  }
  v23 = LineIndex;
  v24 = (uint64_t *)((char *)v21 + 72 * LineIndex);
  v26 = *v24;
  v25 = v24[1];
  v27 = v15 + v14;
  if (v27 > v25 + v26)
  {
    v28 = 72 * LineIndex;
    v29 = -1;
    while (1)
    {
      if (v23 != v29)
      {
        if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) > v23)
        {
          v30 = v25;
        }
        else
        {
          v26 = -1;
          v30 = 0;
        }
        objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithRange:", v26 - v18, v30, v43);
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v19, "addObject:", v31);

        v21 = (PageLayout *)v17[6];
        v20 = (PageLayout *)v17[7];
        v29 = v23;
      }
      if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) <= ++v23)
        goto LABEL_56;
      v26 = *(_QWORD *)((char *)v21 + v28 + 72);
      v25 = *(_QWORD *)((char *)v21 + v28 + 80);
      v28 += 72;
      if (v27 <= v25 + v26)
        goto LABEL_47;
    }
  }
  v29 = -1;
LABEL_47:
  if (v29 == v23)
  {
    if (!v17)
      return;
  }
  else
  {
    if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) > v23)
    {
      v41 = v25;
    }
    else
    {
      v26 = -1;
      v41 = 0;
    }
    objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithRange:", v26 - v18, v41, v43);
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "addObject:", v42);

  }
  CFRelease(v17);
}

void sub_184CD8ED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  void *v10;
  void *v11;

  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)&__p);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineStringRanges(uint64_t a1)
{
  uint64_t v2;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 104))
    {
      objc_opt_new();
    }
    else
    {
      CGPDFTaggedNodeGetStringRange(a1);
      CGPDFTaggedNodeCreateLineStringRangesForStringRange(a1, 0, v2);
    }
  }
}

uint64_t CGPDFTaggedNodeGetStringRange(uint64_t a1)
{
  uint64_t v2;
  uint64_t v4;
  const void *v5;
  const void *v6;
  void **v7;
  _QWORD v8[2];
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  const void *v12;
  _QWORD v13[2];

  if (!a1 || *(_QWORD *)(a1 + 104))
    return 0;
  v13[0] = CGPDFTaggedNodeGetTextRange(a1);
  v13[1] = v4;
  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v6 = v5;
  v11 = 0;
  v12 = v5;
  v9 = 0;
  v10 = 0;
  v8[0] = v13;
  v8[1] = 1;
  v7 = (void **)&v9;
  PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>((uint64_t)v5 + 16, (uint64_t)v8, &v7);
  if (v9 == v10)
  {
    v2 = -1;
    if (!v9)
      goto LABEL_9;
  }
  else
  {
    v2 = *v9;
  }
  v10 = v9;
  operator delete(v9);
LABEL_9:
  if (v6)
    CFRelease(v6);
  return v2;
}

void sub_184CD9078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p)
    operator delete(__p);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a16);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineStringRangesForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t PageStringRangeFromStringRange;
  uint64_t v5;
  int64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  PageLayout *v15;
  PageLayout *v16;
  unint64_t LineIndex;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[4];
  uint64_t v24;
  id v25;
  _QWORD v26[2];
  _BYTE v27[480];
  _QWORD *v28;

  if (a1)
  {
    if (!*(_QWORD *)(a1 + 104))
    {
      PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
      if (PageStringRangeFromStringRange != -1)
      {
        v6 = PageStringRangeFromStringRange;
        v7 = v5;
        CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
        v9 = v8;
        v28 = v8;
        v10 = v8 + 2;
        PageLayout::PageLayout((PageLayout *)v27, (const PageLayout *)(v8 + 2));
        v11 = CGPDFTaggedNodeConvertStringRangeToTextRange((uint64_t)v27, v6, v7);
        v13 = v12;
        PageLayout::~PageLayout((PageLayout *)v27);
        if (v11 != -1)
        {
          v26[0] = CGPDFTaggedNodeGetStringRange(a1);
          v26[1] = v14;
          v24 = -1;
          v25 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
          v23[0] = &v24;
          v23[1] = v10;
          v23[2] = &v25;
          v23[3] = v26;
          v15 = (PageLayout *)v9[6];
          v16 = (PageLayout *)v9[7];
          LineIndex = PageLayout::getLineIndex(v15, v16, v11);
          if (0x8E38E38E38E38E39 * ((v16 - v15) >> 3) <= LineIndex)
          {
LABEL_14:
            __break(1u);
            return;
          }
          v18 = LineIndex;
          v19 = v13 + v11;
          if (v19 > *((_QWORD *)v15 + 9 * LineIndex + 1) + *((_QWORD *)v15 + 9 * LineIndex))
          {
            v20 = 72 * LineIndex;
            do
            {
              CGPDFTaggedNodeCreateLineStringRangesForStringRange::$_0::operator()<CFRange>((uint64_t)v23, v18++);
              v21 = v9[6];
              if (0x8E38E38E38E38E39 * ((v9[7] - v21) >> 3) <= v18)
                goto LABEL_14;
              v22 = *(_QWORD *)(v21 + v20 + 80) + *(_QWORD *)(v21 + v20 + 72);
              v20 += 72;
            }
            while (v19 > v22);
          }
          CGPDFTaggedNodeCreateLineStringRangesForStringRange::$_0::operator()<CFRange>((uint64_t)v23, v18);

LABEL_13:
          CFRelease(v9);
          return;
        }
        if (v9)
          goto LABEL_13;
      }
    }
  }
}

void sub_184CD926C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  uint64_t v15;

  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v15 - 72));
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineStringRangesForStringRange::$_0::operator()<CFRange>(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  _BYTE v13[480];

  if (**(_QWORD **)a1 != a2)
  {
    **(_QWORD **)a1 = a2;
    PageLayout::PageLayout((PageLayout *)v13, *(const PageLayout **)(a1 + 8));
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
    if (0x8E38E38E38E38E39 * ((*(_QWORD *)(*(_QWORD *)(a1 + 8) + 40) - v4) >> 3) <= a2)
    {
      v7 = 0;
      v6 = -1;
    }
    else
    {
      v5 = (uint64_t *)(v4 + 72 * a2);
      v6 = *v5;
      v7 = v5[1];
    }
    v8 = CGPDFTaggedNodeConvertTextRangeToStringRange((uint64_t)v13, v6, v7);
    v10 = v9;
    PageLayout::~PageLayout((PageLayout *)v13);
    v11 = **(void ***)(a1 + 16);
    objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithRange:", v8 - **(_QWORD **)(a1 + 24), v10);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "addObject:", v12);

  }
}

void sub_184CD939C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL CGPDFTaggedNodeIsImageFigure(uint64_t a1)
{
  _BOOL8 v1;
  _DWORD *v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  if (!a1)
    return 0;
  if (*(_BYTE *)(a1 + 112))
    return *(_BYTE *)(a1 + 113) != 0;
  v2 = *(_DWORD **)(a1 + 104);
  if (v2 && *v2 == 257)
    return 1;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __CGPDFTaggedNodeIsImageFigure_block_invoke;
  v4[3] = &unk_1E165EE70;
  v4[4] = &v5;
  CGPDFTaggedNodeEnumerateChildren(a1, v4);
  v1 = *((_BYTE *)v6 + 24) != 0;
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_184CD948C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeGetParent(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 88);
  return result;
}

uint64_t CGPDFTaggedNodeGetNodeContainingTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t TextRange;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[7];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  if (!a1)
    return 0;
  TextRange = CGPDFTaggedNodeGetTextRange(a1);
  v8 = 0;
  if (a2 >= TextRange && a2 < TextRange + v7 && a2 + a3 > TextRange && a2 + a3 <= TextRange + v7)
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2020000000;
    v14 = a1;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = __CGPDFTaggedNodeGetNodeContainingTextRange_block_invoke;
    v10[3] = &unk_1E165EEB8;
    v10[5] = a2;
    v10[6] = a3;
    v10[4] = &v11;
    CGPDFTaggedNodeEnumerateChildren(a1, v10);
    v8 = v12[3];
    _Block_object_dispose(&v11, 8);
  }
  return v8;
}

void sub_184CD95D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeGetNodeContainingPoint(uint64_t a1, int a2, char a3, double a4, double a5, double a6)
{
  uint64_t v10;
  double v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  uint64_t v16;
  _QWORD v18[8];
  int v19;
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  CGRect v25;
  CGRect v26;

  if (!a1)
    return 0;
  v10 = a1;
  v11 = a6 >= 0.0 ? a6 : 0.0;
  v12 = a5 - v11 * 0.5;
  v26.origin.x = CGPDFTaggedNodeGetBounds(a1);
  v26.origin.y = v13;
  v26.size.width = v14;
  v26.size.height = v15;
  v25.origin.x = a4 - v11 * 0.5;
  v25.origin.y = v12;
  v25.size.width = v11;
  v25.size.height = v11;
  if (!CGRectIntersectsRect(v25, v26))
    return 0;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2020000000;
  v24 = v10;
  if (a2 && *(_DWORD *)(v10 + 16) != a2)
    v10 = 0;
  if ((a3 & 1) == 0 && v10 && *(_DWORD *)(v10 + 16) == 700)
    v10 = 0;
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3221225472;
  v18[2] = __CGPDFTaggedNodeGetNodeContainingPoint_block_invoke;
  v18[3] = &unk_1E165EEE0;
  v19 = a2;
  *(double *)&v18[5] = a4;
  *(double *)&v18[6] = a5;
  *(double *)&v18[7] = v11;
  v20 = a3;
  v18[4] = &v21;
  CGPDFTaggedNodeEnumerateChildren(v10, v18);
  v16 = v22[3];
  _Block_object_dispose(&v21, 8);
  return v16;
}

void sub_184CD9778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeGetListStyle(uint64_t a1)
{
  _QWORD *ChildTaggedNodeOfType;
  __CFString *String;
  const __CFString *v3;
  uint64_t v4;
  SInt32 IntValue;

  if (!a1)
    return 0;
  while (*(_DWORD *)(a1 + 16) != 301)
  {
    a1 = *(_QWORD *)(a1 + 88);
    if (!a1)
      return 0;
  }
  ChildTaggedNodeOfType = (_QWORD *)GetChildTaggedNodeOfType(a1, 302);
  if (!ChildTaggedNodeOfType)
    return 0;
  String = CGPDFTaggedNodeCreateString(ChildTaggedNodeOfType);
  if (!String)
    return 0;
  v3 = String;
  if (CFStringHasPrefix(String, CFSTR(""))
    || CFStringHasPrefix(v3, CFSTR(""))
    || CFStringHasPrefix(v3, CFSTR(""))
    || CFStringHasPrefix(v3, CFSTR(""))
    || CFStringHasPrefix(v3, CFSTR(""))
    || CFStringHasPrefix(v3, CFSTR(""))
    || CFStringHasPrefix(v3, CFSTR("")))
  {
    v4 = 257;
  }
  else
  {
    IntValue = CFStringGetIntValue(v3);
    v4 = 0;
    if (IntValue != 0x80000000 && IntValue && IntValue != 0x7FFFFFFF)
      v4 = 513;
  }
  CFRelease(v3);
  return v4;
}

uint64_t GetChildTaggedNodeOfType(uint64_t a1, int a2)
{
  uint64_t v2;
  _QWORD v4[5];
  int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a1;
  if (a1 && *(_DWORD *)(a1 + 16) != a2)
  {
    v6 = 0;
    v7 = &v6;
    v8 = 0x2020000000;
    v9 = 0;
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = ___ZL24GetChildTaggedNodeOfTypeP15CGPDFTaggedNode19CGPDFTaggedNodeType_block_invoke;
    v4[3] = &unk_1E165EF70;
    v4[4] = &v6;
    v5 = a2;
    CGPDFTaggedNodeEnumerateChildren(a1, v4);
    v2 = v7[3];
    _Block_object_dispose(&v6, 8);
  }
  return v2;
}

void sub_184CD999C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL24GetChildTaggedNodeOfTypeP15CGPDFTaggedNode19CGPDFTaggedNodeType_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = GetChildTaggedNodeOfType(a2, *(unsigned int *)(a1 + 40));
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetTableRowCount(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    while (*(_DWORD *)(result + 16) != 400)
    {
      result = *(_QWORD *)(result + 88);
      if (!result)
        return result;
    }
    v1 = 0;
    GetTaggedNodeCountForType(result, 401, &v1);
    return v1;
  }
  return result;
}

void GetTaggedNodeCountForType(uint64_t a1, int a2, _QWORD *a3)
{
  _QWORD v3[5];
  int v4;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == a2)
    {
      ++*a3;
    }
    else
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 3221225472;
      v3[2] = ___ZL25GetTaggedNodeCountForTypeP15CGPDFTaggedNode19CGPDFTaggedNodeTypePm_block_invoke;
      v3[3] = &__block_descriptor_44_e12_B24__0_v8Q16l;
      v4 = a2;
      v3[4] = a3;
      CGPDFTaggedNodeEnumerateChildren(a1, v3);
    }
  }
}

uint64_t ___ZL25GetTaggedNodeCountForTypeP15CGPDFTaggedNode19CGPDFTaggedNodeTypePm_block_invoke(uint64_t a1, uint64_t a2)
{
  GetTaggedNodeCountForType(a2, *(unsigned int *)(a1 + 40), *(_QWORD *)(a1 + 32));
  return 1;
}

uint64_t CGPDFTaggedNodeGetTableColumnCount(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    while (*(_DWORD *)(result + 16) != 400)
    {
      result = *(_QWORD *)(result + 88);
      if (!result)
        return result;
    }
    v1 = 0;
    GetColumnCount(result, &v1);
    return v1;
  }
  return result;
}

void GetColumnCount(uint64_t a1, _QWORD *a2)
{
  _QWORD v4[5];
  uint64_t v5;
  uint64_t v6;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 401)
    {
      v6 = 0;
      GetTaggedNodeCountForType(a1, 403, &v6);
      v5 = 0;
      GetTaggedNodeCountForType(a1, 402, &v5);
      if ((unint64_t)(v5 + v6) > *a2)
        *a2 = v5 + v6;
    }
    else
    {
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 3221225472;
      v4[2] = ___ZL14GetColumnCountP15CGPDFTaggedNodePm_block_invoke;
      v4[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
      v4[4] = a2;
      CGPDFTaggedNodeEnumerateChildren(a1, v4);
    }
  }
}

uint64_t ___ZL14GetColumnCountP15CGPDFTaggedNodePm_block_invoke(uint64_t a1, uint64_t a2)
{
  GetColumnCount(a2, *(_QWORD *)(a1 + 32));
  return 1;
}

uint64_t CGPDFTaggedNodeGetTableCellRowSpan(uint64_t a1)
{
  uint64_t v2;
  __int128 *v3;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  if (!a1)
    return 0x7FFFFFFFFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    v3 = &CPRangeNull;
    while (1)
    {
      if (*(_DWORD *)v2 == 1538)
      {
        v4 = *(_DWORD **)(v2 + 104);
        if (v4)
        {
          if (*v4 == 2)
            break;
        }
      }
      v2 = *(_QWORD *)(v2 + 8);
      if (!v2)
        return *(_QWORD *)v3;
    }
    v3 = (__int128 *)(v4 + 2);
    return *(_QWORD *)v3;
  }
  if ((*(_DWORD *)(a1 + 16) - 401) > 5)
    return 0x7FFFFFFFFFFFFFFFLL;
  v5 = *(_QWORD *)(a1 + 88);
  if (!v5)
    return 0x7FFFFFFFFFFFFFFFLL;
  while (*(_DWORD *)(v5 + 16) != 400)
  {
    v5 = *(_QWORD *)(v5 + 88);
    if (!v5)
      return 0x7FFFFFFFFFFFFFFFLL;
  }
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __CGPDFTaggedNodeGetTableCellRowSpan_block_invoke;
  v9[3] = &unk_1E165EF08;
  v9[4] = &v10;
  v9[5] = a1;
  CGPDFTaggedNodeEnumerateChildren(v5, v9);
  v8 = 0;
  CountRowElements(a1, 0, &v8);
  v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

void sub_184CD9D44(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t CountRowElements(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  _BOOL8 v5;
  int v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  if (a1)
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (v4 == 400)
      return 0;
  }
  else
  {
    v4 = 0;
  }
  if (a1 == a2)
    return 1;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZL16CountRowElementsP15CGPDFTaggedNodeS0_Pm_block_invoke;
  v8[3] = &unk_1E165EEB8;
  v8[4] = &v9;
  v8[5] = a2;
  v8[6] = a3;
  CGPDFTaggedNodeEnumerateChildren(a1, v8);
  v6 = *((unsigned __int8 *)v10 + 24);
  if (v4 == 401 && !*((_BYTE *)v10 + 24))
    ++*a3;
  v5 = v6 != 0;
  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_184CD9E68(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL16CountRowElementsP15CGPDFTaggedNodeS0_Pm_block_invoke(_QWORD *a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = CountRowElements(a2, a1[5], a1[6]);
  return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetTableCellColumnSpan(uint64_t a1)
{
  uint64_t v2;
  __int128 *v3;
  _DWORD *v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t ChildTaggedNodeOfType;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
    return 0x7FFFFFFFFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 104);
  if (v2)
  {
    v3 = &CPRangeNull;
    while (1)
    {
      if (*(_DWORD *)v2 == 1538)
      {
        v4 = *(_DWORD **)(v2 + 104);
        if (v4)
        {
          if (*v4 == 2)
            break;
        }
      }
      v2 = *(_QWORD *)(v2 + 8);
      if (!v2)
        return *(_QWORD *)v3;
    }
    v3 = (__int128 *)(v4 + 6);
    return *(_QWORD *)v3;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 16);
    if ((v6 - 401) > 5)
      return 0x7FFFFFFFFFFFFFFFLL;
    v7 = *(_QWORD *)(a1 + 88);
    if (!v7)
      return 0x7FFFFFFFFFFFFFFFLL;
    while (*(_DWORD *)(v7 + 16) != 400)
    {
      v7 = *(_QWORD *)(v7 + 88);
      if (!v7)
        return 0x7FFFFFFFFFFFFFFFLL;
    }
    if ((v6 - 401) <= 5 && ((1 << (v6 + 111)) & 0x39) != 0)
    {
      v11 = 0;
      ChildTaggedNodeOfType = GetChildTaggedNodeOfType(a1, 401);
      if (!ChildTaggedNodeOfType)
        ChildTaggedNodeOfType = a1;
      CountColumnElements(ChildTaggedNodeOfType, 0, &v11);
      return 0;
    }
    v9 = *(_QWORD *)(a1 + 88);
    if (!v9)
      return 0x7FFFFFFFFFFFFFFFLL;
    v10 = *(_QWORD *)(a1 + 88);
    while (*(_DWORD *)(v10 + 16) != 401)
    {
      v10 = *(_QWORD *)(v10 + 88);
      if (!v10)
      {
        v10 = a1;
        if (v6 != 404)
        {
          v10 = *(_QWORD *)(a1 + 88);
          while (*(_DWORD *)(v10 + 16) != 404)
          {
            v10 = *(_QWORD *)(v10 + 88);
            if (!v10)
            {
              v10 = a1;
              if (v6 != 405)
              {
                v10 = *(_QWORD *)(a1 + 88);
                while (*(_DWORD *)(v10 + 16) != 405)
                {
                  v10 = *(_QWORD *)(v10 + 88);
                  if (!v10)
                  {
                    v10 = a1;
                    if (v6 != 406)
                    {
                      result = 0x7FFFFFFFFFFFFFFFLL;
                      while (*(_DWORD *)(v9 + 16) != 406)
                      {
                        v9 = *(_QWORD *)(v9 + 88);
                        if (!v9)
                          return result;
                      }
                      v10 = v9;
                    }
                    goto LABEL_27;
                  }
                }
              }
              goto LABEL_27;
            }
          }
        }
        break;
      }
    }
LABEL_27:
    v11 = 0;
    CountColumnElements(v10, a1, &v11);
    if (v11)
      return v11 - 1;
    else
      return 0;
  }
}

BOOL CountColumnElements(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v3;
  _BOOL8 v4;
  BOOL v5;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 16);
    if (v3 == 400)
      return 0;
    v5 = v3 == 403;
    if ((v3 & 0xFFFFFFFE) == 0x192)
      ++*a3;
  }
  else
  {
    v5 = 0;
  }
  v4 = a1 == a2;
  if (a1 != a2 && !v5)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2020000000;
    v11 = 0;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZL19CountColumnElementsP15CGPDFTaggedNodeS0_Pm_block_invoke;
    v7[3] = &unk_1E165EEB8;
    v7[4] = &v8;
    v7[5] = a2;
    v7[6] = a3;
    CGPDFTaggedNodeEnumerateChildren(a1, v7);
    v4 = *((_BYTE *)v9 + 24) != 0;
    _Block_object_dispose(&v8, 8);
  }
  return v4;
}

void sub_184CDA178(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL19CountColumnElementsP15CGPDFTaggedNodeS0_Pm_block_invoke(_QWORD *a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = CountColumnElements(a2, a1[5], a1[6]);
  return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetParagraphLinks(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 152);
  return result;
}

uint64_t CGPDFTaggedNodeCreate(uint64_t a1)
{
  uint64_t cftype;
  uint64_t v3;

  if (CGPDFTaggedNodeGetTypeID(void)::onceToken != -1)
    dispatch_once(&CGPDFTaggedNodeGetTypeID(void)::onceToken, &__block_literal_global_12807);
  cftype = pdf_create_cftype();
  v3 = cftype;
  if (cftype)
  {
    *(_DWORD *)(cftype + 16) = 0;
    *(_QWORD *)(cftype + 24) = 0;
    *(_BYTE *)(cftype + 48) = 0;
    *(_BYTE *)(cftype + 113) = 0;
    *(_OWORD *)(cftype + 56) = 0u;
    *(_OWORD *)(cftype + 72) = 0u;
    *(_QWORD *)(cftype + 88) = 0;
    *(_QWORD *)(cftype + 96) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    *(_QWORD *)(v3 + 104) = 0;
    *(_BYTE *)(v3 + 112) = 1;
    *(_QWORD *)(v3 + 200) = 0;
    *(_QWORD *)(v3 + 208) = 0;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(_BYTE *)(v3 + 168) = 0;
    *(_QWORD *)(v3 + 176) = 0;
    *(_QWORD *)(v3 + 184) = 0;
    *(_BYTE *)(v3 + 192) = 0;
    *(_QWORD *)(v3 + 216) = 0;
    *(_QWORD *)(v3 + 224) = a1;
  }
  return v3;
}

uint64_t ___ZL24CGPDFTaggedNodeGetTypeIDv_block_invoke()
{
  uint64_t result;

  result = pdf_register_cftype((uint64_t)&CGPDFTaggedNodeGetTypeID(void)::CGPDFTaggedNodeType);
  CGPDFTaggedNodeGetTypeID(void)::typeID = result;
  return result;
}

void CGPDFTaggedNodeFinalize(uint64_t a1)
{
  const void *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  unint64_t i;
  const void *ChildAtIndex;
  uint64_t v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  void *v14;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  v3 = *(const __CFArray **)(a1 + 96);
  if (v3)
  {
    Count = CFArrayGetCount(v3);
    if (Count)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ChildAtIndex = CGPDFTaggedNodeGetChildAtIndex(a1, i);
        if (ChildAtIndex)
          CFRelease(ChildAtIndex);
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 96));
  }
  v8 = *(_QWORD *)(a1 + 104);
  if (v8)
    CGPDFNodeRelease(v8);
  v9 = *(const void **)(a1 + 120);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 128);
  if (v10)
    CFRelease(v10);
  v11 = *(const void **)(a1 + 136);
  if (v11)
    CFRelease(v11);
  v12 = *(const void **)(a1 + 144);
  if (v12)
    CFRelease(v12);
  v13 = *(const void **)(a1 + 152);
  if (v13)
    CFRelease(v13);
  v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(_QWORD *)(a1 + 208) = v14;
    operator delete(v14);
  }
}

uint64_t CGPDFTaggedNodeCreateCopyWithTextRange(uint64_t a1, CFIndex a2, CFIndex a3)
{
  uint64_t v6;
  uint64_t v7;
  CFIndex v8;
  uint64_t cftype;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFRange v17;

  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v7 = v6;
  v8 = *(_QWORD *)(a1 + 176);
  if (v8 <= a2 && a2 + a3 <= *(_QWORD *)(a1 + 184) + v8)
  {
    if (CGPDFTaggedNodeGetTypeID(void)::onceToken != -1)
      dispatch_once(&CGPDFTaggedNodeGetTypeID(void)::onceToken, &__block_literal_global_12807);
    cftype = pdf_create_cftype();
    if (cftype)
    {
      *(_DWORD *)(cftype + 16) = *(_DWORD *)(a1 + 16);
      *(_QWORD *)(cftype + 24) = *(_QWORD *)(a1 + 24);
      *(_BYTE *)(cftype + 48) = 1;
      v17.location = a2;
      v17.length = a3;
      PageLayout::GetBoundsForTextRange((PageLayout *)(v7 + 16), v17);
      *(_QWORD *)(cftype + 56) = v11;
      *(_QWORD *)(cftype + 64) = v12;
      *(_QWORD *)(cftype + 72) = v13;
      *(_QWORD *)(cftype + 80) = v14;
      *(_OWORD *)(cftype + 88) = *(_OWORD *)(a1 + 88);
      *(_QWORD *)(cftype + 104) = *(_QWORD *)(a1 + 104);
      *(_WORD *)(cftype + 112) = *(_WORD *)(a1 + 112);
      *(_OWORD *)(cftype + 120) = *(_OWORD *)(a1 + 120);
      *(_OWORD *)(cftype + 136) = *(_OWORD *)(a1 + 136);
      v15 = *(_QWORD *)(a1 + 160);
      *(_QWORD *)(cftype + 152) = *(_QWORD *)(a1 + 152);
      *(_QWORD *)(cftype + 160) = v15;
      *(_BYTE *)(cftype + 168) = 1;
      *(_QWORD *)(cftype + 176) = a2;
      *(_QWORD *)(cftype + 184) = a3;
      *(_BYTE *)(cftype + 192) = 0;
      *(_QWORD *)(cftype + 208) = 0;
      *(_QWORD *)(cftype + 216) = 0;
      *(_QWORD *)(cftype + 200) = 0;
      *(_QWORD *)(cftype + 224) = *(_QWORD *)(a1 + 224);
    }
  }
  else
  {
    pdf_error("New text range needs to be within the original node's text range.");
    cftype = 0;
  }
  if (v7)
    CFRelease((CFTypeRef)v7);
  return cftype;
}

uint64_t CGPDFTaggedNodeCreateCopyWithStringRange(uint64_t a1, int64_t a2, uint64_t a3)
{
  uint64_t v6;
  const void *v7;
  PageLayout *v8;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  uint64_t v14;
  uint64_t cftype;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE v21[480];
  uint64_t v22;
  CFRange v23;

  CGPDFPageCopyPageLayoutWithCTLD(*(_QWORD *)(a1 + 224), 1);
  v7 = (const void *)v6;
  v22 = v6;
  v8 = (PageLayout *)(v6 + 16);
  PageLayout::PageLayout((PageLayout *)v21, (const PageLayout *)(v6 + 16));
  v9 = CGPDFTaggedNodeConvertStringRangeToTextRange((uint64_t)v21, a2, a3);
  v11 = v10;
  PageLayout::~PageLayout((PageLayout *)v21);
  v12 = *(_QWORD *)(a1 + 176);
  if (v12 <= v9 && v9 + v11 <= *(_QWORD *)(a1 + 184) + v12)
  {
    if (CGPDFTaggedNodeGetTypeID(void)::onceToken != -1)
      dispatch_once(&CGPDFTaggedNodeGetTypeID(void)::onceToken, &__block_literal_global_12807);
    cftype = pdf_create_cftype();
    v14 = cftype;
    if (cftype)
    {
      *(_DWORD *)(cftype + 16) = *(_DWORD *)(a1 + 16);
      *(_QWORD *)(cftype + 24) = *(_QWORD *)(a1 + 24);
      *(_BYTE *)(cftype + 48) = 1;
      v23.location = v9;
      v23.length = v11;
      PageLayout::GetBoundsForTextRange(v8, v23);
      *(_QWORD *)(v14 + 56) = v16;
      *(_QWORD *)(v14 + 64) = v17;
      *(_QWORD *)(v14 + 72) = v18;
      *(_QWORD *)(v14 + 80) = v19;
      *(_OWORD *)(v14 + 88) = *(_OWORD *)(a1 + 88);
      *(_QWORD *)(v14 + 104) = *(_QWORD *)(a1 + 104);
      *(_WORD *)(v14 + 112) = *(_WORD *)(a1 + 112);
      *(_OWORD *)(v14 + 120) = *(_OWORD *)(a1 + 120);
      *(_OWORD *)(v14 + 136) = *(_OWORD *)(a1 + 136);
      *(_QWORD *)(v14 + 152) = *(_QWORD *)(a1 + 152);
      *(_QWORD *)(v14 + 160) = *(_QWORD *)(a1 + 160);
      *(_BYTE *)(v14 + 168) = 1;
      *(_QWORD *)(v14 + 176) = v9;
      *(_QWORD *)(v14 + 184) = v11;
      *(_BYTE *)(v14 + 192) = 0;
      *(_QWORD *)(v14 + 208) = 0;
      *(_QWORD *)(v14 + 216) = 0;
      *(_QWORD *)(v14 + 200) = 0;
      *(_QWORD *)(v14 + 224) = *(_QWORD *)(a1 + 224);
    }
  }
  else
  {
    pdf_error("New text range needs to be within the original node's text range.");
    v14 = 0;
  }
  if (v7)
    CFRelease(v7);
  return v14;
}

void sub_184CDA674(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  PageLayout::~PageLayout((PageLayout *)va);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v2 - 72));
  _Unwind_Resume(a1);
}

CFStringRef CGPDFTaggedNodeSetType(CFStringRef result, int a2)
{
  CFStringRef v2;
  const char *Name;

  if (result)
  {
    v2 = result;
    LODWORD(result->data) = a2;
    if (!result->length)
    {
      Name = CGPDFTaggedNodeTypeGetName(a2);
      result = CFStringCreateWithCString(0, Name, 0x8000100u);
      v2->length = (uint64_t)result;
    }
  }
  return result;
}

_QWORD *CGPDFTaggedNodeSetLanguageText(_QWORD *result, CFTypeRef cf)
{
  _QWORD *v3;
  const void *v4;

  if (result)
  {
    v3 = result;
    v4 = (const void *)result[18];
    if (v4)
      CFRelease(v4);
    v3[18] = cf;
    return CFRetain(cf);
  }
  return result;
}

void CGPDFTaggedNodeAddTaggedNode(uint64_t a1, _QWORD *cf)
{
  __CFArray *v2;
  CFTypeRef v3;

  if (a1 && cf)
  {
    v2 = *(__CFArray **)(a1 + 96);
    if (v2)
    {
      cf[11] = a1;
      v3 = CFRetain(cf);
      CFArrayAppendValue(v2, v3);
    }
  }
}

uint64_t ___ZL27CGPDFTaggedContextGetTypeIDv_block_invoke()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  CGPDFTaggedContextGetTypeID(void)::id = result;
  return result;
}

uint64_t CGPDFTaggedContextFinalize(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  StructureElement *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void **v8;
  void **v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void **v21;

  v1 = *(uint64_t **)(result + 16);
  if (v1)
  {
    v2 = *v1;
    v3 = *(StructureElement **)(*v1 + 24);
    if (!v3 || (StructureElement::~StructureElement(v3), MEMORY[0x186DC23C4](), (v2 = *v1) != 0))
    {
      v4 = *(void **)(v2 + 248);
      if (v4)
        operator delete(v4);
      v5 = *(_QWORD *)(v2 + 224);
      if (v5)
      {
        v6 = *(_QWORD *)(v2 + 232);
        v7 = *(void **)(v2 + 224);
        if (v6 != v5)
        {
          do
            v6 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v6 - 40);
          while (v6 != v5);
          v7 = *(void **)(v2 + 224);
        }
        *(_QWORD *)(v2 + 232) = v5;
        operator delete(v7);
      }
      v8 = *(void ***)(v2 + 200);
      if (v8)
      {
        v9 = *(void ***)(v2 + 208);
        v10 = *(void **)(v2 + 200);
        if (v9 != v8)
        {
          do
          {
            v9 -= 3;
            v21 = v9;
            std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__destroy_vector::operator()[abi:se180100](&v21);
          }
          while (v9 != v8);
          v10 = *(void **)(v2 + 200);
        }
        *(_QWORD *)(v2 + 208) = v8;
        operator delete(v10);
      }
      std::__tree<unsigned long>::destroy(*(_QWORD **)(v2 + 184));
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(_QWORD **)(v2 + 160));
      v11 = *(_QWORD *)(v2 + 128);
      if (v11)
      {
        v12 = *(_QWORD *)(v2 + 136);
        v13 = *(void **)(v2 + 128);
        if (v12 != v11)
        {
          do
          {
            v14 = v12 - 24;
            std::__tree<unsigned long>::destroy(*(_QWORD **)(v12 - 16));
            v12 = v14;
          }
          while (v14 != v11);
          v13 = *(void **)(v2 + 128);
        }
        *(_QWORD *)(v2 + 136) = v11;
        operator delete(v13);
      }
      v15 = *(_QWORD *)(v2 + 104);
      if (v15)
      {
        v16 = *(_QWORD *)(v2 + 112);
        v17 = *(void **)(v2 + 104);
        if (v16 != v15)
        {
          v18 = *(_QWORD *)(v2 + 112);
          do
          {
            v20 = *(void **)(v18 - 24);
            v18 -= 24;
            v19 = v20;
            if (v20)
            {
              *(_QWORD *)(v16 - 16) = v19;
              operator delete(v19);
            }
            v16 = v18;
          }
          while (v18 != v15);
          v17 = *(void **)(v2 + 104);
        }
        *(_QWORD *)(v2 + 112) = v15;
        operator delete(v17);
      }
      std::mutex::~mutex((std::mutex *)(v2 + 32));
      MEMORY[0x186DC23C4](v2, 0x1030C402EF8FC53);
    }
    JUMPOUT(0x186DC23C4);
  }
  return result;
}

void CGPDFTaggedContextAddNode(uint64_t a1, int64_t a2, uint64_t a3)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  BOOL v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  uint64_t v29;

  if (a1)
  {
    v3 = *(uint64_t **)(a1 + 16);
    if (v3)
    {
      v4 = HIDWORD(a2) - 1;
      v5 = *v3;
      v6 = *(_QWORD *)(*v3 + 128);
      if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v5 + 136) - v6) >> 3) <= v4)
        goto LABEL_39;
      if (!*(_BYTE *)(v5 + 97))
      {
        v7 = v6 + 24 * v4;
        v10 = *(_QWORD **)(v7 + 8);
        v9 = (_QWORD *)(v7 + 8);
        v8 = v10;
        if (v10)
        {
          v12 = v9;
          v13 = v8;
          do
          {
            v14 = v13[4];
            v15 = v14 < a2;
            if (v14 >= a2)
              v16 = v13;
            else
              v16 = v13 + 1;
            if (!v15)
              v12 = v13;
            v13 = (_QWORD *)*v16;
          }
          while (*v16);
          if (v12 != v9 && v12[4] <= a2)
          {
            while (1)
            {
              while (1)
              {
                v17 = v8[4];
                if (v17 <= a2)
                  break;
                v8 = (_QWORD *)*v8;
                if (!v8)
                  goto LABEL_21;
              }
              if (v17 >= a2)
                break;
              v8 = (_QWORD *)v8[1];
              if (!v8)
LABEL_21:
                std::__throw_out_of_range[abi:se180100]("map::at:  key not found");
            }
            v18 = (_QWORD *)v8[5];
            ++*(_DWORD *)(a3 + 40);
            v20 = (_QWORD *)v18[18];
            v19 = v18[19];
            if ((unint64_t)v20 >= v19)
            {
              v22 = (_QWORD *)v18[17];
              v23 = v20 - v22;
              v24 = v23 + 1;
              if ((unint64_t)(v23 + 1) >> 61)
                goto LABEL_40;
              v25 = v19 - (_QWORD)v22;
              if (v25 >> 2 > v24)
                v24 = v25 >> 2;
              if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
                v26 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v26 = v24;
              if (v26)
              {
                if (v26 >> 61)
                  std::__throw_bad_array_new_length[abi:se180100]();
                v27 = (char *)operator new(8 * v26);
                v28 = &v27[8 * v23];
                *(_QWORD *)v28 = a3;
                v21 = v28 + 8;
                if (v20 != v22)
                {
                  do
                  {
                    v29 = *--v20;
                    *((_QWORD *)v28 - 1) = v29;
                    v28 -= 8;
                  }
                  while (v20 != v22);
                  v20 = v22;
                }
                v18[17] = v28;
                v18[18] = v21;
                v18[19] = &v27[8 * v26];
                if (v20)
                  operator delete(v20);
                goto LABEL_38;
              }
            }
            else if (v20)
            {
              *v20 = a3;
              v21 = v20 + 1;
LABEL_38:
              v18[18] = v21;
              return;
            }
LABEL_39:
            __break(1u);
LABEL_40:
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
          }
        }
      }
    }
  }
}

uint64_t CGPDFTaggedPagePropertiesCreate(uint64_t a1)
{
  uint64_t v2;
  _QWORD **v3;
  _QWORD **v4;
  uint64_t Instance;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 16);
  if (!v2 || !CGPDFDocumentIsTaggedPDF(*(_QWORD *)(a1 + 16)))
    return 0;
  CGPDFDocumentCopyTaggedContext(v2);
  v4 = v3;
  if (*(_BYTE *)(*v3[2] + 97))
  {
    CFRelease(v3);
    return 0;
  }
  if (CGPDFTaggedPagePropertiesGetTypeID(void)::onceToken != -1)
    dispatch_once(&CGPDFTaggedPagePropertiesGetTypeID(void)::onceToken, &__block_literal_global_45_12870);
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 16) = v4;
  *(_QWORD *)(Instance + 24) = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 32), 0);
  *(_QWORD *)(Instance + 96) = 0;
  return Instance;
}

uint64_t ___ZL34CGPDFTaggedPagePropertiesGetTypeIDv_block_invoke()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  CGPDFTaggedPagePropertiesGetTypeID(void)::id = result;
  return result;
}

void CGPDFTaggedPagePropertiesFinalize(char *a1)
{
  const void *v2;
  const void *v3;

  v2 = (const void *)*((_QWORD *)a1 + 2);
  if (v2)
    CFRelease(v2);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  v3 = (const void *)*((_QWORD *)a1 + 12);
  if (v3)
    CFRelease(v3);
}

void CGPDFTaggedPagePropertiesRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t CGPDFTaggedPagePropertiesGetStructureTree(uint64_t result)
{
  uint64_t v1;
  size_t v2;
  TaggedParser *v3;
  CGPDFPage *Page;
  uint64_t v5;
  std::mutex *v6;
  __CFDictionary *v7;

  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 16))
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 32));
      if (!*(_QWORD *)(v1 + 96))
      {
        v2 = *(_QWORD *)(v1 + 24);
        v3 = *(TaggedParser **)(*(_QWORD *)(v1 + 16) + 16);
        Page = CGPDFDocumentGetPage(*(CGPDFDocumentRef *)(*(_QWORD *)v3 + 16), v2);
        TaggedParser::AddPage(v3, Page);
        v5 = *(_QWORD *)v3;
        if (*(_QWORD *)(*(_QWORD *)v3 + 24))
        {
          v6 = (std::mutex *)(v5 + 32);
          std::mutex::lock((std::mutex *)(v5 + 32));
          v7 = BuildStructureTree(v2, 0, *(_QWORD *)(*(_QWORD *)v3 + 24));
          std::mutex::unlock(v6);
        }
        else
        {
          v7 = 0;
        }
        *(_QWORD *)(v1 + 96) = v7;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v1 + 32));
      return *(_QWORD *)(v1 + 96);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_184CDAD10(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedpagePropertiesGetStructureElementID(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;

  if (result)
  {
    v2 = *(_QWORD *)(result + 16);
    if (v2)
    {
      v3 = *(_QWORD **)(v2 + 16);
      v4 = *(_QWORD *)(result + 24);
      v6 = (uint64_t *)(*v3 + 128);
      v5 = *v6;
      if (0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3) <= v4 - 1)
      {
        __break(1u);
        return result;
      }
      v8 = (uint64_t *)(a2 | ((unint64_t)v4 << 32));
      v7 = std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v5 + 24 * (v4 - 1)), (uint64_t)v8, &v8)[5];
      if (v7)
        return *v7;
    }
  }
  return -1;
}

uint64_t CGPDFTaggedNodeGetObjectReference(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

void pdf_reader_release(uint64_t *a1)
{
  const void *v2;
  uint64_t v3;

  if (a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
      CFRelease(v2);
    v3 = *a1;
    if (*a1)
      *(_BYTE *)(v3 + 176) = 1;
    pdf_xref_release(v3);
    free(a1);
  }
}

uint64_t convert_version(const char *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t result;
  char *v10;
  unint64_t v11;
  char *v12;

  v12 = 0;
  v6 = strtol_l(a1, &v12, 10, 0);
  v7 = v12;
  if (v12 == a1)
    return 0;
  v8 = v6;
  result = 0;
  if (*v12 == 46 && (v8 & 0x8000000000000000) == 0 && v8 <= 0x7FFFFFFF)
  {
    *a2 = v8;
    v10 = v7 + 1;
    v11 = strtol_l(v7 + 1, &v12, 10, 0);
    if (v12 != v10 && (*v12 | 0x20) == 0x20 && !(v11 >> 31))
    {
      *a3 = v11;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t pdf_reader_get_linearized_page_ranges(uint64_t result, unint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  uint64_t v29;
  std::logic_error *exception;
  void (*v32)(void *);
  struct type_info *v33;

  if (result)
  {
    if (a2 && (v5 = result, *(_QWORD *)(result + 16) >= a2))
    {
      if (a3)
      {
        if (a4)
        {
          *a3 = 0;
          *a4 = 0;
          v8 = *(_QWORD *)(result + 64);
          v9 = a2 - 1;
          v10 = *(_QWORD *)(v8 + 48);
          if (a2 - 1 < (*(_QWORD *)(v8 + 56) - v10) >> 6)
          {
            if (a2 < 2)
              v11 = 1;
            else
              v11 = ((uint64_t)(*(_QWORD *)(v10 + (v9 << 6) + 32) - *(_QWORD *)(v10 + (v9 << 6) + 24)) >> 3) + 1;
            result = (uint64_t)malloc_type_malloc(16 * v11, 0x1000040451B5BE8uLL);
            v12 = v10 + (v9 << 6);
            v13 = *(_QWORD *)(v12 + 48);
            v14 = *(unsigned int *)(v12 + 4);
            *(_QWORD *)result = v13;
            *(_QWORD *)(result + 8) = v14;
            if (a2 < 2)
            {
LABEL_23:
              *a3 = result;
              *a4 = v11;
              return 1;
            }
            v15 = *(_QWORD *)(v5 + 64);
            v16 = *(_QWORD *)(v15 + 48);
            if (*(_QWORD *)(v15 + 56) != v16)
            {
              v17 = (_QWORD *)(result + 16);
              v18 = v10 + (v9 << 6);
              v19 = *(unsigned int **)(v18 + 24);
              v20 = *(unsigned int **)(v18 + 32);
              if (v19 != v20)
              {
                v21 = *(_QWORD *)(v16 + 48);
                v22 = *(unsigned int *)(v16 + 4);
                v23 = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 32);
                v24 = (*(_QWORD *)(*(_QWORD *)(v5 + 72) + 40) - v23) >> 4;
                v25 = v21 + v22;
                while (1)
                {
                  v26 = *v19;
                  if (v24 <= v26)
                    break;
                  v27 = (unsigned int *)(v23 + 16 * v26);
                  v28 = *((_QWORD *)v27 + 1);
                  v29 = *v27;
                  if (v21 <= v28 && v28 + v29 <= v25)
                  {
                    *v17 = v28;
                    v17[1] = v29;
                    v17 += 2;
                  }
                  v19 += 2;
                  if (v19 == v20)
                    goto LABEL_22;
                }
                exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(exception, "shared object index is out of range");
                exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                v32 = (void (*)(void *))MEMORY[0x1E0DE42E0];
                v33 = (struct type_info *)off_1E1620B30;
LABEL_30:
                __cxa_throw(exception, v33, v32);
              }
LABEL_22:
              v11 = ((uint64_t)v17 - result) >> 4;
              goto LABEL_23;
            }
          }
          __break(1u);
          return result;
        }
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "NULL 'range_count' parameter");
      }
      else
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "NULL 'shared_resource_ranges' parameter");
      }
    }
    else
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "page_number is out of range");
    }
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
    v32 = (void (*)(void *))MEMORY[0x1E0DE4360];
    v33 = (struct type_info *)off_1E1620B40;
    goto LABEL_30;
  }
  return result;
}

void sub_184CDB0F0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;
  void *v13;

  __cxa_free_exception(v10);
  v13 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    (*(void (**)(void *))(*(_QWORD *)v13 + 16))(v13);
    pdf_error("%s caught exception: %s");
  }
  else
  {
    pdf_error("%s caught an unknown exception");
  }
  __cxa_end_catch();
  JUMPOUT(0x184CDB01CLL);
}

void *GList::append(GList *this, void *a2)
{
  int v4;
  int v5;
  void *result;
  int v7;

  v5 = *((_DWORD *)this + 2);
  v4 = *((_DWORD *)this + 3);
  result = *(void **)this;
  if (v4 >= v5)
  {
    v7 = *((_DWORD *)this + 4);
    if (v7 <= 0)
      v7 = v5;
    *((_DWORD *)this + 2) = v7 + v5;
    result = greallocn(result, v7 + v5, 8u);
    *(_QWORD *)this = result;
    v4 = *((_DWORD *)this + 3);
  }
  *((_DWORD *)this + 3) = v4 + 1;
  *((_QWORD *)result + v4) = a2;
  return result;
}

void CGErrorSetCallback(CGErrorCallback callback)
{
  pthread_mutex_lock(&error_callback_lock);
  error_callback = callback;
  pthread_mutex_unlock(&error_callback_lock);
}

void CGLog(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CGLogWithArguments(a1, a2, &a9);
}

void CGPostErrorWithArguments(uint64_t a1, va_list a2)
{
  CGLogWithArguments(2, a1, a2);
}

void CGPDFPageGetImages(uint64_t a1, CGPDFContentStream *a2, CGPDFContentStream *a3)
{
  CGPDFContentStreamRef *v6;
  CGPDFContentStreamRef *v7;
  uint64_t v8;

  if (a1)
  {
    if (a2)
    {
      v6 = (CGPDFContentStreamRef *)CGPDFImageExtractorCreate(0);
      if (v6)
      {
        v7 = v6;
        v8 = CGPDFContentStreamCreate(*(_QWORD *)(a1 + 40));
        v7[2] = (CGPDFContentStreamRef)v8;
        if (v8)
        {
          v7[3] = a2;
          v7[4] = a3;
          CGPDFImageExtractorGetImages(v7);
        }
        CGPDFImageExtractorRelease(v7);
      }
    }
  }
}

_QWORD *CGPDFImageExtractorCreate(__int128 ***a1)
{
  _QWORD *v2;
  _QWORD *Copy;
  CGPDFOperatorTable *v4;

  v2 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2)
  {
    if (a1)
      Copy = CGPDFRStateCreateCopy(*a1);
    else
      Copy = CGPDFRStateCreate();
    *v2 = Copy;
    if (!Copy
      || (v4 = CGPDFOperatorTableCreate(),
          CGPDFOperatorTableSetCallback(v4, "q", (CGPDFOperatorCallback)image_q),
          CGPDFOperatorTableSetCallback(v4, "Q", (CGPDFOperatorCallback)image_Q),
          CGPDFOperatorTableSetCallback(v4, "cm", (CGPDFOperatorCallback)image_cm),
          CGPDFOperatorTableSetCallback(v4, "Do", (CGPDFOperatorCallback)image_Do),
          CGPDFOperatorTableSetCallback(v4, "EI", (CGPDFOperatorCallback)image_EI),
          (v2[1] = v4) == 0))
    {
      CGPDFImageExtractorRelease(v2);
      return 0;
    }
  }
  return v2;
}

void CGPDFImageExtractorGetImages(CGPDFContentStreamRef *info)
{
  CGPDFScanner *v1;

  v1 = CGPDFScannerCreate(info[2], info[1], info);
  CGPDFScannerScan(v1);
  if (v1)
    CFRelease(v1);
}

void CGPDFImageExtractorRelease(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    CGPDFRStateRelease((_QWORD *)*a1);
    v2 = (const void *)a1[1];
    if (v2)
      CFRelease(v2);
    v3 = (const void *)a1[2];
    if (v3)
      CFRelease(v3);
    free(a1);
  }
}

void image_q(uint64_t a1, uint64_t *a2)
{
  CGPDFRStateGSave(*a2);
}

void image_Q(uint64_t a1, uint64_t *a2)
{
  CGPDFRStateGRestore(*a2);
}

double image_cm(CGPDFScanner *a1, double ***a2)
{
  double result;
  double *v5;
  double v6[6];
  CGPDFReal value;
  CGPDFReal v8;
  CGPDFReal v9;
  CGPDFReal v10;
  CGPDFReal v11;
  CGPDFReal v12;

  v11 = 0.0;
  v12 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  value = 0.0;
  v8 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v8)
    && CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &v10)
    && CGPDFScannerPopNumber(a1, &v11)
    && CGPDFScannerPopNumber(a1, &v12))
  {
    if (*a2)
      v5 = **a2;
    else
      v5 = 0;
    v6[0] = v12;
    v6[1] = v11;
    v6[2] = v10;
    v6[3] = v9;
    v6[4] = v8;
    v6[5] = value;
    return CGPDFGStateConcatCTM(v5, v6);
  }
  return result;
}

void image_Do(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  CGImage *v9;
  CGImageRef ImageForRenderingSize;
  CGImageRef v11;
  const CGAffineTransform *v12;
  __int128 v13;
  uint64_t v14;
  void (*v15)(CGImageRef, _OWORD *, uint64_t);
  uint64_t v16;
  double ***v17;
  CGPDFStream *v18;
  CGPDFDictionary *v19;
  CGPDFStream *v20;
  CGPDFDictionary *v21;
  CGPDFContentStreamRef v22;
  CGPDFContentStreamRef v23;
  const CGAffineTransform *v24;
  double *v25;
  __int128 v26;
  char *value;
  _OWORD v28[3];
  __int128 v29;
  __int128 v30;
  __int128 v31;

  value = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value))
    return;
  v4 = *((_QWORD *)a1 + 7);
  if (!v4)
    return;
  v5 = value;
  v6 = v4;
  while (1)
  {
    v7 = CGPDFResourcesCopyXObject(*(_QWORD *)(v6 + 32), v5);
    if (v7)
      break;
    v6 = *(_QWORD *)(v6 + 40);
    if (!v6)
      return;
  }
  v8 = v7[4];
  if (v8 == 2)
  {
    v16 = CGPDFXObjectGetValue((uint64_t)v7);
    v17 = (double ***)CGPDFImageExtractorCreate(a2);
    if (v17)
    {
      if (v16)
      {
        v18 = *(CGPDFStream **)v16;
        v19 = *(CGPDFDictionary **)(v16 + 88);
      }
      else
      {
        v18 = 0;
        v19 = 0;
      }
      v22 = CGPDFContentStreamCreateWithStream(v18, v19, *(CGPDFContentStreamRef *)(a2 + 16));
      v17[2] = (double **)v22;
      if (v22)
      {
        *(_OWORD *)(v17 + 3) = *(_OWORD *)(a2 + 24);
      }
      else
      {
        CGPDFImageExtractorRelease(v17);
        v17 = 0;
      }
    }
    CGPDFRStateGSave((uint64_t)*v17);
    v24 = (const CGAffineTransform *)(v16 + 40);
  }
  else
  {
    if (v8 != 1)
    {
      if (!v8)
      {
        v9 = (CGImage *)CGPDFXObjectGetValue((uint64_t)v7);
        ImageForRenderingSize = CGPDFImageCreateImageForRenderingSize(v9, v4, 0.0, 0.0);
        if (ImageForRenderingSize)
        {
          v11 = ImageForRenderingSize;
          v12 = *(const CGAffineTransform **)a2;
          if (*(_QWORD *)a2)
            v12 = *(const CGAffineTransform **)&v12->a;
          if (!v12)
            v12 = &CGAffineTransformIdentity;
          v13 = *(_OWORD *)&v12->c;
          v29 = *(_OWORD *)&v12->a;
          v30 = v13;
          v31 = *(_OWORD *)&v12->tx;
          v15 = *(void (**)(CGImageRef, _OWORD *, uint64_t))(a2 + 24);
          v14 = *(_QWORD *)(a2 + 32);
          v28[0] = v29;
          v28[1] = v13;
          v28[2] = v31;
          v15(ImageForRenderingSize, v28, v14);
          CFRelease(v11);
        }
      }
      return;
    }
    v16 = CGPDFXObjectGetValue((uint64_t)v7);
    v17 = (double ***)CGPDFImageExtractorCreate(a2);
    if (v17)
    {
      if (v16)
      {
        v20 = *(CGPDFStream **)(v16 + 16);
        v21 = *(CGPDFDictionary **)(v16 + 104);
      }
      else
      {
        v20 = 0;
        v21 = 0;
      }
      v23 = CGPDFContentStreamCreateWithStream(v20, v21, *(CGPDFContentStreamRef *)(a2 + 16));
      v17[2] = (double **)v23;
      if (v23)
      {
        *(_OWORD *)(v17 + 3) = *(_OWORD *)(a2 + 24);
      }
      else
      {
        CGPDFImageExtractorRelease(v17);
        v17 = 0;
      }
    }
    CGPDFRStateGSave((uint64_t)*v17);
    v24 = (const CGAffineTransform *)(v16 + 56);
  }
  if (!v16)
    v24 = &CGAffineTransformIdentity;
  if (*v17)
    v25 = **v17;
  else
    v25 = 0;
  v26 = *(_OWORD *)&v24->c;
  v29 = *(_OWORD *)&v24->a;
  v30 = v26;
  v31 = *(_OWORD *)&v24->tx;
  CGPDFGStateConcatCTM(v25, (double *)&v29);
  CGPDFImageExtractorGetImages((CGPDFContentStreamRef *)v17);
  CGPDFRStateGRestore((uint64_t)*v17);
  CGPDFImageExtractorRelease(v17);
}

void image_EI(uint64_t *a1, uint64_t a2)
{
  CGImage *Inline;
  CGImage *v5;
  CGImageRef ImageForRenderingSize;
  CGImageRef v7;
  const CGAffineTransform *v8;
  __int128 v9;
  uint64_t v10;
  void (*v11)(CGImageRef, _OWORD *, uint64_t);
  _OWORD v12[3];
  CGPDFStreamRef value;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  value = 0;
  if (CGPDFScannerPopStream((CGPDFScannerRef)a1, &value))
  {
    Inline = (CGImage *)CGPDFImageCreateInline(a1[7], (uint64_t)value);
    if (Inline)
    {
      v5 = Inline;
      ImageForRenderingSize = CGPDFImageCreateImageForRenderingSize(Inline, a1[7], 0.0, 0.0);
      if (ImageForRenderingSize)
      {
        v7 = ImageForRenderingSize;
        v8 = *(const CGAffineTransform **)a2;
        if (*(_QWORD *)a2)
          v8 = *(const CGAffineTransform **)&v8->a;
        if (!v8)
          v8 = &CGAffineTransformIdentity;
        v9 = *(_OWORD *)&v8->c;
        v14 = *(_OWORD *)&v8->a;
        v15 = v9;
        v16 = *(_OWORD *)&v8->tx;
        v11 = *(void (**)(CGImageRef, _OWORD *, uint64_t))(a2 + 24);
        v10 = *(_QWORD *)(a2 + 32);
        v12[0] = v14;
        v12[1] = v9;
        v12[2] = v16;
        v11(ImageForRenderingSize, v12, v10);
        CFRelease(v7);
      }
      CFRelease(v5);
    }
  }
}

uint64_t CGFontGetMaxUnichars(uint64_t result)
{
  if (result)
  {
    get_unimap((_QWORD *)result);
    return 256;
  }
  return result;
}

char **get_unimap(_QWORD *a1)
{
  unint64_t *v1;
  char **v2;
  char **font_info;
  char *v5;
  unint64_t v6;

  v1 = a1 + 9;
  v2 = (char **)atomic_load(a1 + 9);
  if (!v2)
  {
    v2 = (char **)malloc_type_calloc(1uLL, 0x18uLL, 0x102004014030ADEuLL);
    *v2 = (char *)a1;
    font_info = (char **)get_font_info(a1);
    if (font_info)
      v5 = *font_info;
    else
      v5 = 0;
    v2[1] = v5;
    while (1)
    {
      v6 = __ldaxr(v1);
      if (v6)
        break;
      if (!__stlxr((unint64_t)v2, v1))
        return v2;
    }
    __clrex();
    CGFontUnimapRelease(v2);
    return (char **)v6;
  }
  return v2;
}

uint64_t CGFontGetUnicharsForGlyph(uint64_t result, uint64_t a2, _WORD *a3)
{
  unsigned __int16 *v5;
  int v6;
  unint64_t v7;

  if (!result)
    return result;
  result = (uint64_t)get_unimap((_QWORD *)result);
  if (!result)
    return result;
  if (*(_QWORD *)(result + 8) <= (unint64_t)a2)
    return 0;
  v5 = (unsigned __int16 *)atomic_load((unint64_t *)(result + 16));
  if (!v5)
    goto LABEL_18;
  v6 = a2;
  if (v5 != (unsigned __int16 *)-1)
  {
    v7 = atomic_load((unint64_t *)&v5[4 * (a2 >> 10) + 4]);
    if (v7)
      v6 = *(unsigned __int16 *)(v7 + 2 * (a2 & 0x3FF));
    else
      v6 = *v5;
  }
  if (v6 == 0xFFFF)
  {
LABEL_18:
    if (*(_QWORD *)result)
      return (*(uint64_t (**)(_QWORD, uint64_t, _WORD *, uint64_t))(*(_QWORD *)(*(_QWORD *)result + 16) + 384))(*(_QWORD *)(*(_QWORD *)result + 112), a2, a3, 256);
    return 0;
  }
  if (a3)
    *a3 = v6;
  return 1;
}

void *conversion_cache_get_retained_conversion_params(uint64_t a1, CGColorSpace *a2, __int128 *a3)
{
  CGColorSpace *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  void *result;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  pthread_mutex_t *v38;
  _BOOL4 v39;
  _BYTE *v40;
  _BOOL4 v41;
  _BYTE *v42;
  BOOL v43;
  char v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  float v49;
  CFIndex v50;
  const __CFDictionary *v51;
  float v52;
  float v53;
  float v54;
  void **v55;
  BOOL v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  int v66;
  __int128 v67;
  char v68;
  _BOOL4 v69;
  void *value_out;
  _OWORD v71[3];
  _OWORD v72[3];
  _OWORD valuePtr[3];
  _OWORD key[2];
  __int128 v75;
  int v76;
  void *values[2];
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  _OWORD v85[5];
  _BYTE v86[64];
  void *keys[2];
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  _OWORD v95[9];
  uint64_t v96;

  v4 = a2;
  v5 = a1;
  v96 = *MEMORY[0x1E0C80C00];
  value_out = 0;
  if (a1)
  {
    v6 = *(_QWORD *)(a1 + 24);
    if (v6)
      v7 = (__int128 *)(v6 + 56);
    else
      v7 = 0;
  }
  else
  {
    v7 = 0;
  }
  result = 0;
  if (a2)
  {
    if (v7)
    {
      v9 = *((_QWORD *)a2 + 3);
      if (v9)
      {
        v10 = *(_OWORD *)(v9 + 56);
        v11 = *v7;
        v75 = 0uLL;
        v76 = 0;
        key[0] = v10;
        key[1] = v11;
        if (a3)
        {
          v75 = *a3;
          v76 = *((_DWORD *)a3 + 4);
        }
        cache_lock_12979();
        if (get_cache_predicate_12980 != -1)
          dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
        if (!cache_get_and_retain(*(cache_t **)(get_cache_conversion_cache + 64), key, &value_out))
        {
          cache_unlock_12982();
          if (!value_out)
            _CGHandleAssert("conversion_cache_get_retained_conversion_params", 549, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DisplayColorSpaceConversions/CGDisplayColorSpaceConversion.c", "params != NULL", "params is NULL", v16, v17, v18, v68);
          if (!CGConditionalVarWait((uint64_t)value_out, v12, v13, v14, v15, v16, v17, v18))
          {
            release_and_remove_12986(key, value_out);
            value_out = 0;
            cache_lock_12979();
          }
        }
        if (value_out)
          return value_out;
        v19 = malloc_type_calloc(1uLL, 0x110uLL, 0x10600409D7FDA2EuLL);
        if (v19)
        {
          v27 = v19;
          CGConditionalVarInit((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
          value_out = v27;
          if (get_cache_predicate_12980 != -1)
            dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
          cache_set_and_retain(*(cache_t **)(get_cache_conversion_cache + 64), key, value_out, 0);
        }
        else
        {
          value_out = 0;
        }
        cache_unlock_12982();
        v35 = (char *)value_out;
        if (!value_out)
          return value_out;
        if (v5)
          v36 = *(_QWORD *)(*(_QWORD *)(v5 + 24) + 40);
        else
          v36 = 0;
        if ((v36 & 0xFFFFFFFFFFFFFFFDLL) != 1
          || (v37 = *(_QWORD *)(*((_QWORD *)v4 + 3) + 40), (v37 & 0xFFFFFFFFFFFFFFFDLL) != 1))
        {
          CGConditionalVarPost((uint64_t)value_out, v28, v29, v30, v31, v32, v33, v34);
LABEL_110:
          release_and_remove_12986(key, value_out);
          return 0;
        }
        v38 = &w16_cacheColorLock;
        if (xyz_color_space_predicate != -1)
          dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
        v39 = CGColorSpaceEqualToColorSpace(v5, xyz_color_space_xyz);
        v69 = CGColorSpaceEqualToColorSpace((uint64_t)v4, xyz_color_space_xyz);
        if (v5)
        {
          v40 = *(_BYTE **)(v5 + 24);
          if (v40[15] || v40[16])
            goto LABEL_41;
          v41 = v40[17] != 0;
        }
        else
        {
          v41 = 0;
        }
        if (!v41 && !v39)
        {
          if (xsRGB_color_space_predicate != -1)
            dispatch_once(&xsRGB_color_space_predicate, &__block_literal_global_10_12988);
          v5 = xsRGB_color_space_sRGB;
        }
LABEL_41:
        v42 = (_BYTE *)*((_QWORD *)v4 + 3);
        if (!v42[15] && !v42[16])
        {
          v43 = v42[17] == 0;
          v44 = v69;
          if (!v43)
            v44 = 1;
          if ((v44 & 1) == 0)
          {
            if (xsRGB_color_space_predicate != -1)
              dispatch_once(&xsRGB_color_space_predicate, &__block_literal_global_10_12988);
            v4 = (CGColorSpace *)xsRGB_color_space_sRGB;
          }
        }
        if (v5
          && ((v45 = *(_QWORD *)(v5 + 24), v46 = *(unsigned __int8 *)(v45 + 16), *(_BYTE *)(v45 + 16))
           || *(_BYTE *)(v45 + 17)))
        {
          v90 = 0u;
          v91 = 0u;
          v88 = 0u;
          v89 = 0u;
          *(_OWORD *)keys = 0u;
          v80 = 0u;
          v81 = 0u;
          v78 = 0u;
          v79 = 0u;
          *(_OWORD *)values = 0u;
          if (!v4)
          {
            v50 = 0;
            goto LABEL_75;
          }
          v47 = *(unsigned __int8 *)(*((_QWORD *)v4 + 3) + 16);
        }
        else
        {
          if (!v4
            || (v48 = *((_QWORD *)v4 + 3), v47 = *(unsigned __int8 *)(v48 + 16), !*(_BYTE *)(v48 + 16))
            && !*(_BYTE *)(v48 + 17))
          {
            v51 = 0;
            goto LABEL_91;
          }
          v90 = 0u;
          v91 = 0u;
          v88 = 0u;
          v89 = 0u;
          *(_OWORD *)keys = 0u;
          v80 = 0u;
          v81 = 0u;
          v78 = 0u;
          v79 = 0u;
          *(_OWORD *)values = 0u;
        }
        if (v47)
        {
          keys[0] = CFSTR("kCGPQEOTFOpticalScale");
          LODWORD(valuePtr[0]) = 1120403456;
          values[0] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
          if (a3)
          {
            v49 = *((float *)a3 + 1);
            if (v49 == 0.0)
            {
              v50 = 1;
            }
            else
            {
              keys[1] = CFSTR("kCGPQMasteringDisplayWhite");
              *(float *)valuePtr = v49;
              values[1] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
              v50 = 2;
            }
            v52 = *((float *)a3 + 2);
            if (v52 != 0.0)
            {
              keys[v50] = CFSTR("kCGPQMasteringDisplayBlack");
              *(float *)valuePtr = v52;
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
            v53 = *((float *)a3 + 3);
            if (v53 != 0.0)
            {
              keys[v50] = CFSTR("kCGTargetDisplayWhite");
              *(float *)valuePtr = v53;
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
            if (*((float *)a3 + 2) != 0.0)
            {
              keys[v50] = CFSTR("kCGTargetDisplayBlack");
              LODWORD(valuePtr[0]) = *((_DWORD *)a3 + 3);
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
          }
          else
          {
            v50 = 1;
          }
        }
        else
        {
          v50 = 0;
        }
        if (!v5)
        {
LABEL_78:
          if (a3 && *(_BYTE *)(*((_QWORD *)v4 + 3) + 17))
          {
            v54 = *((float *)a3 + 3);
            if (v54 != 0.0)
            {
              keys[v50] = CFSTR("kCGTargetDisplayWhite");
              *(float *)valuePtr = v54;
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
            if (*((float *)a3 + 2) != 0.0)
            {
              keys[v50] = CFSTR("kCGTargetDisplayBlack");
              LODWORD(valuePtr[0]) = *((_DWORD *)a3 + 3);
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
              goto LABEL_85;
            }
          }
LABEL_84:
          if (!v50)
          {
            v51 = 0;
            goto LABEL_91;
          }
LABEL_85:
          v55 = keys;
          v51 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v50, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          do
          {
            if (*v55)
              CFRelease(*v55);
            ++v55;
            --v50;
          }
          while (v50);
          v38 = &w16_cacheColorLock;
LABEL_91:
          v56 = CGColorSpaceEqualToColorSpace(v5, (uint64_t)v4);
          v57 = v39;
          if (v51)
            v57 = 1;
          if ((v57 | v69) != 1 || v56)
          {
            v94 = 0u;
            memset(v95, 0, sizeof(v95));
            v92 = 0u;
            v93 = 0u;
            v90 = 0u;
            v91 = 0u;
            v88 = 0u;
            v89 = 0u;
            *(_OWORD *)keys = 0u;
            if (*(_QWORD *)&v38[50].__opaque[8] != -1)
              dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
            if (iterate_with_params((uint64_t)keys, xyz_color_space_xyz, v4, v51))
            {
              memset(v86, 0, sizeof(v86));
              v84 = 0u;
              memset(v85, 0, sizeof(v85));
              v82 = 0u;
              v83 = 0u;
              v80 = 0u;
              v81 = 0u;
              v78 = 0u;
              v79 = 0u;
              *(_OWORD *)values = 0u;
              if (*(_QWORD *)&v38[50].__opaque[8] != -1)
                dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
              v66 = iterate_with_params((uint64_t)values, v5, (CGColorSpace *)xyz_color_space_xyz, v51);
              v65 = v66;
              if (v66)
              {
                *((_QWORD *)v35 + 15) = v36;
                *((_QWORD *)v35 + 16) = v37;
                if (v37)
                  memcpy(v35 + 184, (char *)&v95[3] + 8, 8 * v37);
                v71[0] = *(_OWORD *)((char *)v95 + 8);
                v71[1] = *(_OWORD *)((char *)&v95[1] + 8);
                v71[2] = *(_OWORD *)((char *)&v95[2] + 8);
                v72[0] = *(_OWORD *)((char *)v85 + 8);
                v72[1] = *(_OWORD *)((char *)&v85[1] + 8);
                v72[2] = *(_OWORD *)((char *)&v85[2] + 8);
                CGColorMatrixConcat((float *)v72, (float *)v71, (float *)valuePtr);
                v67 = valuePtr[1];
                *(_OWORD *)(v35 + 136) = valuePtr[0];
                *(_OWORD *)(v35 + 152) = v67;
                *(_OWORD *)(v35 + 168) = valuePtr[2];
                if (v36)
                  memcpy(v35 + 208, v86, 8 * v36);
              }
            }
            else
            {
              v65 = 0;
            }
          }
          else
          {
            v65 = iterate_with_params((uint64_t)v35, v5, v4, v51);
          }
          if (v51)
            CFRelease(v51);
          CGConditionalVarPost((uint64_t)value_out, v58, v59, v60, v61, v62, v63, v64);
          if ((v65 & 1) != 0)
            return value_out;
          goto LABEL_110;
        }
        v46 = *(unsigned __int8 *)(*(_QWORD *)(v5 + 24) + 16);
LABEL_75:
        if (v46)
        {
          keys[v50] = CFSTR("kCGPQInvEOTFOpticalScale");
          LODWORD(valuePtr[0]) = 1008981770;
          values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
        }
        if (!v4)
          goto LABEL_84;
        goto LABEL_78;
      }
    }
  }
  return result;
}

uint64_t cache_lock_12979()
{
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  return pthread_mutex_lock((pthread_mutex_t *)get_cache_conversion_cache);
}

uint64_t cache_unlock_12982()
{
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  return pthread_mutex_unlock((pthread_mutex_t *)get_cache_conversion_cache);
}

uint64_t release_and_remove_12986(void *a1, void *value)
{
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), value);
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  return cache_remove(*(cache_t **)(get_cache_conversion_cache + 64), a1);
}

uint64_t iterate_with_params(uint64_t a1, uint64_t a2, CGColorSpace *a3, const __CFDictionary *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[6];
  _QWORD v14[6];
  _QWORD v15[7];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;

  if (a2)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a2 + 24) + 40);
    if (a3)
    {
LABEL_3:
      v5 = *(_QWORD *)(*((_QWORD *)a3 + 3) + 40);
      goto LABEL_6;
    }
  }
  else
  {
    v4 = 0;
    if (a3)
      goto LABEL_3;
  }
  v5 = 0;
LABEL_6:
  *(_QWORD *)(a1 + 120) = v4;
  *(_QWORD *)(a1 + 128) = v5;
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = a1;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = -1;
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = __iterate_with_params_block_invoke_2;
  v15[3] = &unk_1E165F190;
  v15[4] = &v20;
  v15[5] = v5;
  v15[6] = v4;
  v13[5] = &v20;
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = __iterate_with_params_block_invoke_3;
  v14[3] = &unk_1E165F1B8;
  v14[4] = &v20;
  v14[5] = &v16;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v13[2] = __iterate_with_params_block_invoke_4;
  v13[3] = &unk_1E165F1E0;
  v13[4] = &v16;
  v6 = CGColorConversionInfoIterateColorSpaceFunctionsWithCallbacksAndOptions(a2, a3, 0, (uint64_t)&__block_literal_global_24_12998, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 2u, 0, a4);
  if ((_DWORD)v6)
  {
    if (v5 >= 1)
    {
      v7 = -v5;
      v8 = 23;
      do
      {
        if (!*(_QWORD *)(v21[3] + 8 * v8))
          *(_QWORD *)(v21[3] + 8 * v8) = CGDisplayColorCurveCreateIdentity();
        ++v8;
      }
      while (v7 + v8 != 23);
    }
    if (v17[3] == -1)
    {
      v9 = v21[3];
      *(_OWORD *)(v9 + 136) = CGColorMatrixMakeIdentity_identity;
      *(_OWORD *)(v9 + 152) = unk_185002348;
      *(_OWORD *)(v9 + 168) = xmmword_185002358;
    }
    if (v4 >= 1)
    {
      v10 = -v4;
      v11 = 26;
      do
      {
        if (!*(_QWORD *)(v21[3] + 8 * v11))
          *(_QWORD *)(v21[3] + 8 * v11) = CGDisplayColorCurveCreateIdentity();
        ++v11;
      }
      while (v10 + v11 != 26);
    }
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v6;
}

uint64_t __iterate_with_params_block_invoke_2(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t j;
  uint64_t v10;
  const void *v11;
  char v12;
  int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  void *v19;
  uint64_t i;
  uint64_t v21;
  const void *v22;
  char v23;
  int Properties;
  float InputRange;
  float v26;
  float v27;
  float OutputRange;
  float v29;
  void *Identity;
  __int128 v32;
  __int128 v33;
  int v34;
  __int128 v35;
  __int128 v36;
  int v37;

  if (!a3)
  {
    if (a1[5] == a4)
    {
      if (a4 >= 1)
      {
        for (i = 0; i != a4; ++i)
        {
          v21 = *(_QWORD *)(a5 + 8 * i);
          if (v21 < 0)
          {
            Identity = CGDisplayColorCurveCreateIdentity();
          }
          else
          {
            v22 = *(const void **)(*(_QWORD *)(a2 + 52) + 8 * v21);
            v37 = 0;
            v35 = 0u;
            v36 = 0u;
            CGColorTRCGetFunction((uint64_t)v22, (uint64_t)&v35);
            if (CGColorTRCPureGammaOriginal_cglibrarypredicate != -1)
              dispatch_once(&CGColorTRCPureGammaOriginal_cglibrarypredicate, &__block_literal_global_9);
            v23 = CGColorTRCPureGammaOriginal_f(v22);
            Properties = CGColorFunctionGetProperties(v22);
            InputRange = CGColorFunctionGetInputRange(v22);
            v27 = v26;
            OutputRange = CGColorFunctionGetOutputRange(v22);
            v32 = v35;
            v33 = v36;
            v34 = v37;
            Identity = CGDisplayColorCurveCreate(&v32, v23, Properties, InputRange, v27, OutputRange, v29);
          }
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) + 8 * i + 184) = Identity;
        }
      }
      return 1;
    }
    return 0;
  }
  if (a1[6] != a4)
    return 0;
  if (a4 >= 1)
  {
    for (j = 0; j != a4; ++j)
    {
      v10 = *(_QWORD *)(a5 + 8 * j);
      if (v10 < 0)
      {
        v19 = CGDisplayColorCurveCreateIdentity();
      }
      else
      {
        v11 = *(const void **)(*(_QWORD *)(a2 + 52) + 8 * v10);
        v37 = 0;
        v35 = 0u;
        v36 = 0u;
        CGColorTRCGetFunction((uint64_t)v11, (uint64_t)&v35);
        if (CGColorTRCPureGammaOriginal_cglibrarypredicate != -1)
          dispatch_once(&CGColorTRCPureGammaOriginal_cglibrarypredicate, &__block_literal_global_9);
        v12 = CGColorTRCPureGammaOriginal_f(v11);
        v13 = CGColorFunctionGetProperties(v11);
        v14 = CGColorFunctionGetInputRange(v11);
        v16 = v15;
        v17 = CGColorFunctionGetOutputRange(v11);
        v32 = v35;
        v33 = v36;
        v34 = v37;
        v19 = CGDisplayColorCurveCreate(&v32, v12, v13, v14, v16, v17, v18);
      }
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) + 8 * j + 208) = v19;
    }
  }
  return 1;
}

BOOL __iterate_with_params_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  if (!a4)
  {
    v7 = **(_QWORD **)(a2 + 60);
    v12 = 0u;
    v13 = 0u;
    v11 = 0u;
    CGColorMatrixGetMatrix(v7, &v11);
    v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v9 = v12;
    *(_OWORD *)(v8 + 136) = v11;
    *(_OWORD *)(v8 + 152) = v9;
    *(_OWORD *)(v8 + 168) = v13;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a3;
  }
  return a4 == 0;
}

uint64_t __iterate_with_params_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v5;

  v5 = *(CFTypeRef *)(*(_QWORD *)(a2 + 68) + 8 * a4);
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == -1)
  {
    if (v5)
      v5 = CFRetain(v5);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 232) = v5;
  }
  else
  {
    if (v5)
      v5 = CFRetain(v5);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 240) = v5;
  }
  return 1;
}

BOOL __iterate_with_params_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(uint64_t *)(a2 + 36) <= 1 && *(_QWORD *)(a2 + 44) < 2;
}

CGColorSpaceRef __xsRGB_color_space_block_invoke()
{
  CGColorSpaceRef result;

  result = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceExtendedSRGB"));
  xsRGB_color_space_sRGB = (uint64_t)result;
  return result;
}

CGColorSpaceRef __xyz_color_space_block_invoke()
{
  CGColorSpaceRef result;

  result = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericXYZ"));
  xyz_color_space_xyz = (uint64_t)result;
  return result;
}

uint64_t __get_cache_block_invoke_13012()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  cache_attributes_t v7;
  pthread_mutexattr_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  get_cache_conversion_cache = (uint64_t)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040C6685353uLL);
  if (!get_cache_conversion_cache)
    _CGHandleAssert("get_cache_block_invoke", 467, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DisplayColorSpaceConversions/CGDisplayColorSpaceConversion.c", "conversion_cache != NULL", "conversion cache", v0, v1, v2, v7.version);
  v8.__sig = 0;
  *(_QWORD *)v8.__opaque = 0;
  pthread_mutexattr_init(&v8);
  pthread_mutexattr_settype(&v8, 2);
  pthread_mutex_init((pthread_mutex_t *)get_cache_conversion_cache, &v8);
  pthread_mutexattr_destroy(&v8);
  v7 = *(cache_attributes_t *)byte_1E165F0B8;
  if (cache_create("com.apple.CoreGraphics.display_colorspace_conversion_cache", &v7, (cache_t **)(get_cache_conversion_cache + 64)))
  {
    _CGHandleAssert("get_cache_block_invoke", 489, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DisplayColorSpaceConversions/CGDisplayColorSpaceConversion.c", "cacheErr == 0", "cache creation failed", v3, v4, v5, v7.version);
  }
  return cache_set_count_hint();
}

uint64_t conversion_params_data_key_hash(uint64_t a1)
{
  __int128 v1;
  _OWORD v3[3];
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v1 = *(_OWORD *)(a1 + 16);
  v3[0] = *(_OWORD *)a1;
  v3[1] = v1;
  v3[2] = *(_OWORD *)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 48);
  return MEMORY[0x186DC26D0](v3, 52);
}

BOOL conversion_params_data_key_is_equal(uint64_t a1, uint64_t a2)
{
  __int128 v7;
  __int128 v8;

  v8 = *(_OWORD *)(a1 + 16);
  v7 = *(_OWORD *)(a2 + 16);
  if ((_QWORD)v8 != (_QWORD)v7 || *((_QWORD *)&v8 + 1) != *((_QWORD *)&v7 + 1))
    return 0;
  if (*(_QWORD *)a1 != *(_QWORD *)a2 || *(_QWORD *)(a1 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  return *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
      && *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 40)
      && *(_DWORD *)(a1 + 48) == (unint64_t)*(unsigned int *)(a2 + 48);
}

_DWORD *conversion_params_data_key_retain(__int128 *a1, _QWORD *a2)
{
  _DWORD *result;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  result = malloc_type_malloc(0x34uLL, 0x10000403884A0CCuLL);
  if (result)
  {
    v5 = *a1;
    v6 = a1[1];
    v7 = a1[2];
    result[12] = *((_DWORD *)a1 + 12);
    *((_OWORD *)result + 1) = v6;
    *((_OWORD *)result + 2) = v7;
    *(_OWORD *)result = v5;
  }
  *a2 = result;
  return result;
}

void conversion_params_data_key_release(void *a1)
{
  if (a1)
    free(a1);
}

void conversion_params_data_value_release(uint64_t a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)a1))
      pthread_cond_destroy((pthread_cond_t *)(a1 + 64));
    CGColorCurveRelease(*(_QWORD *)(a1 + 184));
    CGColorCurveRelease(*(_QWORD *)(a1 + 192));
    CGColorCurveRelease(*(_QWORD *)(a1 + 200));
    CGColorCurveRelease(*(_QWORD *)(a1 + 208));
    CGColorCurveRelease(*(_QWORD *)(a1 + 216));
    CGColorCurveRelease(*(_QWORD *)(a1 + 224));
    v2 = *(const void **)(a1 + 232);
    if (v2)
      CFRelease(v2);
    v3 = *(const void **)(a1 + 240);
    if (v3)
      CFRelease(v3);
    free((void *)a1);
  }
}

uint64_t conversion_params_data_make_nonpurgeable()
{
  return 1;
}

char *CGColorSpaceGetConversionMatrix@<X0>(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  CGColorSpace *v5;
  char *result;
  void *v7;
  __int128 v8;

  *a3 = CGColorMatrixMakeIdentity_identity;
  a3[1] = unk_185002348;
  a3[2] = xmmword_185002358;
  switch(a2)
  {
    case 0:
    case 2:
      if (xyz_color_space_predicate != -1)
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
      v5 = (CGColorSpace *)a1;
      a1 = xyz_color_space_xyz;
      break;
    case 1:
    case 3:
      if (xyz_color_space_predicate != -1)
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
      v5 = (CGColorSpace *)xyz_color_space_xyz;
      break;
    default:
      v5 = 0;
      a1 = 0;
      break;
  }
  result = (char *)conversion_cache_get_retained_conversion_params(a1, v5, 0);
  if (result)
  {
    v7 = result;
    v8 = *(_OWORD *)(result + 152);
    *a3 = *(_OWORD *)(result + 136);
    a3[1] = v8;
    a3[2] = *(_OWORD *)(result + 168);
    if (get_cache_predicate_12980 != -1)
      dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
    return (char *)cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v7);
  }
  return result;
}

unsigned int *CGColorSpaceCreateConversionCurve(uint64_t a1, unint64_t a2, int a3)
{
  CGColorSpace *v6;
  void *retained_conversion_params;
  void *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  void *v13;

  switch(a3)
  {
    case 0:
    case 2:
      if (xyz_color_space_predicate != -1)
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
      v6 = (CGColorSpace *)a1;
      a1 = xyz_color_space_xyz;
      break;
    case 1:
    case 3:
      if (xyz_color_space_predicate != -1)
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_31_12987);
      v6 = (CGColorSpace *)xyz_color_space_xyz;
      break;
    default:
      v6 = 0;
      a1 = 0;
      break;
  }
  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, v6, 0);
  v8 = retained_conversion_params;
  switch(a3)
  {
    case 0:
    case 2:
      if (!retained_conversion_params || *((_QWORD *)retained_conversion_params + 16) <= a2)
        goto LABEL_22;
      v9 = (unsigned int *)*((_QWORD *)retained_conversion_params + a2 + 23);
      if (v9)
      {
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      if (get_cache_predicate_12980 != -1)
        goto LABEL_24;
      goto LABEL_21;
    case 1:
    case 3:
      if (!retained_conversion_params || *((_QWORD *)retained_conversion_params + 15) <= a2)
        goto LABEL_22;
      v9 = (unsigned int *)*((_QWORD *)retained_conversion_params + a2 + 26);
      if (v9)
      {
        do
          v11 = __ldxr(v9);
        while (__stxr(v11 + 1, v9));
      }
      if (get_cache_predicate_12980 != -1)
      {
LABEL_24:
        v13 = retained_conversion_params;
        dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
        v8 = v13;
      }
LABEL_21:
      cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v8);
      break;
    default:
LABEL_22:
      v9 = 0;
      break;
  }
  return v9;
}

unsigned int *CGDisplayColorSpaceConversionCreateLinearizationCurve(uint64_t a1, CGColorSpace *a2, unint64_t a3, __int128 *a4)
{
  void *retained_conversion_params;
  void *v6;
  unsigned int *v7;
  unsigned int v8;

  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a4);
  if (!retained_conversion_params)
    return 0;
  v6 = retained_conversion_params;
  if (*((_QWORD *)retained_conversion_params + 16) <= a3)
    return 0;
  v7 = (unsigned int *)*((_QWORD *)retained_conversion_params + a3 + 23);
  if (v7)
  {
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v6);
  return v7;
}

uint64_t CGDisplayColorSpaceConversionCreatePreMatrixToneMapping(uint64_t a1, CGColorSpace *a2, __int128 *a3)
{
  void *retained_conversion_params;
  void *v4;
  uint64_t v5;

  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a3);
  if (!retained_conversion_params)
    return 0;
  v4 = retained_conversion_params;
  v5 = *((_QWORD *)retained_conversion_params + 29);
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v4);
  return v5;
}

char *CGDisplayColorSpaceConversionGetConversionMatrix@<X0>(uint64_t a1@<X0>, CGColorSpace *a2@<X1>, __int128 *a3@<X2>, _OWORD *a4@<X8>)
{
  char *result;
  void *v6;
  __int128 v7;

  *a4 = CGColorMatrixMakeIdentity_identity;
  a4[1] = unk_185002348;
  a4[2] = xmmword_185002358;
  result = (char *)conversion_cache_get_retained_conversion_params(a1, a2, a3);
  if (result)
  {
    v6 = result;
    v7 = *(_OWORD *)(result + 152);
    *a4 = *(_OWORD *)(result + 136);
    a4[1] = v7;
    a4[2] = *(_OWORD *)(result + 168);
    if (get_cache_predicate_12980 != -1)
      dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
    return (char *)cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v6);
  }
  return result;
}

uint64_t CGDisplayColorSpaceConversionCreatePostMatrixToneMapping(uint64_t a1, CGColorSpace *a2, __int128 *a3)
{
  void *retained_conversion_params;
  void *v4;
  uint64_t v5;

  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a3);
  if (!retained_conversion_params)
    return 0;
  v4 = retained_conversion_params;
  v5 = *((_QWORD *)retained_conversion_params + 30);
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v4);
  return v5;
}

unsigned int *CGDisplayColorSpaceConversionCreateInvertedLinearizationCurve(uint64_t a1, CGColorSpace *a2, unint64_t a3, __int128 *a4)
{
  void *retained_conversion_params;
  void *v6;
  unsigned int *v7;
  unsigned int v8;

  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a4);
  if (!retained_conversion_params)
    return 0;
  v6 = retained_conversion_params;
  if (*((_QWORD *)retained_conversion_params + 15) <= a3)
    return 0;
  v7 = (unsigned int *)*((_QWORD *)retained_conversion_params + a3 + 26);
  if (v7)
  {
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  if (get_cache_predicate_12980 != -1)
    dispatch_once(&get_cache_predicate_12980, &__block_literal_global_12981);
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v6);
  return v7;
}

uint64_t type4_value_add(double *a1, uint64_t a2, double *a3)
{
  int v3;
  BOOL v4;
  int v5;
  int v6;
  double v7;
  double v8;
  double v10;

  if (*(_DWORD *)a2 == 258)
  {
    if (*(_DWORD *)a3 == 258)
    {
      v10 = *(double *)(a2 + 8) + a3[1];
      goto LABEL_15;
    }
    if (*(_DWORD *)a3 == 257)
    {
      v7 = (double)*((int *)a3 + 2);
      v8 = *(double *)(a2 + 8);
LABEL_13:
      v10 = v8 + v7;
      goto LABEL_15;
    }
    return 0;
  }
  if (*(_DWORD *)a2 != 257)
    return 0;
  v3 = *(_DWORD *)a3;
  if (*(_DWORD *)a3 == 258)
  {
    v7 = (double)*(int *)(a2 + 8);
    v8 = a3[1];
    goto LABEL_13;
  }
  v4 = __OFSUB__(v3, 257);
  if (v3 != 257)
    return 0;
  v5 = *(_DWORD *)(a2 + 8);
  v6 = *((_DWORD *)a3 + 2);
  if ((v6 | v5) < 0)
  {
    if ((v6 & v5) < 0 == v4 || (int)(0x80000000 - v6) <= v5)
      goto LABEL_21;
  }
  else if ((v6 ^ 0x7FFFFFFF) >= v5)
  {
LABEL_21:
    *(_DWORD *)a1 = 257;
    *((_DWORD *)a1 + 2) = v6 + v5;
    return 1;
  }
  v10 = (double)v5 + (double)v6;
LABEL_15:
  *(_DWORD *)a1 = 258;
  a1[1] = v10;
  return 1;
}

uint64_t type4_value_sub(double *a1, double *a2, uint64_t a3)
{
  signed int v3;
  int v4;
  double v5;
  double v7;
  double v8;

  if (*(_DWORD *)a2 != 258)
  {
    if (*(_DWORD *)a2 == 257)
    {
      if (*(_DWORD *)a3 == 258)
      {
        v7 = (double)*((int *)a2 + 2);
        v8 = *(double *)(a3 + 8);
LABEL_19:
        v5 = v7 - v8;
        goto LABEL_20;
      }
      if (*(_DWORD *)a3 == 257)
      {
        v3 = *((_DWORD *)a2 + 2);
        v4 = *(_DWORD *)(a3 + 8);
        if (v3 < 0 || (v4 & 0x80000000) == 0)
        {
          if ((v3 & 0x80000000) == 0 || v4 < 0 || (v4 | 0x80000000) <= v3)
            goto LABEL_22;
        }
        else if (v4 + 0x7FFFFFFF >= v3)
        {
LABEL_22:
          *(_DWORD *)a1 = 257;
          *((_DWORD *)a1 + 2) = v3 - v4;
          return 1;
        }
        v7 = (double)v3;
        v8 = (double)v4;
        goto LABEL_19;
      }
    }
    return 0;
  }
  if (*(_DWORD *)a3 == 258)
  {
    v5 = a2[1] - *(double *)(a3 + 8);
  }
  else
  {
    if (*(_DWORD *)a3 != 257)
      return 0;
    v5 = a2[1] - (double)*(int *)(a3 + 8);
  }
LABEL_20:
  *(_DWORD *)a1 = 258;
  a1[1] = v5;
  return 1;
}

uint64_t type4_value_mul(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  double v5;
  double v6;
  double v8;
  uint64_t v9;

  if (*(_DWORD *)a2 == 258)
  {
    if (*(_DWORD *)a3 == 258)
    {
      v8 = *(double *)(a2 + 8) * *(double *)(a3 + 8);
      goto LABEL_14;
    }
    if (*(_DWORD *)a3 != 257)
      return 0;
    v5 = (double)*(int *)(a3 + 8);
    v6 = *(double *)(a2 + 8);
LABEL_12:
    v8 = v6 * v5;
LABEL_14:
    *(_DWORD *)a1 = 258;
    *(double *)(a1 + 8) = v8;
    return 1;
  }
  if (*(_DWORD *)a2 != 257)
    return 0;
  if (*(_DWORD *)a3 == 258)
  {
    v5 = (double)*(int *)(a2 + 8);
    v6 = *(double *)(a3 + 8);
    goto LABEL_12;
  }
  if (*(_DWORD *)a3 != 257)
    return 0;
  v3 = *(_DWORD *)(a2 + 8);
  v4 = *(_DWORD *)(a3 + 8);
  if (((v4 + 0x8000) | (v3 + 0x8000)) >> 16)
  {
    v9 = v4 * (uint64_t)v3;
    if (v9 == (int)v9)
    {
      *(_DWORD *)a1 = 257;
      *(_DWORD *)(a1 + 8) = v9;
      return 1;
    }
    v8 = (double)v9;
    goto LABEL_14;
  }
  *(_DWORD *)a1 = 257;
  *(_DWORD *)(a1 + 8) = v4 * v3;
  return 1;
}

BOOL type4_value_equal(uint64_t a1, uint64_t a2)
{
  int v2;
  _BOOL8 result;
  int v5;

  if ((*(_DWORD *)a1 - 257) >= 2)
  {
    if (*(_DWORD *)a1 != 256 || *(_DWORD *)a2 != 256)
      return 0;
    return *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
  }
  else
  {
    v5 = 0;
    v2 = type4_value_compare(&v5, a1, (double *)a2);
    result = 0;
    if (!v2)
      return result;
    return v5 == 0;
  }
}

uint64_t type4_value_compare(int *a1, uint64_t a2, double *a3)
{
  int v3;
  double v4;
  double v5;

  if (*(_DWORD *)a2 == 258)
  {
    if (*(_DWORD *)a3 != 258)
    {
      if (*(_DWORD *)a3 != 257)
        return 0;
      v4 = *(double *)(a2 + 8);
      v5 = (double)*((int *)a3 + 2);
LABEL_13:
      if (v4 >= v5)
        v3 = v4 > v5;
      else
        v3 = -1;
      goto LABEL_16;
    }
    v4 = *(double *)(a2 + 8);
LABEL_12:
    v5 = a3[1];
    goto LABEL_13;
  }
  if (*(_DWORD *)a2 != 257)
    return 0;
  if (*(_DWORD *)a3 == 258)
  {
    v4 = (double)*(int *)(a2 + 8);
    goto LABEL_12;
  }
  if (*(_DWORD *)a3 != 257)
    return 0;
  v3 = *(_DWORD *)(a2 + 8) - *((_DWORD *)a3 + 2);
LABEL_16:
  *a1 = v3;
  return 1;
}

uint64_t type4_value_cvi(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  double v5;
  uint64_t result;
  unsigned int v7;
  double __y;

  if (*(_DWORD *)a2 != 258)
  {
    if (*(_DWORD *)a2 != 257)
      return 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    return 1;
  }
  __y = 0.0;
  modf(*(long double *)(a2 + 8), &__y);
  v5 = __y;
  if (__y < -2147483650.0)
  {
    result = 1;
    *a3 = 1;
    *(_DWORD *)a1 = 257;
    v7 = 0x80000000;
LABEL_9:
    *(_DWORD *)(a1 + 8) = v7;
    return result;
  }
  if (__y > 2147483650.0)
  {
    result = 1;
    *a3 = 1;
    *(_DWORD *)a1 = 257;
    v7 = 0x7FFFFFFF;
    goto LABEL_9;
  }
  *a3 = 0;
  *(_DWORD *)a1 = 257;
  *(_DWORD *)(a1 + 8) = (int)v5;
  return 1;
}

void CGPDFGroupRelease(CGColorSpaceRef *a1)
{
  if (a1)
  {
    CGColorSpaceRelease(a1[12]);
    free(a1);
  }
}

unsigned int *CGDisplayColorCurveCreateIdentity()
{
  unsigned int *result;
  unsigned int v1;

  if (CGDisplayColorCurveCreateIdentity_predicate != -1)
    dispatch_once(&CGDisplayColorCurveCreateIdentity_predicate, &__block_literal_global_13075);
  result = (unsigned int *)CGDisplayColorCurveCreateIdentity_curve;
  if (CGDisplayColorCurveCreateIdentity_curve)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

unsigned int *CGColorCurveRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

char *CGDisplayColorCurveCreate(_DWORD *a1, char a2, int a3, float a4, float a5, float a6, float a7)
{
  char *v14;
  char *v15;
  float v16;
  __int128 v17;
  int v18;
  __int128 v19;
  _DWORD *v20;
  unint64_t v21;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v26;
  __int128 v27;
  int v28;

  v14 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x10C2040536035A7uLL);
  v15 = v14;
  if (v14)
  {
    pthread_mutex_init((pthread_mutex_t *)(v14 + 80), 0);
    *(_DWORD *)v15 = 1;
    *((_DWORD *)v15 + 1) = 4;
    v15[60] = a2;
    *((_DWORD *)v15 + 10) = a3;
    *((float *)v15 + 11) = a4;
    *((float *)v15 + 12) = a5;
    *((float *)v15 + 13) = a6;
    *((float *)v15 + 14) = a7;
    v16 = *(float *)a1;
    switch(*a1)
    {
      case 0:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = 1065353216;
        *((_QWORD *)v15 + 2) = 0;
        *((_QWORD *)v15 + 3) = 0;
        *((_DWORD *)v15 + 8) = 0;
        *((_DWORD *)v15 + 16) = a1[1];
        return v15;
      case 1:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 7) = 0;
        *((float *)v15 + 6) = (float)-*((float *)a1 + 3) / *((float *)a1 + 2);
        *((_DWORD *)v15 + 5) = 0;
        *((_DWORD *)v15 + 8) = 0;
        return v15;
      case 2:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = 0;
        *((float *)v15 + 6) = (float)-*((float *)a1 + 3) / *((float *)a1 + 2);
        *((_DWORD *)v15 + 7) = a1[4];
        *((_DWORD *)v15 + 8) = a1[4];
        return v15;
      case 3:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = a1[4];
        *((_DWORD *)v15 + 6) = a1[5];
        *((_DWORD *)v15 + 7) = 0;
        *((_DWORD *)v15 + 8) = 0;
        v17 = *((_OWORD *)a1 + 1);
        v26 = *(_OWORD *)a1;
        v27 = v17;
        v28 = a1[8];
        if (trc_equal_trc((uint64_t)&v26, (uint64_t)&sRGB_curve))
        {
          v18 = 1074580685;
          goto LABEL_20;
        }
        v23 = *((_OWORD *)a1 + 1);
        v26 = *(_OWORD *)a1;
        v27 = v23;
        v28 = a1[8];
        if (!trc_equal_trc((uint64_t)&v26, (uint64_t)&itu_r_709_curve))
          return v15;
        v18 = 1072902963;
        goto LABEL_20;
      case 4:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = a1[4];
        *((_DWORD *)v15 + 6) = a1[5];
        *((_DWORD *)v15 + 7) = a1[6];
        *((_DWORD *)v15 + 8) = a1[7];
        v19 = *((_OWORD *)a1 + 1);
        v26 = *(_OWORD *)a1;
        v27 = v19;
        v28 = a1[8];
        if (trc_equal_trc((uint64_t)&v26, (uint64_t)&inverted_sRGB_curve))
        {
          v18 = 1055439407;
        }
        else
        {
          v24 = *((_OWORD *)a1 + 1);
          v26 = *(_OWORD *)a1;
          v27 = v24;
          v28 = a1[8];
          if (!trc_equal_trc((uint64_t)&v26, (uint64_t)&inverted_itu_r_709_curve))
            return v15;
          v18 = 1057406114;
        }
LABEL_20:
        *((_DWORD *)v15 + 16) = v18;
        break;
      case 5:
        *((_DWORD *)v15 + 1) = 5;
        v20 = malloc_type_malloc(4 * *(_QWORD *)(a1 + 1), 0x100004052888210uLL);
        *((_QWORD *)v15 + 9) = v20;
        if (v20)
        {
          if (*(_QWORD *)(a1 + 1))
          {
            v21 = 0;
            do
            {
              v20[v21] = *(_DWORD *)(*(_QWORD *)(a1 + 3) + 4 * v21);
              ++v21;
              v22 = *(_QWORD *)(a1 + 1);
            }
            while (v21 < v22);
          }
          else
          {
            v22 = 0;
          }
          *((_QWORD *)v15 + 1) = v22;
        }
        *((_QWORD *)v15 + 2) = v20;
        return v15;
      case 6:
      case 7:
      case 8:
      case 9:
        v15[60] = 0;
        *((float *)v15 + 1) = v16;
        *((_DWORD *)v15 + 2) = 0;
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = a1[4];
        *((_DWORD *)v15 + 6) = a1[5];
        *((_DWORD *)v15 + 7) = a1[6];
        *((_DWORD *)v15 + 8) = a1[7];
        *((_DWORD *)v15 + 16) = 0;
        return v15;
      default:
        abort();
    }
  }
  return v15;
}

BOOL trc_equal_trc(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)a1 != 5
      && *(_DWORD *)a1 == *(_DWORD *)a2
      && vabds_f32(*(float *)(a1 + 4), *(float *)(a2 + 4)) < 0.0005
      && vabds_f32(*(float *)(a1 + 8), *(float *)(a2 + 8)) < 0.0005
      && vabds_f32(*(float *)(a1 + 12), *(float *)(a2 + 12)) < 0.0005
      && vabds_f32(*(float *)(a1 + 16), *(float *)(a2 + 16)) < 0.0005
      && vabds_f32(*(float *)(a1 + 20), *(float *)(a2 + 20)) < 0.0005
      && vabds_f32(*(float *)(a1 + 24), *(float *)(a2 + 24)) < 0.0005
      && vabds_f32(*(float *)(a1 + 28), *(float *)(a2 + 28)) < 0.0005;
}

void CGColorCurveRelease(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;

  if (a1)
  {
    do
    {
      v2 = __ldxr((unsigned int *)a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, (unsigned int *)a1));
    if (!v3)
    {
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 80));
      free(*(void **)(a1 + 72));
      free((void *)a1);
    }
  }
}

BOOL CGColorCurveEqualToGammaCurve(uint64_t a1, uint64_t a2)
{
  _BOOL8 v2;
  unsigned int v3;
  uint64_t v4;
  float *v5;
  float *v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  BOOL v13;

  v2 = 0;
  if (a1 && a2)
  {
    if (a1 == a2)
      return 1;
    v3 = *(_DWORD *)(a1 + 4);
    if (v3 != *(_DWORD *)(a2 + 4) || v3 > 9)
      return 0;
    if (v3 != 5)
    {
      if (*(float *)(a1 + 12) == *(float *)(a2 + 12)
        && *(float *)(a1 + 16) == *(float *)(a2 + 16)
        && *(float *)(a1 + 20) == *(float *)(a2 + 20)
        && *(float *)(a1 + 24) == *(float *)(a2 + 24)
        && *(float *)(a1 + 28) == *(float *)(a2 + 28)
        && *(float *)(a1 + 32) == *(float *)(a2 + 32))
      {
        return *(float *)(a1 + 8) == *(float *)(a2 + 8);
      }
      return 0;
    }
    v4 = *(_QWORD *)(a1 + 8);
    if (v4 != *(_QWORD *)(a2 + 8))
      return 0;
    if (!v4)
      return 1;
    v5 = *(float **)(a1 + 16);
    v6 = *(float **)(a2 + 16);
    v7 = v4 - 1;
    do
    {
      v8 = *v5++;
      v9 = v8;
      v10 = *v6++;
      v11 = v10;
      v13 = v7-- != 0;
      v2 = v9 == v11;
    }
    while (v9 == v11 && v13);
  }
  return v2;
}

float get_gamma(uint64_t a1)
{
  uint64_t v2;
  int v3;
  float v4;
  int v5;
  unint64_t v6;
  float v7;
  __int128 v8;
  float v9;
  float v10;
  float v11;
  double v12;
  int v14;
  __int128 v15;
  __int128 v16;

  if (*(_BYTE *)(a1 + 60))
  {
    v2 = a1 + 8;
  }
  else
  {
    if (*(int *)(a1 + 4) <= 5)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
      if (*(float *)(a1 + 64) == 0.0)
      {
        v3 = *(_DWORD *)(a1 + 4);
        v4 = 0.0;
        if (v3 <= 5)
        {
          v5 = 0;
          v6 = 0;
          v7 = 0.0;
          do
          {
            v14 = v3;
            v8 = *(_OWORD *)(a1 + 24);
            v15 = *(_OWORD *)(a1 + 8);
            v16 = v8;
            calculate_trc((uint64_t)&v14, (float)v6 / 1023.0);
            if (v6)
            {
              v10 = v9;
              if (v9 != 1.0 && v6 != 1023 && v9 != 0.0)
              {
                v11 = logf((float)v6 / 1023.0);
                v7 = v7 + (float)(logf(v10) / v11);
                ++v5;
              }
            }
            ++v6;
          }
          while (v6 != 1024);
          if (v5 <= 0)
            v12 = 1.0;
          else
            v12 = (float)(v7 / (float)v5);
          v4 = floor(v12 * 10.0 + 0.5) / 10.0;
        }
        *(float *)(a1 + 64) = v4;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 80));
    }
    v2 = a1 + 64;
  }
  return *(float *)v2;
}

void calculate_trc(uint64_t a1, float a2)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;

  switch(*(_DWORD *)a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      v3 = *(float *)(a1 + 20);
      if (v3 <= a2)
        fmaxf(*(float *)(a1 + 28) + (float)(v3 * *(float *)(a1 + 16)), powf(*(float *)(a1 + 12) + (float)(a2 * *(float *)(a1 + 8)), *(float *)(a1 + 4)) + *(float *)(a1 + 24));
      break;
    case 6:
      v4 = powf(fabsf(a2), *(float *)(a1 + 8));
      powf(fmaxf(v4 - *(float *)(a1 + 16), 0.0) / (float)(*(float *)(a1 + 20) - (float)(*(float *)(a1 + 24) * v4)), *(float *)(a1 + 12));
      break;
    case 7:
      v5 = powf(fabsf(a2) * *(float *)(a1 + 28), *(float *)(a1 + 8));
      v6 = (float)(*(float *)(a1 + 16) + (float)(*(float *)(a1 + 20) * v5)) / ((float)(v5 * *(float *)(a1 + 24)) + 1.0);
      powf(v6, *(float *)(a1 + 12));
      break;
    case 8:
      v8 = *(float *)(a1 + 28) + (float)((float)(1.0 - *(float *)(a1 + 28)) * fabsf(a2));
      if (v8 >= 0.0 && v8 > 0.5)
        expf((float)(v8 - *(float *)(a1 + 16)) / *(float *)(a1 + 8));
      break;
    case 9:
      v7 = fabsf(*(float *)(a1 + 24) * a2);
      if (v7 > *(float *)(a1 + 20))
        log(-(*(float *)(a1 + 12) - v7 * 12.0));
      break;
    default:
      return;
  }
}

uint64_t CGColorCurveOriginalIsPureGamma(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 60);
}

void CGColorCurveGetParameters(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, float *a8)
{
  unsigned int v16;
  float gamma;

  v16 = *(_DWORD *)(a1 + 4);
  if (v16 < 5)
  {
    *a2 = *(_DWORD *)(a1 + 24);
    *a3 = *(_DWORD *)(a1 + 12);
    *a4 = *(_DWORD *)(a1 + 16);
    *a5 = *(_DWORD *)(a1 + 28);
    *a6 = *(_DWORD *)(a1 + 20);
    *a7 = *(_DWORD *)(a1 + 32);
    gamma = *(float *)(a1 + 8);
LABEL_5:
    *a8 = gamma;
    return;
  }
  if (v16 - 6 < 4)
  {
    *a2 = *(_DWORD *)(a1 + 24);
    *a3 = *(_DWORD *)(a1 + 12);
    *a4 = *(_DWORD *)(a1 + 16);
    *a5 = *(_DWORD *)(a1 + 28);
    *a6 = *(_DWORD *)(a1 + 20);
    *a7 = *(_DWORD *)(a1 + 32);
    *a8 = 0.0;
    return;
  }
  if (v16 == 5)
  {
    CGPostError((uint64_t)"%s: CGColorCurve type kCGColorTRCTable used as parametric. Returning estimated gamma", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, (char)"CGColorCurveGetParameters");
    *a2 = 0;
    *a3 = 1065353216;
    *a4 = 0;
    *a5 = 0;
    *a6 = 0;
    *a7 = 0;
    gamma = get_gamma(a1);
    goto LABEL_5;
  }
  CGPostError((uint64_t)"%s: CGColorCurve type %d is not supprted", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, (char)"CGColorCurveGetParameters");
}

__n128 CGColorCurveGetTRC@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a1 + 4);
  v3 = *(_OWORD *)(a1 + 20);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 36);
  return result;
}

uint64_t CGColorCurveGetProperties(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

float CGColorCurveGetInputRange(uint64_t a1)
{
  return *(float *)(a1 + 44);
}

float CGColorCurveGetOutputRange(uint64_t a1)
{
  return *(float *)(a1 + 52);
}

void CGColorCurveMapValue(uint64_t a1, float a2)
{
  __int128 v2;
  _OWORD v3[2];
  int v4;

  v2 = *(_OWORD *)(a1 + 20);
  v3[0] = *(_OWORD *)(a1 + 4);
  v3[1] = v2;
  v4 = *(_DWORD *)(a1 + 36);
  calculate_trc((uint64_t)v3, a2);
}

uint64_t CGColorCurvePrint(uint64_t a1)
{
  uint64_t result;

  switch(*(_DWORD *)(a1 + 4))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      result = printf("%s: d:%f | gamma:%f | c:%f f:%f | a:%f b:%f e:%f");
      break;
    case 5:
      result = printf("%s: table with %zu entries\n");
      break;
    case 6:
    case 7:
    case 8:
    case 9:
      result = printf("%s: %s a:%f | b:%f | c:%f | d:%f | e:%f | f:%f");
      break;
    default:
      result = printf("%s: unknown curve type\n");
      break;
  }
  return result;
}

void CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const CGPath *v13;
  CGContextRef v18;

  if (!c)
  {
    v18 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextAddQuadCurveToPoint", (uint64_t)v18, v6, v7, v8, v9, v10, v11);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v18 = c;
    goto LABEL_8;
  }
  v13 = (const CGPath *)*((_QWORD *)c + 21);
  if (v13 && !CGPathIsEmpty(v13))
    CGPathAddQuadCurveToPoint(*((CGMutablePathRef *)c + 21), (const CGAffineTransform *)(*((_QWORD *)c + 12) + 24), cpx, cpy, x, y);
  else
    CGPostError((uint64_t)"%s: no current point.", v5, v6, v7, v8, v9, v10, v11, (char)"CGContextAddQuadCurveToPoint");
}

void CGContextAddRects(CGContextRef c, const CGRect *rects, size_t count)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CGPath *Mutable;
  CGContextRef v12;

  if (!c)
  {
    v12 = 0;
LABEL_10:
    handle_invalid_context((char)"CGContextAddRects", (uint64_t)v12, count, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v12 = c;
    goto LABEL_10;
  }
  if (rects && count)
  {
    Mutable = (CGPath *)*((_QWORD *)c + 21);
    if (!Mutable)
    {
      Mutable = CGPathCreateMutable();
      *((_QWORD *)c + 21) = Mutable;
    }
    CGPathAddRects(Mutable, (const CGAffineTransform *)(*((_QWORD *)c + 12) + 24), rects, count);
  }
}

void CGContextAddLines(CGContextRef c, const CGPoint *points, size_t count)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CGPath *Mutable;
  CGContextRef v12;

  if (!c)
  {
    v12 = 0;
LABEL_10:
    handle_invalid_context((char)"CGContextAddLines", (uint64_t)v12, count, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v12 = c;
    goto LABEL_10;
  }
  if (points && count)
  {
    Mutable = (CGPath *)*((_QWORD *)c + 21);
    if (!Mutable)
    {
      Mutable = CGPathCreateMutable();
      *((_QWORD *)c + 21) = Mutable;
    }
    CGPathAddLines(Mutable, (const CGAffineTransform *)(*((_QWORD *)c + 12) + 24), points, count);
  }
}

void CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGPath *Mutable;
  CGContextRef v19;

  if (!c)
  {
    v19 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextAddArcToPoint", (uint64_t)v19, v6, v7, v8, v9, v10, v11);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v19 = c;
    goto LABEL_8;
  }
  Mutable = (CGPath *)*((_QWORD *)c + 21);
  if (!Mutable)
  {
    Mutable = CGPathCreateMutable();
    *((_QWORD *)c + 21) = Mutable;
  }
  CGPathAddArcToPoint(Mutable, (const CGAffineTransform *)(*((_QWORD *)c + 12) + 24), x1, y1, x2, y2, radius);
}

BOOL CGContextIsPathEmpty(CGContextRef c)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const CGPath *v7;

  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    v7 = (const CGPath *)*((_QWORD *)c + 21);
    if (v7)
      return CGPathIsEmpty(v7);
  }
  else
  {
    handle_invalid_context((char)"CGContextIsPathEmpty", (uint64_t)c, v1, v2, v3, v4, v5, v6);
  }
  return 1;
}

CGPoint CGContextGetPathCurrentPoint(CGContextRef c)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const CGPath *v9;
  CGContextRef v10;
  double v11;
  double v12;
  CGPoint CurrentPoint;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD v23[3];
  CGPoint result;

  if (!c)
  {
    v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextGetPathCurrentPoint", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
    goto LABEL_9;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v10 = c;
    goto LABEL_8;
  }
  v9 = (const CGPath *)*((_QWORD *)c + 21);
  if (!v9 || CGPathIsEmpty(v9))
  {
    CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGContextGetPathCurrentPoint");
LABEL_9:
    v11 = 0.0;
    v12 = 0.0;
    goto LABEL_12;
  }
  CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*((_QWORD *)c + 21));
  v14 = *((_QWORD *)c + 12);
  v15 = *(_OWORD *)(v14 + 40);
  v23[0] = *(_OWORD *)(v14 + 24);
  v23[1] = v15;
  v23[2] = *(_OWORD *)(v14 + 56);
  v11 = CGPointApplyInverseAffineTransform((double *)v23, v16, v17, v18, v19, v20, v21, v22, CurrentPoint.x, CurrentPoint.y);
LABEL_12:
  result.y = v12;
  result.x = v11;
  return result;
}

CGRect CGContextGetPathBoundingBox(CGContextRef c)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const CGPath *v9;
  CGContextRef v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t v15;
  __int128 v16;
  _OWORD v17[3];
  CGRect BoundingBox;
  CGRect result;

  if (!c)
  {
    v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextGetPathBoundingBox", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
    goto LABEL_9;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v10 = c;
    goto LABEL_8;
  }
  v9 = (const CGPath *)*((_QWORD *)c + 21);
  if (!v9 || CGPathIsEmpty(v9))
  {
    CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGContextGetPathBoundingBox");
LABEL_9:
    v11 = 0.0;
    v12 = INFINITY;
    v13 = INFINITY;
    v14 = 0.0;
    goto LABEL_12;
  }
  BoundingBox = CGPathGetBoundingBox((CGPathRef)*((_QWORD *)c + 21));
  v15 = *((_QWORD *)c + 12);
  v16 = *(_OWORD *)(v15 + 40);
  v17[0] = *(_OWORD *)(v15 + 24);
  v17[1] = v16;
  v17[2] = *(_OWORD *)(v15 + 56);
  v13 = CGRectApplyInverseAffineTransform((double *)v17, *(__n64 *)&BoundingBox.origin.x, BoundingBox.origin.y, BoundingBox.size.width, BoundingBox.size.height).n64_f64[0];
LABEL_12:
  result.size.height = v14;
  result.size.width = v11;
  result.origin.y = v12;
  result.origin.x = v13;
  return result;
}

_QWORD *__draw_path_block_invoke(_QWORD *result, int *a2, _BYTE *a3)
{
  int v3;
  int v4;
  uint64_t v5;

  v3 = *a2;
  if (*a2 == 4)
  {
    v5 = result[7];
LABEL_8:
    ++*(_DWORD *)(*(_QWORD *)(v5 + 8) + 24);
    goto LABEL_11;
  }
  if (v3 == 1)
  {
    v5 = result[6];
    goto LABEL_8;
  }
  if (v3)
  {
    ++*(_DWORD *)(*(_QWORD *)(result[8] + 8) + 24);
LABEL_10:
    *a3 = 1;
    goto LABEL_11;
  }
  v4 = ++*(_DWORD *)(*(_QWORD *)(result[4] + 8) + 24);
  if (v4 != 1)
  {
    if (v4 < 2)
      goto LABEL_11;
    goto LABEL_10;
  }
  *(_OWORD *)(*(_QWORD *)(result[5] + 8) + 24) = *(_OWORD *)*((_QWORD *)a2 + 1);
LABEL_11:
  *(_QWORD *)(*(_QWORD *)(result[9] + 8) + 24) = a2;
  return result;
}

__n128 __draw_path_block_invoke_2(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  __n128 *v6;
  __n128 result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  const void *v13;

  if (*(_DWORD *)a2 == 4)
    v6 = (__n128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  else
    v6 = *(__n128 **)(a2 + 8);
  result = *v6;
  v8 = *(_QWORD *)(a1 + 72);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v10 = *(_QWORD *)(v9 + 24);
  *(_QWORD *)(v9 + 24) = v10 + 1;
  *(__n128 *)(v8 + 16 * v10) = result;
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  if (v11 >= 0x80)
  {
    CGPathAddLines(*(CGMutablePathRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24), 0, *(const CGPoint **)(a1 + 72), v11);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8)+ 24));
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    v13 = *(const void **)(v12 + 24);
    if (v13)
    {
      CFRelease(v13);
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    }
    *(_QWORD *)(v12 + 24) = 0;
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24))
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
      *a3 = 1;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = CGPathCreateMutable();
      result = *(__n128 *)*(_QWORD *)(a2 + 8);
      *(__n128 *)*(_QWORD *)(a1 + 72) = result;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
    }
  }
  return result;
}

void CGContextClipToMaskWithTransform(uint64_t a1, __CFData *image, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  __CFData *v22;
  __CFData *mask_from_image;
  uint64_t v25;
  uint64_t v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double *v43;
  unsigned int *v44;
  const void *v45;
  double v46;
  double v47;

  if (!a1)
  {
    v25 = 0;
LABEL_25:
    handle_invalid_context((char)"CGContextClipToMaskWithTransform", v25, (uint64_t)a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v25 = a1;
    goto LABEL_25;
  }
  if (a9 != INFINITY && a10 != INFINITY)
  {
    v22 = image;
    if (!image)
      goto LABEL_34;
    if ((*((_BYTE *)image + 39) & 2) != 0)
    {
      mask_from_image = 0;
    }
    else
    {
      mask_from_image = create_mask_from_image(image, (uint64_t)image, (uint64_t)a3, a4, a5, a6, a7, a8);
      v22 = mask_from_image;
      if (!mask_from_image)
      {
LABEL_34:
        v45 = *(const void **)(a1 + 168);
        if (v45)
        {
          CFRelease(v45);
          *(_QWORD *)(a1 + 168) = 0;
        }
        return;
      }
    }
    v26 = *(_QWORD *)(a1 + 96);
    v28 = *(double *)(v26 + 24);
    v27 = *(double *)(v26 + 32);
    v30 = *(double *)(v26 + 40);
    v29 = *(double *)(v26 + 48);
    v31 = *(double *)(v26 + 64);
    if (a3)
    {
      v32 = a3[1];
      v33 = a3[2];
      v34 = a3[3];
      v35 = a3[4];
      v36 = a3[5];
      v37 = v32 * v30;
      v38 = v30 * v36;
      v30 = v34 * v30 + v33 * v28;
      v39 = v38 + v35 * v28;
      v28 = v37 + *a3 * v28;
      v40 = v32 * v29;
      v41 = v29 * v36;
      v29 = v34 * v29 + v33 * v27;
      v42 = v41 + v35 * v27;
      v27 = v40 + *a3 * v27;
      v46 = *(double *)(v26 + 56) + v39;
      v31 = v42 + v31;
    }
    else
    {
      v46 = *(double *)(v26 + 56);
    }
    v47 = v31;
    v43 = (double *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
    *(_DWORD *)v43 = 1;
    v43[1] = v28;
    v43[2] = v27;
    v43[3] = v30;
    v43[4] = v29;
    v43[5] = v46;
    v43[6] = v47;
    CFRetain(v22);
    *((_QWORD *)v43 + 7) = v22;
    v43[8] = a9;
    v43[9] = a10;
    v43[10] = a11;
    v43[11] = a12;
    v44 = CGClipCreateWithMask((unsigned int *)v43, HIBYTE(*(_DWORD *)(*(_QWORD *)(v26 + 120) + 4)) & 1);
    CGClipMaskRelease((unsigned int *)v43);
    if (v44)
    {
      maybeCopyClipState(v26);
      CGClipStackAddClip(*(_QWORD *)(v26 + 112), (uint64_t)v44);
      CGClipRelease((char *)v44);
    }
    if (mask_from_image)
      CFRelease(mask_from_image);
    goto LABEL_34;
  }
}

void CGContextClipToRects(CGContextRef c, const CGRect *rects, size_t count)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CGContextRef v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!c)
  {
    v11 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextClipToRects", (uint64_t)v11, count, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v11 = c;
    goto LABEL_7;
  }
  if (count == 1)
  {
    CGContextClipToRect(c, *rects);
  }
  else
  {
    v12 = (const void *)*((_QWORD *)c + 21);
    if (v12)
    {
      CFRelease(v12);
      *((_QWORD *)c + 21) = 0;
    }
    CGContextAddRects(c, rects, count);
    clip((uint64_t)c, 0, v13, v14, v15, v16, v17, v18);
  }
}

BOOL CGContextPathContainsPoint(CGContextRef c, CGPoint point, CGPathDrawingMode mode)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const CGPath *v10;
  CGFloat y;
  CGFloat x;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  int v21;
  unsigned int v22;
  CGContextRef v23;
  const CGAffineTransform *v25;
  const CGPath *stroked_path;
  CGPoint v28;
  CGPoint v29;

  if (!c)
  {
    v23 = 0;
LABEL_12:
    handle_invalid_context((char)"CGContextPathContainsPoint", (uint64_t)v23, v3, v4, v5, v6, v7, v8);
LABEL_13:
    LOBYTE(v22) = 0;
    return v22;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v23 = c;
    goto LABEL_12;
  }
  v10 = (const CGPath *)*((_QWORD *)c + 21);
  if (!v10)
    goto LABEL_13;
  y = point.y;
  x = point.x;
  if (CGPathIsEmpty(v10))
    goto LABEL_13;
  v19 = *((_QWORD *)c + 12);
  v20 = *(double *)(*(_QWORD *)(v19 + 128) + 8);
  if (v20 > 0.0 || v20 == -1.0905473e16)
  {
    LOBYTE(v22) = 0;
    v21 = 0;
    switch(mode)
    {
      case kCGPathFill:
        goto LABEL_21;
      case kCGPathEOFill:
        v21 = 0;
        LOBYTE(v22) = 1;
        goto LABEL_21;
      case kCGPathStroke:
        v25 = (const CGAffineTransform *)(v19 + 24);
        v21 = 1;
        goto LABEL_23;
      case kCGPathFillStroke:
        LOBYTE(v22) = 0;
        goto LABEL_20;
      case kCGPathEOFillStroke:
        LOBYTE(v22) = 1;
LABEL_20:
        v21 = 1;
        goto LABEL_21;
      default:
        return v22;
    }
  }
  if (mode >= (kCGPathEOFillStroke|kCGPathEOFill) || ((0x1Bu >> mode) & 1) == 0)
    goto LABEL_13;
  v21 = 0;
  v22 = (0x16u >> mode) & 1;
LABEL_21:
  v25 = (const CGAffineTransform *)(v19 + 24);
  v28.x = x;
  v28.y = y;
  if (CGPathContainsPoint(*((CGPathRef *)c + 21), (const CGAffineTransform *)(v19 + 24), v28, v22))
  {
    LOBYTE(v22) = 1;
    return v22;
  }
LABEL_23:
  if (v20 == -1.0905473e16 || v21 == 0)
    goto LABEL_13;
  stroked_path = (const CGPath *)create_stroked_path(*((char **)c + 21), *((_QWORD **)c + 12), 1, v14, v15, v16, v17, v18);
  v29.x = x;
  v29.y = y;
  LOBYTE(v22) = CGPathContainsPoint(stroked_path, v25, v29, 0);
  if (stroked_path)
    CFRelease(stroked_path);
  return v22;
}

uint64_t create_stroked_path(char *DashedPath, _QWORD *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _anonymous_namespace_ *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v13;
  const double *v14;
  char *v15;
  uint64_t StrokedPath;

  v9 = (_anonymous_namespace_ *)(a2 + 3);
  v10 = a2[16];
  v11 = *(_QWORD *)(v10 + 32);
  if (v11)
  {
    v13 = *(_QWORD *)(v11 + 16);
    v14 = (const double *)(v11 + 24);
    if (!a3 || v13 != 2)
      goto LABEL_6;
    if (*v14 == 0.0)
    {
      DashedPath = 0;
    }
    else if (*(double *)(v11 + 32) != 0.0)
    {
LABEL_6:
      DashedPath = (char *)CGPathCreateDashedPath(DashedPath, (_anonymous_namespace_ *)(a2 + 3), v14, v13, a5, a6, a7, a8, *(double *)(v11 + 8));
      v10 = a2[16];
      v15 = DashedPath;
      goto LABEL_9;
    }
  }
  v15 = 0;
LABEL_9:
  StrokedPath = CGPathCreateStrokedPath(DashedPath, v9, (char)*(_WORD *)(v10 + 2), (*(__int16 *)(v10 + 2) >> 8), a5, a6, a7, a8, *(double *)(v10 + 8), *(double *)(v10 + 16), *(double *)(a2[18] + 8));
  if (v15)
    CFRelease(v15);
  return StrokedPath;
}

void CGContextReplacePathWithStrokedPath(CGContextRef c)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const CGPath *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t stroked_path;
  const void *v15;
  CGContextRef v16;

  if (!c)
  {
    v16 = 0;
LABEL_11:
    handle_invalid_context((char)"CGContextReplacePathWithStrokedPath", (uint64_t)v16, v1, v2, v3, v4, v5, v6);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v16 = c;
    goto LABEL_11;
  }
  v8 = (const CGPath *)*((_QWORD *)c + 21);
  if (v8 && !CGPathIsEmpty(v8))
  {
    stroked_path = create_stroked_path(*((char **)c + 21), *((_QWORD **)c + 12), 0, v9, v10, v11, v12, v13);
    v15 = (const void *)*((_QWORD *)c + 21);
    if (v15)
      CFRelease(v15);
    *((_QWORD *)c + 21) = stroked_path;
  }
}

void CGContextReplacePathWithClipPath(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  CGContextRef v10;
  CGRect ClipBoundingBox;

  if (!c)
  {
    v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextReplacePathWithClipPath", (uint64_t)v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    v10 = c;
    goto LABEL_8;
  }
  v9 = (const void *)*((_QWORD *)c + 21);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)c + 21) = 0;
  }
  ClipBoundingBox = CGContextGetClipBoundingBox(c);
  CGContextAddRect(c, ClipBoundingBox);
}

void CGContextReplacePathWithShapePath(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  CGMutablePathRef Mutable;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!a1)
  {
    v12 = 0;
LABEL_11:
    handle_invalid_context((char)"CGContextReplacePathWithShapePath", v12, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    v12 = a1;
    goto LABEL_11;
  }
  v10 = *(const void **)(a1 + 168);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 168) = 0;
  }
  if (a2)
  {
    v11 = a2[2];
    if ((_UNKNOWN *)v11 != &the_empty_shape && *(_DWORD *)(v11 + 4 * *(int *)(v11 + 4)) != 0x7FFFFFFF)
    {
      Mutable = CGPathCreateMutable();
      *(_QWORD *)(a1 + 168) = Mutable;
      CGPathAddRegion((uint64_t)Mutable, (_anonymous_namespace_ *)(*(_QWORD *)(a1 + 96) + 24), a2, v14, v15, v16, v17, v18);
    }
  }
}

int32x2_t *CPPDFContextCreate()
{
  int32x2_t *v0;
  int32x2_t *v1;
  const __CFAllocator *v2;
  const CFDictionaryValueCallBacks *v3;
  char *v4;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  void *v18;

  v0 = (int32x2_t *)malloc_type_malloc(0x930uLL, 0x10B0040402FB33CuLL);
  v1 = v0;
  if (v0)
  {
    v0[282] = 0;
    v0[257].i32[0] = 0;
    v0[284].i32[0] = 0;
    v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v0[280] = (int32x2_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
    v1[281] = (int32x2_t)CFDictionaryCreateMutable(v2, 0, 0, v3);
    v4 = (char *)malloc_type_malloc(0x188uLL, 0x10A00400C8B88DDuLL);
    *(_QWORD *)v4 = 0;
    *((_WORD *)v4 + 4) = 0;
    *((_QWORD *)v4 + 9) = 0xFFFFFFFF00000000;
    *((_DWORD *)v4 + 20) = 0;
    *((_QWORD *)v4 + 8) = CGPathCreateMutable();
    *(CGAffineTransform *)(v4 + 16) = CGAffineTransformIdentity;
    *((_OWORD *)v4 + 16) = 0u;
    *((_OWORD *)v4 + 17) = 0u;
    *((_OWORD *)v4 + 18) = xmmword_185004F00;
    *((_WORD *)v4 + 152) = 0;
    *(_QWORD *)(v4 + 316) = 0;
    *(_QWORD *)(v4 + 324) = 0;
    *(_QWORD *)(v4 + 308) = 0;
    *((_DWORD *)v4 + 83) = 0;
    __asm { FMOV            V4.2D, #1.0 }
    *((_OWORD *)v4 + 21) = _Q4;
    *((_QWORD *)v4 + 44) = 0;
    *((_QWORD *)v4 + 45) = 0;
    *(CGAffineTransform *)(v4 + 88) = CGAffineTransformIdentity;
    *((_QWORD *)v4 + 23) = 0;
    *((_QWORD *)v4 + 24) = 0;
    *((_QWORD *)v4 + 25) = 0x4059000000000000;
    *((_QWORD *)v4 + 31) = 0;
    *((_OWORD *)v4 + 13) = 0u;
    *((_OWORD *)v4 + 14) = 0u;
    v4[240] = 0;
    *((_QWORD *)v4 + 47) = 0;
    *((_QWORD *)v4 + 48) = 0;
    *((_QWORD *)v4 + 46) = 0;
    v1[5] = (int32x2_t)v4;
    v1[6] = 0;
    v1[268] = (int32x2_t)0xC8000000C8;
    v1[267].i32[0] = 43200;
    v10 = (char *)malloc_type_malloc(0xA8C0uLL, 0x480F97FFuLL);
    v1[264] = (int32x2_t)v10;
    v11 = v1[267].u32[0];
    v1[267].i32[1] = v11;
    v1[265] = (int32x2_t)v10;
    v1[266] = (int32x2_t)&v10[v11];
    v1[269].i32[0] = 0;
    v1[276] = 0;
    v1[262] = vdup_n_s32(0x7D0u);
    v1[261].i32[0] = 384000;
    v12 = (char *)malloc_type_malloc(0x5DC00uLL, 0x480F97FFuLL);
    v1[258] = (int32x2_t)v12;
    v13 = v1[261].u32[0];
    v1[261].i32[1] = v13;
    v1[259] = (int32x2_t)v12;
    v1[260] = (int32x2_t)&v12[v13];
    v1[263].i32[0] = 0;
    v1[274] = (int32x2_t)0xC8000000C8;
    v1[273].i32[0] = 36800;
    v14 = (char *)malloc_type_malloc(0x8FC0uLL, 0x480F97FFuLL);
    v1[270] = (int32x2_t)v14;
    v15 = v1[273].u32[0];
    v1[273].i32[1] = v15;
    v1[271] = (int32x2_t)v14;
    v1[272] = (int32x2_t)&v14[v15];
    v1[275].i32[0] = 0;
    v1[279] = (int32x2_t)CFDictionaryCreateMutable(v2, 0, 0, v3);
    v16 = malloc_type_calloc(0x3E9uLL, 0x34uLL, 0x10000403884A0CCuLL);
    v1[278] = (int32x2_t)v16;
    v1[277].i32[0] = 1001;
    v1[276] = (int32x2_t)0x100000004;
    if (v16)
    {
      v1[4].i32[0] = 2400;
      v17 = malloc_type_malloc(0x2580uLL, 0x100004052888210uLL);
      v1[283] = (int32x2_t)v17;
      if (v17)
      {
        v1[284] = 0;
        v1[285] = 0;
        v1[287] = (int32x2_t)CPMultiUnicodesCreate();
        v1[293] = 0;
        return v1;
      }
      free(*(void **)&v1[264]);
      free(*(void **)&v1[258]);
      free(*(void **)&v1[270]);
      v18 = (void *)v1[278];
      if (!v18)
        return 0;
    }
    else
    {
      free(*(void **)&v1[264]);
      free(*(void **)&v1[258]);
      v18 = (void *)v1[270];
    }
    free(v18);
    return 0;
  }
  return v1;
}

void CPPDFContextRelease(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  const void *v13;
  unint64_t i;
  const void *v15;
  const void *v16;
  const void *v17;

  free(*(void **)(a1 + 2264));
  v2 = *(_QWORD *)(a1 + 2256);
  if (v2)
  {
    do
    {
      v3 = *(_QWORD *)(v2 + 104);
      if (*(_QWORD *)v2)
        CFRelease(*(CFTypeRef *)v2);
      CGColorSpaceRelease(*(CGColorSpaceRef *)(v2 + 8));
      v4 = *(const void **)(v2 + 16);
      if (v4)
        CFRelease(v4);
      CGColorSpaceRelease(*(CGColorSpaceRef *)(v2 + 24));
      v5 = *(const void **)(v2 + 96);
      if (v5)
        CFRelease(v5);

      free((void *)v2);
      v2 = v3;
    }
    while (v3);
  }
  v6 = *(void **)(a1 + 2224);
  if (v6)
    free(v6);
  CFRelease(*(CFTypeRef *)(a1 + 2232));
  CFRelease(*(CFTypeRef *)(a1 + 2248));
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 2240), (CFDictionaryApplierFunction)freeFont, 0);
  CFRelease(*(CFTypeRef *)(a1 + 2240));
  v7 = *(_QWORD **)(a1 + 40);
  if (v7)
  {
    do
    {
      v8 = (_QWORD *)*v7;
      CPPDFGraphicStateReleaseElements((uint64_t)v7);
      free(v7);
      v7 = v8;
    }
    while (v8);
  }
  v9 = *(_QWORD **)(a1 + 48);
  if (v9)
  {
    do
    {
      v10 = (_QWORD *)*v9;
      free(v9);
      v9 = v10;
    }
    while (v10);
  }
  v11 = *(_QWORD *)(a1 + 2112);
  v12 = *(_QWORD *)(a1 + 2120);
  while (v11 < v12)
  {
    v13 = *(const void **)(v11 + 96);
    if (v13)
    {
      CFRelease(v13);
      v12 = *(_QWORD *)(a1 + 2120);
    }
    v11 += 216;
  }
  for (i = *(_QWORD *)(a1 + 2160); i < *(_QWORD *)(a1 + 2168); i += 184)
  {
    v15 = *(const void **)(i + 96);
    if (v15)
      CFRelease(v15);
    v16 = *(const void **)(i + 168);
    if (v16)
      CFRelease(v16);
  }
  free(*(void **)(a1 + 2064));
  free(*(void **)(a1 + 2112));
  free(*(void **)(a1 + 2160));
  CPMultiUnicodesRelease(*(void **)(a1 + 2296));
  v17 = *(const void **)(a1 + 2344);
  if (v17)
    CFRelease(v17);
  free((void *)a1);
}

void freeFont(uint64_t a1, void *a2)
{
  objc_msgSend(a2, "dispose");

}

void CPPDFContextSaveGState(uint64_t a1)
{
  _QWORD *v2;
  CGPathRef *v3;
  CGMutablePathRef MutableCopy;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  id v9;
  const void *v10;

  v3 = *(CGPathRef **)(a1 + 40);
  v2 = *(_QWORD **)(a1 + 48);
  if (v2)
    *(_QWORD *)(a1 + 48) = *v2;
  else
    v2 = malloc_type_malloc(0x188uLL, 0x10A00400C8B88DDuLL);
  memcpy(v2, v3, 0x188uLL);
  MutableCopy = CGPathCreateMutableCopy(v3[8]);
  v2[8] = MutableCopy;
  if (MutableCopy)
    CFRetain(MutableCopy);
  v5 = (const void *)v2[32];
  if (v5)
    CFRetain(v5);
  v6 = (const void *)v2[33];
  if (v6)
    CFRetain(v6);
  v7 = (const void *)v2[34];
  if (v7)
    CFRetain(v7);
  v8 = (const void *)v2[35];
  if (v8)
    CFRetain(v8);
  v9 = (id)v2[31];
  v10 = (const void *)v2[8];
  if (v10)
    CFRelease(v10);
  *((_DWORD *)v2 + 18) = 0;
  *v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v2;
}

void CPPDFContextRestoreGState(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  int v11;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    v3 = *(_QWORD *)v2;
    if (*(_QWORD *)v2)
    {
      if (*(_DWORD *)(v2 + 72))
      {
        v4 = *(_DWORD *)(a1 + 2212);
        v5 = *(_DWORD *)(a1 + 2216);
        if (v5 > v4)
        {
          v6 = *(_QWORD *)(a1 + 2224);
          if (v6)
          {
            v7 = (unsigned int *)(v6 + 52 * v4);
            v8 = *v7;
            if (!v7[2])
            {
LABEL_11:
              if (v8)
              {
                while (v5 > v8)
                {
                  v9 = v6 + 52 * v8;
                  v11 = *(_DWORD *)(v9 + 4);
                  v10 = (unsigned int *)(v9 + 4);
                  if (v11)
                  {
                    v8 = *(_DWORD *)(v6 + 52 * v8);
                    if (v8)
                      continue;
                  }
                  *v10 = v4;
                  break;
                }
              }
              if (v7)
              {
                v7[1] = 0;
                v7[2] = 0;
                *v7 = v8;
              }
              goto LABEL_18;
            }
            v4 = *(_DWORD *)(a1 + 2208);
            if (v4 + 3 < v5)
            {
              *(_DWORD *)(a1 + 2212) = v4;
              v7 = (unsigned int *)(v6 + 52 * v4);
              if (v5 <= v4)
                v7 = 0;
              *(_DWORD *)(a1 + 2208) = v4 + 3;
              goto LABEL_11;
            }
          }
        }
      }
LABEL_18:
      *(_QWORD *)v2 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 40) = v3;
      *(_QWORD *)(a1 + 48) = v2;
      CPPDFGraphicStateReleaseElements(v2);
    }
  }
}

double CPPDFContextConcatCTM(double *a1, double *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double result;
  double v13;
  double v14;
  double v15;
  double v16;

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = a2[4];
  v6 = a2[5];
  v7 = a1[2];
  v8 = a1[3];
  v9 = a1[4];
  v10 = a1[5];
  v11 = v2 * v9 + *a2 * v7;
  result = v2 * v10 + *a2 * v8;
  v13 = v4 * v9 + v3 * v7;
  v14 = v4 * v10 + v3 * v8;
  v15 = a1[6] + v9 * v6 + v5 * v7;
  v16 = v10 * v6 + v5 * v8 + a1[7];
  a1[2] = v11;
  a1[3] = result;
  a1[4] = v13;
  a1[5] = v14;
  a1[6] = v15;
  a1[7] = v16;
  return result;
}

uint64_t CPPDFContextAddPathToClip(uint64_t result, int a2)
{
  _DWORD *v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v2 = *(_DWORD **)(result + 40);
  if ((v2[19] & 0x80000000) == 0)
  {
    v3 = result;
    v4 = v2[18];
    v2[18] = v4 + 1;
    if (v4)
    {
      if (a2)
      {
        result = CPPDFClipBufferPush(v2[20], result + 2208);
        if ((_DWORD)result)
        {
          v5 = *(_DWORD *)(v3 + 2212);
          v6 = *(_DWORD *)(v3 + 2216);
          if (v6 > v5)
          {
            v7 = *(_QWORD *)(v3 + 2224);
            if (v7)
            {
              v8 = *(_DWORD *)(v7 + 52 * v5);
              if (v8 && v6 > v8)
                *(_DWORD *)(v7 + 52 * v8 + 4) = v5;
            }
          }
        }
      }
    }
    else
    {
      result = CPPDFClipBufferPush(v2[20], result + 2208);
    }
    v10 = *(_DWORD *)(v3 + 2216);
    if (*(_DWORD *)(v3 + 2208) < v10)
    {
      v11 = *(_DWORD *)(v3 + 2212);
      if (v10 > v11)
      {
        v12 = *(_QWORD *)(v3 + 2224);
        if (v12)
        {
          v13 = v12 + 52 * v11;
          v14 = *(unsigned int *)(v13 + 8);
          *(_DWORD *)(v13 + 4 * v14 + 12) = v2[19];
          *(_DWORD *)(v13 + 8) = v14 + 1;
          ++*(_DWORD *)(v3 + 2208);
        }
      }
    }
    v15 = *(_DWORD *)(v3 + 2212);
    v2[19] = -1;
    v2[20] = v15;
  }
  return result;
}

uint64_t CPPDFContextAddStroke(uint64_t a1)
{
  uint64_t result;

  result = CPPDFContextAddShape(a1, 1, 2);
  if ((_DWORD)result)
    return CPPDFContextAddPathToClip(a1, 1);
  return result;
}

uint64_t CPPDFContextAddShape(uint64_t a1, char a2, int a3)
{
  uint64_t v6;
  double x;
  double y;
  double width;
  double height;
  double v11;
  double v12;
  _BOOL4 v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  CGMutablePathRef Mutable;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *Style;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t CurrentMCID;
  CGRect PathBoundingBox;
  CGRect v31;

  if (!*(_QWORD *)(a1 + 2264))
    return 0;
  v6 = a1 + 40;
  PathBoundingBox = CGPathGetPathBoundingBox((CGPathRef)*(_QWORD *)(*(_QWORD *)(a1 + 40) + 64));
  x = PathBoundingBox.origin.x;
  y = PathBoundingBox.origin.y;
  width = PathBoundingBox.size.width;
  height = PathBoundingBox.size.height;
  if (a3 == 2
    && CGPathGetNumberOfPoints(*(char **)(*(_QWORD *)v6 + 64), *(int32x2_t *)&PathBoundingBox.origin.x) == 2
    && (width == 0.0 || height == 0.0))
  {
    v11 = *(double *)(a1 + 16);
    v12 = 0.03;
  }
  else
  {
    v11 = *(double *)(a1 + 16);
    v12 = 0.05;
  }
  v13 = width <= v11 * v12 && height <= *(double *)(a1 + 24) * v12;
  if (fabs(x) == INFINITY
    || fabs(y) == INFINITY
    || fabs(width) == INFINITY
    || fabs(height) == INFINITY
    || (v15 = *(_QWORD *)a1,
        v16 = *(_QWORD *)(a1 + 8),
        v17 = *(_QWORD *)(a1 + 24),
        v31.origin.x = x,
        v31.origin.y = y,
        v31.size.width = width,
        v31.size.height = height,
        !CGRectIntersectsRect(*(CGRect *)(&v11 - 2), v31) || v13))
  {
    v18 = *(const void **)(*(_QWORD *)v6 + 64);
    if (v18)
      CFRelease(v18);
    Mutable = CGPathCreateMutable();
    result = 0;
    *(_QWORD *)(*(_QWORD *)v6 + 64) = Mutable;
  }
  else
  {
    result = primitiveBufferMemoryCheck(a1, a1 + 2112);
    if ((_DWORD)result)
    {
      ++*(_DWORD *)(a1 + 2152);
      v20 = *(_QWORD *)(a1 + 2120);
      *(double *)v20 = x;
      *(double *)(v20 + 8) = y;
      *(double *)(v20 + 16) = width;
      *(double *)(v20 + 24) = height;
      *(_QWORD *)(v20 + 68) = *(_QWORD *)(a1 + 2272);
      v21 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)(v20 + 64) = *(_DWORD *)(v21 + 80);
      *(_QWORD *)(v20 + 96) = *(_QWORD *)(v21 + 64);
      if (a3 == 4)
        Style = 0;
      else
        Style = CPPDFStyleListGetStyle(a1);
      *(_QWORD *)(v20 + 80) = Style;
      *(_BYTE *)(v20 + 104) = a2;
      v23 = *(_OWORD *)(*(_QWORD *)v6 + 16);
      v24 = *(_OWORD *)(*(_QWORD *)v6 + 48);
      *(_OWORD *)(v20 + 128) = *(_OWORD *)(*(_QWORD *)v6 + 32);
      *(_OWORD *)(v20 + 144) = v24;
      *(_OWORD *)(v20 + 112) = v23;
      while (1)
      {
        v6 = *(_QWORD *)v6;
        if (!v6)
          break;
        if (*(_BYTE *)(v6 + 8))
        {
          v25 = *(_OWORD *)(v6 + 16);
          v26 = *(_OWORD *)(v6 + 48);
          *(_OWORD *)(v20 + 176) = *(_OWORD *)(v6 + 32);
          *(_OWORD *)(v20 + 192) = v26;
          *(_OWORD *)(v20 + 160) = v25;
          goto LABEL_30;
        }
      }
      *(CGAffineTransform *)(v20 + 160) = CGAffineTransformIdentity;
LABEL_30:
      *(_DWORD *)(v20 + 88) = a3;
      v27 = *(_QWORD *)(a1 + 2344);
      if (v27 && (v28 = *(_QWORD *)(v27 + 16)) != 0)
        CurrentMCID = TaggedParser::GetCurrentMCID(v28, *(CGPDFPage **)(a1 + 2288));
      else
        CurrentMCID = -1;
      *(_QWORD *)(v20 + 208) = CurrentMCID;
      *(_QWORD *)(a1 + 2120) = v20 + 216;
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64) = CGPathCreateMutable();
      *(_DWORD *)(*(_QWORD *)(a1 + 2264) + 4 * *(unsigned int *)(a1 + 2272)) = 0;
      *(int32x2_t *)(a1 + 2272) = vadd_s32(*(int32x2_t *)(a1 + 2272), (int32x2_t)0x100000001);
      return 1;
    }
  }
  return result;
}

uint64_t primitiveBufferMemoryCheck(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t result;
  int v6;
  int v7;
  int v8;
  size_t v9;
  uint64_t v10;
  void *v11;

  if (*(_QWORD *)(a2 + 8) < *(_QWORD *)(a2 + 16))
    return 1;
  v4 = *(_DWORD *)(a1 + 32) + *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 32) = v4;
  result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 2264), 4 * v4, 0x100004052888210uLL);
  *(_QWORD *)(a1 + 2264) = result;
  if (result)
  {
    v6 = *(_DWORD *)(a2 + 32);
    v7 = v6 + *(_DWORD *)(a2 + 36);
    v8 = *(_DWORD *)(a2 + 24);
    v9 = (v8 + *(_DWORD *)(a2 + 28));
    *(_DWORD *)(a2 + 24) = v9;
    *(_DWORD *)(a2 + 28) = v8;
    *(_DWORD *)(a2 + 32) = v7;
    *(_DWORD *)(a2 + 36) = v6;
    v10 = *(_QWORD *)(a2 + 16);
    v11 = *(void **)a2;
    result = (uint64_t)malloc_type_realloc(*(void **)a2, v9, 0xFF261EC3uLL);
    *(_QWORD *)a2 = result;
    if (result)
    {
      *(_QWORD *)(a2 + 8) = result + (v10 - (_DWORD)v11);
      *(_QWORD *)(a2 + 16) = result + v9;
      return 1;
    }
  }
  return result;
}

uint64_t CPPDFContextAddFill(uint64_t a1, char a2)
{
  uint64_t result;

  result = CPPDFContextAddShape(a1, a2, 1);
  if ((_DWORD)result)
    return CPPDFContextAddPathToClip(a1, 1);
  return result;
}

uint64_t CPPDFContextAddStrokeAndFill(uint64_t a1, char a2)
{
  uint64_t result;

  result = CPPDFContextAddShape(a1, a2, 3);
  if ((_DWORD)result)
    return CPPDFContextAddPathToClip(a1, 1);
  return result;
}

uint64_t CPPDFContextAddClip(uint64_t a1, char a2)
{
  int v3;
  uint64_t result;

  v3 = *(_DWORD *)(a1 + 2152);
  result = CPPDFContextAddShape(a1, a2, 4);
  if ((_DWORD)result)
  {
    result = CPPDFContextAddPathToClip(a1, 1);
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 76) = v3;
  }
  return result;
}

void CPPDFContextAddImage(uint64_t a1, __int128 *a2)
{
  _OWORD *v4;
  __int128 v5;
  uint64_t v6;
  double v7;
  double v8;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  double v12;
  CGFloat height;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  const void *v27;
  const void *v28;
  _OWORD *v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t CurrentMCID;
  CGAffineTransform v36;
  CGRect v37;
  CGRect v38;

  v4 = *(_OWORD **)(a1 + 40);
  v5 = v4[2];
  *(_OWORD *)&v36.a = v4[1];
  *(_OWORD *)&v36.c = v5;
  *(_OWORD *)&v36.tx = v4[3];
  v6 = 0;
  *(_QWORD *)&v5 = 0;
  v7 = 1.0;
  v8 = 1.0;
  v37 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v5 - 8), &v36);
  x = v37.origin.x;
  y = v37.origin.y;
  width = v37.size.width;
  if (fabs(*(double *)a1) != INFINITY)
  {
    height = v37.size.height;
    v14 = *(double *)(a1 + 8);
    if (fabs(v14) != INFINITY)
    {
      v15 = *(double *)(a1 + 16);
      if (fabs(v15) != INFINITY)
      {
        v16 = *(double *)(a1 + 24);
        if (fabs(v16) != INFINITY)
        {
          v38.origin.x = v37.origin.x;
          v38.origin.y = y;
          v38.size.width = width;
          v38.size.height = height;
          v12 = *(double *)a1;
          if (CGRectIntersectsRect(*(CGRect *)(&v14 - 1), v38))
          {
            if (primitiveBufferMemoryCheck(a1, a1 + 2160))
            {
              ++*(_DWORD *)(a1 + 2200);
              v17 = *(_QWORD *)(a1 + 2168);
              v18 = *a2;
              v19 = a2[1];
              v20 = a2[3];
              *(_OWORD *)(v17 + 32) = a2[2];
              *(_OWORD *)(v17 + 48) = v20;
              *(_OWORD *)(v17 + 16) = v19;
              v21 = a2[4];
              v22 = a2[5];
              v23 = a2[7];
              *(_OWORD *)(v17 + 96) = a2[6];
              *(_OWORD *)(v17 + 112) = v23;
              *(_OWORD *)(v17 + 64) = v21;
              *(_OWORD *)(v17 + 80) = v22;
              v24 = a2[8];
              v25 = a2[9];
              v26 = a2[10];
              *(_QWORD *)(v17 + 176) = *((_QWORD *)a2 + 22);
              *(_OWORD *)(v17 + 144) = v25;
              *(_OWORD *)(v17 + 160) = v26;
              *(_OWORD *)(v17 + 128) = v24;
              *(_OWORD *)v17 = v18;
              v27 = *(const void **)(v17 + 96);
              if (v27)
                CFRetain(v27);
              v28 = *(const void **)(v17 + 168);
              if (v28)
                CFRetain(v28);
              v29 = *(_OWORD **)(a1 + 40);
              v30 = v29[1];
              v31 = v29[2];
              *(_OWORD *)(v17 + 136) = v29[3];
              *(_OWORD *)(v17 + 120) = v31;
              *(_OWORD *)(v17 + 104) = v30;
              v32 = *(_QWORD *)(a1 + 40);
              *(_QWORD *)(v17 + 160) = *(_QWORD *)(v32 + 336);
              *(_QWORD *)(v17 + 68) = *(_QWORD *)(a1 + 2272);
              *(_DWORD *)(v17 + 64) = *(_DWORD *)(v32 + 80);
              *(CGFloat *)v17 = x;
              *(CGFloat *)(v17 + 8) = y;
              *(CGFloat *)(v17 + 16) = width;
              *(CGFloat *)(v17 + 24) = height;
              v33 = *(_QWORD *)(a1 + 2344);
              if (v33 && (v34 = *(_QWORD *)(v33 + 16)) != 0)
                CurrentMCID = TaggedParser::GetCurrentMCID(v34, *(CGPDFPage **)(a1 + 2288));
              else
                CurrentMCID = -1;
              *(_QWORD *)(v17 + 176) = CurrentMCID;
              *(_QWORD *)(a1 + 2168) = v17 + 184;
            }
            *(_DWORD *)(*(_QWORD *)(a1 + 2264) + 4 * (*(_DWORD *)(a1 + 2272))++) = 1;
          }
        }
      }
    }
  }
}

CGPath *CPPDFGetClipPathIntersection(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6;
  CGPath *Value;
  CGPath *Mutable;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  size_t v17;
  CFTypeRef *v18;
  CFTypeRef *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;

  *a3 = 1;
  v6 = a2;
  Value = (CGPath *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2232), (const void *)a2);
  Mutable = Value;
  if (!a2 || Value)
    return Mutable;
  v9 = *(_QWORD *)(a1 + 2224);
  v10 = v9 + 52 * v6;
  v13 = *(_DWORD *)(v10 + 8);
  v12 = (unsigned int *)(v10 + 8);
  v11 = v13;
  v14 = *(unsigned int *)(v9 + 52 * v6);
  if ((_DWORD)v14)
    v15 = (_DWORD)v14 == a2;
  else
    v15 = 1;
  v16 = !v15;
  if (v15)
    v17 = v11;
  else
    v17 = v11 + 1;
  if (!(_DWORD)v17)
    return 0;
  v18 = (CFTypeRef *)malloc_type_calloc(v17, 8uLL, 0x6004044C4A2DFuLL);
  v19 = v18;
  v20 = *v12;
  if ((_DWORD)v20)
  {
    v21 = 0;
    v22 = *(_QWORD *)(a1 + 2112);
    v23 = *(_DWORD *)(a1 + 2152);
    do
    {
      v24 = *(_DWORD *)(v9 + 52 * v6 + 12 + 4 * v21);
      if (v24 >= v23)
      {
        free(v18);
        return 0;
      }
      v18[v21++] = *(CFTypeRef *)(v22 + 216 * v24 + 96);
    }
    while (v20 != v21);
    if (!v16)
      goto LABEL_19;
  }
  else
  {
    v20 = 0;
    if (!v16)
      goto LABEL_19;
  }
  v18[v20] = (CFTypeRef)CPPDFGetClipPathIntersection(a1, v14, a3);
LABEL_19:
  if ((_DWORD)v17 == 1)
  {
    Mutable = (CGPath *)*v19;
    if (*v19)
      CFRetain(*v19);
  }
  else
  {
    Mutable = CGPathCreateMutable();
    CGPathAddIntersection(Mutable, (const CGPath **)v19, v17);
  }
  free(v19);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 2232), (const void *)v6, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return Mutable;
}

CGMutablePathRef CPPDFLazyContextAddShape(CGMutablePathRef result)
{
  CGMutablePathRef v1;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  const void *v9;
  CGRect PathBoundingBox;

  v1 = result;
  if (*((_QWORD *)result + 289) >= *((_QWORD *)result + 288))
  {
LABEL_15:
    *((_BYTE *)v1 + 2336) = 1;
    return result;
  }
  PathBoundingBox = CGPathGetPathBoundingBox((CGPathRef)*(_QWORD *)(*((_QWORD *)result + 5) + 64));
  x = PathBoundingBox.origin.x;
  y = PathBoundingBox.origin.y;
  if (fabs(PathBoundingBox.origin.x) == INFINITY
    || fabs(PathBoundingBox.origin.y) == INFINITY
    || (width = PathBoundingBox.size.width, fabs(PathBoundingBox.size.width) == INFINITY)
    || (height = PathBoundingBox.size.height, fabs(PathBoundingBox.size.height) == INFINITY)
    || !CGRectIntersectsRect(*(CGRect *)v1, *(CGRect *)&x))
  {
    v9 = *(const void **)(*((_QWORD *)v1 + 5) + 64);
    if (v9)
      CFRelease(v9);
    result = CGPathCreateMutable();
    *(_QWORD *)(*((_QWORD *)v1 + 5) + 64) = result;
  }
  else
  {
    v6 = *((_QWORD *)v1 + 289);
    v7 = *(const void **)(*((_QWORD *)v1 + 5) + 64);
    if (*((_DWORD *)v1 + 569) == *(_DWORD *)(*((_QWORD *)v1 + 290) + 4 * v6))
    {
      v8 = *((_QWORD *)v1 + 291);
      *((_QWORD *)v1 + 289) = v6 + 1;
      *(_QWORD *)(v8 + 8 * v6) = v7;
    }
    else if (v7)
    {
      CFRelease(v7);
    }
    result = CGPathCreateMutable();
    *(_QWORD *)(*((_QWORD *)v1 + 5) + 64) = result;
    ++*((_DWORD *)v1 + 569);
    if (*((_QWORD *)v1 + 289) == *((_QWORD *)v1 + 288))
      goto LABEL_15;
  }
  return result;
}

char *CGImageEPSRepCreate(CGDataProvider *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  int byte;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  __int128 v84;
  const char *v85;
  int v87;
  __int128 v88;
  __int128 v89;
  _QWORD v90[2];

  v11 = CGAccessSessionCreate(a1);
  v12 = 0;
  *(_QWORD *)&v88 = 0xFFFFFFFFLL;
  *((_QWORD *)&v88 + 1) = v11;
  while (v12 != 4)
  {
    v13 = byte_184F7FE18[v12];
    byte = read_byte((int *)&v88, v4, v5, v6, v7, v8, v9, v10);
    if (byte != -1)
    {
      ++v12;
      if (byte == v13)
        continue;
    }
    CGAccessSessionRewind((uint64_t)v11);
    goto LABEL_13;
  }
  v22 = read_byte((int *)&v88, v4, v5, v6, v7, v8, v9, v10);
  v30 = v22 | (read_byte((int *)&v88, v23, v24, v25, v26, v27, v28, v29) << 8);
  v38 = v30 | (read_byte((int *)&v88, v31, v32, v33, v34, v35, v36, v37) << 16);
  v46 = v38 | (read_byte((int *)&v88, v39, v40, v41, v42, v43, v44, v45) << 24);
  if (v46 >= 9)
  {
    v47 = (int)v46 - 9;
    while (read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21) != -1 && v47-- != 0)
      ;
  }
LABEL_13:
  v49 = 0;
  while (v49 != 2)
  {
    v50 = asc_185033790[v49];
    v51 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    if (v51 != -1)
    {
      ++v49;
      if (v51 == v50)
        continue;
    }
    goto LABEL_63;
  }
  do
  {
    do
      v52 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    while (v52 == 9);
  }
  while (v52 == 32);
  if (v52 != -1)
    LODWORD(v88) = v52;
  v53 = 0;
  while (v53 != 9)
  {
    v54 = aPsAdobe_0[v53];
    v55 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    if (v55 != -1)
    {
      ++v53;
      if (v55 == v54)
        continue;
    }
    goto LABEL_63;
  }
  if (read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21) - 52 < 0xFFFFFFFD)
    goto LABEL_63;
  v56 = 0;
  while (v56 != 1)
  {
    v57 = asc_18503379D[v56];
    v58 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    if (v58 != -1)
    {
      ++v56;
      if (v58 == v57)
        continue;
    }
    goto LABEL_63;
  }
  if (read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21) - 50 < 0xFFFFFFFE)
    goto LABEL_63;
  do
  {
    do
      v59 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    while (v59 == 9);
  }
  while (v59 == 32);
  if (v59 != -1)
    LODWORD(v88) = v59;
  v60 = 0;
  while (v60 != 5)
  {
    v61 = aEpsf[v60];
    v62 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    if (v62 != -1)
    {
      ++v60;
      if (v62 == v61)
        continue;
    }
    goto LABEL_63;
  }
  if (read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21) - 52 < 0xFFFFFFFD)
    goto LABEL_63;
  v63 = 0;
  while (v63 != 1)
  {
    v64 = asc_18503379D[v63];
    v65 = read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21);
    if (v65 != -1)
    {
      ++v63;
      if (v65 == v64)
        continue;
    }
    goto LABEL_63;
  }
  if (read_byte((int *)&v88, v15, v16, v17, v18, v19, v20, v21) - 48 >= 3)
  {
LABEL_63:
    v85 = "Failed to read EPSF header.";
LABEL_64:
    CGPostError((uint64_t)v85, v15, v16, v17, v18, v19, v20, v21, v88);
    CGAccessSessionRelease(v11);
    return 0;
  }
  v90[0] = 0xFFFFFFFFLL;
  v90[1] = v11;
  if (!match_anchored_string((int *)v90, v15, v16, v17, v18, v19, v20, v21))
  {
LABEL_70:
    v85 = "Failed to read EPS bounding box.";
    goto LABEL_64;
  }
  do
  {
    do
      v66 = read_byte((int *)v90, v15, v16, v17, v18, v19, v20, v21);
    while (v66 == 9);
  }
  while (v66 == 32);
  if (v66 != -1)
    LODWORD(v90[0]) = v66;
  v67 = 0;
  v88 = 0u;
  v89 = 0u;
  while (v67 != 7)
  {
    v68 = aAtend[v67];
    v69 = read_byte((int *)v90, v15, v16, v17, v18, v19, v20, v21);
    if (v69 != -1)
    {
      ++v67;
      if (v69 == v68)
        continue;
    }
    CGAccessSessionRewind((uint64_t)v11);
    match_anchored_string((int *)v90, v70, v71, v72, v73, v74, v75, v76);
    if (!get_bbox((int *)v90, (double *)&v88, v77, v78, v79, v80, v81, v82))
      goto LABEL_70;
    goto LABEL_60;
  }
  v87 = 0;
  while (match_anchored_string((int *)v90, v15, v16, v17, v18, v19, v20, v21))
    v87 |= get_bbox((int *)v90, (double *)&v88, v16, v17, v18, v19, v20, v21);
  if ((v87 & 1) == 0)
    goto LABEL_70;
LABEL_60:
  CGAccessSessionRelease(v11);
  v83 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
  *(_DWORD *)v83 = 1;
  CGDataProviderRetain(a1);
  *((_QWORD *)v83 + 1) = a1;
  if (a2)
    CFRetain(a2);
  *((_QWORD *)v83 + 2) = a2;
  v84 = v89;
  *(_OWORD *)(v83 + 24) = v88;
  *(_OWORD *)(v83 + 40) = v84;
  return v83;
}

uint64_t read_byte(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char v10;

  v8 = *a1;
  if (*a1 == -1)
  {
    v10 = 0;
    if (!CGAccessSessionGetBytes(*((uint64_t **)a1 + 1), &v10, 1uLL, a4, a5, a6, a7, a8))
      return 0xFFFFFFFFLL;
    LOBYTE(v8) = v10;
  }
  else
  {
    *a1 = -1;
  }
  return v8;
}

uint64_t match_anchored_string(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int byte;
  int v10;
  uint64_t v11;
  int v12;
  int v13;

BOOL get_bbox(int *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;

  v35 = 0.0;
  result = read_number(a1, &v35, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v34 = 0.0;
    result = read_number(a1, &v34, v11, v12, v13, v14, v15, v16);
    if (result)
    {
      v33 = 0.0;
      result = read_number(a1, &v33, v17, v18, v19, v20, v21, v22);
      if (result)
      {
        v32 = 0.0;
        result = read_number(a1, &v32, v23, v24, v25, v26, v27, v28);
        if (result)
        {
          v29 = v34;
          v30 = v33 - v35;
          v31 = v32 - v34;
          *a2 = v35;
          a2[1] = v29;
          a2[2] = v30;
          a2[3] = v31;
          return 1;
        }
      }
    }
  }
  return result;
}

BOOL read_number(int *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int byte;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v21;
  char v22[64];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  do
  {
    do
      byte = read_byte(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    while (byte == 9);
  }
  while (byte == 32);
  if (byte != -1)
    *a1 = byte;
  v11 = read_byte(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v11 == 45 || v11 == 43)
  {
    v22[0] = v11;
    v11 = read_byte(a1, v12, v13, v14, v15, v16, v17, v18);
    v19 = 1;
  }
  else
  {
    v19 = 0;
  }
  if (v11 - 58 < 0xFFFFFFF6)
    return 0;
  while (1)
  {
    v22[v19] = v11;
    v11 = read_byte(a1, v12, v13, v14, v15, v16, v17, v18);
    if (v11 == -1 || v19 > 0x3D)
      break;
    if (v11 <= 0x2E)
    {
      if (v11 == 46)
        goto LABEL_18;
      if (((1 << v11) & 0x100002600) != 0)
        break;
    }
    if (v11 - 58 < 0xFFFFFFF6)
      return 0;
LABEL_18:
    ++v19;
  }
  v21 = 0;
  v22[v19 + 1] = 0;
  *a2 = strtod_l(v22, &v21, 0);
  return v21 != v22;
}

unsigned int *CGImageEPSRepRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

uint64_t CGImageEPSRepGetSource(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t CGImageEPSRepGetAlternateImage(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

CGFloat CGImageEPSRepGetBBox(uint64_t a1)
{
  const CGRect *v1;

  v1 = &CGRectNull;
  if (a1)
    v1 = (const CGRect *)(a1 + 24);
  return v1->origin.x;
}

_BYTE *PDFWriteNumber(_BYTE *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  double v10;
  double v11;
  double v12;
  int v13;
  int v15;
  int v16;
  int i;

  v10 = fabs(a2);
  if (v10 == INFINITY)
  {
    LOBYTE(v13) = -1;
    if (a2 <= 0.0)
      LOBYTE(v13) = 0;
    return CGDataConsumerPrintf(a1, "%d", a4, a5, a6, a7, a8, a9, v13);
  }
  if (a2 >= -2147483650.0 && a2 <= 2147483650.0)
  {
    v11 = ceil(a2 + -0.5);
    v12 = floor(a2 + 0.5);
    if (a2 >= 0.0)
      v11 = v12;
    v13 = (int)v11;
    if (vabdd_f64(a2, (double)(int)v11) < 0.000001)
      return CGDataConsumerPrintf(a1, "%d", a4, a5, a6, a7, a8, a9, v13);
  }
  if (v10 >= 1.0)
  {
    if (v10 <= 10000000.0)
      return CGDataConsumerPrintf(a1, "%0.7g", a4, a5, a6, a7, a8, a9, SLOBYTE(a2));
    else
      return CGDataConsumerPrintf(a1, "%0.0f", a4, a5, a6, a7, a8, a9, SLOBYTE(a2));
  }
  else if (v10 >= 0.000001)
  {
    v15 = 0;
    v16 = 1;
    do
    {
      if (v10 * (double)v16 >= 1.0)
        break;
      v16 *= 10;
      ++v15;
    }
    while (v15 != 6);
    for (i = 0; i != 6; ++i)
    {
      if (vabdd_f64(v10 * (double)v16, round(v10 * (double)v16)) < 0.00001)
        break;
      v16 *= 10;
    }
    return CGDataConsumerPrintf(a1, "%0.*f", a4, a5, a6, a7, a8, a9, i + v15);
  }
  else
  {
    return CGDataConsumerPrintf(a1, "0", a4, a5, a6, a7, a8, a9, a10);
  }
}

_BYTE *PDFWriteCFData(_BYTE *a1, CFDataRef theData, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  char *BytePtr;
  CFIndex Length;
  CFIndex v14;
  BOOL v15;
  int v16;
  char *v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  char v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  char *v31;
  char v33;
  char v34;

  v9 = a3;
  if (!theData)
  {
    if ((_DWORD)a3)
      v17 = "<>";
    else
      v17 = "()";
    return CGDataConsumerPrintf(a1, v17, a3, a4, a5, a6, a7, a8, a9);
  }
  BytePtr = (char *)CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v14 = Length;
  if (BytePtr)
    v15 = Length == 0;
  else
    v15 = 1;
  v16 = v15;
  if (v9)
  {
    if (v16)
    {
      v17 = "<>";
      return CGDataConsumerPrintf(a1, v17, a3, a4, a5, a6, a7, a8, a9);
    }
    v25 = CGDataConsumerPrintf(a1, "<", a3, a4, a5, a6, a7, a8, v33);
    do
    {
      v26 = *BytePtr++;
      v25 = &v25[(_QWORD)CGDataConsumerPrintf(a1, "%02x", v19, v20, v21, v22, v23, v24, v26)];
      --v14;
    }
    while (v14);
    v27 = ">";
  }
  else
  {
    if (v16)
    {
      v17 = "()";
      return CGDataConsumerPrintf(a1, v17, a3, a4, a5, a6, a7, a8, a9);
    }
    v25 = CGDataConsumerPrintf(a1, "(", a3, a4, a5, a6, a7, a8, v33);
    v28 = MEMORY[0x1E0C80978];
    do
    {
      v30 = *BytePtr++;
      v29 = v30;
      if (v30 > 0x7E || (*(_DWORD *)(v28 + 4 * v29 + 60) & 0x40000) != 0)
      {
        if ((v29 - 40) <= 0x34 && ((1 << (v29 - 40)) & 0x10000000000003) != 0)
          v25 = &v25[(_QWORD)CGDataConsumerPrintf(a1, "\\", v19, v20, v21, v22, v23, v24, v34)];
        v31 = "%c";
      }
      else
      {
        v31 = "\\%03o";
      }
      v25 = &v25[(_QWORD)CGDataConsumerPrintf(a1, v31, v19, v20, v21, v22, v23, v24, v29)];
      --v14;
    }
    while (v14);
    v27 = ")";
  }
  return &v25[(_QWORD)CGDataConsumerPrintf(a1, v27, v19, v20, v21, v22, v23, v24, v34)];
}

CFCalendarRef PDFCreateDateString(uint64_t a1)
{
  const __CFAllocator *v2;
  CFCalendarRef result;
  __CFCalendar *v4;
  const __CFTimeZone *v5;
  const __CFTimeZone *v6;
  CFAbsoluteTime v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  result = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
  if (result)
  {
    v4 = result;
    v5 = CFTimeZoneCreateWithName(v2, CFSTR("GMT"), 1u);
    if (v5)
    {
      v6 = v5;
      CFCalendarSetTimeZone(v4, v5);
      CFRelease(v6);
      MEMORY[0x186DC15A8](a1);
      v10 = 0;
      v11 = 0;
      v9 = 0;
      v8 = 0;
      CFCalendarDecomposeAbsoluteTime(v4, v7, "yMdHms", (char *)&v11 + 4, &v11, (char *)&v10 + 4, &v10, &v9, &v8);
      CFRelease(v4);
      return (CFCalendarRef)CFStringCreateWithFormat(v2, 0, CFSTR("D:%04d%02d%02d%02d%02d%02dZ00'00'"), HIDWORD(v11), v11, HIDWORD(v10), v10, v9, v8);
    }
    else
    {
      CFRelease(v4);
      return 0;
    }
  }
  return result;
}

char *create_image(uint64_t a1, _QWORD *a2, const void *a3, int a4, char a5, const void *a6, int a7)
{
  char *v14;
  uint64_t v15;
  uint64_t v16;
  const void *Property;
  CGColorSpaceRef *v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  const void *v22;
  CGColorSpaceRef *v23;
  uint64_t v24;

  v14 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (!v14)
    return v14;
  *(_DWORD *)v14 = 1;
  *((_QWORD *)v14 + 1) = a1;
  if (a2)
    CFRetain(a2);
  *((_QWORD *)v14 + 6) = a2;
  if (a3)
    CFRetain(a3);
  *((_QWORD *)v14 + 8) = a3;
  v15 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
  *((_QWORD *)v14 + 2) = PDFStreamCreateWithObjectNumber(a1, v15);
  v14[72] = a5;
  *((_QWORD *)v14 + 7) = 0;
  *((_DWORD *)v14 + 11) = a4;
  if (!a2)
    goto LABEL_26;
  v16 = a2[27];
  if (!v16)
    goto LABEL_26;
  Property = CGPropertiesGetProperty(v16, CFSTR("com.apple.ImageIO.imageSourceTypeIdentifier"));
  if (!Property || !CFEqual(Property, CFSTR("public.jpeg")))
  {
LABEL_16:
    v21 = a2[27];
    if (v21)
    {
      v22 = CGPropertiesGetProperty(v21, CFSTR("com.apple.ImageIO.imageSourceTypeIdentifier"));
      if (v22)
      {
        if (CFEqual(v22, CFSTR("public.jpeg-2000")))
        {
          if (init_with_jpeg2000_data_predicate != -1)
            dispatch_once(&init_with_jpeg2000_data_predicate, &__block_literal_global_14_13312);
          v23 = (CGColorSpaceRef *)(v14 + 88);
          v24 = init_with_jpeg2000_data_f(a2, v14 + 88);
          *((_QWORD *)v14 + 10) = v24;
          if (v24)
          {
            v20 = 256;
            goto LABEL_23;
          }
          if (*v23)
            CGColorSpaceRelease(*v23);
        }
      }
    }
LABEL_26:
    *(_WORD *)(v14 + 73) = 0;
    *((_QWORD *)v14 + 10) = 0;
    *((_QWORD *)v14 + 11) = 0;
    goto LABEL_27;
  }
  if (init_with_jpeg_data_predicate != -1)
    dispatch_once(&init_with_jpeg_data_predicate, &__block_literal_global_13310);
  v18 = (CGColorSpaceRef *)(v14 + 88);
  v19 = init_with_jpeg_data_f(a2, v14 + 88);
  *((_QWORD *)v14 + 10) = v19;
  if (!v19)
  {
    if (*v18)
      CGColorSpaceRelease(*v18);
    goto LABEL_16;
  }
  v20 = 1;
LABEL_23:
  *(_WORD *)(v14 + 73) = v20;
LABEL_27:
  snprintf_l(v14 + 24, 0x10uLL, 0, "Im%d", a7);
  if (a6)
    *((_QWORD *)v14 + 12) = CFRetain(a6);
  *((_QWORD *)v14 + 13) = -1;
  return v14;
}

void *__init_with_jpeg2000_data_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (CGLibraryLoadImageIODYLD_once != -1)
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_4_19707);
  if (!CGLibraryLoadImageIODYLD_handle)
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageCopyJPEGDataAndColorSpace");
  result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageCopyJPEGDataAndColorSpace");
  if (!result)
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageCopyJPEGDataAndColorSpace");
  init_with_jpeg2000_data_f = result;
  return result;
}

void *__init_with_jpeg_data_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (CGLibraryLoadImageIODYLD_once != -1)
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_4_19707);
  if (!CGLibraryLoadImageIODYLD_handle)
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageCopyJPEGDataAndColorSpace");
  result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageCopyJPEGDataAndColorSpace");
  if (!result)
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageCopyJPEGDataAndColorSpace");
  init_with_jpeg_data_f = result;
  return result;
}

void PDFImageRelease(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;

  if (a1)
  {
    do
    {
      v2 = __ldxr((unsigned int *)a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, (unsigned int *)a1));
    if (!v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
        PDFStreamRelease(v4);
      v5 = *(const void **)(a1 + 64);
      if (v5)
        CFRelease(v5);
      v6 = *(const void **)(a1 + 48);
      if (v6)
        CFRelease(v6);
      v7 = *(const void **)(a1 + 80);
      if (v7)
        CFRelease(v7);
      CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 88));
      free((void *)a1);
    }
  }
}

uint64_t path_iterator_cull_create(uint64_t a1, unsigned int *a2)
{
  double *v4;
  unint64_t v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  unint64_t v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  double v17;
  double v18;
  double v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t result;
  unsigned int v23;

  v4 = (double *)malloc_type_malloc(0x50uLL, 0x2062DE7BuLL);
  v5 = *(_QWORD *)a1;
  v6 = *(double *)(a1 + 16);
  v7 = *(double *)(a1 + 24);
  if (v6 < 0.0 || v7 < 0.0)
  {
    v8 = *(_QWORD *)(a1 + 8);
    v5 = (unint64_t)CGRectStandardize(*(CGRect *)&v5);
  }
  *(_QWORD *)v4 = v5;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(double *)(a1 + 16);
  v11 = *(double *)(a1 + 24);
  if (v10 < 0.0 || v11 < 0.0)
  {
    v12 = *(_QWORD *)a1;
    *(CGRect *)(&v9 - 1) = CGRectStandardize(*(CGRect *)(&v9 - 1));
  }
  *((_QWORD *)v4 + 1) = v9;
  v13 = *(double *)a1;
  v14 = *(double *)(a1 + 16);
  v15 = *(double *)(a1 + 24);
  if (v14 < 0.0 || v15 < 0.0)
  {
    v16 = *(_QWORD *)(a1 + 8);
    *(CGRect *)&v13 = CGRectStandardize(*(CGRect *)&v13);
  }
  v4[2] = v13 + v14;
  v17 = *(double *)(a1 + 8);
  v18 = *(double *)(a1 + 16);
  v19 = *(double *)(a1 + 24);
  if (v18 < 0.0 || v19 < 0.0)
  {
    v20 = *(_QWORD *)a1;
    *(CGRect *)(&v17 - 1) = CGRectStandardize(*(CGRect *)(&v17 - 1));
  }
  v4[3] = v17 + v19;
  *((_BYTE *)v4 + 64) = 0;
  v21 = malloc_type_malloc(0x200uLL, 0x95C2046AuLL);
  *v21 = 0;
  v21[1] = 0;
  v21[2] = v21 + 64;
  v21[3] = ((unint64_t)v21 + 55) & 0xFFFFFFFFFFFFFFF8;
  v21[4] = 0;
  v21[5] = 464;
  *((_QWORD *)v4 + 9) = v21;
  result = operator new();
  *(_QWORD *)(result + 8) = v4;
  *(_OWORD *)(result + 16) = path_iterator_cull_create_callbacks;
  *(_OWORD *)(result + 32) = *(_OWORD *)&off_1E162CAF0;
  if (a2)
  {
    do
      v23 = __ldxr(a2);
    while (__stxr(v23 + 1, a2));
  }
  *(_QWORD *)(result + 48) = a2;
  *(_DWORD *)result = 1;
  return result;
}

_QWORD *path_cull_begin(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *result;
  uint64_t (*v7)(_QWORD, uint64_t, _QWORD);

  result = path_reset((_QWORD *)(a1 + 72));
  *(_BYTE *)(a1 + 64) = 0;
  if (a3)
  {
    v7 = (uint64_t (*)(_QWORD, uint64_t, _QWORD))a3[2];
    if (v7)
      return (_QWORD *)v7(a3[1], a2, a3[6]);
  }
  return result;
}

uint64_t path_cull_iterate(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  unsigned __int8 **v18;
  unsigned int v19;
  uint64_t v20;
  double *v21;
  uint64_t v22;
  _OWORD *v23;
  _OWORD *v24;

  v10 = result;
  switch(a2)
  {
    case -3:
      finish_subpath((float64x2_t *)result, a4);
      v17 = (_OWORD *)path_add((unsigned __int8 **)(v10 + 72), 0xFFFFFFFD, v11, v12, v13, v14, v15, v16);
      *v17 = *(_OWORD *)a3;
      v17[1] = *(_OWORD *)(a3 + 16);
      add_subpath_points(v10, (double *)a3, 2);
      goto LABEL_11;
    case 0:
      finish_subpath((float64x2_t *)result, a4);
      v18 = (unsigned __int8 **)(v10 + 72);
      v19 = 0;
      goto LABEL_5;
    case 1:
      v18 = (unsigned __int8 **)(result + 72);
      v19 = 1;
LABEL_5:
      *(_OWORD *)path_add(v18, v19, a3, a4, a5, a6, a7, a8) = *(_OWORD *)a3;
      v20 = v10;
      v21 = (double *)a3;
      v22 = 1;
      goto LABEL_8;
    case 2:
      v23 = (_OWORD *)path_add((unsigned __int8 **)(result + 72), 2u, a3, a4, a5, a6, a7, a8);
      *v23 = *(_OWORD *)a3;
      v23[1] = *(_OWORD *)(a3 + 16);
      v20 = v10;
      v21 = (double *)a3;
      v22 = 2;
      goto LABEL_8;
    case 3:
      v24 = (_OWORD *)path_add((unsigned __int8 **)(result + 72), 3u, a3, a4, a5, a6, a7, a8);
      *v24 = *(_OWORD *)a3;
      v24[1] = *(_OWORD *)(a3 + 16);
      v24[2] = *(_OWORD *)(a3 + 32);
      v20 = v10;
      v21 = (double *)a3;
      v22 = 3;
LABEL_8:
      result = add_subpath_points(v20, v21, v22);
      break;
    case 4:
      if (*(_BYTE *)(result + 64))
      {
        path_add((unsigned __int8 **)(result + 72), 4u, a3, a4, a5, a6, a7, a8);
LABEL_11:
        result = (uint64_t)finish_subpath((float64x2_t *)v10, a4);
      }
      break;
    default:
      abort();
  }
  return result;
}

float64x2_t *path_cull_end(float64x2_t *a1, _QWORD *a2)
{
  float64x2_t *result;
  uint64_t (*v4)(_QWORD, _QWORD);

  result = finish_subpath(a1, (uint64_t)a2);
  if (a2)
  {
    v4 = (uint64_t (*)(_QWORD, _QWORD))a2[4];
    if (v4)
      return (float64x2_t *)v4(a2[1], a2[6]);
  }
  return result;
}

void path_cull_release_info(void **a1)
{
  path_free(a1[9]);
  free(a1);
}

float64x2_t *finish_subpath(float64x2_t *result, uint64_t a2)
{
  float64x2_t *v2;
  int32x2_t v3;
  uint64_t v5;
  _QWORD v6[4];

  if (LOBYTE(result[4].f64[0]))
  {
    v2 = result;
    v3 = vmovn_s64(vcltzq_f64(vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(result[1], result[3]), (int8x16_t)result[3], (int8x16_t)result[1]), (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(result[2], *result), (int8x16_t)result[2], *(int8x16_t *)result))));
    if (((v3.i32[0] | v3.i32[1]) & 1) == 0 && a2 && *(_QWORD *)&result[4].f64[1])
    {
      v6[0] = *(_QWORD *)&result[4].f64[1];
      v6[1] = 4;
      v6[2] = 0;
      v6[3] = 0;
      while (1)
      {
        v5 = path_element((uint64_t)v6);
        if (!v5)
          break;
        (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a2 + 24))(*(_QWORD *)(a2 + 8), *(unsigned int *)(v5 + 8), *(_QWORD *)(v5 + 16), *(_QWORD *)(a2 + 48));
      }
    }
    result = (float64x2_t *)path_reset(&v2[4].f64[1]);
    LOBYTE(v2[4].f64[0]) = 0;
  }
  return result;
}

uint64_t add_subpath_points(uint64_t result, double *a2, uint64_t a3)
{
  int v3;
  double v4;
  double v5;
  __int128 v6;

  v3 = *(unsigned __int8 *)(result + 64);
  do
  {
    if (v3)
    {
      v4 = *a2;
      if (*a2 < *(double *)(result + 32))
        *(double *)(result + 32) = v4;
      if (v4 > *(double *)(result + 48))
        *(double *)(result + 48) = v4;
      v5 = a2[1];
      if (v5 < *(double *)(result + 40))
        *(double *)(result + 40) = v5;
      if (v5 > *(double *)(result + 56))
        *(double *)(result + 56) = v5;
    }
    else
    {
      v3 = 1;
      *(_BYTE *)(result + 64) = 1;
      v6 = *(_OWORD *)a2;
      *(_OWORD *)(result + 32) = *(_OWORD *)a2;
      *(_OWORD *)(result + 48) = v6;
    }
    a2 += 2;
    --a3;
  }
  while (a3);
  return result;
}

uint64_t argb32_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned int v43;
  unint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned __int8 *v50;
  unsigned int v51;
  unint64_t v52;
  unsigned __int8 *v53;
  unsigned __int8 *v54;
  unsigned int v55;
  unsigned __int8 *v56;
  unsigned __int8 *v57;
  unint64_t v58;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  int v61;
  char v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  char v67;
  unsigned int v68;
  unsigned __int8 *v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unsigned __int8 *v72;
  unsigned int v73;
  unsigned __int8 *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int8 *v82;
  uint64_t v83;
  unsigned __int8 *v84;
  unsigned __int8 *v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v91 = *(_QWORD *)(result + 80);
  v89 = *(_QWORD *)(result + 88);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v13 = 0;
  else
    v13 = -16777216;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  v87 = *(_DWORD *)(result + 188);
  v17 = v4 + v15 + (v14 * v6) - 1;
  v88 = *(_QWORD *)(result + 64);
  v90 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v90)
      {
        if (a3 <= v89)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
          v29 = v88;
          v30 = v91;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v89;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_43;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v29 = v88;
          v30 = v91;
          v27 = v87 | v25;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v90 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_43;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v29 = v88;
        v30 = v91;
        v27 = v87 | v21;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v29)
        break;
      v31 = *(_QWORD *)(result + 192);
      v32 = v29 - *(_QWORD *)(result + 200);
      v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v87;
        v34 = v32 + 0x1000000;
        v35 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v30)
    {
      v35 = ((unint64_t)a2 >> 26) & 0x3C;
      v34 = a2;
      goto LABEL_29;
    }
    v36 = *(_QWORD *)(result + 192);
    v37 = *(_QWORD *)(result + 200) + v30;
    v38 = v37 - a2 + (v36 >> 1);
    if (v38 < 1)
      goto LABEL_43;
    if (v38 < v36)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v38) >> 32) >> 15)) | v87;
    v34 = v37 - 0x1000000;
    v35 = 28;
LABEL_29:
    if (v27 < 0x400000)
      goto LABEL_43;
    v39 = v28 >> 32;
    v40 = v4 + (int)v39 * (uint64_t)v6 + (v34 >> 32);
    v41 = *(unsigned __int8 **)(result + 32);
    if (v17 >= v40)
      v42 = (unsigned __int8 *)(v4 + (int)v39 * (uint64_t)v6 + (v34 >> 32));
    else
      v42 = (unsigned __int8 *)v17;
    if (v42 < v41)
      v42 = *(unsigned __int8 **)(result + 32);
    v43 = *v42;
    if (v5)
    {
      v44 = v5 + (int)v39 * (uint64_t)v7 + (v34 >> 32);
      v45 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v44)
        v46 = (unsigned __int8 *)v44;
      else
        v46 = v16;
      if (v46 >= v45)
        v45 = v46;
      v43 |= *v45 << 24;
      if (!v8)
        goto LABEL_104;
    }
    else
    {
      v44 = 0;
      if (!v8)
        goto LABEL_104;
    }
    v47 = *(_DWORD *)(v8 + (v35 | v26));
LABEL_48:
    v48 = v47 & 0xF;
    v49 = HIBYTE(v47) & 3;
    switch(v48)
    {
      case 1:
        v69 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        if (v17 < (unint64_t)v69)
          v69 = (unsigned __int8 *)v17;
        if (v69 < v41)
          v69 = v41;
        v66 = *v69;
        if (v5)
        {
          v70 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v70)
            v70 = v16;
          if ((unint64_t)v70 < *(_QWORD *)(result + 40))
            v70 = *(unsigned __int8 **)(result + 40);
          v66 |= *v70 << 24;
        }
        v64 = interpolate_8888_19472[v49];
        v67 = v49 + 1;
        v68 = v43 - ((v64 & v43) >> v67);
        goto LABEL_91;
      case 2:
        v72 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v72)
          v72 = (unsigned __int8 *)v17;
        if (v72 < v41)
          v72 = v41;
        v73 = *v72;
        if (v5)
        {
          v74 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          if (v16 < v74)
            v74 = v16;
          if ((unint64_t)v74 < *(_QWORD *)(result + 40))
            v74 = *(unsigned __int8 **)(result + 40);
          v73 |= *v74 << 24;
        }
        v75 = (v47 >> 28) & 3;
        v76 = interpolate_8888_19472[v75];
        LOBYTE(v75) = v75 + 1;
        v68 = v43 - ((v76 & v43) >> v75);
        v71 = (v76 & v73) >> v75;
        goto LABEL_103;
      case 3:
        v50 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v50)
          v50 = (unsigned __int8 *)v17;
        if (v50 < v41)
          v50 = v41;
        v51 = *v50;
        v52 = v40 + SBYTE1(v47) * (uint64_t)v6;
        if (v17 >= v52)
          v53 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        else
          v53 = (unsigned __int8 *)v17;
        if (v53 < v41)
          v53 = v41;
        v86 = *v53;
        v54 = (unsigned __int8 *)(v52 + SBYTE2(v47));
        if (v17 < (unint64_t)v54)
          v54 = (unsigned __int8 *)v17;
        if (v54 < v41)
          v54 = v41;
        v55 = *v54;
        if (v5)
        {
          v56 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          v57 = *(unsigned __int8 **)(result + 40);
          if (v16 < v56)
            v56 = v16;
          if (v56 < v57)
            v56 = *(unsigned __int8 **)(result + 40);
          v51 |= *v56 << 24;
          v58 = v44 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v58)
            v59 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          else
            v59 = v16;
          if (v59 < v57)
            v59 = *(unsigned __int8 **)(result + 40);
          v86 |= *v59 << 24;
          v60 = (unsigned __int8 *)(v58 + SBYTE2(v47));
          if (v16 < v60)
            v60 = v16;
          if (v60 >= v57)
            v57 = v60;
          v55 |= *v57 << 24;
        }
        v61 = interpolate_8888_19472[v49];
        v62 = v49 + 1;
        v63 = v43 - ((v61 & v43) >> v62) + ((v61 & v86) >> v62);
        v64 = v51 - ((v61 & v51) >> v62) + ((v61 & v55) >> v62);
        v65 = (v47 >> 28) & 3;
        v66 = interpolate_8888_19472[v65];
        v67 = v65 + 1;
        v68 = v63 - ((v63 & v66) >> v67);
LABEL_91:
        v71 = (v64 & v66) >> v67;
LABEL_103:
        v43 = v68 + v71;
        break;
    }
LABEL_104:
    *(_DWORD *)(v11 + 4) = (65792 * v43) | v13 | v43;
    *(_BYTE *)(v12 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v77 = 0;
    a2 += v9;
    v78 = v91 - a2;
    a3 += v10;
    v79 = v89 - a3;
    v80 = -4;
    while (((v79 | v78 | (a3 - v90) | (a2 - v88)) & 0x8000000000000000) == 0)
    {
      v81 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      v40 = v81 + (a2 >> 32);
      v41 = *(unsigned __int8 **)(result + 32);
      if (v17 >= v40)
        v82 = (unsigned __int8 *)(v81 + (a2 >> 32));
      else
        v82 = (unsigned __int8 *)v17;
      if (v82 < v41)
        v82 = *(unsigned __int8 **)(result + 32);
      v43 = *v82;
      if (v5)
      {
        v83 = v5 + SHIDWORD(a3) * (uint64_t)v7;
        v44 = v83 + (a2 >> 32);
        v84 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v44)
          v85 = (unsigned __int8 *)(v83 + (a2 >> 32));
        else
          v85 = v16;
        if (v85 >= v84)
          v84 = v85;
        v43 |= *v84 << 24;
      }
      if (v8)
      {
        v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          v12 += v77 + 1;
          v11 -= v80;
          a4 += ~(_DWORD)v77;
          v27 = -1;
          goto LABEL_48;
        }
      }
      *(_DWORD *)(v11 + 4 * v77 + 8) = (65792 * v43) | v13 | v43;
      *(_BYTE *)(v12 + v77++ + 2) = -1;
      v80 -= 4;
      a2 += v9;
      v78 -= v9;
      a3 += v10;
      v79 -= v10;
      if (a4 - 1 == (_DWORD)v77)
        return result;
    }
    v12 += v77 + 1;
    v11 -= v80;
    a4 += ~(_DWORD)v77;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_RGB555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  unsigned int v42;
  unint64_t v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  int v47;
  int v48;
  int64_t v49;
  unsigned __int16 *v50;
  unsigned int v51;
  unint64_t v52;
  unsigned __int16 *v53;
  unsigned int v54;
  unsigned __int16 *v55;
  unsigned int v56;
  unsigned __int8 *v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  int v62;
  char v63;
  unsigned int v64;
  unsigned __int16 *v65;
  unsigned int v66;
  unsigned __int8 *v67;
  int v68;
  char v69;
  unsigned int v70;
  unsigned int v71;
  unsigned __int16 *v72;
  unsigned int v73;
  unsigned __int8 *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  unsigned __int16 *v82;
  unsigned __int8 *v83;
  unint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v91 = *(_QWORD *)(result + 152) - 4;
  v89 = *(_QWORD *)(result + 88);
  v90 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v11 = 0;
  else
    v11 = -16777216;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v85 = *(_DWORD *)(result + 188);
  v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  v15 = v4 + (v12 * v6) + 2 * v13 - 4;
  v88 = *(_QWORD *)(result + 72);
  v86 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v86;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v89;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_43;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v86;
        v25 = v85 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v88 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_43;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v86;
      v25 = v85 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v85;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(_BYTE *)++v90 = 0;
    v91 += 4;
    if (!a4)
      return result;
  }
  if (a2 <= v87)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_29;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v87;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_43;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v85;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_43;
  v36 = v26 >> 32;
  v37 = v31 >> 32;
  v38 = v4 + (int)v36 * (uint64_t)v6;
  v39 = v38 + 2 * v37;
  v40 = *(unsigned __int16 **)(result + 32);
  if (v15 >= v39)
    v41 = (unsigned __int16 *)(v38 + 2 * v37);
  else
    v41 = (unsigned __int16 *)v15;
  if (v41 < v40)
    v41 = *(unsigned __int16 **)(result + 32);
  v42 = bswap32(*v41) >> 16;
  if (!v5)
  {
    v43 = 0;
    if (!v8)
      goto LABEL_103;
LABEL_46:
    v46 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    v47 = v46 & 0xF;
    v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      v65 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
      if (v15 < (unint64_t)v65)
        v65 = (unsigned __int16 *)v15;
      if (v65 < v40)
        v65 = v40;
      v66 = bswap32(*v65) >> 16;
      if (v5)
      {
        v67 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
        if (v14 < v67)
          v67 = v14;
        if ((unint64_t)v67 < *(_QWORD *)(result + 40))
          v67 = *(unsigned __int8 **)(result + 40);
        v66 |= *v67 << 24;
      }
      v68 = interpolate_8555_19473[v48];
      v69 = v48 + 1;
      v70 = v42 - ((v68 & v42) >> v69);
      v71 = (v68 & v66) >> v69;
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          v49 = (unint64_t)HIWORD(v46) << 56;
          v50 = (unsigned __int16 *)(v39 + (v49 >> 55));
          if (v15 < (unint64_t)v50)
            v50 = (unsigned __int16 *)v15;
          if (v50 < v40)
            v50 = v40;
          v51 = bswap32(*v50) >> 16;
          v52 = v39 + SBYTE1(v46) * (uint64_t)v6;
          if (v15 >= v52)
            v53 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
          else
            v53 = (unsigned __int16 *)v15;
          if (v53 < v40)
            v53 = v40;
          v54 = bswap32(*v53) >> 16;
          v55 = (unsigned __int16 *)(v52 + (v49 >> 55));
          if (v15 < (unint64_t)v55)
            v55 = (unsigned __int16 *)v15;
          if (v55 < v40)
            v55 = v40;
          v56 = bswap32(*v55) >> 16;
          if (v5)
          {
            v57 = (unsigned __int8 *)(v43 + SBYTE2(v46));
            v58 = *(_QWORD *)(result + 40);
            if (v14 < v57)
              v57 = v14;
            if ((unint64_t)v57 < v58)
              v57 = *(unsigned __int8 **)(result + 40);
            v51 |= *v57 << 24;
            v59 = v43 + SBYTE1(v46) * (uint64_t)v7;
            if ((unint64_t)v14 >= v59)
              v60 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
            else
              v60 = v14;
            if ((unint64_t)v60 < v58)
              v60 = *(unsigned __int8 **)(result + 40);
            v54 |= *v60 << 24;
            v61 = (unsigned __int8 *)(v59 + SBYTE2(v46));
            if (v14 < v61)
              v61 = v14;
            if ((unint64_t)v61 < v58)
              v61 = *(unsigned __int8 **)(result + 40);
            v56 |= *v61 << 24;
          }
          v62 = interpolate_8555_19473[v48];
          v63 = v48 + 1;
          v64 = v42 - ((v62 & v42) >> v63) + ((v62 & v54) >> v63);
          v42 = v64
              - ((v64 & interpolate_8555_19473[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1))
              + (((v51 - ((v62 & v51) >> v63) + ((v62 & v56) >> v63)) & interpolate_8555_19473[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      v72 = (unsigned __int16 *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 55));
      if (v15 < (unint64_t)v72)
        v72 = (unsigned __int16 *)v15;
      if (v72 < v40)
        v72 = v40;
      v73 = bswap32(*v72) >> 16;
      if (v5)
      {
        v74 = (unsigned __int8 *)(v43 + SBYTE2(v46));
        if (v14 < v74)
          v74 = v14;
        if ((unint64_t)v74 < *(_QWORD *)(result + 40))
          v74 = *(unsigned __int8 **)(result + 40);
        v73 |= *v74 << 24;
      }
      v75 = (v46 >> 28) & 3;
      v76 = interpolate_8555_19473[v75];
      LOBYTE(v75) = v75 + 1;
      v70 = v42 - ((v76 & v42) >> v75);
      v71 = (v76 & v73) >> v75;
    }
    v42 = v70 + v71;
    goto LABEL_103;
  }
  v43 = v5 + (int)v36 * (uint64_t)v7 + v37;
  v44 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v43)
    v45 = (unsigned __int8 *)v43;
  else
    v45 = v14;
  if (v45 >= v44)
    v44 = v45;
  v42 |= *v44 << 24;
  if (v8)
    goto LABEL_46;
LABEL_103:
  v77 = 0;
  v78 = 0;
  a3 += v9;
  v79 = v89 - a3;
  a2 += v10;
  v80 = v87 - a2;
  while (1)
  {
    v81 = (v42 << 6) & 0xF800 | (((v42 >> 10) & 0x1F) << 19) | (8 * (v42 & 0x1F));
    *(_DWORD *)(v91 + 4 + 4 * v77) = (v11 | (v42 >> 5) | v42) & 0xFF000000 | v81 | (v81 >> 5) & 0x3F3F3F3F;
    *(_BYTE *)(v90 + 1 + v77) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v77)
      return result;
    if ((v79 | v80 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v77 + 1;
      v91 = v91 - v78 + 4;
      a4 += ~(_DWORD)v77;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32);
    v40 = *(unsigned __int16 **)(result + 32);
    if (v15 >= v39)
      v82 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32));
    else
      v82 = (unsigned __int16 *)v15;
    if (v82 < v40)
      v82 = *(unsigned __int16 **)(result + 32);
    v42 = bswap32(*v82) >> 16;
    if (v5)
    {
      v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v43)
        v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      else
        v84 = (unint64_t)v14;
      if (v84 >= (unint64_t)v83)
        v83 = (unsigned __int8 *)v84;
      v42 |= *v83 << 24;
    }
    if (v8)
    {
      v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v90 += v77 + 1;
        v91 = v91 - v78 + 4;
        a4 += ~(_DWORD)v77;
        v25 = -1;
        goto LABEL_48;
      }
    }
    v78 -= 4;
    ++v77;
    a3 += v9;
    v79 -= v9;
    a2 += v10;
    v80 -= v10;
    v25 = -1;
  }
}

uint64_t argb32_sample_rgb555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  unsigned int v42;
  unint64_t v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  int v47;
  int v48;
  int64_t v49;
  unsigned __int16 *v50;
  unsigned int v51;
  unint64_t v52;
  unsigned __int16 *v53;
  unsigned int v54;
  unsigned __int16 *v55;
  unsigned int v56;
  unsigned __int8 *v57;
  unint64_t v58;
  unint64_t v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  int v62;
  char v63;
  unsigned int v64;
  unsigned __int16 *v65;
  unsigned int v66;
  unsigned __int8 *v67;
  int v68;
  char v69;
  unsigned int v70;
  unsigned int v71;
  unsigned __int16 *v72;
  unsigned int v73;
  unsigned __int8 *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  unsigned __int16 *v82;
  unsigned __int8 *v83;
  unint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v91 = *(_QWORD *)(result + 152) - 4;
  v89 = *(_QWORD *)(result + 88);
  v90 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v11 = 0;
  else
    v11 = -16777216;
  v12 = *(_DWORD *)(result + 260) - 1;
  v13 = *(unsigned int *)(result + 256);
  v85 = *(_DWORD *)(result + 188);
  v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  v15 = v4 + (v12 * v6) + 2 * v13 - 4;
  v88 = *(_QWORD *)(result + 72);
  v86 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        v26 = a3;
        v27 = v86;
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = *(_QWORD *)(result + 224) + v89;
        v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_43;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v27 = v86;
        v25 = v85 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v16 = *(_QWORD *)(result + 216);
      v17 = v88 - *(_QWORD *)(result + 224);
      v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1)
        goto LABEL_43;
      if (v18 >= v16)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
      v27 = v86;
      v25 = v85 | v19;
      v26 = v17 + 0x1000000;
      v24 = 512;
    }
    if (a2 >= v27)
      break;
    v28 = *(_QWORD *)(result + 192);
    v29 = v27 - *(_QWORD *)(result + 200);
    v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28)
        v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v30) >> 32) >> 15)) | v85;
      v31 = v29 + 0x1000000;
      v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(_BYTE *)++v90 = 0;
    v91 += 4;
    if (!a4)
      return result;
  }
  if (a2 <= v87)
  {
    v32 = ((unint64_t)a2 >> 26) & 0x3C;
    v31 = a2;
    goto LABEL_29;
  }
  v33 = *(_QWORD *)(result + 192);
  v34 = *(_QWORD *)(result + 200) + v87;
  v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1)
    goto LABEL_43;
  if (v35 < v33)
    v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v85;
  v31 = v34 - 0x1000000;
  v32 = 28;
LABEL_29:
  if (v25 < 0x400000)
    goto LABEL_43;
  v36 = v26 >> 32;
  v37 = v31 >> 32;
  v38 = v4 + (int)v36 * (uint64_t)v6;
  v39 = v38 + 2 * v37;
  v40 = *(unsigned __int16 **)(result + 32);
  if (v15 >= v39)
    v41 = (unsigned __int16 *)(v38 + 2 * v37);
  else
    v41 = (unsigned __int16 *)v15;
  if (v41 < v40)
    v41 = *(unsigned __int16 **)(result + 32);
  v42 = *v41;
  if (!v5)
  {
    v43 = 0;
    if (!v8)
      goto LABEL_103;
LABEL_46:
    v46 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    v47 = v46 & 0xF;
    v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      v65 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
      if (v15 < (unint64_t)v65)
        v65 = (unsigned __int16 *)v15;
      if (v65 < v40)
        v65 = v40;
      v66 = *v65;
      if (v5)
      {
        v67 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
        if (v14 < v67)
          v67 = v14;
        if ((unint64_t)v67 < *(_QWORD *)(result + 40))
          v67 = *(unsigned __int8 **)(result + 40);
        v66 |= *v67 << 24;
      }
      v68 = interpolate_8555_19473[v48];
      v69 = v48 + 1;
      v70 = v42 - ((v68 & v42) >> v69);
      v71 = (v68 & v66) >> v69;
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          v49 = (unint64_t)HIWORD(v46) << 56;
          v50 = (unsigned __int16 *)(v39 + (v49 >> 55));
          if (v15 < (unint64_t)v50)
            v50 = (unsigned __int16 *)v15;
          if (v50 < v40)
            v50 = v40;
          v51 = *v50;
          v52 = v39 + SBYTE1(v46) * (uint64_t)v6;
          if (v15 >= v52)
            v53 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
          else
            v53 = (unsigned __int16 *)v15;
          if (v53 < v40)
            v53 = v40;
          v54 = *v53;
          v55 = (unsigned __int16 *)(v52 + (v49 >> 55));
          if (v15 < (unint64_t)v55)
            v55 = (unsigned __int16 *)v15;
          if (v55 < v40)
            v55 = v40;
          v56 = *v55;
          if (v5)
          {
            v57 = (unsigned __int8 *)(v43 + SBYTE2(v46));
            v58 = *(_QWORD *)(result + 40);
            if (v14 < v57)
              v57 = v14;
            if ((unint64_t)v57 < v58)
              v57 = *(unsigned __int8 **)(result + 40);
            v51 |= *v57 << 24;
            v59 = v43 + SBYTE1(v46) * (uint64_t)v7;
            if ((unint64_t)v14 >= v59)
              v60 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
            else
              v60 = v14;
            if ((unint64_t)v60 < v58)
              v60 = *(unsigned __int8 **)(result + 40);
            v54 |= *v60 << 24;
            v61 = (unsigned __int8 *)(v59 + SBYTE2(v46));
            if (v14 < v61)
              v61 = v14;
            if ((unint64_t)v61 < v58)
              v61 = *(unsigned __int8 **)(result + 40);
            v56 |= *v61 << 24;
          }
          v62 = interpolate_8555_19473[v48];
          v63 = v48 + 1;
          v64 = v42 - ((v62 & v42) >> v63) + ((v62 & v54) >> v63);
          v42 = v64
              - ((v64 & interpolate_8555_19473[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1))
              + (((v51 - ((v62 & v51) >> v63) + ((v62 & v56) >> v63)) & interpolate_8555_19473[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      v72 = (unsigned __int16 *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 55));
      if (v15 < (unint64_t)v72)
        v72 = (unsigned __int16 *)v15;
      if (v72 < v40)
        v72 = v40;
      v73 = *v72;
      if (v5)
      {
        v74 = (unsigned __int8 *)(v43 + SBYTE2(v46));
        if (v14 < v74)
          v74 = v14;
        if ((unint64_t)v74 < *(_QWORD *)(result + 40))
          v74 = *(unsigned __int8 **)(result + 40);
        v73 |= *v74 << 24;
      }
      v75 = (v46 >> 28) & 3;
      v76 = interpolate_8555_19473[v75];
      LOBYTE(v75) = v75 + 1;
      v70 = v42 - ((v76 & v42) >> v75);
      v71 = (v76 & v73) >> v75;
    }
    v42 = v70 + v71;
    goto LABEL_103;
  }
  v43 = v5 + (int)v36 * (uint64_t)v7 + v37;
  v44 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v43)
    v45 = (unsigned __int8 *)v43;
  else
    v45 = v14;
  if (v45 >= v44)
    v44 = v45;
  v42 |= *v44 << 24;
  if (v8)
    goto LABEL_46;
LABEL_103:
  v77 = 0;
  v78 = 0;
  a3 += v9;
  v79 = v89 - a3;
  a2 += v10;
  v80 = v87 - a2;
  while (1)
  {
    v81 = (v42 << 6) & 0xF800 | (((v42 >> 10) & 0x1F) << 19) | (8 * (v42 & 0x1F));
    *(_DWORD *)(v91 + 4 + 4 * v77) = (v11 | (v42 >> 5) | v42) & 0xFF000000 | v81 | (v81 >> 5) & 0x3F3F3F3F;
    *(_BYTE *)(v90 + 1 + v77) = v25 >> 22;
    if (a4 - 1 == (_DWORD)v77)
      return result;
    if ((v79 | v80 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v77 + 1;
      v91 = v91 - v78 + 4;
      a4 += ~(_DWORD)v77;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32);
    v40 = *(unsigned __int16 **)(result + 32);
    if (v15 >= v39)
      v82 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32));
    else
      v82 = (unsigned __int16 *)v15;
    if (v82 < v40)
      v82 = *(unsigned __int16 **)(result + 32);
    v42 = *v82;
    if (v5)
    {
      v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v43)
        v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      else
        v84 = (unint64_t)v14;
      if (v84 >= (unint64_t)v83)
        v83 = (unsigned __int8 *)v84;
      v42 |= *v83 << 24;
    }
    if (v8)
    {
      v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v90 += v77 + 1;
        v91 = v91 - v78 + 4;
        a4 += ~(_DWORD)v77;
        v25 = -1;
        goto LABEL_48;
      }
    }
    v78 -= 4;
    ++v77;
    a3 += v9;
    v79 -= v9;
    a2 += v10;
    v80 -= v10;
    v25 = -1;
  }
}

uint64_t argb32_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  unint64_t v46;
  unsigned __int8 *v47;
  int v48;
  unsigned __int8 *v49;
  unsigned int v50;
  char v51;
  unsigned int v52;
  int v53;
  int v54;
  unsigned int v55;
  char v56;
  unsigned int v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  int v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 *v70;
  unsigned int v71;
  int v72;
  uint64_t v73;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 64);
  v8 = *(_QWORD *)(result + 72);
  v9 = *(_QWORD *)(result + 88);
  v73 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v11 = *(_QWORD *)(result + 120);
  v12 = *(_QWORD *)(result + 152) - 4;
  v13 = *(_QWORD *)(result + 144) - 1;
  v72 = *(_DWORD *)(result + 188);
  v14 = v4 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v5) - 3;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v8)
      {
        if ((uint64_t)a3 <= v9)
        {
          v23 = (a3 >> 22) & 0x3C0;
          v24 = 0x3FFFFFFF;
          HIDWORD(v25) = HIDWORD(a3);
        }
        else
        {
          v19 = *(_QWORD *)(result + 216);
          v20 = *(_QWORD *)(result + 224) + v9;
          v21 = v20 - a3 + (v19 >> 1);
          if (v21 < 1)
            goto LABEL_34;
          if (v21 >= v19)
            LODWORD(v22) = 0x3FFFFFFF;
          else
            v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
          v24 = v72 | v22;
          v25 = v20 - 0x1000000;
          v23 = 448;
        }
      }
      else
      {
        v15 = *(_QWORD *)(result + 216);
        v16 = v8 - *(_QWORD *)(result + 224);
        v17 = a3 - v16 + (v15 >> 1);
        if (v17 < 1)
          goto LABEL_34;
        if (v17 >= v15)
          LODWORD(v18) = 0x3FFFFFFF;
        else
          v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
        v24 = v72 | v18;
        v25 = v16 + 0x1000000;
        v23 = 512;
      }
      if (a2 >= v7)
        break;
      v26 = *(_QWORD *)(result + 192);
      v27 = v7 - *(_QWORD *)(result + 200);
      v28 = a2 - v27 + (v26 >> 1);
      if (v28 >= 1)
      {
        if (v28 < v26)
          v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v72;
        v29 = v27 + 0x1000000;
        v30 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v10;
      a3 += v11;
      v12 += 4;
      *(_BYTE *)++v13 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v73)
    {
      v30 = ((unint64_t)a2 >> 26) & 0x3C;
      v29 = a2;
      goto LABEL_26;
    }
    v31 = *(_QWORD *)(result + 192);
    v32 = *(_QWORD *)(result + 200) + v73;
    v33 = v32 - a2 + (v31 >> 1);
    if (v33 < 1)
      goto LABEL_34;
    if (v33 < v31)
      v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v72;
    v29 = v32 - 0x1000000;
    v30 = 28;
LABEL_26:
    if (v24 < 0x400000)
      goto LABEL_34;
    v34 = v4 + SHIDWORD(v25) * (uint64_t)v5;
    v35 = 3 * (v29 >> 32);
    v36 = v34 + v35;
    v37 = *(unsigned __int8 **)(result + 32);
    if (v14 >= v34 + v35)
      v38 = (unsigned __int8 *)(v34 + v35);
    else
      v38 = (unsigned __int8 *)v14;
    if (v38 < v37)
      v38 = *(unsigned __int8 **)(result + 32);
    v39 = (v38[1] << 16) | (*v38 << 24) | (v38[2] << 8) | 0xFF;
    if (!v6)
      goto LABEL_65;
    v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
    v41 = v40 & 0xF;
    v42 = HIBYTE(v40) & 3;
    switch(v41)
    {
      case 1:
        v58 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
        if (v14 < (unint64_t)v58)
          v58 = (unsigned __int8 *)v14;
        if (v58 < v37)
          v58 = v37;
        v39 = v39
            - ((interpolate_8888_19472[v42] & v39) >> (v42 + 1))
            + ((((v58[1] << 16) | (*v58 << 24) | (v58[2] << 8) | 0xFFu) & interpolate_8888_19472[v42]) >> (v42 + 1));
        break;
      case 2:
        v59 = (unsigned __int8 *)(v36 + 3 * SBYTE2(v40));
        if (v14 < (unint64_t)v59)
          v59 = (unsigned __int8 *)v14;
        if (v59 < v37)
          v59 = v37;
        v53 = (v59[1] << 16) | (*v59 << 24) | (v59[2] << 8) | 0xFF;
        v60 = (v40 >> 28) & 3;
        v55 = interpolate_8888_19472[v60];
        v56 = v60 + 1;
        v57 = v39 - ((v55 & v39) >> v56);
        goto LABEL_64;
      case 3:
        v43 = 3 * SBYTE2(v40);
        v44 = (unsigned __int8 *)(v36 + v43);
        if (v14 < v36 + v43)
          v44 = (unsigned __int8 *)v14;
        if (v44 < v37)
          v44 = v37;
        v45 = (v44[1] << 16) | (*v44 << 24) | (v44[2] << 8) | 0xFF;
        v46 = v36 + SBYTE1(v40) * (uint64_t)v5;
        if (v14 >= v46)
          v47 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
        else
          v47 = (unsigned __int8 *)v14;
        if (v47 < v37)
          v47 = v37;
        v48 = (v47[1] << 16) | (*v47 << 24) | (v47[2] << 8) | 0xFF;
        v49 = (unsigned __int8 *)(v46 + v43);
        if (v14 < (unint64_t)v49)
          v49 = (unsigned __int8 *)v14;
        if (v49 < v37)
          v49 = v37;
        v50 = interpolate_8888_19472[v42];
        v51 = v42 + 1;
        v52 = v39 - ((v50 & v39) >> v51) + ((v48 & v50) >> v51);
        v53 = v45 - ((v50 & v45) >> v51) + ((((v49[1] << 16) | (*v49 << 24) | (v49[2] << 8) | 0xFF) & v50) >> v51);
        v54 = (v40 >> 28) & 3;
        v55 = interpolate_8888_19472[v54];
        v56 = v54 + 1;
        v57 = v52 - ((v52 & v55) >> v56);
LABEL_64:
        v39 = v57 + ((v53 & v55) >> v56);
        break;
    }
LABEL_65:
    v61 = v12;
    HIDWORD(v62) = v39;
    LODWORD(v62) = v39;
    *(_DWORD *)(v12 + 4) = v62 >> 8;
    v12 += 4;
    *(_BYTE *)(v13 + 1) = v24 >> 22;
    if (a4 == 1)
      break;
    v63 = 0;
    a2 += v10;
    v64 = v73 - a2;
    a3 += v11;
    v65 = v9 - a3;
    v66 = --a4;
    while (1)
    {
      v67 = v13 + v63 + 1;
      if (((v65 | v64 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
        break;
      v68 = v4 + SHIDWORD(a3) * (uint64_t)v5;
      v69 = 3 * (a2 >> 32);
      v36 = v68 + v69;
      v37 = *(unsigned __int8 **)(result + 32);
      if (v14 >= v68 + v69)
        v70 = (unsigned __int8 *)(v68 + v69);
      else
        v70 = (unsigned __int8 *)v14;
      if (v70 < v37)
        v70 = *(unsigned __int8 **)(result + 32);
      v71 = (v70[1] << 16) | (*v70 << 24) | (v70[2] << 8);
      if (v6)
      {
        v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v40 & 0xF) != 0)
        {
          v39 = v71 | 0xFF;
          v24 = -1;
          v13 = v67;
          goto LABEL_37;
        }
      }
      --a4;
      v12 += 4;
      *(_DWORD *)(v61 + 4 * v63 + 8) = (v71 >> 8) | 0xFF000000;
      *(_BYTE *)(v13 + v63++ + 2) = -1;
      a2 += v10;
      v64 -= v10;
      a3 += v11;
      v65 -= v11;
      if (v66 == (_DWORD)v63)
        return result;
    }
    v13 += v63 + 1;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_RGBA32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned int *v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int *v50;
  int v51;
  char v52;
  unsigned int v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int *v57;
  int v58;
  char v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int *v62;
  char v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int *v70;
  unint64_t v71;
  int v72;
  uint64_t v73;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 64);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v73 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v72 = *(_DWORD *)(result + 188);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v14 = 0;
  else
    v14 = 255;
  v15 = v13 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v7)
      {
        if ((uint64_t)a3 <= v8)
        {
          v24 = (a3 >> 22) & 0x3C0;
          v25 = 0x3FFFFFFF;
          HIDWORD(v26) = HIDWORD(a3);
        }
        else
        {
          v20 = *(_QWORD *)(result + 216);
          v21 = *(_QWORD *)(result + 224) + v8;
          v22 = v21 - a3 + (v20 >> 1);
          if (v22 < 1)
            goto LABEL_37;
          if (v22 >= v20)
            LODWORD(v23) = 0x3FFFFFFF;
          else
            v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
          v25 = v72 | v23;
          v26 = v21 - 0x1000000;
          v24 = 448;
        }
      }
      else
      {
        v16 = *(_QWORD *)(result + 216);
        v17 = v7 - *(_QWORD *)(result + 224);
        v18 = a3 - v17 + (v16 >> 1);
        if (v18 < 1)
          goto LABEL_37;
        if (v18 >= v16)
          LODWORD(v19) = 0x3FFFFFFF;
        else
          v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
        v25 = v72 | v19;
        v26 = v17 + 0x1000000;
        v24 = 512;
      }
      if (a2 >= v6)
        break;
      v27 = *(_QWORD *)(result + 192);
      v28 = v6 - *(_QWORD *)(result + 200);
      v29 = a2 - v28 + (v27 >> 1);
      if (v29 >= 1)
      {
        if (v29 < v27)
          v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v72;
        v30 = v28 + 0x1000000;
        v31 = 32;
        goto LABEL_29;
      }
LABEL_37:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v73)
    {
      v31 = ((unint64_t)a2 >> 26) & 0x3C;
      v30 = a2;
      goto LABEL_29;
    }
    v32 = *(_QWORD *)(result + 192);
    v33 = *(_QWORD *)(result + 200) + v73;
    v34 = v33 - a2 + (v32 >> 1);
    if (v34 < 1)
      goto LABEL_37;
    if (v34 < v32)
      v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v72;
    v30 = v33 - 0x1000000;
    v31 = 28;
LABEL_29:
    if (v25 < 0x400000)
      goto LABEL_37;
    v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
    v36 = v30 >> 32;
    v37 = v35 + 4 * v36;
    v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37)
      v39 = (unsigned int *)(v35 + 4 * v36);
    else
      v39 = (unsigned int *)v15;
    if (v39 < v38)
      v39 = *(unsigned int **)(result + 32);
    v40 = bswap32(*v39);
    if (!v5)
      goto LABEL_69;
    v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
    v42 = v41 & 0xF;
    v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        v57 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v15 < (unint64_t)v57)
          v57 = (unsigned int *)v15;
        if (v57 < v38)
          v57 = v38;
        v58 = interpolate_8888_19472[v43];
        v59 = v43 + 1;
        v60 = v40 - ((v58 & v40) >> v59);
        v61 = (bswap32(*v57) & v58) >> v59;
        goto LABEL_68;
      case 2:
        v62 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
        if (v15 < (unint64_t)v62)
          v62 = (unsigned int *)v15;
        if (v62 < v38)
          v62 = v38;
        v53 = bswap32(*v62);
        v54 = (v41 >> 28) & 3;
        v55 = interpolate_8888_19472[v54];
        v56 = v55 & v40;
        goto LABEL_67;
      case 3:
        v44 = (unint64_t)HIWORD(v41) << 56;
        v45 = (unsigned int *)(v37 + (v44 >> 54));
        if (v15 < (unint64_t)v45)
          v45 = (unsigned int *)v15;
        if (v45 < v38)
          v45 = v38;
        v46 = bswap32(*v45);
        v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v15 >= v47)
          v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        else
          v48 = (unsigned int *)v15;
        if (v48 < v38)
          v48 = v38;
        v49 = bswap32(*v48);
        v50 = (unsigned int *)(v47 + (v44 >> 54));
        if (v15 < (unint64_t)v50)
          v50 = (unsigned int *)v15;
        if (v50 < v38)
          v50 = v38;
        v51 = interpolate_8888_19472[v43];
        v52 = v43 + 1;
        v40 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
        v53 = v46 - ((v51 & v46) >> v52) + ((bswap32(*v50) & v51) >> v52);
        v54 = (v41 >> 28) & 3;
        v55 = interpolate_8888_19472[v54];
        v56 = v40 & v55;
LABEL_67:
        v63 = v54 + 1;
        v60 = v40 - (v56 >> v63);
        v61 = (v53 & v55) >> v63;
LABEL_68:
        v40 = v60 + v61;
        break;
    }
LABEL_69:
    HIDWORD(v64) = v40 | v14;
    LODWORD(v64) = v40 | v14;
    *(_DWORD *)(v11 + 4) = v64 >> 8;
    *(_BYTE *)(v12 + 1) = v25 >> 22;
    if (a4 == 1)
      break;
    v65 = 0;
    a2 += v9;
    v66 = v73 - a2;
    a3 += v10;
    v67 = v8 - a3;
    v68 = -4;
    while (((v67 | v66 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) == 0)
    {
      v69 = v13 + SHIDWORD(a3) * (uint64_t)v4;
      v37 = v69 + 4 * (a2 >> 32);
      v38 = *(unsigned int **)(result + 32);
      if (v15 >= v37)
        v70 = (unsigned int *)(v69 + 4 * (a2 >> 32));
      else
        v70 = (unsigned int *)v15;
      if (v70 < v38)
        v70 = *(unsigned int **)(result + 32);
      v40 = bswap32(*v70);
      if (v5)
      {
        v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v41 & 0xF) != 0)
        {
          v12 += v65 + 1;
          v11 -= v68;
          a4 += ~(_DWORD)v65;
          v25 = -1;
          goto LABEL_40;
        }
      }
      HIDWORD(v71) = v40 | v14;
      LODWORD(v71) = v40 | v14;
      *(_DWORD *)(v11 + 4 * v65 + 8) = v71 >> 8;
      *(_BYTE *)(v12 + v65++ + 2) = -1;
      v68 -= 4;
      a2 += v9;
      v66 -= v9;
      a3 += v10;
      v67 -= v10;
      if (a4 - 1 == (_DWORD)v65)
        return result;
    }
    v12 += v65 + 1;
    v11 -= v68;
    a4 += ~(_DWORD)v65;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_rgba32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned int *v45;
  unsigned int v46;
  unint64_t v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int *v50;
  unsigned int v51;
  char v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  int v56;
  char v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int *v60;
  unsigned int v61;
  char v62;
  unsigned int v63;
  unsigned int *v64;
  int v65;
  int v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  unint64_t v74;
  int v75;
  uint64_t v76;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 64);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v76 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v75 = *(_DWORD *)(result + 188);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  v13 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v14 = 0;
  else
    v14 = 255;
  v15 = v13 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v7)
      {
        if ((uint64_t)a3 <= v8)
        {
          v24 = (a3 >> 22) & 0x3C0;
          v25 = 0x3FFFFFFF;
          HIDWORD(v26) = HIDWORD(a3);
        }
        else
        {
          v20 = *(_QWORD *)(result + 216);
          v21 = *(_QWORD *)(result + 224) + v8;
          v22 = v21 - a3 + (v20 >> 1);
          if (v22 < 1)
            goto LABEL_37;
          if (v22 >= v20)
            LODWORD(v23) = 0x3FFFFFFF;
          else
            v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
          v25 = v75 | v23;
          v26 = v21 - 0x1000000;
          v24 = 448;
        }
      }
      else
      {
        v16 = *(_QWORD *)(result + 216);
        v17 = v7 - *(_QWORD *)(result + 224);
        v18 = a3 - v17 + (v16 >> 1);
        if (v18 < 1)
          goto LABEL_37;
        if (v18 >= v16)
          LODWORD(v19) = 0x3FFFFFFF;
        else
          v19 = (unint64_t)(*(_QWORD *)(result + 232) * v18) >> 32;
        v25 = v75 | v19;
        v26 = v17 + 0x1000000;
        v24 = 512;
      }
      if (a2 >= v6)
        break;
      v27 = *(_QWORD *)(result + 192);
      v28 = v6 - *(_QWORD *)(result + 200);
      v29 = a2 - v28 + (v27 >> 1);
      if (v29 >= 1)
      {
        if (v29 < v27)
          v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v75;
        v30 = v28 + 0x1000000;
        v31 = 32;
        goto LABEL_29;
      }
LABEL_37:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v76)
    {
      v31 = ((unint64_t)a2 >> 26) & 0x3C;
      v30 = a2;
      goto LABEL_29;
    }
    v32 = *(_QWORD *)(result + 192);
    v33 = *(_QWORD *)(result + 200) + v76;
    v34 = v33 - a2 + (v32 >> 1);
    if (v34 < 1)
      goto LABEL_37;
    if (v34 < v32)
      v25 = ((v25 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v75;
    v30 = v33 - 0x1000000;
    v31 = 28;
LABEL_29:
    if (v25 < 0x400000)
      goto LABEL_37;
    v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
    v36 = v30 >> 32;
    v37 = v35 + 4 * v36;
    v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37)
      v39 = (unsigned int *)(v35 + 4 * v36);
    else
      v39 = (unsigned int *)v15;
    if (v39 < v38)
      v39 = *(unsigned int **)(result + 32);
    v40 = *v39;
    if (!v5)
      goto LABEL_69;
    v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
    v42 = v41 & 0xF;
    v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        v60 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v15 < (unint64_t)v60)
          v60 = (unsigned int *)v15;
        if (v60 < v38)
          v60 = v38;
        v61 = interpolate_8888_19472[v43];
        v62 = v43 + 1;
        v58 = v40 - ((v61 & v40) >> v62);
        v63 = (v61 & *v60) >> v62;
        goto LABEL_68;
      case 2:
        v64 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
        if (v15 < (unint64_t)v64)
          v64 = (unsigned int *)v15;
        if (v64 < v38)
          v64 = v38;
        v65 = (v41 >> 28) & 3;
        v66 = interpolate_8888_19472[v65];
        v57 = v65 + 1;
        v58 = v40 - ((v66 & v40) >> v57);
        v59 = v66 & *v64;
        goto LABEL_67;
      case 3:
        v44 = (unint64_t)HIWORD(v41) << 56;
        v45 = (unsigned int *)(v37 + (v44 >> 54));
        if (v15 < (unint64_t)v45)
          v45 = (unsigned int *)v15;
        if (v45 < v38)
          v45 = v38;
        v46 = *v45;
        v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v15 >= v47)
          v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        else
          v48 = (unsigned int *)v15;
        if (v48 < v38)
          v48 = v38;
        v49 = *v48;
        v50 = (unsigned int *)(v47 + (v44 >> 54));
        if (v15 < (unint64_t)v50)
          v50 = (unsigned int *)v15;
        if (v50 < v38)
          v50 = v38;
        v51 = interpolate_8888_19472[v43];
        v52 = v43 + 1;
        v53 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
        v54 = v46 - ((v51 & v46) >> v52) + ((v51 & *v50) >> v52);
        v55 = (v41 >> 28) & 3;
        v56 = interpolate_8888_19472[v55];
        v57 = v55 + 1;
        v58 = v53 - ((v53 & v56) >> v57);
        v59 = v54 & v56;
LABEL_67:
        v63 = v59 >> v57;
LABEL_68:
        v40 = v58 + v63;
        break;
    }
LABEL_69:
    HIDWORD(v67) = v40 | v14;
    LODWORD(v67) = v40 | v14;
    *(_DWORD *)(v11 + 4) = v67 >> 8;
    *(_BYTE *)(v12 + 1) = v25 >> 22;
    if (a4 == 1)
      break;
    v68 = 0;
    a2 += v9;
    v69 = v76 - a2;
    a3 += v10;
    v70 = v8 - a3;
    v71 = -4;
    while (((v70 | v69 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) == 0)
    {
      v72 = v13 + SHIDWORD(a3) * (uint64_t)v4;
      v37 = v72 + 4 * (a2 >> 32);
      v38 = *(unsigned int **)(result + 32);
      if (v15 >= v37)
        v73 = (unsigned int *)(v72 + 4 * (a2 >> 32));
      else
        v73 = (unsigned int *)v15;
      if (v73 < v38)
        v73 = *(unsigned int **)(result + 32);
      v40 = *v73;
      if (v5)
      {
        v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v41 & 0xF) != 0)
        {
          v12 += v68 + 1;
          v11 -= v71;
          a4 += ~(_DWORD)v68;
          v25 = -1;
          goto LABEL_40;
        }
      }
      HIDWORD(v74) = v40 | v14;
      LODWORD(v74) = v40 | v14;
      *(_DWORD *)(v11 + 4 * v68 + 8) = v74 >> 8;
      *(_BYTE *)(v12 + v68++ + 2) = -1;
      v71 -= 4;
      a2 += v9;
      v69 -= v9;
      a3 += v10;
      v70 -= v10;
      if (a4 - 1 == (_DWORD)v68)
        return result;
    }
    v12 += v68 + 1;
    v11 -= v71;
    a4 += ~(_DWORD)v68;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_ARGB32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int *v64;
  unsigned int v65;
  unint64_t v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int *v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int *v82;
  int v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int *v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v108 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v108 = v5 % v6;
  }
  else
  {
    v108 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v107 = v11;
  }
  else
  {
    v107 = 0;
  }
  v103 = *(_QWORD *)(result + 80);
  v104 = *(_QWORD *)(result + 64);
  v105 = *(_QWORD *)(result + 88);
  v106 = *(_QWORD *)(result + 72);
  v12 = *(_QWORD *)(result + 152) - 4;
  v13 = *(_QWORD *)(result + 144) - 1;
  if (*(_QWORD *)(result + 40))
    v14 = 0;
  else
    v14 = -16777216;
  v102 = *(_DWORD *)(result + 188);
  v15 = v9 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  v16 = -*(_QWORD *)(result + 64);
  v17 = -*(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v106)
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v106 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_55;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v28 = v102 | v21;
        v29 = v19 + 0x1000000;
        v26 = a3 - (v19 + 0x1000000);
        v27 = 512;
        goto LABEL_25;
      }
      if (a3 <= v105)
      {
        v26 = 0;
        v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        v28 = 0x3FFFFFFF;
        v29 = a3;
LABEL_25:
        v30 = v104;
        goto LABEL_28;
      }
      v22 = *(_QWORD *)(result + 216);
      v23 = *(_QWORD *)(result + 224) + v105;
      v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1)
        goto LABEL_55;
      if (v24 >= v22)
        LODWORD(v25) = 0x3FFFFFFF;
      else
        v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
      v30 = v104;
      v28 = v102 | v25;
      v29 = v23 - 0x1000000;
      v26 = a3 - (v23 - 0x1000000);
      v27 = 448;
LABEL_28:
      if (a2 >= v30)
        break;
      v31 = *(_QWORD *)(result + 192);
      v32 = v30 - *(_QWORD *)(result + 200);
      v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31)
          v28 = ((v28 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v102;
        v34 = v32 + 0x1000000;
        v35 = a2 - (v32 + 0x1000000);
        v36 = 32;
        goto LABEL_39;
      }
LABEL_55:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 4;
      *(_BYTE *)++v13 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v103)
    {
      v35 = 0;
      v36 = ((unint64_t)a2 >> 26) & 0x3C;
      v34 = a2;
      goto LABEL_39;
    }
    v37 = *(_QWORD *)(result + 192);
    v38 = *(_QWORD *)(result + 200) + v103;
    v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1)
      goto LABEL_55;
    if (v39 < v37)
      v28 = ((v28 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v39) >> 32) >> 15)) | v102;
    v34 = v38 - 0x1000000;
    v35 = a2 - (v38 - 0x1000000);
    v36 = 28;
LABEL_39:
    if (v28 < 0x400000)
      goto LABEL_55;
    if (v6)
    {
      v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7)
        v42 = v7;
      else
        v42 = 0;
      v29 = v40 - v42;
      if (v41 >= v6)
        v43 = v6;
      else
        v43 = 0;
      v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    v44 = v9 + SHIDWORD(v29) * (uint64_t)v4;
    v45 = v34 >> 32;
    v46 = v44 + 4 * v45;
    v47 = *(unsigned int **)(result + 32);
    if (v15 >= v46)
      v48 = (unsigned int *)(v44 + 4 * v45);
    else
      v48 = (unsigned int *)v15;
    if (v48 < v47)
      v48 = *(unsigned int **)(result + 32);
    v49 = bswap32(*v48);
    if (!v8)
      goto LABEL_104;
    v50 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_58:
    v51 = v50 & 0xF;
    v52 = v50 >> 8;
    v53 = HIBYTE(v50) & 3;
    switch(v51)
    {
      case 1:
        LODWORD(v77) = SBYTE1(v50);
        if (v6)
        {
          v78 = v52 << 56;
          v79 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          v80 = v7 & (v79 >> 63);
          if (v80 + v79 >= v7)
            v81 = v7;
          else
            v81 = 0;
          v77 = (v80 + (v78 >> 24) - v81) >> 32;
        }
        v82 = (unsigned int *)(v46 + (int)v77 * (uint64_t)v4);
        if (v15 < (unint64_t)v82)
          v82 = (unsigned int *)v15;
        if (v82 < v47)
          v82 = v47;
        v83 = interpolate_8888_19472[v53];
        v84 = v53 + 1;
        v75 = v49 - ((v83 & v49) >> v84);
        v76 = (bswap32(*v82) & v83) >> v84;
        goto LABEL_93;
      case 2:
        v85 = SBYTE2(v50);
        if (v6)
        {
          v86 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          v87 = v6 & (v86 >> 63);
          if (v87 + v86 >= v6)
            v88 = v6;
          else
            v88 = 0;
          v85 = (v87 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v88) >> 32;
        }
        v89 = (unsigned int *)(v46 + 4 * v85);
        if (v15 < (unint64_t)v89)
          v89 = (unsigned int *)v15;
        if (v89 < v47)
          v89 = v47;
        v49 = v49
            - ((interpolate_8888_19472[(v50 >> 28) & 3] & v49) >> (((v50 >> 28) & 3) + 1))
            + ((bswap32(*v89) & interpolate_8888_19472[(v50 >> 28) & 3]) >> (((v50 >> 28) & 3) + 1));
        break;
      case 3:
        v101 = HIBYTE(v50) & 3;
        LODWORD(v54) = SBYTE1(v50);
        v55 = SBYTE2(v50);
        if (v6)
        {
          v56 = v52 << 56;
          v57 = v26 + (v56 >> 24);
          v58 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          v59 = v7 & (v57 >> 63);
          v60 = v6 & (v58 >> 63);
          v61 = v60 + v58;
          if (v59 + v57 >= v7)
            v62 = v7;
          else
            v62 = 0;
          if (v61 >= v6)
            v63 = v6;
          else
            v63 = 0;
          v54 = (v59 + (v56 >> 24) - v62) >> 32;
          v55 = (v60 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v63) >> 32;
        }
        v64 = (unsigned int *)(v46 + 4 * v55);
        if (v15 < (unint64_t)v64)
          v64 = (unsigned int *)v15;
        if (v64 < v47)
          v64 = v47;
        v65 = bswap32(*v64);
        v66 = v46 + (int)v54 * (uint64_t)v4;
        if (v15 >= v66)
          v67 = (unsigned int *)(v46 + (int)v54 * (uint64_t)v4);
        else
          v67 = (unsigned int *)v15;
        if (v67 < v47)
          v67 = v47;
        v68 = bswap32(*v67);
        v69 = (unsigned int *)(v66 + 4 * v55);
        if (v15 < (unint64_t)v69)
          v69 = (unsigned int *)v15;
        if (v69 < v47)
          v69 = v47;
        v70 = interpolate_8888_19472[v101];
        v71 = v49 - ((v70 & v49) >> (v101 + 1)) + ((v70 & v68) >> (v101 + 1));
        v72 = v65 - ((v70 & v65) >> (v101 + 1)) + ((bswap32(*v69) & v70) >> (v101 + 1));
        v73 = (v50 >> 28) & 3;
        v74 = interpolate_8888_19472[v73];
        LOBYTE(v73) = v73 + 1;
        v75 = v71 - ((v71 & v74) >> v73);
        v76 = (v72 & v74) >> v73;
LABEL_93:
        v49 = v75 + v76;
        break;
    }
LABEL_104:
    *(_DWORD *)(v12 + 4) = v49 | v14;
    *(_BYTE *)(v13 + 1) = v28 >> 22;
    if (a4 == 1)
      break;
    v90 = 0;
    a2 += v5;
    v91 = v103 - a2;
    a3 += v10;
    v92 = v105 - a3;
    v93 = -4;
    while (((v92 | v91 | (v17 + a3) | (v16 + a2)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v94 = (v7 & ((v26 + v107) >> 63)) + v26 + v107;
        v95 = (v6 & ((v35 + v108) >> 63)) + v35 + v108;
        if (v94 >= v7)
          v96 = v7;
        else
          v96 = 0;
        v97 = v94 - v96;
        if (v95 >= v6)
          v98 = v6;
        else
          v98 = 0;
        v99 = v95 - v98;
        v35 = v99;
        v26 = v97;
      }
      else
      {
        v99 = a2;
        HIDWORD(v97) = HIDWORD(a3);
      }
      v46 = v9 + SHIDWORD(v97) * (uint64_t)v4 + 4 * (v99 >> 32);
      v47 = *(unsigned int **)(result + 32);
      if (v15 >= v46)
        v100 = (unsigned int *)v46;
      else
        v100 = (unsigned int *)v15;
      if (v100 < v47)
        v100 = *(unsigned int **)(result + 32);
      v49 = bswap32(*v100);
      if (v8)
      {
        v50 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v50 & 0xF) != 0)
        {
          v13 += v90 + 1;
          v12 -= v93;
          a4 += ~(_DWORD)v90;
          v28 = -1;
          goto LABEL_58;
        }
      }
      *(_DWORD *)(v12 + 4 * v90 + 8) = v49 | v14;
      *(_BYTE *)(v13 + v90++ + 2) = -1;
      v93 -= 4;
      a2 += v5;
      v91 -= v5;
      a3 += v10;
      v92 -= v10;
      if (a4 - 1 == (_DWORD)v90)
        return result;
    }
    v13 += v90 + 1;
    v12 -= v93;
    a4 += ~(_DWORD)v90;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  unsigned int *v37;
  unint64_t v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int64_t v46;
  unsigned int *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int *v50;
  unint64_t v51;
  unsigned int *v52;
  unint64_t v53;
  unsigned __int8 *v54;
  unint64_t v55;
  unint64_t v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  uint64_t v59;
  char v60;
  unint64_t v61;
  int v62;
  unint64_t v63;
  char v64;
  unint64_t v65;
  unint64_t v66;
  unsigned int *v67;
  unint64_t v68;
  unsigned __int8 *v69;
  uint64_t v70;
  char v71;
  unint64_t v72;
  unsigned int *v73;
  uint64_t v74;
  unsigned __int8 *v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int *v82;
  unsigned __int8 *v83;
  unint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unsigned __int8 *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;

  v6 = *(_QWORD *)(result + 40);
  v7 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v88 = *(_QWORD *)(result + 88);
  v101 = *(_QWORD *)(result + 120);
  v102 = *(_QWORD *)(result + 112);
  v8 = (int *)(*(_QWORD *)(result + 152) - 4);
  v91 = *(_QWORD *)(result + 144) - 1;
  v9 = 0xFF00000000;
  if (v6)
    v9 = 0;
  v96 = v9;
  v10 = *(_DWORD *)(result + 260) - 1;
  v99 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v11 = *(unsigned int *)(result + 256);
  v86 = *(_DWORD *)(result + 188);
  v93 = *(_DWORD *)(result + 28);
  v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  v100 = v95 + (v10 * v99) + 4 * v11 - 8;
  v89 = *(_QWORD *)(result + 64);
  v90 = *(_QWORD *)(result + 72);
  v97 = *(_QWORD *)(result + 40);
  v98 = result;
  while (1)
  {
    if (a3 >= v90)
    {
      if (a3 <= v88)
      {
        v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        v24 = a3;
        v15 = a4;
        v16 = v89;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v88;
        v20 = v19 - a3 + (v18 >> 1);
        v15 = a4;
        v16 = v89;
        if (v20 < 1)
          goto LABEL_40;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v23 = v86 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v12 = *(_QWORD *)(result + 216);
      v13 = v90 - *(_QWORD *)(result + 224);
      v14 = a3 - v13 + (v12 >> 1);
      v15 = a4;
      v16 = v89;
      if (v14 < 1)
        goto LABEL_40;
      if (v14 >= v12)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v14) >> 32;
      v23 = v86 | v17;
      v24 = v13 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        v29 = ((unint64_t)a2 >> 26) & 0x3C;
        v28 = a2;
      }
      else
      {
        v30 = *(_QWORD *)(result + 192);
        v31 = *(_QWORD *)(result + 200) + v87;
        v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1)
          goto LABEL_40;
        if (v32 < v30)
          v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v86;
        v28 = v31 - 0x1000000;
        v29 = 28;
      }
    }
    else
    {
      v25 = *(_QWORD *)(result + 192);
      v26 = v16 - *(_QWORD *)(result + 200);
      v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1)
        goto LABEL_40;
      if (v27 < v25)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v86;
      v28 = v26 + 0x1000000;
      v29 = 32;
    }
    if (v23 >= 0x400000)
      break;
LABEL_40:
    v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(_BYTE *)++v91 = 0;
LABEL_41:
    a4 = v42;
    if (!v42)
      return result;
  }
  v33 = v24 >> 32;
  v34 = v28 >> 32;
  v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 4 * (v28 >> 32);
  v36 = *(unsigned int **)(result + 32);
  v37 = (unsigned int *)v100;
  if (v100 >= v35)
    v37 = (unsigned int *)v35;
  if (v37 < v36)
    v37 = *(unsigned int **)(result + 32);
  v38 = bswap32(*v37);
  if (v6)
  {
    v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    v40 = *(unsigned __int8 **)(result + 40);
    v41 = v94;
    v92 = v39;
    if ((unint64_t)v94 >= v39)
      v41 = (unsigned __int8 *)v39;
    if (v41 >= v40)
      v40 = v41;
    v38 |= (unint64_t)*v40 << 32;
    if (!v7)
      goto LABEL_102;
  }
  else
  {
    v92 = 0;
    if (!v7)
      goto LABEL_102;
  }
  v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_46:
  v44 = v43 & 0xF;
  v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    v67 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67)
      v67 = (unsigned int *)v100;
    if (v67 >= v36)
      v36 = v67;
    v68 = bswap32(*v36);
    if (v6)
    {
      v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69)
        v69 = v94;
      if ((unint64_t)v69 < *(_QWORD *)(result + 40))
        v69 = *(unsigned __int8 **)(result + 40);
      v68 |= (unint64_t)*v69 << 32;
    }
    v70 = interpolate_cif10a[v45];
    v71 = v45 + 1;
    v65 = v38 - ((v70 & v38) >> v71);
    v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      v73 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 54));
      if (v100 < (unint64_t)v73)
        v73 = (unsigned int *)v100;
      if (v73 >= v36)
        v36 = v73;
      v74 = bswap32(*v36);
      if (v6)
      {
        v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75)
          v75 = v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(unsigned __int8 **)(result + 40);
        v74 |= (unint64_t)*v75 << 32;
      }
      v76 = (v43 >> 28) & 3;
      v77 = interpolate_cif10a[v76];
      v64 = v76 + 1;
      v65 = v38 - ((v77 & v38) >> v64);
      v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3)
        goto LABEL_102;
      v46 = (unint64_t)HIWORD(v43) << 56;
      v47 = (unsigned int *)(v35 + (v46 >> 54));
      if (v100 < (unint64_t)v47)
        v47 = (unsigned int *)v100;
      if (v47 < v36)
        v47 = v36;
      v48 = bswap32(*v47);
      v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49)
        v50 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      else
        v50 = (unsigned int *)v100;
      if (v50 < v36)
        v50 = v36;
      v51 = bswap32(*v50);
      v52 = (unsigned int *)(v49 + (v46 >> 54));
      if (v100 < (unint64_t)v52)
        v52 = (unsigned int *)v100;
      if (v52 >= v36)
        v36 = v52;
      v53 = bswap32(*v36);
      if (v6)
      {
        v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        v55 = *(_QWORD *)(result + 40);
        if (v94 < v54)
          v54 = v94;
        if ((unint64_t)v54 < v55)
          v54 = *(unsigned __int8 **)(result + 40);
        v48 |= (unint64_t)*v54 << 32;
        v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56)
          v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        else
          v57 = v94;
        if ((unint64_t)v57 < v55)
          v57 = *(unsigned __int8 **)(result + 40);
        v51 |= (unint64_t)*v57 << 32;
        v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58)
          v58 = v94;
        if ((unint64_t)v58 < v55)
          v58 = *(unsigned __int8 **)(result + 40);
        v53 |= (unint64_t)*v58 << 32;
      }
      v59 = interpolate_cif10a[v45];
      v60 = v45 + 1;
      v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      v62 = (v43 >> 28) & 3;
      v63 = interpolate_cif10a[v62];
      v64 = v62 + 1;
      v65 = v61 - ((v61 & v63) >> v64);
      v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    v72 = v66 >> v64;
  }
  v38 = v65 + v72;
LABEL_102:
  v78 = 0;
  ++v8;
  v85 = v15;
  v79 = v15 - 1;
  a3 += v101;
  v80 = v88 - a3;
  a2 += v102;
  v81 = v87 - a2;
  while (1)
  {
    CMYK32_13340(v8, v38 | v96);
    *(_BYTE *)(v91 + 1 + v78) = v23 >> 22;
    v6 = v97;
    result = v98;
    if (v79 == (_DWORD)v78)
      return result;
    if ((v80 | v81 | (a3 - v90) | (a2 - v89)) < 0)
    {
      v91 += v78 + 1;
      v42 = ~(_DWORD)v78 + v85;
      goto LABEL_41;
    }
    v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32);
    v36 = *(unsigned int **)(v98 + 32);
    v82 = (unsigned int *)v100;
    if (v100 >= v35)
      v82 = (unsigned int *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32));
    if (v82 < v36)
      v82 = *(unsigned int **)(v98 + 32);
    v38 = bswap32(*v82);
    if (v97)
    {
      v83 = *(unsigned __int8 **)(v98 + 40);
      v84 = (unint64_t)v94;
      v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92)
        v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if (v84 >= (unint64_t)v83)
        v83 = (unsigned __int8 *)v84;
      v38 |= (unint64_t)*v83 << 32;
    }
    if (v7)
    {
      v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        v15 = ~(_DWORD)v78 + v85;
        v23 = -1;
        goto LABEL_46;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    v23 = -1;
  }
}

uint64_t argb32_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  unsigned int *v37;
  unint64_t v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int64_t v46;
  unsigned int *v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int *v50;
  unint64_t v51;
  unsigned int *v52;
  unint64_t v53;
  unsigned __int8 *v54;
  unint64_t v55;
  unint64_t v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  uint64_t v59;
  char v60;
  unint64_t v61;
  int v62;
  unint64_t v63;
  char v64;
  unint64_t v65;
  unint64_t v66;
  unsigned int *v67;
  unint64_t v68;
  unsigned __int8 *v69;
  uint64_t v70;
  char v71;
  unint64_t v72;
  unsigned int *v73;
  uint64_t v74;
  unsigned __int8 *v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int *v82;
  unsigned __int8 *v83;
  unint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unsigned __int8 *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;

  v6 = *(_QWORD *)(result + 40);
  v7 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v88 = *(_QWORD *)(result + 88);
  v101 = *(_QWORD *)(result + 120);
  v102 = *(_QWORD *)(result + 112);
  v8 = (int *)(*(_QWORD *)(result + 152) - 4);
  v91 = *(_QWORD *)(result + 144) - 1;
  v9 = 0xFF00000000;
  if (v6)
    v9 = 0;
  v96 = v9;
  v10 = *(_DWORD *)(result + 260) - 1;
  v99 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v11 = *(unsigned int *)(result + 256);
  v86 = *(_DWORD *)(result + 188);
  v93 = *(_DWORD *)(result + 28);
  v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  v100 = v95 + (v10 * v99) + 4 * v11 - 8;
  v89 = *(_QWORD *)(result + 64);
  v90 = *(_QWORD *)(result + 72);
  v97 = *(_QWORD *)(result + 40);
  v98 = result;
  while (1)
  {
    if (a3 >= v90)
    {
      if (a3 <= v88)
      {
        v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        v24 = a3;
        v15 = a4;
        v16 = v89;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v88;
        v20 = v19 - a3 + (v18 >> 1);
        v15 = a4;
        v16 = v89;
        if (v20 < 1)
          goto LABEL_40;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v23 = v86 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v12 = *(_QWORD *)(result + 216);
      v13 = v90 - *(_QWORD *)(result + 224);
      v14 = a3 - v13 + (v12 >> 1);
      v15 = a4;
      v16 = v89;
      if (v14 < 1)
        goto LABEL_40;
      if (v14 >= v12)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v14) >> 32;
      v23 = v86 | v17;
      v24 = v13 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        v29 = ((unint64_t)a2 >> 26) & 0x3C;
        v28 = a2;
      }
      else
      {
        v30 = *(_QWORD *)(result + 192);
        v31 = *(_QWORD *)(result + 200) + v87;
        v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1)
          goto LABEL_40;
        if (v32 < v30)
          v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v86;
        v28 = v31 - 0x1000000;
        v29 = 28;
      }
    }
    else
    {
      v25 = *(_QWORD *)(result + 192);
      v26 = v16 - *(_QWORD *)(result + 200);
      v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1)
        goto LABEL_40;
      if (v27 < v25)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v86;
      v28 = v26 + 0x1000000;
      v29 = 32;
    }
    if (v23 >= 0x400000)
      break;
LABEL_40:
    v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(_BYTE *)++v91 = 0;
LABEL_41:
    a4 = v42;
    if (!v42)
      return result;
  }
  v33 = v24 >> 32;
  v34 = v28 >> 32;
  v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 4 * (v28 >> 32);
  v36 = *(unsigned int **)(result + 32);
  v37 = (unsigned int *)v100;
  if (v100 >= v35)
    v37 = (unsigned int *)v35;
  if (v37 < v36)
    v37 = *(unsigned int **)(result + 32);
  v38 = *v37;
  if (v6)
  {
    v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    v40 = *(unsigned __int8 **)(result + 40);
    v41 = v94;
    v92 = v39;
    if ((unint64_t)v94 >= v39)
      v41 = (unsigned __int8 *)v39;
    if (v41 >= v40)
      v40 = v41;
    v38 |= (unint64_t)*v40 << 32;
    if (!v7)
      goto LABEL_102;
  }
  else
  {
    v92 = 0;
    if (!v7)
      goto LABEL_102;
  }
  v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_46:
  v44 = v43 & 0xF;
  v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    v67 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67)
      v67 = (unsigned int *)v100;
    if (v67 >= v36)
      v36 = v67;
    v68 = *v36;
    if (v6)
    {
      v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69)
        v69 = v94;
      if ((unint64_t)v69 < *(_QWORD *)(result + 40))
        v69 = *(unsigned __int8 **)(result + 40);
      v68 |= (unint64_t)*v69 << 32;
    }
    v70 = interpolate_cif10a[v45];
    v71 = v45 + 1;
    v65 = v38 - ((v70 & v38) >> v71);
    v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      v73 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 54));
      if (v100 < (unint64_t)v73)
        v73 = (unsigned int *)v100;
      if (v73 >= v36)
        v36 = v73;
      v74 = *v36;
      if (v6)
      {
        v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75)
          v75 = v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(unsigned __int8 **)(result + 40);
        v74 |= (unint64_t)*v75 << 32;
      }
      v76 = (v43 >> 28) & 3;
      v77 = interpolate_cif10a[v76];
      v64 = v76 + 1;
      v65 = v38 - ((v77 & v38) >> v64);
      v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3)
        goto LABEL_102;
      v46 = (unint64_t)HIWORD(v43) << 56;
      v47 = (unsigned int *)(v35 + (v46 >> 54));
      if (v100 < (unint64_t)v47)
        v47 = (unsigned int *)v100;
      if (v47 < v36)
        v47 = v36;
      v48 = *v47;
      v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49)
        v50 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      else
        v50 = (unsigned int *)v100;
      if (v50 < v36)
        v50 = v36;
      v51 = *v50;
      v52 = (unsigned int *)(v49 + (v46 >> 54));
      if (v100 < (unint64_t)v52)
        v52 = (unsigned int *)v100;
      if (v52 >= v36)
        v36 = v52;
      v53 = *v36;
      if (v6)
      {
        v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        v55 = *(_QWORD *)(result + 40);
        if (v94 < v54)
          v54 = v94;
        if ((unint64_t)v54 < v55)
          v54 = *(unsigned __int8 **)(result + 40);
        v48 |= (unint64_t)*v54 << 32;
        v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56)
          v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        else
          v57 = v94;
        if ((unint64_t)v57 < v55)
          v57 = *(unsigned __int8 **)(result + 40);
        v51 |= (unint64_t)*v57 << 32;
        v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58)
          v58 = v94;
        if ((unint64_t)v58 < v55)
          v58 = *(unsigned __int8 **)(result + 40);
        v53 |= (unint64_t)*v58 << 32;
      }
      v59 = interpolate_cif10a[v45];
      v60 = v45 + 1;
      v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      v62 = (v43 >> 28) & 3;
      v63 = interpolate_cif10a[v62];
      v64 = v62 + 1;
      v65 = v61 - ((v61 & v63) >> v64);
      v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    v72 = v66 >> v64;
  }
  v38 = v65 + v72;
LABEL_102:
  v78 = 0;
  ++v8;
  v85 = v15;
  v79 = v15 - 1;
  a3 += v101;
  v80 = v88 - a3;
  a2 += v102;
  v81 = v87 - a2;
  while (1)
  {
    CMYK32_13340(v8, v38 | v96);
    *(_BYTE *)(v91 + 1 + v78) = v23 >> 22;
    v6 = v97;
    result = v98;
    if (v79 == (_DWORD)v78)
      return result;
    if ((v80 | v81 | (a3 - v90) | (a2 - v89)) < 0)
    {
      v91 += v78 + 1;
      v42 = ~(_DWORD)v78 + v85;
      goto LABEL_41;
    }
    v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32);
    v36 = *(unsigned int **)(v98 + 32);
    v82 = (unsigned int *)v100;
    if (v100 >= v35)
      v82 = (unsigned int *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32));
    if (v82 < v36)
      v82 = *(unsigned int **)(v98 + 32);
    v38 = *v82;
    if (v97)
    {
      v83 = *(unsigned __int8 **)(v98 + 40);
      v84 = (unint64_t)v94;
      v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92)
        v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if (v84 >= (unint64_t)v83)
        v83 = (unsigned __int8 *)v84;
      v38 |= (unint64_t)*v83 << 32;
    }
    if (v7)
    {
      v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        v15 = ~(_DWORD)v78 + v85;
        v23 = -1;
        goto LABEL_46;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    v23 = -1;
  }
}

uint64_t argb32_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned __int16 *v43;
  unint64_t v44;
  unint64_t v45;
  unsigned __int16 *v46;
  unint64_t v47;
  unsigned __int16 *v48;
  uint64_t v49;
  char v50;
  unint64_t v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  char v55;
  unint64_t v56;
  unsigned __int16 *v57;
  uint64_t v58;
  char v59;
  unint64_t v60;
  unsigned __int16 *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int16 *v68;
  int v69;
  uint64_t v70;
  uint64_t v71;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v70 = *(_QWORD *)(result + 64);
  v71 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  v69 = *(_DWORD *)(result + 188);
  v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        v22 = (a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        v25 = v70;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v8;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_34;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v25 = v70;
        v23 = v69 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v7 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_34;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v25 = v70;
      v23 = v69 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v25)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v25 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v69;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(_BYTE *)++v12 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v71)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v71;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v69;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v23 < 0x400000)
    goto LABEL_34;
  v34 = v29 >> 32;
  v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  v36 = v35 + 6 * (int)v34;
  v37 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v36)
    v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  else
    v38 = (unsigned __int16 *)v13;
  if (v38 < v37)
    v38 = *(unsigned __int16 **)(result + 32);
  v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6)
    goto LABEL_66;
  v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57)
        v57 = (unsigned __int16 *)v13;
      if (v57 < v37)
        v57 = v37;
      v58 = interpolate_16161616_19469[v42];
      v59 = v42 + 1;
      v56 = v39 - ((v58 & v39) >> v59);
      v60 = (((bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      v39 = v56 + v60;
      break;
    case 2:
      v61 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61)
        v61 = (unsigned __int16 *)v13;
      if (v61 < v37)
        v61 = v37;
      v52 = (bswap32(*v61) >> 16) | ((unint64_t)(bswap32(v61[1]) >> 16) << 16) | ((unint64_t)(bswap32(v61[2]) >> 16) << 32) | 0xFFFF000000000000;
      v62 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v62];
      v55 = v62 + 1;
      v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43)
        v43 = (unsigned __int16 *)v13;
      if (v43 < v37)
        v43 = v37;
      v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45)
        v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      else
        v46 = (unsigned __int16 *)v13;
      if (v46 < v37)
        v46 = v37;
      v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48)
        v48 = (unsigned __int16 *)v13;
      if (v48 < v37)
        v48 = v37;
      v49 = interpolate_16161616_19469[v42];
      v50 = v42 + 1;
      v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      v53 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v53];
      v55 = v53 + 1;
      v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  v63 = 0;
  v64 = 0;
  a3 += v10;
  v65 = v8 - a3;
  a2 += v9;
  v66 = v71 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = BYTE5(v39) | HIDWORD(v39) & 0xFF000000 | (BYTE1(v39) << 16) | (BYTE3(v39) << 8);
    *(_BYTE *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v65 | v66 | (a3 - v7) | (a2 - v70)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      v11 = v11 - v63 + 4;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v67 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v36 = v67 + 6 * SHIDWORD(a2);
    v37 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v36)
      v68 = (unsigned __int16 *)(v67 + 6 * SHIDWORD(a2));
    else
      v68 = (unsigned __int16 *)v13;
    if (v68 < v37)
      v68 = *(unsigned __int16 **)(result + 32);
    v39 = (bswap32(*v68) >> 16) | ((unint64_t)(bswap32(v68[1]) >> 16) << 16) | ((unint64_t)(bswap32(v68[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        v11 = v11 - v63 + 4;
        a4 += ~(_DWORD)v64;
        v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    v23 = -1;
  }
}

uint64_t argb32_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  unsigned int *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int *v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int *v46;
  unint64_t v47;
  unsigned int *v48;
  uint64_t v49;
  char v50;
  unint64_t v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  char v55;
  unint64_t v56;
  unsigned int *v57;
  uint64_t v58;
  char v59;
  unint64_t v60;
  unsigned int *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int *v67;
  int v68;
  uint64_t v69;
  uint64_t v70;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 72);
  v8 = *(_QWORD *)(result + 88);
  v69 = *(_QWORD *)(result + 64);
  v70 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v10 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 4;
  v12 = *(_QWORD *)(result + 144) - 1;
  v68 = *(_DWORD *)(result + 188);
  v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        v22 = (a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        v25 = v69;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v8;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_34;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v25 = v69;
        v23 = v68 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v7 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_34;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v25 = v69;
      v23 = v68 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v25)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v25 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v68;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(_BYTE *)++v12 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v70)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_26;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v70;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_34;
  if (v33 < v31)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v68;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_26:
  if (v23 < 0x400000)
    goto LABEL_34;
  v34 = v29 >> 32;
  v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  v36 = v35 + 6 * (int)v34;
  v37 = *(unsigned int **)(result + 32);
  if (v13 >= v36)
    v38 = (unsigned int *)(v35 + 6 * (int)v34);
  else
    v38 = (unsigned int *)v13;
  if (v38 < v37)
    v38 = *(unsigned int **)(result + 32);
  v39 = *v38 | ((unint64_t)*((unsigned __int16 *)v38 + 2) << 32) | 0xFFFF000000000000;
  if (!v6)
    goto LABEL_66;
  v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v57 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57)
        v57 = (unsigned int *)v13;
      if (v57 < v37)
        v57 = v37;
      v58 = interpolate_16161616_19469[v42];
      v59 = v42 + 1;
      v56 = v39 - ((v58 & v39) >> v59);
      v60 = ((*v57 | ((unint64_t)*((unsigned __int16 *)v57 + 2) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      v39 = v56 + v60;
      break;
    case 2:
      v61 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61)
        v61 = (unsigned int *)v13;
      if (v61 < v37)
        v61 = v37;
      v52 = *v61 | ((unint64_t)*((unsigned __int16 *)v61 + 2) << 32) | 0xFFFF000000000000;
      v62 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v62];
      v55 = v62 + 1;
      v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      v43 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43)
        v43 = (unsigned int *)v13;
      if (v43 < v37)
        v43 = v37;
      v44 = *v43 | ((unint64_t)*((unsigned __int16 *)v43 + 2) << 32) | 0xFFFF000000000000;
      v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45)
        v46 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      else
        v46 = (unsigned int *)v13;
      if (v46 < v37)
        v46 = v37;
      v47 = *v46 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32) | 0xFFFF000000000000;
      v48 = (unsigned int *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48)
        v48 = (unsigned int *)v13;
      if (v48 < v37)
        v48 = v37;
      v49 = interpolate_16161616_19469[v42];
      v50 = v42 + 1;
      v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      v52 = v44
          - ((v49 & v44) >> v50)
          + (((*v48 | ((unint64_t)*((unsigned __int16 *)v48 + 2) << 32) | 0xFFFF000000000000) & v49) >> v50);
      v53 = (v40 >> 28) & 3;
      v54 = interpolate_16161616_19469[v53];
      v55 = v53 + 1;
      v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  v63 = 0;
  v64 = 0;
  a3 += v10;
  v65 = v8 - a3;
  a2 += v9;
  v66 = v70 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = BYTE5(v39) | HIDWORD(v39) & 0xFF000000 | (BYTE1(v39) << 16) | (BYTE3(v39) << 8);
    *(_BYTE *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v65 | v66 | (a3 - v7) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      v11 = v11 - v63 + 4;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v36 = v4 + SHIDWORD(a3) * (uint64_t)v5 + 6 * SHIDWORD(a2);
    v37 = *(unsigned int **)(result + 32);
    if (v13 >= v36)
      v67 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v5 + 6 * SHIDWORD(a2));
    else
      v67 = (unsigned int *)v13;
    if (v67 < v37)
      v67 = *(unsigned int **)(result + 32);
    v39 = *v67 | ((unint64_t)*((unsigned __int16 *)v67 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        v11 = v11 - v63 + 4;
        a4 += ~(_DWORD)v64;
        v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    v23 = -1;
  }
}

uint64_t argb32_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  unint64_t v40;
  unsigned int v41;
  int v42;
  int v43;
  int64_t v44;
  unsigned __int16 *v45;
  unint64_t v46;
  unint64_t v47;
  unsigned __int16 *v48;
  unint64_t v49;
  unsigned __int16 *v50;
  uint64_t v51;
  char v52;
  unint64_t v53;
  unint64_t v54;
  int v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int16 *v59;
  uint64_t v60;
  char v61;
  unsigned __int16 *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned __int16 *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v73 = *(_QWORD *)(result + 80);
  v72 = *(_QWORD *)(result + 88);
  v7 = *(_QWORD *)(result + 112);
  v8 = *(_QWORD *)(result + 120);
  v70 = *(_DWORD *)(result + 188);
  v9 = *(_QWORD *)(result + 152) - 4;
  v10 = *(_QWORD *)(result + 144) - 1;
  v11 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v12 = 0;
  else
    v12 = 0xFF00000000000000;
  v13 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  v71 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v72)
      {
        v22 = (a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        v25 = v71;
        v26 = v73;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v72;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_37;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v25 = v71;
        v26 = v73;
        v23 = v70 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v6 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_37;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v25 = v71;
      v26 = v73;
      v23 = v70 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v25)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v25 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v70;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v7;
    a3 += v8;
    v9 += 4;
    *(_BYTE *)++v10 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v26)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_29;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v26;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_37;
  if (v34 < v32)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v70;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_29:
  if (v23 < 0x400000)
    goto LABEL_37;
  v35 = v11 + SHIDWORD(v24) * (uint64_t)v4;
  v36 = v30 >> 32;
  v37 = v35 + 8 * v36;
  v38 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v37)
    v39 = (unsigned __int16 *)(v35 + 8 * v36);
  else
    v39 = (unsigned __int16 *)v13;
  if (v39 < v38)
    v39 = *(unsigned __int16 **)(result + 32);
  v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    v41 = *(_DWORD *)(v5 + (v31 | v22));
LABEL_40:
    v42 = v41 & 0xF;
    v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        v59 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v13 < (unint64_t)v59)
          v59 = (unsigned __int16 *)v13;
        if (v59 < v38)
          v59 = v38;
        v60 = interpolate_16161616_19469[v43];
        v61 = v43 + 1;
        v57 = v40 - ((v60 & v40) >> v61);
        v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v60) >> v61;
LABEL_62:
        v40 = v57 + v58;
        break;
      case 2:
        v62 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
        if (v13 < (unint64_t)v62)
          v62 = (unsigned __int16 *)v13;
        if (v62 < v38)
          v62 = v38;
        v63 = (v41 >> 28) & 3;
        v40 = v40
            - ((interpolate_16161616_19469[v63] & v40) >> (v63 + 1))
            + (((((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16)) & interpolate_16161616_19469[v63]) >> (v63 + 1));
        break;
      case 3:
        v44 = (unint64_t)HIWORD(v41) << 56;
        v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
        if (v13 < (unint64_t)v45)
          v45 = (unsigned __int16 *)v13;
        if (v45 < v38)
          v45 = v38;
        v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
        v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v13 >= v47)
          v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        else
          v48 = (unsigned __int16 *)v13;
        if (v48 < v38)
          v48 = v38;
        v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
        v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
        if (v13 < (unint64_t)v50)
          v50 = (unsigned __int16 *)v13;
        if (v50 < v38)
          v50 = v38;
        v51 = interpolate_16161616_19469[v43];
        v52 = v43 + 1;
        v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
        v54 = v46
            - ((v51 & v46) >> v52)
            + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52);
        v55 = (v41 >> 28) & 3;
        v56 = interpolate_16161616_19469[v55];
        LOBYTE(v55) = v55 + 1;
        v57 = v53 - ((v53 & v56) >> v55);
        v58 = (v54 & v56) >> v55;
        goto LABEL_62;
    }
  }
  v64 = 0;
  v65 = 0;
  a3 += v8;
  v66 = v72 - a3;
  a2 += v7;
  v67 = v73 - a2;
  while (1)
  {
    *(_DWORD *)(v9 + 4 + 4 * v65) = BYTE5(v40) | (BYTE1(v40) << 16) | (BYTE3(v40) << 8) | ((v40 | v12) >> 32) & 0xFF000000;
    *(_BYTE *)(v10 + 1 + v65) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v65)
      return result;
    if (((v66 | v67 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v10 += v65 + 1;
      v9 = v9 - v64 + 4;
      a4 += ~(_DWORD)v65;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v68 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    v37 = v68 + 8 * (a2 >> 32);
    v38 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v37)
      v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    else
      v69 = (unsigned __int16 *)v13;
    if (v69 < v38)
      v69 = *(unsigned __int16 **)(result + 32);
    v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v10 += v65 + 1;
        v9 = v9 - v64 + 4;
        a4 += ~(_DWORD)v65;
        v23 = -1;
        goto LABEL_40;
      }
    }
    ++v65;
    v64 -= 4;
    a3 += v8;
    v66 -= v8;
    a2 += v7;
    v67 -= v7;
    v23 = -1;
  }
}

uint64_t argb32_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t *v37;
  unint64_t *v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  int64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  int v54;
  unint64_t v55;
  char v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t *v59;
  unint64_t v60;
  char v61;
  unint64_t v62;
  unint64_t *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v6 = *(_QWORD *)(result + 72);
  v7 = *(_QWORD *)(result + 88);
  v74 = *(_QWORD *)(result + 80);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v72 = *(_DWORD *)(result + 188);
  v10 = *(_QWORD *)(result + 152) - 4;
  v11 = *(_QWORD *)(result + 144) - 1;
  v12 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(result + 40))
    v13 = 0;
  else
    v13 = 0xFF00000000000000;
  v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  v73 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        v23 = (a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v7;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_37;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v24 = v72 | v22;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v6 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_37;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v24 = v72 | v18;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v73)
      break;
    v26 = *(_QWORD *)(result + 192);
    v27 = v73 - *(_QWORD *)(result + 200);
    v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v28) >> 32) >> 15)) | v72;
      v29 = v27 + 0x1000000;
      v30 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 4;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v74)
  {
    v30 = ((unint64_t)a2 >> 26) & 0x3C;
    v29 = a2;
    goto LABEL_29;
  }
  v31 = *(_QWORD *)(result + 192);
  v32 = *(_QWORD *)(result + 200) + v74;
  v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1)
    goto LABEL_37;
  if (v33 < v31)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v72;
  v29 = v32 - 0x1000000;
  v30 = 28;
LABEL_29:
  if (v24 < 0x400000)
    goto LABEL_37;
  v34 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  v35 = v29 >> 32;
  v36 = v34 + 8 * v35;
  v37 = *(unint64_t **)(result + 32);
  if (v14 >= v36)
    v38 = (unint64_t *)(v34 + 8 * v35);
  else
    v38 = (unint64_t *)v14;
  if (v38 < v37)
    v38 = *(unint64_t **)(result + 32);
  v39 = *v38;
  if (!v5)
    goto LABEL_69;
  v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_40:
  v41 = v40 & 0xF;
  v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      v59 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59)
        v59 = (unint64_t *)v14;
      if (v59 < v37)
        v59 = v37;
      v60 = interpolate_16161616_19469[v42];
      v61 = v42 + 1;
      v57 = v39 - ((v60 & v39) >> v61);
      v62 = (v60 & *v59) >> v61;
LABEL_68:
      v39 = v57 + v62;
      break;
    case 2:
      v63 = (unint64_t *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 53));
      if (v14 < (unint64_t)v63)
        v63 = (unint64_t *)v14;
      if (v63 < v37)
        v63 = v37;
      v64 = (v40 >> 28) & 3;
      v65 = interpolate_16161616_19469[v64];
      v56 = v64 + 1;
      v57 = v39 - ((v65 & v39) >> v56);
      v58 = v65 & *v63;
LABEL_67:
      v62 = v58 >> v56;
      goto LABEL_68;
    case 3:
      v43 = (unint64_t)HIWORD(v40) << 56;
      v44 = (unint64_t *)(v36 + (v43 >> 53));
      if (v14 < (unint64_t)v44)
        v44 = (unint64_t *)v14;
      if (v44 < v37)
        v44 = v37;
      v45 = *v44;
      v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46)
        v47 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      else
        v47 = (unint64_t *)v14;
      if (v47 < v37)
        v47 = v37;
      v48 = *v47;
      v49 = (unint64_t *)(v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49)
        v49 = (unint64_t *)v14;
      if (v49 < v37)
        v49 = v37;
      v50 = interpolate_16161616_19469[v42];
      v51 = v42 + 1;
      v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      v54 = (v40 >> 28) & 3;
      v55 = interpolate_16161616_19469[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      v58 = v53 & v55;
      goto LABEL_67;
  }
LABEL_69:
  v66 = 0;
  v67 = 0;
  a3 += v9;
  v68 = v7 - a3;
  a2 += v8;
  v69 = v74 - a2;
  while (1)
  {
    *(_DWORD *)(v10 + 4 + 4 * v66) = BYTE5(v39) | (BYTE1(v39) << 16) | (BYTE3(v39) << 8) | ((v39 | v13) >> 32) & 0xFF000000;
    *(_BYTE *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v66)
      return result;
    if (((v68 | v69 | (a3 - v6) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v10 = v10 - v67 + 4;
      v11 += v66 + 1;
      a4 += ~(_DWORD)v66;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v70 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    v36 = v70 + 8 * (a2 >> 32);
    v37 = *(unint64_t **)(result + 32);
    if (v14 >= v36)
      v71 = (unint64_t *)(v70 + 8 * (a2 >> 32));
    else
      v71 = (unint64_t *)v14;
    if (v71 < v37)
      v71 = *(unint64_t **)(result + 32);
    v39 = *v71;
    if (v5)
    {
      v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v10 = v10 - v67 + 4;
        v11 += v66 + 1;
        a4 += ~(_DWORD)v66;
        v24 = -1;
        goto LABEL_40;
      }
    }
    v67 -= 4;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    v24 = -1;
  }
}

int *argb32_sample_RGBF(int *result, unint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int8x8_t *v36;
  int8x8_t *v37;
  float32x2_t v38;
  float v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int8x8_t *v44;
  int8x8_t *v45;
  float v46;
  int8x8_t *v47;
  float32x2_t v48;
  int8x8_t *v49;
  float v50;
  _DWORD *v51;
  int8x8_t *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int8x8_t *v57;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;

  v12 = *((_QWORD *)result + 22);
  v60 = *((_QWORD *)result + 10);
  v63 = *((_QWORD *)result + 11);
  v68 = *((_QWORD *)result + 15);
  v69 = *((_QWORD *)result + 14);
  v13 = (int *)(*((_QWORD *)result + 19) - 4);
  v64 = *((_QWORD *)result + 18) - 1;
  v65 = *((_QWORD *)result + 4);
  v66 = result[6];
  v70 = result;
  v59 = result[47];
  v67 = v65 + ((result[65] - 1) * v66) + 4 * (3 * result[64]) - 16;
  v61 = *((_QWORD *)result + 8);
  v62 = *((_QWORD *)result + 9);
  while (1)
  {
    if ((uint64_t)a3 >= v62)
    {
      if ((uint64_t)a3 <= v63)
      {
        v24 = (a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        v17 = a4;
        v18 = v61;
      }
      else
      {
        v20 = *((_QWORD *)v70 + 27);
        v21 = *((_QWORD *)v70 + 28) + v63;
        v22 = v21 - a3 + (v20 >> 1);
        v17 = a4;
        v18 = v61;
        if (v22 < 1)
          goto LABEL_33;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*((_QWORD *)v70 + 29) * v22) >> 32;
        v25 = v59 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v14 = *((_QWORD *)v70 + 27);
      v15 = v62 - *((_QWORD *)v70 + 28);
      v16 = a3 - v15 + (v14 >> 1);
      v17 = a4;
      v18 = v61;
      if (v16 < 1)
        goto LABEL_33;
      if (v16 >= v14)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*((_QWORD *)v70 + 29) * v16) >> 32;
      v25 = v59 | v19;
      v26 = v15 + 0x1000000;
      v24 = 512;
    }
    if ((uint64_t)a2 >= v18)
    {
      if ((uint64_t)a2 <= v60)
      {
        v31 = (a2 >> 26) & 0x3C;
        HIDWORD(v30) = HIDWORD(a2);
      }
      else
      {
        v32 = *((_QWORD *)v70 + 24);
        v33 = *((_QWORD *)v70 + 25) + v60;
        v34 = v33 - a2 + (v32 >> 1);
        if (v34 < 1)
          goto LABEL_33;
        if (v34 < v32)
          v25 = ((v25 >> 15) * (((unint64_t)(*((_QWORD *)v70 + 26) * v34) >> 32) >> 15)) | v59;
        v30 = v33 - 0x1000000;
        v31 = 28;
      }
    }
    else
    {
      v27 = *((_QWORD *)v70 + 24);
      v28 = v18 - *((_QWORD *)v70 + 25);
      v29 = a2 - v28 + (v27 >> 1);
      if (v29 < 1)
        goto LABEL_33;
      if (v29 < v27)
        v25 = ((v25 >> 15) * (((unint64_t)(*((_QWORD *)v70 + 26) * v29) >> 32) >> 15)) | v59;
      v30 = v28 + 0x1000000;
      v31 = 32;
    }
    if (v25 >= 0x400000)
      break;
LABEL_33:
    v41 = v17 - 1;
    a2 += v69;
    a3 += v68;
    ++v13;
    *(_BYTE *)++v64 = 0;
LABEL_34:
    a4 = v41;
    if (!v41)
      return result;
  }
  v35 = v65 + SHIDWORD(v26) * (uint64_t)v66 + 12 * SHIDWORD(v30);
  v36 = (int8x8_t *)*((_QWORD *)v70 + 4);
  v37 = (int8x8_t *)v67;
  if (v67 >= v35)
    v37 = (int8x8_t *)v35;
  if (v37 < v36)
    v37 = (int8x8_t *)*((_QWORD *)v70 + 4);
  v38 = (float32x2_t)vrev32_s8(*v37);
  v39 = COERCE_FLOAT(bswap32(v37[1].u32[0]));
  if (!v12)
    goto LABEL_36;
  v40 = *(_DWORD *)(v12 + (v31 | v24));
LABEL_38:
  v42 = v40 & 0xF;
  v43 = HIBYTE(v40) & 3;
  if (v42 == 1)
  {
    v49 = (int8x8_t *)(v35 + SBYTE1(v40) * (uint64_t)v66);
    if (v67 < (unint64_t)v49)
      v49 = (int8x8_t *)v67;
    if (v49 >= v36)
      v36 = v49;
    v50 = COERCE_FLOAT(bswap32(v36[1].u32[0]));
    v51 = &interpolate_rgbaf_19467[4 * v43];
    goto LABEL_61;
  }
  if (v42 == 2)
  {
    v52 = (int8x8_t *)(v35 + 12 * SBYTE2(v40));
    if (v67 < (unint64_t)v52)
      v52 = (int8x8_t *)v67;
    if (v52 >= v36)
      v36 = v52;
    v50 = COERCE_FLOAT(bswap32(v36[1].u32[0]));
    v51 = &interpolate_rgbaf_19467[4 * ((v40 >> 28) & 3)];
LABEL_61:
    LODWORD(a8) = v51[3];
    v38 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a8, 0), (float32x2_t)vrev32_s8(*v36), *(float *)&a8);
    v39 = (float)(v39 - (float)(v39 * *(float *)&a8)) + (float)(v50 * *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 + (float)(1.0 - *(float *)&a8);
    goto LABEL_62;
  }
  if (v42 != 3)
  {
LABEL_36:
    LODWORD(a8) = 1.0;
    goto LABEL_62;
  }
  v44 = (int8x8_t *)(v35 + 12 * SBYTE2(v40));
  if (v67 >= (unint64_t)v44)
    v45 = v44;
  else
    v45 = (int8x8_t *)v67;
  if (v45 < v36)
    v45 = v36;
  v46 = COERCE_FLOAT(bswap32(v45[1].u32[0]));
  v47 = (int8x8_t *)((char *)v44 + SBYTE1(v40) * (uint64_t)v66);
  if (v67 < (unint64_t)v47)
    v47 = (int8x8_t *)v67;
  if (v47 >= v36)
    v36 = v47;
  LODWORD(a9) = interpolate_rgbaf_19467[4 * v43 + 3];
  LODWORD(a10) = interpolate_rgbaf_19467[4 * ((v40 >> 28) & 3) + 3];
  v39 = (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v46 * *(float *)&a9))
              - (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v46 * *(float *)&a9))
                      * *(float *)&a10))
      + (float)((float)((float)(v46 - (float)(v46 * *(float *)&a9))
                      + (float)(COERCE_FLOAT(bswap32(v36[1].u32[0])) * *(float *)&a9))
              * *(float *)&a10);
  a8 = COERCE_DOUBLE(vrev32_s8(*v45));
  v48 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a8, *(float *)&a9);
  v38 = vmla_n_f32(vmls_lane_f32(v48, v48, *(float32x2_t *)&a10, 0), vmla_n_f32(vmls_lane_f32(*(float32x2_t *)&a8, *(float32x2_t *)&a8, *(float32x2_t *)&a9, 0), (float32x2_t)vrev32_s8(*v36), *(float *)&a9), *(float *)&a10);
  *(float *)&a8 = (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9))
                        - (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10))
                + (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10);
LABEL_62:
  v53 = 0;
  ++v13;
  v58 = v17;
  v54 = v17 - 1;
  a3 += v68;
  v55 = v63 - a3;
  a2 += v69;
  v56 = v60 - a2;
  while (1)
  {
    result = RGBAF(v13, v38.f32[0], v38.f32[1], v39, *(float *)&a8);
    *(_BYTE *)(v64 + 1 + v53) = v25 >> 22;
    if (v54 == (_DWORD)v53)
      return result;
    if (((v55 | v56 | (a3 - v62) | (a2 - v61)) & 0x8000000000000000) != 0)
    {
      v64 += v53 + 1;
      v41 = ~(_DWORD)v53 + v58;
      goto LABEL_34;
    }
    v35 = v65 + SHIDWORD(a3) * (uint64_t)v66 + 12 * SHIDWORD(a2);
    v36 = (int8x8_t *)*((_QWORD *)v70 + 4);
    v57 = (int8x8_t *)v67;
    if (v67 >= v35)
      v57 = (int8x8_t *)(v65 + SHIDWORD(a3) * (uint64_t)v66 + 12 * SHIDWORD(a2));
    if (v57 < v36)
      v57 = (int8x8_t *)*((_QWORD *)v70 + 4);
    v38 = (float32x2_t)vrev32_s8(*v57);
    v39 = COERCE_FLOAT(bswap32(v57[1].u32[0]));
    if (v12)
    {
      v40 = *(_DWORD *)(v12 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v64 += v53 + 1;
        v17 = ~(_DWORD)v53 + v58;
        v25 = -1;
        goto LABEL_38;
      }
    }
    ++v53;
    ++v13;
    a3 += v68;
    v55 -= v68;
    a2 += v69;
    v56 -= v69;
    LODWORD(a8) = 1.0;
    v25 = -1;
  }
}

int *argb32_sample_RGBf(int *result, unint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  float32x2_t *v36;
  float32x2_t *v37;
  float32x2_t v38;
  float v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  float32x2_t *v44;
  float32x2_t *v45;
  float32x2_t *v46;
  float32x2_t v47;
  float32x2_t *v48;
  float v49;
  _DWORD *v50;
  float32x2_t *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;

  v12 = *((_QWORD *)result + 22);
  v59 = *((_QWORD *)result + 10);
  v62 = *((_QWORD *)result + 11);
  v67 = *((_QWORD *)result + 15);
  v68 = *((_QWORD *)result + 14);
  v13 = (int *)(*((_QWORD *)result + 19) - 4);
  v63 = *((_QWORD *)result + 18) - 1;
  v64 = *((_QWORD *)result + 4);
  v65 = result[6];
  v69 = result;
  v58 = result[47];
  v66 = v64 + ((result[65] - 1) * v65) + 4 * (3 * result[64]) - 16;
  v60 = *((_QWORD *)result + 8);
  v61 = *((_QWORD *)result + 9);
  while (1)
  {
    if ((uint64_t)a3 >= v61)
    {
      if ((uint64_t)a3 <= v62)
      {
        v24 = (a3 >> 22) & 0x3C0;
        v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        v17 = a4;
        v18 = v60;
      }
      else
      {
        v20 = *((_QWORD *)v69 + 27);
        v21 = *((_QWORD *)v69 + 28) + v62;
        v22 = v21 - a3 + (v20 >> 1);
        v17 = a4;
        v18 = v60;
        if (v22 < 1)
          goto LABEL_33;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*((_QWORD *)v69 + 29) * v22) >> 32;
        v25 = v58 | v23;
        v26 = v21 - 0x1000000;
        v24 = 448;
      }
    }
    else
    {
      v14 = *((_QWORD *)v69 + 27);
      v15 = v61 - *((_QWORD *)v69 + 28);
      v16 = a3 - v15 + (v14 >> 1);
      v17 = a4;
      v18 = v60;
      if (v16 < 1)
        goto LABEL_33;
      if (v16 >= v14)
        LODWORD(v19) = 0x3FFFFFFF;
      else
        v19 = (unint64_t)(*((_QWORD *)v69 + 29) * v16) >> 32;
      v25 = v58 | v19;
      v26 = v15 + 0x1000000;
      v24 = 512;
    }
    if ((uint64_t)a2 >= v18)
    {
      if ((uint64_t)a2 <= v59)
      {
        v31 = (a2 >> 26) & 0x3C;
        HIDWORD(v30) = HIDWORD(a2);
      }
      else
      {
        v32 = *((_QWORD *)v69 + 24);
        v33 = *((_QWORD *)v69 + 25) + v59;
        v34 = v33 - a2 + (v32 >> 1);
        if (v34 < 1)
          goto LABEL_33;
        if (v34 < v32)
          v25 = ((v25 >> 15) * (((unint64_t)(*((_QWORD *)v69 + 26) * v34) >> 32) >> 15)) | v58;
        v30 = v33 - 0x1000000;
        v31 = 28;
      }
    }
    else
    {
      v27 = *((_QWORD *)v69 + 24);
      v28 = v18 - *((_QWORD *)v69 + 25);
      v29 = a2 - v28 + (v27 >> 1);
      if (v29 < 1)
        goto LABEL_33;
      if (v29 < v27)
        v25 = ((v25 >> 15) * (((unint64_t)(*((_QWORD *)v69 + 26) * v29) >> 32) >> 15)) | v58;
      v30 = v28 + 0x1000000;
      v31 = 32;
    }
    if (v25 >= 0x400000)
      break;
LABEL_33:
    v41 = v17 - 1;
    a2 += v68;
    a3 += v67;
    ++v13;
    *(_BYTE *)++v63 = 0;
LABEL_34:
    a4 = v41;
    if (!v41)
      return result;
  }
  v35 = v64 + SHIDWORD(v26) * (uint64_t)v65 + 12 * SHIDWORD(v30);
  v36 = (float32x2_t *)*((_QWORD *)v69 + 4);
  v37 = (float32x2_t *)v66;
  if (v66 >= v35)
    v37 = (float32x2_t *)v35;
  if (v37 < v36)
    v37 = (float32x2_t *)*((_QWORD *)v69 + 4);
  v38 = *v37;
  v39 = v37[1].f32[0];
  if (!v12)
    goto LABEL_36;
  v40 = *(_DWORD *)(v12 + (v31 | v24));
LABEL_38:
  v42 = v40 & 0xF;
  v43 = HIBYTE(v40) & 3;
  if (v42 == 1)
  {
    v48 = (float32x2_t *)(v35 + SBYTE1(v40) * (uint64_t)v65);
    if (v66 < (unint64_t)v48)
      v48 = (float32x2_t *)v66;
    if (v48 >= v36)
      v36 = v48;
    v49 = v36[1].f32[0];
    v50 = &interpolate_rgbaf_19467[4 * v43];
    goto LABEL_61;
  }
  if (v42 == 2)
  {
    v51 = (float32x2_t *)(v35 + 12 * SBYTE2(v40));
    if (v66 < (unint64_t)v51)
      v51 = (float32x2_t *)v66;
    if (v51 >= v36)
      v36 = v51;
    v49 = v36[1].f32[0];
    v50 = &interpolate_rgbaf_19467[4 * ((v40 >> 28) & 3)];
LABEL_61:
    LODWORD(a8) = v50[3];
    v38 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a8, 0), *v36, *(float *)&a8);
    v39 = (float)(v39 - (float)(v39 * *(float *)&a8)) + (float)(v49 * *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 + (float)(1.0 - *(float *)&a8);
    goto LABEL_62;
  }
  if (v42 != 3)
  {
LABEL_36:
    LODWORD(a8) = 1.0;
    goto LABEL_62;
  }
  v44 = (float32x2_t *)(v35 + 12 * SBYTE2(v40));
  if (v66 >= (unint64_t)v44)
    v45 = v44;
  else
    v45 = (float32x2_t *)v66;
  if (v45 < v36)
    v45 = v36;
  v46 = (float32x2_t *)((char *)v44 + SBYTE1(v40) * (uint64_t)v65);
  if (v66 < (unint64_t)v46)
    v46 = (float32x2_t *)v66;
  if (v46 >= v36)
    v36 = v46;
  LODWORD(a9) = interpolate_rgbaf_19467[4 * v43 + 3];
  LODWORD(a10) = interpolate_rgbaf_19467[4 * ((v40 >> 28) & 3) + 3];
  v39 = (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v45[1].f32[0] * *(float *)&a9))
              - (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v45[1].f32[0] * *(float *)&a9))
                      * *(float *)&a10))
      + (float)((float)((float)(v45[1].f32[0] - (float)(v45[1].f32[0] * *(float *)&a9))
                      + (float)(v36[1].f32[0] * *(float *)&a9))
              * *(float *)&a10);
  v47 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a9, 0), *v45, *(float *)&a9);
  v38 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a10, 0), vmla_n_f32(vmls_lane_f32(*v45, *v45, *(float32x2_t *)&a9, 0), *v36, *(float *)&a9), *(float *)&a10);
  *(float *)&a8 = (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9))
                        - (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10))
                + (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10);
LABEL_62:
  v52 = 0;
  ++v13;
  v57 = v17;
  v53 = v17 - 1;
  a3 += v67;
  v54 = v62 - a3;
  a2 += v68;
  v55 = v59 - a2;
  while (1)
  {
    result = RGBAF(v13, v38.f32[0], v38.f32[1], v39, *(float *)&a8);
    *(_BYTE *)(v63 + 1 + v52) = v25 >> 22;
    if (v53 == (_DWORD)v52)
      return result;
    if (((v54 | v55 | (a3 - v61) | (a2 - v60)) & 0x8000000000000000) != 0)
    {
      v63 += v52 + 1;
      v41 = ~(_DWORD)v52 + v57;
      goto LABEL_34;
    }
    v35 = v64 + SHIDWORD(a3) * (uint64_t)v65 + 12 * SHIDWORD(a2);
    v36 = (float32x2_t *)*((_QWORD *)v69 + 4);
    v56 = v66;
    if (v66 >= v35)
      v56 = v64 + SHIDWORD(a3) * (uint64_t)v65 + 12 * SHIDWORD(a2);
    if (v56 < (unint64_t)v36)
      v56 = *((_QWORD *)v69 + 4);
    v38 = *(float32x2_t *)v56;
    v39 = *(float *)(v56 + 8);
    if (v12)
    {
      v40 = *(_DWORD *)(v12 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v63 += v52 + 1;
        v17 = ~(_DWORD)v52 + v57;
        v25 = -1;
        goto LABEL_38;
      }
    }
    ++v52;
    ++v13;
    a3 += v67;
    v54 -= v67;
    a2 += v68;
    v55 -= v68;
    LODWORD(a8) = 1.0;
    v25 = -1;
  }
}

int *argb32_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  float32x2_t v11;
  float32x2_t v12;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int *result;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  int8x8_t *v40;
  int8x8_t *v41;
  float v42;
  int v43;
  float32x2_t v44;
  float v45;
  unsigned int v46;
  int v47;
  int v48;
  int8x8_t *v49;
  float32x2_t v50;
  float v51;
  float v52;
  float v53;
  unint64_t v54;
  float32x2_t v55;
  float v56;
  float32x2_t v57;
  int8x8_t *v58;
  float32x2_t v59;
  float v60;
  float v61;
  _DWORD *v62;
  int8x8_t *v63;
  uint64_t v64;
  int v65;
  unint64_t v66;
  uint64_t v67;
  int8x8_t *v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;

  v15 = *(_QWORD *)(a1 + 176);
  v71 = *(_QWORD *)(a1 + 80);
  v74 = *(int **)(a1 + 88);
  v81 = *(_QWORD *)(a1 + 112);
  v80 = *(_QWORD *)(a1 + 120);
  v70 = *(_DWORD *)(a1 + 188);
  v16 = (int *)(*(_QWORD *)(a1 + 152) - 4);
  v75 = *(_QWORD *)(a1 + 144) - 1;
  v79 = *(_QWORD *)(a1 + 40);
  v76 = *(_QWORD *)(a1 + 32);
  v77 = *(_DWORD *)(a1 + 24);
  v78 = v76 + ((*(_DWORD *)(a1 + 260) - 1) * v77) + 4 * (4 * *(_DWORD *)(a1 + 256)) - 16;
  v72 = *(_QWORD *)(a1 + 72);
  v73 = *(_QWORD *)(a1 + 64);
  while (1)
  {
    if (a3 >= v72)
    {
      result = v74;
      if (a3 <= (uint64_t)v74)
      {
        v28 = ((unint64_t)a3 >> 22) & 0x3C0;
        v29 = 0x3FFFFFFF;
        HIDWORD(v30) = HIDWORD(a3);
        v20 = a4;
        v22 = v73;
      }
      else
      {
        v24 = *(_QWORD *)(a1 + 216);
        v25 = (char *)v74 + *(_QWORD *)(a1 + 224);
        v26 = (uint64_t)&v25[(v24 >> 1) - a3];
        v20 = a4;
        v22 = v73;
        if (v26 < 1)
          goto LABEL_33;
        if (v26 >= v24)
          LODWORD(v27) = 0x3FFFFFFF;
        else
          v27 = (unint64_t)(*(_QWORD *)(a1 + 232) * v26) >> 32;
        v29 = v70 | v27;
        v30 = v25 - 0x1000000;
        v28 = 448;
      }
    }
    else
    {
      v17 = *(_QWORD *)(a1 + 216);
      v18 = v72 - *(_QWORD *)(a1 + 224);
      v19 = a3 - v18 + (v17 >> 1);
      v20 = a4;
      v22 = v73;
      result = v74;
      if (v19 < 1)
        goto LABEL_33;
      if (v19 >= v17)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(a1 + 232) * v19) >> 32;
      v29 = v70 | v23;
      v30 = (char *)(v18 + 0x1000000);
      v28 = 512;
    }
    if (a2 >= v22)
    {
      if (a2 <= v71)
      {
        v35 = ((unint64_t)a2 >> 26) & 0x3C;
        v34 = a2;
      }
      else
      {
        v36 = *(_QWORD *)(a1 + 192);
        v37 = *(_QWORD *)(a1 + 200) + v71;
        v38 = v37 - a2 + (v36 >> 1);
        if (v38 < 1)
          goto LABEL_33;
        if (v38 < v36)
          v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v38) >> 32) >> 15)) | v70;
        v34 = v37 - 0x1000000;
        v35 = 28;
      }
    }
    else
    {
      v31 = *(_QWORD *)(a1 + 192);
      v32 = v22 - *(_QWORD *)(a1 + 200);
      v33 = a2 - v32 + (v31 >> 1);
      if (v33 < 1)
        goto LABEL_33;
      if (v33 < v31)
        v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v33) >> 32) >> 15)) | v70;
      v34 = v32 + 0x1000000;
      v35 = 32;
    }
    if (v29 >= 0x400000)
      break;
LABEL_33:
    v43 = v20 - 1;
    a2 += v81;
    a3 += v80;
    ++v16;
    *(_BYTE *)++v75 = 0;
LABEL_34:
    a4 = v43;
    if (!v43)
      return result;
  }
  v39 = v76 + SHIDWORD(v30) * (uint64_t)v77 + 16 * (v34 >> 32);
  v40 = *(int8x8_t **)(a1 + 32);
  v41 = (int8x8_t *)v78;
  if (v78 >= v39)
    v41 = (int8x8_t *)v39;
  if (v41 < v40)
    v41 = *(int8x8_t **)(a1 + 32);
  if (v79)
    v42 = COERCE_FLOAT(bswap32(v41[1].u32[1]));
  else
    v42 = 1.0;
  v44 = (float32x2_t)vrev32_s8(*v41);
  v45 = COERCE_FLOAT(bswap32(v41[1].u32[0]));
  if (v15)
  {
    v46 = *(_DWORD *)(v15 + (v35 | v28));
LABEL_40:
    v47 = v46 & 0xF;
    v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      v58 = (int8x8_t *)(v39 + SBYTE1(v46) * (uint64_t)v77);
      if (v78 < (unint64_t)v58)
        v58 = (int8x8_t *)v78;
      if (v58 >= v40)
        v40 = v58;
      v59 = (float32x2_t)vrev32_s8(*v40);
      v60 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
      v61 = 1.0;
      if (v79)
        v61 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
      v62 = &interpolate_rgbaf_19467[4 * v48];
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          v49 = (int8x8_t *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 52));
          if (v78 < (unint64_t)v49)
            v49 = (int8x8_t *)v78;
          if (v49 < v40)
            v49 = v40;
          v50 = (float32x2_t)vrev32_s8(*v49);
          v51 = COERCE_FLOAT(bswap32(v49[1].u32[0]));
          v52 = 1.0;
          v53 = 1.0;
          if (v79)
            v53 = COERCE_FLOAT(bswap32(v49[1].u32[1]));
          v54 = v39 + SBYTE1(v46) * (uint64_t)v77 + 16 * SBYTE2(v46);
          if (v78 < v54)
            v54 = v78;
          if (v54 >= (unint64_t)v40)
            v40 = (int8x8_t *)v54;
          v55 = (float32x2_t)vrev32_s8(*v40);
          v56 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
          if (v79)
            v52 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
          v11.i32[0] = interpolate_rgbaf_19467[4 * v48 + 3];
          v12.i32[0] = interpolate_rgbaf_19467[4 * ((v46 >> 28) & 3) + 3];
          v45 = (float)((float)((float)(v45 - (float)(v45 * v11.f32[0])) + (float)(v51 * v11.f32[0]))
                      - (float)((float)((float)(v45 - (float)(v45 * v11.f32[0])) + (float)(v51 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v51 - (float)(v51 * v11.f32[0])) + (float)(v56 * v11.f32[0])) * v12.f32[0]);
          v57 = vmla_n_f32(vmls_lane_f32(v44, v44, v11, 0), v50, v11.f32[0]);
          v44 = vmla_n_f32(vmls_lane_f32(v57, v57, v12, 0), vmla_n_f32(vmls_lane_f32(v50, v50, v11, 0), v55, v11.f32[0]), v12.f32[0]);
          v42 = (float)((float)((float)(v42 - (float)(v42 * v11.f32[0])) + (float)(v53 * v11.f32[0]))
                      - (float)((float)((float)(v42 - (float)(v42 * v11.f32[0])) + (float)(v53 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v53 - (float)(v53 * v11.f32[0])) + (float)(v52 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_71;
      }
      v63 = (int8x8_t *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 52));
      if (v78 < (unint64_t)v63)
        v63 = (int8x8_t *)v78;
      if (v63 >= v40)
        v40 = v63;
      v59 = (float32x2_t)vrev32_s8(*v40);
      v60 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
      v61 = 1.0;
      if (v79)
        v61 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
      v62 = &interpolate_rgbaf_19467[4 * ((v46 >> 28) & 3)];
    }
    LODWORD(a11) = v62[3];
    v44 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
    v45 = (float)(v45 - (float)(v45 * *(float *)&a11)) + (float)(v60 * *(float *)&a11);
    v42 = (float)(v42 - (float)(v42 * *(float *)&a11)) + (float)(v61 * *(float *)&a11);
  }
LABEL_71:
  v64 = 0;
  ++v16;
  v69 = v20;
  v65 = v20 - 1;
  a3 += v80;
  v66 = (unint64_t)result - a3;
  a2 += v81;
  v67 = v71 - a2;
  while (1)
  {
    result = RGBAF(v16, v44.f32[0], v44.f32[1], v45, v42);
    *(_BYTE *)(v75 + 1 + v64) = v29 >> 22;
    if (v65 == (_DWORD)v64)
      return result;
    if (((v66 | v67 | (a3 - v72) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v75 += v64 + 1;
      v43 = ~(_DWORD)v64 + v69;
      goto LABEL_34;
    }
    v39 = v76 + SHIDWORD(a3) * (uint64_t)v77 + 16 * (a2 >> 32);
    v40 = *(int8x8_t **)(a1 + 32);
    v68 = (int8x8_t *)v78;
    if (v78 >= v39)
      v68 = (int8x8_t *)(v76 + SHIDWORD(a3) * (uint64_t)v77 + 16 * (a2 >> 32));
    if (v68 < v40)
      v68 = *(int8x8_t **)(a1 + 32);
    if (v79)
      v42 = COERCE_FLOAT(bswap32(v68[1].u32[1]));
    else
      v42 = 1.0;
    v44 = (float32x2_t)vrev32_s8(*v68);
    v45 = COERCE_FLOAT(bswap32(v68[1].u32[0]));
    if (v15)
    {
      v46 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        result = v74;
        v75 += v64 + 1;
        v20 = ~(_DWORD)v64 + v69;
        v29 = -1;
        goto LABEL_40;
      }
    }
    ++v16;
    ++v64;
    a3 += v80;
    v66 -= v80;
    a2 += v81;
    v67 -= v81;
    v29 = -1;
  }
}

int *argb32_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  float32x2_t v11;
  float32x2_t v12;
  uint64_t v15;
  int *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int *result;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  float32x2_t *v41;
  float32x2_t *v42;
  float v43;
  int v44;
  float32x2_t v45;
  float v46;
  unsigned int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  float32x2_t *v52;
  float32x2_t v53;
  float v54;
  float32x2_t *v55;
  float v56;
  float32x2_t *v57;
  float32x2_t v58;
  float v59;
  float v60;
  _DWORD *v61;
  float32x2_t *v62;
  float32x2_t *v63;
  float32x2_t v64;
  uint64_t v65;
  int v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;

  v15 = *(_QWORD *)(a1 + 176);
  v72 = *(_QWORD *)(a1 + 80);
  v75 = *(int **)(a1 + 88);
  v82 = *(_QWORD *)(a1 + 112);
  v81 = *(_QWORD *)(a1 + 120);
  v71 = *(_DWORD *)(a1 + 188);
  v16 = (int *)(*(_QWORD *)(a1 + 152) - 4);
  v76 = *(_QWORD *)(a1 + 144) - 1;
  v79 = *(_DWORD *)(a1 + 24);
  v80 = *(_QWORD *)(a1 + 40);
  v77 = *(_QWORD *)(a1 + 32);
  v17 = v77 + ((*(_DWORD *)(a1 + 260) - 1) * v79) + 4 * (4 * *(_DWORD *)(a1 + 256)) - 16;
  v73 = *(_QWORD *)(a1 + 64);
  v74 = *(_QWORD *)(a1 + 72);
  v78 = v17;
  while (1)
  {
    if (a3 >= v74)
    {
      result = v75;
      if (a3 <= (uint64_t)v75)
      {
        v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        v30 = 0x3FFFFFFF;
        HIDWORD(v31) = HIDWORD(a3);
        v21 = a4;
        v22 = v73;
      }
      else
      {
        v25 = *(_QWORD *)(a1 + 216);
        v26 = (char *)v75 + *(_QWORD *)(a1 + 224);
        v27 = (uint64_t)&v26[(v25 >> 1) - a3];
        v21 = a4;
        v22 = v73;
        if (v27 < 1)
          goto LABEL_34;
        if (v27 >= v25)
          LODWORD(v28) = 0x3FFFFFFF;
        else
          v28 = (unint64_t)(*(_QWORD *)(a1 + 232) * v27) >> 32;
        v30 = v71 | v28;
        v31 = v26 - 0x1000000;
        v29 = 448;
      }
    }
    else
    {
      v18 = *(_QWORD *)(a1 + 216);
      v19 = v74 - *(_QWORD *)(a1 + 224);
      v20 = a3 - v19 + (v18 >> 1);
      v21 = a4;
      v22 = v73;
      result = v75;
      if (v20 < 1)
        goto LABEL_34;
      if (v20 >= v18)
        LODWORD(v24) = 0x3FFFFFFF;
      else
        v24 = (unint64_t)(*(_QWORD *)(a1 + 232) * v20) >> 32;
      v30 = v71 | v24;
      v31 = (char *)(v19 + 0x1000000);
      v29 = 512;
    }
    if (a2 >= v22)
    {
      if (a2 <= v72)
      {
        v36 = ((unint64_t)a2 >> 26) & 0x3C;
        v35 = a2;
      }
      else
      {
        v37 = *(_QWORD *)(a1 + 192);
        v38 = *(_QWORD *)(a1 + 200) + v72;
        v39 = v38 - a2 + (v37 >> 1);
        if (v39 < 1)
          goto LABEL_34;
        if (v39 < v37)
          v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v39) >> 32) >> 15)) | v71;
        v35 = v38 - 0x1000000;
        v36 = 28;
      }
    }
    else
    {
      v32 = *(_QWORD *)(a1 + 192);
      v33 = v22 - *(_QWORD *)(a1 + 200);
      v34 = a2 - v33 + (v32 >> 1);
      if (v34 < 1)
        goto LABEL_34;
      if (v34 < v32)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(a1 + 208) * v34) >> 32) >> 15)) | v71;
      v35 = v33 + 0x1000000;
      v36 = 32;
    }
    if (v30 >= 0x400000)
      break;
LABEL_34:
    v44 = v21 - 1;
    a2 += v82;
    a3 += v81;
    ++v16;
    *(_BYTE *)++v76 = 0;
LABEL_35:
    a4 = v44;
    if (!v44)
      return result;
  }
  v40 = v77 + SHIDWORD(v31) * (uint64_t)v79 + 16 * (v35 >> 32);
  v41 = *(float32x2_t **)(a1 + 32);
  if (v17 >= v40)
    v42 = (float32x2_t *)v40;
  else
    v42 = (float32x2_t *)v17;
  if (v42 < v41)
    v42 = *(float32x2_t **)(a1 + 32);
  if (v80)
    v43 = v42[1].f32[1];
  else
    v43 = 1.0;
  v45 = *v42;
  v46 = v42[1].f32[0];
  if (v15)
  {
    v47 = *(_DWORD *)(v15 + (v36 | v29));
LABEL_41:
    v48 = v47 & 0xF;
    v49 = HIBYTE(v47) & 3;
    if (v48 == 1)
    {
      v57 = (float32x2_t *)(v40 + SBYTE1(v47) * (uint64_t)v79);
      if (v17 < (unint64_t)v57)
        v57 = (float32x2_t *)v17;
      if (v57 >= v41)
        v41 = v57;
      v58 = *v41;
      v59 = v41[1].f32[0];
      v60 = 1.0;
      if (v80)
        v60 = v41[1].f32[1];
      v61 = &interpolate_rgbaf_19467[4 * v49];
    }
    else
    {
      if (v48 != 2)
      {
        if (v48 == 3)
        {
          v50 = SBYTE1(v47) * (uint64_t)v79;
          v51 = 16 * SBYTE2(v47);
          v52 = (float32x2_t *)(v40 + v51);
          if (v17 < v40 + v51)
            v52 = (float32x2_t *)v17;
          if (v52 < v41)
            v52 = v41;
          v53 = *v52;
          if (v80)
          {
            v54 = v52[1].f32[1];
            v55 = (float32x2_t *)(v40 + v50 + v51);
            if (v17 < (unint64_t)v55)
              v55 = (float32x2_t *)v17;
            if (v55 >= v41)
              v41 = v55;
            v56 = v41[1].f32[1];
          }
          else
          {
            v63 = (float32x2_t *)(v40 + v50 + v51);
            if (v17 < (unint64_t)v63)
              v63 = (float32x2_t *)v17;
            if (v63 >= v41)
              v41 = v63;
            v54 = 1.0;
            v56 = 1.0;
          }
          v11.i32[0] = interpolate_rgbaf_19467[4 * v49 + 3];
          v12.i32[0] = interpolate_rgbaf_19467[4 * ((v47 >> 28) & 3) + 3];
          v46 = (float)((float)((float)(v46 - (float)(v46 * v11.f32[0])) + (float)(v52[1].f32[0] * v11.f32[0]))
                      - (float)((float)((float)(v46 - (float)(v46 * v11.f32[0])) + (float)(v52[1].f32[0] * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v52[1].f32[0] - (float)(v52[1].f32[0] * v11.f32[0]))
                              + (float)(v41[1].f32[0] * v11.f32[0]))
                      * v12.f32[0]);
          v64 = vmla_n_f32(vmls_lane_f32(v45, v45, v11, 0), v53, v11.f32[0]);
          v45 = vmla_n_f32(vmls_lane_f32(v64, v64, v12, 0), vmla_n_f32(vmls_lane_f32(v53, v53, v11, 0), *v41, v11.f32[0]), v12.f32[0]);
          v43 = (float)((float)((float)(v43 - (float)(v43 * v11.f32[0])) + (float)(v54 * v11.f32[0]))
                      - (float)((float)((float)(v43 - (float)(v43 * v11.f32[0])) + (float)(v54 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v54 - (float)(v54 * v11.f32[0])) + (float)(v56 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_75;
      }
      v62 = (float32x2_t *)(v40 + ((uint64_t)((unint64_t)HIWORD(v47) << 56) >> 52));
      if (v17 < (unint64_t)v62)
        v62 = (float32x2_t *)v17;
      if (v62 >= v41)
        v41 = v62;
      v58 = *v41;
      v59 = v41[1].f32[0];
      v60 = 1.0;
      if (v80)
        v60 = v41[1].f32[1];
      v61 = &interpolate_rgbaf_19467[4 * ((v47 >> 28) & 3)];
    }
    LODWORD(a11) = v61[3];
    v45 = vmla_n_f32(vmls_lane_f32(v45, v45, *(float32x2_t *)&a11, 0), v58, *(float *)&a11);
    v46 = (float)(v46 - (float)(v46 * *(float *)&a11)) + (float)(v59 * *(float *)&a11);
    v43 = (float)(v43 - (float)(v43 * *(float *)&a11)) + (float)(v60 * *(float *)&a11);
  }
LABEL_75:
  v65 = 0;
  ++v16;
  v70 = v21;
  v66 = v21 - 1;
  a3 += v81;
  v67 = (unint64_t)result - a3;
  a2 += v82;
  v68 = v72 - a2;
  while (1)
  {
    result = RGBAF(v16, v45.f32[0], v45.f32[1], v46, v43);
    *(_BYTE *)(v76 + 1 + v65) = v30 >> 22;
    v17 = v78;
    if (v66 == (_DWORD)v65)
      return result;
    if (((v67 | v68 | (a3 - v74) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v76 += v65 + 1;
      v44 = ~(_DWORD)v65 + v70;
      goto LABEL_35;
    }
    v40 = v77 + SHIDWORD(a3) * (uint64_t)v79 + 16 * (a2 >> 32);
    v41 = *(float32x2_t **)(a1 + 32);
    if (v78 >= v40)
      v69 = v77 + SHIDWORD(a3) * (uint64_t)v79 + 16 * (a2 >> 32);
    else
      v69 = v78;
    if (v69 < (unint64_t)v41)
      v69 = *(_QWORD *)(a1 + 32);
    if (v80)
      v43 = *(float *)(v69 + 12);
    else
      v43 = 1.0;
    v45 = *(float32x2_t *)v69;
    v46 = *(float *)(v69 + 8);
    if (v15)
    {
      v47 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        result = v75;
        v76 += v65 + 1;
        v21 = ~(_DWORD)v65 + v70;
        v30 = -1;
        goto LABEL_41;
      }
    }
    ++v16;
    ++v65;
    a3 += v81;
    v67 -= v81;
    a2 += v82;
    v68 -= v82;
    v30 = -1;
  }
}

int *RGBAF(int *result, float a2, float a3, float a4, float a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (a5 <= 0.0)
  {
    v9 = 0;
  }
  else
  {
    v5 = (int)(float)((float)(a5 * 255.0) + 0.5);
    if (a5 > 1.0)
    {
      v5 = 255;
      a5 = 1.0;
    }
    v6 = (int)(float)((float)(a2 * 255.0) + 0.5);
    if (a2 < 0.0)
      v6 = 0;
    if (a2 > a5)
      v6 = v5;
    v7 = (int)(float)((float)(a3 * 255.0) + 0.5);
    if (a3 < 0.0)
      v7 = 0;
    if (a3 > a5)
      v7 = v5;
    v8 = (int)(float)((float)(a4 * 255.0) + 0.5);
    if (a4 < 0.0)
      v8 = 0;
    if (a4 > a5)
      v8 = v5;
    v9 = (v6 << 16) | (v5 << 24) | (v7 << 8) | v8;
  }
  *result = v9;
  return result;
}

int *CMYK32_13340(int *result, uint64_t a2)
{
  int v2;
  int v3;

  v2 = BYTE4(a2) - (BYTE3(a2) + a2);
  v3 = BYTE4(a2) - (BYTE2(a2) + a2);
  *result = (HIDWORD(a2) << 24) | ((v2 & ~(v2 >> 31)) << 16) | ((v3 & ~(v3 >> 31)) << 8) | (BYTE4(a2) - (BYTE1(a2) + a2)) & ~((BYTE4(a2) - (BYTE1(a2) + a2)) >> 31);
  return result;
}

void argb32_shade_radial_RGB(uint64_t a1, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v20;
  float v21;
  float v22;
  float v23;
  float v24;
  int v25;
  float v26;
  float v27;
  float v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int16 *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  float v43;
  float v44;
  int v45;
  int v46;
  float v47;
  float v48;
  float v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  BOOL v63;
  float v64;
  BOOL v65;
  int v66;
  float v67;
  _WORD *v68;
  __int16 v69;
  __int16 v70;
  __int16 v71;
  __int16 v72;
  __int16 v73;
  __int16 v74;
  __int16 v75;
  __int16 v76;
  __int16 v77;
  char v78;
  float v79;
  float v80;
  float v81;
  unsigned __int16 *v82;
  int v83;
  float v84;
  float v85;
  float v86;
  float v88;
  float v89;
  float v90;
  int v91;
  int v92;
  uint64_t v94;
  int v95;
  unsigned __int16 v96;
  unsigned __int16 v97;
  int v98;
  unsigned __int16 *v99;
  __int16 *v100;
  __int16 v101;
  __int16 v102;
  __int16 v103;
  __int16 v104;
  unsigned int v105;
  __int16 v106;
  __int16 v107;
  __int16 v108;
  __int16 v109;
  __int16 v110;
  __int16 v111;
  __int16 v112;
  int v113;
  unsigned int v114;
  __int16 v115;
  __int16 v116;
  unsigned int v117;
  __int16 v118;
  char v119;
  char v120;
  _WORD *v121;
  __int16 v122;
  __int16 v123;
  __int16 v124;
  __int16 v125;
  __int16 v126;
  __int16 v127;
  __int16 v128;
  __int16 v129;
  __int16 v130;
  uint64_t v131;
  _WORD *v132;
  __int16 v133;
  __int16 v134;
  __int16 v135;
  __int16 v136;
  __int16 v137;
  unsigned __int16 *v138;
  unsigned __int16 *v139;
  int32x2_t v140;
  int32x2_t v141;
  int32x2_t v142;
  int32x2_t v143;
  int v144;
  _BYTE *v145;
  int32x2_t v146;
  int8x8_t v147;
  int32x2_t v148;

  v12 = *(float *)(a1 + 280);
  v13 = *(float *)(a1 + 284);
  v14 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v15 = v14 * (float)a2;
  v16 = v14 * (float)(uint64_t)a3;
  v17 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v16) + (float)(v12 * v15));
  v18 = *(float *)(a1 + 300) + (float)((float)(v16 * *(float *)(a1 + 292)) + (float)(v13 * v15));
  v20 = *(_QWORD *)(a1 + 400);
  v21 = *(float *)(a1 + 336);
  v22 = *(float *)(a1 + 344);
  v23 = *(float *)(a1 + 304);
  v24 = *(float *)(a1 + 308);
  v25 = *(_DWORD *)(a1 + 324);
  LODWORD(a12) = *(_DWORD *)(v20 + 8);
  v26 = *(float *)(v20 + 16);
  v27 = *(float *)(v20 + 20);
  v28 = *(float *)(v20 + 28);
  v31 = a1 + 144;
  v29 = *(char **)(a1 + 144);
  v30 = *(_QWORD *)(v31 + 8);
  v32 = *(unsigned __int16 **)(a1 + 376);
  v33 = *(_QWORD *)(a1 + 360);
  v34 = ((unint64_t)a2 >> 8) & 0xF;
  if (*(float *)&a12 != 0.0 || v28 != 0.0 || v13 != 0.0)
  {
    v46 = *(_DWORD *)(a1 + 320);
    v47 = *(float *)(v20 + 12);
    v48 = *(float *)(v20 + 24);
    v49 = *(float *)(v20 + 32);
    v50 = a1 + 368;
    v51 = *(_QWORD *)(a1 + 368);
    v52 = v51 + ((a3 >> 4) & 0xF0);
    v38 = v51 == 0;
    v53 = 15;
    if (v38)
    {
      v53 = 0;
      v34 = 0;
    }
    else
    {
      v50 = v52;
    }
    v54 = -v48;
    v55 = v24 - v23;
    while (1)
    {
      v56 = v54 + (float)((float)(v17 + v17) * *(float *)&a12);
      v57 = (float)((float)(v18 * v18) + (float)(v17 * v17)) - v28;
      if (v27 == 0.0)
      {
        v64 = v57 / v56;
      }
      else
      {
        v58 = (float)((float)(v27 * -4.0) * v57) + (float)(v56 * v56);
        if (v58 < 0.0)
          goto LABEL_54;
        v59 = sqrtf(v58);
        v60 = v49 * (float)(v56 - v59);
        v61 = v56 + v59;
        v62 = v49 * v61;
        v63 = (float)(v49 * v61) <= v60;
        if ((float)(v49 * v61) <= v60)
          v64 = v49 * v61;
        else
          v64 = v60;
        if (v63)
          v62 = v60;
        if (v62 < 0.0)
        {
          v65 = v62 < v47;
LABEL_40:
          v66 = v46;
          if (v65)
            goto LABEL_54;
LABEL_41:
          if ((v66 & 0x80000000) == 0)
            goto LABEL_53;
          goto LABEL_54;
        }
        if (v62 <= 1.0)
        {
          v67 = v23 + (float)(v62 * v55);
          goto LABEL_52;
        }
        if ((v25 & 0x80000000) == 0)
        {
          v66 = v25;
          if (v62 <= v26)
          {
LABEL_53:
            v68 = (_WORD *)(v33 + 8 * v66);
            v69 = v68[1];
            v70 = *(unsigned __int8 *)(v50 + v34);
            v71 = v68[2];
            v72 = v68[3];
            v73 = v70 + *v68;
            v74 = v70 + v69;
            v75 = v70 + v71;
            v76 = v70 + v72;
            goto LABEL_56;
          }
        }
      }
      if (v64 < 0.0)
      {
        v65 = v64 < v47;
        goto LABEL_40;
      }
      if (v64 > 1.0)
      {
        v66 = v25;
        if (v64 > v26)
          goto LABEL_54;
        goto LABEL_41;
      }
      v67 = v23 + (float)(v64 * v55);
LABEL_52:
      v66 = (int)(float)(v22 * (float)(v67 - v21));
      if ((v66 & 0x80000000) == 0)
        goto LABEL_53;
LABEL_54:
      if (!v32)
      {
        v78 = 0;
        goto LABEL_58;
      }
      v77 = *(unsigned __int8 *)(v50 + v34);
      v73 = v77 + *v32;
      v74 = v77 + v32[1];
      v75 = v77 + v32[2];
      v76 = v77 + v32[3];
LABEL_56:
      *(_DWORD *)v30 = v74 & 0xFF00 | (HIBYTE(v73) << 16) & 0xFFFFFF | HIBYTE(v75) | (HIBYTE(v76) << 24);
      v78 = -1;
LABEL_58:
      v34 = ((_DWORD)v34 + 1) & v53;
      v17 = v12 + v17;
      v18 = v13 + v18;
      v30 += 4;
      *v29++ = v78;
      if (!--a4)
        return;
    }
  }
  v35 = a1 + 368;
  v36 = *(_QWORD *)(a1 + 368);
  v37 = (BYTE1(a2) + 1) & 0xF;
  v38 = v36 == 0;
  if (v36)
    v39 = v36 + ((a3 >> 4) & 0xF0);
  else
    v39 = v35;
  if (v38)
    LODWORD(v40) = 0;
  else
    LODWORD(v40) = v37;
  if (v38)
    LODWORD(v41) = 0;
  else
    LODWORD(v41) = v34;
  if (v38)
    v42 = 0;
  else
    v42 = 15;
  v43 = v18 * v18;
  v44 = -v27;
  if (v43 <= (float)-v27)
  {
    v79 = fabsf(*(float *)(v20 + 32));
    v80 = v27 * -4.0;
    v81 = v24 - v23;
    v82 = (unsigned __int16 *)(v33 + 8 * v25);
    v83 = a4 + 2;
    while (1)
    {
      v84 = v43 + (float)(v17 * v17);
      v85 = v12 + v17;
      v86 = v43 + (float)(v85 * v85);
      if (v84 > v44 && v86 > v44)
      {
        if (v25 < 0)
        {
          if (!v32)
          {
            v120 = 0;
            v119 = 0;
            goto LABEL_82;
          }
          v95 = *v32;
          v96 = v32[1];
          v97 = v32[2];
          v98 = v32[3];
        }
        else
        {
          v95 = *v82;
          v96 = v82[1];
          v97 = v82[2];
          v98 = v82[3];
        }
        v113 = *(unsigned __int8 *)(v39 + v41);
        v114 = (v113 + v95) >> 8;
        v115 = v113 + v96;
        v116 = v113 + v97;
        v117 = (v113 + v98) >> 8;
        v118 = *(unsigned __int8 *)(v39 + v40);
        v109 = v118 + v95;
        v110 = v118 + v96;
        v111 = v118 + v97;
        v112 = v118 + v98;
        *(_DWORD *)v30 = v115 & 0xFF00 | (v114 << 16) & 0xFFFFFF | HIBYTE(v116) | (v117 << 24);
        goto LABEL_80;
      }
      v88 = sqrtf(v80 * v86);
      v89 = v79 * sqrtf(v80 * v84);
      v90 = v79 * v88;
      v91 = (int)(float)(v22 * (float)((float)(v23 + (float)(v89 * v81)) - v21));
      v92 = (int)(float)(v22 * (float)((float)(v23 + (float)((float)(v79 * v88) * v81)) - v21));
      if (v89 <= 1.0 && v90 <= 1.0)
      {
        v99 = (unsigned __int16 *)(v33 + 8 * v91);
        v100 = (__int16 *)(v33 + 8 * v92);
        v101 = *v100;
        v102 = v100[1];
        v103 = v100[2];
        v104 = v100[3];
        LODWORD(v100) = *(unsigned __int8 *)(v39 + v41);
        v105 = (v100 + *v99) >> 8;
        v106 = (_WORD)v100 + v99[1];
        v107 = (_WORD)v100 + v99[2];
        LODWORD(v99) = (v100 + v99[3]) >> 8;
        v108 = *(unsigned __int8 *)(v39 + v40);
        v109 = v108 + v101;
        v110 = v108 + v102;
        v111 = v108 + v103;
        v112 = v108 + v104;
        *(_DWORD *)v30 = v106 & 0xFF00 | (v105 << 16) & 0xFFFFFF | HIBYTE(v107) | (v99 << 24);
LABEL_80:
        v119 = -1;
        goto LABEL_81;
      }
      if (v89 <= 1.0)
      {
        if ((v91 & 0x80000000) == 0)
        {
          v94 = 4 * v91;
LABEL_86:
          v121 = (_WORD *)(v33 + 2 * v94);
          v122 = v121[1];
          v123 = *(unsigned __int8 *)(v39 + v41);
          v124 = v121[2];
          v125 = v121[3];
          v126 = v123 + *v121;
          v127 = v123 + v122;
          v128 = v123 + v124;
          v129 = v123 + v125;
          goto LABEL_89;
        }
      }
      else if (v89 <= v26)
      {
        v94 = 4 * v25;
        if ((v25 & 0x80000000) == 0)
          goto LABEL_86;
      }
      if (!v32)
      {
        v119 = 0;
        goto LABEL_90;
      }
      v130 = *(unsigned __int8 *)(v39 + v41);
      v126 = v130 + *v32;
      v127 = v130 + v32[1];
      v128 = v130 + v32[2];
      v129 = v130 + v32[3];
LABEL_89:
      *(_DWORD *)v30 = v127 & 0xFF00 | (HIBYTE(v126) << 16) & 0xFFFFFF | HIBYTE(v128) | (HIBYTE(v129) << 24);
      v119 = -1;
LABEL_90:
      if (v90 <= 1.0)
      {
        if (v92 < 0)
          goto LABEL_97;
        v131 = 4 * v92;
      }
      else if (v90 > v26 || (v131 = 4 * v25, v25 < 0))
      {
LABEL_97:
        if (!v32)
        {
          v120 = 0;
          goto LABEL_82;
        }
        v137 = *(unsigned __int8 *)(v39 + v40);
        v109 = v137 + *v32;
        v110 = v137 + v32[1];
        v111 = v137 + v32[2];
        v112 = v137 + v32[3];
        goto LABEL_81;
      }
      v132 = (_WORD *)(v33 + 2 * v131);
      v133 = v132[1];
      v134 = *(unsigned __int8 *)(v39 + v40);
      v135 = v132[2];
      v136 = v132[3];
      v109 = v134 + *v132;
      v110 = v134 + v133;
      v111 = v134 + v135;
      v112 = v134 + v136;
LABEL_81:
      *(_DWORD *)(v30 + 4) = v110 & 0xFF00 | (HIBYTE(v109) << 16) & 0xFFFFFF | HIBYTE(v111) | (HIBYTE(v112) << 24);
      v120 = -1;
LABEL_82:
      v17 = v12 + v85;
      LOBYTE(v41) = (v41 + 1) & v42;
      LOBYTE(v40) = (v40 + 1) & v42;
      v30 += 8;
      *v29 = v119;
      v29[1] = v120;
      v29 += 2;
      v83 -= 2;
      if (v83 <= 2)
        return;
    }
  }
  if (v32 || (v25 & 0x80000000) == 0)
  {
    v138 = (unsigned __int16 *)(v33 + 8 * v25);
    if (v25 >= 0)
      v139 = v138;
    else
      v139 = v32;
    v140 = vdup_n_s32(*v139);
    v141 = vdup_n_s32(v139[1]);
    v142 = vdup_n_s32(v139[2]);
    v143 = vdup_n_s32(v139[3]);
    v144 = a4 + 4;
    do
    {
      v145 = (_BYTE *)(v39 + v41);
      v41 = ((_DWORD)v41 + 1) & v42;
      LOBYTE(a12) = *v145;
      BYTE4(a12) = *(_BYTE *)(v39 + v40);
      v146 = (int32x2_t)vand_s8(*(int8x8_t *)&a12, (int8x8_t)0xFF000000FFLL);
      v147 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v140, v146), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v141, v146), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vadd_s32(v142, v146), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), (int8x8_t)(*(_QWORD *)&vshl_n_s32(vadd_s32(v143, v146), 0x10uLL) & 0xFF00FFFFFF00FFFFLL)));
      *(int8x8_t *)v30 = v147;
      v40 = ((_DWORD)v40 + 1) & v42;
      v147.i8[0] = *(_BYTE *)(v39 + v41);
      v147.i8[4] = *(_BYTE *)(v39 + v40);
      v148 = (int32x2_t)vand_s8(v147, (int8x8_t)0xFF000000FFLL);
      a12 = COERCE_DOUBLE(vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v140, v148), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v141, v148), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vadd_s32(v142, v148), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), (int8x8_t)(*(_QWORD *)&vshl_n_s32(vadd_s32(v143, v148), 0x10uLL) & 0xFF00FFFFFF00FFFFLL))));
      *(double *)(v30 + 8) = a12;
      *(_DWORD *)v29 = -1;
      v29 += 4;
      v144 -= 4;
      v30 += 16;
    }
    while (v144 > 4);
  }
  else
  {
    if (a4 >= 4)
      v45 = 4;
    else
      v45 = a4;
    bzero(v29, ((a4 - v45 + 3) & 0xFFFFFFFC) + 4);
  }
}

void argb32_shade_conic_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v15;
  uint64_t v16;
  unsigned int *v17;
  _BYTE *v18;
  uint64_t v19;
  float v20;
  float v21;
  unsigned int v22;
  float v23;
  float v24;
  unsigned int v25;
  float v26;
  float v27;
  unsigned __int16 *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned __int16 *v33;
  int v34;
  int v35;
  int v36;
  float v37;
  float v38;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  v9 = *(_QWORD *)(a1 + 368);
  if (v9)
    v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  else
    v10 = a1 + 368;
  if (v9)
    v11 = 15;
  else
    v11 = 0;
  v12 = *(float *)(a1 + 284);
  v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  v37 = *(float *)(a1 + 336);
  v38 = *(float *)(a1 + 304);
  v15 = *(float *)(a1 + 344);
  v16 = *(_QWORD *)(a1 + 360);
  v18 = *(_BYTE **)(a1 + 144);
  v17 = *(unsigned int **)(a1 + 152);
  if (v9)
    v19 = ((unint64_t)a2 >> 8) & 0xF;
  else
    v19 = 0;
  v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    v21 = v15 * (float)((float)(v38 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v37);
    v22 = vcvtms_s32_f32(v21);
    v23 = ceilf(v21);
    v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0)
      v22 = v25;
    v26 = ceilf(v21 - v15);
    if (v21 <= v15)
      v27 = v23;
    else
      v27 = v26;
    v28 = (unsigned __int16 *)(v16 + 2 * (int)(4 * v22));
    v29 = *v28;
    v30 = 255 - (int)v24;
    v31 = v28[1];
    v32 = v28[2];
    v33 = (unsigned __int16 *)(v16 + 8 * (int)v27);
    v34 = v33[2];
    v35 = (int)v24 * *v33;
    LODWORD(v28) = (int)v24 * v33[3] + v30 * v28[3];
    LODWORD(v33) = (int)v24 * v33[1] + v30 * v31;
    v36 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = (v35 + (v36 << 8) + v30 * v29) & 0xFF0000 | (v36 + (v33 >> 8)) & 0xFF00 | ((unsigned __int16)(v36 + (((int)v24 * v34 + v30 * v32) >> 8)) >> 8) | (((unsigned __int16)(v36 + (v28 >> 8)) >> 8) << 24);
    v19 = ((_DWORD)v19 + 1) & v11;
    v8 = v4 + v8;
    v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
}

uint64_t argb32_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  _WORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int *v26;
  char *v27;
  int v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  _WORD *v35;
  __int16 v36;
  int v37;
  int v38;
  __int16 v39;
  char v40;

  v4 = *(float *)(result + 280);
  v5 = *(float *)(*(_QWORD *)(result + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  v9 = result + 368;
  v10 = *(_QWORD *)(result + 368);
  v11 = 15;
  if (v10)
    v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  else
    v11 = 0;
  v12 = *(float *)(result + 284);
  v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  v14 = *(float *)(result + 304);
  v15 = *(float *)(result + 308);
  v16 = *(float *)(result + 312);
  v17 = *(float *)(result + 316);
  v18 = *(float *)(result + 336);
  v19 = *(float *)(result + 348);
  v20 = *(float *)(result + 344);
  v21 = *(float *)(result + 356);
  v22 = *(_WORD **)(result + 376);
  v23 = *(_QWORD *)(result + 360);
  v24 = 4 * *(_DWORD *)(result + 48);
  if (v10)
    v25 = ((unint64_t)a2 >> 8) & 0xF;
  else
    v25 = 0;
  v27 = *(char **)(result + 144);
  v26 = *(int **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      v35 = (_WORD *)(v23
                    + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                    + 8 * (int)(float)(v20 * (float)(v8 - v18)));
      v36 = v35[1];
      v37 = *(unsigned __int8 *)(v9 + v25);
      v38 = (unsigned __int16)v35[2];
      v39 = v35[3];
      v32 = v37 + *v35;
      v33 = v37 + v36;
      result = (v37 + v38);
      v34 = v37 + v39;
      goto LABEL_21;
    }
    if (v22)
    {
      v31 = *(unsigned __int8 *)(v9 + v25);
      v32 = v31 + *v22;
      v33 = v31 + v22[1];
      result = v31 + (unsigned __int16)v22[2];
      v34 = v31 + v22[3];
LABEL_21:
      *v26 = v33 & 0xFF00 | (HIBYTE(v32) << 16) & 0xFFFFFF | BYTE1(result) | (HIBYTE(v34) << 24);
      v40 = -1;
      goto LABEL_22;
    }
    v40 = 0;
LABEL_22:
    v25 = ((_DWORD)v25 + 1) & v11;
    v8 = v4 + v8;
    v13 = v12 + v13;
    ++v26;
    *v27++ = v40;
    --a4;
  }
  while (a4);
  return result;
}

unint64_t PDM_13345(unsigned int a1, int a2)
{
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;

  v2 = ((a1 >> 8) & 0xFF00FF) * (a2 ^ 0xFF) + 8388736;
  v3 = ((((((a1 & 0xFF00FF) * (a2 ^ 0xFF) + 8388736) >> 8) & 0xFF00FF) + (a1 & 0xFF00FF) * (a2 ^ 0xFF) + 8388736) >> 8) & 0xFF00FF | (((v2 >> 8) & 0xFF00FF) + v2) & 0xFF00FF00;
  v4 = (((a1 | ((unint64_t)a1 << 40)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
     - (((v3 | (unint64_t)(v3 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  return (((v4 & 0x100010001000100) - ((v4 & 0x100010001000100) >> 8)) & v4 | ((((v4 & 0x100010001000100)
                                                                                   - ((v4 & 0x100010001000100) >> 8)) & v4) << 40)) >> 32;
}

unsigned int *DMplusDM_13346(unsigned int *result, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;

  v5 = (unsigned __int16)(BYTE1(a4) * (_WORD)a5) + (unsigned __int16)(BYTE1(a2) * (_WORD)a3);
  v6 = ((((a4 >> 8) & 0xFF00FF) * a5) >> 16) + ((((a2 >> 8) & 0xFF00FF) * a3) >> 16);
  if (v5 >= 0xFE79)
    v5 = 65145;
  if (v6 >= 0xFE79)
    v6 = 65145;
  v7 = (a2 & 0xFF00FF) * a3;
  v8 = (unsigned __int16)(a4 * (_WORD)a5) + (unsigned __int16)v7;
  v9 = (((a4 & 0xFF00FF) * a5) >> 16) + HIWORD(v7);
  if (v8 >= 0xFE79)
    v10 = 65145;
  else
    v10 = v8;
  if (v9 >= 0xFE79)
    v11 = 65145;
  else
    v11 = v9;
  *result = ((((((v10 | (v11 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v10 | (v11 << 16)) + 8388736) >> 8) & 0xFF00FF | (((((v5 | (v6 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v5 | (v6 << 16)) + 8388736) & 0xFF00FF00;
  return result;
}

_DWORD *DplusDM_13347(_DWORD *result, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v4;
  unint64_t v5;

  v4 = ((((((a3 & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF) + (a3 & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF | ((((((a3 >> 8) & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF) + ((a3 >> 8) & 0xFF00FF) * a4 + 8388736) & 0xFF00FF00;
  v5 = (((v4 | (unint64_t)(v4 << 40)) >> 8) & 0xFF00FF00FF00FFLL)
     + (((a2 | ((unint64_t)a2 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  *result = ((((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) | v5) & 0xFF00FF00FF00FFLL | (((((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) | v5) & 0xFF00FF00FF00FFLL) << 40)) >> 32;
  return result;
}

_DWORD *DAplusdDA_13348(_DWORD *result, int a2, int a3, int a4, int a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;

  v5 = ((((65793 * a3) | ((unint64_t)(65793 * a3) << 40)) >> 8) & 0xFEFF00FFFEFF00FFLL | 0x100010001000100)
     - (((a2 & 0xFFFFFF | ((unint64_t)(a2 & 0xFFFFFF) << 40)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  v6 = ((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) & v5;
  v7 = (v6 | (v6 << 40)) >> 32;
  v8 = ((((65793 * a5) | ((unint64_t)(65793 * a5) << 40)) >> 8) & 0xFEFF00FFFEFF00FFLL | 0x100010001000100)
     - (((a4 & 0xFFFFFF | ((unint64_t)(a4 & 0xFFFFFF) << 40)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  v9 = ((v8 & 0x100010001000100) - ((v8 & 0x100010001000100) >> 8)) & v8;
  v10 = (v9 | (v9 << 40)) >> 32;
  v11 = (((v10 | (a5 << 24)) >> 8) & 0xFF00FF) + (((v7 | (a3 << 24)) >> 8) & 0xFF00FF);
  LODWORD(v7) = (v11 << 8) & 0xFF00FF00 | ((v10 & 0xFF00FF) + (v7 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                           * (v11 & 0x1000100 | (((v10 & 0xFF00FF) + (v7 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v11 & 0x1000100 | (((v10 & 0xFF00FF) + (v7 & 0xFF00FF)) >> 8) & 0x10001));
  v12 = ((((65793 * BYTE3(v7)) | ((unint64_t)(65793 * BYTE3(v7)) << 40)) >> 8) & 0xFEFF00FFFEFF00FFLL | 0x100010001000100)
      - (((v7 & 0xFFFFFF | ((v7 & 0xFFFFFF) << 40)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  *result = v7 & 0xFF000000 | ((((v12 & 0x100010001000100) - ((v12 & 0x100010001000100) >> 8)) & v12 | ((((v12 & 0x100010001000100) - ((v12 & 0x100010001000100) >> 8)) & v12) << 40)) >> 32);
  return result;
}

uint64_t PDAmultiplyPDA_13349(unsigned int a1, int a2, unsigned __int8 a3, int a4)
{
  int32x2_t v4;
  unsigned int v5;
  double v6;
  double v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;

  v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  v5 = ((a4 ^ 0xFF) + a3) * a1;
  v6 = COERCE_DOUBLE(vmul_s32(vadd_s32(vdup_n_s32(a4 ^ 0xFFu), v4), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)));
  v7 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v6, v4, vdup_n_s32(a2 ^ 0xFFu)));
  if (a2 != 255)
  {
    v5 += a3 * (a2 ^ 0xFF);
    v6 = v7;
  }
  v8 = 255 * (a4 + a2) - a4 * a2;
  v9 = HIDWORD(v6) + 128;
  if (HIDWORD(v6) >> 7 >= 0x1FD)
    v9 = 65152;
  v10 = v9 + (v9 >> 8);
  if (v5 >> 7 >= 0x1FD)
    v11 = 65152;
  else
    v11 = v5 + 128;
  v12 = v11 + (v11 >> 8);
  if (v8 >= 65152)
    v13 = 65152;
  else
    v13 = v8 + 128;
  v14 = (v13 + (v13 >> 8)) >> 8;
  if (LODWORD(v6) >> 7 >= 0x1FD)
    v15 = 16711680;
  else
    v15 = (257 * LODWORD(v6) + 32896) & 0xFF0000;
  return v15 & 0xFF0000 | (v14 << 24) | v10 & 0xFF00 | BYTE1(v12);
}

uint64_t PDAscreenPDA_13350(int a1, int a2, int a3, int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;

  v4 = BYTE2(a3) * (BYTE2(a1) ^ 0xFF) - BYTE2(a1) + (BYTE2(a1) << 8);
  v5 = BYTE1(a3) * (BYTE1(a1) ^ 0xFF) - BYTE1(a1) + (BYTE1(a1) << 8);
  v6 = a3 * (a1 ^ 0xFF) - a1 + (a1 << 8);
  v7 = 255 * (a4 + a2) - a4 * a2;
  v8 = v5 + 128;
  if (v5 >> 7 >= 0x1FD)
    v8 = 65152;
  v9 = v8 + (v8 >> 8);
  if (v6 >> 7 >= 0x1FD)
    v10 = 65152;
  else
    v10 = v6 + 128;
  v11 = v10 + (v10 >> 8);
  if (v7 >= 65152)
    v12 = 65152;
  else
    v12 = v7 + 128;
  v13 = (v12 + (v12 >> 8)) >> 8;
  if (v4 >> 7 >= 0x1FD)
    v14 = 16711680;
  else
    v14 = (257 * v4 + 32896) & 0xFF0000;
  return v14 & 0xFF0000 | v9 & 0xFF00 | BYTE1(v11) | (v13 << 24);
}

uint64_t PDAoverlayPDA_13351(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;

  v4 = BYTE2(a1);
  v5 = BYTE1(a1);
  v6 = a1;
  v7 = BYTE2(a3);
  v8 = BYTE1(a3);
  v9 = a3;
  if (BYTE2(a3) >= a4)
    v7 = a4;
  if (BYTE2(a1) >= a2)
    v4 = a2;
  v10 = 2 * v4 * v7;
  if (BYTE1(a3) >= a4)
    v8 = a4;
  if (BYTE1(a1) >= a2)
    v5 = a2;
  v11 = 2 * v5 * v8;
  if (a3 >= a4)
    v9 = a4;
  if (a1 >= a2)
    v6 = a2;
  v12 = 2 * v6 * v9;
  v13 = a4 * a2;
  v14 = (a2 + 1) >> 1;
  v15 = a4 + 255;
  v16 = a2 + 255;
  v17 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  v18 = a4 ^ 0xFF;
  v19 = a2 ^ 0xFF;
  v20 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  if (v4 < v14)
    v21 = v20;
  else
    v21 = v17;
  v22 = v15 * v5 + v8 * v16 - (v13 + v11);
  v23 = v8 * v19 + v18 * v5 + v11;
  if (v5 < v14)
    v24 = v23;
  else
    v24 = v22;
  if (v6 < v14)
    v25 = v9 * v19 + v18 * v6 + v12;
  else
    v25 = v15 * v6 + v9 * v16 - (v13 + v12);
  v26 = 255 * (a4 + a2) - v13;
  if (v24 >= 65152)
    v27 = 65152;
  else
    v27 = v24 + 128;
  v28 = v27 + (v27 >> 8);
  if (v25 >= 65152)
    v29 = 65152;
  else
    v29 = v25 + 128;
  v30 = v29 + (v29 >> 8);
  if (v26 >= 65152)
    v31 = 65152;
  else
    v31 = v26 + 128;
  v32 = (v31 + (v31 >> 8)) >> 8;
  if (v21 >= 65152)
    v33 = 16711680;
  else
    v33 = (257 * v21 + 32896) & 0xFF0000;
  return v33 & 0xFF0000 | (v32 << 24) | v28 & 0xFF00 | BYTE1(v30);
}

uint64_t PDAlightenPDA_13352(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  double v10;
  int v11;
  double v12;
  unsigned int v13;
  int32x2_t v14;
  double v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;

  v4 = a1;
  v5 = a3;
  v6 = vdup_n_s32(a4);
  v7 = vdup_n_s32(a2);
  v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  v9 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  v10 = COERCE_DOUBLE(vmax_u32((uint32x2_t)vmul_s32(v8, v7), (uint32x2_t)vmul_s32(v9, v6)));
  if (a3 >= a4)
    v5 = a4;
  if (a1 >= a2)
    v4 = a2;
  v11 = v4 * a4;
  if (v5 * a2 > v4 * a4)
    v11 = v5 * a2;
  v12 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, vdup_n_s32(a4 ^ 0xFF), v9));
  v13 = v11 + (a4 ^ 0xFF) * v4;
  if (a4 == 255)
  {
    v13 = v11;
    *(double *)&v14 = v10;
  }
  else
  {
    *(double *)&v14 = v12;
  }
  v15 = COERCE_DOUBLE(vmla_s32(v14, v8, vdup_n_s32(a2 ^ 0xFF)));
  v16 = v13 + v5 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    v13 = v16;
    *(double *)&v14 = v15;
  }
  v17 = 255 * (a4 + a2) - a4 * a2;
  v18 = v14.i32[1] + 128;
  if ((unsigned __int32)v14.i32[1] >> 7 >= 0x1FD)
    v18 = 65152;
  v19 = v18 + (v18 >> 8);
  if (v13 >> 7 >= 0x1FD)
    v20 = 65152;
  else
    v20 = v13 + 128;
  v21 = v20 + (v20 >> 8);
  if (v17 >= 65152)
    v22 = 65152;
  else
    v22 = v17 + 128;
  v23 = (v22 + (v22 >> 8)) >> 8;
  if ((unsigned __int32)v14.i32[0] >> 7 >= 0x1FD)
    v24 = 16711680;
  else
    v24 = (257 * v14.i32[0] + 32896) & 0xFF0000;
  return v24 & 0xFF0000 | (v23 << 24) | v19 & 0xFF00 | BYTE1(v21);
}

uint64_t PDAdarkenPDA_13353(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  double v10;
  int v11;
  double v12;
  unsigned int v13;
  int32x2_t v14;
  double v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;

  v4 = a1;
  v5 = a3;
  v6 = vdup_n_s32(a4);
  v7 = vdup_n_s32(a2);
  v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  v9 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  v10 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vmul_s32(v8, v7), (uint32x2_t)vmul_s32(v9, v6)));
  if (a3 >= a4)
    v5 = a4;
  if (a1 >= a2)
    v4 = a2;
  v11 = v4 * a4;
  if (v5 * a2 < v4 * a4)
    v11 = v5 * a2;
  v12 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, vdup_n_s32(a4 ^ 0xFF), v9));
  v13 = v11 + (a4 ^ 0xFF) * v4;
  if (a4 == 255)
  {
    v13 = v11;
    *(double *)&v14 = v10;
  }
  else
  {
    *(double *)&v14 = v12;
  }
  v15 = COERCE_DOUBLE(vmla_s32(v14, v8, vdup_n_s32(a2 ^ 0xFF)));
  v16 = v13 + v5 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    v13 = v16;
    *(double *)&v14 = v15;
  }
  v17 = 255 * (a4 + a2) - a4 * a2;
  v18 = v14.i32[1] + 128;
  if ((unsigned __int32)v14.i32[1] >> 7 >= 0x1FD)
    v18 = 65152;
  v19 = v18 + (v18 >> 8);
  if (v13 >> 7 >= 0x1FD)
    v20 = 65152;
  else
    v20 = v13 + 128;
  v21 = v20 + (v20 >> 8);
  if (v17 >= 65152)
    v22 = 65152;
  else
    v22 = v17 + 128;
  v23 = (v22 + (v22 >> 8)) >> 8;
  if ((unsigned __int32)v14.i32[0] >> 7 >= 0x1FD)
    v24 = 16711680;
  else
    v24 = (257 * v14.i32[0] + 32896) & 0xFF0000;
  return v24 & 0xFF0000 | (v23 << 24) | v19 & 0xFF00 | BYTE1(v21);
}

uint64_t PDAcolordodgePDA_13354(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;

  v4 = a4 * a4;
  if (BYTE2(a1) >= a2)
    v5 = a2;
  else
    v5 = BYTE2(a1);
  if (BYTE2(a3) >= a4)
    v6 = a4;
  else
    v6 = BYTE2(a3);
  if (v5)
  {
    if (BYTE2(a3) >= a4)
      v7 = 65025;
    else
      v7 = (int)(v4 * v5) / (int)(a4 - v6);
  }
  else
  {
    v7 = 0;
  }
  if (BYTE1(a1) >= a2)
    v8 = a2;
  else
    v8 = BYTE1(a1);
  if (BYTE1(a3) >= a4)
    v9 = a4;
  else
    v9 = BYTE1(a3);
  if (v8)
  {
    if (BYTE1(a3) >= a4)
      v10 = 65025;
    else
      v10 = (int)(v4 * v8) / (int)(a4 - v9);
  }
  else
  {
    v10 = 0;
  }
  if (a1 >= a2)
    v11 = a2;
  else
    v11 = a1;
  if (a3 >= a4)
    v12 = a4;
  else
    v12 = a3;
  if (v11)
  {
    if (a3 >= a4)
      v13 = 65025;
    else
      v13 = (int)(v4 * v11) / (int)(a4 - v12);
  }
  else
  {
    v13 = 0;
  }
  v14 = v7 + (a4 ^ 0xFF) * v5;
  v15 = v10 + (a4 ^ 0xFF) * v8;
  if (a4 == 255)
  {
    v14 = v7;
    v16 = v10;
  }
  else
  {
    v16 = v15;
  }
  if (a4 != 255)
    v13 += (a4 ^ 0xFF) * v11;
  v17 = v14 + v6 * (a2 ^ 0xFF);
  v18 = v16 + v9 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    v17 = v14;
    v19 = v16;
  }
  else
  {
    v19 = v18;
  }
  if (a2 == 255)
    v20 = v13;
  else
    v20 = v13 + v12 * (a2 ^ 0xFF);
  v21 = 255 * (a4 + a2) - a4 * a2;
  if (v17 >= v21)
    v17 = 255 * (a4 + a2) - a4 * a2;
  if (v19 >= v21)
    v19 = 255 * (a4 + a2) - a4 * a2;
  if (v20 >= v21)
    v20 = 255 * (a4 + a2) - a4 * a2;
  if (v19 >= 65152)
    v22 = 65152;
  else
    v22 = v19 + 128;
  v23 = v22 + (v22 >> 8);
  if (v20 >= 65152)
    v24 = 65152;
  else
    v24 = v20 + 128;
  v25 = v24 + (v24 >> 8);
  if (v21 >= 65152)
    v26 = 65152;
  else
    v26 = v21 + 128;
  v27 = (v26 + (v26 >> 8)) >> 8;
  if (v17 >= 65152)
    v28 = 16711680;
  else
    v28 = (257 * v17 + 32896) & 0xFF0000;
  return v28 & 0xFF0000 | (v27 << 24) | v23 & 0xFF00 | BYTE1(v25);
}

uint64_t PDAcolorburnPDA_13355(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  signed int v10;
  unsigned int v11;
  signed int v12;
  unsigned int v13;
  signed int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;

  v4 = BYTE2(a1);
  v5 = BYTE1(a1);
  v6 = a1;
  v7 = BYTE1(a3);
  v8 = a3;
  v9 = a4 * a2;
  if (BYTE2(a3) >= a4)
    v10 = a4;
  else
    v10 = BYTE2(a3);
  if (v4 >= a2)
    v11 = a2;
  else
    v11 = v4;
  if (v7 >= a4)
    v12 = a4;
  else
    v12 = v7;
  if (v5 >= a2)
    v13 = a2;
  else
    v13 = v5;
  if (v8 >= a4)
    v14 = a4;
  else
    v14 = v8;
  if (v6 >= a2)
    v15 = a2;
  else
    v15 = v6;
  v16 = v9 + (a4 ^ 0xFF) * v11;
  v17 = v9 + (a4 ^ 0xFF) * v13;
  if (a4 == 255)
  {
    v16 = a4 * a2;
    v17 = 255 * a2;
    v18 = 255 * a2;
  }
  else
  {
    v18 = v9 + (a4 ^ 0xFF) * v15;
  }
  if (a2 == 255)
    v19 = v16;
  else
    v19 = v16 + v10 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    v20 = v18;
  }
  else
  {
    v17 += v12 * (a2 ^ 0xFF);
    v20 = v18 + v14 * (a2 ^ 0xFF);
  }
  if (v4 < a2)
  {
    if (v10)
      v19 = (v19 - (int)(a4 * a4 * (a2 - v11)) / v10) & ~((int)(v19 - (int)(a4 * a4 * (a2 - v11)) / v10) >> 31);
    else
      v19 = 0;
  }
  if (v5 < a2)
  {
    if (v12)
      v17 = (v17 - (int)(a4 * a4 * (a2 - v13)) / v12) & ~((int)(v17 - (int)(a4 * a4 * (a2 - v13)) / v12) >> 31);
    else
      v17 = 0;
  }
  if (v6 < a2)
  {
    if (v14)
      v20 = (v20 - (int)(a4 * a4 * (a2 - v15)) / v14) & ~((int)(v20 - (int)(a4 * a4 * (a2 - v15)) / v14) >> 31);
    else
      v20 = 0;
  }
  v21 = 255 * (a4 + a2) - v9;
  v22 = v17 + 128;
  if (v17 >> 7 >= 0x1FD)
    v22 = 65152;
  v23 = v22 + (v22 >> 8);
  if (v20 >> 7 >= 0x1FD)
    v24 = 65152;
  else
    v24 = v20 + 128;
  v25 = v24 + (v24 >> 8);
  if (v21 >= 65152)
    v26 = 65152;
  else
    v26 = v21 + 128;
  v27 = (v26 + (v26 >> 8)) >> 8;
  if (v19 >> 7 >= 0x1FD)
    v28 = 16711680;
  else
    v28 = (257 * v19 + 32896) & 0xFF0000;
  return v28 & 0xFFFFFF | (v27 << 24) | v23 & 0xFF00 | (v25 >> 8);
}

uint64_t PDAhardlightPDA_13356(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;

  v4 = BYTE2(a1);
  v5 = BYTE1(a1);
  v6 = a1;
  v7 = BYTE2(a3);
  v8 = BYTE1(a3);
  v9 = a3;
  if (BYTE2(a3) >= a4)
    v7 = a4;
  if (BYTE2(a1) >= a2)
    v4 = a2;
  v10 = 2 * v4 * v7;
  if (BYTE1(a3) >= a4)
    v8 = a4;
  if (BYTE1(a1) >= a2)
    v5 = a2;
  v11 = 2 * v5 * v8;
  if (a3 >= a4)
    v9 = a4;
  if (a1 >= a2)
    v6 = a2;
  v12 = 2 * v6 * v9;
  v13 = a4 * a2;
  v14 = (a4 + 1) >> 1;
  v15 = a4 ^ 0xFF;
  v16 = a2 ^ 0xFF;
  v17 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  v18 = a4 + 255;
  v19 = a2 + 255;
  v20 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  if (v7 <= v14)
    v20 = v17;
  v21 = v8 * v16 + v15 * v5 + v11;
  v22 = v18 * v5 + v8 * v19 - (v13 + v11);
  if (v8 <= v14)
    v22 = v21;
  v23 = v9 * v16 + v15 * v6 + v12;
  v24 = v18 * v6 + v9 * v19 - (v13 + v12);
  if (v9 <= v14)
    v24 = v23;
  v25 = 255 * (a4 + a2) - v13;
  if (v22 >= 65152)
    v26 = 65152;
  else
    v26 = v22 + 128;
  v27 = v26 + (v26 >> 8);
  if (v24 >= 65152)
    v28 = 65152;
  else
    v28 = v24 + 128;
  v29 = v28 + (v28 >> 8);
  if (v25 >= 65152)
    v30 = 65152;
  else
    v30 = v25 + 128;
  v31 = (v30 + (v30 >> 8)) >> 8;
  if (v20 >= 65152)
    v32 = 16711680;
  else
    v32 = (257 * v20 + 32896) & 0xFF0000;
  return v32 & 0xFF0000 | (v31 << 24) | v27 & 0xFF00 | BYTE1(v29);
}

uint64_t PDAsoftlightPDA_13357(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;

  v4 = BYTE2(a1);
  v5 = BYTE2(a3);
  if (BYTE2(a3) >= a4)
    v5 = a4;
  if (BYTE2(a1) >= a2)
    v4 = a2;
  v6 = a3;
  v7 = BYTE1(a3);
  v8 = a1;
  v9 = BYTE1(a1);
  v10 = (int)(v4 * v4 * (2 * v5 - a4)) / (int)a2;
  v11 = (2 * v4 * v5 - v10) & ~((int)(2 * v4 * v5 - v10) >> 31);
  if (BYTE1(a3) >= a4)
    v7 = a4;
  if (BYTE1(a1) >= a2)
    v9 = a2;
  v12 = (int)(v9 * v9 * (2 * v7 - a4)) / (int)a2;
  v13 = (2 * v9 * v7 - v12) & ~((int)(2 * v9 * v7 - v12) >> 31);
  if (a3 >= a4)
    v6 = a4;
  if (a1 >= a2)
    v8 = a2;
  v14 = 2 * v8 * v6 - (int)(v8 * v8 * (2 * v6 - a4)) / (int)a2;
  v15 = v14 & ~(v14 >> 31);
  v16 = v11 + (a4 ^ 0xFF) * v4;
  v17 = v13 + v9 * (a4 ^ 0xFF);
  v18 = v15 + v8 * (a4 ^ 0xFF);
  if (a4 == 255)
  {
    v16 = v11;
    v17 = v13;
    v18 = v15;
  }
  v19 = v16 + v5 * (a2 ^ 0xFF);
  v20 = v17 + v7 * (a2 ^ 0xFF);
  v21 = v18 + v6 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    v22 = v17;
  }
  else
  {
    v16 = v19;
    v22 = v20;
  }
  if (a2 == 255)
    v21 = v18;
  v23 = 255 * (a4 + a2) - a4 * a2;
  v24 = v22 + 128;
  if (v22 >> 7 >= 0x1FD)
    v24 = 65152;
  v25 = v24 + (v24 >> 8);
  if (v21 >> 7 >= 0x1FD)
    v26 = 65152;
  else
    v26 = v21 + 128;
  v27 = v26 + (v26 >> 8);
  if (v23 >= 65152)
    v28 = 65152;
  else
    v28 = v23 + 128;
  v29 = (v28 + (v28 >> 8)) >> 8;
  if (v16 >> 7 >= 0x1FD)
    v30 = 16711680;
  else
    v30 = (257 * v16 + 32896) & 0xFF0000;
  return v30 & 0xFF0000 | (v29 << 24) | v25 & 0xFF00 | BYTE1(v27);
}

uint64_t PDAdifferencePDA_13358(unsigned __int32 a1, unsigned int a2, unsigned __int32 a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  int8x8_t v6;
  int8x8_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  unsigned int v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int32x2_t v21;
  int32x2_t v22;
  uint32x2_t v23;
  int32x2_t v24;
  int32x2_t v25;
  unsigned int v26;
  int32x2_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;

  v4 = BYTE2(a1);
  v5 = BYTE2(a3);
  v6.i32[0] = a1;
  v6.i32[1] = a1 >> 8;
  v7.i32[0] = a3;
  v7.i32[1] = a3 >> 8;
  v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8(v7, (int8x8_t)0xFF000000FFLL), (uint32x2_t)vdup_n_s32(a4));
  v9 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8(v6, (int8x8_t)0xFF000000FFLL), (uint32x2_t)vdup_n_s32(a2));
  v10 = vmul_s32((int32x2_t)__PAIR64__(v8.u32[1], v9.u32[0]), (int32x2_t)__PAIR64__(a2, a4));
  v11 = vrev64_s32((int32x2_t)__PAIR64__(a2, a4));
  if (BYTE2(a3) >= a4)
    v5 = a4;
  if (BYTE2(a1) >= a2)
    v4 = a2;
  v12 = v5 + v4;
  v13 = v4 * a4;
  v14 = v5 * a2;
  v16 = v13 - v14;
  v15 = v13 - v14 < 0;
  v17 = 255 * v12 - v14 - v13;
  if (v15)
    v18 = -v16;
  else
    v18 = v16;
  v19 = v17 + v18;
  v20 = 255 * (a4 + a2) - a4 * a2;
  v21 = vadd_s32(v8, v9);
  v8.i32[1] = v9.i32[1];
  v22 = vmul_s32(v8, v11);
  v23 = (uint32x2_t)__PAIR64__(v10.u32[1], v22.u32[0]);
  v24 = vneg_s32(v10);
  v10.i32[1] = v22.i32[1];
  v25 = (int32x2_t)vaba_u32((uint32x2_t)vsub_s32(vmla_s32(v24, v21, (int32x2_t)0xFF000000FFLL), v22), v23, (uint32x2_t)v10);
  v26 = v25.i32[1] + 128;
  v27 = vcgt_s32(vdup_n_s32(0xFE80u), v25);
  if ((v27.i8[4] & 1) == 0)
    v26 = 65152;
  v28 = v26 + (v26 >> 8);
  v29 = v25.i32[0] + 128;
  if ((v27.i8[0] & 1) == 0)
    v29 = 65152;
  v30 = v29 + (v29 >> 8);
  if (v20 >= 65152)
    v31 = 65152;
  else
    v31 = v20 + 128;
  v32 = (v31 + (v31 >> 8)) >> 8;
  if (v19 >= 65152)
    v33 = 16711680;
  else
    v33 = (257 * v19 + 32896) & 0xFF0000;
  return v33 & 0xFF0000 | (v32 << 24) | v28 & 0xFF00 | BYTE1(v30);
}

uint64_t PDAexclusionPDA_13359(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;

  v4 = BYTE2(a1);
  v5 = BYTE1(a1);
  v6 = a1;
  v7 = BYTE2(a3);
  if (BYTE2(a3) >= a4)
    v7 = a4;
  if (BYTE2(a1) >= a2)
    v4 = a2;
  v8 = 255 * (v7 + v4) - 2 * v4 * v7;
  if (BYTE1(a3) >= a4)
    v9 = a4;
  else
    v9 = BYTE1(a3);
  if (BYTE1(a1) >= a2)
    v5 = a2;
  v10 = 255 * (v9 + v5) - 2 * v5 * v9;
  if (a3 >= a4)
    v11 = a4;
  else
    v11 = a3;
  if (a1 >= a2)
    v6 = a2;
  v12 = 255 * (v11 + v6) - 2 * v6 * v11;
  v13 = 255 * (a4 + a2) - a4 * a2;
  if (v10 >= 65152)
    v14 = 65152;
  else
    v14 = v10 + 128;
  v15 = v14 + (v14 >> 8);
  if (v12 >= 65152)
    v16 = 65152;
  else
    v16 = v12 + 128;
  v17 = v16 + (v16 >> 8);
  if (v13 >= 65152)
    v18 = 65152;
  else
    v18 = v13 + 128;
  v19 = (v18 + (v18 >> 8)) >> 8;
  if (v8 >= 65152)
    v20 = 16711680;
  else
    v20 = (257 * v8 + 32896) & 0xFF0000;
  return v20 & 0xFF0000 | v15 & 0xFF00 | (v19 << 24) | BYTE1(v17);
}

uint64_t PDAhuePDA_13360(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  unsigned int v4;
  int32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  double v8;
  unsigned int v9;
  double v10;
  uint32x2_t v11;
  double v12;
  int v13;
  unsigned int v14;
  double v15;
  double v16;
  uint32x2_t v17;
  double v18;
  unsigned int v19;
  signed int v20;
  double v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  __int32 v27;
  __int32 v28;
  __int32 v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  signed int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int32x2_t v53;
  signed int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = vdup_n_s32(a4);
  v6 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v5);
  v7 = vdup_n_s32(a2);
  v8 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7));
  if (a3 >= a4)
    v9 = a4;
  else
    v9 = a3;
  if (a1 >= a2)
    v4 = a2;
  v10 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFF), *(int32x2_t *)&v8));
  v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v8, v5);
  v12 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL));
  if (a4 == 255)
    v13 = 0;
  else
    v13 = (a4 ^ 0xFF) * v4;
  if (a4 == 255)
    v14 = v4;
  else
    v14 = (v4 * a4 + 128 + ((v4 * a4 + 128) >> 8)) >> 8;
  if (a4 == 255)
  {
    v10 = 0.0;
    v15 = v8;
  }
  else
  {
    v15 = v12;
  }
  v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, v6, vdup_n_s32(a2 ^ 0xFF)));
  v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v6, v7);
  v18 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL));
  v19 = v13 + v9 * (a2 ^ 0xFF);
  v20 = (v9 * a2 + 128 + ((v9 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
  {
    v19 = v13;
    v20 = v9;
    v21 = v10;
  }
  else
  {
    *(double *)&v6 = v18;
    v21 = v16;
  }
  v53 = v6;
  v54 = v20;
  v22 = vcge_u32((uint32x2_t)v6, (uint32x2_t)vdup_lane_s32(v6, 1)).u8[0];
  v23 = v22 & 1;
  v24 = (v22 & 1) == 0;
  if (v20 >= *(_DWORD *)((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * v23)))
  {
    v26 = v20 <= *(_DWORD *)((unint64_t)&v53 | (4 * v24));
    v25 = v22 & 1;
    if (v26)
      v23 = 2;
    else
      v23 = (v22 & 1) == 0;
    if (!v26)
      v24 = 2;
  }
  else
  {
    v25 = 2;
  }
  v27 = v53.i32[v24];
  v28 = v53.i32[v25];
  v29 = v27 - v28;
  if (v27 <= v28)
  {
    v53.i32[v24] = 0;
    v53.i32[v23] = 0;
    v30 = LODWORD(v15);
    v31 = HIDWORD(v15);
  }
  else
  {
    v30 = LODWORD(v15);
    v31 = HIDWORD(v15);
    if (LODWORD(v15) >= HIDWORD(v15))
      v32 = HIDWORD(v15);
    else
      v32 = LODWORD(v15);
    if (LODWORD(v15) <= HIDWORD(v15))
      v33 = HIDWORD(v15);
    else
      v33 = LODWORD(v15);
    if (v14 <= v33)
      v34 = v33;
    else
      v34 = v14;
    if (v14 >= v32)
      v33 = v34;
    else
      v32 = v14;
    v35 = v33 - v32;
    v53.i32[v24] = v35;
    v53.i32[v23] = ((v53.i32[v23] - v53.i32[v25]) * ((int)(v35 << 16) / v29) + 0x8000) >> 16;
  }
  v53.i32[v25] = 0;
  v36 = 77 * (v30 - v53.i32[0]) + 151 * (v31 - v53.i32[1]) + 28 * (v14 - v54);
  v37 = v53.i32[0] + ((v36 + 128) >> 8);
  v38 = v53.i32[1] + ((v36 + 128) >> 8);
  v39 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v40 = v54 + ((v36 + 128) >> 8);
  if (v36 != (char)v36)
  {
    if (v53.i32[0] >= v53.i32[1])
      v41 = v53.i32[1] + ((v36 + 128) >> 8);
    else
      v41 = v53.i32[0] + ((v36 + 128) >> 8);
    if (v53.i32[0] >= v53.i32[1])
      v42 = v53.i32[0] + ((v36 + 128) >> 8);
    else
      v42 = v53.i32[1] + ((v36 + 128) >> 8);
    if (v40 <= v42)
      v43 = v42;
    else
      v43 = v54 + ((v36 + 128) >> 8);
    if (v40 >= v41)
      v44 = v41;
    else
      v44 = v54 + ((v36 + 128) >> 8);
    if (v40 >= v41)
      v42 = v43;
    if (v42 > v39 || v44 < 0)
    {
      v45 = (77 * v37 + 151 * v38 + 28 * v40 + 128) >> 8;
      if (v36 > -129)
      {
        v46 = v42 - v45;
        if (v42 == v45)
          goto LABEL_63;
        v47 = v39 - v45;
      }
      else
      {
        v46 = v45 - v44;
        if (v45 == v44)
          goto LABEL_63;
        v47 = (77 * v37 + 151 * v38 + 28 * v40 + 128) >> 8;
      }
      v48 = (v47 << 16) / v46;
      v37 = v45 + ((v48 * (v37 - v45) + 0x8000) >> 16);
      v38 = v45 + ((v48 * (v38 - v45) + 0x8000) >> 16);
      v40 = v45 + ((v48 * (v40 - v45) + 0x8000) >> 16);
    }
  }
LABEL_63:
  if (v19 >> 7 >= 0x1FD)
    v49 = 65152;
  else
    v49 = v19 + 128;
  if (HIDWORD(v21) >> 7 >= 0x1FD)
    v50 = 65152;
  else
    v50 = HIDWORD(v21) + 128;
  if (LODWORD(v21) >> 7 >= 0x1FD)
    v51 = 65152;
  else
    v51 = LODWORD(v21) + 128;
  return (v40 + ((unsigned __int16)(v49 + (v49 >> 8)) >> 8)) | ((a4 + a2 - v39) << 24) | ((_WORD)v50 + (unsigned __int16)(v50 >> 8) + ((_WORD)v38 << 8)) & 0xFF00 | ((v37 + ((unsigned __int16)(v51 + (v51 >> 8)) >> 8)) << 16);
}

uint64_t PDAsaturationPDA_13361(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  int32x2_t v4;
  double v5;
  int32x2_t v6;
  int32x2_t v7;
  unsigned int v8;
  signed int v9;
  int32x2_t v10;
  uint32x2_t v11;
  unsigned int v12;
  double v13;
  double v14;
  uint32x2_t v15;
  double v16;
  unsigned int v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int32 v22;
  __int32 v23;
  BOOL v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  signed int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  int32x2_t v47;
  signed int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v4 = vdup_n_s32(a4);
  v5 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v4));
  v6 = vdup_n_s32(a2);
  v7 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  if (a3 >= a4)
    v8 = a4;
  else
    v8 = a3;
  if (a1 >= a2)
    v9 = a2;
  else
    v9 = a1;
  if (a4 == 255)
  {
    v12 = 0;
    v10 = 0;
  }
  else
  {
    v10 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v7);
    v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v7, v4);
    v7 = (int32x2_t)vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL);
    v12 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
  }
  v13 = COERCE_DOUBLE(vrev64_s32(v10));
  v14 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v13, *(int32x2_t *)&v5, vdup_n_s32(a2 ^ 0xFF)));
  v15 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v5, v6);
  v16 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v15, v15, 8uLL), 8uLL));
  v17 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
    v17 = v8;
  else
    v12 += v8 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    v16 = v5;
    v18 = v13;
  }
  else
  {
    v18 = v14;
  }
  v47 = v7;
  v48 = v9;
  v19 = v7.i32[0] < (unsigned __int32)v7.i32[1];
  v20 = v7.i32[0] >= (unsigned __int32)v7.i32[1];
  if (v9 >= *(_DWORD *)((unint64_t)&v47 | (4 * v20)))
  {
    v21 = v7.i32[0] >= (unsigned __int32)v7.i32[1];
    if (v9 <= *(_DWORD *)((unint64_t)&v47 | (4 * v19)))
      v20 = 2;
    else
      v20 = v7.i32[0] < (unsigned __int32)v7.i32[1];
    if (v9 > *(_DWORD *)((unint64_t)&v47 | (4 * v19)))
      v19 = 2;
  }
  else
  {
    v21 = 2;
  }
  v22 = v47.i32[v19];
  v23 = v47.i32[v21];
  v24 = __OFSUB__(v22, v23);
  v25 = v22 - v23;
  if ((v25 < 0) ^ v24 | (v25 == 0))
  {
    v47.i32[v19] = 0;
    v47.i32[v20] = 0;
  }
  else
  {
    v26 = LODWORD(v16);
    if (HIDWORD(v16) >= LODWORD(v16))
      v27 = LODWORD(v16);
    else
      v27 = HIDWORD(v16);
    if (HIDWORD(v16) > LODWORD(v16))
      v26 = HIDWORD(v16);
    if (v17 <= v26)
      v28 = v26;
    else
      v28 = v17;
    if (v17 >= v27)
    {
      v17 = v27;
      v26 = v28;
    }
    v29 = v26 - v17;
    v47.i32[v19] = v29;
    v47.i32[v20] = ((v47.i32[v20] - v47.i32[v21]) * ((int)(v29 << 16) / v25) + 0x8000) >> 16;
  }
  v47.i32[v21] = 0;
  v30 = 77 * (v7.i32[0] - v47.i32[0]) + 151 * (v7.i32[1] - v47.i32[1]) + 28 * (v9 - v48);
  v31 = v47.i32[0] + ((v30 + 128) >> 8);
  v32 = v47.i32[1] + ((v30 + 128) >> 8);
  v33 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v34 = v48 + ((v30 + 128) >> 8);
  if (v30 != (char)v30)
  {
    if (v47.i32[0] >= v47.i32[1])
      v35 = v47.i32[1] + ((v30 + 128) >> 8);
    else
      v35 = v47.i32[0] + ((v30 + 128) >> 8);
    if (v47.i32[0] >= v47.i32[1])
      v36 = v47.i32[0] + ((v30 + 128) >> 8);
    else
      v36 = v47.i32[1] + ((v30 + 128) >> 8);
    if (v34 <= v36)
      v37 = v36;
    else
      v37 = v48 + ((v30 + 128) >> 8);
    if (v34 >= v35)
      v38 = v35;
    else
      v38 = v48 + ((v30 + 128) >> 8);
    if (v34 >= v35)
      v36 = v37;
    if (v36 > v33 || v38 < 0)
    {
      v39 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      if (v30 > -129)
      {
        v40 = v36 - v39;
        if (v36 == v39)
          goto LABEL_59;
        v41 = v33 - v39;
      }
      else
      {
        v40 = v39 - v38;
        if (v39 == v38)
          goto LABEL_59;
        v41 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      }
      v42 = (v41 << 16) / v40;
      v31 = v39 + ((v42 * (v31 - v39) + 0x8000) >> 16);
      v32 = v39 + ((v42 * (v32 - v39) + 0x8000) >> 16);
      v34 = v39 + ((v42 * (v34 - v39) + 0x8000) >> 16);
    }
  }
LABEL_59:
  if (v12 >> 7 >= 0x1FD)
    v43 = 65152;
  else
    v43 = v12 + 128;
  if (LODWORD(v18) >> 7 >= 0x1FD)
    v44 = 65152;
  else
    v44 = LODWORD(v18) + 128;
  if (HIDWORD(v18) >> 7 >= 0x1FD)
    v45 = 65152;
  else
    v45 = HIDWORD(v18) + 128;
  return (v34 + ((unsigned __int16)(v43 + (v43 >> 8)) >> 8)) | ((a4 + a2 - v33) << 24) | ((_WORD)v44 + (unsigned __int16)(v44 >> 8) + ((_WORD)v32 << 8)) & 0xFF00 | ((v31 + ((unsigned __int16)(v45 + (v45 >> 8)) >> 8)) << 16);
}

uint64_t PDAluminosityPDA_13362(unsigned __int8 a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint32x2_t v4;
  unsigned int v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  unsigned int v9;
  int32x2_t v10;
  uint32x2_t v11;
  unsigned int v12;
  int32x2_t v13;
  uint32x2_t v14;
  int32x2_t v15;
  int v16;
  int v17;
  __int32 v18;
  signed int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint32x2_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;

  v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  v5 = a3;
  v6 = vdup_n_s32(a4);
  v7 = vdup_n_s32(a2);
  v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  if (a3 >= a4)
    v5 = a4;
  if (a1 >= a2)
    v9 = a2;
  else
    v9 = a1;
  if (a4 == 255)
  {
    v12 = 0;
    v10 = 0;
  }
  else
  {
    v10 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v8);
    v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v8, v6);
    v8 = (int32x2_t)vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL);
    v12 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
  }
  v13 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v6);
  if (a2 != 255)
  {
    v10 = vmla_s32(v10, v13, vdup_n_s32(a2 ^ 0xFF));
    v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v13, v7);
    v13 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
    v12 += v5 * (a2 ^ 0xFF);
    v5 = (v5 * a2 + 128 + ((v5 * a2 + 128) >> 8)) >> 8;
  }
  v15 = vmul_s32(vsub_s32(v13, v8), (int32x2_t)0x4D00000097);
  v16 = v15.i32[0] + 28 * (v5 - v9) + v15.i32[1];
  v17 = v8.i32[1] + ((v16 + 128) >> 8);
  v18 = v8.i32[0] + ((v16 + 128) >> 8);
  v19 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v20 = v9 + ((v16 + 128) >> 8);
  if (v16 != (char)v16)
  {
    if (v8.i32[1] >= (unsigned __int32)v8.i32[0])
      v21 = v8.i32[0] + ((v16 + 128) >> 8);
    else
      v21 = v8.i32[1] + ((v16 + 128) >> 8);
    if (v8.i32[1] >= (unsigned __int32)v8.i32[0])
      v22 = v8.i32[1] + ((v16 + 128) >> 8);
    else
      v22 = v8.i32[0] + ((v16 + 128) >> 8);
    if (v20 <= v22)
      v23 = v22;
    else
      v23 = v20;
    if (v20 >= v21)
      v24 = v21;
    else
      v24 = v20;
    if (v20 >= v21)
      v22 = v23;
    if (v22 > v19 || v24 < 0)
    {
      v25 = (77 * v17 + 151 * v18 + 28 * v20 + 128) >> 8;
      if (v16 > -129)
      {
        v26 = v22 - v25;
        if (v22 == v25)
          goto LABEL_34;
        v27 = v19 - v25;
      }
      else
      {
        v26 = v25 - v24;
        if (v25 == v24)
          goto LABEL_34;
        v27 = (77 * v17 + 151 * v18 + 28 * v20 + 128) >> 8;
      }
      v28 = (v27 << 16) / v26;
      v17 = v25 + ((v28 * (v17 - v25) + 0x8000) >> 16);
      v18 = v25 + ((v28 * (v18 - v25) + 0x8000) >> 16);
      v20 = v25 + ((v28 * (v20 - v25) + 0x8000) >> 16);
    }
  }
LABEL_34:
  v29 = a4 + a2 - v19;
  v30 = v12 + 128;
  if (v12 >> 7 >= 0x1FD)
    v30 = 65152;
  v31 = v20 + ((v30 + (v30 >> 8)) >> 8);
  v32 = vcgt_u32((uint32x2_t)vdup_n_s32(0xFE80u), (uint32x2_t)v10);
  v33 = v10.i32[0] + 128;
  if ((v32.i8[0] & 1) == 0)
    v33 = 65152;
  v34 = v33 + (v33 >> 8);
  if ((v32.i8[4] & 1) != 0)
    v35 = v10.i32[1] + 128;
  else
    v35 = 65152;
  return v31 | (v29 << 24) | ((_WORD)v34 + ((_WORD)v18 << 8)) & 0xFF00 | ((v17 + ((unsigned __int16)(v35 + (v35 >> 8)) >> 8)) << 16);
}

uint64_t PDAtranspose_huePDA_13363(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  unsigned int v4;
  uint32x2_t v5;
  uint32x2_t v6;
  unsigned int v7;
  int32x2_t v8;
  double v9;
  int32x2_t v10;
  double v11;
  int v12;
  double v13;
  uint32x2_t v14;
  double v15;
  unsigned int v16;
  double v17;
  double v18;
  uint32x2_t v19;
  double v20;
  unsigned int v21;
  unsigned int v22;
  double v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  signed int v41;
  int v42;
  int v43;
  signed int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  int v55;
  double v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  v6 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  if (a3 >= a4)
    v7 = a4;
  else
    v7 = a3;
  if (a1 >= a2)
    v4 = a2;
  v8 = vdup_n_s32(a4);
  v9 = COERCE_DOUBLE(vmin_u32(v6, (uint32x2_t)v8));
  v10 = vdup_n_s32(a2);
  v11 = COERCE_DOUBLE(vmin_u32(v5, (uint32x2_t)v10));
  v12 = (a4 ^ 0xFF) * v4;
  v13 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFF), *(int32x2_t *)&v11));
  v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v11, v8);
  v15 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL));
  if (a4 == 255)
  {
    v12 = 0;
    v16 = v4;
  }
  else
  {
    v16 = (v4 * a4 + 128 + ((v4 * a4 + 128) >> 8)) >> 8;
  }
  if (a4 == 255)
  {
    v13 = 0.0;
    v17 = v11;
  }
  else
  {
    v17 = v15;
  }
  v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v13, *(int32x2_t *)&v9, vdup_n_s32(a2 ^ 0xFF)));
  v19 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v9, v10);
  v20 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v19, v19, 8uLL), 8uLL));
  if (a2 == 255)
    v21 = v12;
  else
    v21 = v12 + v7 * (a2 ^ 0xFF);
  if (a2 == 255)
    v22 = v7;
  else
    v22 = (v7 * a2 + 128 + ((v7 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
  {
    v23 = v13;
  }
  else
  {
    v9 = v20;
    v23 = v18;
  }
  v55 = v22;
  v56 = v9;
  v24 = v22 >= LODWORD(v9);
  v25 = v22 < LODWORD(v9);
  v26 = v24;
  if (SHIDWORD(v9) >= *(&v55 + v26))
  {
    v28 = *(&v55 + v25);
    v27 = v26;
    if (SHIDWORD(v9) <= v28)
      v26 = 2;
    else
      v26 = v25;
    if (SHIDWORD(v9) > v28)
      v25 = 2;
  }
  else
  {
    v27 = 2;
  }
  v29 = *(&v55 + v25);
  v30 = *(&v55 + v27);
  v31 = v29 - v30;
  if (v29 <= v30)
  {
    *(&v55 + v25) = 0;
    *(&v55 + v26) = 0;
    v32 = LODWORD(v17);
    v35 = HIDWORD(v17);
  }
  else
  {
    v32 = LODWORD(v17);
    if (v16 >= LODWORD(v17))
      v33 = LODWORD(v17);
    else
      v33 = v16;
    if (v16 <= LODWORD(v17))
      v34 = LODWORD(v17);
    else
      v34 = v16;
    v35 = HIDWORD(v17);
    if (HIDWORD(v17) <= v34)
      v36 = v34;
    else
      v36 = HIDWORD(v17);
    if (HIDWORD(v17) >= v33)
      v34 = v36;
    else
      v33 = HIDWORD(v17);
    v37 = v34 - v33;
    *(&v55 + v25) = v37;
    *(&v55 + v26) = ((*(&v55 + v26) - *(&v55 + v27)) * ((v37 << 16) / v31) + 0x8000) >> 16;
  }
  *(&v55 + v27) = 0;
  v38 = 77 * (v16 - v55) + 151 * (v32 - LODWORD(v56)) + 28 * (v35 - HIDWORD(v56));
  v39 = v55 + ((v38 + 128) >> 8);
  v40 = LODWORD(v56) + ((v38 + 128) >> 8);
  v41 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v42 = HIDWORD(v56) + ((v38 + 128) >> 8);
  if (v38 != (char)v38)
  {
    if (v55 >= SLODWORD(v56))
      v43 = LODWORD(v56) + ((v38 + 128) >> 8);
    else
      v43 = v55 + ((v38 + 128) >> 8);
    if (v55 >= SLODWORD(v56))
      v44 = v55 + ((v38 + 128) >> 8);
    else
      v44 = LODWORD(v56) + ((v38 + 128) >> 8);
    if (v42 <= v44)
      v45 = v44;
    else
      v45 = HIDWORD(v56) + ((v38 + 128) >> 8);
    if (v42 >= v43)
      v46 = v43;
    else
      v46 = HIDWORD(v56) + ((v38 + 128) >> 8);
    if (v42 >= v43)
      v44 = v45;
    if (v44 > v41 || v46 < 0)
    {
      v47 = (77 * v39 + 151 * v40 + 28 * v42 + 128) >> 8;
      if (v38 > -129)
      {
        v48 = v44 - v47;
        if (v44 == v47)
          goto LABEL_69;
        v49 = v41 - v47;
      }
      else
      {
        v48 = v47 - v46;
        if (v47 == v46)
          goto LABEL_69;
        v49 = (77 * v39 + 151 * v40 + 28 * v42 + 128) >> 8;
      }
      v50 = (v49 << 16) / v48;
      v39 = v47 + ((v50 * (v39 - v47) + 0x8000) >> 16);
      v40 = v47 + ((v50 * (v40 - v47) + 0x8000) >> 16);
      v42 = v47 + ((v50 * (v42 - v47) + 0x8000) >> 16);
    }
  }
LABEL_69:
  if (HIDWORD(v23) >> 7 >= 0x1FD)
    v51 = 65152;
  else
    v51 = HIDWORD(v23) + 128;
  if (LODWORD(v23) >> 7 >= 0x1FD)
    v52 = 65152;
  else
    v52 = LODWORD(v23) + 128;
  if (v21 >> 7 >= 0x1FD)
    v53 = 65152;
  else
    v53 = v21 + 128;
  return ((a4 + a2 - v41) << 24) | ((v42 + ((unsigned __int16)(v51 + (v51 >> 8)) >> 8)) << 16) | (v52 + (v52 >> 8) + (v40 << 8)) & 0xFF00 | (v39 + ((unsigned __int16)(v53 + (v53 >> 8)) >> 8));
}

uint64_t PDAtranspose_saturationPDA_13364(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  uint32x2_t v4;
  uint32x2_t v5;
  unsigned int v6;
  unsigned int v7;
  int32x2_t v8;
  double v9;
  int32x2_t v10;
  int32x2_t v11;
  unsigned int v12;
  int32x2_t v13;
  uint32x2_t v14;
  double v15;
  double v16;
  uint32x2_t v17;
  double v18;
  unsigned int v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  signed int v35;
  int v36;
  int v37;
  signed int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  int v49;
  int32x2_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  if (a3 >= a4)
    v6 = a4;
  else
    v6 = a3;
  if (a1 >= a2)
    v7 = a2;
  else
    v7 = a1;
  v8 = vdup_n_s32(a4);
  v9 = COERCE_DOUBLE(vmin_u32(v5, (uint32x2_t)v8));
  v10 = vdup_n_s32(a2);
  v11 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v10);
  if (a4 == 255)
  {
    v12 = 0;
    v13 = 0;
  }
  else
  {
    v12 = (a4 ^ 0xFF) * v7;
    v7 = (v7 * a4 + 128 + ((v7 * a4 + 128) >> 8)) >> 8;
    v13 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v11);
    v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v11, v8);
    v11 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
  }
  v15 = COERCE_DOUBLE(vrev64_s32(v13));
  v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, *(int32x2_t *)&v9, vdup_n_s32(a2 ^ 0xFF)));
  v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v9, v10);
  v18 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL));
  if (a2 == 255)
  {
    v19 = v6;
  }
  else
  {
    v12 += v6 * (a2 ^ 0xFF);
    v19 = (v6 * a2 + 128 + ((v6 * a2 + 128) >> 8)) >> 8;
  }
  if (a2 == 255)
  {
    v18 = v9;
    v20 = v15;
  }
  else
  {
    v20 = v16;
  }
  v49 = v7;
  v50 = v11;
  v21 = v7 < v11.i32[0];
  v22 = v7 >= v11.i32[0];
  if (v11.i32[1] >= *(&v49 + v22))
  {
    v23 = v7 >= v11.i32[0];
    if (v11.i32[1] <= *(&v49 + v21))
      v22 = 2;
    else
      v22 = v7 < v11.i32[0];
    if (v11.i32[1] > *(&v49 + v21))
      v21 = 2;
  }
  else
  {
    v23 = 2;
  }
  v24 = *(&v49 + v21);
  v25 = *(&v49 + v23);
  v26 = __OFSUB__(v24, v25);
  v27 = v24 - v25;
  if ((v27 < 0) ^ v26 | (v27 == 0))
  {
    *(&v49 + v21) = 0;
    *(&v49 + v22) = 0;
  }
  else
  {
    if (v19 >= HIDWORD(v18))
      v28 = HIDWORD(v18);
    else
      v28 = v19;
    if (v19 <= HIDWORD(v18))
      v19 = HIDWORD(v18);
    v29 = LODWORD(v18);
    if (LODWORD(v18) <= v19)
      v30 = v19;
    else
      v30 = LODWORD(v18);
    if (LODWORD(v18) >= v28)
    {
      v29 = v28;
      v19 = v30;
    }
    v31 = v19 - v29;
    *(&v49 + v21) = v31;
    *(&v49 + v22) = ((*(&v49 + v22) - *(&v49 + v23)) * ((v31 << 16) / v27) + 0x8000) >> 16;
  }
  *(&v49 + v23) = 0;
  v32 = 77 * (v7 - v49) + 151 * (v11.i32[0] - v50.i32[0]) + 28 * (v11.i32[1] - v50.i32[1]);
  v33 = v49 + ((v32 + 128) >> 8);
  v34 = v50.i32[0] + ((v32 + 128) >> 8);
  v35 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v36 = v50.i32[1] + ((v32 + 128) >> 8);
  if (v32 != (char)v32)
  {
    if (v49 >= v50.i32[0])
      v37 = v50.i32[0] + ((v32 + 128) >> 8);
    else
      v37 = v49 + ((v32 + 128) >> 8);
    if (v49 >= v50.i32[0])
      v38 = v49 + ((v32 + 128) >> 8);
    else
      v38 = v50.i32[0] + ((v32 + 128) >> 8);
    if (v36 <= v38)
      v39 = v38;
    else
      v39 = v50.i32[1] + ((v32 + 128) >> 8);
    if (v36 >= v37)
      v40 = v37;
    else
      v40 = v50.i32[1] + ((v32 + 128) >> 8);
    if (v36 >= v37)
      v38 = v39;
    if (v38 > v35 || v40 < 0)
    {
      v41 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      if (v32 > -129)
      {
        v42 = v38 - v41;
        if (v38 == v41)
          goto LABEL_59;
        v43 = v35 - v41;
      }
      else
      {
        v42 = v41 - v40;
        if (!v42)
          goto LABEL_59;
        v43 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      }
      v44 = (v43 << 16) / v42;
      v33 = v41 + ((v44 * (v33 - v41) + 0x8000) >> 16);
      v34 = v41 + ((v44 * (v34 - v41) + 0x8000) >> 16);
      v36 = v41 + ((v44 * (v36 - v41) + 0x8000) >> 16);
    }
  }
LABEL_59:
  if (LODWORD(v20) >> 7 >= 0x1FD)
    v45 = 65152;
  else
    v45 = LODWORD(v20) + 128;
  v46 = HIDWORD(v20) + 128;
  if (HIDWORD(v20) >> 7 >= 0x1FD)
    v46 = 65152;
  if (v12 >> 7 >= 0x1FD)
    v47 = 65152;
  else
    v47 = v12 + 128;
  return ((a4 + a2 - v35) << 24) | ((v36 + ((unsigned __int16)(v45 + (v45 >> 8)) >> 8)) << 16) | (v46 + (v46 >> 8) + (v34 << 8)) & 0xFF00 | (v33 + ((unsigned __int16)(v47 + (v47 >> 8)) >> 8));
}

uint64_t PDAtranspose_luminosityPDA_13365(unsigned __int8 a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  uint32x2_t v5;
  uint32x2_t v6;
  int32x2_t v7;
  unsigned int v8;
  int32x2_t v9;
  int32x2_t v10;
  unsigned int v11;
  int32x2_t v12;
  uint32x2_t v13;
  int32x2_t v14;
  uint32x2_t v15;
  signed int v16;
  int32x2_t v17;
  signed __int32 v18;
  int v19;
  __int32 v20;
  int v21;
  BOOL v22;
  int v23;
  signed int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  uint32x2_t v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;

  v4 = a3;
  v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  v6 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  if (a3 >= a4)
    v4 = a4;
  v7 = vdup_n_s32(a4);
  if (a1 >= a2)
    v8 = a2;
  else
    v8 = a1;
  v9 = vdup_n_s32(a2);
  v10 = (int32x2_t)vmin_u32(v5, (uint32x2_t)v9);
  if (a4 == 255)
  {
    v11 = 0;
    v12 = 0;
  }
  else
  {
    v11 = (a4 ^ 0xFF) * v8;
    v8 = (v8 * a4 + 128 + ((v8 * a4 + 128) >> 8)) >> 8;
    v12 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v10);
    v13 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v10, v7);
    v10 = (int32x2_t)vshr_n_u32(vsra_n_u32(v13, v13, 8uLL), 8uLL);
  }
  v14 = (int32x2_t)vmin_u32(v6, (uint32x2_t)v7);
  if (a2 != 255)
  {
    v11 += v4 * (a2 ^ 0xFF);
    v4 = (v4 * a2 + 128 + ((v4 * a2 + 128) >> 8)) >> 8;
    v12 = vmla_s32(v12, v14, vdup_n_s32(a2 ^ 0xFF));
    v15 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v14, v9);
    v14 = (int32x2_t)vshr_n_u32(vsra_n_u32(v15, v15, 8uLL), 8uLL);
  }
  v16 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v17 = vmul_s32(vsub_s32(v14, v10), (int32x2_t)0x1C00000097);
  v18 = vadd_s32(v17, vdup_lane_s32(v17, 1)).u32[0] + 77 * (v4 - v8);
  v19 = v8 + ((v18 + 128) >> 8);
  v20 = v10.i32[0] + ((v18 + 128) >> 8);
  v21 = v10.i32[1] + ((v18 + 128) >> 8);
  if (v18 != (char)v18)
  {
    v22 = v8 >= v10.i32[0];
    if (v8 >= v10.i32[0])
      v23 = v10.i32[0] + ((v18 + 128) >> 8);
    else
      v23 = v8 + ((v18 + 128) >> 8);
    if (v22)
      v24 = v19;
    else
      v24 = v10.i32[0] + ((v18 + 128) >> 8);
    if (v21 <= v24)
      v25 = v24;
    else
      v25 = v10.i32[1] + ((v18 + 128) >> 8);
    if (v21 >= v23)
      v26 = v23;
    else
      v26 = v10.i32[1] + ((v18 + 128) >> 8);
    if (v21 >= v23)
      v24 = v25;
    if (v24 > v16 || v26 < 0)
    {
      v27 = (77 * v19 + 151 * v20 + 28 * v21 + 128) >> 8;
      if (v18 > -129)
      {
        v28 = v24 - v27;
        if (v24 == v27)
          goto LABEL_34;
        v29 = v16 - v27;
      }
      else
      {
        v28 = v27 - v26;
        if (v27 == v26)
          goto LABEL_34;
        v29 = (77 * v19 + 151 * v20 + 28 * v21 + 128) >> 8;
      }
      v30 = (v29 << 16) / v28;
      v19 = v27 + ((v30 * (v19 - v27) + 0x8000) >> 16);
      v20 = v27 + ((v30 * (v20 - v27) + 0x8000) >> 16);
      v21 = v27 + ((v30 * (v21 - v27) + 0x8000) >> 16);
    }
  }
LABEL_34:
  v31 = a4 + a2 - v16;
  v32 = vcgt_u32((uint32x2_t)vdup_n_s32(0xFE80u), (uint32x2_t)v12);
  v33 = v12.i32[1] + 128;
  if ((v32.i8[4] & 1) == 0)
    v33 = 65152;
  v34 = v21 + ((v33 + (v33 >> 8)) >> 8);
  v35 = v12.i32[0] + 128;
  if ((v32.i8[0] & 1) == 0)
    v35 = 65152;
  v36 = v35 + (v35 >> 8);
  if (v11 >> 7 >= 0x1FD)
    v37 = 65152;
  else
    v37 = v11 + 128;
  return (v31 << 24) | (v34 << 16) | ((_WORD)v36 + ((_WORD)v20 << 8)) & 0xFF00 | (v19 + ((unsigned __int16)(v37 + (v37 >> 8)) >> 8));
}

void argb32_mark_image_W8(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int *v15;
  int v16;
  void *v17;
  void *v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;

  v10 = a2;
  v12 = *(int *)(a1 + 28);
  v13 = *(_DWORD *)(a1 + 4);
  v14 = *(unsigned int *)(a1 + 8);
  v21 = *(_DWORD *)(a1 + 8);
  v22 = v13;
  v15 = *(int **)(a1 + 136);
  if (v15)
  {
    v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    v18 = v17;
    if (v17)
      goto LABEL_5;
  }
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v23 = 0;
  while (1)
  {
    CGSConvertW8toRGBA8888((char *)(*(_QWORD *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18)
      break;
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    v20 = v23;
    v19 = HIDWORD(v23);
    v14 = v21;
    v13 = v22;
  }
}

unint64_t argb32_image_mark_W8(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unsigned int v26;
  char v27;
  unsigned __int8 *v28;
  unsigned int v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned __int8 *v38;
  int v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int8 *v45;
  unsigned int v46;
  char v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unsigned __int8 *v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned __int8 *v58;
  int v59;
  int v60;
  unsigned int v61;
  unsigned __int8 *v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 *v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  unsigned __int8 *v74;
  int v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  int v91;
  uint64_t *v92;
  unint64_t v93;

  v7 = *((unsigned __int8 *)a2 + 8);
  v89 = *a2;
  v8 = (unsigned int *)*((_QWORD *)a2 + 2);
  v88 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 15);
  v9 = *((_QWORD *)a2 + 16);
  v11 = *((_QWORD *)a2 + 7);
  v85 = *((_QWORD *)a2 + 9);
  v12 = *((_QWORD *)a2 + 5) + v85 * a4;
  v13 = *(unsigned __int8 **)(result + 32);
  v14 = &v13[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  v93 = result;
  v86 = v11;
  v87 = v10;
  if (*(_QWORD *)(result + 176))
  {
    v83 = *((_QWORD *)a2 + 11);
    v81 = ~(-1 << v11);
    v82 = *((_QWORD *)a2 + 13);
    v80 = v11 - 4;
    v15 = v14 - 4;
    v78 = a5;
    v79 = -v10;
    v77 = v9 + 16 * a3 + 8;
    while (1)
    {
      if (((v82 - v12) | (v12 - v83)) < 0)
      {
        v18 = 0;
        v17 = 0;
      }
      else
      {
        v16 = ((v12 & (unint64_t)v81) >> v80) & 0xF;
        v17 = (unint64_t)(v16 - 7) >= 9 ? v79 : v10;
        v18 = weights_19497[v16] & 0xF;
      }
      v19 = *(_QWORD *)(v93 + 32) + (v12 >> v11) * v10;
      v91 = a6;
      v90 = v12;
      if (v89 != 1)
        break;
      if (a5 >= 1)
      {
        v20 = (uint64_t *)v77;
        v21 = v78;
        while (1)
        {
          v22 = *(v20 - 1);
          v23 = *v20;
          v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22)
            v25 = (unsigned __int8 *)(v19 + v22);
          else
            v25 = v15;
          if (v25 < v13)
            v25 = v13;
          v26 = *v25;
          v27 = v23 & 0xF;
          if ((v23 & 0xF) != 0)
            break;
          if (v18)
          {
            v38 = (unsigned __int8 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17)
              v38 = v15;
            if (v38 < v13)
              v38 = v13;
            v39 = BLEND8_19499[v18];
            v36 = v26 - ((v39 & v26) >> v18);
            v37 = (v39 & *v38) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          result = v26 | (65792 * v26) | 0xFF000000;
          if (v7 != 255)
            result = PDM_13345(result, v7);
          v20 += 2;
          *v8++ = result;
          if (!--v21)
            goto LABEL_83;
        }
        v28 = (unsigned __int8 *)(v24 + (v23 >> 4));
        if (v15 < v28)
          v28 = v15;
        if (v28 < v13)
          v28 = v13;
        v29 = *v28;
        if (v18)
        {
          v30 = (unsigned __int8 *)(v24 + v17);
          if (v15 >= v30)
            v31 = v30;
          else
            v31 = v15;
          if (v31 < v13)
            v31 = v13;
          v32 = *v31;
          v33 = &v30[v23 >> 4];
          if (v15 < v33)
            v33 = v15;
          if (v33 < v13)
            v33 = v13;
          v34 = BLEND8_19499[v18];
          v26 = v26 - ((v34 & v26) >> v18) + ((v34 & v32) >> v18);
          v29 = v29 - ((v34 & v29) >> v18) + ((v34 & *v33) >> v18);
        }
        v35 = BLEND8_19499[*v20 & 0xF];
        v36 = v26 - ((v35 & v26) >> v27);
        v37 = (v35 & v29) >> v27;
LABEL_40:
        v26 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      v10 = v87;
      v8 += v88;
      LOBYTE(v11) = v86;
      v12 = v90 + v85;
      a6 = v91 - 1;
      if (v91 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_83;
    v41 = (uint64_t *)v77;
    v40 = v78;
    while (1)
    {
      v42 = *(v41 - 1);
      v43 = *v41;
      v44 = v19 + v42;
      if ((unint64_t)v15 >= v19 + v42)
        v45 = (unsigned __int8 *)(v19 + v42);
      else
        v45 = v15;
      if (v45 < v13)
        v45 = v13;
      v46 = *v45;
      v47 = v43 & 0xF;
      if ((v43 & 0xF) != 0)
        break;
      if (v18)
      {
        v58 = (unsigned __int8 *)(v44 + v17);
        if ((unint64_t)v15 < v44 + v17)
          v58 = v15;
        if (v58 < v13)
          v58 = v13;
        v59 = BLEND8_19499[v18];
        v56 = v46 - ((v59 & v46) >> v18);
        v57 = (v59 & *v58) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      v60 = v46 | (65792 * v46);
      v61 = v60 | 0xFF000000;
      if (v7 != 255)
      {
        result = PDM_13345(v60 | 0xFF000000, v7);
        v61 = result;
      }
      if (HIBYTE(v61))
      {
        if (HIBYTE(v61) == 255)
          *v8 = v61;
        else
          result = (unint64_t)DplusDM_13347(v8, v61, *v8, ~v61 >> 24);
      }
      v41 += 2;
      ++v8;
      if (!--v40)
        goto LABEL_83;
    }
    v48 = (unsigned __int8 *)(v44 + (v43 >> 4));
    if (v15 < v48)
      v48 = v15;
    if (v48 < v13)
      v48 = v13;
    v49 = *v48;
    if (v18)
    {
      v50 = (unsigned __int8 *)(v44 + v17);
      if (v15 >= v50)
        v51 = v50;
      else
        v51 = v15;
      if (v51 < v13)
        v51 = v13;
      v52 = *v51;
      v53 = &v50[v43 >> 4];
      if (v15 < v53)
        v53 = v15;
      if (v53 < v13)
        v53 = v13;
      v54 = BLEND8_19499[v18];
      v46 = v46 - ((v54 & v46) >> v18) + ((v54 & v52) >> v18);
      v49 = v49 - ((v54 & v49) >> v18) + ((v54 & *v53) >> v18);
    }
    v55 = BLEND8_19499[*v41 & 0xF];
    v56 = v46 - ((v55 & v46) >> v47);
    v57 = (v55 & v49) >> v47;
LABEL_75:
    v46 = v56 + v57;
    goto LABEL_76;
  }
  v92 = (uint64_t *)(v9 + 16 * a3);
  v62 = v14 - 4;
  v63 = a5;
  do
  {
    v64 = v12;
    v65 = *(unsigned __int8 **)(v93 + 32);
    v66 = &v65[(v12 >> v11) * v10];
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        v67 = v92;
        v68 = v63;
        do
        {
          v69 = *v67;
          v67 += 2;
          v70 = &v66[v69];
          if (v62 < &v66[v69])
            v70 = v62;
          if (v70 < v65)
            v70 = v65;
          result = *v70 | (*v70 << 8) | (*v70 << 16) | 0xFF000000;
          if (v7 != 255)
            result = PDM_13345(result, v7);
          *v8++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      v71 = v92;
      v72 = v63;
      if (a5 >= 1)
      {
        do
        {
          v73 = *v71;
          v71 += 2;
          v74 = &v66[v73];
          if (v62 < &v66[v73])
            v74 = v62;
          if ((unint64_t)v74 < *(_QWORD *)(v93 + 32))
            v74 = *(unsigned __int8 **)(v93 + 32);
          v75 = *v74 | (*v74 << 8) | (*v74 << 16);
          v76 = v75 | 0xFF000000;
          if (v7 != 255)
          {
            result = PDM_13345(v75 | 0xFF000000, v7);
            v76 = result;
          }
          if (HIBYTE(v76))
          {
            if (HIBYTE(v76) == 255)
              *v8 = v76;
            else
              result = (unint64_t)DplusDM_13347(v8, v76, *v8, ~v76 >> 24);
          }
          ++v8;
          --v72;
        }
        while (v72);
      }
    }
    v10 = v87;
    v8 += v88;
    LOBYTE(v11) = v86;
    v12 = v64 + v85;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t argb32_image_mark_RGB24(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 *v24;
  unsigned int v25;
  char v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  int v31;
  unsigned __int8 *v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned __int8 *v37;
  unsigned int v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 *v44;
  unsigned int v45;
  char v46;
  unsigned __int8 *v47;
  int v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  int v51;
  unsigned __int8 *v52;
  unsigned int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned __int8 *v57;
  unsigned int v58;
  unsigned int v59;
  unsigned __int8 *v60;
  uint64_t v61;
  unsigned __int8 *v62;
  unsigned __int8 *v63;
  int v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int8 *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 *v72;
  int v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  uint64_t *v89;
  unint64_t v90;

  v6 = *((unsigned __int8 *)a2 + 8);
  v86 = *a2;
  v7 = (unsigned int *)*((_QWORD *)a2 + 2);
  v85 = *((_QWORD *)a2 + 3) - a5;
  v9 = *((_QWORD *)a2 + 15);
  v8 = *((_QWORD *)a2 + 16);
  v10 = *((_QWORD *)a2 + 7);
  v82 = *((_QWORD *)a2 + 9);
  v11 = *((_QWORD *)a2 + 5) + v82 * a4;
  v12 = *(unsigned __int8 **)(result + 32);
  v13 = &v12[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  v90 = result;
  v87 = a5;
  v83 = v10;
  v84 = v9;
  if (*(_QWORD *)(result + 176))
  {
    v81 = *((_QWORD *)a2 + 11);
    v79 = ~(-1 << v10);
    v80 = *((_QWORD *)a2 + 13);
    v78 = v10 - 4;
    v14 = v13 - 3;
    v76 = a5;
    v77 = -v9;
    v75 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v80 - v11) | (v11 - v81)) < 0)
      {
        v17 = 0;
        v16 = 0;
      }
      else
      {
        v15 = ((v11 & (unint64_t)v79) >> v78) & 0xF;
        v16 = (unint64_t)(v15 - 7) >= 9 ? v77 : v9;
        v17 = weights_19497[v15] & 0xF;
      }
      v18 = *(_QWORD *)(v90 + 32) + (v11 >> v10) * v9;
      v88 = a6;
      if (v86 != 1)
        break;
      if (a5 >= 1)
      {
        v19 = (uint64_t *)v75;
        v20 = v76;
        while (1)
        {
          v21 = *(v19 - 1);
          v22 = *v19;
          v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21)
            v24 = (unsigned __int8 *)(v18 + v21);
          else
            v24 = v14;
          if (v24 < v12)
            v24 = v12;
          v25 = (*v24 << 24) | (v24[1] << 16) | (v24[2] << 8);
          v26 = v22 & 0xF;
          if ((v22 & 0xF) != 0)
            break;
          if (v17)
          {
            v37 = (unsigned __int8 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16)
              v37 = v14;
            if (v37 < v12)
              v37 = v12;
            v38 = BLEND8_19499[v17];
            v35 = v25 - ((v38 & v25) >> v17);
            v36 = (((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          result = (v25 >> 8) | 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v19 += 2;
          *v7++ = result;
          if (!--v20)
            goto LABEL_83;
        }
        v27 = (unsigned __int8 *)(v23 + (v22 >> 4));
        if (v14 < v27)
          v27 = v14;
        if (v27 < v12)
          v27 = v12;
        v28 = (*v27 << 24) | (v27[1] << 16) | (v27[2] << 8);
        if (v17)
        {
          v29 = (unsigned __int8 *)(v23 + v16);
          if (v14 >= v29)
            v30 = v29;
          else
            v30 = v14;
          if (v30 < v12)
            v30 = v12;
          v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
          v32 = &v29[v22 >> 4];
          if (v14 < v32)
            v32 = v14;
          if (v32 < v12)
            v32 = v12;
          v33 = BLEND8_19499[v17];
          v25 = v25 - ((v33 & v25) >> v17) + ((v33 & v31) >> v17);
          v28 = v28 - ((v33 & v28) >> v17) + ((((*v32 << 24) | (v32[1] << 16) | (v32[2] << 8)) & v33) >> v17);
        }
        v34 = BLEND8_19499[*v19 & 0xF];
        v35 = v25 - ((v34 & v25) >> v26);
        v36 = (v34 & v28) >> v26;
LABEL_40:
        v25 = v35 + v36;
        goto LABEL_41;
      }
LABEL_83:
      v9 = v84;
      v7 += v85;
      LOBYTE(v10) = v83;
      v11 += v82;
      a6 = v88 - 1;
      a5 = v87;
      if (v88 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_83;
    v39 = (uint64_t *)v75;
    v40 = v76;
    while (1)
    {
      v41 = *(v39 - 1);
      v42 = *v39;
      v43 = v18 + v41;
      if ((unint64_t)v14 >= v18 + v41)
        v44 = (unsigned __int8 *)(v18 + v41);
      else
        v44 = v14;
      if (v44 < v12)
        v44 = v12;
      v45 = (*v44 << 24) | (v44[1] << 16) | (v44[2] << 8);
      v46 = v42 & 0xF;
      if ((v42 & 0xF) != 0)
        break;
      if (v17)
      {
        v57 = (unsigned __int8 *)(v43 + v16);
        if ((unint64_t)v14 < v43 + v16)
          v57 = v14;
        if (v57 < v12)
          v57 = v12;
        v58 = BLEND8_19499[v17];
        v55 = v45 - ((v58 & v45) >> v17);
        v56 = (((*v57 << 24) | (v57[1] << 16) | (v57[2] << 8)) & v58) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      v59 = (v45 >> 8) | 0xFF000000;
      if (v6 != 255)
      {
        result = PDM_13345((v45 >> 8) | 0xFF000000, v6);
        v59 = result;
      }
      if (HIBYTE(v59))
      {
        if (HIBYTE(v59) == 255)
          *v7 = v59;
        else
          result = (unint64_t)DplusDM_13347(v7, v59, *v7, ~v59 >> 24);
      }
      v39 += 2;
      ++v7;
      if (!--v40)
        goto LABEL_83;
    }
    v47 = (unsigned __int8 *)(v43 + (v42 >> 4));
    if (v14 < v47)
      v47 = v14;
    if (v47 < v12)
      v47 = v12;
    v48 = (*v47 << 24) | (v47[1] << 16) | (v47[2] << 8);
    if (v17)
    {
      v49 = (unsigned __int8 *)(v43 + v16);
      if (v14 >= v49)
        v50 = v49;
      else
        v50 = v14;
      if (v50 < v12)
        v50 = v12;
      v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      v52 = &v49[v42 >> 4];
      if (v14 < v52)
        v52 = v14;
      if (v52 < v12)
        v52 = v12;
      v53 = BLEND8_19499[v17];
      v45 = v45 - ((v53 & v45) >> v17) + ((v53 & v51) >> v17);
      v48 = v48 - ((v53 & v48) >> v17) + ((((*v52 << 24) | (v52[1] << 16) | (v52[2] << 8)) & v53) >> v17);
    }
    v54 = BLEND8_19499[*v39 & 0xF];
    v55 = v45 - ((v54 & v45) >> v46);
    v56 = (v54 & v48) >> v46;
LABEL_75:
    v45 = v55 + v56;
    goto LABEL_76;
  }
  v89 = (uint64_t *)(v8 + 16 * a3);
  v60 = v13 - 3;
  v61 = a5;
  do
  {
    v62 = *(unsigned __int8 **)(v90 + 32);
    v63 = &v62[(v11 >> v10) * v9];
    v64 = a6;
    if (v86 == 1)
    {
      if (a5 >= 1)
      {
        v65 = v89;
        v66 = v61;
        do
        {
          v67 = *v65;
          v65 += 2;
          v68 = &v63[v67];
          if (v60 < &v63[v67])
            v68 = v60;
          if (v68 < v62)
            v68 = v62;
          result = (*v68 << 16) | (v68[1] << 8) | v68[2] | 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          *v7++ = result;
          --v66;
        }
        while (v66);
      }
    }
    else
    {
      v69 = v89;
      v70 = v61;
      if (a5 >= 1)
      {
        do
        {
          v71 = *v69;
          v69 += 2;
          v72 = &v63[v71];
          if (v60 < &v63[v71])
            v72 = v60;
          if ((unint64_t)v72 < *(_QWORD *)(v90 + 32))
            v72 = *(unsigned __int8 **)(v90 + 32);
          v73 = (*v72 << 16) | (v72[1] << 8) | v72[2];
          v74 = v73 | 0xFF000000;
          if (v6 != 255)
          {
            result = PDM_13345(v73 | 0xFF000000, v6);
            v74 = result;
          }
          if (HIBYTE(v74))
          {
            if (HIBYTE(v74) == 255)
              *v7 = v74;
            else
              result = (unint64_t)DplusDM_13347(v7, v74, *v7, ~v74 >> 24);
          }
          ++v7;
          --v70;
        }
        while (v70);
      }
    }
    v9 = v84;
    v7 += v85;
    LOBYTE(v10) = v83;
    v11 += v82;
    a6 = v64 - 1;
    a5 = v87;
  }
  while (v64 != 1);
  return result;
}

unint64_t argb32_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  int v7;
  unsigned int *v8;
  int v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  unsigned int *v16;
  uint64_t v17;
  char v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  char v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int *v41;
  int v42;
  unint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  char v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int *v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int *v62;
  int v63;
  int v64;
  unint64_t v65;
  unsigned int v66;
  unsigned int *v67;
  unsigned int *v68;
  char *v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  unsigned int *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  unsigned int *v78;
  int v79;
  unint64_t v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;

  v6 = *((unsigned __int8 *)a2 + 8);
  v7 = a2[1];
  v93 = *a2;
  v8 = *(unsigned int **)(result + 32);
  if (*(_QWORD *)(result + 40))
    v9 = 0;
  else
    v9 = 255;
  v10 = (unsigned int *)*((_QWORD *)a2 + 2);
  v92 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 15);
  v11 = *((_QWORD *)a2 + 16);
  v13 = *((_QWORD *)a2 + 7);
  v89 = *((_QWORD *)a2 + 9);
  v14 = *((_QWORD *)a2 + 5) + v89 * a4;
  v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v99 = result;
  v94 = a5;
  v90 = v13;
  v91 = v12;
  if (*(_QWORD *)(result + 176))
  {
    v86 = ~(-1 << v13);
    v87 = *((_QWORD *)a2 + 13);
    v88 = *((_QWORD *)a2 + 11);
    v85 = v13 - 4;
    v84 = -v12;
    v16 = (unsigned int *)(v15 - 4);
    v82 = v11 + 16 * a3 + 8;
    v83 = a5;
    while (1)
    {
      if (((v87 - v14) | (v14 - v88)) < 0)
      {
        v21 = 0;
        v100 = 0;
      }
      else
      {
        v17 = ((v14 & (unint64_t)v86) >> v85) & 0xF;
        v18 = weights_19497[v17];
        v19 = (unint64_t)(v17 - 7) >= 9;
        v20 = v84;
        if (!v19)
          v20 = v12;
        v100 = v20;
        v21 = v18 & 0xF;
      }
      v22 = *(_QWORD *)(v99 + 32) + (v14 >> v13) * v12;
      v97 = a6;
      v95 = v14;
      if (v93 != 1)
        break;
      if (a5 >= 1)
      {
        v24 = (uint64_t *)v82;
        v23 = v83;
        while (1)
        {
          v25 = *(v24 - 1);
          v26 = *v24;
          v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25)
            v28 = (unsigned int *)(v22 + v25);
          else
            v28 = v16;
          if (v28 < v8)
            v28 = v8;
          v29 = bswap32(*v28);
          v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0)
            break;
          if (v21)
          {
            v41 = (unsigned int *)(v27 + v100);
            if ((unint64_t)v16 < v27 + v100)
              v41 = v16;
            if (v41 < v8)
              v41 = v8;
            v42 = BLEND8_19499[v21];
            v39 = v29 - ((v42 & v29) >> v21);
            v40 = (bswap32(*v41) & v42) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          HIDWORD(v43) = __ROL4__(v29, v7);
          LODWORD(v43) = HIDWORD(v43);
          result = (v43 >> 8) | (v9 << 24);
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v24 += 2;
          *v10++ = result;
          if (!--v23)
            goto LABEL_85;
        }
        v31 = (unsigned int *)(v27 + (v26 >> 4));
        if (v16 < v31)
          v31 = v16;
        if (v31 < v8)
          v31 = v8;
        v32 = bswap32(*v31);
        if (v21)
        {
          v33 = (unsigned int *)(v27 + v100);
          if (v16 >= v33)
            v34 = v33;
          else
            v34 = v16;
          if (v34 < v8)
            v34 = v8;
          v35 = bswap32(*v34);
          v36 = (unsigned int *)((char *)v33 + (v26 >> 4));
          if (v16 < v36)
            v36 = v16;
          if (v36 < v8)
            v36 = v8;
          v37 = BLEND8_19499[v21];
          v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
          v32 = v32 - ((v37 & v32) >> v21) + ((bswap32(*v36) & v37) >> v21);
        }
        v38 = BLEND8_19499[*v24 & 0xF];
        v39 = v29 - ((v38 & v29) >> v30);
        v40 = (v38 & v32) >> v30;
LABEL_42:
        v29 = v39 + v40;
        goto LABEL_43;
      }
LABEL_85:
      v12 = v91;
      v10 += v92;
      LOBYTE(v13) = v90;
      v14 = v95 + v89;
      a6 = v97 - 1;
      a5 = v94;
      if (v97 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_85;
    v44 = (uint64_t *)v82;
    v45 = v83;
    while (1)
    {
      v46 = *(v44 - 1);
      v47 = *v44;
      v48 = v22 + v46;
      if ((unint64_t)v16 >= v22 + v46)
        v49 = (unsigned int *)(v22 + v46);
      else
        v49 = v16;
      if (v49 < v8)
        v49 = v8;
      v50 = bswap32(*v49);
      v51 = v47 & 0xF;
      if ((v47 & 0xF) != 0)
        break;
      if (v21)
      {
        v62 = (unsigned int *)(v48 + v100);
        if ((unint64_t)v16 < v48 + v100)
          v62 = v16;
        if (v62 < v8)
          v62 = v8;
        v63 = BLEND8_19499[v21];
        v60 = v50 - ((v63 & v50) >> v21);
        v61 = (bswap32(*v62) & v63) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      HIDWORD(v65) = __ROL4__(v50, v7);
      LODWORD(v65) = HIDWORD(v65);
      v64 = v65 >> 8;
      v66 = v64 | (v9 << 24);
      if (v6 != 255)
      {
        result = PDM_13345(v64 | (v9 << 24), v6);
        v66 = result;
      }
      if (HIBYTE(v66))
      {
        if (HIBYTE(v66) == 255)
          *v10 = v66;
        else
          result = (unint64_t)DplusDM_13347(v10, v66, *v10, ~v66 >> 24);
      }
      v44 += 2;
      ++v10;
      if (!--v45)
        goto LABEL_85;
    }
    v52 = (unsigned int *)(v48 + (v47 >> 4));
    if (v16 < v52)
      v52 = v16;
    if (v52 < v8)
      v52 = v8;
    v53 = bswap32(*v52);
    if (v21)
    {
      v54 = (unsigned int *)(v48 + v100);
      if (v16 >= v54)
        v55 = v54;
      else
        v55 = v16;
      if (v55 < v8)
        v55 = v8;
      v56 = bswap32(*v55);
      v57 = (unsigned int *)((char *)v54 + (v47 >> 4));
      if (v16 < v57)
        v57 = v16;
      if (v57 < v8)
        v57 = v8;
      v58 = BLEND8_19499[v21];
      v50 = v50 - ((v58 & v50) >> v21) + ((v58 & v56) >> v21);
      v53 = v53 - ((v58 & v53) >> v21) + ((bswap32(*v57) & v58) >> v21);
    }
    v59 = BLEND8_19499[*v44 & 0xF];
    v60 = v50 - ((v59 & v50) >> v51);
    v61 = (v59 & v53) >> v51;
LABEL_77:
    v50 = v60 + v61;
    goto LABEL_78;
  }
  v67 = (unsigned int *)(v15 - 4);
  v101 = a5;
  v102 = (uint64_t *)(v11 + 16 * a3);
  do
  {
    v68 = *(unsigned int **)(v99 + 32);
    v69 = (char *)v68 + (v14 >> v13) * v12;
    v98 = a6;
    v96 = v14;
    if (v93 == 1)
    {
      if (a5 >= 1)
      {
        v70 = v101;
        v71 = v102;
        do
        {
          v72 = *v71;
          v71 += 2;
          v73 = (unsigned int *)&v69[v72];
          if (v67 < (unsigned int *)&v69[v72])
            v73 = v67;
          if (v73 < v68)
            v73 = v68;
          HIDWORD(v74) = __ROL4__(bswap32(*v73), v7);
          LODWORD(v74) = HIDWORD(v74);
          result = (v74 >> 8) | (v9 << 24);
          if (v6 != 255)
            result = PDM_13345(result, v6);
          *v10++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      v75 = v101;
      v76 = v102;
      if (a5 >= 1)
      {
        do
        {
          v77 = *v76;
          v76 += 2;
          v78 = (unsigned int *)&v69[v77];
          if (v67 < (unsigned int *)&v69[v77])
            v78 = v67;
          if ((unint64_t)v78 < *(_QWORD *)(v99 + 32))
            v78 = *(unsigned int **)(v99 + 32);
          HIDWORD(v80) = __ROL4__(bswap32(*v78), v7);
          LODWORD(v80) = HIDWORD(v80);
          v79 = v80 >> 8;
          v81 = v79 | (v9 << 24);
          if (v6 != 255)
          {
            result = PDM_13345(v79 | (v9 << 24), v6);
            v81 = result;
          }
          if (HIBYTE(v81))
          {
            if (HIBYTE(v81) == 255)
              *v10 = v81;
            else
              result = (unint64_t)DplusDM_13347(v10, v81, *v10, ~v81 >> 24);
          }
          ++v10;
          --v75;
        }
        while (v75);
      }
    }
    v12 = v91;
    v10 += v92;
    LOBYTE(v13) = v90;
    v14 = v96 + v89;
    a6 = v98 - 1;
    a5 = v94;
  }
  while (v98 != 1);
  return result;
}

void argb32_mark_image_rgbx32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  uint64_t v13;
  int v14;
  int v15;
  int *v16;
  int v17;
  void *v18;
  void *v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  char *v24;
  int v25;
  unsigned int v26;
  int v27;
  uint64_t i;

  v11 = a2;
  v13 = *(int *)(a1 + 28);
  v14 = *(_DWORD *)(a1 + 4);
  v15 = *(_DWORD *)(a1 + 8);
  v26 = v15;
  v27 = v14;
  v16 = *(int **)(a1 + 136);
  if (v16)
  {
    v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    v19 = v18;
    if (v18)
      goto LABEL_9;
  }
  v20 = 0;
  v21 = 0;
  v19 = 0;
  for (i = 0; ; v20 = HIDWORD(i))
  {
    v22 = *(_DWORD *)(a1 + 76);
    v23 = (char *)(*(_QWORD *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    v24 = (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toRGBA8888(v23, v25, v24, v13, v27, v26, 0x1Bu, *(_QWORD *)(a1 + 48) != 0);
      if (!v19)
        return;
    }
    else if (*(_QWORD *)(a1 + 96))
    {
      CGSConvertARGB8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19)
        return;
    }
    else
    {
      CGSConvertXRGB8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19)
        return;
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26))
      break;
    v21 = i;
  }
  free(v19);
}

unint64_t argb32_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  int v7;
  unsigned int *v8;
  int v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  unsigned int *v16;
  uint64_t v17;
  char v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  char v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int *v41;
  int v42;
  unint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  char v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int *v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int *v62;
  int v63;
  int v64;
  unint64_t v65;
  unsigned int v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  char *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  char *v78;
  int v79;
  unint64_t v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;

  v6 = *((unsigned __int8 *)a2 + 8);
  v7 = a2[1];
  v93 = *a2;
  v8 = *(unsigned int **)(result + 32);
  if (*(_QWORD *)(result + 40))
    v9 = 0;
  else
    v9 = 255;
  v10 = (unsigned int *)*((_QWORD *)a2 + 2);
  v92 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 15);
  v11 = *((_QWORD *)a2 + 16);
  v13 = *((_QWORD *)a2 + 7);
  v89 = *((_QWORD *)a2 + 9);
  v14 = *((_QWORD *)a2 + 5) + v89 * a4;
  v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v99 = result;
  v94 = a5;
  v90 = v13;
  v91 = v12;
  if (*(_QWORD *)(result + 176))
  {
    v86 = ~(-1 << v13);
    v87 = *((_QWORD *)a2 + 13);
    v88 = *((_QWORD *)a2 + 11);
    v85 = v13 - 4;
    v84 = -v12;
    v16 = (unsigned int *)(v15 - 4);
    v82 = v11 + 16 * a3 + 8;
    v83 = a5;
    while (1)
    {
      if (((v87 - v14) | (v14 - v88)) < 0)
      {
        v21 = 0;
        v100 = 0;
      }
      else
      {
        v17 = ((v14 & (unint64_t)v86) >> v85) & 0xF;
        v18 = weights_19497[v17];
        v19 = (unint64_t)(v17 - 7) >= 9;
        v20 = v84;
        if (!v19)
          v20 = v12;
        v100 = v20;
        v21 = v18 & 0xF;
      }
      v22 = *(_QWORD *)(v99 + 32) + (v14 >> v13) * v12;
      v97 = a6;
      v95 = v14;
      if (v93 != 1)
        break;
      if (a5 >= 1)
      {
        v24 = (uint64_t *)v82;
        v23 = v83;
        while (1)
        {
          v25 = *(v24 - 1);
          v26 = *v24;
          v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25)
            v28 = (unsigned int *)(v22 + v25);
          else
            v28 = v16;
          if (v28 < v8)
            v28 = v8;
          v29 = *v28;
          v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0)
            break;
          if (v21)
          {
            v41 = (unsigned int *)(v27 + v100);
            if ((unint64_t)v16 < v27 + v100)
              v41 = v16;
            if (v41 < v8)
              v41 = v8;
            v42 = BLEND8_19499[v21];
            v39 = v29 - ((v42 & v29) >> v21);
            v40 = (v42 & *v41) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          HIDWORD(v43) = __ROL4__(v29, v7);
          LODWORD(v43) = HIDWORD(v43);
          result = (v43 >> 8) | (v9 << 24);
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v24 += 2;
          *v10++ = result;
          if (!--v23)
            goto LABEL_85;
        }
        v31 = (unsigned int *)(v27 + (v26 >> 4));
        if (v16 < v31)
          v31 = v16;
        if (v31 < v8)
          v31 = v8;
        v32 = *v31;
        if (v21)
        {
          v33 = (unsigned int *)(v27 + v100);
          if (v16 >= v33)
            v34 = v33;
          else
            v34 = v16;
          if (v34 < v8)
            v34 = v8;
          v35 = *v34;
          v36 = (unsigned int *)((char *)v33 + (v26 >> 4));
          if (v16 < v36)
            v36 = v16;
          if (v36 < v8)
            v36 = v8;
          v37 = BLEND8_19499[v21];
          v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
          v32 = v32 - ((v37 & v32) >> v21) + ((v37 & *v36) >> v21);
        }
        v38 = BLEND8_19499[*v24 & 0xF];
        v39 = v29 - ((v38 & v29) >> v30);
        v40 = (v38 & v32) >> v30;
LABEL_42:
        v29 = v39 + v40;
        goto LABEL_43;
      }
LABEL_85:
      v12 = v91;
      v10 += v92;
      LOBYTE(v13) = v90;
      v14 = v95 + v89;
      a6 = v97 - 1;
      a5 = v94;
      if (v97 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_85;
    v44 = (uint64_t *)v82;
    v45 = v83;
    while (1)
    {
      v46 = *(v44 - 1);
      v47 = *v44;
      v48 = v22 + v46;
      if ((unint64_t)v16 >= v22 + v46)
        v49 = (unsigned int *)(v22 + v46);
      else
        v49 = v16;
      if (v49 < v8)
        v49 = v8;
      v50 = *v49;
      v51 = v47 & 0xF;
      if ((v47 & 0xF) != 0)
        break;
      if (v21)
      {
        v62 = (unsigned int *)(v48 + v100);
        if ((unint64_t)v16 < v48 + v100)
          v62 = v16;
        if (v62 < v8)
          v62 = v8;
        v63 = BLEND8_19499[v21];
        v60 = v50 - ((v63 & v50) >> v21);
        v61 = (v63 & *v62) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      HIDWORD(v65) = __ROL4__(v50, v7);
      LODWORD(v65) = HIDWORD(v65);
      v64 = v65 >> 8;
      v66 = v64 | (v9 << 24);
      if (v6 != 255)
      {
        result = PDM_13345(v64 | (v9 << 24), v6);
        v66 = result;
      }
      if (HIBYTE(v66))
      {
        if (HIBYTE(v66) == 255)
          *v10 = v66;
        else
          result = (unint64_t)DplusDM_13347(v10, v66, *v10, ~v66 >> 24);
      }
      v44 += 2;
      ++v10;
      if (!--v45)
        goto LABEL_85;
    }
    v52 = (unsigned int *)(v48 + (v47 >> 4));
    if (v16 < v52)
      v52 = v16;
    if (v52 < v8)
      v52 = v8;
    v53 = *v52;
    if (v21)
    {
      v54 = (unsigned int *)(v48 + v100);
      if (v16 >= v54)
        v55 = v54;
      else
        v55 = v16;
      if (v55 < v8)
        v55 = v8;
      v56 = *v55;
      v57 = (unsigned int *)((char *)v54 + (v47 >> 4));
      if (v16 < v57)
        v57 = v16;
      if (v57 < v8)
        v57 = v8;
      v58 = BLEND8_19499[v21];
      v50 = v50 - ((v58 & v50) >> v21) + ((v58 & v56) >> v21);
      v53 = v53 - ((v58 & v53) >> v21) + ((v58 & *v57) >> v21);
    }
    v59 = BLEND8_19499[*v44 & 0xF];
    v60 = v50 - ((v59 & v50) >> v51);
    v61 = (v59 & v53) >> v51;
LABEL_77:
    v50 = v60 + v61;
    goto LABEL_78;
  }
  v67 = v15 - 4;
  v101 = a5;
  v102 = (uint64_t *)(v11 + 16 * a3);
  do
  {
    v68 = *(char **)(v99 + 32);
    v69 = &v68[(v14 >> v13) * v12];
    v98 = a6;
    v96 = v14;
    if (v93 == 1)
    {
      if (a5 >= 1)
      {
        v70 = v101;
        v71 = v102;
        do
        {
          v72 = *v71;
          v71 += 2;
          v73 = &v69[v72];
          if (v67 < &v69[v72])
            v73 = v67;
          if (v73 < v68)
            v73 = v68;
          HIDWORD(v74) = __ROL4__(*(_DWORD *)v73, v7);
          LODWORD(v74) = HIDWORD(v74);
          result = (v74 >> 8) | (v9 << 24);
          if (v6 != 255)
            result = PDM_13345(result, v6);
          *v10++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      v75 = v101;
      v76 = v102;
      if (a5 >= 1)
      {
        do
        {
          v77 = *v76;
          v76 += 2;
          v78 = &v69[v77];
          if (v67 < &v69[v77])
            v78 = v67;
          if ((unint64_t)v78 < *(_QWORD *)(v99 + 32))
            v78 = *(char **)(v99 + 32);
          HIDWORD(v80) = __ROL4__(*(_DWORD *)v78, v7);
          LODWORD(v80) = HIDWORD(v80);
          v79 = v80 >> 8;
          v81 = v79 | (v9 << 24);
          if (v6 != 255)
          {
            result = PDM_13345(v79 | (v9 << 24), v6);
            v81 = result;
          }
          if (HIBYTE(v81))
          {
            if (HIBYTE(v81) == 255)
              *v10 = v81;
            else
              result = (unint64_t)DplusDM_13347(v10, v81, *v10, ~v81 >> 24);
          }
          ++v10;
          --v75;
        }
        while (v75);
      }
    }
    v12 = v91;
    v10 += v92;
    LOBYTE(v13) = v90;
    v14 = v96 + v89;
    a6 = v98 - 1;
    a5 = v94;
  }
  while (v98 != 1);
  return result;
}

void argb32_mark_image_xrgb32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  uint64_t v13;
  int v14;
  int v15;
  int *v16;
  int v17;
  void *v18;
  void *v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  char *v24;
  unsigned int v25;
  int v26;
  uint64_t i;

  v11 = a2;
  v13 = *(int *)(a1 + 28);
  v14 = *(_DWORD *)(a1 + 4);
  v15 = *(_DWORD *)(a1 + 8);
  v25 = v15;
  v26 = v14;
  v16 = *(int **)(a1 + 136);
  if (v16)
  {
    v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    v19 = v18;
    if (v18)
      goto LABEL_9;
  }
  v20 = 0;
  v21 = 0;
  v19 = 0;
  for (i = 0; ; v20 = HIDWORD(i))
  {
    v22 = *(_DWORD *)(a1 + 76);
    v23 = (char *)(*(_QWORD *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    v24 = (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    if (v11 == 2)
    {
      CGSBlend8888toRGBA8888(v23, v22 * a5, v24, v13, v26, v25, 0xC6u, *(_QWORD *)(a1 + 48) != 0);
      if (!v19)
        return;
    }
    else if (*(_QWORD *)(a1 + 96))
    {
      CGBlt_copyBytes(4 * v26, v25, v23, v24, v22 * a5, v13);
      if (!v19)
        return;
    }
    else
    {
      CGSConvertRGBX8888toRGBA8888(v23, v22 * a5, v24, v13, v26, v25, a7, a8);
      if (!v19)
        return;
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v26, &v25))
      break;
    v21 = i;
  }
  free(v19);
}

void argb32_mark_image_W16(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int *v15;
  int v16;
  void *v17;
  void *v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;

  v10 = a2;
  v12 = *(int *)(a1 + 28);
  v13 = *(_DWORD *)(a1 + 4);
  v14 = *(unsigned int *)(a1 + 8);
  v21 = *(_DWORD *)(a1 + 8);
  v22 = v13;
  v15 = *(int **)(a1 + 136);
  if (v15)
  {
    v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    v18 = v17;
    if (v17)
      goto LABEL_5;
  }
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v23 = 0;
  while (1)
  {
    CGSConvertW16toRGBA8888(*(_QWORD *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + 2 * (v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18)
      break;
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    v20 = v23;
    v19 = HIDWORD(v23);
    v14 = v21;
    v13 = v22;
  }
}

unint64_t argb32_image_mark_W16(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  char *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  unint64_t v33;
  unsigned __int16 *v34;
  uint64_t v35;
  uint64_t v36;
  __int16 v37;
  unint64_t v38;
  unsigned __int16 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int16 *v50;
  unint64_t v51;
  unsigned __int16 *v52;
  unsigned __int16 *v53;
  unint64_t v54;
  unsigned __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  __int16 v58;
  unint64_t v59;
  unsigned __int16 *v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  unsigned int v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  unsigned int v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v88;
  char v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  uint64_t *v95;
  unint64_t v96;

  v7 = *((unsigned __int8 *)a2 + 8);
  v92 = *a2;
  v8 = (unsigned int *)*((_QWORD *)a2 + 2);
  v91 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 15);
  v9 = *((_QWORD *)a2 + 16);
  v11 = *((_QWORD *)a2 + 7);
  v88 = *((_QWORD *)a2 + 9);
  v12 = *((_QWORD *)a2 + 5) + v88 * a4;
  v13 = *(unsigned __int16 **)(result + 32);
  v14 = (char *)v13
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v96 = result;
  v89 = v11;
  v90 = v10;
  if (*(_QWORD *)(result + 176))
  {
    v86 = *((_QWORD *)a2 + 11);
    v84 = ~(-1 << v11);
    v85 = *((_QWORD *)a2 + 13);
    v83 = v11 - 4;
    v15 = (unsigned __int16 *)(v14 - 4);
    v81 = a5;
    v82 = -v10;
    v80 = v9 + 16 * a3 + 8;
    while (1)
    {
      if (((v85 - v12) | (v12 - v86)) < 0)
      {
        v18 = 0;
        v17 = 0;
      }
      else
      {
        v16 = ((v12 & (unint64_t)v84) >> v83) & 0xF;
        v17 = (unint64_t)(v16 - 7) >= 9 ? v82 : v10;
        v18 = weights_19497[v16] & 0xF;
      }
      v19 = *(_QWORD *)(v96 + 32) + (v12 >> v11) * v10;
      v94 = a6;
      v93 = v12;
      if (v92 != 1)
        break;
      if (a5 >= 1)
      {
        v20 = (uint64_t *)v80;
        v21 = v81;
        while (1)
        {
          v22 = *(v20 - 1);
          v23 = *v20;
          v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22)
            v25 = (unsigned __int16 *)(v19 + v22);
          else
            v25 = v15;
          if (v25 < v13)
            v25 = v13;
          v26 = bswap32(*v25) >> 16;
          v27 = *v20 & 0xF;
          if ((v23 & 0xF) != 0)
            break;
          if (v18)
          {
            v39 = (unsigned __int16 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17)
              v39 = v15;
            if (v39 < v13)
              v39 = v13;
            v40 = BLEND16_19498[v18];
            v37 = v26 - ((v40 & v26) >> v18);
            v38 = (v40 & (unint64_t)(bswap32(*v39) >> 16)) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          result = (65793 * BYTE1(v26)) | 0xFF000000;
          if (v7 != 255)
            result = PDM_13345(result, v7);
          v20 += 2;
          *v8++ = result;
          if (!--v21)
            goto LABEL_83;
        }
        v28 = v23 >> 4;
        v29 = (unsigned __int16 *)(v24 + (v23 >> 4));
        if (v15 < v29)
          v29 = v15;
        if (v29 < v13)
          v29 = v13;
        v30 = bswap32(*v29) >> 16;
        if (v18)
        {
          v31 = (unsigned __int16 *)(v24 + v17);
          if (v15 >= v31)
            v32 = v31;
          else
            v32 = v15;
          if (v32 < v13)
            v32 = v13;
          v33 = bswap32(*v32) >> 16;
          v34 = (unsigned __int16 *)((char *)v31 + v28);
          if (v15 < v34)
            v34 = v15;
          if (v34 < v13)
            v34 = v13;
          v35 = BLEND16_19498[v18];
          LODWORD(v26) = v26 - ((v35 & v26) >> v18) + ((v35 & v33) >> v18);
          LODWORD(v30) = v30 - ((v35 & v30) >> v18) + ((v35 & (unint64_t)(bswap32(*v34) >> 16)) >> v18);
        }
        v36 = BLEND16_19498[v27];
        v37 = v26 - ((unint64_t)(v36 & v26) >> v27);
        v38 = (unint64_t)(v36 & v30) >> v27;
LABEL_40:
        LOWORD(v26) = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      v10 = v90;
      v8 += v91;
      LOBYTE(v11) = v89;
      v12 = v93 + v88;
      a6 = v94 - 1;
      if (v94 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_83;
    v42 = (uint64_t *)v80;
    v41 = v81;
    while (1)
    {
      v43 = *(v42 - 1);
      v44 = *v42;
      v45 = v19 + v43;
      if ((unint64_t)v15 >= v19 + v43)
        v46 = (unsigned __int16 *)(v19 + v43);
      else
        v46 = v15;
      if (v46 < v13)
        v46 = v13;
      v47 = bswap32(*v46) >> 16;
      v48 = *v42 & 0xF;
      if ((v44 & 0xF) != 0)
        break;
      if (v18)
      {
        v60 = (unsigned __int16 *)(v45 + v17);
        if ((unint64_t)v15 < v45 + v17)
          v60 = v15;
        if (v60 < v13)
          v60 = v13;
        v61 = BLEND16_19498[v18];
        v58 = v47 - ((v61 & v47) >> v18);
        v59 = (v61 & (unint64_t)(bswap32(*v60) >> 16)) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      v62 = 65793 * BYTE1(v47);
      v63 = v62 | 0xFF000000;
      if (v7 != 255)
      {
        result = PDM_13345(v62 | 0xFF000000, v7);
        v63 = result;
      }
      if (HIBYTE(v63))
      {
        if (HIBYTE(v63) == 255)
          *v8 = v63;
        else
          result = (unint64_t)DplusDM_13347(v8, v63, *v8, ~v63 >> 24);
      }
      v42 += 2;
      ++v8;
      if (!--v41)
        goto LABEL_83;
    }
    v49 = v44 >> 4;
    v50 = (unsigned __int16 *)(v45 + (v44 >> 4));
    if (v15 < v50)
      v50 = v15;
    if (v50 < v13)
      v50 = v13;
    v51 = bswap32(*v50) >> 16;
    if (v18)
    {
      v52 = (unsigned __int16 *)(v45 + v17);
      if (v15 >= v52)
        v53 = v52;
      else
        v53 = v15;
      if (v53 < v13)
        v53 = v13;
      v54 = bswap32(*v53) >> 16;
      v55 = (unsigned __int16 *)((char *)v52 + v49);
      if (v15 < v55)
        v55 = v15;
      if (v55 < v13)
        v55 = v13;
      v56 = BLEND16_19498[v18];
      LODWORD(v47) = v47 - ((v56 & v47) >> v18) + ((v56 & v54) >> v18);
      LODWORD(v51) = v51 - ((v56 & v51) >> v18) + ((v56 & (unint64_t)(bswap32(*v55) >> 16)) >> v18);
    }
    v57 = BLEND16_19498[v48];
    v58 = v47 - ((unint64_t)(v57 & v47) >> v48);
    v59 = (unint64_t)(v57 & v51) >> v48;
LABEL_75:
    LOWORD(v47) = v58 + v59;
    goto LABEL_76;
  }
  v95 = (uint64_t *)(v9 + 16 * a3);
  v64 = v14 - 4;
  v65 = a5;
  do
  {
    v66 = v12;
    v67 = *(char **)(v96 + 32);
    v68 = &v67[(v12 >> v11) * v10];
    if (v92 == 1)
    {
      if (a5 >= 1)
      {
        v69 = v95;
        v70 = v65;
        do
        {
          v71 = *v69;
          v69 += 2;
          v72 = &v68[v71];
          if (v64 < &v68[v71])
            v72 = v64;
          if (v72 < v67)
            v72 = v67;
          v73 = bswap32(*(unsigned __int16 *)v72);
          result = HIWORD(v73) & 0xFF00 | (HIBYTE(v73) << 16) | HIBYTE(v73) | 0xFF000000;
          if (v7 != 255)
            result = PDM_13345(result, v7);
          *v8++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      v74 = v95;
      v75 = v65;
      if (a5 >= 1)
      {
        do
        {
          v76 = *v74;
          v74 += 2;
          v77 = &v68[v76];
          if (v64 < &v68[v76])
            v77 = v64;
          if ((unint64_t)v77 < *(_QWORD *)(v96 + 32))
            v77 = *(char **)(v96 + 32);
          v78 = bswap32(*(unsigned __int16 *)v77);
          v79 = HIWORD(v78) & 0xFF00 | (HIBYTE(v78) << 16) | HIBYTE(v78) | 0xFF000000;
          if (v7 != 255)
          {
            result = PDM_13345(HIWORD(v78) & 0xFF00 | (HIBYTE(v78) << 16) | HIBYTE(v78) | 0xFF000000, v7);
            v79 = result;
          }
          if (HIBYTE(v79))
          {
            if (HIBYTE(v79) == 255)
              *v8 = v79;
            else
              result = (unint64_t)DplusDM_13347(v8, v79, *v8, ~v79 >> 24);
          }
          ++v8;
          --v75;
        }
        while (v75);
      }
    }
    v10 = v90;
    v8 += v91;
    LOBYTE(v11) = v89;
    v12 = v66 + v88;
    --a6;
  }
  while (a6);
  return result;
}

void argb32_mark_image_w16(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int *v15;
  int v16;
  void *v17;
  void *v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;

  v10 = a2;
  v12 = *(int *)(a1 + 28);
  v13 = *(_DWORD *)(a1 + 4);
  v14 = *(unsigned int *)(a1 + 8);
  v21 = *(_DWORD *)(a1 + 8);
  v22 = v13;
  v15 = *(int **)(a1 + 136);
  if (v15)
  {
    v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    v18 = v17;
    if (v17)
      goto LABEL_5;
  }
  v19 = 0;
  v20 = 0;
  v18 = 0;
  v23 = 0;
  while (1)
  {
    CGSConvertw16toRGBA8888(*(_QWORD *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + 2 * (v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18)
      break;
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    v20 = v23;
    v19 = HIDWORD(v23);
    v14 = v21;
    v13 = v22;
  }
}

unint64_t argb32_image_mark_w16(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  char *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  unint64_t v33;
  unsigned __int16 *v34;
  uint64_t v35;
  uint64_t v36;
  __int16 v37;
  unint64_t v38;
  unsigned __int16 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int16 *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int16 *v50;
  unint64_t v51;
  unsigned __int16 *v52;
  unsigned __int16 *v53;
  unint64_t v54;
  unsigned __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  __int16 v58;
  unint64_t v59;
  unsigned __int16 *v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  int v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  uint64_t v92;
  int v93;
  uint64_t *v94;
  unint64_t v95;

  v7 = *((unsigned __int8 *)a2 + 8);
  v91 = *a2;
  v8 = (unsigned int *)*((_QWORD *)a2 + 2);
  v90 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 15);
  v9 = *((_QWORD *)a2 + 16);
  v11 = *((_QWORD *)a2 + 7);
  v87 = *((_QWORD *)a2 + 9);
  v12 = *((_QWORD *)a2 + 5) + v87 * a4;
  v13 = *(unsigned __int16 **)(result + 32);
  v14 = (char *)v13
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v95 = result;
  v88 = v11;
  v89 = v10;
  if (*(_QWORD *)(result + 176))
  {
    v85 = *((_QWORD *)a2 + 11);
    v83 = ~(-1 << v11);
    v84 = *((_QWORD *)a2 + 13);
    v82 = v11 - 4;
    v15 = (unsigned __int16 *)(v14 - 4);
    v80 = a5;
    v81 = -v10;
    v79 = v9 + 16 * a3 + 8;
    while (1)
    {
      if (((v84 - v12) | (v12 - v85)) < 0)
      {
        v18 = 0;
        v17 = 0;
      }
      else
      {
        v16 = ((v12 & (unint64_t)v83) >> v82) & 0xF;
        v17 = (unint64_t)(v16 - 7) >= 9 ? v81 : v10;
        v18 = weights_19497[v16] & 0xF;
      }
      v19 = *(_QWORD *)(v95 + 32) + (v12 >> v11) * v10;
      v93 = a6;
      v92 = v12;
      if (v91 != 1)
        break;
      if (a5 >= 1)
      {
        v20 = (uint64_t *)v79;
        v21 = v80;
        while (1)
        {
          v22 = *(v20 - 1);
          v23 = *v20;
          v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22)
            v25 = (unsigned __int16 *)(v19 + v22);
          else
            v25 = v15;
          if (v25 < v13)
            v25 = v13;
          v26 = *v25;
          v27 = *v20 & 0xF;
          if ((v23 & 0xF) != 0)
            break;
          if (v18)
          {
            v39 = (unsigned __int16 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17)
              v39 = v15;
            if (v39 < v13)
              v39 = v13;
            v40 = BLEND16_19498[v18];
            v37 = v26 - ((v40 & v26) >> v18);
            v38 = (unint64_t)(unsigned __int16)(v40 & *v39) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          result = (65793 * BYTE1(v26)) | 0xFF000000;
          if (v7 != 255)
            result = PDM_13345(result, v7);
          v20 += 2;
          *v8++ = result;
          if (!--v21)
            goto LABEL_83;
        }
        v28 = v23 >> 4;
        v29 = (unsigned __int16 *)(v24 + (v23 >> 4));
        if (v15 < v29)
          v29 = v15;
        if (v29 < v13)
          v29 = v13;
        v30 = *v29;
        if (v18)
        {
          v31 = (unsigned __int16 *)(v24 + v17);
          if (v15 >= v31)
            v32 = v31;
          else
            v32 = v15;
          if (v32 < v13)
            v32 = v13;
          v33 = *v32;
          v34 = (unsigned __int16 *)((char *)v31 + v28);
          if (v15 < v34)
            v34 = v15;
          if (v34 < v13)
            v34 = v13;
          v35 = BLEND16_19498[v18];
          LODWORD(v26) = v26 - ((v35 & v26) >> v18) + ((v35 & v33) >> v18);
          LODWORD(v30) = v30 - ((v35 & v30) >> v18) + ((unint64_t)(unsigned __int16)(v35 & *v34) >> v18);
        }
        v36 = BLEND16_19498[v27];
        v37 = v26 - ((unint64_t)(v36 & v26) >> v27);
        v38 = (unint64_t)(v36 & v30) >> v27;
LABEL_40:
        LOWORD(v26) = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      v10 = v89;
      v8 += v90;
      LOBYTE(v11) = v88;
      v12 = v92 + v87;
      a6 = v93 - 1;
      if (v93 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_83;
    v42 = (uint64_t *)v79;
    v41 = v80;
    while (1)
    {
      v43 = *(v42 - 1);
      v44 = *v42;
      v45 = v19 + v43;
      if ((unint64_t)v15 >= v19 + v43)
        v46 = (unsigned __int16 *)(v19 + v43);
      else
        v46 = v15;
      if (v46 < v13)
        v46 = v13;
      v47 = *v46;
      v48 = *v42 & 0xF;
      if ((v44 & 0xF) != 0)
        break;
      if (v18)
      {
        v60 = (unsigned __int16 *)(v45 + v17);
        if ((unint64_t)v15 < v45 + v17)
          v60 = v15;
        if (v60 < v13)
          v60 = v13;
        v61 = BLEND16_19498[v18];
        v58 = v47 - ((v61 & v47) >> v18);
        v59 = (unint64_t)(unsigned __int16)(v61 & *v60) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      v62 = 65793 * BYTE1(v47);
      v63 = v62 | 0xFF000000;
      if (v7 != 255)
      {
        result = PDM_13345(v62 | 0xFF000000, v7);
        v63 = result;
      }
      if (HIBYTE(v63))
      {
        if (HIBYTE(v63) == 255)
          *v8 = v63;
        else
          result = (unint64_t)DplusDM_13347(v8, v63, *v8, ~v63 >> 24);
      }
      v42 += 2;
      ++v8;
      if (!--v41)
        goto LABEL_83;
    }
    v49 = v44 >> 4;
    v50 = (unsigned __int16 *)(v45 + (v44 >> 4));
    if (v15 < v50)
      v50 = v15;
    if (v50 < v13)
      v50 = v13;
    v51 = *v50;
    if (v18)
    {
      v52 = (unsigned __int16 *)(v45 + v17);
      if (v15 >= v52)
        v53 = v52;
      else
        v53 = v15;
      if (v53 < v13)
        v53 = v13;
      v54 = *v53;
      v55 = (unsigned __int16 *)((char *)v52 + v49);
      if (v15 < v55)
        v55 = v15;
      if (v55 < v13)
        v55 = v13;
      v56 = BLEND16_19498[v18];
      LODWORD(v47) = v47 - ((v56 & v47) >> v18) + ((v56 & v54) >> v18);
      LODWORD(v51) = v51 - ((v56 & v51) >> v18) + ((unint64_t)(unsigned __int16)(v56 & *v55) >> v18);
    }
    v57 = BLEND16_19498[v48];
    v58 = v47 - ((unint64_t)(v57 & v47) >> v48);
    v59 = (unint64_t)(v57 & v51) >> v48;
LABEL_75:
    LOWORD(v47) = v58 + v59;
    goto LABEL_76;
  }
  v94 = (uint64_t *)(v9 + 16 * a3);
  v64 = v14 - 4;
  v65 = a5;
  do
  {
    v66 = v12;
    v67 = *(char **)(v95 + 32);
    v68 = &v67[(v12 >> v11) * v10];
    if (v91 == 1)
    {
      if (a5 >= 1)
      {
        v69 = v94;
        v70 = v65;
        do
        {
          v71 = *v69;
          v69 += 2;
          v72 = &v68[v71];
          if (v64 < &v68[v71])
            v72 = v64;
          if (v72 < v67)
            v72 = v67;
          result = *(_WORD *)v72 & 0xFF00 | (HIBYTE(*(unsigned __int16 *)v72) << 16) | HIBYTE(*(unsigned __int16 *)v72) | 0xFF000000;
          if (v7 != 255)
            result = PDM_13345(result, v7);
          *v8++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      v73 = v94;
      v74 = v65;
      if (a5 >= 1)
      {
        do
        {
          v75 = *v73;
          v73 += 2;
          v76 = &v68[v75];
          if (v64 < &v68[v75])
            v76 = v64;
          if ((unint64_t)v76 < *(_QWORD *)(v95 + 32))
            v76 = *(char **)(v95 + 32);
          v77 = *(_WORD *)v76 & 0xFF00 | (HIBYTE(*(unsigned __int16 *)v76) << 16) | HIBYTE(*(unsigned __int16 *)v76);
          v78 = v77 | 0xFF000000;
          if (v7 != 255)
          {
            result = PDM_13345(v77 | 0xFF000000, v7);
            v78 = result;
          }
          if (HIBYTE(v78))
          {
            if (HIBYTE(v78) == 255)
              *v8 = v78;
            else
              result = (unint64_t)DplusDM_13347(v8, v78, *v8, ~v78 >> 24);
          }
          ++v8;
          --v74;
        }
        while (v74);
      }
    }
    v10 = v89;
    v8 += v90;
    LOBYTE(v11) = v88;
    v12 = v66 + v87;
    --a6;
  }
  while (a6);
  return result;
}

void argb32_mark_image_RGB48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int *v13;
  int v14;
  void *v15;
  void *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  char *v28;
  int v29;
  uint64_t i;
  char *v31;
  int v32;
  char *v33;
  char v34;
  char v35;
  int v36;
  void *v39;
  int v40;
  int v41;
  uint64_t v42;

  v36 = a2;
  v9 = *(unsigned int *)(a1 + 28);
  v10 = (int)v9;
  v11 = *(_DWORD *)(a1 + 4);
  v12 = *(_DWORD *)(a1 + 8);
  v40 = v12;
  v41 = v11;
  v13 = *(int **)(a1 + 136);
  if (v13)
  {
    v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v42) = *(_DWORD *)(a1 + 108);
    HIDWORD(v42) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v42, v11, v12);
    v16 = v15;
    if (v15)
      goto LABEL_24;
  }
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v42 = 0;
  if (v11 < 0)
LABEL_4:
    _CGHandleAssert("CGSConvertBGR16toRGBA8888", 465, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0)
      _CGHandleAssert("CGSConvertBGR16toRGBA8888", 465, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v12);
    v39 = v16;
    v19 = *(_DWORD *)(a1 + 76);
    v20 = *(_QWORD *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v36);
    v21 = (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    v22 = v19 * (uint64_t)a4;
    v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      v24 = v10;
      v21 += v23 * v10;
      v25 = v9;
      v26 = -(int)v9;
    }
    else
    {
      v24 = v10;
      v25 = v9;
      v26 = v9;
    }
    v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21)
        v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0x6AA0E972uLL);
    }
    if (v12 >= 1)
    {
      for (i = 0; i != v12; ++i)
      {
        if (v11 >= 1)
        {
          v31 = &v28[i * v26];
          v32 = v11;
          v33 = (char *)(v20 + i * (int)v22);
          do
          {
            v34 = *v33;
            v35 = v33[2];
            *v31 = v33[4];
            v31[1] = v35;
            v31[2] = v34;
            v31[3] = -1;
            v33 += 6;
            v31 += 4;
            --v32;
          }
          while (v32);
        }
      }
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    v10 = v24;
    v9 = v25;
    v16 = v39;
    if (!v39)
      break;
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v42 + 1, &v42, &v41, &v40))
    {
      free(v16);
      return;
    }
    v18 = v42;
    v17 = HIDWORD(v42);
    v12 = v40;
    v11 = v41;
    if (v41 < 0)
      goto LABEL_4;
  }
}

unint64_t argb32_image_mark_RGB48(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  char *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unint64_t v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unint64_t v32;
  unsigned __int16 *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unsigned __int16 *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int16 *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 *v49;
  unint64_t v50;
  unsigned __int16 *v51;
  unsigned __int16 *v52;
  unint64_t v53;
  unsigned __int16 *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int16 *v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  char *v63;
  uint64_t v64;
  char *v65;
  char *v66;
  int v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  int v91;
  uint64_t *v92;
  unint64_t v93;

  v6 = *((unsigned __int8 *)a2 + 8);
  v89 = *a2;
  v7 = (unsigned int *)*((_QWORD *)a2 + 2);
  v88 = *((_QWORD *)a2 + 3) - a5;
  v9 = *((_QWORD *)a2 + 15);
  v8 = *((_QWORD *)a2 + 16);
  v10 = *((_QWORD *)a2 + 7);
  v85 = *((_QWORD *)a2 + 9);
  v11 = *((_QWORD *)a2 + 5) + v85 * a4;
  v12 = *(unsigned __int16 **)(result + 32);
  v13 = (char *)v12
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v93 = result;
  v90 = a5;
  v86 = v10;
  v87 = v9;
  if (*(_QWORD *)(result + 176))
  {
    v84 = *((_QWORD *)a2 + 11);
    v82 = ~(-1 << v10);
    v83 = *((_QWORD *)a2 + 13);
    v81 = v10 - 4;
    v14 = (unsigned __int16 *)(v13 - 6);
    v79 = a5;
    v80 = -v9;
    v78 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v83 - v11) | (v11 - v84)) < 0)
      {
        v17 = 0;
        v16 = 0;
      }
      else
      {
        v15 = ((v11 & (unint64_t)v82) >> v81) & 0xF;
        v16 = (unint64_t)(v15 - 7) >= 9 ? v80 : v9;
        v17 = weights_19497[v15] & 0xF;
      }
      v18 = *(_QWORD *)(v93 + 32) + (v11 >> v10) * v9;
      v91 = a6;
      if (v89 != 1)
        break;
      if (a5 >= 1)
      {
        v19 = (uint64_t *)v78;
        v20 = v79;
        while (1)
        {
          v21 = *(v19 - 1);
          v22 = *v19;
          v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21)
            v24 = (unsigned __int16 *)(v18 + v21);
          else
            v24 = v14;
          if (v24 < v12)
            v24 = v12;
          v25 = bswap32(v24[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v24[2]) >> 16) << 32) | (bswap32(*v24) >> 16);
          v26 = *v19 & 0xF;
          if ((v22 & 0xF) != 0)
            break;
          if (v17)
          {
            v38 = (unsigned __int16 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16)
              v38 = v14;
            if (v38 < v12)
              v38 = v12;
            v39 = BLEND16_19498[v17];
            v36 = v25 - ((v39 & v25) >> v17);
            v37 = ((bswap32(v38[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | (bswap32(*v38) >> 16)) & v39) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          result = BYTE5(v25) | (BYTE1(v25) << 16) | (BYTE3(v25) << 8) | 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v19 += 2;
          *v7++ = result;
          if (!--v20)
            goto LABEL_83;
        }
        v27 = v22 >> 4;
        v28 = (unsigned __int16 *)(v23 + (v22 >> 4));
        if (v14 < v28)
          v28 = v14;
        if (v28 < v12)
          v28 = v12;
        v29 = bswap32(v28[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v28[2]) >> 16) << 32) | (bswap32(*v28) >> 16);
        if (v17)
        {
          v30 = (unsigned __int16 *)(v23 + v16);
          if (v14 >= v30)
            v31 = v30;
          else
            v31 = v14;
          if (v31 < v12)
            v31 = v12;
          v32 = bswap32(v31[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v31[2]) >> 16) << 32) | (bswap32(*v31) >> 16);
          v33 = (unsigned __int16 *)((char *)v30 + v27);
          if (v14 < v33)
            v33 = v14;
          if (v33 < v12)
            v33 = v12;
          v34 = BLEND16_19498[v17];
          v25 = v25 - ((v34 & v25) >> v17) + ((v32 & v34) >> v17);
          v29 = v29
              - ((v34 & v29) >> v17)
              + (((bswap32(v33[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v33[2]) >> 16) << 32) | (bswap32(*v33) >> 16)) & v34) >> v17);
        }
        v35 = BLEND16_19498[v26];
        v36 = v25 - ((v35 & v25) >> v26);
        v37 = (v35 & v29) >> v26;
LABEL_40:
        v25 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      v9 = v87;
      v7 += v88;
      LOBYTE(v10) = v86;
      v11 += v85;
      a6 = v91 - 1;
      a5 = v90;
      if (v91 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_83;
    v40 = (uint64_t *)v78;
    v41 = v79;
    while (1)
    {
      v42 = *(v40 - 1);
      v43 = *v40;
      v44 = v18 + v42;
      if ((unint64_t)v14 >= v18 + v42)
        v45 = (unsigned __int16 *)(v18 + v42);
      else
        v45 = v14;
      if (v45 < v12)
        v45 = v12;
      v46 = bswap32(v45[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | (bswap32(*v45) >> 16);
      v47 = *v40 & 0xF;
      if ((v43 & 0xF) != 0)
        break;
      if (v17)
      {
        v59 = (unsigned __int16 *)(v44 + v16);
        if ((unint64_t)v14 < v44 + v16)
          v59 = v14;
        if (v59 < v12)
          v59 = v12;
        v60 = BLEND16_19498[v17];
        v57 = v46 - ((v60 & v46) >> v17);
        v58 = ((bswap32(v59[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v59[2]) >> 16) << 32) | (bswap32(*v59) >> 16)) & v60) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      v61 = BYTE5(v46) | (BYTE1(v46) << 16) | (BYTE3(v46) << 8);
      v62 = v61 | 0xFF000000;
      if (v6 != 255)
      {
        result = PDM_13345(v61 | 0xFF000000, v6);
        v62 = result;
      }
      if (HIBYTE(v62))
      {
        if (HIBYTE(v62) == 255)
          *v7 = v62;
        else
          result = (unint64_t)DplusDM_13347(v7, v62, *v7, ~v62 >> 24);
      }
      v40 += 2;
      ++v7;
      if (!--v41)
        goto LABEL_83;
    }
    v48 = v43 >> 4;
    v49 = (unsigned __int16 *)(v44 + (v43 >> 4));
    if (v14 < v49)
      v49 = v14;
    if (v49 < v12)
      v49 = v12;
    v50 = bswap32(v49[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v49[2]) >> 16) << 32) | (bswap32(*v49) >> 16);
    if (v17)
    {
      v51 = (unsigned __int16 *)(v44 + v16);
      if (v14 >= v51)
        v52 = v51;
      else
        v52 = v14;
      if (v52 < v12)
        v52 = v12;
      v53 = bswap32(v52[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v52[2]) >> 16) << 32) | (bswap32(*v52) >> 16);
      v54 = (unsigned __int16 *)((char *)v51 + v48);
      if (v14 < v54)
        v54 = v14;
      if (v54 < v12)
        v54 = v12;
      v55 = BLEND16_19498[v17];
      v46 = v46 - ((v55 & v46) >> v17) + ((v53 & v55) >> v17);
      v50 = v50
          - ((v55 & v50) >> v17)
          + (((bswap32(v54[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v54[2]) >> 16) << 32) | (bswap32(*v54) >> 16)) & v55) >> v17);
    }
    v56 = BLEND16_19498[v47];
    v57 = v46 - ((v56 & v46) >> v47);
    v58 = (v56 & v50) >> v47;
LABEL_75:
    v46 = v57 + v58;
    goto LABEL_76;
  }
  v92 = (uint64_t *)(v8 + 16 * a3);
  v63 = v13 - 6;
  v64 = a5;
  do
  {
    v65 = *(char **)(v93 + 32);
    v66 = &v65[(v11 >> v10) * v9];
    v67 = a6;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        v68 = v92;
        v69 = v64;
        do
        {
          v70 = *v68;
          v68 += 2;
          v71 = &v66[v70];
          if (v63 < &v66[v70])
            v71 = v63;
          if (v71 < v65)
            v71 = v65;
          result = v71[4] | (*(unsigned __int16 *)v71 << 16) | (*((_WORD *)v71 + 1) << 8) | 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          *v7++ = result;
          --v69;
        }
        while (v69);
      }
    }
    else
    {
      v72 = v92;
      v73 = v64;
      if (a5 >= 1)
      {
        do
        {
          v74 = *v72;
          v72 += 2;
          v75 = &v66[v74];
          if (v63 < &v66[v74])
            v75 = v63;
          if ((unint64_t)v75 < *(_QWORD *)(v93 + 32))
            v75 = *(char **)(v93 + 32);
          v76 = v75[4] | (*(unsigned __int16 *)v75 << 16) | (*((_WORD *)v75 + 1) << 8);
          v77 = v76 | 0xFF000000;
          if (v6 != 255)
          {
            result = PDM_13345(v76 | 0xFF000000, v6);
            v77 = result;
          }
          if (HIBYTE(v77))
          {
            if (HIBYTE(v77) == 255)
              *v7 = v77;
            else
              result = (unint64_t)DplusDM_13347(v7, v77, *v7, ~v77 >> 24);
          }
          ++v7;
          --v73;
        }
        while (v73);
      }
    }
    v9 = v87;
    v7 += v88;
    LOBYTE(v10) = v86;
    v11 += v85;
    a6 = v67 - 1;
    a5 = v90;
  }
  while (v67 != 1);
  return result;
}

void argb32_mark_image_rgb48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int *v13;
  int v14;
  void *v15;
  void *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  char *v28;
  int v29;
  uint64_t v30;
  char *v31;
  char *v32;
  int v33;
  char *v34;
  char v35;
  char v36;
  char v37;
  int v38;
  void *v41;
  int v42;
  int v43;
  uint64_t v44;

  v38 = a2;
  v9 = *(unsigned int *)(a1 + 28);
  v10 = (int)v9;
  v11 = *(_DWORD *)(a1 + 4);
  v12 = *(_DWORD *)(a1 + 8);
  v42 = v12;
  v43 = v11;
  v13 = *(int **)(a1 + 136);
  if (v13)
  {
    v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v44) = *(_DWORD *)(a1 + 108);
    HIDWORD(v44) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v44, v11, v12);
    v16 = v15;
    if (v15)
      goto LABEL_24;
  }
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v44 = 0;
  if (v11 < 0)
LABEL_4:
    _CGHandleAssert("CGSConvertbgr16toRGBA8888", 850, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0)
      _CGHandleAssert("CGSConvertbgr16toRGBA8888", 850, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v12);
    v41 = v16;
    v19 = *(_DWORD *)(a1 + 76);
    v20 = *(_QWORD *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v38);
    v21 = (char *)(*(_QWORD *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    v22 = v19 * (uint64_t)a4;
    v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      v24 = v10;
      v21 += v23 * v10;
      v25 = v9;
      v26 = -(int)v9;
    }
    else
    {
      v24 = v10;
      v25 = v9;
      v26 = v9;
    }
    v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21)
        v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0xC245444CuLL);
    }
    if (v12 >= 1)
    {
      v30 = 0;
      v31 = (char *)(v20 + 5);
      do
      {
        if (v11 >= 1)
        {
          v32 = &v28[v30 * v26];
          v33 = v11;
          v34 = v31;
          do
          {
            v35 = *(v34 - 4);
            v36 = *(v34 - 2);
            v37 = *v34;
            v34 += 6;
            *v32 = v37;
            v32[1] = v36;
            v32[2] = v35;
            v32[3] = -1;
            v32 += 4;
            --v33;
          }
          while (v33);
        }
        ++v30;
        v31 += (int)v22;
      }
      while (v30 != v12);
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    v10 = v24;
    v9 = v25;
    v16 = v41;
    if (!v41)
      break;
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v44 + 1, &v44, &v43, &v42))
    {
      free(v16);
      return;
    }
    v18 = v44;
    v17 = HIDWORD(v44);
    v12 = v42;
    v11 = v43;
    if (v43 < 0)
      goto LABEL_4;
  }
}

unint64_t argb32_image_mark_rgb48(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  char *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unint64_t v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unint64_t v32;
  unsigned __int16 *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unsigned __int16 *v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned __int16 *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 *v49;
  unint64_t v50;
  unsigned __int16 *v51;
  unsigned __int16 *v52;
  unint64_t v53;
  unsigned __int16 *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int16 *v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  char *v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  int v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  int v91;
  uint64_t *v92;
  unint64_t v93;

  v6 = *((unsigned __int8 *)a2 + 8);
  v89 = *a2;
  v7 = (unsigned int *)*((_QWORD *)a2 + 2);
  v88 = *((_QWORD *)a2 + 3) - a5;
  v9 = *((_QWORD *)a2 + 15);
  v8 = *((_QWORD *)a2 + 16);
  v10 = *((_QWORD *)a2 + 7);
  v85 = *((_QWORD *)a2 + 9);
  v11 = *((_QWORD *)a2 + 5) + v85 * a4;
  v12 = *(unsigned __int16 **)(result + 32);
  v13 = (char *)v12
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v93 = result;
  v90 = a5;
  v86 = v10;
  v87 = v9;
  if (*(_QWORD *)(result + 176))
  {
    v84 = *((_QWORD *)a2 + 11);
    v82 = ~(-1 << v10);
    v83 = *((_QWORD *)a2 + 13);
    v81 = v10 - 4;
    v14 = (unsigned __int16 *)(v13 - 6);
    v79 = a5;
    v80 = -v9;
    v78 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v83 - v11) | (v11 - v84)) < 0)
      {
        v17 = 0;
        v16 = 0;
      }
      else
      {
        v15 = ((v11 & (unint64_t)v82) >> v81) & 0xF;
        v16 = (unint64_t)(v15 - 7) >= 9 ? v80 : v9;
        v17 = weights_19497[v15] & 0xF;
      }
      v18 = *(_QWORD *)(v93 + 32) + (v11 >> v10) * v9;
      v91 = a6;
      if (v89 != 1)
        break;
      if (a5 >= 1)
      {
        v19 = (uint64_t *)v78;
        v20 = v79;
        while (1)
        {
          v21 = *(v19 - 1);
          v22 = *v19;
          v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21)
            v24 = (unsigned __int16 *)(v18 + v21);
          else
            v24 = v14;
          if (v24 < v12)
            v24 = v12;
          v25 = *v24 | ((unint64_t)*(unsigned int *)(v24 + 1) << 16);
          v26 = *v19 & 0xF;
          if ((v22 & 0xF) != 0)
            break;
          if (v17)
          {
            v38 = (unsigned __int16 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16)
              v38 = v14;
            if (v38 < v12)
              v38 = v12;
            v39 = BLEND16_19498[v17];
            v36 = v25 - ((v39 & v25) >> v17);
            v37 = ((*v38 | ((unint64_t)*(unsigned int *)(v38 + 1) << 16)) & v39) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          result = BYTE5(v25) | (BYTE1(v25) << 16) | (BYTE3(v25) << 8) | 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v19 += 2;
          *v7++ = result;
          if (!--v20)
            goto LABEL_83;
        }
        v27 = v22 >> 4;
        v28 = (unsigned __int16 *)(v23 + (v22 >> 4));
        if (v14 < v28)
          v28 = v14;
        if (v28 < v12)
          v28 = v12;
        v29 = *v28 | ((unint64_t)*(unsigned int *)(v28 + 1) << 16);
        if (v17)
        {
          v30 = (unsigned __int16 *)(v23 + v16);
          if (v14 >= v30)
            v31 = v30;
          else
            v31 = v14;
          if (v31 < v12)
            v31 = v12;
          v32 = *v31 | ((unint64_t)*(unsigned int *)(v31 + 1) << 16);
          v33 = (unsigned __int16 *)((char *)v30 + v27);
          if (v14 < v33)
            v33 = v14;
          if (v33 < v12)
            v33 = v12;
          v34 = BLEND16_19498[v17];
          v25 = v25 - ((v34 & v25) >> v17) + ((v32 & v34) >> v17);
          v29 = v29
              - ((v34 & v29) >> v17)
              + (((*v33 | ((unint64_t)*(unsigned int *)(v33 + 1) << 16)) & v34) >> v17);
        }
        v35 = BLEND16_19498[v26];
        v36 = v25 - ((v35 & v25) >> v26);
        v37 = (v35 & v29) >> v26;
LABEL_40:
        v25 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      v9 = v87;
      v7 += v88;
      LOBYTE(v10) = v86;
      v11 += v85;
      a6 = v91 - 1;
      a5 = v90;
      if (v91 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_83;
    v40 = (uint64_t *)v78;
    v41 = v79;
    while (1)
    {
      v42 = *(v40 - 1);
      v43 = *v40;
      v44 = v18 + v42;
      if ((unint64_t)v14 >= v18 + v42)
        v45 = (unsigned __int16 *)(v18 + v42);
      else
        v45 = v14;
      if (v45 < v12)
        v45 = v12;
      v46 = *v45 | ((unint64_t)*(unsigned int *)(v45 + 1) << 16);
      v47 = *v40 & 0xF;
      if ((v43 & 0xF) != 0)
        break;
      if (v17)
      {
        v59 = (unsigned __int16 *)(v44 + v16);
        if ((unint64_t)v14 < v44 + v16)
          v59 = v14;
        if (v59 < v12)
          v59 = v12;
        v60 = BLEND16_19498[v17];
        v57 = v46 - ((v60 & v46) >> v17);
        v58 = ((*v59 | ((unint64_t)*(unsigned int *)(v59 + 1) << 16)) & v60) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      v61 = BYTE5(v46) | (BYTE1(v46) << 16) | (BYTE3(v46) << 8);
      v62 = v61 | 0xFF000000;
      if (v6 != 255)
      {
        result = PDM_13345(v61 | 0xFF000000, v6);
        v62 = result;
      }
      if (HIBYTE(v62))
      {
        if (HIBYTE(v62) == 255)
          *v7 = v62;
        else
          result = (unint64_t)DplusDM_13347(v7, v62, *v7, ~v62 >> 24);
      }
      v40 += 2;
      ++v7;
      if (!--v41)
        goto LABEL_83;
    }
    v48 = v43 >> 4;
    v49 = (unsigned __int16 *)(v44 + (v43 >> 4));
    if (v14 < v49)
      v49 = v14;
    if (v49 < v12)
      v49 = v12;
    v50 = *v49 | ((unint64_t)*(unsigned int *)(v49 + 1) << 16);
    if (v17)
    {
      v51 = (unsigned __int16 *)(v44 + v16);
      if (v14 >= v51)
        v52 = v51;
      else
        v52 = v14;
      if (v52 < v12)
        v52 = v12;
      v53 = *v52 | ((unint64_t)*(unsigned int *)(v52 + 1) << 16);
      v54 = (unsigned __int16 *)((char *)v51 + v48);
      if (v14 < v54)
        v54 = v14;
      if (v54 < v12)
        v54 = v12;
      v55 = BLEND16_19498[v17];
      v46 = v46 - ((v55 & v46) >> v17) + ((v53 & v55) >> v17);
      v50 = v50 - ((v55 & v50) >> v17) + (((*v54 | ((unint64_t)*(unsigned int *)(v54 + 1) << 16)) & v55) >> v17);
    }
    v56 = BLEND16_19498[v47];
    v57 = v46 - ((v56 & v46) >> v47);
    v58 = (v56 & v50) >> v47;
LABEL_75:
    v46 = v57 + v58;
    goto LABEL_76;
  }
  v92 = (uint64_t *)(v8 + 16 * a3);
  v63 = v13 - 6;
  v64 = a5;
  do
  {
    v65 = *(_QWORD *)(v93 + 32);
    v66 = v65 + (v11 >> v10) * v9;
    v67 = a6;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        v68 = v92;
        v69 = v64;
        do
        {
          v70 = *v68;
          v68 += 2;
          v71 = v66 + v70;
          if ((unint64_t)v63 < v66 + v70)
            v71 = (unint64_t)v63;
          if (v71 < v65)
            v71 = v65;
          result = *(unsigned __int8 *)(v71 + 5) | (HIBYTE(*(_WORD *)v71) << 16) | (*(unsigned __int8 *)(v71 + 3) << 8) | 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          *v7++ = result;
          --v69;
        }
        while (v69);
      }
    }
    else
    {
      v72 = v92;
      v73 = v64;
      if (a5 >= 1)
      {
        do
        {
          v74 = *v72;
          v72 += 2;
          v75 = v66 + v74;
          if ((unint64_t)v63 < v66 + v74)
            v75 = (unint64_t)v63;
          if (v75 < *(_QWORD *)(v93 + 32))
            v75 = *(_QWORD *)(v93 + 32);
          v76 = *(unsigned __int8 *)(v75 + 5) | (HIBYTE(*(_WORD *)v75) << 16) | (*(unsigned __int8 *)(v75 + 3) << 8);
          v77 = v76 | 0xFF000000;
          if (v6 != 255)
          {
            result = PDM_13345(v76 | 0xFF000000, v6);
            v77 = result;
          }
          if (HIBYTE(v77))
          {
            if (HIBYTE(v77) == 255)
              *v7 = v77;
            else
              result = (unint64_t)DplusDM_13347(v7, v77, *v7, ~v77 >> 24);
          }
          ++v7;
          --v73;
        }
        while (v73);
      }
    }
    v9 = v87;
    v7 += v88;
    LOBYTE(v10) = v86;
    v11 += v85;
    a6 = v67 - 1;
    a5 = v90;
  }
  while (v67 != 1);
  return result;
}

void argb32_mark_image_RGBA64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v10;
  int *v11;
  int v12;
  void *v13;
  void *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int32x4_t v27;
  int v28;
  uint32x4_t *v29;
  __int32 *v30;
  unsigned int v31;
  int32x4_t v32;
  int8x16_t v33;
  int32x4_t v34;
  int v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  BOOL v42;
  int v43;
  __int32 v44;
  int v45;
  _BOOL4 v46;
  uint64_t v47;
  int v48;
  unint64_t v49;
  char *v50;
  int v51;
  int v52;
  char *v53;
  uint64_t i;
  char *v55;
  int v56;
  char *v57;
  char v58;
  char v59;
  char v60;
  int v62;
  int v63;
  void *v67;
  int v68;
  int v69;
  uint64_t v70;

  v8 = a5;
  v63 = a2;
  v62 = *(_DWORD *)(a1 + 28);
  v9 = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 8);
  v68 = v10;
  v69 = v9;
  v11 = *(int **)(a1 + 136);
  if (v11)
  {
    v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v70) = *(_DWORD *)(a1 + 108);
    HIDWORD(v70) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v70, v9, v10);
    v14 = v13;
    if (v13)
      goto LABEL_50;
  }
  v15 = 0;
  v16 = 0;
  v14 = 0;
  v70 = 0;
  while (1)
  {
    v17 = *(_DWORD *)(a1 + 76);
    v18 = *(_QWORD *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    v20 = *(_QWORD *)(a1 + 48);
    v21 = (char *)(*(_QWORD *)(a1 + 40) + v19 * v62 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    v22 = v17 * (uint64_t)v8;
    v67 = v14;
    if (v63 == 2)
    {
      if (v20)
        v23 = 0;
      else
        v23 = -16777216;
      if (v10 >= 1)
      {
        v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FFLL;
        v25.i64[1] = 0xFF000000FFLL;
        v26.i64[0] = 0xFF000000FF000000;
        v26.i64[1] = 0xFF000000FF000000;
        v27.i64[0] = 0x1000100010001;
        v27.i64[1] = 0x1000100010001;
        do
        {
          v28 = v9;
          v29 = (uint32x4_t *)v21;
          v30 = (__int32 *)v18;
          v31 = v9;
          if (v9 >= 4)
          {
            do
            {
              v32.i32[0] = v30[1];
              v32.i32[1] = v30[3];
              v32.i32[2] = v30[5];
              v32.i32[3] = v30[7];
              v33 = (int8x16_t)vshlq_n_s32(v32, 8uLL);
              v34 = (int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x18uLL);
              v35 = vaddvq_s32(v34);
              if (v35)
              {
                v36.i32[0] = *v30;
                v36.i32[1] = v30[2];
                v36.i32[2] = v30[4];
                v36.i32[3] = v30[6];
                v37 = (int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v36, 0x10uLL) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL)), (int8x16_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v36, 8uLL) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))), vorrq_s8(vandq_s8((int8x16_t)v32, v25), vandq_s8(v33, v26)));
                if (v35 != 1020)
                {
                  v38 = (int32x4_t)veorq_s8((int8x16_t)v34, v25);
                  v39.i16[0] = v29->u8[0];
                  v39.i16[1] = BYTE2(v29->u32[0]);
                  v39.i16[2] = BYTE4(v29->i64[0]);
                  v39.i16[3] = BYTE6(v29->i64[0]);
                  v39.i16[4] = v29->i64[1];
                  v39.i16[5] = BYTE2(v29->i64[1]);
                  v39.i16[6] = BYTE12(*(unsigned __int128 *)v29);
                  v39.i16[7] = BYTE14(*(unsigned __int128 *)v29);
                  v40 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v29, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v38);
                  v41 = vmulq_s32(v39, v38);
                  v37 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v41, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v41, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v37, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v40, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)v29 = vorrq_s8((int8x16_t)v37, v24);
              }
              v28 = v31 - 4;
              v30 += 8;
              ++v29;
              v42 = v31 > 7;
              v31 -= 4;
            }
            while (v42);
          }
          if (v28 >= 1)
          {
            v43 = v28 + 1;
            do
            {
              v44 = v30[1];
              if (BYTE2(v44))
              {
                v45 = (*v30 >> 8) & 0xFF00 | (*v30 << 16) & 0xFFFFFF | v30[1] | (BYTE2(v30[1]) << 24);
                if (BYTE2(v44) != 255)
                  v45 += ((((v29->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                          + 65537
                          + ((((v29->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFFu)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v29->i32[0] = v45 | v23;
              }
              v29 = (uint32x4_t *)((char *)v29 + 4);
              --v43;
              v30 += 2;
            }
            while (v43 > 1);
          }
          v18 += v22;
          v21 += v62;
          v42 = v10-- <= 1;
        }
        while (!v42);
      }
    }
    else
    {
      v46 = 0;
      if (v20)
        v46 = *(_QWORD *)(a1 + 96) != 0;
      if (v9 < 0)
        _CGHandleAssert("CGSConvertBGRA16toRGBA8888", 499, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v9);
      if (v10 < 0)
        _CGHandleAssert("CGSConvertBGRA16toRGBA8888", 499, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v10);
      v47 = v10 - 1;
      if (v62 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        v48 = -v62;
        v21 += v47 * v62;
      }
      else
      {
        v48 = v62;
      }
      v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          v52 = v48;
          v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0xA390BB75uLL);
          v48 = v52;
          v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        for (i = 0; i != v10; ++i)
        {
          if (v9 >= 1)
          {
            v55 = &v50[i * v48];
            v56 = v9;
            v57 = (char *)(v18 + i * (int)v22);
            do
            {
              v58 = *v57;
              v59 = v57[2];
              v60 = v57[6];
              if (!v46)
                v60 = -1;
              *v55 = v57[4];
              v55[1] = v59;
              v55[2] = v58;
              v55[3] = v60;
              v57 += 8;
              v55 += 4;
              --v56;
            }
            while (v56);
          }
        }
      }
      v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    v14 = v67;
    if (!v67)
      break;
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v70 + 1, &v70, &v69, &v68))
    {
      free(v14);
      return;
    }
    v16 = v70;
    v15 = HIDWORD(v70);
    v10 = v68;
    v9 = v69;
  }
}

unint64_t argb32_image_mark_RGBA64(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int16 *v32;
  unint64_t v33;
  unsigned __int16 *v34;
  unsigned __int16 *v35;
  unint64_t v36;
  unsigned __int16 *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unsigned __int16 *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int16 *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int16 *v53;
  unint64_t v54;
  unsigned __int16 *v55;
  unsigned __int16 *v56;
  unint64_t v57;
  unsigned __int16 *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unsigned __int16 *v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned __int16 *v68;
  unsigned __int16 *v69;
  char *v70;
  int v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int16 *v75;
  unsigned __int16 *v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  unsigned __int16 *v85;
  unsigned __int16 *v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  int v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t *v110;

  v6 = *((unsigned __int8 *)a2 + 8);
  v105 = *a2;
  v7 = *(unsigned __int16 **)(result + 32);
  if (*(_QWORD *)(result + 40))
    v8 = 0;
  else
    v8 = 0xFFFFLL;
  v9 = (unsigned int *)*((_QWORD *)a2 + 2);
  v104 = *((_QWORD *)a2 + 3) - a5;
  v11 = *((_QWORD *)a2 + 15);
  v10 = *((_QWORD *)a2 + 16);
  v12 = *((_QWORD *)a2 + 7);
  v101 = *((_QWORD *)a2 + 9);
  v13 = *((_QWORD *)a2 + 5) + v101 * a4;
  v14 = (char *)v7
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v108 = result;
  v102 = v12;
  v103 = v11;
  if (*(_QWORD *)(result + 176))
  {
    v99 = *((_QWORD *)a2 + 11);
    v97 = ~(-1 << v12);
    v98 = *((_QWORD *)a2 + 13);
    v96 = v12 - 4;
    v15 = (unsigned __int16 *)(v14 - 8);
    v16 = v8 << 48;
    v94 = a5;
    v95 = -v11;
    v93 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v98 - v13) | (v13 - v99)) < 0)
      {
        v21 = 0;
        v109 = 0;
      }
      else
      {
        v17 = ((v13 & (unint64_t)v97) >> v96) & 0xF;
        v18 = weights_19497[v17];
        v19 = (unint64_t)(v17 - 7) >= 9;
        v20 = v95;
        if (!v19)
          v20 = v11;
        v109 = v20;
        v21 = v18 & 0xF;
      }
      v22 = *(_QWORD *)(v108 + 32) + (v13 >> v12) * v11;
      v106 = a6;
      if (v105 != 1)
        break;
      if (a5 >= 1)
      {
        v23 = (uint64_t *)v93;
        v24 = v94;
        while (1)
        {
          v25 = *(v23 - 1);
          v26 = *v23;
          v27 = v22 + v25;
          if ((unint64_t)v15 >= v22 + v25)
            v28 = (unsigned __int16 *)(v22 + v25);
          else
            v28 = v15;
          if (v28 < v7)
            v28 = v7;
          v29 = ((unint64_t)(bswap32(v28[3]) >> 16) << 48) | ((unint64_t)(bswap32(v28[2]) >> 16) << 32) | bswap32(v28[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v28) >> 16);
          v30 = *v23 & 0xF;
          if ((v26 & 0xF) != 0)
            break;
          if (v21)
          {
            v42 = (unsigned __int16 *)(v27 + v109);
            if ((unint64_t)v15 < v27 + v109)
              v42 = v15;
            if (v42 < v7)
              v42 = v7;
            v43 = BLEND16_19498[v21];
            v40 = v29 - ((v43 & v29) >> v21);
            v41 = ((((unint64_t)(bswap32(v42[3]) >> 16) << 48) | ((unint64_t)(bswap32(v42[2]) >> 16) << 32) | bswap32(v42[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v42) >> 16)) & v43) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          result = BYTE5(v29) | (BYTE1(v29) << 16) | (BYTE3(v29) << 8) | ((v29 | v16) >> 32) & 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v23 += 2;
          *v9++ = result;
          if (!--v24)
            goto LABEL_85;
        }
        v31 = v26 >> 4;
        v32 = (unsigned __int16 *)(v27 + (v26 >> 4));
        if (v15 < v32)
          v32 = v15;
        if (v32 < v7)
          v32 = v7;
        v33 = ((unint64_t)(bswap32(v32[3]) >> 16) << 48) | ((unint64_t)(bswap32(v32[2]) >> 16) << 32) | bswap32(v32[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v32) >> 16);
        if (v21)
        {
          v34 = (unsigned __int16 *)(v27 + v109);
          if (v15 >= v34)
            v35 = v34;
          else
            v35 = v15;
          if (v35 < v7)
            v35 = v7;
          v36 = ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
          v37 = (unsigned __int16 *)((char *)v34 + v31);
          if (v15 < v37)
            v37 = v15;
          if (v37 < v7)
            v37 = v7;
          v38 = BLEND16_19498[v21];
          v29 = v29 - ((v38 & v29) >> v21) + ((v36 & v38) >> v21);
          v33 = v33
              - ((v38 & v33) >> v21)
              + (((((unint64_t)(bswap32(v37[3]) >> 16) << 48) | ((unint64_t)(bswap32(v37[2]) >> 16) << 32) | bswap32(v37[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v37) >> 16)) & v38) >> v21);
        }
        v39 = BLEND16_19498[v30];
        v40 = v29 - ((v39 & v29) >> v30);
        v41 = (v39 & v33) >> v30;
LABEL_42:
        v29 = v40 + v41;
        goto LABEL_43;
      }
LABEL_85:
      v11 = v103;
      v9 += v104;
      LOBYTE(v12) = v102;
      v13 += v101;
      a6 = v106 - 1;
      if (v106 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_85;
    v45 = (uint64_t *)v93;
    v44 = v94;
    while (1)
    {
      v46 = *(v45 - 1);
      v47 = *v45;
      v48 = v22 + v46;
      if ((unint64_t)v15 >= v22 + v46)
        v49 = (unsigned __int16 *)(v22 + v46);
      else
        v49 = v15;
      if (v49 < v7)
        v49 = v7;
      v50 = ((unint64_t)(bswap32(v49[3]) >> 16) << 48) | ((unint64_t)(bswap32(v49[2]) >> 16) << 32) | bswap32(v49[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v49) >> 16);
      v51 = *v45 & 0xF;
      if ((v47 & 0xF) != 0)
        break;
      if (v21)
      {
        v63 = (unsigned __int16 *)(v48 + v109);
        if ((unint64_t)v15 < v48 + v109)
          v63 = v15;
        if (v63 < v7)
          v63 = v7;
        v64 = BLEND16_19498[v21];
        v61 = v50 - ((v64 & v50) >> v21);
        v62 = ((((unint64_t)(bswap32(v63[3]) >> 16) << 48) | ((unint64_t)(bswap32(v63[2]) >> 16) << 32) | bswap32(v63[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v63) >> 16)) & v64) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      v65 = ((v50 | v16) >> 32) & 0xFF000000;
      v66 = BYTE5(v50) | (BYTE1(v50) << 16) | (BYTE3(v50) << 8);
      v67 = v66 | v65;
      if (v6 != 255)
      {
        result = PDM_13345(v66 | v65, v6);
        v67 = result;
      }
      if (HIBYTE(v67))
      {
        if (HIBYTE(v67) == 255)
          *v9 = v67;
        else
          result = (unint64_t)DplusDM_13347(v9, v67, *v9, ~v67 >> 24);
      }
      v45 += 2;
      ++v9;
      if (!--v44)
        goto LABEL_85;
    }
    v52 = v47 >> 4;
    v53 = (unsigned __int16 *)(v48 + (v47 >> 4));
    if (v15 < v53)
      v53 = v15;
    if (v53 < v7)
      v53 = v7;
    v54 = ((unint64_t)(bswap32(v53[3]) >> 16) << 48) | ((unint64_t)(bswap32(v53[2]) >> 16) << 32) | bswap32(v53[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v53) >> 16);
    if (v21)
    {
      v55 = (unsigned __int16 *)(v48 + v109);
      if (v15 >= v55)
        v56 = v55;
      else
        v56 = v15;
      if (v56 < v7)
        v56 = v7;
      v57 = ((unint64_t)(bswap32(v56[3]) >> 16) << 48) | ((unint64_t)(bswap32(v56[2]) >> 16) << 32) | bswap32(v56[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v56) >> 16);
      v58 = (unsigned __int16 *)((char *)v55 + v52);
      if (v15 < v58)
        v58 = v15;
      if (v58 < v7)
        v58 = v7;
      v59 = BLEND16_19498[v21];
      v50 = v50 - ((v59 & v50) >> v21) + ((v57 & v59) >> v21);
      v54 = v54
          - ((v59 & v54) >> v21)
          + (((((unint64_t)(bswap32(v58[3]) >> 16) << 48) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | bswap32(v58[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v58) >> 16)) & v59) >> v21);
    }
    v60 = BLEND16_19498[v51];
    v61 = v50 - ((v60 & v50) >> v51);
    v62 = (v60 & v54) >> v51;
LABEL_77:
    v50 = v61 + v62;
    goto LABEL_78;
  }
  v110 = (uint64_t *)(v10 + 16 * a3);
  v68 = (unsigned __int16 *)(v14 - 8);
  v107 = a5;
  do
  {
    v69 = *(unsigned __int16 **)(v108 + 32);
    v70 = (char *)v69 + (v13 >> v12) * v11;
    if (v105 == 1)
    {
      v71 = a6;
      if (a5 >= 1)
      {
        v72 = v110;
        v73 = v107;
        do
        {
          v74 = *v72;
          v72 += 2;
          v75 = (unsigned __int16 *)&v70[v74];
          if (v68 < (unsigned __int16 *)&v70[v74])
            v75 = v68;
          if (v75 >= v69)
            v76 = v75;
          else
            v76 = v69;
          v77 = bswap32(v76[3]);
          v78 = bswap32(*v76) >> 16;
          v79 = bswap32(v76[1]) >> 16;
          v80 = bswap32(v76[2]) >> 16;
          v81 = v8 | HIWORD(v77);
          if (v6 == 255)
            result = (v80 >> 8) & 0xFF00FFFF | (BYTE1(v81) << 24) | (BYTE1(v78) << 16) | v79 & 0xFF00;
          else
            result = PDM_13345((v80 >> 8) & 0xFF00FFFF | (BYTE1(v81) << 24) | (BYTE1(v78) << 16) | v79 & 0xFF00, v6);
          *v9++ = result;
          --v73;
        }
        while (v73);
      }
    }
    else
    {
      v71 = a6;
      v82 = v110;
      v83 = v107;
      if (a5 >= 1)
      {
        do
        {
          v84 = *v82;
          v82 += 2;
          v85 = (unsigned __int16 *)&v70[v84];
          if (v68 < (unsigned __int16 *)&v70[v84])
            v85 = v68;
          if ((unint64_t)v85 >= *(_QWORD *)(v108 + 32))
            v86 = v85;
          else
            v86 = *(unsigned __int16 **)(v108 + 32);
          v87 = bswap32(v86[3]);
          v88 = bswap32(*v86) >> 16;
          v89 = bswap32(v86[1]) >> 16;
          v90 = bswap32(v86[2]) >> 16;
          v91 = v8 | HIWORD(v87);
          if (v6 == 255)
          {
            v92 = (v90 >> 8) & 0xFF00FFFF | (BYTE1(v91) << 24) | (BYTE1(v88) << 16) | v89 & 0xFF00;
          }
          else
          {
            result = PDM_13345((v90 >> 8) & 0xFF00FFFF | (BYTE1(v91) << 24) | (BYTE1(v88) << 16) | v89 & 0xFF00, v6);
            v92 = result;
          }
          if (HIBYTE(v92))
          {
            if (HIBYTE(v92) == 255)
              *v9 = v92;
            else
              result = (unint64_t)DplusDM_13347(v9, v92, *v9, ~v92 >> 24);
          }
          ++v9;
          --v83;
        }
        while (v83);
      }
    }
    v11 = v103;
    v9 += v104;
    LOBYTE(v12) = v102;
    v13 += v101;
    a6 = v71 - 1;
  }
  while (v71 != 1);
  return result;
}

void argb32_mark_image_rgba64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v10;
  int *v11;
  int v12;
  void *v13;
  void *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int32x4_t v27;
  int v28;
  uint32x4_t *v29;
  __int32 *v30;
  unsigned int v31;
  int8x16_t v32;
  int32x4_t v33;
  int v34;
  int32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  BOOL v41;
  int v42;
  unsigned __int32 v43;
  unsigned __int32 v44;
  unsigned int v45;
  _BOOL4 v46;
  uint64_t v47;
  int v48;
  unint64_t v49;
  char *v50;
  int v51;
  int v52;
  char *v53;
  uint64_t v54;
  char *v55;
  char *v56;
  char *v57;
  int v58;
  char v59;
  char v60;
  char v61;
  int v63;
  int v64;
  void *v68;
  int v69;
  int v70;
  uint64_t v71;

  v8 = a5;
  v64 = a2;
  v63 = *(_DWORD *)(a1 + 28);
  v9 = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 8);
  v69 = v10;
  v70 = v9;
  v11 = *(int **)(a1 + 136);
  if (v11)
  {
    v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v71) = *(_DWORD *)(a1 + 108);
    HIDWORD(v71) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v71, v9, v10);
    v14 = v13;
    if (v13)
      goto LABEL_50;
  }
  v15 = 0;
  v16 = 0;
  v14 = 0;
  v71 = 0;
  while (1)
  {
    v17 = *(_DWORD *)(a1 + 76);
    v18 = *(_QWORD *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    v20 = *(_QWORD *)(a1 + 48);
    v21 = (char *)(*(_QWORD *)(a1 + 40) + v19 * v63 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    v22 = v17 * (uint64_t)v8;
    v68 = v14;
    if (v64 == 2)
    {
      if (v20)
        v23 = 0;
      else
        v23 = -16777216;
      if (v10 >= 1)
      {
        v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FFLL;
        v25.i64[1] = 0xFF000000FFLL;
        v26.i64[0] = 0xFF000000FF000000;
        v26.i64[1] = 0xFF000000FF000000;
        v27.i64[0] = 0x1000100010001;
        v27.i64[1] = 0x1000100010001;
        do
        {
          v28 = v9;
          v29 = (uint32x4_t *)v21;
          v30 = (__int32 *)v18;
          v31 = v9;
          if (v9 >= 4)
          {
            do
            {
              v32.i32[0] = v30[1];
              v32.i32[1] = v30[3];
              v32.i32[2] = v30[5];
              v32.i32[3] = v30[7];
              v33 = (int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x18uLL);
              v34 = vaddvq_s32(v33);
              if (v34)
              {
                v35.i32[0] = *v30;
                v35.i32[1] = v30[2];
                v35.i32[2] = v30[4];
                v35.i32[3] = v30[6];
                v36 = (int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v35, 8uLL) & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL)), (int8x16_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v35, 0x10uLL) & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00))), vorrq_s8(vandq_s8(v32, v26), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v32, 8uLL), v25)));
                if (v34 != 1020)
                {
                  v37 = (int32x4_t)veorq_s8((int8x16_t)v33, v25);
                  v38.i16[0] = v29->u8[0];
                  v38.i16[1] = BYTE2(v29->u32[0]);
                  v38.i16[2] = BYTE4(v29->i64[0]);
                  v38.i16[3] = BYTE6(v29->i64[0]);
                  v38.i16[4] = v29->i64[1];
                  v38.i16[5] = BYTE2(v29->i64[1]);
                  v38.i16[6] = BYTE12(*(unsigned __int128 *)v29);
                  v38.i16[7] = BYTE14(*(unsigned __int128 *)v29);
                  v39 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v29, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v37);
                  v40 = vmulq_s32(v38, v37);
                  v36 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v40, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v36, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v39, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v39, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)v29 = vorrq_s8((int8x16_t)v36, v24);
              }
              v28 = v31 - 4;
              v30 += 8;
              ++v29;
              v41 = v31 > 7;
              v31 -= 4;
            }
            while (v41);
          }
          if (v28 >= 1)
          {
            v42 = v28 + 1;
            do
            {
              v43 = v30[1];
              v44 = HIBYTE(v43);
              if (HIBYTE(v43))
              {
                v45 = HIWORD(*v30) & 0xFF00 | (BYTE1(*v30) << 16) | v43 & 0xFF000000 | BYTE1(v43);
                if (v44 != 255)
                  v45 += ((((v29->i32[0] & 0xFF00FF) * (v44 ^ 0xFF)
                          + 65537
                          + ((((v29->i32[0] & 0xFF00FF) * (v44 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (v44 ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (v44 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v29->i32[0] = v45 | v23;
              }
              v29 = (uint32x4_t *)((char *)v29 + 4);
              --v42;
              v30 += 2;
            }
            while (v42 > 1);
          }
          v18 += v22;
          v21 += v63;
          v41 = v10-- <= 1;
        }
        while (!v41);
      }
    }
    else
    {
      v46 = 0;
      if (v20)
        v46 = *(_QWORD *)(a1 + 96) != 0;
      if (v9 < 0)
        _CGHandleAssert("CGSConvertbgra16toRGBA8888", 972, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v9);
      if (v10 < 0)
        _CGHandleAssert("CGSConvertbgra16toRGBA8888", 972, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v10);
      v47 = v10 - 1;
      if (v63 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        v48 = -v63;
        v21 += v47 * v63;
      }
      else
      {
        v48 = v63;
      }
      v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          v52 = v48;
          v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0x619F4619uLL);
          v48 = v52;
          v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        v54 = 0;
        v55 = (char *)(v18 + 3);
        do
        {
          if (v9 >= 1)
          {
            v56 = &v50[v54 * v48];
            v57 = v55;
            v58 = v9;
            do
            {
              v59 = *(v57 - 2);
              v60 = *v57;
              v61 = v57[4];
              if (!v46)
                v61 = -1;
              *v56 = v57[2];
              v56[1] = v60;
              v56[2] = v59;
              v56[3] = v61;
              v56 += 4;
              v57 += 8;
              --v58;
            }
            while (v58);
          }
          ++v54;
          v55 += (int)v22;
        }
        while (v54 != v10);
      }
      v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    v14 = v68;
    if (!v68)
      break;
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v71 + 1, &v71, &v70, &v69))
    {
      free(v14);
      return;
    }
    v16 = v71;
    v15 = HIDWORD(v71);
    v10 = v69;
    v9 = v70;
  }
}

unint64_t argb32_image_mark_rgba64(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  char *v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  char *v34;
  char *v35;
  unint64_t v36;
  char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  unint64_t v54;
  char *v55;
  char *v56;
  unint64_t v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  char *v63;
  unint64_t v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  char *v68;
  uint64_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  int v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v94;
  char v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t *v104;

  v6 = *((unsigned __int8 *)a2 + 8);
  v98 = *a2;
  v7 = *(char **)(result + 32);
  if (*(_QWORD *)(result + 40))
    v8 = 0;
  else
    v8 = 0xFFFFLL;
  v9 = (unsigned int *)*((_QWORD *)a2 + 2);
  v97 = *((_QWORD *)a2 + 3) - a5;
  v11 = *((_QWORD *)a2 + 15);
  v10 = *((_QWORD *)a2 + 16);
  v12 = *((_QWORD *)a2 + 7);
  v94 = *((_QWORD *)a2 + 9);
  v13 = *((_QWORD *)a2 + 5) + v94 * a4;
  v14 = &v7[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
          + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  v102 = result;
  v95 = v12;
  v96 = v11;
  if (*(_QWORD *)(result + 176))
  {
    v92 = *((_QWORD *)a2 + 11);
    v90 = ~(-1 << v12);
    v91 = *((_QWORD *)a2 + 13);
    v89 = v12 - 4;
    v15 = v14 - 8;
    v16 = v8 << 48;
    v87 = a5;
    v88 = -v11;
    v86 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v91 - v13) | (v13 - v92)) < 0)
      {
        v21 = 0;
        v103 = 0;
      }
      else
      {
        v17 = ((v13 & (unint64_t)v90) >> v89) & 0xF;
        v18 = weights_19497[v17];
        v19 = (unint64_t)(v17 - 7) >= 9;
        v20 = v88;
        if (!v19)
          v20 = v11;
        v103 = v20;
        v21 = v18 & 0xF;
      }
      v22 = *(_QWORD *)(v102 + 32) + (v13 >> v12) * v11;
      v100 = a6;
      v99 = v13;
      if (v98 != 1)
        break;
      if (a5 >= 1)
      {
        v23 = (uint64_t *)v86;
        v24 = v87;
        while (1)
        {
          v25 = *(v23 - 1);
          v26 = *v23;
          v27 = v22 + v25;
          if ((unint64_t)v15 >= v22 + v25)
            v28 = (char *)(v22 + v25);
          else
            v28 = v15;
          if (v28 < v7)
            v28 = v7;
          v29 = *(_QWORD *)v28;
          v30 = *v23 & 0xF;
          if ((v26 & 0xF) != 0)
            break;
          if (v21)
          {
            v42 = (char *)(v27 + v103);
            if ((unint64_t)v15 < v27 + v103)
              v42 = v15;
            if (v42 < v7)
              v42 = v7;
            v43 = BLEND16_19498[v21];
            v40 = v29 - ((v43 & v29) >> v21);
            v41 = (v43 & *(_QWORD *)v42) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          result = BYTE5(v29) | (BYTE1(v29) << 16) | (BYTE3(v29) << 8) | ((v29 | v16) >> 32) & 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          v23 += 2;
          *v9++ = result;
          if (!--v24)
            goto LABEL_85;
        }
        v31 = v26 >> 4;
        v32 = (char *)(v27 + (v26 >> 4));
        if (v15 < v32)
          v32 = v15;
        if (v32 < v7)
          v32 = v7;
        v33 = *(_QWORD *)v32;
        if (v21)
        {
          v34 = (char *)(v27 + v103);
          if (v15 >= v34)
            v35 = v34;
          else
            v35 = v15;
          if (v35 < v7)
            v35 = v7;
          v36 = *(_QWORD *)v35;
          v37 = &v34[v31];
          if (v15 < v37)
            v37 = v15;
          if (v37 < v7)
            v37 = v7;
          v38 = BLEND16_19498[v21];
          v29 = v29 - ((v38 & v29) >> v21) + ((v38 & v36) >> v21);
          v33 = v33 - ((v38 & v33) >> v21) + ((v38 & *(_QWORD *)v37) >> v21);
        }
        v39 = BLEND16_19498[v30];
        v40 = v29 - ((v39 & v29) >> v30);
        v41 = (v39 & v33) >> v30;
LABEL_42:
        v29 = v40 + v41;
        goto LABEL_43;
      }
LABEL_85:
      v11 = v96;
      v9 += v97;
      LOBYTE(v12) = v95;
      v13 = v99 + v94;
      a6 = v100 - 1;
      if (v100 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_85;
    v45 = (uint64_t *)v86;
    v44 = v87;
    while (1)
    {
      v46 = *(v45 - 1);
      v47 = *v45;
      v48 = v22 + v46;
      if ((unint64_t)v15 >= v22 + v46)
        v49 = (char *)(v22 + v46);
      else
        v49 = v15;
      if (v49 < v7)
        v49 = v7;
      v50 = *(_QWORD *)v49;
      v51 = *v45 & 0xF;
      if ((v47 & 0xF) != 0)
        break;
      if (v21)
      {
        v63 = (char *)(v48 + v103);
        if ((unint64_t)v15 < v48 + v103)
          v63 = v15;
        if (v63 < v7)
          v63 = v7;
        v64 = BLEND16_19498[v21];
        v61 = v50 - ((v64 & v50) >> v21);
        v62 = (v64 & *(_QWORD *)v63) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      v65 = ((v50 | v16) >> 32) & 0xFF000000;
      v66 = BYTE5(v50) | (BYTE1(v50) << 16) | (BYTE3(v50) << 8);
      v67 = v66 | v65;
      if (v6 != 255)
      {
        result = PDM_13345(v66 | v65, v6);
        v67 = result;
      }
      if (HIBYTE(v67))
      {
        if (HIBYTE(v67) == 255)
          *v9 = v67;
        else
          result = (unint64_t)DplusDM_13347(v9, v67, *v9, ~v67 >> 24);
      }
      v45 += 2;
      ++v9;
      if (!--v44)
        goto LABEL_85;
    }
    v52 = v47 >> 4;
    v53 = (char *)(v48 + (v47 >> 4));
    if (v15 < v53)
      v53 = v15;
    if (v53 < v7)
      v53 = v7;
    v54 = *(_QWORD *)v53;
    if (v21)
    {
      v55 = (char *)(v48 + v103);
      if (v15 >= v55)
        v56 = v55;
      else
        v56 = v15;
      if (v56 < v7)
        v56 = v7;
      v57 = *(_QWORD *)v56;
      v58 = &v55[v52];
      if (v15 < v58)
        v58 = v15;
      if (v58 < v7)
        v58 = v7;
      v59 = BLEND16_19498[v21];
      v50 = v50 - ((v59 & v50) >> v21) + ((v59 & v57) >> v21);
      v54 = v54 - ((v59 & v54) >> v21) + ((v59 & *(_QWORD *)v58) >> v21);
    }
    v60 = BLEND16_19498[v51];
    v61 = v50 - ((v60 & v50) >> v51);
    v62 = (v60 & v54) >> v51;
LABEL_77:
    v50 = v61 + v62;
    goto LABEL_78;
  }
  v104 = (uint64_t *)(v10 + 16 * a3);
  v68 = v14 - 8;
  v69 = v8 << 48;
  v101 = a5;
  do
  {
    v70 = *(char **)(v102 + 32);
    v71 = &v70[(v13 >> v12) * v11];
    if (v98 == 1)
    {
      v72 = v13;
      v73 = a6;
      if (a5 >= 1)
      {
        v74 = v104;
        v75 = v101;
        do
        {
          v76 = *v74;
          v74 += 2;
          v77 = &v71[v76];
          if (v68 < &v71[v76])
            v77 = v68;
          if (v77 < v70)
            v77 = v70;
          result = ((unsigned __int16)WORD2(*(_QWORD *)v77) >> 8) | (BYTE1(*(_QWORD *)v77) << 16) | (BYTE3(*(_QWORD *)v77) << 8) | ((*(_QWORD *)v77 | (unint64_t)v69) >> 32) & 0xFF000000;
          if (v6 != 255)
            result = PDM_13345(result, v6);
          *v9++ = result;
          --v75;
        }
        while (v75);
      }
    }
    else
    {
      v72 = v13;
      v73 = a6;
      v78 = v104;
      v79 = v101;
      if (a5 >= 1)
      {
        do
        {
          v80 = *v78;
          v78 += 2;
          v81 = &v71[v80];
          if (v68 < &v71[v80])
            v81 = v68;
          if ((unint64_t)v81 < *(_QWORD *)(v102 + 32))
            v81 = *(char **)(v102 + 32);
          v82 = *(_QWORD *)v81;
          v83 = ((v82 | (unint64_t)v69) >> 32) & 0xFF000000;
          v84 = BYTE5(v82) | (BYTE1(v82) << 16) | (BYTE3(v82) << 8);
          v85 = v84 | v83;
          if (v6 != 255)
          {
            result = PDM_13345(v84 | v83, v6);
            v85 = result;
          }
          if (HIBYTE(v85))
          {
            if (HIBYTE(v85) == 255)
              *v9 = v85;
            else
              result = (unint64_t)DplusDM_13347(v9, v85, *v9, ~v85 >> 24);
          }
          ++v9;
          --v79;
        }
        while (v79);
      }
    }
    v11 = v96;
    v9 += v97;
    LOBYTE(v12) = v95;
    v13 = v72 + v94;
    a6 = v73 - 1;
  }
  while (v73 != 1);
  return result;
}

_DWORD *DplusDAM(_DWORD *result, unsigned int a2, int a3, int a4, int a5)
{
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;

  v5 = (BYTE1(a3) | (a4 << 16)) * a5 + 8388736;
  v6 = (((v5 >> 8) & 0xFF00FF) + v5) & 0xFF00FF00 | ((((((a3 & 0xFF00FFu) * a5 + 8388736) >> 8) & 0xFF00FF)
                                                    + (a3 & 0xFF00FF) * a5
                                                    + 8388736) >> 8) & 0xFF00FF;
  v7 = (((v6 | (unint64_t)(v6 << 40)) >> 8) & 0xFF00FF00FF00FFLL)
     + (((a2 | ((unint64_t)a2 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  *result = ((((v7 & 0x100010001000100) - ((v7 & 0x100010001000100) >> 8)) | v7) & 0xFF00FF00FF00FFLL | (((((v7 & 0x100010001000100) - ((v7 & 0x100010001000100) >> 8)) | v7) & 0xFF00FF00FF00FFLL) << 40)) >> 32;
  return result;
}

_DWORD *DAM(_DWORD *result, int a2, unsigned __int8 a3, int a4)
{
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  v4 = a2 & 0xFF00FF;
  v5 = a2 & 0xFFFFFF | (a3 << 24);
  v6 = ((v5 >> 8) & 0xFF00FF) * (a4 ^ 0xFF) + 8388736;
  v7 = (((v6 >> 8) & 0xFF00FF) + v6) & 0xFF00FF00 | (((((v4 * (a4 ^ 0xFFu) + 8388736) >> 8) & 0xFF00FF)
                                                    + v4 * (a4 ^ 0xFF)
                                                    + 8388736) >> 8) & 0xFF00FF;
  v8 = (((v5 | (unint64_t)(v5 << 40)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
     - (((v7 | (unint64_t)(v7 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  *result = (((v8 & 0x100010001000100) - ((v8 & 0x100010001000100uLL) >> 8)) & v8 | ((((v8 & 0x100010001000100)
                                                                                       - ((v8 & 0x100010001000100uLL) >> 8)) & v8) << 40)) >> 32;
  return result;
}

unint64_t argb32_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int *v36;
  uint64_t v37;
  unsigned int *v38;
  uint64_t v39;
  BOOL v40;
  int v41;
  int v42;
  unint64_t v43;
  uint64_t v44;
  unsigned int *v45;
  unsigned int *v46;
  uint64_t v47;
  unsigned int *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unint64_t v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int *v61;
  uint64_t v62;
  unsigned int *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  unint64_t v73;
  uint64_t v74;
  unsigned int *v75;
  unsigned int *v76;
  uint64_t v77;
  unsigned int *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unsigned int v86;
  unsigned int v87;
  unint64_t v88;
  uint64_t v89;
  unsigned int *v90;
  unsigned int *v91;
  uint64_t v92;
  unsigned int *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unsigned int v100;
  unint64_t v101;
  uint64_t v102;
  unsigned int *v103;
  unsigned int *v104;
  uint64_t v105;
  unsigned int *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unsigned int v113;
  unsigned int v114;
  unint64_t v115;
  uint64_t v116;
  unsigned int *v117;
  unsigned int *v118;
  uint64_t v119;
  unsigned int *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  int v127;
  unsigned int v128;
  unint64_t v129;
  uint64_t v130;
  unsigned int *v131;
  unsigned int *v132;
  uint64_t v133;
  unsigned int *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  int v141;
  unsigned int v142;
  unint64_t v143;
  uint64_t v144;
  unsigned int *v145;
  unsigned int *v146;
  uint64_t v147;
  unsigned int *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  int v154;
  char v155;
  unsigned int v156;
  unint64_t v157;
  uint64_t v158;
  unsigned int *v159;
  unsigned int *v160;
  uint64_t v161;
  unsigned int *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  unsigned int v169;
  unint64_t v170;
  uint64_t v171;
  unsigned int *v172;
  unsigned int *v173;
  uint64_t v174;
  unsigned int *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  int v180;
  int v181;
  unsigned int v182;
  unsigned int v183;
  int v184;
  unint64_t v185;
  uint64_t v186;
  unsigned int *v187;
  unsigned int *v188;
  uint64_t v189;
  unsigned int *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  unsigned int v196;
  unsigned int v197;
  unsigned int v198;
  int v199;
  unint64_t v200;
  uint64_t v201;
  unsigned int *v202;
  unsigned int *v203;
  uint64_t v204;
  unsigned int *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  int v210;
  unsigned int v211;
  int v212;
  unsigned int v213;
  int v214;
  unint64_t v215;
  uint64_t v216;
  unsigned int *v217;
  unsigned int *v218;
  uint64_t v219;
  unsigned int *v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  int v225;
  unsigned int v226;
  int v227;
  unsigned int v228;
  int v229;
  unint64_t v230;
  uint64_t v231;
  unsigned int *v232;
  unsigned int *v233;
  uint64_t v234;
  unsigned int *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  int v240;
  unsigned int v241;
  int v242;
  unsigned int v243;
  int v244;
  unint64_t v245;
  uint64_t v246;
  unsigned int *v247;
  unsigned int *v248;
  uint64_t v249;
  unsigned int *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  int v255;
  unsigned int v256;
  unsigned int v257;
  unsigned int v258;
  int v259;
  unint64_t v260;
  uint64_t v261;
  unsigned int *v262;
  unsigned int *v263;
  uint64_t v264;
  unsigned int *v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  int v270;
  unsigned int v271;
  unsigned int v272;
  unsigned int v273;
  int v274;
  unint64_t v275;
  uint64_t v276;
  unsigned int *v277;
  unsigned int *v278;
  uint64_t v279;
  unsigned int *v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  int v285;
  unsigned int v286;
  int v287;
  unsigned int v288;
  int v289;
  unint64_t v290;
  uint64_t v291;
  unsigned int *v292;
  unsigned int *v293;
  uint64_t v294;
  unsigned int *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  int v300;
  unsigned int v301;
  int v302;
  unsigned int v303;
  int v304;
  unint64_t v305;
  uint64_t v306;
  unsigned int *v307;
  unsigned int *v308;
  uint64_t v309;
  unsigned int *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  int v315;
  unsigned int v316;
  int v317;
  unsigned int v318;
  int v319;
  unint64_t v320;
  uint64_t v321;
  unsigned int *v322;
  unsigned int *v323;
  uint64_t v324;
  unsigned int *v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  int v330;
  unsigned int v331;
  int v332;
  unsigned int v333;
  int v334;
  unint64_t v335;
  uint64_t v336;
  unsigned int *v337;
  unsigned int *v338;
  uint64_t v339;
  unsigned int *v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  int v345;
  unsigned int v346;
  unsigned __int32 v347;
  unsigned int v348;
  int v349;
  unint64_t v350;
  uint64_t v351;
  unsigned int *v352;
  unsigned int *v353;
  uint64_t v354;
  unsigned int *v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  int v360;
  unsigned int v361;
  int v362;
  unsigned int v363;
  int v364;
  unint64_t v365;
  uint64_t v366;
  unsigned int *v367;
  unsigned int *v368;
  uint64_t v369;
  unsigned int *v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  int v375;
  unsigned int v376;
  int v377;
  unsigned int v378;
  int v379;
  unint64_t v380;
  uint64_t v381;
  unsigned int *v382;
  unsigned int *v383;
  uint64_t v384;
  unsigned int *v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  int v390;
  unsigned int v391;
  int v392;
  unsigned int v393;
  int v394;
  unint64_t v395;
  uint64_t v396;
  unsigned int *v397;
  unsigned int *v398;
  uint64_t v399;
  unsigned int *v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  int v405;
  unsigned int v406;
  unsigned int v407;
  unsigned int v408;
  unint64_t v409;
  uint64_t v410;
  unsigned int *v411;
  unsigned int *v412;
  uint64_t v413;
  unsigned int *v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  int v419;
  unsigned int v420;
  unsigned int v421;
  unsigned int v422;
  int v423;
  unint64_t v424;
  uint64_t v425;
  unsigned int *v426;
  unsigned int *v427;
  uint64_t v428;
  unsigned int *v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  int v434;
  unsigned int v435;
  int v436;
  unsigned int v437;
  int v438;
  unint64_t v439;
  uint64_t v440;
  unsigned int *v441;
  unsigned int *v442;
  uint64_t v443;
  unsigned int *v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  int v449;
  unsigned int v450;
  int v451;
  unsigned int v452;
  int v453;
  unint64_t v454;
  uint64_t v455;
  unsigned int *v456;
  unsigned int *v457;
  uint64_t v458;
  unsigned int *v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  int v464;
  unsigned int v465;
  unsigned int v466;
  unsigned int v467;
  unint64_t v468;
  uint64_t v469;
  unsigned int *v470;
  unsigned int *v471;
  uint64_t v472;
  unsigned int *v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  int v478;
  unsigned int v479;
  unsigned int v480;
  unsigned int v481;
  int v482;
  unint64_t v483;
  uint64_t v484;
  unsigned int *v485;
  unsigned int *v486;
  uint64_t v487;
  unsigned int *v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  _BOOL4 v510;
  unint64_t v511;
  int v512;
  uint64_t v513;
  unint64_t v514;
  uint64_t v515;
  int v516;
  unsigned int *v517;
  int v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;

  v2 = *(_QWORD *)(result + 136);
  if (v2)
  {
    v516 = *(_DWORD *)(result + 4);
    v3 = v516;
    v518 = *(_DWORD *)(result + 8);
    v519 = *(_QWORD *)(result + 48);
    v4 = *(_QWORD *)(result + 88);
    v5 = *(_QWORD *)(result + 96);
    v6 = (unint64_t)*(int *)(result + 28) >> 2;
    v7 = (unsigned int *)(*(_QWORD *)(result + 40) + 4 * (*(int *)(result + 12) + v6 * *(int *)(result + 16)));
    v8 = *(int *)(result + 124);
    v9 = (char *)(v2 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v8);
    v10 = *(int *)(result + 56);
    v11 = *(int *)(result + 60);
    v12 = *(int *)(result + 76);
    if (*(unsigned __int8 *)(result + 1) << 8 != 256)
    {
      v18 = *(_DWORD *)(result + 64);
      v17 = *(_DWORD *)(result + 68);
      v13 = v12 >> 2;
      v19 = v5 != 0;
      v515 = v8 - v516;
      v514 = v6 - v516;
      if (v4)
      {
        v512 = 0;
        v511 = v4 + 4 * v13 * v17;
        v513 = v13;
        v20 = v4 + 4 * v13 * ((int)v11 % v17);
        v14 = (unsigned int *)(v20 + 4 * ((int)v10 % v18));
        v21 = v20 + 4 * v18;
        v16 = 1;
        v517 = v14;
LABEL_16:
        switch(a2)
        {
          case 0:
            v22 = v16;
            v23 = 4 * v16;
            do
            {
              v24 = v516;
              do
              {
                v25 = *v9;
                if (*v9)
                {
                  if (v25 == 255)
                    result = 0;
                  else
                    result = PDM_13345(*v7, v25 ^ 0xFFu);
                  *v7 = result;
                }
                v9 += v22;
                v7 = (unsigned int *)((char *)v7 + v23);
                --v24;
              }
              while (v24);
              v9 += v515;
              v7 += v514;
              --v518;
            }
            while (v518);
            return result;
          case 1:
            if (v519)
              v26 = v19;
            else
              v26 = 1;
            v27 = v16;
            v28 = -(uint64_t)v18;
            v29 = -(v513 * v17);
            v30 = 4 * v16;
            if ((v26 & 1) != 0)
            {
              do
              {
                v31 = v516;
                do
                {
                  v32 = *v9;
                  if (*v9)
                  {
                    if (v32 == 255)
                      *v7 = *v14;
                    else
                      result = (unint64_t)DMplusDM_13346(v7, *v14, v32, *v7, v32 ^ 0xFFu);
                  }
                  v9 += v27;
                  v33 = (unint64_t)&v14[v27];
                  if (v33 >= v21)
                    v34 = v28;
                  else
                    v34 = 0;
                  v14 = (unsigned int *)(v33 + 4 * v34);
                  v7 = (unsigned int *)((char *)v7 + v30);
                  --v31;
                }
                while (v31);
                v9 += v515;
                v7 += v514;
                v35 = v517;
                v36 = &v517[v513];
                if ((unint64_t)v36 >= v511)
                  v37 = v29;
                else
                  v37 = 0;
                v38 = &v36[v37];
                v39 = v21 + 4 * v37 + 4 * v513;
                if (v512)
                {
                  v14 += v513;
                }
                else
                {
                  v21 = v39;
                  v35 = v38;
                  v14 = v38;
                }
                v40 = v518 == 1;
                v517 = v35;
                --v518;
              }
              while (!v40);
            }
            else
            {
              do
              {
                v41 = v516;
                do
                {
                  v42 = *v9;
                  if (*v9)
                  {
                    if (v42 == 255)
                      *v7 = *v14 | 0xFF000000;
                    else
                      result = (unint64_t)DMplusDAM(v7, *v7, v42 ^ 0xFFu, *v14, 255, v42);
                  }
                  v9 += v27;
                  v43 = (unint64_t)&v14[v27];
                  if (v43 >= v21)
                    v44 = v28;
                  else
                    v44 = 0;
                  v14 = (unsigned int *)(v43 + 4 * v44);
                  v7 = (unsigned int *)((char *)v7 + v30);
                  --v41;
                }
                while (v41);
                v9 += v515;
                v7 += v514;
                v45 = v517;
                v46 = &v517[v513];
                if ((unint64_t)v46 >= v511)
                  v47 = v29;
                else
                  v47 = 0;
                v48 = &v46[v47];
                v49 = v21 + 4 * v47 + 4 * v513;
                if (v512)
                {
                  v14 += v513;
                }
                else
                {
                  v21 = v49;
                  v45 = v48;
                  v14 = v48;
                }
                v40 = v518 == 1;
                v517 = v45;
                --v518;
              }
              while (!v40);
            }
            return result;
          case 2:
            v50 = v16;
            v51 = -(uint64_t)v18;
            v52 = -(v513 * v17);
            v53 = 4 * v16;
            while (1)
            {
              v54 = v516;
              do
              {
                v55 = *v9;
                if (!*v9)
                  goto LABEL_78;
                if (v55 == 255)
                {
                  v56 = *v14;
                  v57 = HIBYTE(*v14);
                  if (!v57)
                    goto LABEL_78;
                  if (v57 == 255)
                  {
                    *v7 = v56;
                    goto LABEL_78;
                  }
                }
                else
                {
                  result = PDM_13345(*v14, v55);
                  if (!BYTE3(result))
                    goto LABEL_78;
                  v56 = result;
                }
                result = (unint64_t)DplusDM_13347(v7, v56, *v7, ~v56 >> 24);
LABEL_78:
                v9 += v50;
                v58 = (unint64_t)&v14[v50];
                if (v58 >= v21)
                  v59 = v51;
                else
                  v59 = 0;
                v14 = (unsigned int *)(v58 + 4 * v59);
                v7 = (unsigned int *)((char *)v7 + v53);
                --v54;
              }
              while (v54);
              v9 += v515;
              v7 += v514;
              v60 = v517;
              v61 = &v517[v513];
              if ((unint64_t)v61 >= v511)
                v62 = v52;
              else
                v62 = 0;
              v63 = &v61[v62];
              v64 = v21 + 4 * v62 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v64;
                v60 = v63;
                v14 = v63;
              }
              v40 = v518 == 1;
              v517 = v60;
              --v518;
              if (v40)
                return result;
            }
          case 3:
            v65 = v16;
            v66 = -(uint64_t)v18;
            v67 = -(v513 * v17);
            v68 = 4 * v16;
            do
            {
              v69 = v516;
              do
              {
                v70 = *v9;
                if (*v9)
                {
                  if (v70 == 255)
                  {
                    v71 = HIBYTE(*v14);
                    if (!v19)
                      LOBYTE(v71) = -1;
                    result = (unint64_t)DAM(v7, *v14, v71, *((unsigned __int8 *)v7 + 3));
                  }
                  else
                  {
                    v72 = HIBYTE(*v14);
                    if (!v19)
                      LOBYTE(v72) = -1;
                    result = (unint64_t)DMplusDAM(v7, *v7, v70 ^ 0xFFu, *v14, v72, ((unsigned __int16)(HIBYTE(*v7) * v70+ 128+ ((HIBYTE(*v7) * v70 + 128) >> 8)) >> 8));
                  }
                }
                v9 += v65;
                v73 = (unint64_t)&v14[v65];
                if (v73 >= v21)
                  v74 = v66;
                else
                  v74 = 0;
                v14 = (unsigned int *)(v73 + 4 * v74);
                v7 = (unsigned int *)((char *)v7 + v68);
                --v69;
              }
              while (v69);
              v9 += v515;
              v7 += v514;
              v75 = v517;
              v76 = &v517[v513];
              if ((unint64_t)v76 >= v511)
                v77 = v67;
              else
                v77 = 0;
              v78 = &v76[v77];
              v79 = v21 + 4 * v77 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v79;
                v75 = v78;
                v14 = v78;
              }
              v40 = v518 == 1;
              v517 = v75;
              --v518;
            }
            while (!v40);
            return result;
          case 4:
            v80 = v16;
            v81 = -(uint64_t)v18;
            v82 = -(v513 * v17);
            v83 = 4 * v16;
            do
            {
              v84 = v516;
              do
              {
                v85 = *v9;
                if (*v9)
                {
                  if (v85 == 255)
                  {
                    v86 = HIBYTE(*v14);
                    if (!v19)
                      LOBYTE(v86) = -1;
                    result = (unint64_t)DAM(v7, *v14, v86, *((unsigned __int8 *)v7 + 3) ^ 0xFFu);
                  }
                  else
                  {
                    v87 = HIBYTE(*v14);
                    if (!v19)
                      LOBYTE(v87) = -1;
                    result = (unint64_t)DMplusDAM(v7, *v7, v85 ^ 0xFFu, *v14, v87, ((unsigned __int16)((~*v7 >> 24) * v85+ 128+ (((~*v7 >> 24) * v85 + 128) >> 8)) >> 8));
                  }
                }
                v9 += v80;
                v88 = (unint64_t)&v14[v80];
                if (v88 >= v21)
                  v89 = v81;
                else
                  v89 = 0;
                v14 = (unsigned int *)(v88 + 4 * v89);
                v7 = (unsigned int *)((char *)v7 + v83);
                --v84;
              }
              while (v84);
              v9 += v515;
              v7 += v514;
              v90 = v517;
              v91 = &v517[v513];
              if ((unint64_t)v91 >= v511)
                v92 = v82;
              else
                v92 = 0;
              v93 = &v91[v92];
              v94 = v21 + 4 * v92 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v94;
                v90 = v93;
                v14 = v93;
              }
              v40 = v518 == 1;
              v517 = v90;
              --v518;
            }
            while (!v40);
            return result;
          case 5:
            v95 = v16;
            v96 = -(uint64_t)v18;
            v97 = -(v513 * v17);
            v98 = 4 * v16;
            do
            {
              v99 = v516;
              do
              {
                if (*v9)
                {
                  v100 = PDM_13345(*v14, *v9);
                  result = (unint64_t)DMplusDM_13346(v7, v100, HIBYTE(*v7), *v7, ~v100 >> 24);
                }
                v9 += v95;
                v101 = (unint64_t)&v14[v95];
                if (v101 >= v21)
                  v102 = v96;
                else
                  v102 = 0;
                v14 = (unsigned int *)(v101 + 4 * v102);
                v7 = (unsigned int *)((char *)v7 + v98);
                --v99;
              }
              while (v99);
              v9 += v515;
              v7 += v514;
              v103 = v517;
              v104 = &v517[v513];
              if ((unint64_t)v104 >= v511)
                v105 = v97;
              else
                v105 = 0;
              v106 = &v104[v105];
              v107 = v21 + 4 * v105 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v107;
                v103 = v106;
                v14 = v106;
              }
              v40 = v518 == 1;
              v517 = v103;
              --v518;
            }
            while (!v40);
            return result;
          case 6:
            v108 = v16;
            v109 = -(uint64_t)v18;
            v520 = -(v513 * v17);
            v110 = 4 * v16;
            do
            {
              v111 = v516;
              do
              {
                v112 = *v9;
                if (*v9 && ~HIBYTE(*v7))
                {
                  if (~HIBYTE(*v7) == 255)
                  {
                    v113 = HIBYTE(*v14);
                    if (!v19)
                      LOBYTE(v113) = -1;
                    result = (unint64_t)DAM(v7, *v14, v113, v112);
                  }
                  else
                  {
                    v114 = HIBYTE(*v14);
                    if (!v19)
                      LOBYTE(v114) = -1;
                    result = (unint64_t)DplusDAM(v7, *v7, *v14, v114, ((unsigned __int16)(~HIBYTE(*v7)* (_WORD)v112+ 128+ ((~HIBYTE(*v7)* v112+ 128) >> 8)) >> 8));
                  }
                }
                v9 += v108;
                v115 = (unint64_t)&v14[v108];
                if (v115 >= v21)
                  v116 = v109;
                else
                  v116 = 0;
                v14 = (unsigned int *)(v115 + 4 * v116);
                v7 = (unsigned int *)((char *)v7 + v110);
                --v111;
              }
              while (v111);
              v9 += v515;
              v7 += v514;
              v117 = v517;
              v118 = &v517[v513];
              v119 = v520;
              if ((unint64_t)v118 < v511)
                v119 = 0;
              v120 = &v118[v119];
              v121 = v21 + 4 * v119 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v121;
                v117 = v120;
                v14 = v120;
              }
              v40 = v518 == 1;
              v517 = v117;
              --v518;
            }
            while (!v40);
            return result;
          case 7:
            v122 = v16;
            v123 = -(uint64_t)v18;
            v124 = -(v513 * v17);
            v125 = 4 * v16;
            do
            {
              v126 = v516;
              do
              {
                v127 = *v9;
                if (*v9)
                {
                  if (v127 == 255)
                  {
                    result = PDM_13345(*v7, *((unsigned __int8 *)v14 + 3));
                    *v7 = result;
                  }
                  else
                  {
                    v128 = *((unsigned __int8 *)v14 + 3) * v127 + 128;
                    result = (unint64_t)DMplusDM_13346(v7, *v7, ((unsigned __int16)(v128 + (v128 >> 8)) >> 8), *v7, v127 ^ 0xFFu);
                  }
                }
                v9 += v122;
                v129 = (unint64_t)&v14[v122];
                if (v129 >= v21)
                  v130 = v123;
                else
                  v130 = 0;
                v14 = (unsigned int *)(v129 + 4 * v130);
                v7 = (unsigned int *)((char *)v7 + v125);
                --v126;
              }
              while (v126);
              v9 += v515;
              v7 += v514;
              v131 = v517;
              v132 = &v517[v513];
              if ((unint64_t)v132 >= v511)
                v133 = v124;
              else
                v133 = 0;
              v134 = &v132[v133];
              v135 = v21 + 4 * v133 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v135;
                v131 = v134;
                v14 = v134;
              }
              v40 = v518 == 1;
              v517 = v131;
              --v518;
            }
            while (!v40);
            return result;
          case 8:
            v136 = v16;
            v137 = -(uint64_t)v18;
            v138 = -(v513 * v17);
            v139 = 4 * v16;
            do
            {
              v140 = v516;
              do
              {
                v141 = *v9;
                if (*v9)
                {
                  if (v141 == 255)
                    LOBYTE(v142) = *((_BYTE *)v14 + 3);
                  else
                    v142 = (*((unsigned __int8 *)v14 + 3) * v141
                          + 128
                          + ((*((unsigned __int8 *)v14 + 3) * v141 + 128) >> 8)) >> 8;
                  result = PDM_13345(*v7, ~(_BYTE)v142);
                  *v7 = result;
                }
                v9 += v136;
                v143 = (unint64_t)&v14[v136];
                if (v143 >= v21)
                  v144 = v137;
                else
                  v144 = 0;
                v14 = (unsigned int *)(v143 + 4 * v144);
                v7 = (unsigned int *)((char *)v7 + v139);
                --v140;
              }
              while (v140);
              v9 += v515;
              v7 += v514;
              v145 = v517;
              v146 = &v517[v513];
              if ((unint64_t)v146 >= v511)
                v147 = v138;
              else
                v147 = 0;
              v148 = &v146[v147];
              v149 = v21 + 4 * v147 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v149;
                v145 = v148;
                v14 = v148;
              }
              v40 = v518 == 1;
              v517 = v145;
              --v518;
            }
            while (!v40);
            return result;
          case 9:
            v150 = v16;
            v151 = -(uint64_t)v18;
            v152 = -(v513 * v17);
            v153 = 4 * v16;
            do
            {
              v154 = v516;
              do
              {
                v155 = *v9;
                if (*v9)
                {
                  v156 = PDM_13345(*v14, *v9);
                  result = (unint64_t)DMplusDM_13346(v7, v156, ~*v7 >> 24, *v7, (~v155 + HIBYTE(v156)));
                }
                v9 += v150;
                v157 = (unint64_t)&v14[v150];
                if (v157 >= v21)
                  v158 = v151;
                else
                  v158 = 0;
                v14 = (unsigned int *)(v157 + 4 * v158);
                v7 = (unsigned int *)((char *)v7 + v153);
                --v154;
              }
              while (v154);
              v9 += v515;
              v7 += v514;
              v159 = v517;
              v160 = &v517[v513];
              if ((unint64_t)v160 >= v511)
                v161 = v152;
              else
                v161 = 0;
              v162 = &v160[v161];
              v163 = v21 + 4 * v161 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v163;
                v159 = v162;
                v14 = v162;
              }
              v40 = v518 == 1;
              v517 = v159;
              --v518;
            }
            while (!v40);
            return result;
          case 10:
            v164 = v16;
            v165 = -(uint64_t)v18;
            v166 = -(v513 * v17);
            v167 = 4 * v16;
            do
            {
              v168 = v516;
              do
              {
                if (*v9)
                {
                  v169 = PDM_13345(*v14, *v9);
                  result = (unint64_t)DMplusDM_13346(v7, v169, ~*v7 >> 24, *v7, ~v169 >> 24);
                }
                v9 += v164;
                v170 = (unint64_t)&v14[v164];
                if (v170 >= v21)
                  v171 = v165;
                else
                  v171 = 0;
                v14 = (unsigned int *)(v170 + 4 * v171);
                v7 = (unsigned int *)((char *)v7 + v167);
                --v168;
              }
              while (v168);
              v9 += v515;
              v7 += v514;
              v172 = v517;
              v173 = &v517[v513];
              if ((unint64_t)v173 >= v511)
                v174 = v166;
              else
                v174 = 0;
              v175 = &v173[v174];
              v176 = v21 + 4 * v174 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v176;
                v172 = v175;
                v14 = v175;
              }
              v40 = v518 == 1;
              v517 = v172;
              --v518;
            }
            while (!v40);
            return result;
          case 11:
            v177 = v16;
            v178 = -(uint64_t)v18;
            v490 = -(v513 * v17);
            v179 = 4 * v16;
            do
            {
              v180 = v516;
              do
              {
                v181 = *v9;
                if (*v9)
                {
                  v182 = PDM_13345(*v14, *v9);
                  v183 = HIBYTE(*v7);
                  if (!v519)
                    LOBYTE(v183) = -1;
                  if (v19)
                    v184 = HIBYTE(v182);
                  else
                    v184 = v181;
                  result = (unint64_t)DAplusdDA_13348(v7, *v7, v183, v182, v184);
                }
                v9 += v177;
                v185 = (unint64_t)&v14[v177];
                if (v185 >= v21)
                  v186 = v178;
                else
                  v186 = 0;
                v14 = (unsigned int *)(v185 + 4 * v186);
                v7 = (unsigned int *)((char *)v7 + v179);
                --v180;
              }
              while (v180);
              v9 += v515;
              v7 += v514;
              v187 = v517;
              v188 = &v517[v513];
              v189 = v490;
              if ((unint64_t)v188 < v511)
                v189 = 0;
              v190 = &v188[v189];
              v191 = v21 + 4 * v189 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v191;
                v187 = v190;
                v14 = v190;
              }
              v40 = v518 == 1;
              v517 = v187;
              --v518;
            }
            while (!v40);
            return result;
          case 12:
            v192 = v16;
            v193 = -(uint64_t)v18;
            v521 = -(v513 * v17);
            v194 = 4 * v16;
            v510 = v19;
            do
            {
              v195 = v516;
              do
              {
                v196 = *v9;
                if (*v9)
                {
                  result = PDM_13345(*v14, *v9);
                  v197 = *v7;
                  v198 = BYTE3(result);
                  if (!v510)
                    v198 = v196;
                  v199 = ((v197 >> 8) & 0xFF00FF) + BYTE1(result) + (v198 << 16);
                  *v7 = (v199 << 8) & 0xFF00FF00 | ((v197 & 0xFF00FF) + (result & 0xFF00FF)) & 0xFF00FF | (15 * (v199 & 0x1000100 | (((v197 & 0xFF00FF) + (result & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v199 & 0x1000100 | (((v197 & 0xFF00FF) + (result & 0xFF00FF)) >> 8) & 0x10001));
                }
                v9 += v192;
                v200 = (unint64_t)&v14[v192];
                if (v200 >= v21)
                  v201 = v193;
                else
                  v201 = 0;
                v14 = (unsigned int *)(v200 + 4 * v201);
                v7 = (unsigned int *)((char *)v7 + v194);
                --v195;
              }
              while (v195);
              v9 += v515;
              v7 += v514;
              v202 = v517;
              v203 = &v517[v513];
              v204 = v521;
              if ((unint64_t)v203 < v511)
                v204 = 0;
              v205 = &v203[v204];
              v206 = v21 + 4 * v204 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v206;
                v202 = v205;
                v14 = v205;
              }
              v40 = v518 == 1;
              v517 = v202;
              --v518;
            }
            while (!v40);
            return result;
          case 13:
            v207 = v16;
            v208 = -(uint64_t)v18;
            v491 = -(v513 * v17);
            v209 = 4 * v16;
            while (1)
            {
              v210 = v516;
              do
              {
                v211 = *v9;
                if (!*v9)
                  goto LABEL_300;
                result = PDM_13345(*v14, *v9);
                v212 = result;
                if (v19)
                {
                  v211 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_300;
                }
                result = *v7;
                if (!v519)
                {
                  v213 = 255;
LABEL_298:
                  result = PDAmultiplyPDA_13349(result, v213, v212, v211);
                  v214 = result;
                  goto LABEL_299;
                }
                v213 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_298;
                v214 = v212 & 0xFFFFFF | (v211 << 24);
LABEL_299:
                *v7 = v214;
LABEL_300:
                v9 += v207;
                v215 = (unint64_t)&v14[v207];
                if (v215 >= v21)
                  v216 = v208;
                else
                  v216 = 0;
                v14 = (unsigned int *)(v215 + 4 * v216);
                v7 = (unsigned int *)((char *)v7 + v209);
                --v210;
              }
              while (v210);
              v9 += v515;
              v7 += v514;
              v217 = v517;
              v218 = &v517[v513];
              v219 = v491;
              if ((unint64_t)v218 < v511)
                v219 = 0;
              v220 = &v218[v219];
              v221 = v21 + 4 * v219 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v221;
                v217 = v220;
                v14 = v220;
              }
              v40 = v518 == 1;
              v517 = v217;
              --v518;
              if (v40)
                return result;
            }
          case 14:
            v222 = v16;
            v223 = -(uint64_t)v18;
            v492 = -(v513 * v17);
            v224 = 4 * v16;
            while (1)
            {
              v225 = v516;
              do
              {
                v226 = *v9;
                if (!*v9)
                  goto LABEL_323;
                result = PDM_13345(*v14, *v9);
                v227 = result;
                if (v19)
                {
                  v226 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_323;
                }
                result = *v7;
                if (!v519)
                {
                  v228 = 255;
LABEL_321:
                  result = PDAscreenPDA_13350(result, v228, v227, v226);
                  v229 = result;
                  goto LABEL_322;
                }
                v228 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_321;
                v229 = v227 & 0xFFFFFF | (v226 << 24);
LABEL_322:
                *v7 = v229;
LABEL_323:
                v9 += v222;
                v230 = (unint64_t)&v14[v222];
                if (v230 >= v21)
                  v231 = v223;
                else
                  v231 = 0;
                v14 = (unsigned int *)(v230 + 4 * v231);
                v7 = (unsigned int *)((char *)v7 + v224);
                --v225;
              }
              while (v225);
              v9 += v515;
              v7 += v514;
              v232 = v517;
              v233 = &v517[v513];
              v234 = v492;
              if ((unint64_t)v233 < v511)
                v234 = 0;
              v235 = &v233[v234];
              v236 = v21 + 4 * v234 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v236;
                v232 = v235;
                v14 = v235;
              }
              v40 = v518 == 1;
              v517 = v232;
              --v518;
              if (v40)
                return result;
            }
          case 15:
            v237 = v16;
            v238 = -(uint64_t)v18;
            v493 = -(v513 * v17);
            v239 = 4 * v16;
            while (1)
            {
              v240 = v516;
              do
              {
                v241 = *v9;
                if (!*v9)
                  goto LABEL_346;
                result = PDM_13345(*v14, *v9);
                v242 = result;
                if (v19)
                {
                  v241 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_346;
                }
                result = *v7;
                if (!v519)
                {
                  v243 = 255;
LABEL_344:
                  result = PDAoverlayPDA_13351(result, v243, v242, v241);
                  v244 = result;
                  goto LABEL_345;
                }
                v243 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_344;
                v244 = v242 & 0xFFFFFF | (v241 << 24);
LABEL_345:
                *v7 = v244;
LABEL_346:
                v9 += v237;
                v245 = (unint64_t)&v14[v237];
                if (v245 >= v21)
                  v246 = v238;
                else
                  v246 = 0;
                v14 = (unsigned int *)(v245 + 4 * v246);
                v7 = (unsigned int *)((char *)v7 + v239);
                --v240;
              }
              while (v240);
              v9 += v515;
              v7 += v514;
              v247 = v517;
              v248 = &v517[v513];
              v249 = v493;
              if ((unint64_t)v248 < v511)
                v249 = 0;
              v250 = &v248[v249];
              v251 = v21 + 4 * v249 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v251;
                v247 = v250;
                v14 = v250;
              }
              v40 = v518 == 1;
              v517 = v247;
              --v518;
              if (v40)
                return result;
            }
          case 16:
            v252 = v16;
            v253 = -(uint64_t)v18;
            v494 = -(v513 * v17);
            v254 = 4 * v16;
            while (1)
            {
              v255 = v516;
              do
              {
                v256 = *v9;
                if (!*v9)
                  goto LABEL_369;
                result = PDM_13345(*v14, *v9);
                v257 = result;
                if (v19)
                {
                  v256 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_369;
                }
                result = *v7;
                if (!v519)
                {
                  v258 = 255;
LABEL_367:
                  result = PDAdarkenPDA_13353(result, v258, v257, v256);
                  v259 = result;
                  goto LABEL_368;
                }
                v258 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_367;
                v259 = v257 & 0xFFFFFF | (v256 << 24);
LABEL_368:
                *v7 = v259;
LABEL_369:
                v9 += v252;
                v260 = (unint64_t)&v14[v252];
                if (v260 >= v21)
                  v261 = v253;
                else
                  v261 = 0;
                v14 = (unsigned int *)(v260 + 4 * v261);
                v7 = (unsigned int *)((char *)v7 + v254);
                --v255;
              }
              while (v255);
              v9 += v515;
              v7 += v514;
              v262 = v517;
              v263 = &v517[v513];
              v264 = v494;
              if ((unint64_t)v263 < v511)
                v264 = 0;
              v265 = &v263[v264];
              v266 = v21 + 4 * v264 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v266;
                v262 = v265;
                v14 = v265;
              }
              v40 = v518 == 1;
              v517 = v262;
              --v518;
              if (v40)
                return result;
            }
          case 17:
            v267 = v16;
            v268 = -(uint64_t)v18;
            v495 = -(v513 * v17);
            v269 = 4 * v16;
            while (1)
            {
              v270 = v516;
              do
              {
                v271 = *v9;
                if (!*v9)
                  goto LABEL_392;
                result = PDM_13345(*v14, *v9);
                v272 = result;
                if (v19)
                {
                  v271 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_392;
                }
                result = *v7;
                if (!v519)
                {
                  v273 = 255;
LABEL_390:
                  result = PDAlightenPDA_13352(result, v273, v272, v271);
                  v274 = result;
                  goto LABEL_391;
                }
                v273 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_390;
                v274 = v272 & 0xFFFFFF | (v271 << 24);
LABEL_391:
                *v7 = v274;
LABEL_392:
                v9 += v267;
                v275 = (unint64_t)&v14[v267];
                if (v275 >= v21)
                  v276 = v268;
                else
                  v276 = 0;
                v14 = (unsigned int *)(v275 + 4 * v276);
                v7 = (unsigned int *)((char *)v7 + v269);
                --v270;
              }
              while (v270);
              v9 += v515;
              v7 += v514;
              v277 = v517;
              v278 = &v517[v513];
              v279 = v495;
              if ((unint64_t)v278 < v511)
                v279 = 0;
              v280 = &v278[v279];
              v281 = v21 + 4 * v279 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v281;
                v277 = v280;
                v14 = v280;
              }
              v40 = v518 == 1;
              v517 = v277;
              --v518;
              if (v40)
                return result;
            }
          case 18:
            v282 = v16;
            v283 = -(uint64_t)v18;
            v496 = -(v513 * v17);
            v284 = 4 * v16;
            while (1)
            {
              v285 = v516;
              do
              {
                v286 = *v9;
                if (!*v9)
                  goto LABEL_415;
                result = PDM_13345(*v14, *v9);
                v287 = result;
                if (v19)
                {
                  v286 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_415;
                }
                result = *v7;
                if (!v519)
                {
                  v288 = 255;
LABEL_413:
                  result = PDAcolordodgePDA_13354(result, v288, v287, v286);
                  v289 = result;
                  goto LABEL_414;
                }
                v288 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_413;
                v289 = v287 & 0xFFFFFF | (v286 << 24);
LABEL_414:
                *v7 = v289;
LABEL_415:
                v9 += v282;
                v290 = (unint64_t)&v14[v282];
                if (v290 >= v21)
                  v291 = v283;
                else
                  v291 = 0;
                v14 = (unsigned int *)(v290 + 4 * v291);
                v7 = (unsigned int *)((char *)v7 + v284);
                --v285;
              }
              while (v285);
              v9 += v515;
              v7 += v514;
              v292 = v517;
              v293 = &v517[v513];
              v294 = v496;
              if ((unint64_t)v293 < v511)
                v294 = 0;
              v295 = &v293[v294];
              v296 = v21 + 4 * v294 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v296;
                v292 = v295;
                v14 = v295;
              }
              v40 = v518 == 1;
              v517 = v292;
              --v518;
              if (v40)
                return result;
            }
          case 19:
            v297 = v16;
            v298 = -(uint64_t)v18;
            v497 = -(v513 * v17);
            v299 = 4 * v16;
            while (1)
            {
              v300 = v516;
              do
              {
                v301 = *v9;
                if (!*v9)
                  goto LABEL_438;
                result = PDM_13345(*v14, *v9);
                v302 = result;
                if (v19)
                {
                  v301 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_438;
                }
                result = *v7;
                if (!v519)
                {
                  v303 = 255;
LABEL_436:
                  result = PDAcolorburnPDA_13355(result, v303, v302, v301);
                  v304 = result;
                  goto LABEL_437;
                }
                v303 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_436;
                v304 = v302 & 0xFFFFFF | (v301 << 24);
LABEL_437:
                *v7 = v304;
LABEL_438:
                v9 += v297;
                v305 = (unint64_t)&v14[v297];
                if (v305 >= v21)
                  v306 = v298;
                else
                  v306 = 0;
                v14 = (unsigned int *)(v305 + 4 * v306);
                v7 = (unsigned int *)((char *)v7 + v299);
                --v300;
              }
              while (v300);
              v9 += v515;
              v7 += v514;
              v307 = v517;
              v308 = &v517[v513];
              v309 = v497;
              if ((unint64_t)v308 < v511)
                v309 = 0;
              v310 = &v308[v309];
              v311 = v21 + 4 * v309 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v311;
                v307 = v310;
                v14 = v310;
              }
              v40 = v518 == 1;
              v517 = v307;
              --v518;
              if (v40)
                return result;
            }
          case 20:
            v312 = v16;
            v313 = -(uint64_t)v18;
            v498 = -(v513 * v17);
            v314 = 4 * v16;
            while (1)
            {
              v315 = v516;
              do
              {
                v316 = *v9;
                if (!*v9)
                  goto LABEL_461;
                result = PDM_13345(*v14, *v9);
                v317 = result;
                if (v19)
                {
                  v316 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_461;
                }
                result = *v7;
                if (!v519)
                {
                  v318 = 255;
LABEL_459:
                  result = PDAsoftlightPDA_13357(result, v318, v317, v316);
                  v319 = result;
                  goto LABEL_460;
                }
                v318 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_459;
                v319 = v317 & 0xFFFFFF | (v316 << 24);
LABEL_460:
                *v7 = v319;
LABEL_461:
                v9 += v312;
                v320 = (unint64_t)&v14[v312];
                if (v320 >= v21)
                  v321 = v313;
                else
                  v321 = 0;
                v14 = (unsigned int *)(v320 + 4 * v321);
                v7 = (unsigned int *)((char *)v7 + v314);
                --v315;
              }
              while (v315);
              v9 += v515;
              v7 += v514;
              v322 = v517;
              v323 = &v517[v513];
              v324 = v498;
              if ((unint64_t)v323 < v511)
                v324 = 0;
              v325 = &v323[v324];
              v326 = v21 + 4 * v324 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v326;
                v322 = v325;
                v14 = v325;
              }
              v40 = v518 == 1;
              v517 = v322;
              --v518;
              if (v40)
                return result;
            }
          case 21:
            v327 = v16;
            v328 = -(uint64_t)v18;
            v499 = -(v513 * v17);
            v329 = 4 * v16;
            while (1)
            {
              v330 = v516;
              do
              {
                v331 = *v9;
                if (!*v9)
                  goto LABEL_484;
                result = PDM_13345(*v14, *v9);
                v332 = result;
                if (v19)
                {
                  v331 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_484;
                }
                result = *v7;
                if (!v519)
                {
                  v333 = 255;
LABEL_482:
                  result = PDAhardlightPDA_13356(result, v333, v332, v331);
                  v334 = result;
                  goto LABEL_483;
                }
                v333 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_482;
                v334 = v332 & 0xFFFFFF | (v331 << 24);
LABEL_483:
                *v7 = v334;
LABEL_484:
                v9 += v327;
                v335 = (unint64_t)&v14[v327];
                if (v335 >= v21)
                  v336 = v328;
                else
                  v336 = 0;
                v14 = (unsigned int *)(v335 + 4 * v336);
                v7 = (unsigned int *)((char *)v7 + v329);
                --v330;
              }
              while (v330);
              v9 += v515;
              v7 += v514;
              v337 = v517;
              v338 = &v517[v513];
              v339 = v499;
              if ((unint64_t)v338 < v511)
                v339 = 0;
              v340 = &v338[v339];
              v341 = v21 + 4 * v339 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v341;
                v337 = v340;
                v14 = v340;
              }
              v40 = v518 == 1;
              v517 = v337;
              --v518;
              if (v40)
                return result;
            }
          case 22:
            v342 = v16;
            v343 = -(uint64_t)v18;
            v500 = -(v513 * v17);
            v344 = 4 * v16;
            while (1)
            {
              v345 = v516;
              do
              {
                v346 = *v9;
                if (!*v9)
                  goto LABEL_507;
                result = PDM_13345(*v14, *v9);
                v347 = result;
                if (v19)
                {
                  v346 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_507;
                }
                result = *v7;
                if (!v519)
                {
                  v348 = 255;
LABEL_505:
                  result = PDAdifferencePDA_13358(result, v348, v347, v346);
                  v349 = result;
                  goto LABEL_506;
                }
                v348 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_505;
                v349 = v347 & 0xFFFFFF | (v346 << 24);
LABEL_506:
                *v7 = v349;
LABEL_507:
                v9 += v342;
                v350 = (unint64_t)&v14[v342];
                if (v350 >= v21)
                  v351 = v343;
                else
                  v351 = 0;
                v14 = (unsigned int *)(v350 + 4 * v351);
                v7 = (unsigned int *)((char *)v7 + v344);
                --v345;
              }
              while (v345);
              v9 += v515;
              v7 += v514;
              v352 = v517;
              v353 = &v517[v513];
              v354 = v500;
              if ((unint64_t)v353 < v511)
                v354 = 0;
              v355 = &v353[v354];
              v356 = v21 + 4 * v354 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v356;
                v352 = v355;
                v14 = v355;
              }
              v40 = v518 == 1;
              v517 = v352;
              --v518;
              if (v40)
                return result;
            }
          case 23:
            v357 = v16;
            v358 = -(uint64_t)v18;
            v501 = -(v513 * v17);
            v359 = 4 * v16;
            while (1)
            {
              v360 = v516;
              do
              {
                v361 = *v9;
                if (!*v9)
                  goto LABEL_530;
                result = PDM_13345(*v14, *v9);
                v362 = result;
                if (v19)
                {
                  v361 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_530;
                }
                result = *v7;
                if (!v519)
                {
                  v363 = 255;
LABEL_528:
                  result = PDAexclusionPDA_13359(result, v363, v362, v361);
                  v364 = result;
                  goto LABEL_529;
                }
                v363 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_528;
                v364 = v362 & 0xFFFFFF | (v361 << 24);
LABEL_529:
                *v7 = v364;
LABEL_530:
                v9 += v357;
                v365 = (unint64_t)&v14[v357];
                if (v365 >= v21)
                  v366 = v358;
                else
                  v366 = 0;
                v14 = (unsigned int *)(v365 + 4 * v366);
                v7 = (unsigned int *)((char *)v7 + v359);
                --v360;
              }
              while (v360);
              v9 += v515;
              v7 += v514;
              v367 = v517;
              v368 = &v517[v513];
              v369 = v501;
              if ((unint64_t)v368 < v511)
                v369 = 0;
              v370 = &v368[v369];
              v371 = v21 + 4 * v369 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v371;
                v367 = v370;
                v14 = v370;
              }
              v40 = v518 == 1;
              v517 = v367;
              --v518;
              if (v40)
                return result;
            }
          case 24:
            v372 = v16;
            v373 = -(uint64_t)v18;
            v502 = -(v513 * v17);
            v374 = 4 * v16;
            while (1)
            {
              v375 = v516;
              do
              {
                v376 = *v9;
                if (!*v9)
                  goto LABEL_553;
                result = PDM_13345(*v14, *v9);
                v377 = result;
                if (v19)
                {
                  v376 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_553;
                }
                result = *v7;
                if (!v519)
                {
                  v378 = 255;
LABEL_551:
                  result = PDAhuePDA_13360(result, v378, v377, v376);
                  v379 = result;
                  goto LABEL_552;
                }
                v378 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_551;
                v379 = v377 & 0xFFFFFF | (v376 << 24);
LABEL_552:
                *v7 = v379;
LABEL_553:
                v9 += v372;
                v380 = (unint64_t)&v14[v372];
                if (v380 >= v21)
                  v381 = v373;
                else
                  v381 = 0;
                v14 = (unsigned int *)(v380 + 4 * v381);
                v7 = (unsigned int *)((char *)v7 + v374);
                --v375;
              }
              while (v375);
              v9 += v515;
              v7 += v514;
              v382 = v517;
              v383 = &v517[v513];
              v384 = v502;
              if ((unint64_t)v383 < v511)
                v384 = 0;
              v385 = &v383[v384];
              v386 = v21 + 4 * v384 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v386;
                v382 = v385;
                v14 = v385;
              }
              v40 = v518 == 1;
              v517 = v382;
              --v518;
              if (v40)
                return result;
            }
          case 25:
            v387 = v16;
            v388 = -(uint64_t)v18;
            v503 = -(v513 * v17);
            v389 = 4 * v16;
            while (1)
            {
              v390 = v516;
              do
              {
                v391 = *v9;
                if (!*v9)
                  goto LABEL_576;
                result = PDM_13345(*v14, *v9);
                v392 = result;
                if (v19)
                {
                  v391 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_576;
                }
                result = *v7;
                if (!v519)
                {
                  v393 = 255;
LABEL_574:
                  result = PDAsaturationPDA_13361(result, v393, v392, v391);
                  v394 = result;
                  goto LABEL_575;
                }
                v393 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_574;
                v394 = v392 & 0xFFFFFF | (v391 << 24);
LABEL_575:
                *v7 = v394;
LABEL_576:
                v9 += v387;
                v395 = (unint64_t)&v14[v387];
                if (v395 >= v21)
                  v396 = v388;
                else
                  v396 = 0;
                v14 = (unsigned int *)(v395 + 4 * v396);
                v7 = (unsigned int *)((char *)v7 + v389);
                --v390;
              }
              while (v390);
              v9 += v515;
              v7 += v514;
              v397 = v517;
              v398 = &v517[v513];
              v399 = v503;
              if ((unint64_t)v398 < v511)
                v399 = 0;
              v400 = &v398[v399];
              v401 = v21 + 4 * v399 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v401;
                v397 = v400;
                v14 = v400;
              }
              v40 = v518 == 1;
              v517 = v397;
              --v518;
              if (v40)
                return result;
            }
          case 26:
            v402 = v16;
            v403 = -(uint64_t)v18;
            v504 = -(v513 * v17);
            v404 = 4 * v16;
            while (1)
            {
              v405 = v516;
              do
              {
                v406 = *v9;
                if (!*v9)
                  goto LABEL_599;
                result = PDM_13345(*v14, *v9);
                if (v19)
                {
                  v406 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_599;
                }
                v407 = *v7;
                if (!v519)
                {
                  v408 = 255;
LABEL_597:
                  result = PDAluminosityPDA_13362(result, v406, v407, v408);
                  goto LABEL_598;
                }
                v408 = HIBYTE(v407);
                if (HIBYTE(v407))
                  goto LABEL_597;
                result = result & 0xFFFFFF | (v406 << 24);
LABEL_598:
                *v7 = result;
LABEL_599:
                v9 += v402;
                v409 = (unint64_t)&v14[v402];
                if (v409 >= v21)
                  v410 = v403;
                else
                  v410 = 0;
                v14 = (unsigned int *)(v409 + 4 * v410);
                v7 = (unsigned int *)((char *)v7 + v404);
                --v405;
              }
              while (v405);
              v9 += v515;
              v7 += v514;
              v411 = v517;
              v412 = &v517[v513];
              v413 = v504;
              if ((unint64_t)v412 < v511)
                v413 = 0;
              v414 = &v412[v413];
              v415 = v21 + 4 * v413 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v415;
                v411 = v414;
                v14 = v414;
              }
              v40 = v518 == 1;
              v517 = v411;
              --v518;
              if (v40)
                return result;
            }
          case 27:
            v416 = v16;
            v417 = -(uint64_t)v18;
            v505 = -(v513 * v17);
            v418 = 4 * v16;
            while (1)
            {
              v419 = v516;
              do
              {
                v420 = *v9;
                if (!*v9)
                  goto LABEL_622;
                result = PDM_13345(*v14, *v9);
                v421 = result;
                if (v19)
                {
                  v420 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_622;
                }
                result = *v7;
                if (!v519)
                {
                  v422 = 255;
LABEL_620:
                  result = PDAluminosityPDA_13362(result, v422, v421, v420);
                  v423 = result;
                  goto LABEL_621;
                }
                v422 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_620;
                v423 = v421 & 0xFFFFFF | (v420 << 24);
LABEL_621:
                *v7 = v423;
LABEL_622:
                v9 += v416;
                v424 = (unint64_t)&v14[v416];
                if (v424 >= v21)
                  v425 = v417;
                else
                  v425 = 0;
                v14 = (unsigned int *)(v424 + 4 * v425);
                v7 = (unsigned int *)((char *)v7 + v418);
                --v419;
              }
              while (v419);
              v9 += v515;
              v7 += v514;
              v426 = v517;
              v427 = &v517[v513];
              v428 = v505;
              if ((unint64_t)v427 < v511)
                v428 = 0;
              v429 = &v427[v428];
              v430 = v21 + 4 * v428 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v430;
                v426 = v429;
                v14 = v429;
              }
              v40 = v518 == 1;
              v517 = v426;
              --v518;
              if (v40)
                return result;
            }
          case 28:
            v431 = v16;
            v432 = -(uint64_t)v18;
            v506 = -(v513 * v17);
            v433 = 4 * v16;
            while (1)
            {
              v434 = v516;
              do
              {
                v435 = *v9;
                if (!*v9)
                  goto LABEL_645;
                result = PDM_13345(*v14, *v9);
                v436 = result;
                if (v19)
                {
                  v435 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_645;
                }
                result = *v7;
                if (!v519)
                {
                  v437 = 255;
LABEL_643:
                  result = PDAtranspose_huePDA_13363(result, v437, v436, v435);
                  v438 = result;
                  goto LABEL_644;
                }
                v437 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_643;
                v438 = v436 & 0xFFFFFF | (v435 << 24);
LABEL_644:
                *v7 = v438;
LABEL_645:
                v9 += v431;
                v439 = (unint64_t)&v14[v431];
                if (v439 >= v21)
                  v440 = v432;
                else
                  v440 = 0;
                v14 = (unsigned int *)(v439 + 4 * v440);
                v7 = (unsigned int *)((char *)v7 + v433);
                --v434;
              }
              while (v434);
              v9 += v515;
              v7 += v514;
              v441 = v517;
              v442 = &v517[v513];
              v443 = v506;
              if ((unint64_t)v442 < v511)
                v443 = 0;
              v444 = &v442[v443];
              v445 = v21 + 4 * v443 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v445;
                v441 = v444;
                v14 = v444;
              }
              v40 = v518 == 1;
              v517 = v441;
              --v518;
              if (v40)
                return result;
            }
          case 29:
            v446 = v16;
            v447 = -(uint64_t)v18;
            v507 = -(v513 * v17);
            v448 = 4 * v16;
            while (1)
            {
              v449 = v516;
              do
              {
                v450 = *v9;
                if (!*v9)
                  goto LABEL_668;
                result = PDM_13345(*v14, *v9);
                v451 = result;
                if (v19)
                {
                  v450 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_668;
                }
                result = *v7;
                if (!v519)
                {
                  v452 = 255;
LABEL_666:
                  result = PDAtranspose_saturationPDA_13364(result, v452, v451, v450);
                  v453 = result;
                  goto LABEL_667;
                }
                v452 = BYTE3(result);
                if (BYTE3(result))
                  goto LABEL_666;
                v453 = v451 & 0xFFFFFF | (v450 << 24);
LABEL_667:
                *v7 = v453;
LABEL_668:
                v9 += v446;
                v454 = (unint64_t)&v14[v446];
                if (v454 >= v21)
                  v455 = v447;
                else
                  v455 = 0;
                v14 = (unsigned int *)(v454 + 4 * v455);
                v7 = (unsigned int *)((char *)v7 + v448);
                --v449;
              }
              while (v449);
              v9 += v515;
              v7 += v514;
              v456 = v517;
              v457 = &v517[v513];
              v458 = v507;
              if ((unint64_t)v457 < v511)
                v458 = 0;
              v459 = &v457[v458];
              v460 = v21 + 4 * v458 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v460;
                v456 = v459;
                v14 = v459;
              }
              v40 = v518 == 1;
              v517 = v456;
              --v518;
              if (v40)
                return result;
            }
          case 30:
            v461 = v16;
            v462 = -(uint64_t)v18;
            v508 = -(v513 * v17);
            v463 = 4 * v16;
            while (1)
            {
              v464 = v516;
              do
              {
                v465 = *v9;
                if (!*v9)
                  goto LABEL_691;
                result = PDM_13345(*v14, *v9);
                if (v19)
                {
                  v465 = BYTE3(result);
                  if (!BYTE3(result))
                    goto LABEL_691;
                }
                v466 = *v7;
                if (!v519)
                {
                  v467 = 255;
LABEL_689:
                  result = PDAtranspose_luminosityPDA_13365(result, v465, v466, v467);
                  goto LABEL_690;
                }
                v467 = HIBYTE(v466);
                if (HIBYTE(v466))
                  goto LABEL_689;
                result = result & 0xFFFFFF | (v465 << 24);
LABEL_690:
                *v7 = result;
LABEL_691:
                v9 += v461;
                v468 = (unint64_t)&v14[v461];
                if (v468 >= v21)
                  v469 = v462;
                else
                  v469 = 0;
                v14 = (unsigned int *)(v468 + 4 * v469);
                v7 = (unsigned int *)((char *)v7 + v463);
                --v464;
              }
              while (v464);
              v9 += v515;
              v7 += v514;
              v470 = v517;
              v471 = &v517[v513];
              v472 = v508;
              if ((unint64_t)v471 < v511)
                v472 = 0;
              v473 = &v471[v472];
              v474 = v21 + 4 * v472 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                v21 = v474;
                v470 = v473;
                v14 = v473;
              }
              v40 = v518 == 1;
              v517 = v470;
              --v518;
              if (v40)
                return result;
            }
          case 31:
            v475 = v16;
            v476 = -(uint64_t)v18;
            v509 = -(v513 * v17);
            v477 = 4 * v16;
            break;
          default:
            return result;
        }
LABEL_704:
        v478 = v516;
        while (1)
        {
          v479 = *v9;
          if (*v9)
          {
            result = PDM_13345(*v14, *v9);
            v480 = result;
            if (!v19)
              break;
            v479 = BYTE3(result);
            if (BYTE3(result))
              break;
          }
LABEL_714:
          v9 += v475;
          v483 = (unint64_t)&v14[v475];
          if (v483 >= v21)
            v484 = v476;
          else
            v484 = 0;
          v14 = (unsigned int *)(v483 + 4 * v484);
          v7 = (unsigned int *)((char *)v7 + v477);
          if (!--v478)
          {
            v9 += v515;
            v7 += v514;
            v485 = v517;
            v486 = &v517[v513];
            v487 = v509;
            if ((unint64_t)v486 < v511)
              v487 = 0;
            v488 = &v486[v487];
            v489 = v21 + 4 * v487 + 4 * v513;
            if (v512)
            {
              v14 += v513;
            }
            else
            {
              v21 = v489;
              v485 = v488;
              v14 = v488;
            }
            v40 = v518 == 1;
            v517 = v485;
            --v518;
            if (v40)
              return result;
            goto LABEL_704;
          }
        }
        result = *v7;
        if (v519)
        {
          v481 = BYTE3(result);
          if (!BYTE3(result))
          {
            v482 = v480 & 0xFFFFFF | (v479 << 24);
LABEL_713:
            *v7 = v482;
            goto LABEL_714;
          }
        }
        else
        {
          v481 = 255;
        }
        result = PDAtranspose_luminosityPDA_13365(result, v481, v480, v479);
        v482 = result;
        goto LABEL_713;
      }
      v14 = 0;
      v21 = 0;
      v16 = 1;
LABEL_15:
      v511 = 0;
      v517 = 0;
      v513 = v13 - v3;
      v512 = 1;
      goto LABEL_16;
    }
    v13 = v12 >> 2;
    v14 = (unsigned int *)(v4 + 4 * (v10 + v13 * v11));
    if (v13 != v6)
    {
      v16 = 1;
LABEL_14:
      v17 = 0;
      v3 = v16 * v516;
      v19 = v5 != 0;
      v514 = v6 - v3;
      v515 = v8 - v3;
      v21 = -1;
      v18 = v13;
      goto LABEL_15;
    }
    if ((char *)v7 - (char *)v14 >= 1)
    {
      if (v516 >= (uint64_t)((unint64_t)((char *)v7 - (char *)v14) >> 2))
      {
        v7 += v516 - 1;
        v14 += v516 - 1;
        v9 += v516 - 1;
        v16 = -1;
        goto LABEL_13;
      }
      v15 = *(int *)(result + 8) - 1;
      if (v7 <= &v14[v6 * v15 - 1 + v516])
      {
        v7 += v6 * v15;
        v13 = -(uint64_t)v6;
        v9 += v8 * v15;
        v8 = -v8;
        v16 = 1;
        v14 += v6 * v15;
        v6 = -(uint64_t)v6;
        goto LABEL_14;
      }
    }
    v16 = 1;
LABEL_13:
    v13 = (unint64_t)*(int *)(result + 28) >> 2;
    goto LABEL_14;
  }
  return result;
}

void argb32_mark_constdeep(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  long double v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;
  int32x2_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int32x2_t v32;
  unsigned int v33;
  int8x8_t v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  __int8 *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  uint32x2_t v43;
  uint32x2_t v44;
  unsigned __int32 v45;
  unint64_t v46;
  unint64_t v47;
  int v48;
  int v49;
  long double v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  int v58;
  unsigned int *v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  unsigned int v70;
  BOOL v71;
  int v72;
  int v73;
  uint64_t mask_table;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  unsigned int v87;
  unint64_t v88;
  unint64_t v89;
  int v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  uint64_t v98;
  int v99;
  int v100;
  int v101;
  uint64_t v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  int v113;
  signed int v114;
  int v115;
  signed int v116;
  int v117;
  unsigned int v118;
  int v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  int v133;
  int32x2_t v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  int32x2_t v138;
  unsigned int v139;
  int8x8_t v140;
  unsigned int v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  int v145;
  __int8 *v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  uint32x2_t v150;
  uint32x2_t v151;
  unsigned __int32 v152;
  unint64_t v153;
  unint64_t v154;
  int v155;
  uint64_t v156;
  uint64_t v157;

  v9 = *(unsigned int **)(a2 + 88);
  if (v9)
    v10 = *v9;
  else
    v10 = -16777216;
  v157 = *(int *)(a2 + 28);
  v11 = *(_QWORD *)(a2 + 40) + (int)v157 * (uint64_t)*(int *)(a2 + 16) + 4 * *(int *)(a2 + 12);
  v156 = *(int *)(a2 + 124);
  v12 = *(_QWORD *)(a2 + 136) + (int)v156 * (uint64_t)*(int *)(a2 + 108) + 2 * *(int *)(a2 + 104);
  if (*(_QWORD *)(a2 + 48))
  {
    v13 = *(_QWORD *)(a2 + 152);
    v14 = *(double *)(a2 + 144);
    if (v13 && v14 == 2.0)
    {
      v15 = PIXELCONSTANT_13369(*(float **)(a1 + 64), *(_DWORD *)v13, *(float **)(v13 + 8), *(float *)(v13 + 16));
      v16 = *(_DWORD *)(a2 + 4);
      v17 = *(_DWORD *)(a2 + 8);
      v155 = v17;
      if (HIBYTE(v10) == 255)
      {
        if (v17 >= 1)
        {
          v18 = 0;
          v19 = (BYTE2(v10) * BYTE2(v10) + 128 + ((BYTE2(v10) * BYTE2(v10) + 128) >> 8)) >> 8;
          v20 = (BYTE1(v10) * BYTE1(v10) + 128 + ((BYTE1(v10) * BYTE1(v10) + 128) >> 8)) >> 8;
          v21 = (v10 * v10
               + 128
               + ((v10 * v10 + 128) >> 8)) >> 8;
          do
          {
            if (v16 >= 1)
            {
              v22 = 0;
              do
              {
                v23 = *(unsigned __int16 *)(v12 + 2 * v22);
                if (*(_WORD *)(v12 + 2 * v22))
                {
                  v24 = *(unsigned int *)(v11 + 4 * v22);
                  v25 = ((v15 | ((unint64_t)v15 << 24)) & 0xFF00FF00FF00FFLL)
                      * (~(_DWORD)v24 >> 24)
                      + 0x80008000800080;
                  v26 = ((((v25 >> 8) & 0xFF00FF00FF00FFLL) + v25) >> 8) & 0xFF00FF00FF00FFLL;
                  v27 = v24 + ((v26 >> 24) | v26);
                  v28 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v27), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                  v29 = (v24 + (BYTE3(v26) | v26));
                  v30 = HIBYTE(v27);
                  v31 = v29;
                  v32 = v28;
                  if (v30 - 1 <= 0xFD)
                  {
                    v32 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(v28, vdup_n_s32(v33)), 8uLL);
                    v31 = (v29 * v33) >> 8;
                  }
                  v34 = (int8x8_t)vmul_s32(v32, v32);
                  v38 = (int)((256 - ((v36 * v36) >> 8)) * v30 - ((v36 * v36) >> 8) + ((v36 * v36) >> 8 << 8)) >> 8;
                                                                         + (256 - v35)
                                                                         * ((v34.i32[0]
                                                                           + 128
                                                                           + ((v34.i32[0] + 128) >> 8)) >> 8)) >> 8];
                  v40 = v38
                                                              + (256 - v37)
                                                              * ((v31 * v31 + 128 + ((v31 * v31 + 128) >> 8)) >> 8)) >> 8]
                      + 128;
                  v41 = (v40 + (v40 >> 8)) >> 8;
                  if (v35 <= v36)
                    v35 = v36;
                  if (v35 > v37)
                    v37 = v35;
                  v42 = 256 - v37;
                  v34.i8[0] = *v39;
                                                                    + (256 - v36)
                                                                    * ((v34.i32[1]
                                                                      + 128
                                                                      + ((v34.i32[1] + 128) >> 8)) >> 8)) >> 8];
                  v43 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, vdup_n_s32(v38), (int32x2_t)vand_s8(v34, (int8x8_t)0xFF000000FFLL));
                  v44 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vshr_n_u32(vsra_n_u32(v43, v43, 8uLL), 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v42), v28), 8uLL)), 0), (uint32x2_t)0x800000010);
                  v45 = (v41 - ((int)(v42 * v29) >> 8)) & ~((int)(v41 - ((int)(v42 * v29) >> 8)) >> 31) | (((v38 - ((int)(v42 * v30) >> 8)) & ~((int)(v38 - ((int)(v42 * v30) >> 8)) >> 31)) << 24) | v44.i32[0] | v44.i32[1];
                  v46 = ((v24 | (v24 << 24)) & 0xFF00FF00FF00FFLL) * (~v45 >> 24) + 0x80008000800080;
                  v47 = ((((v46 >> 8) & 0xFF00FF00FF00FFLL) + v46) >> 8) & 0xFF00FF00FF00FFLL;
                  *(_DWORD *)(v11 + 4 * v22) = v45 + ((v47 >> 24) | v47);
                }
                ++v22;
              }
              while (v16 != (_DWORD)v22);
            }
            v11 += v157;
            v12 += v156;
            ++v18;
          }
          while (v18 != v17);
        }
      }
      else if (v17 >= 1)
      {
        v119 = 0;
        v120 = (v15 | ((unint64_t)v15 << 24)) & 0xFF00FF00FF00FFLL;
        do
        {
          if (v16 >= 1)
          {
            v121 = 0;
            do
            {
              v122 = *(unsigned __int16 *)(v12 + 2 * v121);
              if (*(_WORD *)(v12 + 2 * v121))
              {
                v123 = *(unsigned int *)(v11 + 4 * v121);
                v124 = v120 * (~(_DWORD)v123 >> 24) + 0x80008000800080;
                v125 = ((((v124 >> 8) & 0xFF00FF00FF00FFLL) + v124) >> 8) & 0xFF00FF00FF00FFLL;
                v126 = v123 + ((v125 >> 24) | v125);
                v127 = ((v126 | (v126 << 24)) & 0xFF00FF00FF00FFLL) * (~v10 >> 24) + 0x80008000800080;
                v128 = ((((v127 >> 8) & 0xFF00FF00FF00FFLL) + v127) >> 8) & 0xFF00FF00FF00FFLL;
                LODWORD(v128) = v10 + ((v128 >> 24) | v128);
                v129 = BYTE2(v128);
                v130 = BYTE1(v128);
                v131 = v128;
                v132 = BYTE3(v128);
                if (v132 - 1 <= 0xFD)
                {
                  v129 = (v129 * v133) >> 8;
                  v130 = (v130 * v133) >> 8;
                  v131 = (v131 * v133) >> 8;
                }
                v134 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v126), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                v135 = v126;
                v136 = BYTE3(v126);
                v137 = v135;
                v138 = v134;
                if (v136 - 1 <= 0xFD)
                {
                  v138 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(v134, vdup_n_s32(v139)), 8uLL);
                  v137 = (v135 * v139) >> 8;
                }
                v140 = (int8x8_t)vmul_s32(v138, v138);
                v144 = (int)(((v142 * v142) >> 8) * v132 + (256 - ((v142 * v142) >> 8)) * v136) >> 8;
                                                             * v143
                                                             + (256 - v143)
                                                             * ((v137 * v137 + 128 + ((v137 * v137 + 128) >> 8)) >> 8)) >> 8];
                                                                          + 128
                                                                          + ((v130 * v130 + 128) >> 8)) >> 8)
                                                                        * v142
                                                                        + (256 - v142)
                                                                        * ((v140.i32[1]
                                                                          + 128
                                                                          + ((v140.i32[1] + 128) >> 8)) >> 8)) >> 8];
                v147 = (v144 * v145 + 128 + ((v144 * v145 + 128) >> 8)) >> 8;
                if (v141 <= v142)
                  v148 = v142;
                else
                  v148 = v141;
                if (v148 > v143)
                  v143 = v148;
                v149 = 256 - v143;
                                                                   * v141
                                                                   + (256 - v141)
                                                                   * ((v140.i32[0]
                                                                     + 128
                                                                     + ((v140.i32[0] + 128) >> 8)) >> 8)) >> 8];
                v140.i8[4] = *v146;
                v150 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, vdup_n_s32(v144), (int32x2_t)vand_s8(v140, (int8x8_t)0xFF000000FFLL));
                v151 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vshr_n_u32(vsra_n_u32(v150, v150, 8uLL), 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v149), v134), 8uLL)), 0), (uint32x2_t)0x800000010);
                v152 = (v147 - ((int)(v149 * v135) >> 8)) & ~((int)(v147 - ((int)(v149 * v135) >> 8)) >> 31) | (((v144 - ((int)(v149 * v136) >> 8)) & ~((int)(v144 - ((int)(v149 * v136) >> 8)) >> 31)) << 24) | v151.i32[0] | v151.i32[1];
                v153 = ((v123 | (v123 << 24)) & 0xFF00FF00FF00FFLL) * (~v152 >> 24) + 0x80008000800080;
                v154 = ((((v153 >> 8) & 0xFF00FF00FF00FFLL) + v153) >> 8) & 0xFF00FF00FF00FFLL;
                *(_DWORD *)(v11 + 4 * v121) = v152 + ((v154 >> 24) | v154);
              }
              ++v121;
            }
            while (v16 != (_DWORD)v121);
          }
          v11 += v157;
          v12 += v156;
          ++v119;
        }
        while (v119 != v155);
      }
      return;
    }
    v72 = *(_DWORD *)(a2 + 4);
    v73 = *(_DWORD *)(a2 + 8);
    mask_table = get_mask_table(a1, a2, a3, a4, a5, a6, a7, a8);
    v75 = mask_table;
    v76 = HIBYTE(v10);
    v77 = BYTE2(v10);
    v78 = v10;
    v79 = BYTE1(v10);
    if ((_DWORD)v76)
    {
      v80 = *(unsigned __int16 *)(mask_table + 2 * v76 + 512);
      v77 = (BYTE2(v10) * v80 + 128) >> 8;
      v79 = (BYTE1(v10) * v80 + 128) >> 8;
      v78 = (v10 * v80 + 128) >> 8;
    }
    v81 = *(unsigned __int16 *)(mask_table + 2 * v76);
    v59 = (unsigned int *)gamma_table_create(v14);
    if (v73 < 1)
      goto LABEL_96;
    v82 = 0;
    v83 = *((unsigned __int16 *)v59 + v77 + 8);
    v84 = *((unsigned __int16 *)v59 + v79 + 8);
    v85 = *((unsigned __int16 *)v59 + v78 + 8);
    do
    {
      if (v72 >= 1)
      {
        v86 = 0;
        do
        {
          v87 = *(unsigned __int16 *)(v12 + 2 * v86);
          if (*(_WORD *)(v12 + 2 * v86))
          {
            v88 = *(unsigned int *)(v11 + 4 * v86);
            v89 = v88 >> 24;
            v90 = BYTE2(v88);
            v91 = BYTE1(v88);
            v92 = *(_DWORD *)(v11 + 4 * v86);
            if (HIBYTE(*(_DWORD *)(v11 + 4 * v86)))
            {
              v96 = *(unsigned __int16 *)(v75 + 2 * v89 + 512);
              v93 = (BYTE2(v88) * v96 + 128) >> 8;
              v94 = (v91 * v96 + 128) >> 8;
              v95 = (v92 * v96 + 128) >> 8;
            }
            else
            {
              v93 = BYTE2(v88);
              v94 = v91;
              v95 = *(_DWORD *)(v11 + 4 * v86);
            }
            v97 = (v87 >> 2) & 0xF8;
            v98 = *(unsigned __int16 *)(v75 + 2 * (((v97 + 16) * v97) >> 8));
            v99 = *(unsigned __int16 *)(v75 + 2 * ((v87 >> 7) & 0xF8 | (((v87 >> 7) & 0xF8) >> 5)));
            v100 = *(unsigned __int16 *)(v75 + 2 * (v97 | (v97 >> 5)));
            v101 = *(unsigned __int16 *)(v75 + 2 * ((8 * (v87 & 0x1F)) | ((8 * (v87 & 0x1F)) >> 5)));
            v102 = *(unsigned __int16 *)(v75 + 2 * v89);
            if (v93 >= 0x400)
              v103 = 1024;
            else
              v103 = v93;
            if (v94 >= 0x400)
              v104 = 1024;
            else
              v104 = v94;
            if (v95 >= 0x400)
              v105 = 1024;
            else
              v105 = v95;
            v106 = *((unsigned __int16 *)v59 + v103 + 8);
            v107 = *((unsigned __int16 *)v59 + v104 + 8) * (_DWORD)v102 + 512;
            v108 = *((unsigned __int16 *)v59 + v105 + 8) * (_DWORD)v102 + 512;
            v109 = v98 - ((v102 * v98 + 512) >> 10) + v102;
            v110 = ((int)((v83 - ((v106 * v102 + 512) >> 10)) * v99 + 512) >> 10)
                 + ((v106 * v102 + 512) >> 10);
            v111 = ((int)((v84 - (v107 >> 10)) * v100 + 512) >> 10) + (v107 >> 10);
            v112 = ((int)((v85 - (v108 >> 10)) * v101 + 512) >> 10) + (v108 >> 10);
            if ((int)v109 >= 1)
            {
              v113 = *(unsigned __int16 *)(v75 + 2 * v109 + 1024);
              v110 = (v110 * v113 + 512) >> 10;
              v111 = (v111 * v113 + 512) >> 10;
              v112 = (v112 * v113 + 512) >> 10;
            }
            if (v110 >= 1024)
              v110 = 1024;
            if (v111 >= 1024)
              v111 = 1024;
            if (v112 >= 1024)
              v112 = 1024;
            v114 = v89 + (((*(unsigned __int8 *)(v75 + 3074 + v109) - (int)v89) * v81 + 512) >> 10);
            v115 = v90
                 + (((*(unsigned __int8 *)(v75
                                         + 3074
                                         + ((int)(v109 * *((unsigned __int16 *)v59 + v110 + 1033) + 512) >> 10))
                    - v90)
                   * v81
                   + 512) >> 10);
            v116 = v91
                 + ((int)((*(unsigned __int8 *)(v75
                                              + 3074
                                              + ((int)(v109 * *((unsigned __int16 *)v59 + v111 + 1033) + 512) >> 10))
                         - v91)
                        * v81
                        + 512) >> 10);
            v117 = v92
                 + (((*(unsigned __int8 *)(v75
                                         + 3074
                                         + ((int)(v109 * *((unsigned __int16 *)v59 + v112 + 1033) + 512) >> 10))
                    - v92)
                   * v81
                   + 512) >> 10);
            if (v114 < v115)
              v115 = v114;
            if (v114 < v116)
              v116 = v114;
            if (v114 < v117)
              v117 = v114;
            *(_DWORD *)(v11 + 4 * v86) = (v115 << 16) | (v114 << 24) | (v116 << 8) | v117;
          }
          ++v86;
        }
        while (v72 != (_DWORD)v86);
      }
      v12 += v156;
      v11 += v157;
      ++v82;
    }
    while (v82 != v73);
    if (v59)
    {
LABEL_96:
      do
      {
        v118 = __ldxr(v59);
        v71 = --v118 == 0;
      }
      while (__stxr(v118, v59));
      goto LABEL_74;
    }
  }
  else
  {
    v48 = *(_DWORD *)(a2 + 4);
    v49 = *(_DWORD *)(a2 + 8);
    v50 = *(double *)(a2 + 144);
    v51 = get_mask_table(a1, a2, a3, a4, a5, a6, a7, a8);
    v52 = v51;
    v53 = HIBYTE(v10);
    v54 = BYTE2(v10);
    v55 = v10;
    v56 = BYTE1(v10);
    if ((_DWORD)v53)
    {
      v57 = *(unsigned __int16 *)(v51 + 2 * v53 + 512);
      v54 = (BYTE2(v10) * v57 + 128) >> 8;
      v56 = (BYTE1(v10) * v57 + 128) >> 8;
      v55 = (v10 * v57 + 128) >> 8;
    }
    v58 = *(unsigned __int16 *)(v51 + 2 * v53);
    v59 = (unsigned int *)gamma_table_create(v50);
    if (v49 < 1)
      goto LABEL_97;
    v60 = 0;
    v61 = *((unsigned __int16 *)v59 + v54 + 8);
    v62 = *((unsigned __int16 *)v59 + v56 + 8);
    v63 = *((unsigned __int16 *)v59 + v55 + 8);
    do
    {
      if (v48 >= 1)
      {
        v64 = 0;
        do
        {
          if (*(_WORD *)(v12 + 2 * v64))
          {
            v66 = *(_DWORD *)(v11 + 4 * v64);
            v67 = *((unsigned __int16 *)v59 + *(unsigned __int16 *)(v52 + 2 * BYTE2(v66)) + 8);
            v68 = *((unsigned __int16 *)v59 + *(unsigned __int16 *)(v52 + 2 * BYTE1(v66)) + 8);
            v69 = *((unsigned __int16 *)v59 + *(unsigned __int16 *)(v52 + 2 * v66) + 8);
            v65 = *(unsigned __int16 *)(v12 + 2 * v64);
            *(_DWORD *)(v11 + 4 * v64) = ((BYTE2(v66)
                                         + (((*(unsigned __int8 *)(v52
                                                                 + 3074
                                                                 + *((unsigned __int16 *)v59
                                                                   + v67
                                                                   + (((v61 - v67)
                                                                     * *(unsigned __int16 *)(v52
                                                                                           + 2
                                                                                           * ((v65 >> 7) & 0xF8 | (((v65 >> 7) & 0xF8) >> 5)))
                                                                     + 512) >> 10)
                                                                   + 1033))
                                            - BYTE2(v66))
                                           * v58
                                           + 512) >> 10)) << 16) | ((BYTE1(v66)
                                                                   + (((*(unsigned __int8 *)(v52
                                                                                           + 3074
                                                                                           + *((unsigned __int16 *)v59
                                                                                             + v68
                                                                                             + (((v62 - v68)
                                                                                               * *(unsigned __int16 *)(v52 + 2 * ((v65 >> 2) & 0xF8 | (((v65 >> 2) & 0xF8) >> 5)))
                                                                                               + 512) >> 10)
                                                                                             + 1033))
                                                                      - BYTE1(v66))
                                                                     * v58
                                                                     + 512) >> 10)) << 8) | (v66
                                                                                           + (((*(unsigned __int8 *)(v52 + 3074 + *((unsigned __int16 *)v59 + v69 + (((v63 - v69) * *(unsigned __int16 *)(v52 + 2 * ((8 * (v65 & 0x1F)) | ((8 * (v65 & 0x1F)) >> 5))) + 512) >> 10) + 1033))
                                                                                              - v66)
                                                                                             * v58
                                                                                             + 512) >> 10)) | 0xFF000000;
          }
          ++v64;
        }
        while (v48 != (_DWORD)v64);
      }
      v12 += v156;
      v11 += v157;
      ++v60;
    }
    while (v60 != v49);
    if (v59)
    {
LABEL_97:
      do
      {
        v70 = __ldxr(v59);
        v71 = --v70 == 0;
      }
      while (__stxr(v70, v59));
LABEL_74:
      if (v71)
        free(v59);
    }
  }
}

void argb32_mark_pixeldeep(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  int v15;
  unsigned int v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int32x2_t v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  int32x2_t v39;
  unsigned int v40;
  int8x8_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  unsigned __int8 *v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  uint32x2_t v51;
  uint32x2_t v52;
  unsigned __int32 v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t mask_table;
  unsigned int *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  unsigned int v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  unsigned int *v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  signed int v100;
  int v101;
  signed int v102;
  int v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;

  v131 = *(int *)(a2 + 28);
  v127 = *(_QWORD *)(a2 + 40);
  v8 = v127 + (int)v131 * (uint64_t)*(int *)(a2 + 16) + 4 * *(int *)(a2 + 12);
  v130 = *(int *)(a2 + 124);
  v9 = *(_QWORD *)(a2 + 136) + (int)v130 * (uint64_t)*(int *)(a2 + 108) + 2 * *(int *)(a2 + 104);
  v10 = *(int *)(a2 + 64);
  v11 = *(int *)(a2 + 56);
  if (*(unsigned __int8 *)(a2 + 1) << 8 == 512)
  {
    v11 %= v10;
    v12 = *(int *)(a2 + 60) % (uint64_t)*(int *)(a2 + 68);
  }
  else
  {
    v12 = *(int *)(a2 + 60);
  }
  v13 = *(_QWORD *)(a2 + 152);
  v14 = *(double *)(a2 + 144);
  v129 = *(int *)(a2 + 68);
  v120 = v11;
  v132 = v12;
  if (v13 && v14 == 2.0 && (v14 = 2.0, *(_QWORD *)(a2 + 48)))
  {
    v125 = *(_DWORD *)(a2 + 8);
    if (v125 >= 1)
    {
      v121 = *(_DWORD *)(a2 + 76);
      v123 = *(_QWORD *)(a2 + 88);
      v15 = *(_DWORD *)(a2 + 4);
      v16 = PIXELCONSTANT_13369(*(float **)(a1 + 64), *(_DWORD *)v13, *(float **)(v13 + 8), *(float *)(v13 + 16));
      v17 = 0;
      v18 = (v16 | ((unint64_t)v16 << 24)) & 0xFF00FF00FF00FFLL;
      do
      {
        v128 = v17;
        if (v15 >= 1)
        {
          v19 = 0;
          v20 = v120;
          do
          {
            v21 = *(unsigned __int16 *)(v9 + 2 * v19);
            if (*(_WORD *)(v9 + 2 * v19))
            {
              v22 = *(_DWORD *)(v123 + v121 * (uint64_t)(int)v132 + 4 * v20);
              v23 = *(unsigned int *)(v8 + 4 * v19);
              v24 = v18 * (~(_DWORD)v23 >> 24) + 0x80008000800080;
              v25 = ((((v24 >> 8) & 0xFF00FF00FF00FFLL) + v24) >> 8) & 0xFF00FF00FF00FFLL;
              v26 = v23 + ((v25 >> 24) | v25);
              v27 = ((v26 | (v26 << 24)) & 0xFF00FF00FF00FFLL) * (~v22 >> 24) + 0x80008000800080;
              v28 = ((((v27 >> 8) & 0xFF00FF00FF00FFLL) + v27) >> 8) & 0xFF00FF00FF00FFLL;
              v29 = v22 + ((v28 >> 24) | v28);
              v30 = BYTE2(v29);
              v31 = BYTE1(v29);
              v32 = v29;
              v33 = HIBYTE(v29);
              if (v33 - 1 <= 0xFD)
              {
                v30 = (v30 * v34) >> 8;
                v31 = (v31 * v34) >> 8;
                v32 = (v32 * v34) >> 8;
              }
              v35 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v26), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
              v36 = v26;
              v37 = BYTE3(v26);
              v38 = v36;
              v39 = v35;
              if (v37 - 1 <= 0xFD)
              {
                v39 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(v35, vdup_n_s32(v40)), 8uLL);
                v38 = (v36 * v40) >> 8;
              }
              v41 = (int8x8_t)vmul_s32(v39, v39);
              v45 = (int)(((v43 * v43) >> 8) * v33 + (256 - ((v43 * v43) >> 8)) * v37) >> 8;
                                                          + (256 - v44)
                                                          * ((v38 * v38 + 128 + ((v38 * v38 + 128) >> 8)) >> 8)) >> 8];
                                                           + (256 - v43)
                                                           * ((v41.i32[1] + 128 + ((v41.i32[1] + 128) >> 8)) >> 8)) >> 8];
              v48 = (v45 * v46 + 128 + ((v45 * v46 + 128) >> 8)) >> 8;
              if (v42 <= v43)
                v49 = v43;
              else
                v49 = v42;
              if (v49 > v44)
                v44 = v49;
              v50 = 256 - v44;
                                                                * v42
                                                                + (256 - v42)
                                                                * ((v41.i32[0]
                                                                  + 128
                                                                  + ((v41.i32[0] + 128) >> 8)) >> 8)) >> 8];
              v41.i8[4] = *v47;
              v51 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, vdup_n_s32(v45), (int32x2_t)vand_s8(v41, (int8x8_t)0xFF000000FFLL));
              v52 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vshr_n_u32(vsra_n_u32(v51, v51, 8uLL), 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v50), v35), 8uLL)), 0), (uint32x2_t)0x800000010);
              v53 = (v48 - ((int)(v50 * v36) >> 8)) & ~((int)(v48 - ((int)(v50 * v36) >> 8)) >> 31) | (((v45 - ((int)(v50 * v37) >> 8)) & ~((int)(v45 - ((int)(v50 * v37) >> 8)) >> 31)) << 24) | v52.i32[0] | v52.i32[1];
              v54 = ((v23 | (v23 << 24)) & 0xFF00FF00FF00FFLL) * (~v53 >> 24) + 0x80008000800080;
              v55 = ((((v54 >> 8) & 0xFF00FF00FF00FFLL) + v54) >> 8) & 0xFF00FF00FF00FFLL;
              *(_DWORD *)(v8 + 4 * v19) = v53 + ((v55 >> 24) | v55);
            }
            if (v20 + 1 < (int)v10)
              ++v20;
            else
              v20 = 0;
            ++v19;
          }
          while (v15 != (_DWORD)v19);
        }
        v8 += v131;
        v9 += v130;
        if ((int)v132 + 1 < (int)v129)
          v56 = v132 + 1;
        else
          v56 = 0;
        LODWORD(v132) = v56;
        v17 = v128 + 1;
      }
      while (v128 + 1 != v125);
    }
  }
  else
  {
    v124 = *(int *)(a2 + 76);
    v126 = *(_QWORD *)(a2 + 88);
    v58 = *(int *)(a2 + 4);
    v57 = *(int *)(a2 + 8);
    mask_table = get_mask_table(a1, a2, a3, a4, a5, a6, a7, a8);
    v60 = (unsigned int *)gamma_table_create(v14);
    v122 = v57;
    v61 = v132;
    if ((int)v57 >= 1)
    {
      v62 = 0;
      do
      {
        v133 = v61;
        v63 = v126 + v61 * v124;
        if (v127)
        {
          if ((int)v58 >= 1)
          {
            v64 = 0;
            v65 = v120;
            do
            {
              v66 = *(unsigned __int16 *)(v9 + 2 * v64);
              if (*(_WORD *)(v9 + 2 * v64))
              {
                v67 = *(unsigned int *)(v63 + 4 * v65);
                if (v65 + 1 < v10)
                  ++v65;
                else
                  v65 = 0;
                v68 = v67 >> 24;
                v69 = BYTE2(v67);
                v70 = BYTE1(v67);
                v71 = v67;
                if (BYTE3(v67))
                {
                  v69 = (BYTE2(v67) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v68 + 512) + 128) >> 8;
                  v70 = (BYTE1(v67) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v68 + 512) + 128) >> 8;
                  v71 = (v67 * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v68 + 512) + 128) >> 8;
                }
                v72 = *(unsigned int *)(v8 + 4 * v64);
                v73 = v72 >> 24;
                v74 = BYTE2(v72);
                v75 = BYTE1(v72);
                v76 = *(_DWORD *)(v8 + 4 * v64);
                if (HIBYTE(*(_DWORD *)(v8 + 4 * v64)))
                {
                  v80 = *(unsigned __int16 *)(mask_table + 2 * v73 + 512);
                  v77 = (BYTE2(v72) * v80 + 128) >> 8;
                  v78 = (v75 * v80 + 128) >> 8;
                  v79 = (v76 * v80 + 128) >> 8;
                }
                else
                {
                  v77 = BYTE2(v72);
                  v78 = v75;
                  v79 = *(_DWORD *)(v8 + 4 * v64);
                }
                v81 = (v66 >> 2) & 0xF8;
                v82 = *(unsigned __int16 *)(mask_table + 2 * (((v81 + 16) * v81) >> 8));
                v83 = *(unsigned __int16 *)(mask_table + 2 * ((v66 >> 7) & 0xF8 | (((v66 >> 7) & 0xF8) >> 5)));
                v84 = *(unsigned __int16 *)(mask_table + 2 * (v81 | (v81 >> 5)));
                v85 = *(unsigned __int16 *)(mask_table + 2 * ((8 * (v66 & 0x1F)) | ((8 * (v66 & 0x1F)) >> 5)));
                v86 = v60 + 4;
                v87 = *((unsigned __int16 *)v60 + v69 + 8);
                v88 = *((unsigned __int16 *)v60 + v70 + 8);
                v89 = *((unsigned __int16 *)v60 + v71 + 8);
                v90 = *(unsigned __int16 *)(mask_table + 2 * v73);
                if (v77 >= 0x400)
                  v77 = 1024;
                if (v78 >= 0x400)
                  v78 = 1024;
                if (v79 >= 0x400)
                  v79 = 1024;
                v91 = *((unsigned __int16 *)v86 + v77) * (_DWORD)v90 + 512;
                v92 = *((unsigned __int16 *)v86 + v78) * (_DWORD)v90 + 512;
                v93 = *((unsigned __int16 *)v86 + v79) * (_DWORD)v90 + 512;
                v94 = v82 - ((v90 * v82 + 512) >> 10) + v90;
                v95 = ((int)((v87 - (v91 >> 10)) * v83 + 512) >> 10) + (v91 >> 10);
                v96 = ((int)((v88 - (v92 >> 10)) * v84 + 512) >> 10) + (v92 >> 10);
                v97 = ((int)((v89 - (v93 >> 10)) * v85 + 512) >> 10) + (v93 >> 10);
                if ((int)v94 >= 1)
                {
                  v98 = *(unsigned __int16 *)(mask_table + 2 * v94 + 1024);
                  v95 = (v95 * v98 + 512) >> 10;
                  v96 = (v96 * v98 + 512) >> 10;
                  v97 = (v97 * v98 + 512) >> 10;
                }
                v99 = *(unsigned __int16 *)(mask_table + 2 * v68);
                if (v95 >= 1024)
                  v95 = 1024;
                if (v96 >= 1024)
                  v96 = 1024;
                if (v97 >= 1024)
                  v97 = 1024;
                v100 = v73 + (((*(unsigned __int8 *)(mask_table + 3074 + v94) - (int)v73) * v99 + 512) >> 10);
                v101 = v74
                     + (((*(unsigned __int8 *)(mask_table
                                             + 3074
                                             + ((int)(v94 * *((unsigned __int16 *)v60 + v95 + 1033) + 512) >> 10))
                        - v74)
                       * v99
                       + 512) >> 10);
                v102 = v75
                     + ((int)((*(unsigned __int8 *)(mask_table
                                                  + 3074
                                                  + ((int)(v94 * *((unsigned __int16 *)v60 + v96 + 1033) + 512) >> 10))
                             - v75)
                            * v99
                            + 512) >> 10);
                v103 = v76
                     + (((*(unsigned __int8 *)(mask_table
                                             + 3074
                                             + ((int)(v94 * *((unsigned __int16 *)v60 + v97 + 1033) + 512) >> 10))
                        - v76)
                       * v99
                       + 512) >> 10);
                if (v100 >= v101)
                  v104 = v101;
                else
                  v104 = v100;
                if (v100 < v102)
                  v102 = v100;
                if (v100 < v103)
                  v103 = v100;
                *(_DWORD *)(v8 + 4 * v64) = (v104 << 16) | (v100 << 24) | (v102 << 8) | v103;
              }
              else if (v65 + 1 < v10)
              {
                ++v65;
              }
              else
              {
                v65 = 0;
              }
              ++v64;
            }
            while (v58 != v64);
          }
        }
        else if ((int)v58 >= 1)
        {
          v105 = 0;
          v106 = v120;
          do
          {
            if (*(_WORD *)(v9 + 2 * v105))
            {
              v108 = *(unsigned int *)(v63 + 4 * v106);
              if (v106 + 1 < v10)
                ++v106;
              else
                v106 = 0;
              v109 = v108 >> 24;
              v110 = BYTE2(v108);
              v111 = BYTE1(v108);
              v112 = v108;
              if (BYTE3(v108))
              {
                v110 = (BYTE2(v108) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v109 + 512) + 128) >> 8;
                v111 = (BYTE1(v108) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v109 + 512) + 128) >> 8;
                v112 = (v108 * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v109 + 512)
                      + 128) >> 8;
              }
              v113 = *(unsigned __int16 *)(mask_table + 2 * v109);
              v114 = *(_DWORD *)(v8 + 4 * v105);
              v115 = *((unsigned __int16 *)v60 + *(unsigned __int16 *)(mask_table + 2 * BYTE2(v114)) + 8);
              v116 = *((unsigned __int16 *)v60 + *(unsigned __int16 *)(mask_table + 2 * BYTE1(v114)) + 8);
              v117 = *((unsigned __int16 *)v60 + *(unsigned __int16 *)(mask_table + 2 * v114) + 8);
              v107 = *(unsigned __int16 *)(v9 + 2 * v105);
              *(_DWORD *)(v8 + 4 * v105) = ((BYTE2(v114)
                                           + (((*(unsigned __int8 *)(mask_table
                                                                   + 3074
                                                                   + *((unsigned __int16 *)v60
                                                                     + v115
                                                                     + (((*((unsigned __int16 *)v60 + v110 + 8) - v115)
                                                                       * *(unsigned __int16 *)(mask_table
                                                                                             + 2
                                                                                             * ((v107 >> 7) & 0xF8 | (((v107 >> 7) & 0xF8) >> 5)))
                                                                       + 512) >> 10)
                                                                     + 1033))
                                              - BYTE2(v114))
                                             * v113
                                             + 512) >> 10)) << 16) | ((BYTE1(v114)
                                                                     + (((*(unsigned __int8 *)(mask_table
                                                                                             + 3074
                                                                                             + *((unsigned __int16 *)v60
                                                                                               + v116
                                                                                               + (((*((unsigned __int16 *)v60 + v111 + 8)
                                                                                                  - v116)
                                                                                                 * *(unsigned __int16 *)(mask_table + 2 * ((v107 >> 2) & 0xF8 | (((v107 >> 2) & 0xF8) >> 5)))
                                                                                                 + 512) >> 10)
                                                                                               + 1033))
                                                                        - BYTE1(v114))
                                                                       * v113
                                                                       + 512) >> 10)) << 8) | (v114
                                                                                             + (((*(unsigned __int8 *)(mask_table + 3074 + *((unsigned __int16 *)v60 + v117 + (((*((unsigned __int16 *)v60 + v112 + 8) - v117) * *(unsigned __int16 *)(mask_table + 2 * ((8 * (v107 & 0x1F)) | ((8 * (v107 & 0x1F)) >> 5))) + 512) >> 10) + 1033))
                                                                                                - v114)
                                                                                               * v113
                                                                                               + 512) >> 10)) | 0xFF000000;
            }
            else if (v106 + 1 < v10)
            {
              ++v106;
            }
            else
            {
              v106 = 0;
            }
            ++v105;
          }
          while (v58 != v105);
        }
        v9 += v130;
        if (v133 + 1 < v129)
          v61 = v133 + 1;
        else
          v61 = 0;
        v8 += v131;
        ++v62;
      }
      while (v62 != v122);
    }
    if (v60)
    {
      do
      {
        v118 = __ldxr(v60);
        v119 = v118 - 1;
      }
      while (__stxr(v119, v60));
      if (!v119)
        free(v60);
    }
  }
}

void argb32_mark_bits(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  size_t v9;
  _BYTE *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[7];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[4096];
  uint64_t v21;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v5 = v2;
  v21 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(v2 + 112);
  v7 = *(_DWORD *)(v2 + 116);
  v8 = (v6 + 15) & 0xFFFFFFF0;
  v9 = v8 * v7;
  if ((int)v9 <= 4096)
  {
    v10 = v20;
  }
  else
  {
    v10 = malloc_type_malloc(v9, 0x8303D2FuLL);
    if (!v10)
      return;
  }
  CGSConvertBitsToMask(*(uint16x4_t **)(v5 + 136), *(_DWORD *)(v5 + 124), v10, v8, v6, v7, *(_DWORD *)(v5 + 128));
  v11 = *(_OWORD *)(v5 + 112);
  v16[6] = *(_OWORD *)(v5 + 96);
  v17 = v11;
  v12 = *(_OWORD *)(v5 + 144);
  v18 = *(_OWORD *)(v5 + 128);
  v19 = v12;
  v13 = *(_OWORD *)(v5 + 48);
  v16[2] = *(_OWORD *)(v5 + 32);
  v16[3] = v13;
  v14 = *(_OWORD *)(v5 + 80);
  v16[4] = *(_OWORD *)(v5 + 64);
  v16[5] = v14;
  v15 = *(_OWORD *)(v5 + 16);
  v16[0] = *(_OWORD *)v5;
  v16[1] = v15;
  HIDWORD(v17) = (v6 + 15) & 0xFFFFFFF0;
  *((_QWORD *)&v18 + 1) = v10;
  if (BYTE1(v16[0]) << 8 == 1024)
    argb32_mark_constmask((uint64_t)v16, v4);
  else
    argb32_mark_pixelmask((unint64_t)v16, v4);
  if (v10 != v20)
    free(v10);
}

